// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_files.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "device_files.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace video_widevine_client
{
namespace sdk
{

void protobuf_ShutdownFile_device_5ffiles_2eproto()
{
    delete DeviceCertificate::default_instance_;
    delete License::default_instance_;
    delete UsageInfo::default_instance_;
    delete UsageInfo_ProviderSession::default_instance_;
    delete File::default_instance_;
    delete HashedFile::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_device_5ffiles_2eproto_impl()
{
    GOOGLE_PROTOBUF_VERIFY_VERSION;
#else
void protobuf_AddDesc_device_5ffiles_2eproto()
{
    static bool already_here = false;

    if (already_here) return;

    already_here = true;
    GOOGLE_PROTOBUF_VERIFY_VERSION;
#endif
    DeviceCertificate::default_instance_ = new DeviceCertificate();
    License::default_instance_ = new License();
    UsageInfo::default_instance_ = new UsageInfo();
    UsageInfo_ProviderSession::default_instance_ = new UsageInfo_ProviderSession();
    File::default_instance_ = new File();
    HashedFile::default_instance_ = new HashedFile();
    DeviceCertificate::default_instance_->InitAsDefaultInstance();
    License::default_instance_->InitAsDefaultInstance();
    UsageInfo::default_instance_->InitAsDefaultInstance();
    UsageInfo_ProviderSession::default_instance_->InitAsDefaultInstance();
    File::default_instance_->InitAsDefaultInstance();
    HashedFile::default_instance_->InitAsDefaultInstance();
    ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_device_5ffiles_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_device_5ffiles_2eproto_once_);
void protobuf_AddDesc_device_5ffiles_2eproto()
{
    ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_device_5ffiles_2eproto_once_,
            &protobuf_AddDesc_device_5ffiles_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_device_5ffiles_2eproto {
    StaticDescriptorInitializer_device_5ffiles_2eproto() {
        protobuf_AddDesc_device_5ffiles_2eproto();
    }
} static_descriptor_initializer_device_5ffiles_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int DeviceCertificate::kCertificateFieldNumber;
const int DeviceCertificate::kWrappedPrivateKeyFieldNumber;
#endif  // !_MSC_VER

DeviceCertificate::DeviceCertificate()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void DeviceCertificate::InitAsDefaultInstance()
{
}

DeviceCertificate::DeviceCertificate(const DeviceCertificate& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void DeviceCertificate::SharedCtor()
{
    _cached_size_ = 0;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    wrapped_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceCertificate::~DeviceCertificate()
{
    SharedDtor();
}

void DeviceCertificate::SharedDtor()
{
    if (certificate_ != &::google::protobuf::internal::kEmptyString) {
        delete certificate_;
    }

    if (wrapped_private_key_ != &::google::protobuf::internal::kEmptyString) {
        delete wrapped_private_key_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void DeviceCertificate::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceCertificate& DeviceCertificate::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

DeviceCertificate* DeviceCertificate::default_instance_ = NULL;

DeviceCertificate* DeviceCertificate::New() const
{
    return new DeviceCertificate;
}

void DeviceCertificate::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_certificate()) {
            if (certificate_ != &::google::protobuf::internal::kEmptyString) {
                certificate_->clear();
            }
        }

        if (has_wrapped_private_key()) {
            if (wrapped_private_key_ != &::google::protobuf::internal::kEmptyString) {
                wrapped_private_key_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceCertificate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes certificate = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_certificate()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_wrapped_private_key;

                break;
            }

            // optional bytes wrapped_private_key = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_wrapped_private_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_wrapped_private_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void DeviceCertificate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes certificate = 1;
    if (has_certificate()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->certificate(), output);
    }

    // optional bytes wrapped_private_key = 2;
    if (has_wrapped_private_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->wrapped_private_key(), output);
    }
}

int DeviceCertificate::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes certificate = 1;
        if (has_certificate()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->certificate());
        }

        // optional bytes wrapped_private_key = 2;
        if (has_wrapped_private_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->wrapped_private_key());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void DeviceCertificate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const DeviceCertificate*>(&from));
}

void DeviceCertificate::MergeFrom(const DeviceCertificate& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_certificate()) {
            set_certificate(from.certificate());
        }

        if (from.has_wrapped_private_key()) {
            set_wrapped_private_key(from.wrapped_private_key());
        }
    }
}

void DeviceCertificate::CopyFrom(const DeviceCertificate& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool DeviceCertificate::IsInitialized() const
{
    return true;
}

void DeviceCertificate::Swap(DeviceCertificate* other)
{
    if (other != this) {
        std::swap(certificate_, other->certificate_);
        std::swap(wrapped_private_key_, other->wrapped_private_key_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string DeviceCertificate::GetTypeName() const
{
    return "video_widevine_client.sdk.DeviceCertificate";
}


// ===================================================================

bool License_LicenseState_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const License_LicenseState License::ACTIVE;
const License_LicenseState License::RELEASING;
const License_LicenseState License::LicenseState_MIN;
const License_LicenseState License::LicenseState_MAX;
const int License::LicenseState_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int License::kStateFieldNumber;
const int License::kPsshDataFieldNumber;
const int License::kLicenseRequestFieldNumber;
const int License::kLicenseFieldNumber;
const int License::kRenewalRequestFieldNumber;
const int License::kRenewalFieldNumber;
const int License::kReleaseServerUrlFieldNumber;
#endif  // !_MSC_VER

License::License()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License::InitAsDefaultInstance()
{
}

License::License(const License& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License::SharedCtor()
{
    _cached_size_ = 0;
    state_ = 1;
    pssh_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    renewal_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    renewal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    release_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License::~License()
{
    SharedDtor();
}

void License::SharedDtor()
{
    if (pssh_data_ != &::google::protobuf::internal::kEmptyString) {
        delete pssh_data_;
    }

    if (license_request_ != &::google::protobuf::internal::kEmptyString) {
        delete license_request_;
    }

    if (license_ != &::google::protobuf::internal::kEmptyString) {
        delete license_;
    }

    if (renewal_request_ != &::google::protobuf::internal::kEmptyString) {
        delete renewal_request_;
    }

    if (renewal_ != &::google::protobuf::internal::kEmptyString) {
        delete renewal_;
    }

    if (release_server_url_ != &::google::protobuf::internal::kEmptyString) {
        delete release_server_url_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void License::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License& License::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

License* License::default_instance_ = NULL;

License* License::New() const
{
    return new License;
}

void License::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        state_ = 1;

        if (has_pssh_data()) {
            if (pssh_data_ != &::google::protobuf::internal::kEmptyString) {
                pssh_data_->clear();
            }
        }

        if (has_license_request()) {
            if (license_request_ != &::google::protobuf::internal::kEmptyString) {
                license_request_->clear();
            }
        }

        if (has_license()) {
            if (license_ != &::google::protobuf::internal::kEmptyString) {
                license_->clear();
            }
        }

        if (has_renewal_request()) {
            if (renewal_request_ != &::google::protobuf::internal::kEmptyString) {
                renewal_request_->clear();
            }
        }

        if (has_renewal()) {
            if (renewal_ != &::google::protobuf::internal::kEmptyString) {
                renewal_->clear();
            }
        }

        if (has_release_server_url()) {
            if (release_server_url_ != &::google::protobuf::internal::kEmptyString) {
                release_server_url_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_client.sdk.License.LicenseState state = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_client::sdk::License_LicenseState_IsValid(value)) {
                        set_state(static_cast< ::video_widevine_client::sdk::License_LicenseState >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_pssh_data;

                break;
            }

            // optional bytes pssh_data = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_pssh_data:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_pssh_data()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_license_request;

                break;
            }

            // optional bytes license_request = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license_request:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_license_request()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_license;

                break;
            }

            // optional bytes license = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_license()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_renewal_request;

                break;
            }

            // optional bytes renewal_request = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_renewal_request:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_renewal_request()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_renewal;

                break;
            }

            // optional bytes renewal = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_renewal:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_renewal()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(58)) goto parse_release_server_url;

                break;
            }

            // optional bytes release_server_url = 7;
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_release_server_url:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_release_server_url()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_client.sdk.License.LicenseState state = 1;
    if (has_state()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->state(), output);
    }

    // optional bytes pssh_data = 2;
    if (has_pssh_data()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->pssh_data(), output);
    }

    // optional bytes license_request = 3;
    if (has_license_request()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->license_request(), output);
    }

    // optional bytes license = 4;
    if (has_license()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->license(), output);
    }

    // optional bytes renewal_request = 5;
    if (has_renewal_request()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            5, this->renewal_request(), output);
    }

    // optional bytes renewal = 6;
    if (has_renewal()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            6, this->renewal(), output);
    }

    // optional bytes release_server_url = 7;
    if (has_release_server_url()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            7, this->release_server_url(), output);
    }
}

int License::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_client.sdk.License.LicenseState state = 1;
        if (has_state()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
        }

        // optional bytes pssh_data = 2;
        if (has_pssh_data()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->pssh_data());
        }

        // optional bytes license_request = 3;
        if (has_license_request()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->license_request());
        }

        // optional bytes license = 4;
        if (has_license()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->license());
        }

        // optional bytes renewal_request = 5;
        if (has_renewal_request()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->renewal_request());
        }

        // optional bytes renewal = 6;
        if (has_renewal()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->renewal());
        }

        // optional bytes release_server_url = 7;
        if (has_release_server_url()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->release_server_url());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License*>(&from));
}

void License::MergeFrom(const License& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_state()) {
            set_state(from.state());
        }

        if (from.has_pssh_data()) {
            set_pssh_data(from.pssh_data());
        }

        if (from.has_license_request()) {
            set_license_request(from.license_request());
        }

        if (from.has_license()) {
            set_license(from.license());
        }

        if (from.has_renewal_request()) {
            set_renewal_request(from.renewal_request());
        }

        if (from.has_renewal()) {
            set_renewal(from.renewal());
        }

        if (from.has_release_server_url()) {
            set_release_server_url(from.release_server_url());
        }
    }
}

void License::CopyFrom(const License& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License::IsInitialized() const
{
    return true;
}

void License::Swap(License* other)
{
    if (other != this) {
        std::swap(state_, other->state_);
        std::swap(pssh_data_, other->pssh_data_);
        std::swap(license_request_, other->license_request_);
        std::swap(license_, other->license_);
        std::swap(renewal_request_, other->renewal_request_);
        std::swap(renewal_, other->renewal_);
        std::swap(release_server_url_, other->release_server_url_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License::GetTypeName() const
{
    return "video_widevine_client.sdk.License";
}


// ===================================================================

#ifndef _MSC_VER
const int UsageInfo_ProviderSession::kTokenFieldNumber;
const int UsageInfo_ProviderSession::kLicenseRequestFieldNumber;
const int UsageInfo_ProviderSession::kLicenseFieldNumber;
#endif  // !_MSC_VER

UsageInfo_ProviderSession::UsageInfo_ProviderSession()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void UsageInfo_ProviderSession::InitAsDefaultInstance()
{
}

UsageInfo_ProviderSession::UsageInfo_ProviderSession(const UsageInfo_ProviderSession& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void UsageInfo_ProviderSession::SharedCtor()
{
    _cached_size_ = 0;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UsageInfo_ProviderSession::~UsageInfo_ProviderSession()
{
    SharedDtor();
}

void UsageInfo_ProviderSession::SharedDtor()
{
    if (token_ != &::google::protobuf::internal::kEmptyString) {
        delete token_;
    }

    if (license_request_ != &::google::protobuf::internal::kEmptyString) {
        delete license_request_;
    }

    if (license_ != &::google::protobuf::internal::kEmptyString) {
        delete license_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void UsageInfo_ProviderSession::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UsageInfo_ProviderSession& UsageInfo_ProviderSession::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

UsageInfo_ProviderSession* UsageInfo_ProviderSession::default_instance_ = NULL;

UsageInfo_ProviderSession* UsageInfo_ProviderSession::New() const
{
    return new UsageInfo_ProviderSession;
}

void UsageInfo_ProviderSession::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_token()) {
            if (token_ != &::google::protobuf::internal::kEmptyString) {
                token_->clear();
            }
        }

        if (has_license_request()) {
            if (license_request_ != &::google::protobuf::internal::kEmptyString) {
                license_request_->clear();
            }
        }

        if (has_license()) {
            if (license_ != &::google::protobuf::internal::kEmptyString) {
                license_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UsageInfo_ProviderSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes token = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_license_request;

                break;
            }

            // optional bytes license_request = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license_request:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_license_request()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_license;

                break;
            }

            // optional bytes license = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_license()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void UsageInfo_ProviderSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes token = 1;
    if (has_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->token(), output);
    }

    // optional bytes license_request = 2;
    if (has_license_request()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->license_request(), output);
    }

    // optional bytes license = 3;
    if (has_license()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->license(), output);
    }
}

int UsageInfo_ProviderSession::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes token = 1;
        if (has_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->token());
        }

        // optional bytes license_request = 2;
        if (has_license_request()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->license_request());
        }

        // optional bytes license = 3;
        if (has_license()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->license());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void UsageInfo_ProviderSession::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const UsageInfo_ProviderSession*>(&from));
}

void UsageInfo_ProviderSession::MergeFrom(const UsageInfo_ProviderSession& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_token()) {
            set_token(from.token());
        }

        if (from.has_license_request()) {
            set_license_request(from.license_request());
        }

        if (from.has_license()) {
            set_license(from.license());
        }
    }
}

void UsageInfo_ProviderSession::CopyFrom(const UsageInfo_ProviderSession& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool UsageInfo_ProviderSession::IsInitialized() const
{
    return true;
}

void UsageInfo_ProviderSession::Swap(UsageInfo_ProviderSession* other)
{
    if (other != this) {
        std::swap(token_, other->token_);
        std::swap(license_request_, other->license_request_);
        std::swap(license_, other->license_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string UsageInfo_ProviderSession::GetTypeName() const
{
    return "video_widevine_client.sdk.UsageInfo.ProviderSession";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UsageInfo::kSessionsFieldNumber;
#endif  // !_MSC_VER

UsageInfo::UsageInfo()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void UsageInfo::InitAsDefaultInstance()
{
}

UsageInfo::UsageInfo(const UsageInfo& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void UsageInfo::SharedCtor()
{
    _cached_size_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UsageInfo::~UsageInfo()
{
    SharedDtor();
}

void UsageInfo::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void UsageInfo::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UsageInfo& UsageInfo::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

UsageInfo* UsageInfo::default_instance_ = NULL;

UsageInfo* UsageInfo::New() const
{
    return new UsageInfo;
}

void UsageInfo::Clear()
{
    sessions_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UsageInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // repeated .video_widevine_client.sdk.UsageInfo.ProviderSession sessions = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_sessions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, add_sessions()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(10)) goto parse_sessions;

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void UsageInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // repeated .video_widevine_client.sdk.UsageInfo.ProviderSession sessions = 1;
    for (int i = 0; i < this->sessions_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->sessions(i), output);
    }
}

int UsageInfo::ByteSize() const
{
    int total_size = 0;
    // repeated .video_widevine_client.sdk.UsageInfo.ProviderSession sessions = 1;
    total_size += 1 * this->sessions_size();

    for (int i = 0; i < this->sessions_size(); i++) {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->sessions(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void UsageInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const UsageInfo*>(&from));
}

void UsageInfo::MergeFrom(const UsageInfo& from)
{
    GOOGLE_CHECK_NE(&from, this);
    sessions_.MergeFrom(from.sessions_);
}

void UsageInfo::CopyFrom(const UsageInfo& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool UsageInfo::IsInitialized() const
{
    return true;
}

void UsageInfo::Swap(UsageInfo* other)
{
    if (other != this) {
        sessions_.Swap(&other->sessions_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string UsageInfo::GetTypeName() const
{
    return "video_widevine_client.sdk.UsageInfo";
}


// ===================================================================

bool File_FileType_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const File_FileType File::DEVICE_CERTIFICATE;
const File_FileType File::LICENSE;
const File_FileType File::USAGE_INFO;
const File_FileType File::FileType_MIN;
const File_FileType File::FileType_MAX;
const int File::FileType_ARRAYSIZE;
#endif  // _MSC_VER
bool File_FileVersion_IsValid(int value)
{
    switch (value) {
        case 1:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const File_FileVersion File::VERSION_1;
const File_FileVersion File::FileVersion_MIN;
const File_FileVersion File::FileVersion_MAX;
const int File::FileVersion_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int File::kTypeFieldNumber;
const int File::kVersionFieldNumber;
const int File::kDeviceCertificateFieldNumber;
const int File::kLicenseFieldNumber;
const int File::kUsageInfoFieldNumber;
#endif  // !_MSC_VER

File::File()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void File::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    device_certificate_ = const_cast< ::video_widevine_client::sdk::DeviceCertificate*>(
                              ::video_widevine_client::sdk::DeviceCertificate::internal_default_instance());
#else
    device_certificate_ = const_cast< ::video_widevine_client::sdk::DeviceCertificate*>(&::video_widevine_client::sdk::DeviceCertificate::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    license_ = const_cast< ::video_widevine_client::sdk::License*>(
                   ::video_widevine_client::sdk::License::internal_default_instance());
#else
    license_ = const_cast< ::video_widevine_client::sdk::License*>(&::video_widevine_client::sdk::License::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    usage_info_ = const_cast< ::video_widevine_client::sdk::UsageInfo*>(
                      ::video_widevine_client::sdk::UsageInfo::internal_default_instance());
#else
    usage_info_ = const_cast< ::video_widevine_client::sdk::UsageInfo*>(&::video_widevine_client::sdk::UsageInfo::default_instance());
#endif
}

File::File(const File& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void File::SharedCtor()
{
    _cached_size_ = 0;
    type_ = 1;
    version_ = 1;
    device_certificate_ = NULL;
    license_ = NULL;
    usage_info_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

File::~File()
{
    SharedDtor();
}

void File::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete device_certificate_;
        delete license_;
        delete usage_info_;
    }
}

void File::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const File& File::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

File* File::default_instance_ = NULL;

File* File::New() const
{
    return new File;
}

void File::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        type_ = 1;
        version_ = 1;

        if (has_device_certificate()) {
            if (device_certificate_ != NULL) device_certificate_->::video_widevine_client::sdk::DeviceCertificate::Clear();
        }

        if (has_license()) {
            if (license_ != NULL) license_->::video_widevine_client::sdk::License::Clear();
        }

        if (has_usage_info()) {
            if (usage_info_ != NULL) usage_info_->::video_widevine_client::sdk::UsageInfo::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool File::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_client.sdk.File.FileType type = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_client::sdk::File_FileType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_client::sdk::File_FileType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_version;

                break;
            }

            // optional .video_widevine_client.sdk.File.FileVersion version = 2 [default = VERSION_1];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_version:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_client::sdk::File_FileVersion_IsValid(value)) {
                        set_version(static_cast< ::video_widevine_client::sdk::File_FileVersion >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_device_certificate;

                break;
            }

            // optional .video_widevine_client.sdk.DeviceCertificate device_certificate = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_device_certificate:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_device_certificate()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_license;

                break;
            }

            // optional .video_widevine_client.sdk.License license = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_license()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_usage_info;

                break;
            }

            // optional .video_widevine_client.sdk.UsageInfo usage_info = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_usage_info:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_usage_info()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void File::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_client.sdk.File.FileType type = 1;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->type(), output);
    }

    // optional .video_widevine_client.sdk.File.FileVersion version = 2 [default = VERSION_1];
    if (has_version()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->version(), output);
    }

    // optional .video_widevine_client.sdk.DeviceCertificate device_certificate = 3;
    if (has_device_certificate()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->device_certificate(), output);
    }

    // optional .video_widevine_client.sdk.License license = 4;
    if (has_license()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, this->license(), output);
    }

    // optional .video_widevine_client.sdk.UsageInfo usage_info = 5;
    if (has_usage_info()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, this->usage_info(), output);
    }
}

int File::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_client.sdk.File.FileType type = 1;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional .video_widevine_client.sdk.File.FileVersion version = 2 [default = VERSION_1];
        if (has_version()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->version());
        }

        // optional .video_widevine_client.sdk.DeviceCertificate device_certificate = 3;
        if (has_device_certificate()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->device_certificate());
        }

        // optional .video_widevine_client.sdk.License license = 4;
        if (has_license()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->license());
        }

        // optional .video_widevine_client.sdk.UsageInfo usage_info = 5;
        if (has_usage_info()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->usage_info());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void File::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const File*>(&from));
}

void File::MergeFrom(const File& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_version()) {
            set_version(from.version());
        }

        if (from.has_device_certificate()) {
            mutable_device_certificate()->::video_widevine_client::sdk::DeviceCertificate::MergeFrom(from.device_certificate());
        }

        if (from.has_license()) {
            mutable_license()->::video_widevine_client::sdk::License::MergeFrom(from.license());
        }

        if (from.has_usage_info()) {
            mutable_usage_info()->::video_widevine_client::sdk::UsageInfo::MergeFrom(from.usage_info());
        }
    }
}

void File::CopyFrom(const File& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool File::IsInitialized() const
{
    return true;
}

void File::Swap(File* other)
{
    if (other != this) {
        std::swap(type_, other->type_);
        std::swap(version_, other->version_);
        std::swap(device_certificate_, other->device_certificate_);
        std::swap(license_, other->license_);
        std::swap(usage_info_, other->usage_info_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string File::GetTypeName() const
{
    return "video_widevine_client.sdk.File";
}


// ===================================================================

#ifndef _MSC_VER
const int HashedFile::kFileFieldNumber;
const int HashedFile::kHashFieldNumber;
#endif  // !_MSC_VER

HashedFile::HashedFile()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void HashedFile::InitAsDefaultInstance()
{
}

HashedFile::HashedFile(const HashedFile& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void HashedFile::SharedCtor()
{
    _cached_size_ = 0;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HashedFile::~HashedFile()
{
    SharedDtor();
}

void HashedFile::SharedDtor()
{
    if (file_ != &::google::protobuf::internal::kEmptyString) {
        delete file_;
    }

    if (hash_ != &::google::protobuf::internal::kEmptyString) {
        delete hash_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void HashedFile::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HashedFile& HashedFile::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_device_5ffiles_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_device_5ffiles_2eproto();

#endif
    return *default_instance_;
}

HashedFile* HashedFile::default_instance_ = NULL;

HashedFile* HashedFile::New() const
{
    return new HashedFile;
}

void HashedFile::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_file()) {
            if (file_ != &::google::protobuf::internal::kEmptyString) {
                file_->clear();
            }
        }

        if (has_hash()) {
            if (hash_ != &::google::protobuf::internal::kEmptyString) {
                hash_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HashedFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes file = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_file()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_hash;

                break;
            }

            // optional bytes hash = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_hash:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_hash()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void HashedFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes file = 1;
    if (has_file()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->file(), output);
    }

    // optional bytes hash = 2;
    if (has_hash()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->hash(), output);
    }
}

int HashedFile::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes file = 1;
        if (has_file()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->file());
        }

        // optional bytes hash = 2;
        if (has_hash()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->hash());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void HashedFile::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const HashedFile*>(&from));
}

void HashedFile::MergeFrom(const HashedFile& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_file()) {
            set_file(from.file());
        }

        if (from.has_hash()) {
            set_hash(from.hash());
        }
    }
}

void HashedFile::CopyFrom(const HashedFile& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool HashedFile::IsInitialized() const
{
    return true;
}

void HashedFile::Swap(HashedFile* other)
{
    if (other != this) {
        std::swap(file_, other->file_);
        std::swap(hash_, other->hash_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string HashedFile::GetTypeName() const
{
    return "video_widevine_client.sdk.HashedFile";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace video_widevine_client

// @@protoc_insertion_point(global_scope)
