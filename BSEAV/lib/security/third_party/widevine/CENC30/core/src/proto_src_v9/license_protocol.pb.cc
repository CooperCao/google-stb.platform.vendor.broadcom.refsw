// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: license_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "license_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace video_widevine_server
{
namespace sdk
{

void protobuf_ShutdownFile_license_5fprotocol_2eproto()
{
    delete LicenseIdentification::default_instance_;
    delete License::default_instance_;
    delete License_Policy::default_instance_;
    delete License_KeyContainer::default_instance_;
    delete License_KeyContainer_KeyControl::default_instance_;
    delete License_KeyContainer_OutputProtection::default_instance_;
    delete License_KeyContainer_VideoResolutionConstraint::default_instance_;
    delete License_KeyContainer_OperatorSessionKeyPermissions::default_instance_;
    delete LicenseRequest::default_instance_;
    delete LicenseRequest_ContentIdentification::default_instance_;
    delete LicenseRequest_ContentIdentification_CENC::default_instance_;
    delete LicenseRequest_ContentIdentification_WebM::default_instance_;
    delete LicenseRequest_ContentIdentification_ExistingLicense::default_instance_;
    delete LicenseError::default_instance_;
    delete RemoteAttestation::default_instance_;
    delete SignedMessage::default_instance_;
    delete SessionInit::default_instance_;
    delete SessionState::default_instance_;
    delete ProvisioningOptions::default_instance_;
    delete ProvisioningRequest::default_instance_;
    delete ProvisioningResponse::default_instance_;
    delete SignedProvisioningMessage::default_instance_;
    delete ClientIdentification::default_instance_;
    delete ClientIdentification_NameValue::default_instance_;
    delete ClientIdentification_ClientCapabilities::default_instance_;
    delete EncryptedClientIdentification::default_instance_;
    delete DeviceCertificate::default_instance_;
    delete SignedDeviceCertificate::default_instance_;
    delete ProvisionedDeviceInfo::default_instance_;
    delete DeviceCertificateStatus::default_instance_;
    delete DeviceCertificateStatusList::default_instance_;
    delete SignedCertificateStatusList::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_license_5fprotocol_2eproto_impl()
{
    GOOGLE_PROTOBUF_VERIFY_VERSION;
#else
void protobuf_AddDesc_license_5fprotocol_2eproto()
{
    static bool already_here = false;

    if (already_here) return;

    already_here = true;
    GOOGLE_PROTOBUF_VERIFY_VERSION;
#endif
    LicenseIdentification::default_instance_ = new LicenseIdentification();
    License::default_instance_ = new License();
    License_Policy::default_instance_ = new License_Policy();
    License_KeyContainer::default_instance_ = new License_KeyContainer();
    License_KeyContainer_KeyControl::default_instance_ = new License_KeyContainer_KeyControl();
    License_KeyContainer_OutputProtection::default_instance_ = new License_KeyContainer_OutputProtection();
    License_KeyContainer_VideoResolutionConstraint::default_instance_ = new License_KeyContainer_VideoResolutionConstraint();
    License_KeyContainer_OperatorSessionKeyPermissions::default_instance_ = new License_KeyContainer_OperatorSessionKeyPermissions();
    LicenseRequest::default_instance_ = new LicenseRequest();
    LicenseRequest_ContentIdentification::default_instance_ = new LicenseRequest_ContentIdentification();
    LicenseRequest_ContentIdentification_CENC::default_instance_ = new LicenseRequest_ContentIdentification_CENC();
    LicenseRequest_ContentIdentification_WebM::default_instance_ = new LicenseRequest_ContentIdentification_WebM();
    LicenseRequest_ContentIdentification_ExistingLicense::default_instance_ = new LicenseRequest_ContentIdentification_ExistingLicense();
    LicenseError::default_instance_ = new LicenseError();
    RemoteAttestation::default_instance_ = new RemoteAttestation();
    SignedMessage::default_instance_ = new SignedMessage();
    SessionInit::default_instance_ = new SessionInit();
    SessionState::default_instance_ = new SessionState();
    ProvisioningOptions::default_instance_ = new ProvisioningOptions();
    ProvisioningRequest::default_instance_ = new ProvisioningRequest();
    ProvisioningResponse::default_instance_ = new ProvisioningResponse();
    SignedProvisioningMessage::default_instance_ = new SignedProvisioningMessage();
    ClientIdentification::default_instance_ = new ClientIdentification();
    ClientIdentification_NameValue::default_instance_ = new ClientIdentification_NameValue();
    ClientIdentification_ClientCapabilities::default_instance_ = new ClientIdentification_ClientCapabilities();
    EncryptedClientIdentification::default_instance_ = new EncryptedClientIdentification();
    DeviceCertificate::default_instance_ = new DeviceCertificate();
    SignedDeviceCertificate::default_instance_ = new SignedDeviceCertificate();
    ProvisionedDeviceInfo::default_instance_ = new ProvisionedDeviceInfo();
    DeviceCertificateStatus::default_instance_ = new DeviceCertificateStatus();
    DeviceCertificateStatusList::default_instance_ = new DeviceCertificateStatusList();
    SignedCertificateStatusList::default_instance_ = new SignedCertificateStatusList();
    LicenseIdentification::default_instance_->InitAsDefaultInstance();
    License::default_instance_->InitAsDefaultInstance();
    License_Policy::default_instance_->InitAsDefaultInstance();
    License_KeyContainer::default_instance_->InitAsDefaultInstance();
    License_KeyContainer_KeyControl::default_instance_->InitAsDefaultInstance();
    License_KeyContainer_OutputProtection::default_instance_->InitAsDefaultInstance();
    License_KeyContainer_VideoResolutionConstraint::default_instance_->InitAsDefaultInstance();
    License_KeyContainer_OperatorSessionKeyPermissions::default_instance_->InitAsDefaultInstance();
    LicenseRequest::default_instance_->InitAsDefaultInstance();
    LicenseRequest_ContentIdentification::default_instance_->InitAsDefaultInstance();
    LicenseRequest_ContentIdentification_CENC::default_instance_->InitAsDefaultInstance();
    LicenseRequest_ContentIdentification_WebM::default_instance_->InitAsDefaultInstance();
    LicenseRequest_ContentIdentification_ExistingLicense::default_instance_->InitAsDefaultInstance();
    LicenseError::default_instance_->InitAsDefaultInstance();
    RemoteAttestation::default_instance_->InitAsDefaultInstance();
    SignedMessage::default_instance_->InitAsDefaultInstance();
    SessionInit::default_instance_->InitAsDefaultInstance();
    SessionState::default_instance_->InitAsDefaultInstance();
    ProvisioningOptions::default_instance_->InitAsDefaultInstance();
    ProvisioningRequest::default_instance_->InitAsDefaultInstance();
    ProvisioningResponse::default_instance_->InitAsDefaultInstance();
    SignedProvisioningMessage::default_instance_->InitAsDefaultInstance();
    ClientIdentification::default_instance_->InitAsDefaultInstance();
    ClientIdentification_NameValue::default_instance_->InitAsDefaultInstance();
    ClientIdentification_ClientCapabilities::default_instance_->InitAsDefaultInstance();
    EncryptedClientIdentification::default_instance_->InitAsDefaultInstance();
    DeviceCertificate::default_instance_->InitAsDefaultInstance();
    SignedDeviceCertificate::default_instance_->InitAsDefaultInstance();
    ProvisionedDeviceInfo::default_instance_->InitAsDefaultInstance();
    DeviceCertificateStatus::default_instance_->InitAsDefaultInstance();
    DeviceCertificateStatusList::default_instance_->InitAsDefaultInstance();
    SignedCertificateStatusList::default_instance_->InitAsDefaultInstance();
    ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_license_5fprotocol_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_license_5fprotocol_2eproto_once_);
void protobuf_AddDesc_license_5fprotocol_2eproto()
{
    ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_license_5fprotocol_2eproto_once_,
            &protobuf_AddDesc_license_5fprotocol_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_license_5fprotocol_2eproto {
    StaticDescriptorInitializer_license_5fprotocol_2eproto() {
        protobuf_AddDesc_license_5fprotocol_2eproto();
    }
} static_descriptor_initializer_license_5fprotocol_2eproto_;
#endif
bool LicenseType_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
            return true;

        default:
            return false;
    }
}

bool ProtocolVersion_IsValid(int value)
{
    switch (value) {
        case 20:
        case 21:
            return true;

        default:
            return false;
    }
}


// ===================================================================

#ifndef _MSC_VER
const int LicenseIdentification::kRequestIdFieldNumber;
const int LicenseIdentification::kSessionIdFieldNumber;
const int LicenseIdentification::kPurchaseIdFieldNumber;
const int LicenseIdentification::kTypeFieldNumber;
const int LicenseIdentification::kVersionFieldNumber;
const int LicenseIdentification::kProviderSessionTokenFieldNumber;
#endif  // !_MSC_VER

LicenseIdentification::LicenseIdentification()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseIdentification::InitAsDefaultInstance()
{
}

LicenseIdentification::LicenseIdentification(const LicenseIdentification& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseIdentification::SharedCtor()
{
    _cached_size_ = 0;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    purchase_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    type_ = 1;
    version_ = 0;
    provider_session_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseIdentification::~LicenseIdentification()
{
    SharedDtor();
}

void LicenseIdentification::SharedDtor()
{
    if (request_id_ != &::google::protobuf::internal::kEmptyString) {
        delete request_id_;
    }

    if (session_id_ != &::google::protobuf::internal::kEmptyString) {
        delete session_id_;
    }

    if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
        delete purchase_id_;
    }

    if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
        delete provider_session_token_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void LicenseIdentification::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseIdentification& LicenseIdentification::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseIdentification* LicenseIdentification::default_instance_ = NULL;

LicenseIdentification* LicenseIdentification::New() const
{
    return new LicenseIdentification;
}

void LicenseIdentification::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_request_id()) {
            if (request_id_ != &::google::protobuf::internal::kEmptyString) {
                request_id_->clear();
            }
        }

        if (has_session_id()) {
            if (session_id_ != &::google::protobuf::internal::kEmptyString) {
                session_id_->clear();
            }
        }

        if (has_purchase_id()) {
            if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
                purchase_id_->clear();
            }
        }

        type_ = 1;
        version_ = 0;

        if (has_provider_session_token()) {
            if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
                provider_session_token_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseIdentification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes request_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_request_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_session_id;

                break;
            }

            // optional bytes session_id = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_session_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_session_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_purchase_id;

                break;
            }

            // optional bytes purchase_id = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_purchase_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_purchase_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_type;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseType type = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::LicenseType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::LicenseType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_version;

                break;
            }

            // optional int32 version = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_version:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32 > (
                             input, &version_)));
                    set_has_version();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_provider_session_token;

                break;
            }

            // optional bytes provider_session_token = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_provider_session_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_provider_session_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseIdentification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes request_id = 1;
    if (has_request_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->request_id(), output);
    }

    // optional bytes session_id = 2;
    if (has_session_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->session_id(), output);
    }

    // optional bytes purchase_id = 3;
    if (has_purchase_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->purchase_id(), output);
    }

    // optional .video_widevine_server.sdk.LicenseType type = 4;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->type(), output);
    }

    // optional int32 version = 5;
    if (has_version()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->version(), output);
    }

    // optional bytes provider_session_token = 6;
    if (has_provider_session_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            6, this->provider_session_token(), output);
    }
}

int LicenseIdentification::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes request_id = 1;
        if (has_request_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->request_id());
        }

        // optional bytes session_id = 2;
        if (has_session_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->session_id());
        }

        // optional bytes purchase_id = 3;
        if (has_purchase_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->purchase_id());
        }

        // optional .video_widevine_server.sdk.LicenseType type = 4;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional int32 version = 5;
        if (has_version()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int32Size(
                              this->version());
        }

        // optional bytes provider_session_token = 6;
        if (has_provider_session_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->provider_session_token());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseIdentification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseIdentification*>(&from));
}

void LicenseIdentification::MergeFrom(const LicenseIdentification& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_request_id()) {
            set_request_id(from.request_id());
        }

        if (from.has_session_id()) {
            set_session_id(from.session_id());
        }

        if (from.has_purchase_id()) {
            set_purchase_id(from.purchase_id());
        }

        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_version()) {
            set_version(from.version());
        }

        if (from.has_provider_session_token()) {
            set_provider_session_token(from.provider_session_token());
        }
    }
}

void LicenseIdentification::CopyFrom(const LicenseIdentification& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseIdentification::IsInitialized() const
{
    return true;
}

void LicenseIdentification::Swap(LicenseIdentification* other)
{
    if (other != this) {
        std::swap(request_id_, other->request_id_);
        std::swap(session_id_, other->session_id_);
        std::swap(purchase_id_, other->purchase_id_);
        std::swap(type_, other->type_);
        std::swap(version_, other->version_);
        std::swap(provider_session_token_, other->provider_session_token_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseIdentification::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseIdentification";
}


// ===================================================================

#ifndef _MSC_VER
const int License_Policy::kCanPlayFieldNumber;
const int License_Policy::kCanPersistFieldNumber;
const int License_Policy::kCanRenewFieldNumber;
const int License_Policy::kRentalDurationSecondsFieldNumber;
const int License_Policy::kPlaybackDurationSecondsFieldNumber;
const int License_Policy::kLicenseDurationSecondsFieldNumber;
const int License_Policy::kRenewalRecoveryDurationSecondsFieldNumber;
const int License_Policy::kRenewalServerUrlFieldNumber;
const int License_Policy::kRenewalDelaySecondsFieldNumber;
const int License_Policy::kRenewalRetryIntervalSecondsFieldNumber;
const int License_Policy::kRenewWithUsageFieldNumber;
#endif  // !_MSC_VER

License_Policy::License_Policy()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_Policy::InitAsDefaultInstance()
{
}

License_Policy::License_Policy(const License_Policy& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_Policy::SharedCtor()
{
    _cached_size_ = 0;
    can_play_ = false;
    can_persist_ = false;
    can_renew_ = false;
    rental_duration_seconds_ = GOOGLE_LONGLONG(0);
    playback_duration_seconds_ = GOOGLE_LONGLONG(0);
    license_duration_seconds_ = GOOGLE_LONGLONG(0);
    renewal_recovery_duration_seconds_ = GOOGLE_LONGLONG(0);
    renewal_server_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    renewal_delay_seconds_ = GOOGLE_LONGLONG(0);
    renewal_retry_interval_seconds_ = GOOGLE_LONGLONG(0);
    renew_with_usage_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_Policy::~License_Policy()
{
    SharedDtor();
}

void License_Policy::SharedDtor()
{
    if (renewal_server_url_ != &::google::protobuf::internal::kEmptyString) {
        delete renewal_server_url_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void License_Policy::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_Policy& License_Policy::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_Policy* License_Policy::default_instance_ = NULL;

License_Policy* License_Policy::New() const
{
    return new License_Policy;
}

void License_Policy::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        can_play_ = false;
        can_persist_ = false;
        can_renew_ = false;
        rental_duration_seconds_ = GOOGLE_LONGLONG(0);
        playback_duration_seconds_ = GOOGLE_LONGLONG(0);
        license_duration_seconds_ = GOOGLE_LONGLONG(0);
        renewal_recovery_duration_seconds_ = GOOGLE_LONGLONG(0);

        if (has_renewal_server_url()) {
            if (renewal_server_url_ != &::google::protobuf::internal::kEmptyString) {
                renewal_server_url_->clear();
            }
        }
    }

    if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        renewal_delay_seconds_ = GOOGLE_LONGLONG(0);
        renewal_retry_interval_seconds_ = GOOGLE_LONGLONG(0);
        renew_with_usage_ = false;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_Policy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bool can_play = 1 [default = false];
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &can_play_)));
                    set_has_can_play();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_can_persist;

                break;
            }

            // optional bool can_persist = 2 [default = false];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_can_persist:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &can_persist_)));
                    set_has_can_persist();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_can_renew;

                break;
            }

            // optional bool can_renew = 3 [default = false];
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_can_renew:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &can_renew_)));
                    set_has_can_renew();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_rental_duration_seconds;

                break;
            }

            // optional int64 rental_duration_seconds = 4 [default = 0];
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_rental_duration_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &rental_duration_seconds_)));
                    set_has_rental_duration_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_playback_duration_seconds;

                break;
            }

            // optional int64 playback_duration_seconds = 5 [default = 0];
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_playback_duration_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &playback_duration_seconds_)));
                    set_has_playback_duration_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(48)) goto parse_license_duration_seconds;

                break;
            }

            // optional int64 license_duration_seconds = 6 [default = 0];
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_duration_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &license_duration_seconds_)));
                    set_has_license_duration_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(56)) goto parse_renewal_recovery_duration_seconds;

                break;
            }

            // optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_renewal_recovery_duration_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &renewal_recovery_duration_seconds_)));
                    set_has_renewal_recovery_duration_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(66)) goto parse_renewal_server_url;

                break;
            }

            // optional string renewal_server_url = 8;
            case 8: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_renewal_server_url:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_renewal_server_url()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(72)) goto parse_renewal_delay_seconds;

                break;
            }

            // optional int64 renewal_delay_seconds = 9 [default = 0];
            case 9: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_renewal_delay_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &renewal_delay_seconds_)));
                    set_has_renewal_delay_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(80)) goto parse_renewal_retry_interval_seconds;

                break;
            }

            // optional int64 renewal_retry_interval_seconds = 10 [default = 0];
            case 10: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_renewal_retry_interval_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &renewal_retry_interval_seconds_)));
                    set_has_renewal_retry_interval_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(88)) goto parse_renew_with_usage;

                break;
            }

            // optional bool renew_with_usage = 11 [default = false];
            case 11: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_renew_with_usage:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &renew_with_usage_)));
                    set_has_renew_with_usage();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_Policy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bool can_play = 1 [default = false];
    if (has_can_play()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->can_play(), output);
    }

    // optional bool can_persist = 2 [default = false];
    if (has_can_persist()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->can_persist(), output);
    }

    // optional bool can_renew = 3 [default = false];
    if (has_can_renew()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->can_renew(), output);
    }

    // optional int64 rental_duration_seconds = 4 [default = 0];
    if (has_rental_duration_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->rental_duration_seconds(), output);
    }

    // optional int64 playback_duration_seconds = 5 [default = 0];
    if (has_playback_duration_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->playback_duration_seconds(), output);
    }

    // optional int64 license_duration_seconds = 6 [default = 0];
    if (has_license_duration_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->license_duration_seconds(), output);
    }

    // optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
    if (has_renewal_recovery_duration_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->renewal_recovery_duration_seconds(), output);
    }

    // optional string renewal_server_url = 8;
    if (has_renewal_server_url()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            8, this->renewal_server_url(), output);
    }

    // optional int64 renewal_delay_seconds = 9 [default = 0];
    if (has_renewal_delay_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->renewal_delay_seconds(), output);
    }

    // optional int64 renewal_retry_interval_seconds = 10 [default = 0];
    if (has_renewal_retry_interval_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->renewal_retry_interval_seconds(), output);
    }

    // optional bool renew_with_usage = 11 [default = false];
    if (has_renew_with_usage()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->renew_with_usage(), output);
    }
}

int License_Policy::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bool can_play = 1 [default = false];
        if (has_can_play()) {
            total_size += 1 + 1;
        }

        // optional bool can_persist = 2 [default = false];
        if (has_can_persist()) {
            total_size += 1 + 1;
        }

        // optional bool can_renew = 3 [default = false];
        if (has_can_renew()) {
            total_size += 1 + 1;
        }

        // optional int64 rental_duration_seconds = 4 [default = 0];
        if (has_rental_duration_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->rental_duration_seconds());
        }

        // optional int64 playback_duration_seconds = 5 [default = 0];
        if (has_playback_duration_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->playback_duration_seconds());
        }

        // optional int64 license_duration_seconds = 6 [default = 0];
        if (has_license_duration_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->license_duration_seconds());
        }

        // optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
        if (has_renewal_recovery_duration_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->renewal_recovery_duration_seconds());
        }

        // optional string renewal_server_url = 8;
        if (has_renewal_server_url()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->renewal_server_url());
        }
    }

    if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        // optional int64 renewal_delay_seconds = 9 [default = 0];
        if (has_renewal_delay_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->renewal_delay_seconds());
        }

        // optional int64 renewal_retry_interval_seconds = 10 [default = 0];
        if (has_renewal_retry_interval_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->renewal_retry_interval_seconds());
        }

        // optional bool renew_with_usage = 11 [default = false];
        if (has_renew_with_usage()) {
            total_size += 1 + 1;
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_Policy::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_Policy*>(&from));
}

void License_Policy::MergeFrom(const License_Policy& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_can_play()) {
            set_can_play(from.can_play());
        }

        if (from.has_can_persist()) {
            set_can_persist(from.can_persist());
        }

        if (from.has_can_renew()) {
            set_can_renew(from.can_renew());
        }

        if (from.has_rental_duration_seconds()) {
            set_rental_duration_seconds(from.rental_duration_seconds());
        }

        if (from.has_playback_duration_seconds()) {
            set_playback_duration_seconds(from.playback_duration_seconds());
        }

        if (from.has_license_duration_seconds()) {
            set_license_duration_seconds(from.license_duration_seconds());
        }

        if (from.has_renewal_recovery_duration_seconds()) {
            set_renewal_recovery_duration_seconds(from.renewal_recovery_duration_seconds());
        }

        if (from.has_renewal_server_url()) {
            set_renewal_server_url(from.renewal_server_url());
        }
    }

    if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        if (from.has_renewal_delay_seconds()) {
            set_renewal_delay_seconds(from.renewal_delay_seconds());
        }

        if (from.has_renewal_retry_interval_seconds()) {
            set_renewal_retry_interval_seconds(from.renewal_retry_interval_seconds());
        }

        if (from.has_renew_with_usage()) {
            set_renew_with_usage(from.renew_with_usage());
        }
    }
}

void License_Policy::CopyFrom(const License_Policy& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_Policy::IsInitialized() const
{
    return true;
}

void License_Policy::Swap(License_Policy* other)
{
    if (other != this) {
        std::swap(can_play_, other->can_play_);
        std::swap(can_persist_, other->can_persist_);
        std::swap(can_renew_, other->can_renew_);
        std::swap(rental_duration_seconds_, other->rental_duration_seconds_);
        std::swap(playback_duration_seconds_, other->playback_duration_seconds_);
        std::swap(license_duration_seconds_, other->license_duration_seconds_);
        std::swap(renewal_recovery_duration_seconds_, other->renewal_recovery_duration_seconds_);
        std::swap(renewal_server_url_, other->renewal_server_url_);
        std::swap(renewal_delay_seconds_, other->renewal_delay_seconds_);
        std::swap(renewal_retry_interval_seconds_, other->renewal_retry_interval_seconds_);
        std::swap(renew_with_usage_, other->renew_with_usage_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_Policy::GetTypeName() const
{
    return "video_widevine_server.sdk.License.Policy";
}


// -------------------------------------------------------------------

bool License_KeyContainer_KeyType_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
        case 4:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const License_KeyContainer_KeyType License_KeyContainer::SIGNING;
const License_KeyContainer_KeyType License_KeyContainer::CONTENT;
const License_KeyContainer_KeyType License_KeyContainer::KEY_CONTROL;
const License_KeyContainer_KeyType License_KeyContainer::OPERATOR_SESSION;
const License_KeyContainer_KeyType License_KeyContainer::KeyType_MIN;
const License_KeyContainer_KeyType License_KeyContainer::KeyType_MAX;
const int License_KeyContainer::KeyType_ARRAYSIZE;
#endif  // _MSC_VER
bool License_KeyContainer_SecurityLevel_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const License_KeyContainer_SecurityLevel License_KeyContainer::SW_SECURE_CRYPTO;
const License_KeyContainer_SecurityLevel License_KeyContainer::SW_SECURE_DECODE;
const License_KeyContainer_SecurityLevel License_KeyContainer::HW_SECURE_CRYPTO;
const License_KeyContainer_SecurityLevel License_KeyContainer::HW_SECURE_DECODE;
const License_KeyContainer_SecurityLevel License_KeyContainer::HW_SECURE_ALL;
const License_KeyContainer_SecurityLevel License_KeyContainer::SecurityLevel_MIN;
const License_KeyContainer_SecurityLevel License_KeyContainer::SecurityLevel_MAX;
const int License_KeyContainer::SecurityLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int License_KeyContainer_KeyControl::kKeyControlBlockFieldNumber;
const int License_KeyContainer_KeyControl::kIvFieldNumber;
#endif  // !_MSC_VER

License_KeyContainer_KeyControl::License_KeyContainer_KeyControl()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_KeyContainer_KeyControl::InitAsDefaultInstance()
{
}

License_KeyContainer_KeyControl::License_KeyContainer_KeyControl(const License_KeyContainer_KeyControl& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_KeyContainer_KeyControl::SharedCtor()
{
    _cached_size_ = 0;
    key_control_block_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_KeyContainer_KeyControl::~License_KeyContainer_KeyControl()
{
    SharedDtor();
}

void License_KeyContainer_KeyControl::SharedDtor()
{
    if (key_control_block_ != &::google::protobuf::internal::kEmptyString) {
        delete key_control_block_;
    }

    if (iv_ != &::google::protobuf::internal::kEmptyString) {
        delete iv_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void License_KeyContainer_KeyControl::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_KeyContainer_KeyControl& License_KeyContainer_KeyControl::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_KeyContainer_KeyControl* License_KeyContainer_KeyControl::default_instance_ = NULL;

License_KeyContainer_KeyControl* License_KeyContainer_KeyControl::New() const
{
    return new License_KeyContainer_KeyControl;
}

void License_KeyContainer_KeyControl::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_key_control_block()) {
            if (key_control_block_ != &::google::protobuf::internal::kEmptyString) {
                key_control_block_->clear();
            }
        }

        if (has_iv()) {
            if (iv_ != &::google::protobuf::internal::kEmptyString) {
                iv_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_KeyContainer_KeyControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes key_control_block = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_key_control_block()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_iv;

                break;
            }

            // optional bytes iv = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_iv:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_iv()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_KeyContainer_KeyControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes key_control_block = 1;
    if (has_key_control_block()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->key_control_block(), output);
    }

    // optional bytes iv = 2;
    if (has_iv()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->iv(), output);
    }
}

int License_KeyContainer_KeyControl::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes key_control_block = 1;
        if (has_key_control_block()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->key_control_block());
        }

        // optional bytes iv = 2;
        if (has_iv()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->iv());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_KeyContainer_KeyControl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_KeyContainer_KeyControl*>(&from));
}

void License_KeyContainer_KeyControl::MergeFrom(const License_KeyContainer_KeyControl& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_key_control_block()) {
            set_key_control_block(from.key_control_block());
        }

        if (from.has_iv()) {
            set_iv(from.iv());
        }
    }
}

void License_KeyContainer_KeyControl::CopyFrom(const License_KeyContainer_KeyControl& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_KeyContainer_KeyControl::IsInitialized() const
{
    return true;
}

void License_KeyContainer_KeyControl::Swap(License_KeyContainer_KeyControl* other)
{
    if (other != this) {
        std::swap(key_control_block_, other->key_control_block_);
        std::swap(iv_, other->iv_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_KeyContainer_KeyControl::GetTypeName() const
{
    return "video_widevine_server.sdk.License.KeyContainer.KeyControl";
}


// -------------------------------------------------------------------

bool License_KeyContainer_OutputProtection_HDCP_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_NONE;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_V1;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_V2;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_V2_1;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_V2_2;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_MIN;
const License_KeyContainer_OutputProtection_HDCP License_KeyContainer_OutputProtection::HDCP_MAX;
const int License_KeyContainer_OutputProtection::HDCP_ARRAYSIZE;
#endif  // _MSC_VER
bool License_KeyContainer_OutputProtection_CGMS_IsValid(int value)
{
    switch (value) {
        case 0:
        case 2:
        case 3:
        case 42:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::CGMS_NONE;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::COPY_FREE;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::COPY_ONCE;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::COPY_NEVER;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::CGMS_MIN;
const License_KeyContainer_OutputProtection_CGMS License_KeyContainer_OutputProtection::CGMS_MAX;
const int License_KeyContainer_OutputProtection::CGMS_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int License_KeyContainer_OutputProtection::kHdcpFieldNumber;
const int License_KeyContainer_OutputProtection::kCgmsFlagsFieldNumber;
#endif  // !_MSC_VER

License_KeyContainer_OutputProtection::License_KeyContainer_OutputProtection()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_KeyContainer_OutputProtection::InitAsDefaultInstance()
{
}

License_KeyContainer_OutputProtection::License_KeyContainer_OutputProtection(const License_KeyContainer_OutputProtection& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_KeyContainer_OutputProtection::SharedCtor()
{
    _cached_size_ = 0;
    hdcp_ = 0;
    cgms_flags_ = 42;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_KeyContainer_OutputProtection::~License_KeyContainer_OutputProtection()
{
    SharedDtor();
}

void License_KeyContainer_OutputProtection::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void License_KeyContainer_OutputProtection::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_KeyContainer_OutputProtection& License_KeyContainer_OutputProtection::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_KeyContainer_OutputProtection* License_KeyContainer_OutputProtection::default_instance_ = NULL;

License_KeyContainer_OutputProtection* License_KeyContainer_OutputProtection::New() const
{
    return new License_KeyContainer_OutputProtection;
}

void License_KeyContainer_OutputProtection::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        hdcp_ = 0;
        cgms_flags_ = 42;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_KeyContainer_OutputProtection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP_IsValid(value)) {
                        set_hdcp(static_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_HDCP >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_cgms_flags;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_cgms_flags:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS_IsValid(value)) {
                        set_cgms_flags(static_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection_CGMS >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_KeyContainer_OutputProtection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
    if (has_hdcp()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->hdcp(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
    if (has_cgms_flags()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->cgms_flags(), output);
    }
}

int License_KeyContainer_OutputProtection::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
        if (has_hdcp()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->hdcp());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
        if (has_cgms_flags()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->cgms_flags());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_KeyContainer_OutputProtection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_KeyContainer_OutputProtection*>(&from));
}

void License_KeyContainer_OutputProtection::MergeFrom(const License_KeyContainer_OutputProtection& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_hdcp()) {
            set_hdcp(from.hdcp());
        }

        if (from.has_cgms_flags()) {
            set_cgms_flags(from.cgms_flags());
        }
    }
}

void License_KeyContainer_OutputProtection::CopyFrom(const License_KeyContainer_OutputProtection& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_KeyContainer_OutputProtection::IsInitialized() const
{
    return true;
}

void License_KeyContainer_OutputProtection::Swap(License_KeyContainer_OutputProtection* other)
{
    if (other != this) {
        std::swap(hdcp_, other->hdcp_);
        std::swap(cgms_flags_, other->cgms_flags_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_KeyContainer_OutputProtection::GetTypeName() const
{
    return "video_widevine_server.sdk.License.KeyContainer.OutputProtection";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int License_KeyContainer_VideoResolutionConstraint::kMinResolutionPixelsFieldNumber;
const int License_KeyContainer_VideoResolutionConstraint::kMaxResolutionPixelsFieldNumber;
const int License_KeyContainer_VideoResolutionConstraint::kRequiredProtectionFieldNumber;
#endif  // !_MSC_VER

License_KeyContainer_VideoResolutionConstraint::License_KeyContainer_VideoResolutionConstraint()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_KeyContainer_VideoResolutionConstraint::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    required_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(
                               ::video_widevine_server::sdk::License_KeyContainer_OutputProtection::internal_default_instance());
#else
    required_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(&::video_widevine_server::sdk::License_KeyContainer_OutputProtection::default_instance());
#endif
}

License_KeyContainer_VideoResolutionConstraint::License_KeyContainer_VideoResolutionConstraint(const License_KeyContainer_VideoResolutionConstraint& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_KeyContainer_VideoResolutionConstraint::SharedCtor()
{
    _cached_size_ = 0;
    min_resolution_pixels_ = 0u;
    max_resolution_pixels_ = 0u;
    required_protection_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_KeyContainer_VideoResolutionConstraint::~License_KeyContainer_VideoResolutionConstraint()
{
    SharedDtor();
}

void License_KeyContainer_VideoResolutionConstraint::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete required_protection_;
    }
}

void License_KeyContainer_VideoResolutionConstraint::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_KeyContainer_VideoResolutionConstraint& License_KeyContainer_VideoResolutionConstraint::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_KeyContainer_VideoResolutionConstraint* License_KeyContainer_VideoResolutionConstraint::default_instance_ = NULL;

License_KeyContainer_VideoResolutionConstraint* License_KeyContainer_VideoResolutionConstraint::New() const
{
    return new License_KeyContainer_VideoResolutionConstraint;
}

void License_KeyContainer_VideoResolutionConstraint::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        min_resolution_pixels_ = 0u;
        max_resolution_pixels_ = 0u;

        if (has_required_protection()) {
            if (required_protection_ != NULL) required_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_KeyContainer_VideoResolutionConstraint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional uint32 min_resolution_pixels = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &min_resolution_pixels_)));
                    set_has_min_resolution_pixels();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_max_resolution_pixels;

                break;
            }

            // optional uint32 max_resolution_pixels = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_max_resolution_pixels:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &max_resolution_pixels_)));
                    set_has_max_resolution_pixels();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_required_protection;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_required_protection:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_required_protection()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_KeyContainer_VideoResolutionConstraint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional uint32 min_resolution_pixels = 1;
    if (has_min_resolution_pixels()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->min_resolution_pixels(), output);
    }

    // optional uint32 max_resolution_pixels = 2;
    if (has_max_resolution_pixels()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_resolution_pixels(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 3;
    if (has_required_protection()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->required_protection(), output);
    }
}

int License_KeyContainer_VideoResolutionConstraint::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional uint32 min_resolution_pixels = 1;
        if (has_min_resolution_pixels()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->min_resolution_pixels());
        }

        // optional uint32 max_resolution_pixels = 2;
        if (has_max_resolution_pixels()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->max_resolution_pixels());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 3;
        if (has_required_protection()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->required_protection());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_KeyContainer_VideoResolutionConstraint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_KeyContainer_VideoResolutionConstraint*>(&from));
}

void License_KeyContainer_VideoResolutionConstraint::MergeFrom(const License_KeyContainer_VideoResolutionConstraint& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_min_resolution_pixels()) {
            set_min_resolution_pixels(from.min_resolution_pixels());
        }

        if (from.has_max_resolution_pixels()) {
            set_max_resolution_pixels(from.max_resolution_pixels());
        }

        if (from.has_required_protection()) {
            mutable_required_protection()->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::MergeFrom(from.required_protection());
        }
    }
}

void License_KeyContainer_VideoResolutionConstraint::CopyFrom(const License_KeyContainer_VideoResolutionConstraint& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_KeyContainer_VideoResolutionConstraint::IsInitialized() const
{
    return true;
}

void License_KeyContainer_VideoResolutionConstraint::Swap(License_KeyContainer_VideoResolutionConstraint* other)
{
    if (other != this) {
        std::swap(min_resolution_pixels_, other->min_resolution_pixels_);
        std::swap(max_resolution_pixels_, other->max_resolution_pixels_);
        std::swap(required_protection_, other->required_protection_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_KeyContainer_VideoResolutionConstraint::GetTypeName() const
{
    return "video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int License_KeyContainer_OperatorSessionKeyPermissions::kAllowEncryptFieldNumber;
const int License_KeyContainer_OperatorSessionKeyPermissions::kAllowDecryptFieldNumber;
const int License_KeyContainer_OperatorSessionKeyPermissions::kAllowSignFieldNumber;
const int License_KeyContainer_OperatorSessionKeyPermissions::kAllowSignatureVerifyFieldNumber;
#endif  // !_MSC_VER

License_KeyContainer_OperatorSessionKeyPermissions::License_KeyContainer_OperatorSessionKeyPermissions()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_KeyContainer_OperatorSessionKeyPermissions::InitAsDefaultInstance()
{
}

License_KeyContainer_OperatorSessionKeyPermissions::License_KeyContainer_OperatorSessionKeyPermissions(const License_KeyContainer_OperatorSessionKeyPermissions& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_KeyContainer_OperatorSessionKeyPermissions::SharedCtor()
{
    _cached_size_ = 0;
    allow_encrypt_ = false;
    allow_decrypt_ = false;
    allow_sign_ = false;
    allow_signature_verify_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_KeyContainer_OperatorSessionKeyPermissions::~License_KeyContainer_OperatorSessionKeyPermissions()
{
    SharedDtor();
}

void License_KeyContainer_OperatorSessionKeyPermissions::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void License_KeyContainer_OperatorSessionKeyPermissions::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_KeyContainer_OperatorSessionKeyPermissions& License_KeyContainer_OperatorSessionKeyPermissions::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_KeyContainer_OperatorSessionKeyPermissions* License_KeyContainer_OperatorSessionKeyPermissions::default_instance_ = NULL;

License_KeyContainer_OperatorSessionKeyPermissions* License_KeyContainer_OperatorSessionKeyPermissions::New() const
{
    return new License_KeyContainer_OperatorSessionKeyPermissions;
}

void License_KeyContainer_OperatorSessionKeyPermissions::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        allow_encrypt_ = false;
        allow_decrypt_ = false;
        allow_sign_ = false;
        allow_signature_verify_ = false;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_KeyContainer_OperatorSessionKeyPermissions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bool allow_encrypt = 1 [default = false];
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &allow_encrypt_)));
                    set_has_allow_encrypt();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_allow_decrypt;

                break;
            }

            // optional bool allow_decrypt = 2 [default = false];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_allow_decrypt:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &allow_decrypt_)));
                    set_has_allow_decrypt();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_allow_sign;

                break;
            }

            // optional bool allow_sign = 3 [default = false];
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_allow_sign:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &allow_sign_)));
                    set_has_allow_sign();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_allow_signature_verify;

                break;
            }

            // optional bool allow_signature_verify = 4 [default = false];
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_allow_signature_verify:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &allow_signature_verify_)));
                    set_has_allow_signature_verify();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_KeyContainer_OperatorSessionKeyPermissions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bool allow_encrypt = 1 [default = false];
    if (has_allow_encrypt()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->allow_encrypt(), output);
    }

    // optional bool allow_decrypt = 2 [default = false];
    if (has_allow_decrypt()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->allow_decrypt(), output);
    }

    // optional bool allow_sign = 3 [default = false];
    if (has_allow_sign()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->allow_sign(), output);
    }

    // optional bool allow_signature_verify = 4 [default = false];
    if (has_allow_signature_verify()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->allow_signature_verify(), output);
    }
}

int License_KeyContainer_OperatorSessionKeyPermissions::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bool allow_encrypt = 1 [default = false];
        if (has_allow_encrypt()) {
            total_size += 1 + 1;
        }

        // optional bool allow_decrypt = 2 [default = false];
        if (has_allow_decrypt()) {
            total_size += 1 + 1;
        }

        // optional bool allow_sign = 3 [default = false];
        if (has_allow_sign()) {
            total_size += 1 + 1;
        }

        // optional bool allow_signature_verify = 4 [default = false];
        if (has_allow_signature_verify()) {
            total_size += 1 + 1;
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_KeyContainer_OperatorSessionKeyPermissions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_KeyContainer_OperatorSessionKeyPermissions*>(&from));
}

void License_KeyContainer_OperatorSessionKeyPermissions::MergeFrom(const License_KeyContainer_OperatorSessionKeyPermissions& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_allow_encrypt()) {
            set_allow_encrypt(from.allow_encrypt());
        }

        if (from.has_allow_decrypt()) {
            set_allow_decrypt(from.allow_decrypt());
        }

        if (from.has_allow_sign()) {
            set_allow_sign(from.allow_sign());
        }

        if (from.has_allow_signature_verify()) {
            set_allow_signature_verify(from.allow_signature_verify());
        }
    }
}

void License_KeyContainer_OperatorSessionKeyPermissions::CopyFrom(const License_KeyContainer_OperatorSessionKeyPermissions& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_KeyContainer_OperatorSessionKeyPermissions::IsInitialized() const
{
    return true;
}

void License_KeyContainer_OperatorSessionKeyPermissions::Swap(License_KeyContainer_OperatorSessionKeyPermissions* other)
{
    if (other != this) {
        std::swap(allow_encrypt_, other->allow_encrypt_);
        std::swap(allow_decrypt_, other->allow_decrypt_);
        std::swap(allow_sign_, other->allow_sign_);
        std::swap(allow_signature_verify_, other->allow_signature_verify_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_KeyContainer_OperatorSessionKeyPermissions::GetTypeName() const
{
    return "video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int License_KeyContainer::kIdFieldNumber;
const int License_KeyContainer::kIvFieldNumber;
const int License_KeyContainer::kKeyFieldNumber;
const int License_KeyContainer::kTypeFieldNumber;
const int License_KeyContainer::kLevelFieldNumber;
const int License_KeyContainer::kRequiredProtectionFieldNumber;
const int License_KeyContainer::kRequestedProtectionFieldNumber;
const int License_KeyContainer::kKeyControlFieldNumber;
const int License_KeyContainer::kOperatorSessionKeyPermissionsFieldNumber;
const int License_KeyContainer::kVideoResolutionConstraintsFieldNumber;
#endif  // !_MSC_VER

License_KeyContainer::License_KeyContainer()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License_KeyContainer::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    required_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(
                               ::video_widevine_server::sdk::License_KeyContainer_OutputProtection::internal_default_instance());
#else
    required_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(&::video_widevine_server::sdk::License_KeyContainer_OutputProtection::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    requested_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(
                                ::video_widevine_server::sdk::License_KeyContainer_OutputProtection::internal_default_instance());
#else
    requested_protection_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OutputProtection*>(&::video_widevine_server::sdk::License_KeyContainer_OutputProtection::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    key_control_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_KeyControl*>(
                       ::video_widevine_server::sdk::License_KeyContainer_KeyControl::internal_default_instance());
#else
    key_control_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_KeyControl*>(&::video_widevine_server::sdk::License_KeyContainer_KeyControl::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    operator_session_key_permissions_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions*>(
                                            ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions::internal_default_instance());
#else
    operator_session_key_permissions_ = const_cast< ::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions*>(&::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions::default_instance());
#endif
}

License_KeyContainer::License_KeyContainer(const License_KeyContainer& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License_KeyContainer::SharedCtor()
{
    _cached_size_ = 0;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    type_ = 1;
    level_ = 1;
    required_protection_ = NULL;
    requested_protection_ = NULL;
    key_control_ = NULL;
    operator_session_key_permissions_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License_KeyContainer::~License_KeyContainer()
{
    SharedDtor();
}

void License_KeyContainer::SharedDtor()
{
    if (id_ != &::google::protobuf::internal::kEmptyString) {
        delete id_;
    }

    if (iv_ != &::google::protobuf::internal::kEmptyString) {
        delete iv_;
    }

    if (key_ != &::google::protobuf::internal::kEmptyString) {
        delete key_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete required_protection_;
        delete requested_protection_;
        delete key_control_;
        delete operator_session_key_permissions_;
    }
}

void License_KeyContainer::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License_KeyContainer& License_KeyContainer::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License_KeyContainer* License_KeyContainer::default_instance_ = NULL;

License_KeyContainer* License_KeyContainer::New() const
{
    return new License_KeyContainer;
}

void License_KeyContainer::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_id()) {
            if (id_ != &::google::protobuf::internal::kEmptyString) {
                id_->clear();
            }
        }

        if (has_iv()) {
            if (iv_ != &::google::protobuf::internal::kEmptyString) {
                iv_->clear();
            }
        }

        if (has_key()) {
            if (key_ != &::google::protobuf::internal::kEmptyString) {
                key_->clear();
            }
        }

        type_ = 1;
        level_ = 1;

        if (has_required_protection()) {
            if (required_protection_ != NULL) required_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
        }

        if (has_requested_protection()) {
            if (requested_protection_ != NULL) requested_protection_->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::Clear();
        }

        if (has_key_control()) {
            if (key_control_ != NULL) key_control_->::video_widevine_server::sdk::License_KeyContainer_KeyControl::Clear();
        }
    }

    if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        if (has_operator_session_key_permissions()) {
            if (operator_session_key_permissions_ != NULL) operator_session_key_permissions_->::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions::Clear();
        }
    }

    video_resolution_constraints_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License_KeyContainer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_iv;

                break;
            }

            // optional bytes iv = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_iv:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_iv()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_key;

                break;
            }

            // optional bytes key = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_type;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.KeyType type = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::License_KeyContainer_KeyType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::License_KeyContainer_KeyType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_level;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_level:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::License_KeyContainer_SecurityLevel_IsValid(value)) {
                        set_level(static_cast< ::video_widevine_server::sdk::License_KeyContainer_SecurityLevel >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_required_protection;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_required_protection:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_required_protection()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(58)) goto parse_requested_protection;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection requested_protection = 7;
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_requested_protection:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_requested_protection()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(66)) goto parse_key_control;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.KeyControl key_control = 8;
            case 8: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_key_control:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_key_control()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(74)) goto parse_operator_session_key_permissions;

                break;
            }

            // optional .video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
            case 9: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_operator_session_key_permissions:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_operator_session_key_permissions()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(82)) goto parse_video_resolution_constraints;

                break;
            }

            // repeated .video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
            case 10: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_video_resolution_constraints:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, add_video_resolution_constraints()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(82)) goto parse_video_resolution_constraints;

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License_KeyContainer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes id = 1;
    if (has_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->id(), output);
    }

    // optional bytes iv = 2;
    if (has_iv()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->iv(), output);
    }

    // optional bytes key = 3;
    if (has_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->key(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.KeyType type = 4;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->type(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
    if (has_level()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            5, this->level(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 6;
    if (has_required_protection()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            6, this->required_protection(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection requested_protection = 7;
    if (has_requested_protection()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            7, this->requested_protection(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.KeyControl key_control = 8;
    if (has_key_control()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            8, this->key_control(), output);
    }

    // optional .video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
    if (has_operator_session_key_permissions()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            9, this->operator_session_key_permissions(), output);
    }

    // repeated .video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
    for (int i = 0; i < this->video_resolution_constraints_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            10, this->video_resolution_constraints(i), output);
    }
}

int License_KeyContainer::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes id = 1;
        if (has_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->id());
        }

        // optional bytes iv = 2;
        if (has_iv()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->iv());
        }

        // optional bytes key = 3;
        if (has_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->key());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.KeyType type = 4;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
        if (has_level()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->level());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection required_protection = 6;
        if (has_required_protection()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->required_protection());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.OutputProtection requested_protection = 7;
        if (has_requested_protection()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->requested_protection());
        }

        // optional .video_widevine_server.sdk.License.KeyContainer.KeyControl key_control = 8;
        if (has_key_control()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->key_control());
        }
    }

    if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        // optional .video_widevine_server.sdk.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
        if (has_operator_session_key_permissions()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->operator_session_key_permissions());
        }
    }

    // repeated .video_widevine_server.sdk.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
    total_size += 1 * this->video_resolution_constraints_size();

    for (int i = 0; i < this->video_resolution_constraints_size(); i++) {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->video_resolution_constraints(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License_KeyContainer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License_KeyContainer*>(&from));
}

void License_KeyContainer::MergeFrom(const License_KeyContainer& from)
{
    GOOGLE_CHECK_NE(&from, this);
    video_resolution_constraints_.MergeFrom(from.video_resolution_constraints_);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_id()) {
            set_id(from.id());
        }

        if (from.has_iv()) {
            set_iv(from.iv());
        }

        if (from.has_key()) {
            set_key(from.key());
        }

        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_level()) {
            set_level(from.level());
        }

        if (from.has_required_protection()) {
            mutable_required_protection()->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::MergeFrom(from.required_protection());
        }

        if (from.has_requested_protection()) {
            mutable_requested_protection()->::video_widevine_server::sdk::License_KeyContainer_OutputProtection::MergeFrom(from.requested_protection());
        }

        if (from.has_key_control()) {
            mutable_key_control()->::video_widevine_server::sdk::License_KeyContainer_KeyControl::MergeFrom(from.key_control());
        }
    }

    if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
        if (from.has_operator_session_key_permissions()) {
            mutable_operator_session_key_permissions()->::video_widevine_server::sdk::License_KeyContainer_OperatorSessionKeyPermissions::MergeFrom(from.operator_session_key_permissions());
        }
    }
}

void License_KeyContainer::CopyFrom(const License_KeyContainer& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License_KeyContainer::IsInitialized() const
{
    return true;
}

void License_KeyContainer::Swap(License_KeyContainer* other)
{
    if (other != this) {
        std::swap(id_, other->id_);
        std::swap(iv_, other->iv_);
        std::swap(key_, other->key_);
        std::swap(type_, other->type_);
        std::swap(level_, other->level_);
        std::swap(required_protection_, other->required_protection_);
        std::swap(requested_protection_, other->requested_protection_);
        std::swap(key_control_, other->key_control_);
        std::swap(operator_session_key_permissions_, other->operator_session_key_permissions_);
        video_resolution_constraints_.Swap(&other->video_resolution_constraints_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License_KeyContainer::GetTypeName() const
{
    return "video_widevine_server.sdk.License.KeyContainer";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int License::kIdFieldNumber;
const int License::kPolicyFieldNumber;
const int License::kKeyFieldNumber;
const int License::kLicenseStartTimeFieldNumber;
const int License::kRemoteAttestationVerifiedFieldNumber;
const int License::kProviderClientTokenFieldNumber;
#endif  // !_MSC_VER

License::License()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void License::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(
              ::video_widevine_server::sdk::LicenseIdentification::internal_default_instance());
#else
    id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(&::video_widevine_server::sdk::LicenseIdentification::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    policy_ = const_cast< ::video_widevine_server::sdk::License_Policy*>(
                  ::video_widevine_server::sdk::License_Policy::internal_default_instance());
#else
    policy_ = const_cast< ::video_widevine_server::sdk::License_Policy*>(&::video_widevine_server::sdk::License_Policy::default_instance());
#endif
}

License::License(const License& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void License::SharedCtor()
{
    _cached_size_ = 0;
    id_ = NULL;
    policy_ = NULL;
    license_start_time_ = GOOGLE_LONGLONG(0);
    remote_attestation_verified_ = false;
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

License::~License()
{
    SharedDtor();
}

void License::SharedDtor()
{
    if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
        delete provider_client_token_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete id_;
        delete policy_;
    }
}

void License::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const License& License::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

License* License::default_instance_ = NULL;

License* License::New() const
{
    return new License;
}

void License::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_id()) {
            if (id_ != NULL) id_->::video_widevine_server::sdk::LicenseIdentification::Clear();
        }

        if (has_policy()) {
            if (policy_ != NULL) policy_->::video_widevine_server::sdk::License_Policy::Clear();
        }

        license_start_time_ = GOOGLE_LONGLONG(0);
        remote_attestation_verified_ = false;

        if (has_provider_client_token()) {
            if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
                provider_client_token_->clear();
            }
        }
    }

    key_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool License::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.LicenseIdentification id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_policy;

                break;
            }

            // optional .video_widevine_server.sdk.License.Policy policy = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_policy:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_policy()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_key;

                break;
            }

            // repeated .video_widevine_server.sdk.License.KeyContainer key = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, add_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_key;

                if (input->ExpectTag(32)) goto parse_license_start_time;

                break;
            }

            // optional int64 license_start_time = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_start_time:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &license_start_time_)));
                    set_has_license_start_time();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_remote_attestation_verified;

                break;
            }

            // optional bool remote_attestation_verified = 5 [default = false];
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_remote_attestation_verified:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &remote_attestation_verified_)));
                    set_has_remote_attestation_verified();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_provider_client_token;

                break;
            }

            // optional bytes provider_client_token = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_provider_client_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_provider_client_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void License::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.LicenseIdentification id = 1;
    if (has_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->id(), output);
    }

    // optional .video_widevine_server.sdk.License.Policy policy = 2;
    if (has_policy()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, this->policy(), output);
    }

    // repeated .video_widevine_server.sdk.License.KeyContainer key = 3;
    for (int i = 0; i < this->key_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->key(i), output);
    }

    // optional int64 license_start_time = 4;
    if (has_license_start_time()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->license_start_time(), output);
    }

    // optional bool remote_attestation_verified = 5 [default = false];
    if (has_remote_attestation_verified()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->remote_attestation_verified(), output);
    }

    // optional bytes provider_client_token = 6;
    if (has_provider_client_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            6, this->provider_client_token(), output);
    }
}

int License::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.LicenseIdentification id = 1;
        if (has_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->id());
        }

        // optional .video_widevine_server.sdk.License.Policy policy = 2;
        if (has_policy()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->policy());
        }

        // optional int64 license_start_time = 4;
        if (has_license_start_time()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->license_start_time());
        }

        // optional bool remote_attestation_verified = 5 [default = false];
        if (has_remote_attestation_verified()) {
            total_size += 1 + 1;
        }

        // optional bytes provider_client_token = 6;
        if (has_provider_client_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->provider_client_token());
        }
    }

    // repeated .video_widevine_server.sdk.License.KeyContainer key = 3;
    total_size += 1 * this->key_size();

    for (int i = 0; i < this->key_size(); i++) {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->key(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void License::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const License*>(&from));
}

void License::MergeFrom(const License& from)
{
    GOOGLE_CHECK_NE(&from, this);
    key_.MergeFrom(from.key_);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_id()) {
            mutable_id()->::video_widevine_server::sdk::LicenseIdentification::MergeFrom(from.id());
        }

        if (from.has_policy()) {
            mutable_policy()->::video_widevine_server::sdk::License_Policy::MergeFrom(from.policy());
        }

        if (from.has_license_start_time()) {
            set_license_start_time(from.license_start_time());
        }

        if (from.has_remote_attestation_verified()) {
            set_remote_attestation_verified(from.remote_attestation_verified());
        }

        if (from.has_provider_client_token()) {
            set_provider_client_token(from.provider_client_token());
        }
    }
}

void License::CopyFrom(const License& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool License::IsInitialized() const
{
    return true;
}

void License::Swap(License* other)
{
    if (other != this) {
        std::swap(id_, other->id_);
        std::swap(policy_, other->policy_);
        key_.Swap(&other->key_);
        std::swap(license_start_time_, other->license_start_time_);
        std::swap(remote_attestation_verified_, other->remote_attestation_verified_);
        std::swap(provider_client_token_, other->provider_client_token_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string License::GetTypeName() const
{
    return "video_widevine_server.sdk.License";
}


// ===================================================================

bool LicenseRequest_RequestType_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const LicenseRequest_RequestType LicenseRequest::NEW;
const LicenseRequest_RequestType LicenseRequest::RENEWAL;
const LicenseRequest_RequestType LicenseRequest::RELEASE;
const LicenseRequest_RequestType LicenseRequest::RequestType_MIN;
const LicenseRequest_RequestType LicenseRequest::RequestType_MAX;
const int LicenseRequest::RequestType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LicenseRequest_ContentIdentification_CENC::kPsshFieldNumber;
const int LicenseRequest_ContentIdentification_CENC::kLicenseTypeFieldNumber;
const int LicenseRequest_ContentIdentification_CENC::kRequestIdFieldNumber;
#endif  // !_MSC_VER

LicenseRequest_ContentIdentification_CENC::LicenseRequest_ContentIdentification_CENC()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseRequest_ContentIdentification_CENC::InitAsDefaultInstance()
{
}

LicenseRequest_ContentIdentification_CENC::LicenseRequest_ContentIdentification_CENC(const LicenseRequest_ContentIdentification_CENC& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseRequest_ContentIdentification_CENC::SharedCtor()
{
    _cached_size_ = 0;
    license_type_ = 1;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseRequest_ContentIdentification_CENC::~LicenseRequest_ContentIdentification_CENC()
{
    SharedDtor();
}

void LicenseRequest_ContentIdentification_CENC::SharedDtor()
{
    if (request_id_ != &::google::protobuf::internal::kEmptyString) {
        delete request_id_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void LicenseRequest_ContentIdentification_CENC::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseRequest_ContentIdentification_CENC& LicenseRequest_ContentIdentification_CENC::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseRequest_ContentIdentification_CENC* LicenseRequest_ContentIdentification_CENC::default_instance_ = NULL;

LicenseRequest_ContentIdentification_CENC* LicenseRequest_ContentIdentification_CENC::New() const
{
    return new LicenseRequest_ContentIdentification_CENC;
}

void LicenseRequest_ContentIdentification_CENC::Clear()
{
    if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
        license_type_ = 1;

        if (has_request_id()) {
            if (request_id_ != &::google::protobuf::internal::kEmptyString) {
                request_id_->clear();
            }
        }
    }

    pssh_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseRequest_ContentIdentification_CENC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // repeated bytes pssh = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_pssh:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->add_pssh()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(10)) goto parse_pssh;

                if (input->ExpectTag(16)) goto parse_license_type;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseType license_type = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::LicenseType_IsValid(value)) {
                        set_license_type(static_cast< ::video_widevine_server::sdk::LicenseType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_request_id;

                break;
            }

            // optional bytes request_id = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_request_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_request_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseRequest_ContentIdentification_CENC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // repeated bytes pssh = 1;
    for (int i = 0; i < this->pssh_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->pssh(i), output);
    }

    // optional .video_widevine_server.sdk.LicenseType license_type = 2;
    if (has_license_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->license_type(), output);
    }

    // optional bytes request_id = 3;
    if (has_request_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->request_id(), output);
    }
}

int LicenseRequest_ContentIdentification_CENC::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
        // optional .video_widevine_server.sdk.LicenseType license_type = 2;
        if (has_license_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->license_type());
        }

        // optional bytes request_id = 3;
        if (has_request_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->request_id());
        }
    }

    // repeated bytes pssh = 1;
    total_size += 1 * this->pssh_size();

    for (int i = 0; i < this->pssh_size(); i++) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
                          this->pssh(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseRequest_ContentIdentification_CENC::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseRequest_ContentIdentification_CENC*>(&from));
}

void LicenseRequest_ContentIdentification_CENC::MergeFrom(const LicenseRequest_ContentIdentification_CENC& from)
{
    GOOGLE_CHECK_NE(&from, this);
    pssh_.MergeFrom(from.pssh_);

    if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
        if (from.has_license_type()) {
            set_license_type(from.license_type());
        }

        if (from.has_request_id()) {
            set_request_id(from.request_id());
        }
    }
}

void LicenseRequest_ContentIdentification_CENC::CopyFrom(const LicenseRequest_ContentIdentification_CENC& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseRequest_ContentIdentification_CENC::IsInitialized() const
{
    return true;
}

void LicenseRequest_ContentIdentification_CENC::Swap(LicenseRequest_ContentIdentification_CENC* other)
{
    if (other != this) {
        pssh_.Swap(&other->pssh_);
        std::swap(license_type_, other->license_type_);
        std::swap(request_id_, other->request_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseRequest_ContentIdentification_CENC::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LicenseRequest_ContentIdentification_WebM::kHeaderFieldNumber;
const int LicenseRequest_ContentIdentification_WebM::kLicenseTypeFieldNumber;
const int LicenseRequest_ContentIdentification_WebM::kRequestIdFieldNumber;
#endif  // !_MSC_VER

LicenseRequest_ContentIdentification_WebM::LicenseRequest_ContentIdentification_WebM()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseRequest_ContentIdentification_WebM::InitAsDefaultInstance()
{
}

LicenseRequest_ContentIdentification_WebM::LicenseRequest_ContentIdentification_WebM(const LicenseRequest_ContentIdentification_WebM& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseRequest_ContentIdentification_WebM::SharedCtor()
{
    _cached_size_ = 0;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_type_ = 1;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseRequest_ContentIdentification_WebM::~LicenseRequest_ContentIdentification_WebM()
{
    SharedDtor();
}

void LicenseRequest_ContentIdentification_WebM::SharedDtor()
{
    if (header_ != &::google::protobuf::internal::kEmptyString) {
        delete header_;
    }

    if (request_id_ != &::google::protobuf::internal::kEmptyString) {
        delete request_id_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void LicenseRequest_ContentIdentification_WebM::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseRequest_ContentIdentification_WebM& LicenseRequest_ContentIdentification_WebM::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseRequest_ContentIdentification_WebM* LicenseRequest_ContentIdentification_WebM::default_instance_ = NULL;

LicenseRequest_ContentIdentification_WebM* LicenseRequest_ContentIdentification_WebM::New() const
{
    return new LicenseRequest_ContentIdentification_WebM;
}

void LicenseRequest_ContentIdentification_WebM::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_header()) {
            if (header_ != &::google::protobuf::internal::kEmptyString) {
                header_->clear();
            }
        }

        license_type_ = 1;

        if (has_request_id()) {
            if (request_id_ != &::google::protobuf::internal::kEmptyString) {
                request_id_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseRequest_ContentIdentification_WebM::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes header = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_header()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_license_type;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseType license_type = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::LicenseType_IsValid(value)) {
                        set_license_type(static_cast< ::video_widevine_server::sdk::LicenseType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_request_id;

                break;
            }

            // optional bytes request_id = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_request_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_request_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseRequest_ContentIdentification_WebM::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes header = 1;
    if (has_header()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->header(), output);
    }

    // optional .video_widevine_server.sdk.LicenseType license_type = 2;
    if (has_license_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->license_type(), output);
    }

    // optional bytes request_id = 3;
    if (has_request_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->request_id(), output);
    }
}

int LicenseRequest_ContentIdentification_WebM::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes header = 1;
        if (has_header()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->header());
        }

        // optional .video_widevine_server.sdk.LicenseType license_type = 2;
        if (has_license_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->license_type());
        }

        // optional bytes request_id = 3;
        if (has_request_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->request_id());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseRequest_ContentIdentification_WebM::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseRequest_ContentIdentification_WebM*>(&from));
}

void LicenseRequest_ContentIdentification_WebM::MergeFrom(const LicenseRequest_ContentIdentification_WebM& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_header()) {
            set_header(from.header());
        }

        if (from.has_license_type()) {
            set_license_type(from.license_type());
        }

        if (from.has_request_id()) {
            set_request_id(from.request_id());
        }
    }
}

void LicenseRequest_ContentIdentification_WebM::CopyFrom(const LicenseRequest_ContentIdentification_WebM& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseRequest_ContentIdentification_WebM::IsInitialized() const
{
    return true;
}

void LicenseRequest_ContentIdentification_WebM::Swap(LicenseRequest_ContentIdentification_WebM* other)
{
    if (other != this) {
        std::swap(header_, other->header_);
        std::swap(license_type_, other->license_type_);
        std::swap(request_id_, other->request_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseRequest_ContentIdentification_WebM::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LicenseRequest_ContentIdentification_ExistingLicense::kLicenseIdFieldNumber;
const int LicenseRequest_ContentIdentification_ExistingLicense::kSecondsSinceStartedFieldNumber;
const int LicenseRequest_ContentIdentification_ExistingLicense::kSecondsSinceLastPlayedFieldNumber;
const int LicenseRequest_ContentIdentification_ExistingLicense::kSessionUsageTableEntryFieldNumber;
#endif  // !_MSC_VER

LicenseRequest_ContentIdentification_ExistingLicense::LicenseRequest_ContentIdentification_ExistingLicense()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseRequest_ContentIdentification_ExistingLicense::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    license_id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(
                      ::video_widevine_server::sdk::LicenseIdentification::internal_default_instance());
#else
    license_id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(&::video_widevine_server::sdk::LicenseIdentification::default_instance());
#endif
}

LicenseRequest_ContentIdentification_ExistingLicense::LicenseRequest_ContentIdentification_ExistingLicense(const LicenseRequest_ContentIdentification_ExistingLicense& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseRequest_ContentIdentification_ExistingLicense::SharedCtor()
{
    _cached_size_ = 0;
    license_id_ = NULL;
    seconds_since_started_ = GOOGLE_LONGLONG(0);
    seconds_since_last_played_ = GOOGLE_LONGLONG(0);
    session_usage_table_entry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseRequest_ContentIdentification_ExistingLicense::~LicenseRequest_ContentIdentification_ExistingLicense()
{
    SharedDtor();
}

void LicenseRequest_ContentIdentification_ExistingLicense::SharedDtor()
{
    if (session_usage_table_entry_ != &::google::protobuf::internal::kEmptyString) {
        delete session_usage_table_entry_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete license_id_;
    }
}

void LicenseRequest_ContentIdentification_ExistingLicense::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseRequest_ContentIdentification_ExistingLicense& LicenseRequest_ContentIdentification_ExistingLicense::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseRequest_ContentIdentification_ExistingLicense* LicenseRequest_ContentIdentification_ExistingLicense::default_instance_ = NULL;

LicenseRequest_ContentIdentification_ExistingLicense* LicenseRequest_ContentIdentification_ExistingLicense::New() const
{
    return new LicenseRequest_ContentIdentification_ExistingLicense;
}

void LicenseRequest_ContentIdentification_ExistingLicense::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_license_id()) {
            if (license_id_ != NULL) license_id_->::video_widevine_server::sdk::LicenseIdentification::Clear();
        }

        seconds_since_started_ = GOOGLE_LONGLONG(0);
        seconds_since_last_played_ = GOOGLE_LONGLONG(0);

        if (has_session_usage_table_entry()) {
            if (session_usage_table_entry_ != &::google::protobuf::internal::kEmptyString) {
                session_usage_table_entry_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseRequest_ContentIdentification_ExistingLicense::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_license_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_seconds_since_started;

                break;
            }

            // optional int64 seconds_since_started = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_seconds_since_started:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &seconds_since_started_)));
                    set_has_seconds_since_started();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_seconds_since_last_played;

                break;
            }

            // optional int64 seconds_since_last_played = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_seconds_since_last_played:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &seconds_since_last_played_)));
                    set_has_seconds_since_last_played();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_session_usage_table_entry;

                break;
            }

            // optional bytes session_usage_table_entry = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_session_usage_table_entry:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_session_usage_table_entry()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseRequest_ContentIdentification_ExistingLicense::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
    if (has_license_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->license_id(), output);
    }

    // optional int64 seconds_since_started = 2;
    if (has_seconds_since_started()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->seconds_since_started(), output);
    }

    // optional int64 seconds_since_last_played = 3;
    if (has_seconds_since_last_played()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->seconds_since_last_played(), output);
    }

    // optional bytes session_usage_table_entry = 4;
    if (has_session_usage_table_entry()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->session_usage_table_entry(), output);
    }
}

int LicenseRequest_ContentIdentification_ExistingLicense::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
        if (has_license_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->license_id());
        }

        // optional int64 seconds_since_started = 2;
        if (has_seconds_since_started()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->seconds_since_started());
        }

        // optional int64 seconds_since_last_played = 3;
        if (has_seconds_since_last_played()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->seconds_since_last_played());
        }

        // optional bytes session_usage_table_entry = 4;
        if (has_session_usage_table_entry()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->session_usage_table_entry());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseRequest_ContentIdentification_ExistingLicense::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseRequest_ContentIdentification_ExistingLicense*>(&from));
}

void LicenseRequest_ContentIdentification_ExistingLicense::MergeFrom(const LicenseRequest_ContentIdentification_ExistingLicense& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_license_id()) {
            mutable_license_id()->::video_widevine_server::sdk::LicenseIdentification::MergeFrom(from.license_id());
        }

        if (from.has_seconds_since_started()) {
            set_seconds_since_started(from.seconds_since_started());
        }

        if (from.has_seconds_since_last_played()) {
            set_seconds_since_last_played(from.seconds_since_last_played());
        }

        if (from.has_session_usage_table_entry()) {
            set_session_usage_table_entry(from.session_usage_table_entry());
        }
    }
}

void LicenseRequest_ContentIdentification_ExistingLicense::CopyFrom(const LicenseRequest_ContentIdentification_ExistingLicense& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseRequest_ContentIdentification_ExistingLicense::IsInitialized() const
{
    return true;
}

void LicenseRequest_ContentIdentification_ExistingLicense::Swap(LicenseRequest_ContentIdentification_ExistingLicense* other)
{
    if (other != this) {
        std::swap(license_id_, other->license_id_);
        std::swap(seconds_since_started_, other->seconds_since_started_);
        std::swap(seconds_since_last_played_, other->seconds_since_last_played_);
        std::swap(session_usage_table_entry_, other->session_usage_table_entry_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseRequest_ContentIdentification_ExistingLicense::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LicenseRequest_ContentIdentification::kCencIdFieldNumber;
const int LicenseRequest_ContentIdentification::kWebmIdFieldNumber;
const int LicenseRequest_ContentIdentification::kLicenseFieldNumber;
#endif  // !_MSC_VER

LicenseRequest_ContentIdentification::LicenseRequest_ContentIdentification()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseRequest_ContentIdentification::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    cenc_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC*>(
                   ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC::internal_default_instance());
#else
    cenc_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC*>(&::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    webm_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM*>(
                   ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM::internal_default_instance());
#else
    webm_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM*>(&::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    license_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense*>(
                   ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense::internal_default_instance());
#else
    license_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense*>(&::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense::default_instance());
#endif
}

LicenseRequest_ContentIdentification::LicenseRequest_ContentIdentification(const LicenseRequest_ContentIdentification& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseRequest_ContentIdentification::SharedCtor()
{
    _cached_size_ = 0;
    cenc_id_ = NULL;
    webm_id_ = NULL;
    license_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseRequest_ContentIdentification::~LicenseRequest_ContentIdentification()
{
    SharedDtor();
}

void LicenseRequest_ContentIdentification::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete cenc_id_;
        delete webm_id_;
        delete license_;
    }
}

void LicenseRequest_ContentIdentification::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseRequest_ContentIdentification& LicenseRequest_ContentIdentification::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseRequest_ContentIdentification* LicenseRequest_ContentIdentification::default_instance_ = NULL;

LicenseRequest_ContentIdentification* LicenseRequest_ContentIdentification::New() const
{
    return new LicenseRequest_ContentIdentification;
}

void LicenseRequest_ContentIdentification::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_cenc_id()) {
            if (cenc_id_ != NULL) cenc_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC::Clear();
        }

        if (has_webm_id()) {
            if (webm_id_ != NULL) webm_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM::Clear();
        }

        if (has_license()) {
            if (license_ != NULL) license_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseRequest_ContentIdentification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC cenc_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_cenc_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_webm_id;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM webm_id = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_webm_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_webm_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_license;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense license = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_license:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_license()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseRequest_ContentIdentification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC cenc_id = 1;
    if (has_cenc_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->cenc_id(), output);
    }

    // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM webm_id = 2;
    if (has_webm_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, this->webm_id(), output);
    }

    // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense license = 3;
    if (has_license()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->license(), output);
    }
}

int LicenseRequest_ContentIdentification::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.CENC cenc_id = 1;
        if (has_cenc_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->cenc_id());
        }

        // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.WebM webm_id = 2;
        if (has_webm_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->webm_id());
        }

        // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification.ExistingLicense license = 3;
        if (has_license()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->license());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseRequest_ContentIdentification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseRequest_ContentIdentification*>(&from));
}

void LicenseRequest_ContentIdentification::MergeFrom(const LicenseRequest_ContentIdentification& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_cenc_id()) {
            mutable_cenc_id()->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_CENC::MergeFrom(from.cenc_id());
        }

        if (from.has_webm_id()) {
            mutable_webm_id()->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_WebM::MergeFrom(from.webm_id());
        }

        if (from.has_license()) {
            mutable_license()->::video_widevine_server::sdk::LicenseRequest_ContentIdentification_ExistingLicense::MergeFrom(from.license());
        }
    }
}

void LicenseRequest_ContentIdentification::CopyFrom(const LicenseRequest_ContentIdentification& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseRequest_ContentIdentification::IsInitialized() const
{
    return true;
}

void LicenseRequest_ContentIdentification::Swap(LicenseRequest_ContentIdentification* other)
{
    if (other != this) {
        std::swap(cenc_id_, other->cenc_id_);
        std::swap(webm_id_, other->webm_id_);
        std::swap(license_, other->license_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseRequest_ContentIdentification::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseRequest.ContentIdentification";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LicenseRequest::kClientIdFieldNumber;
const int LicenseRequest::kContentIdFieldNumber;
const int LicenseRequest::kTypeFieldNumber;
const int LicenseRequest::kRequestTimeFieldNumber;
const int LicenseRequest::kKeyControlNonceDeprecatedFieldNumber;
const int LicenseRequest::kProtocolVersionFieldNumber;
const int LicenseRequest::kKeyControlNonceFieldNumber;
const int LicenseRequest::kEncryptedClientIdFieldNumber;
#endif  // !_MSC_VER

LicenseRequest::LicenseRequest()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_id_ = const_cast< ::video_widevine_server::sdk::ClientIdentification*>(
                     ::video_widevine_server::sdk::ClientIdentification::internal_default_instance());
#else
    client_id_ = const_cast< ::video_widevine_server::sdk::ClientIdentification*>(&::video_widevine_server::sdk::ClientIdentification::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    content_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification*>(
                      ::video_widevine_server::sdk::LicenseRequest_ContentIdentification::internal_default_instance());
#else
    content_id_ = const_cast< ::video_widevine_server::sdk::LicenseRequest_ContentIdentification*>(&::video_widevine_server::sdk::LicenseRequest_ContentIdentification::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    encrypted_client_id_ = const_cast< ::video_widevine_server::sdk::EncryptedClientIdentification*>(
                               ::video_widevine_server::sdk::EncryptedClientIdentification::internal_default_instance());
#else
    encrypted_client_id_ = const_cast< ::video_widevine_server::sdk::EncryptedClientIdentification*>(&::video_widevine_server::sdk::EncryptedClientIdentification::default_instance());
#endif
}

LicenseRequest::LicenseRequest(const LicenseRequest& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseRequest::SharedCtor()
{
    _cached_size_ = 0;
    client_id_ = NULL;
    content_id_ = NULL;
    type_ = 1;
    request_time_ = GOOGLE_LONGLONG(0);
    key_control_nonce_deprecated_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    protocol_version_ = 20;
    key_control_nonce_ = 0u;
    encrypted_client_id_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseRequest::~LicenseRequest()
{
    SharedDtor();
}

void LicenseRequest::SharedDtor()
{
    if (key_control_nonce_deprecated_ != &::google::protobuf::internal::kEmptyString) {
        delete key_control_nonce_deprecated_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete client_id_;
        delete content_id_;
        delete encrypted_client_id_;
    }
}

void LicenseRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseRequest& LicenseRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseRequest* LicenseRequest::default_instance_ = NULL;

LicenseRequest* LicenseRequest::New() const
{
    return new LicenseRequest;
}

void LicenseRequest::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_client_id()) {
            if (client_id_ != NULL) client_id_->::video_widevine_server::sdk::ClientIdentification::Clear();
        }

        if (has_content_id()) {
            if (content_id_ != NULL) content_id_->::video_widevine_server::sdk::LicenseRequest_ContentIdentification::Clear();
        }

        type_ = 1;
        request_time_ = GOOGLE_LONGLONG(0);

        if (has_key_control_nonce_deprecated()) {
            if (key_control_nonce_deprecated_ != &::google::protobuf::internal::kEmptyString) {
                key_control_nonce_deprecated_->clear();
            }
        }

        protocol_version_ = 20;
        key_control_nonce_ = 0u;

        if (has_encrypted_client_id()) {
            if (encrypted_client_id_ != NULL) encrypted_client_id_->::video_widevine_server::sdk::EncryptedClientIdentification::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_client_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_content_id;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification content_id = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_content_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_content_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_type;

                break;
            }

            // optional .video_widevine_server.sdk.LicenseRequest.RequestType type = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_type:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::LicenseRequest_RequestType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::LicenseRequest_RequestType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_request_time;

                break;
            }

            // optional int64 request_time = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_request_time:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &request_time_)));
                    set_has_request_time();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_key_control_nonce_deprecated;

                break;
            }

            // optional bytes key_control_nonce_deprecated = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_key_control_nonce_deprecated:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_key_control_nonce_deprecated()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(48)) goto parse_protocol_version;

                break;
            }

            // optional .video_widevine_server.sdk.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_protocol_version:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::ProtocolVersion_IsValid(value)) {
                        set_protocol_version(static_cast< ::video_widevine_server::sdk::ProtocolVersion >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(56)) goto parse_key_control_nonce;

                break;
            }

            // optional uint32 key_control_nonce = 7;
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_key_control_nonce:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &key_control_nonce_)));
                    set_has_key_control_nonce();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(66)) goto parse_encrypted_client_id;

                break;
            }

            // optional .video_widevine_server.sdk.EncryptedClientIdentification encrypted_client_id = 8;
            case 8: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_encrypted_client_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_encrypted_client_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
    if (has_client_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->client_id(), output);
    }

    // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification content_id = 2;
    if (has_content_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, this->content_id(), output);
    }

    // optional .video_widevine_server.sdk.LicenseRequest.RequestType type = 3;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            3, this->type(), output);
    }

    // optional int64 request_time = 4;
    if (has_request_time()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->request_time(), output);
    }

    // optional bytes key_control_nonce_deprecated = 5;
    if (has_key_control_nonce_deprecated()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            5, this->key_control_nonce_deprecated(), output);
    }

    // optional .video_widevine_server.sdk.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
    if (has_protocol_version()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            6, this->protocol_version(), output);
    }

    // optional uint32 key_control_nonce = 7;
    if (has_key_control_nonce()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->key_control_nonce(), output);
    }

    // optional .video_widevine_server.sdk.EncryptedClientIdentification encrypted_client_id = 8;
    if (has_encrypted_client_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            8, this->encrypted_client_id(), output);
    }
}

int LicenseRequest::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
        if (has_client_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->client_id());
        }

        // optional .video_widevine_server.sdk.LicenseRequest.ContentIdentification content_id = 2;
        if (has_content_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->content_id());
        }

        // optional .video_widevine_server.sdk.LicenseRequest.RequestType type = 3;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional int64 request_time = 4;
        if (has_request_time()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->request_time());
        }

        // optional bytes key_control_nonce_deprecated = 5;
        if (has_key_control_nonce_deprecated()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->key_control_nonce_deprecated());
        }

        // optional .video_widevine_server.sdk.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
        if (has_protocol_version()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol_version());
        }

        // optional uint32 key_control_nonce = 7;
        if (has_key_control_nonce()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->key_control_nonce());
        }

        // optional .video_widevine_server.sdk.EncryptedClientIdentification encrypted_client_id = 8;
        if (has_encrypted_client_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->encrypted_client_id());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseRequest*>(&from));
}

void LicenseRequest::MergeFrom(const LicenseRequest& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client_id()) {
            mutable_client_id()->::video_widevine_server::sdk::ClientIdentification::MergeFrom(from.client_id());
        }

        if (from.has_content_id()) {
            mutable_content_id()->::video_widevine_server::sdk::LicenseRequest_ContentIdentification::MergeFrom(from.content_id());
        }

        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_request_time()) {
            set_request_time(from.request_time());
        }

        if (from.has_key_control_nonce_deprecated()) {
            set_key_control_nonce_deprecated(from.key_control_nonce_deprecated());
        }

        if (from.has_protocol_version()) {
            set_protocol_version(from.protocol_version());
        }

        if (from.has_key_control_nonce()) {
            set_key_control_nonce(from.key_control_nonce());
        }

        if (from.has_encrypted_client_id()) {
            mutable_encrypted_client_id()->::video_widevine_server::sdk::EncryptedClientIdentification::MergeFrom(from.encrypted_client_id());
        }
    }
}

void LicenseRequest::CopyFrom(const LicenseRequest& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseRequest::IsInitialized() const
{
    return true;
}

void LicenseRequest::Swap(LicenseRequest* other)
{
    if (other != this) {
        std::swap(client_id_, other->client_id_);
        std::swap(content_id_, other->content_id_);
        std::swap(type_, other->type_);
        std::swap(request_time_, other->request_time_);
        std::swap(key_control_nonce_deprecated_, other->key_control_nonce_deprecated_);
        std::swap(protocol_version_, other->protocol_version_);
        std::swap(key_control_nonce_, other->key_control_nonce_);
        std::swap(encrypted_client_id_, other->encrypted_client_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseRequest::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseRequest";
}


// ===================================================================

bool LicenseError_Error_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const LicenseError_Error LicenseError::INVALID_DEVICE_CERTIFICATE;
const LicenseError_Error LicenseError::REVOKED_DEVICE_CERTIFICATE;
const LicenseError_Error LicenseError::SERVICE_UNAVAILABLE;
const LicenseError_Error LicenseError::Error_MIN;
const LicenseError_Error LicenseError::Error_MAX;
const int LicenseError::Error_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LicenseError::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

LicenseError::LicenseError()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void LicenseError::InitAsDefaultInstance()
{
}

LicenseError::LicenseError(const LicenseError& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void LicenseError::SharedCtor()
{
    _cached_size_ = 0;
    error_code_ = 1;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LicenseError::~LicenseError()
{
    SharedDtor();
}

void LicenseError::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void LicenseError::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LicenseError& LicenseError::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

LicenseError* LicenseError::default_instance_ = NULL;

LicenseError* LicenseError::New() const
{
    return new LicenseError;
}

void LicenseError::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        error_code_ = 1;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LicenseError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.LicenseError.Error error_code = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::LicenseError_Error_IsValid(value)) {
                        set_error_code(static_cast< ::video_widevine_server::sdk::LicenseError_Error >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void LicenseError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.LicenseError.Error error_code = 1;
    if (has_error_code()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->error_code(), output);
    }
}

int LicenseError::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.LicenseError.Error error_code = 1;
        if (has_error_code()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void LicenseError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const LicenseError*>(&from));
}

void LicenseError::MergeFrom(const LicenseError& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_error_code()) {
            set_error_code(from.error_code());
        }
    }
}

void LicenseError::CopyFrom(const LicenseError& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool LicenseError::IsInitialized() const
{
    return true;
}

void LicenseError::Swap(LicenseError* other)
{
    if (other != this) {
        std::swap(error_code_, other->error_code_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string LicenseError::GetTypeName() const
{
    return "video_widevine_server.sdk.LicenseError";
}


// ===================================================================

#ifndef _MSC_VER
const int RemoteAttestation::kCertificateFieldNumber;
const int RemoteAttestation::kSaltFieldNumber;
const int RemoteAttestation::kSignatureFieldNumber;
#endif  // !_MSC_VER

RemoteAttestation::RemoteAttestation()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void RemoteAttestation::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    certificate_ = const_cast< ::video_widevine_server::sdk::EncryptedClientIdentification*>(
                       ::video_widevine_server::sdk::EncryptedClientIdentification::internal_default_instance());
#else
    certificate_ = const_cast< ::video_widevine_server::sdk::EncryptedClientIdentification*>(&::video_widevine_server::sdk::EncryptedClientIdentification::default_instance());
#endif
}

RemoteAttestation::RemoteAttestation(const RemoteAttestation& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void RemoteAttestation::SharedCtor()
{
    _cached_size_ = 0;
    certificate_ = NULL;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoteAttestation::~RemoteAttestation()
{
    SharedDtor();
}

void RemoteAttestation::SharedDtor()
{
    if (salt_ != &::google::protobuf::internal::kEmptyString) {
        delete salt_;
    }

    if (signature_ != &::google::protobuf::internal::kEmptyString) {
        delete signature_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete certificate_;
    }
}

void RemoteAttestation::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RemoteAttestation& RemoteAttestation::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

RemoteAttestation* RemoteAttestation::default_instance_ = NULL;

RemoteAttestation* RemoteAttestation::New() const
{
    return new RemoteAttestation;
}

void RemoteAttestation::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_certificate()) {
            if (certificate_ != NULL) certificate_->::video_widevine_server::sdk::EncryptedClientIdentification::Clear();
        }

        if (has_salt()) {
            if (salt_ != &::google::protobuf::internal::kEmptyString) {
                salt_->clear();
            }
        }

        if (has_signature()) {
            if (signature_ != &::google::protobuf::internal::kEmptyString) {
                signature_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RemoteAttestation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.EncryptedClientIdentification certificate = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_certificate()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_salt;

                break;
            }

            // optional bytes salt = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_salt:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_salt()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_signature;

                break;
            }

            // optional bytes signature = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signature:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signature()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void RemoteAttestation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.EncryptedClientIdentification certificate = 1;
    if (has_certificate()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->certificate(), output);
    }

    // optional bytes salt = 2;
    if (has_salt()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->salt(), output);
    }

    // optional bytes signature = 3;
    if (has_signature()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->signature(), output);
    }
}

int RemoteAttestation::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.EncryptedClientIdentification certificate = 1;
        if (has_certificate()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->certificate());
        }

        // optional bytes salt = 2;
        if (has_salt()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->salt());
        }

        // optional bytes signature = 3;
        if (has_signature()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signature());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void RemoteAttestation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const RemoteAttestation*>(&from));
}

void RemoteAttestation::MergeFrom(const RemoteAttestation& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_certificate()) {
            mutable_certificate()->::video_widevine_server::sdk::EncryptedClientIdentification::MergeFrom(from.certificate());
        }

        if (from.has_salt()) {
            set_salt(from.salt());
        }

        if (from.has_signature()) {
            set_signature(from.signature());
        }
    }
}

void RemoteAttestation::CopyFrom(const RemoteAttestation& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool RemoteAttestation::IsInitialized() const
{
    return true;
}

void RemoteAttestation::Swap(RemoteAttestation* other)
{
    if (other != this) {
        std::swap(certificate_, other->certificate_);
        std::swap(salt_, other->salt_);
        std::swap(signature_, other->signature_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string RemoteAttestation::GetTypeName() const
{
    return "video_widevine_server.sdk.RemoteAttestation";
}


// ===================================================================

bool SignedMessage_MessageType_IsValid(int value)
{
    switch (value) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const SignedMessage_MessageType SignedMessage::LICENSE_REQUEST;
const SignedMessage_MessageType SignedMessage::LICENSE;
const SignedMessage_MessageType SignedMessage::ERROR_RESPONSE;
const SignedMessage_MessageType SignedMessage::SERVICE_CERTIFICATE_REQUEST;
const SignedMessage_MessageType SignedMessage::SERVICE_CERTIFICATE;
const SignedMessage_MessageType SignedMessage::MessageType_MIN;
const SignedMessage_MessageType SignedMessage::MessageType_MAX;
const int SignedMessage::MessageType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SignedMessage::kTypeFieldNumber;
const int SignedMessage::kMsgFieldNumber;
const int SignedMessage::kSignatureFieldNumber;
const int SignedMessage::kSessionKeyFieldNumber;
const int SignedMessage::kRemoteAttestationFieldNumber;
#endif  // !_MSC_VER

SignedMessage::SignedMessage()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SignedMessage::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    remote_attestation_ = const_cast< ::video_widevine_server::sdk::RemoteAttestation*>(
                              ::video_widevine_server::sdk::RemoteAttestation::internal_default_instance());
#else
    remote_attestation_ = const_cast< ::video_widevine_server::sdk::RemoteAttestation*>(&::video_widevine_server::sdk::RemoteAttestation::default_instance());
#endif
}

SignedMessage::SignedMessage(const SignedMessage& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SignedMessage::SharedCtor()
{
    _cached_size_ = 0;
    type_ = 1;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    remote_attestation_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedMessage::~SignedMessage()
{
    SharedDtor();
}

void SignedMessage::SharedDtor()
{
    if (msg_ != &::google::protobuf::internal::kEmptyString) {
        delete msg_;
    }

    if (signature_ != &::google::protobuf::internal::kEmptyString) {
        delete signature_;
    }

    if (session_key_ != &::google::protobuf::internal::kEmptyString) {
        delete session_key_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete remote_attestation_;
    }
}

void SignedMessage::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignedMessage& SignedMessage::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SignedMessage* SignedMessage::default_instance_ = NULL;

SignedMessage* SignedMessage::New() const
{
    return new SignedMessage;
}

void SignedMessage::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        type_ = 1;

        if (has_msg()) {
            if (msg_ != &::google::protobuf::internal::kEmptyString) {
                msg_->clear();
            }
        }

        if (has_signature()) {
            if (signature_ != &::google::protobuf::internal::kEmptyString) {
                signature_->clear();
            }
        }

        if (has_session_key()) {
            if (session_key_ != &::google::protobuf::internal::kEmptyString) {
                session_key_->clear();
            }
        }

        if (has_remote_attestation()) {
            if (remote_attestation_ != NULL) remote_attestation_->::video_widevine_server::sdk::RemoteAttestation::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.SignedMessage.MessageType type = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::SignedMessage_MessageType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::SignedMessage_MessageType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_msg;

                break;
            }

            // optional bytes msg = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_msg:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_msg()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_signature;

                break;
            }

            // optional bytes signature = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signature:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signature()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_session_key;

                break;
            }

            // optional bytes session_key = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_session_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_session_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_remote_attestation;

                break;
            }

            // optional .video_widevine_server.sdk.RemoteAttestation remote_attestation = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_remote_attestation:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_remote_attestation()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SignedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.SignedMessage.MessageType type = 1;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->type(), output);
    }

    // optional bytes msg = 2;
    if (has_msg()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->msg(), output);
    }

    // optional bytes signature = 3;
    if (has_signature()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->signature(), output);
    }

    // optional bytes session_key = 4;
    if (has_session_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->session_key(), output);
    }

    // optional .video_widevine_server.sdk.RemoteAttestation remote_attestation = 5;
    if (has_remote_attestation()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            5, this->remote_attestation(), output);
    }
}

int SignedMessage::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.SignedMessage.MessageType type = 1;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional bytes msg = 2;
        if (has_msg()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->msg());
        }

        // optional bytes signature = 3;
        if (has_signature()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signature());
        }

        // optional bytes session_key = 4;
        if (has_session_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->session_key());
        }

        // optional .video_widevine_server.sdk.RemoteAttestation remote_attestation = 5;
        if (has_remote_attestation()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->remote_attestation());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SignedMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SignedMessage*>(&from));
}

void SignedMessage::MergeFrom(const SignedMessage& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_msg()) {
            set_msg(from.msg());
        }

        if (from.has_signature()) {
            set_signature(from.signature());
        }

        if (from.has_session_key()) {
            set_session_key(from.session_key());
        }

        if (from.has_remote_attestation()) {
            mutable_remote_attestation()->::video_widevine_server::sdk::RemoteAttestation::MergeFrom(from.remote_attestation());
        }
    }
}

void SignedMessage::CopyFrom(const SignedMessage& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SignedMessage::IsInitialized() const
{
    return true;
}

void SignedMessage::Swap(SignedMessage* other)
{
    if (other != this) {
        std::swap(type_, other->type_);
        std::swap(msg_, other->msg_);
        std::swap(signature_, other->signature_);
        std::swap(session_key_, other->session_key_);
        std::swap(remote_attestation_, other->remote_attestation_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SignedMessage::GetTypeName() const
{
    return "video_widevine_server.sdk.SignedMessage";
}


// ===================================================================

bool SessionInit_ReplayControl_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const SessionInit_ReplayControl SessionInit::NO_SESSION_USAGE;
const SessionInit_ReplayControl SessionInit::NONCE_REQUIRED_AND_NEW_SESSION_USAGE;
const SessionInit_ReplayControl SessionInit::NONCE_REQUIRED_OR_EXISTING_SESSION_USAGE;
const SessionInit_ReplayControl SessionInit::ReplayControl_MIN;
const SessionInit_ReplayControl SessionInit::ReplayControl_MAX;
const int SessionInit::ReplayControl_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SessionInit::kSessionIdFieldNumber;
const int SessionInit::kPurchaseIdFieldNumber;
const int SessionInit::kMasterSigningKeyFieldNumber;
const int SessionInit::kSigningKeyFieldNumber;
const int SessionInit::kLicenseStartTimeFieldNumber;
const int SessionInit::kProviderClientTokenFieldNumber;
const int SessionInit::kProviderSessionTokenFieldNumber;
const int SessionInit::kReplayControlFieldNumber;
#endif  // !_MSC_VER

SessionInit::SessionInit()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SessionInit::InitAsDefaultInstance()
{
}

SessionInit::SessionInit(const SessionInit& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SessionInit::SharedCtor()
{
    _cached_size_ = 0;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    purchase_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    master_signing_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signing_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_start_time_ = GOOGLE_LONGLONG(0);
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    provider_session_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    replay_control_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionInit::~SessionInit()
{
    SharedDtor();
}

void SessionInit::SharedDtor()
{
    if (session_id_ != &::google::protobuf::internal::kEmptyString) {
        delete session_id_;
    }

    if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
        delete purchase_id_;
    }

    if (master_signing_key_ != &::google::protobuf::internal::kEmptyString) {
        delete master_signing_key_;
    }

    if (signing_key_ != &::google::protobuf::internal::kEmptyString) {
        delete signing_key_;
    }

    if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
        delete provider_client_token_;
    }

    if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
        delete provider_session_token_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void SessionInit::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionInit& SessionInit::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SessionInit* SessionInit::default_instance_ = NULL;

SessionInit* SessionInit::New() const
{
    return new SessionInit;
}

void SessionInit::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_session_id()) {
            if (session_id_ != &::google::protobuf::internal::kEmptyString) {
                session_id_->clear();
            }
        }

        if (has_purchase_id()) {
            if (purchase_id_ != &::google::protobuf::internal::kEmptyString) {
                purchase_id_->clear();
            }
        }

        if (has_master_signing_key()) {
            if (master_signing_key_ != &::google::protobuf::internal::kEmptyString) {
                master_signing_key_->clear();
            }
        }

        if (has_signing_key()) {
            if (signing_key_ != &::google::protobuf::internal::kEmptyString) {
                signing_key_->clear();
            }
        }

        license_start_time_ = GOOGLE_LONGLONG(0);

        if (has_provider_client_token()) {
            if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
                provider_client_token_->clear();
            }
        }

        if (has_provider_session_token()) {
            if (provider_session_token_ != &::google::protobuf::internal::kEmptyString) {
                provider_session_token_->clear();
            }
        }

        replay_control_ = 0;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SessionInit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes session_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_session_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_purchase_id;

                break;
            }

            // optional bytes purchase_id = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_purchase_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_purchase_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_master_signing_key;

                break;
            }

            // optional bytes master_signing_key = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_master_signing_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_master_signing_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_signing_key;

                break;
            }

            // optional bytes signing_key = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signing_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signing_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_license_start_time;

                break;
            }

            // optional int64 license_start_time = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_start_time:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64 > (
                             input, &license_start_time_)));
                    set_has_license_start_time();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_provider_client_token;

                break;
            }

            // optional bytes provider_client_token = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_provider_client_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_provider_client_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(58)) goto parse_provider_session_token;

                break;
            }

            // optional bytes provider_session_token = 7;
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_provider_session_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_provider_session_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(64)) goto parse_replay_control;

                break;
            }

            // optional .video_widevine_server.sdk.SessionInit.ReplayControl replay_control = 8 [default = NO_SESSION_USAGE];
            case 8: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_replay_control:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::SessionInit_ReplayControl_IsValid(value)) {
                        set_replay_control(static_cast< ::video_widevine_server::sdk::SessionInit_ReplayControl >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SessionInit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes session_id = 1;
    if (has_session_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->session_id(), output);
    }

    // optional bytes purchase_id = 2;
    if (has_purchase_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->purchase_id(), output);
    }

    // optional bytes master_signing_key = 3;
    if (has_master_signing_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->master_signing_key(), output);
    }

    // optional bytes signing_key = 4;
    if (has_signing_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->signing_key(), output);
    }

    // optional int64 license_start_time = 5;
    if (has_license_start_time()) {
        ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->license_start_time(), output);
    }

    // optional bytes provider_client_token = 6;
    if (has_provider_client_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            6, this->provider_client_token(), output);
    }

    // optional bytes provider_session_token = 7;
    if (has_provider_session_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            7, this->provider_session_token(), output);
    }

    // optional .video_widevine_server.sdk.SessionInit.ReplayControl replay_control = 8 [default = NO_SESSION_USAGE];
    if (has_replay_control()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            8, this->replay_control(), output);
    }
}

int SessionInit::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes session_id = 1;
        if (has_session_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->session_id());
        }

        // optional bytes purchase_id = 2;
        if (has_purchase_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->purchase_id());
        }

        // optional bytes master_signing_key = 3;
        if (has_master_signing_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->master_signing_key());
        }

        // optional bytes signing_key = 4;
        if (has_signing_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signing_key());
        }

        // optional int64 license_start_time = 5;
        if (has_license_start_time()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::Int64Size(
                              this->license_start_time());
        }

        // optional bytes provider_client_token = 6;
        if (has_provider_client_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->provider_client_token());
        }

        // optional bytes provider_session_token = 7;
        if (has_provider_session_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->provider_session_token());
        }

        // optional .video_widevine_server.sdk.SessionInit.ReplayControl replay_control = 8 [default = NO_SESSION_USAGE];
        if (has_replay_control()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->replay_control());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SessionInit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SessionInit*>(&from));
}

void SessionInit::MergeFrom(const SessionInit& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_session_id()) {
            set_session_id(from.session_id());
        }

        if (from.has_purchase_id()) {
            set_purchase_id(from.purchase_id());
        }

        if (from.has_master_signing_key()) {
            set_master_signing_key(from.master_signing_key());
        }

        if (from.has_signing_key()) {
            set_signing_key(from.signing_key());
        }

        if (from.has_license_start_time()) {
            set_license_start_time(from.license_start_time());
        }

        if (from.has_provider_client_token()) {
            set_provider_client_token(from.provider_client_token());
        }

        if (from.has_provider_session_token()) {
            set_provider_session_token(from.provider_session_token());
        }

        if (from.has_replay_control()) {
            set_replay_control(from.replay_control());
        }
    }
}

void SessionInit::CopyFrom(const SessionInit& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SessionInit::IsInitialized() const
{
    return true;
}

void SessionInit::Swap(SessionInit* other)
{
    if (other != this) {
        std::swap(session_id_, other->session_id_);
        std::swap(purchase_id_, other->purchase_id_);
        std::swap(master_signing_key_, other->master_signing_key_);
        std::swap(signing_key_, other->signing_key_);
        std::swap(license_start_time_, other->license_start_time_);
        std::swap(provider_client_token_, other->provider_client_token_);
        std::swap(provider_session_token_, other->provider_session_token_);
        std::swap(replay_control_, other->replay_control_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SessionInit::GetTypeName() const
{
    return "video_widevine_server.sdk.SessionInit";
}


// ===================================================================

#ifndef _MSC_VER
const int SessionState::kLicenseIdFieldNumber;
const int SessionState::kSigningKeyFieldNumber;
const int SessionState::kKeyboxSystemIdFieldNumber;
#endif  // !_MSC_VER

SessionState::SessionState()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SessionState::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    license_id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(
                      ::video_widevine_server::sdk::LicenseIdentification::internal_default_instance());
#else
    license_id_ = const_cast< ::video_widevine_server::sdk::LicenseIdentification*>(&::video_widevine_server::sdk::LicenseIdentification::default_instance());
#endif
}

SessionState::SessionState(const SessionState& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SessionState::SharedCtor()
{
    _cached_size_ = 0;
    license_id_ = NULL;
    signing_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    keybox_system_id_ = 0u;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SessionState::~SessionState()
{
    SharedDtor();
}

void SessionState::SharedDtor()
{
    if (signing_key_ != &::google::protobuf::internal::kEmptyString) {
        delete signing_key_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete license_id_;
    }
}

void SessionState::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionState& SessionState::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SessionState* SessionState::default_instance_ = NULL;

SessionState* SessionState::New() const
{
    return new SessionState;
}

void SessionState::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_license_id()) {
            if (license_id_ != NULL) license_id_->::video_widevine_server::sdk::LicenseIdentification::Clear();
        }

        if (has_signing_key()) {
            if (signing_key_ != &::google::protobuf::internal::kEmptyString) {
                signing_key_->clear();
            }
        }

        keybox_system_id_ = 0u;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SessionState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_license_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_signing_key;

                break;
            }

            // optional bytes signing_key = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signing_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signing_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_keybox_system_id;

                break;
            }

            // optional uint32 keybox_system_id = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_keybox_system_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &keybox_system_id_)));
                    set_has_keybox_system_id();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SessionState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
    if (has_license_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->license_id(), output);
    }

    // optional bytes signing_key = 2;
    if (has_signing_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->signing_key(), output);
    }

    // optional uint32 keybox_system_id = 3;
    if (has_keybox_system_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->keybox_system_id(), output);
    }
}

int SessionState::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.LicenseIdentification license_id = 1;
        if (has_license_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->license_id());
        }

        // optional bytes signing_key = 2;
        if (has_signing_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signing_key());
        }

        // optional uint32 keybox_system_id = 3;
        if (has_keybox_system_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->keybox_system_id());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SessionState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SessionState*>(&from));
}

void SessionState::MergeFrom(const SessionState& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_license_id()) {
            mutable_license_id()->::video_widevine_server::sdk::LicenseIdentification::MergeFrom(from.license_id());
        }

        if (from.has_signing_key()) {
            set_signing_key(from.signing_key());
        }

        if (from.has_keybox_system_id()) {
            set_keybox_system_id(from.keybox_system_id());
        }
    }
}

void SessionState::CopyFrom(const SessionState& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SessionState::IsInitialized() const
{
    return true;
}

void SessionState::Swap(SessionState* other)
{
    if (other != this) {
        std::swap(license_id_, other->license_id_);
        std::swap(signing_key_, other->signing_key_);
        std::swap(keybox_system_id_, other->keybox_system_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SessionState::GetTypeName() const
{
    return "video_widevine_server.sdk.SessionState";
}


// ===================================================================

bool ProvisioningOptions_CertificateType_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const ProvisioningOptions_CertificateType ProvisioningOptions::WIDEVINE_DRM;
const ProvisioningOptions_CertificateType ProvisioningOptions::X509;
const ProvisioningOptions_CertificateType ProvisioningOptions::CertificateType_MIN;
const ProvisioningOptions_CertificateType ProvisioningOptions::CertificateType_MAX;
const int ProvisioningOptions::CertificateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ProvisioningOptions::kCertificateTypeFieldNumber;
const int ProvisioningOptions::kCertificateAuthorityFieldNumber;
#endif  // !_MSC_VER

ProvisioningOptions::ProvisioningOptions()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ProvisioningOptions::InitAsDefaultInstance()
{
}

ProvisioningOptions::ProvisioningOptions(const ProvisioningOptions& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ProvisioningOptions::SharedCtor()
{
    _cached_size_ = 0;
    certificate_type_ = 0;
    certificate_authority_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProvisioningOptions::~ProvisioningOptions()
{
    SharedDtor();
}

void ProvisioningOptions::SharedDtor()
{
    if (certificate_authority_ != &::google::protobuf::internal::kEmptyString) {
        delete certificate_authority_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void ProvisioningOptions::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProvisioningOptions& ProvisioningOptions::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ProvisioningOptions* ProvisioningOptions::default_instance_ = NULL;

ProvisioningOptions* ProvisioningOptions::New() const
{
    return new ProvisioningOptions;
}

void ProvisioningOptions::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        certificate_type_ = 0;

        if (has_certificate_authority()) {
            if (certificate_authority_ != &::google::protobuf::internal::kEmptyString) {
                certificate_authority_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ProvisioningOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.ProvisioningOptions.CertificateType certificate_type = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::ProvisioningOptions_CertificateType_IsValid(value)) {
                        set_certificate_type(static_cast< ::video_widevine_server::sdk::ProvisioningOptions_CertificateType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_certificate_authority;

                break;
            }

            // optional string certificate_authority = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_certificate_authority:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_certificate_authority()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ProvisioningOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.ProvisioningOptions.CertificateType certificate_type = 1;
    if (has_certificate_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->certificate_type(), output);
    }

    // optional string certificate_authority = 2;
    if (has_certificate_authority()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            2, this->certificate_authority(), output);
    }
}

int ProvisioningOptions::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.ProvisioningOptions.CertificateType certificate_type = 1;
        if (has_certificate_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->certificate_type());
        }

        // optional string certificate_authority = 2;
        if (has_certificate_authority()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->certificate_authority());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ProvisioningOptions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ProvisioningOptions*>(&from));
}

void ProvisioningOptions::MergeFrom(const ProvisioningOptions& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_certificate_type()) {
            set_certificate_type(from.certificate_type());
        }

        if (from.has_certificate_authority()) {
            set_certificate_authority(from.certificate_authority());
        }
    }
}

void ProvisioningOptions::CopyFrom(const ProvisioningOptions& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ProvisioningOptions::IsInitialized() const
{
    return true;
}

void ProvisioningOptions::Swap(ProvisioningOptions* other)
{
    if (other != this) {
        std::swap(certificate_type_, other->certificate_type_);
        std::swap(certificate_authority_, other->certificate_authority_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ProvisioningOptions::GetTypeName() const
{
    return "video_widevine_server.sdk.ProvisioningOptions";
}


// ===================================================================

#ifndef _MSC_VER
const int ProvisioningRequest::kClientIdFieldNumber;
const int ProvisioningRequest::kNonceFieldNumber;
const int ProvisioningRequest::kOptionsFieldNumber;
#endif  // !_MSC_VER

ProvisioningRequest::ProvisioningRequest()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ProvisioningRequest::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_id_ = const_cast< ::video_widevine_server::sdk::ClientIdentification*>(
                     ::video_widevine_server::sdk::ClientIdentification::internal_default_instance());
#else
    client_id_ = const_cast< ::video_widevine_server::sdk::ClientIdentification*>(&::video_widevine_server::sdk::ClientIdentification::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    options_ = const_cast< ::video_widevine_server::sdk::ProvisioningOptions*>(
                   ::video_widevine_server::sdk::ProvisioningOptions::internal_default_instance());
#else
    options_ = const_cast< ::video_widevine_server::sdk::ProvisioningOptions*>(&::video_widevine_server::sdk::ProvisioningOptions::default_instance());
#endif
}

ProvisioningRequest::ProvisioningRequest(const ProvisioningRequest& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ProvisioningRequest::SharedCtor()
{
    _cached_size_ = 0;
    client_id_ = NULL;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    options_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProvisioningRequest::~ProvisioningRequest()
{
    SharedDtor();
}

void ProvisioningRequest::SharedDtor()
{
    if (nonce_ != &::google::protobuf::internal::kEmptyString) {
        delete nonce_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete client_id_;
        delete options_;
    }
}

void ProvisioningRequest::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProvisioningRequest& ProvisioningRequest::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ProvisioningRequest* ProvisioningRequest::default_instance_ = NULL;

ProvisioningRequest* ProvisioningRequest::New() const
{
    return new ProvisioningRequest;
}

void ProvisioningRequest::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_client_id()) {
            if (client_id_ != NULL) client_id_->::video_widevine_server::sdk::ClientIdentification::Clear();
        }

        if (has_nonce()) {
            if (nonce_ != &::google::protobuf::internal::kEmptyString) {
                nonce_->clear();
            }
        }

        if (has_options()) {
            if (options_ != NULL) options_->::video_widevine_server::sdk::ProvisioningOptions::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ProvisioningRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_client_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_nonce;

                break;
            }

            // optional bytes nonce = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_nonce:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_nonce()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_options;

                break;
            }

            // optional .video_widevine_server.sdk.ProvisioningOptions options = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_options:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_options()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ProvisioningRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
    if (has_client_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, this->client_id(), output);
    }

    // optional bytes nonce = 2;
    if (has_nonce()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->nonce(), output);
    }

    // optional .video_widevine_server.sdk.ProvisioningOptions options = 3;
    if (has_options()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->options(), output);
    }
}

int ProvisioningRequest::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.ClientIdentification client_id = 1;
        if (has_client_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->client_id());
        }

        // optional bytes nonce = 2;
        if (has_nonce()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->nonce());
        }

        // optional .video_widevine_server.sdk.ProvisioningOptions options = 3;
        if (has_options()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->options());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ProvisioningRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ProvisioningRequest*>(&from));
}

void ProvisioningRequest::MergeFrom(const ProvisioningRequest& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client_id()) {
            mutable_client_id()->::video_widevine_server::sdk::ClientIdentification::MergeFrom(from.client_id());
        }

        if (from.has_nonce()) {
            set_nonce(from.nonce());
        }

        if (from.has_options()) {
            mutable_options()->::video_widevine_server::sdk::ProvisioningOptions::MergeFrom(from.options());
        }
    }
}

void ProvisioningRequest::CopyFrom(const ProvisioningRequest& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ProvisioningRequest::IsInitialized() const
{
    return true;
}

void ProvisioningRequest::Swap(ProvisioningRequest* other)
{
    if (other != this) {
        std::swap(client_id_, other->client_id_);
        std::swap(nonce_, other->nonce_);
        std::swap(options_, other->options_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ProvisioningRequest::GetTypeName() const
{
    return "video_widevine_server.sdk.ProvisioningRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ProvisioningResponse::kDeviceRsaKeyFieldNumber;
const int ProvisioningResponse::kDeviceRsaKeyIvFieldNumber;
const int ProvisioningResponse::kDeviceCertificateFieldNumber;
const int ProvisioningResponse::kNonceFieldNumber;
#endif  // !_MSC_VER

ProvisioningResponse::ProvisioningResponse()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ProvisioningResponse::InitAsDefaultInstance()
{
}

ProvisioningResponse::ProvisioningResponse(const ProvisioningResponse& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ProvisioningResponse::SharedCtor()
{
    _cached_size_ = 0;
    device_rsa_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    device_rsa_key_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProvisioningResponse::~ProvisioningResponse()
{
    SharedDtor();
}

void ProvisioningResponse::SharedDtor()
{
    if (device_rsa_key_ != &::google::protobuf::internal::kEmptyString) {
        delete device_rsa_key_;
    }

    if (device_rsa_key_iv_ != &::google::protobuf::internal::kEmptyString) {
        delete device_rsa_key_iv_;
    }

    if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
        delete device_certificate_;
    }

    if (nonce_ != &::google::protobuf::internal::kEmptyString) {
        delete nonce_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void ProvisioningResponse::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProvisioningResponse& ProvisioningResponse::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ProvisioningResponse* ProvisioningResponse::default_instance_ = NULL;

ProvisioningResponse* ProvisioningResponse::New() const
{
    return new ProvisioningResponse;
}

void ProvisioningResponse::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_device_rsa_key()) {
            if (device_rsa_key_ != &::google::protobuf::internal::kEmptyString) {
                device_rsa_key_->clear();
            }
        }

        if (has_device_rsa_key_iv()) {
            if (device_rsa_key_iv_ != &::google::protobuf::internal::kEmptyString) {
                device_rsa_key_iv_->clear();
            }
        }

        if (has_device_certificate()) {
            if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
                device_certificate_->clear();
            }
        }

        if (has_nonce()) {
            if (nonce_ != &::google::protobuf::internal::kEmptyString) {
                nonce_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ProvisioningResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes device_rsa_key = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_device_rsa_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_device_rsa_key_iv;

                break;
            }

            // optional bytes device_rsa_key_iv = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_device_rsa_key_iv:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_device_rsa_key_iv()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_device_certificate;

                break;
            }

            // optional bytes device_certificate = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_device_certificate:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_device_certificate()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_nonce;

                break;
            }

            // optional bytes nonce = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_nonce:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_nonce()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ProvisioningResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes device_rsa_key = 1;
    if (has_device_rsa_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->device_rsa_key(), output);
    }

    // optional bytes device_rsa_key_iv = 2;
    if (has_device_rsa_key_iv()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->device_rsa_key_iv(), output);
    }

    // optional bytes device_certificate = 3;
    if (has_device_certificate()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->device_certificate(), output);
    }

    // optional bytes nonce = 4;
    if (has_nonce()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->nonce(), output);
    }
}

int ProvisioningResponse::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes device_rsa_key = 1;
        if (has_device_rsa_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->device_rsa_key());
        }

        // optional bytes device_rsa_key_iv = 2;
        if (has_device_rsa_key_iv()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->device_rsa_key_iv());
        }

        // optional bytes device_certificate = 3;
        if (has_device_certificate()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->device_certificate());
        }

        // optional bytes nonce = 4;
        if (has_nonce()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->nonce());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ProvisioningResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ProvisioningResponse*>(&from));
}

void ProvisioningResponse::MergeFrom(const ProvisioningResponse& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_device_rsa_key()) {
            set_device_rsa_key(from.device_rsa_key());
        }

        if (from.has_device_rsa_key_iv()) {
            set_device_rsa_key_iv(from.device_rsa_key_iv());
        }

        if (from.has_device_certificate()) {
            set_device_certificate(from.device_certificate());
        }

        if (from.has_nonce()) {
            set_nonce(from.nonce());
        }
    }
}

void ProvisioningResponse::CopyFrom(const ProvisioningResponse& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ProvisioningResponse::IsInitialized() const
{
    return true;
}

void ProvisioningResponse::Swap(ProvisioningResponse* other)
{
    if (other != this) {
        std::swap(device_rsa_key_, other->device_rsa_key_);
        std::swap(device_rsa_key_iv_, other->device_rsa_key_iv_);
        std::swap(device_certificate_, other->device_certificate_);
        std::swap(nonce_, other->nonce_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ProvisioningResponse::GetTypeName() const
{
    return "video_widevine_server.sdk.ProvisioningResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int SignedProvisioningMessage::kMessageFieldNumber;
const int SignedProvisioningMessage::kSignatureFieldNumber;
#endif  // !_MSC_VER

SignedProvisioningMessage::SignedProvisioningMessage()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SignedProvisioningMessage::InitAsDefaultInstance()
{
}

SignedProvisioningMessage::SignedProvisioningMessage(const SignedProvisioningMessage& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SignedProvisioningMessage::SharedCtor()
{
    _cached_size_ = 0;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedProvisioningMessage::~SignedProvisioningMessage()
{
    SharedDtor();
}

void SignedProvisioningMessage::SharedDtor()
{
    if (message_ != &::google::protobuf::internal::kEmptyString) {
        delete message_;
    }

    if (signature_ != &::google::protobuf::internal::kEmptyString) {
        delete signature_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void SignedProvisioningMessage::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignedProvisioningMessage& SignedProvisioningMessage::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SignedProvisioningMessage* SignedProvisioningMessage::default_instance_ = NULL;

SignedProvisioningMessage* SignedProvisioningMessage::New() const
{
    return new SignedProvisioningMessage;
}

void SignedProvisioningMessage::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_message()) {
            if (message_ != &::google::protobuf::internal::kEmptyString) {
                message_->clear();
            }
        }

        if (has_signature()) {
            if (signature_ != &::google::protobuf::internal::kEmptyString) {
                signature_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignedProvisioningMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes message = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_message()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_signature;

                break;
            }

            // optional bytes signature = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signature:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signature()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SignedProvisioningMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes message = 1;
    if (has_message()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->message(), output);
    }

    // optional bytes signature = 2;
    if (has_signature()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->signature(), output);
    }
}

int SignedProvisioningMessage::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes message = 1;
        if (has_message()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->message());
        }

        // optional bytes signature = 2;
        if (has_signature()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signature());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SignedProvisioningMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SignedProvisioningMessage*>(&from));
}

void SignedProvisioningMessage::MergeFrom(const SignedProvisioningMessage& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_message()) {
            set_message(from.message());
        }

        if (from.has_signature()) {
            set_signature(from.signature());
        }
    }
}

void SignedProvisioningMessage::CopyFrom(const SignedProvisioningMessage& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SignedProvisioningMessage::IsInitialized() const
{
    return true;
}

void SignedProvisioningMessage::Swap(SignedProvisioningMessage* other)
{
    if (other != this) {
        std::swap(message_, other->message_);
        std::swap(signature_, other->signature_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SignedProvisioningMessage::GetTypeName() const
{
    return "video_widevine_server.sdk.SignedProvisioningMessage";
}


// ===================================================================

bool ClientIdentification_TokenType_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const ClientIdentification_TokenType ClientIdentification::KEYBOX;
const ClientIdentification_TokenType ClientIdentification::DEVICE_CERTIFICATE;
const ClientIdentification_TokenType ClientIdentification::REMOTE_ATTESTATION_CERTIFICATE;
const ClientIdentification_TokenType ClientIdentification::TokenType_MIN;
const ClientIdentification_TokenType ClientIdentification::TokenType_MAX;
const int ClientIdentification::TokenType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ClientIdentification_NameValue::kNameFieldNumber;
const int ClientIdentification_NameValue::kValueFieldNumber;
#endif  // !_MSC_VER

ClientIdentification_NameValue::ClientIdentification_NameValue()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ClientIdentification_NameValue::InitAsDefaultInstance()
{
}

ClientIdentification_NameValue::ClientIdentification_NameValue(const ClientIdentification_NameValue& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ClientIdentification_NameValue::SharedCtor()
{
    _cached_size_ = 0;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientIdentification_NameValue::~ClientIdentification_NameValue()
{
    SharedDtor();
}

void ClientIdentification_NameValue::SharedDtor()
{
    if (name_ != &::google::protobuf::internal::kEmptyString) {
        delete name_;
    }

    if (value_ != &::google::protobuf::internal::kEmptyString) {
        delete value_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void ClientIdentification_NameValue::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientIdentification_NameValue& ClientIdentification_NameValue::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ClientIdentification_NameValue* ClientIdentification_NameValue::default_instance_ = NULL;

ClientIdentification_NameValue* ClientIdentification_NameValue::New() const
{
    return new ClientIdentification_NameValue;
}

void ClientIdentification_NameValue::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_name()) {
            if (name_ != &::google::protobuf::internal::kEmptyString) {
                name_->clear();
            }
        }

        if (has_value()) {
            if (value_ != &::google::protobuf::internal::kEmptyString) {
                value_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientIdentification_NameValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional string name = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_name()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_value;

                break;
            }

            // optional string value = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_value:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_value()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ClientIdentification_NameValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional string name = 1;
    if (has_name()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            1, this->name(), output);
    }

    // optional string value = 2;
    if (has_value()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            2, this->value(), output);
    }
}

int ClientIdentification_NameValue::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional string name = 1;
        if (has_name()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->name());
        }

        // optional string value = 2;
        if (has_value()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->value());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ClientIdentification_NameValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ClientIdentification_NameValue*>(&from));
}

void ClientIdentification_NameValue::MergeFrom(const ClientIdentification_NameValue& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_name()) {
            set_name(from.name());
        }

        if (from.has_value()) {
            set_value(from.value());
        }
    }
}

void ClientIdentification_NameValue::CopyFrom(const ClientIdentification_NameValue& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ClientIdentification_NameValue::IsInitialized() const
{
    return true;
}

void ClientIdentification_NameValue::Swap(ClientIdentification_NameValue* other)
{
    if (other != this) {
        std::swap(name_, other->name_);
        std::swap(value_, other->value_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ClientIdentification_NameValue::GetTypeName() const
{
    return "video_widevine_server.sdk.ClientIdentification.NameValue";
}


// -------------------------------------------------------------------

bool ClientIdentification_ClientCapabilities_HdcpVersion_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HDCP_NONE;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HDCP_V1;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HDCP_V2;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HDCP_V2_1;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HDCP_V2_2;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HdcpVersion_MIN;
const ClientIdentification_ClientCapabilities_HdcpVersion ClientIdentification_ClientCapabilities::HdcpVersion_MAX;
const int ClientIdentification_ClientCapabilities::HdcpVersion_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ClientIdentification_ClientCapabilities::kClientTokenFieldNumber;
const int ClientIdentification_ClientCapabilities::kSessionTokenFieldNumber;
const int ClientIdentification_ClientCapabilities::kVideoResolutionConstraintsFieldNumber;
const int ClientIdentification_ClientCapabilities::kMaxHdcpVersionFieldNumber;
#endif  // !_MSC_VER

ClientIdentification_ClientCapabilities::ClientIdentification_ClientCapabilities()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ClientIdentification_ClientCapabilities::InitAsDefaultInstance()
{
}

ClientIdentification_ClientCapabilities::ClientIdentification_ClientCapabilities(const ClientIdentification_ClientCapabilities& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ClientIdentification_ClientCapabilities::SharedCtor()
{
    _cached_size_ = 0;
    client_token_ = false;
    session_token_ = false;
    video_resolution_constraints_ = false;
    max_hdcp_version_ = 0;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientIdentification_ClientCapabilities::~ClientIdentification_ClientCapabilities()
{
    SharedDtor();
}

void ClientIdentification_ClientCapabilities::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void ClientIdentification_ClientCapabilities::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientIdentification_ClientCapabilities& ClientIdentification_ClientCapabilities::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ClientIdentification_ClientCapabilities* ClientIdentification_ClientCapabilities::default_instance_ = NULL;

ClientIdentification_ClientCapabilities* ClientIdentification_ClientCapabilities::New() const
{
    return new ClientIdentification_ClientCapabilities;
}

void ClientIdentification_ClientCapabilities::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        client_token_ = false;
        session_token_ = false;
        video_resolution_constraints_ = false;
        max_hdcp_version_ = 0;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientIdentification_ClientCapabilities::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bool client_token = 1 [default = false];
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &client_token_)));
                    set_has_client_token();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_session_token;

                break;
            }

            // optional bool session_token = 2 [default = false];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_session_token:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &session_token_)));
                    set_has_session_token();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_video_resolution_constraints;

                break;
            }

            // optional bool video_resolution_constraints = 3 [default = false];
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_video_resolution_constraints:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &video_resolution_constraints_)));
                    set_has_video_resolution_constraints();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(32)) goto parse_max_hdcp_version;

                break;
            }

            // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_max_hdcp_version:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion_IsValid(value)) {
                        set_max_hdcp_version(static_cast< ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities_HdcpVersion >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ClientIdentification_ClientCapabilities::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bool client_token = 1 [default = false];
    if (has_client_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->client_token(), output);
    }

    // optional bool session_token = 2 [default = false];
    if (has_session_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->session_token(), output);
    }

    // optional bool video_resolution_constraints = 3 [default = false];
    if (has_video_resolution_constraints()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->video_resolution_constraints(), output);
    }

    // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
    if (has_max_hdcp_version()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            4, this->max_hdcp_version(), output);
    }
}

int ClientIdentification_ClientCapabilities::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bool client_token = 1 [default = false];
        if (has_client_token()) {
            total_size += 1 + 1;
        }

        // optional bool session_token = 2 [default = false];
        if (has_session_token()) {
            total_size += 1 + 1;
        }

        // optional bool video_resolution_constraints = 3 [default = false];
        if (has_video_resolution_constraints()) {
            total_size += 1 + 1;
        }

        // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
        if (has_max_hdcp_version()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->max_hdcp_version());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ClientIdentification_ClientCapabilities::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ClientIdentification_ClientCapabilities*>(&from));
}

void ClientIdentification_ClientCapabilities::MergeFrom(const ClientIdentification_ClientCapabilities& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_client_token()) {
            set_client_token(from.client_token());
        }

        if (from.has_session_token()) {
            set_session_token(from.session_token());
        }

        if (from.has_video_resolution_constraints()) {
            set_video_resolution_constraints(from.video_resolution_constraints());
        }

        if (from.has_max_hdcp_version()) {
            set_max_hdcp_version(from.max_hdcp_version());
        }
    }
}

void ClientIdentification_ClientCapabilities::CopyFrom(const ClientIdentification_ClientCapabilities& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ClientIdentification_ClientCapabilities::IsInitialized() const
{
    return true;
}

void ClientIdentification_ClientCapabilities::Swap(ClientIdentification_ClientCapabilities* other)
{
    if (other != this) {
        std::swap(client_token_, other->client_token_);
        std::swap(session_token_, other->session_token_);
        std::swap(video_resolution_constraints_, other->video_resolution_constraints_);
        std::swap(max_hdcp_version_, other->max_hdcp_version_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ClientIdentification_ClientCapabilities::GetTypeName() const
{
    return "video_widevine_server.sdk.ClientIdentification.ClientCapabilities";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ClientIdentification::kTypeFieldNumber;
const int ClientIdentification::kTokenFieldNumber;
const int ClientIdentification::kClientInfoFieldNumber;
const int ClientIdentification::kProviderClientTokenFieldNumber;
const int ClientIdentification::kLicenseCounterFieldNumber;
const int ClientIdentification::kClientCapabilitiesFieldNumber;
#endif  // !_MSC_VER

ClientIdentification::ClientIdentification()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ClientIdentification::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    client_capabilities_ = const_cast< ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities*>(
                               ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities::internal_default_instance());
#else
    client_capabilities_ = const_cast< ::video_widevine_server::sdk::ClientIdentification_ClientCapabilities*>(&::video_widevine_server::sdk::ClientIdentification_ClientCapabilities::default_instance());
#endif
}

ClientIdentification::ClientIdentification(const ClientIdentification& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ClientIdentification::SharedCtor()
{
    _cached_size_ = 0;
    type_ = 0;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    provider_client_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    license_counter_ = 0u;
    client_capabilities_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientIdentification::~ClientIdentification()
{
    SharedDtor();
}

void ClientIdentification::SharedDtor()
{
    if (token_ != &::google::protobuf::internal::kEmptyString) {
        delete token_;
    }

    if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
        delete provider_client_token_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete client_capabilities_;
    }
}

void ClientIdentification::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientIdentification& ClientIdentification::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ClientIdentification* ClientIdentification::default_instance_ = NULL;

ClientIdentification* ClientIdentification::New() const
{
    return new ClientIdentification;
}

void ClientIdentification::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        type_ = 0;

        if (has_token()) {
            if (token_ != &::google::protobuf::internal::kEmptyString) {
                token_->clear();
            }
        }

        if (has_provider_client_token()) {
            if (provider_client_token_ != &::google::protobuf::internal::kEmptyString) {
                provider_client_token_->clear();
            }
        }

        license_counter_ = 0u;

        if (has_client_capabilities()) {
            if (client_capabilities_ != NULL) client_capabilities_->::video_widevine_server::sdk::ClientIdentification_ClientCapabilities::Clear();
        }
    }

    client_info_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientIdentification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.ClientIdentification.TokenType type = 1 [default = KEYBOX];
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::ClientIdentification_TokenType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::ClientIdentification_TokenType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_token;

                break;
            }

            // optional bytes token = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_client_info;

                break;
            }

            // repeated .video_widevine_server.sdk.ClientIdentification.NameValue client_info = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_client_info:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, add_client_info()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_client_info;

                if (input->ExpectTag(34)) goto parse_provider_client_token;

                break;
            }

            // optional bytes provider_client_token = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_provider_client_token:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_provider_client_token()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_license_counter;

                break;
            }

            // optional uint32 license_counter = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_license_counter:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &license_counter_)));
                    set_has_license_counter();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(50)) goto parse_client_capabilities;

                break;
            }

            // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities client_capabilities = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_client_capabilities:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_client_capabilities()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ClientIdentification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.ClientIdentification.TokenType type = 1 [default = KEYBOX];
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->type(), output);
    }

    // optional bytes token = 2;
    if (has_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->token(), output);
    }

    // repeated .video_widevine_server.sdk.ClientIdentification.NameValue client_info = 3;
    for (int i = 0; i < this->client_info_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->client_info(i), output);
    }

    // optional bytes provider_client_token = 4;
    if (has_provider_client_token()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->provider_client_token(), output);
    }

    // optional uint32 license_counter = 5;
    if (has_license_counter()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->license_counter(), output);
    }

    // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities client_capabilities = 6;
    if (has_client_capabilities()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            6, this->client_capabilities(), output);
    }
}

int ClientIdentification::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.ClientIdentification.TokenType type = 1 [default = KEYBOX];
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional bytes token = 2;
        if (has_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->token());
        }

        // optional bytes provider_client_token = 4;
        if (has_provider_client_token()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->provider_client_token());
        }

        // optional uint32 license_counter = 5;
        if (has_license_counter()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->license_counter());
        }

        // optional .video_widevine_server.sdk.ClientIdentification.ClientCapabilities client_capabilities = 6;
        if (has_client_capabilities()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->client_capabilities());
        }
    }

    // repeated .video_widevine_server.sdk.ClientIdentification.NameValue client_info = 3;
    total_size += 1 * this->client_info_size();

    for (int i = 0; i < this->client_info_size(); i++) {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->client_info(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ClientIdentification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ClientIdentification*>(&from));
}

void ClientIdentification::MergeFrom(const ClientIdentification& from)
{
    GOOGLE_CHECK_NE(&from, this);
    client_info_.MergeFrom(from.client_info_);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_token()) {
            set_token(from.token());
        }

        if (from.has_provider_client_token()) {
            set_provider_client_token(from.provider_client_token());
        }

        if (from.has_license_counter()) {
            set_license_counter(from.license_counter());
        }

        if (from.has_client_capabilities()) {
            mutable_client_capabilities()->::video_widevine_server::sdk::ClientIdentification_ClientCapabilities::MergeFrom(from.client_capabilities());
        }
    }
}

void ClientIdentification::CopyFrom(const ClientIdentification& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ClientIdentification::IsInitialized() const
{
    return true;
}

void ClientIdentification::Swap(ClientIdentification* other)
{
    if (other != this) {
        std::swap(type_, other->type_);
        std::swap(token_, other->token_);
        client_info_.Swap(&other->client_info_);
        std::swap(provider_client_token_, other->provider_client_token_);
        std::swap(license_counter_, other->license_counter_);
        std::swap(client_capabilities_, other->client_capabilities_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ClientIdentification::GetTypeName() const
{
    return "video_widevine_server.sdk.ClientIdentification";
}


// ===================================================================

#ifndef _MSC_VER
const int EncryptedClientIdentification::kServiceIdFieldNumber;
const int EncryptedClientIdentification::kServiceCertificateSerialNumberFieldNumber;
const int EncryptedClientIdentification::kEncryptedClientIdFieldNumber;
const int EncryptedClientIdentification::kEncryptedClientIdIvFieldNumber;
const int EncryptedClientIdentification::kEncryptedPrivacyKeyFieldNumber;
#endif  // !_MSC_VER

EncryptedClientIdentification::EncryptedClientIdentification()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void EncryptedClientIdentification::InitAsDefaultInstance()
{
}

EncryptedClientIdentification::EncryptedClientIdentification(const EncryptedClientIdentification& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void EncryptedClientIdentification::SharedCtor()
{
    _cached_size_ = 0;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    service_certificate_serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    encrypted_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    encrypted_client_id_iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    encrypted_privacy_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncryptedClientIdentification::~EncryptedClientIdentification()
{
    SharedDtor();
}

void EncryptedClientIdentification::SharedDtor()
{
    if (service_id_ != &::google::protobuf::internal::kEmptyString) {
        delete service_id_;
    }

    if (service_certificate_serial_number_ != &::google::protobuf::internal::kEmptyString) {
        delete service_certificate_serial_number_;
    }

    if (encrypted_client_id_ != &::google::protobuf::internal::kEmptyString) {
        delete encrypted_client_id_;
    }

    if (encrypted_client_id_iv_ != &::google::protobuf::internal::kEmptyString) {
        delete encrypted_client_id_iv_;
    }

    if (encrypted_privacy_key_ != &::google::protobuf::internal::kEmptyString) {
        delete encrypted_privacy_key_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void EncryptedClientIdentification::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EncryptedClientIdentification& EncryptedClientIdentification::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

EncryptedClientIdentification* EncryptedClientIdentification::default_instance_ = NULL;

EncryptedClientIdentification* EncryptedClientIdentification::New() const
{
    return new EncryptedClientIdentification;
}

void EncryptedClientIdentification::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_service_id()) {
            if (service_id_ != &::google::protobuf::internal::kEmptyString) {
                service_id_->clear();
            }
        }

        if (has_service_certificate_serial_number()) {
            if (service_certificate_serial_number_ != &::google::protobuf::internal::kEmptyString) {
                service_certificate_serial_number_->clear();
            }
        }

        if (has_encrypted_client_id()) {
            if (encrypted_client_id_ != &::google::protobuf::internal::kEmptyString) {
                encrypted_client_id_->clear();
            }
        }

        if (has_encrypted_client_id_iv()) {
            if (encrypted_client_id_iv_ != &::google::protobuf::internal::kEmptyString) {
                encrypted_client_id_iv_->clear();
            }
        }

        if (has_encrypted_privacy_key()) {
            if (encrypted_privacy_key_ != &::google::protobuf::internal::kEmptyString) {
                encrypted_privacy_key_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EncryptedClientIdentification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional string service_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_service_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_service_certificate_serial_number;

                break;
            }

            // optional bytes service_certificate_serial_number = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_service_certificate_serial_number:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_service_certificate_serial_number()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_encrypted_client_id;

                break;
            }

            // optional bytes encrypted_client_id = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_encrypted_client_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_encrypted_client_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_encrypted_client_id_iv;

                break;
            }

            // optional bytes encrypted_client_id_iv = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_encrypted_client_id_iv:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_encrypted_client_id_iv()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_encrypted_privacy_key;

                break;
            }

            // optional bytes encrypted_privacy_key = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_encrypted_privacy_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_encrypted_privacy_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void EncryptedClientIdentification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional string service_id = 1;
    if (has_service_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            1, this->service_id(), output);
    }

    // optional bytes service_certificate_serial_number = 2;
    if (has_service_certificate_serial_number()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->service_certificate_serial_number(), output);
    }

    // optional bytes encrypted_client_id = 3;
    if (has_encrypted_client_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            3, this->encrypted_client_id(), output);
    }

    // optional bytes encrypted_client_id_iv = 4;
    if (has_encrypted_client_id_iv()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->encrypted_client_id_iv(), output);
    }

    // optional bytes encrypted_privacy_key = 5;
    if (has_encrypted_privacy_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            5, this->encrypted_privacy_key(), output);
    }
}

int EncryptedClientIdentification::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional string service_id = 1;
        if (has_service_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->service_id());
        }

        // optional bytes service_certificate_serial_number = 2;
        if (has_service_certificate_serial_number()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->service_certificate_serial_number());
        }

        // optional bytes encrypted_client_id = 3;
        if (has_encrypted_client_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->encrypted_client_id());
        }

        // optional bytes encrypted_client_id_iv = 4;
        if (has_encrypted_client_id_iv()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->encrypted_client_id_iv());
        }

        // optional bytes encrypted_privacy_key = 5;
        if (has_encrypted_privacy_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->encrypted_privacy_key());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void EncryptedClientIdentification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const EncryptedClientIdentification*>(&from));
}

void EncryptedClientIdentification::MergeFrom(const EncryptedClientIdentification& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_service_id()) {
            set_service_id(from.service_id());
        }

        if (from.has_service_certificate_serial_number()) {
            set_service_certificate_serial_number(from.service_certificate_serial_number());
        }

        if (from.has_encrypted_client_id()) {
            set_encrypted_client_id(from.encrypted_client_id());
        }

        if (from.has_encrypted_client_id_iv()) {
            set_encrypted_client_id_iv(from.encrypted_client_id_iv());
        }

        if (from.has_encrypted_privacy_key()) {
            set_encrypted_privacy_key(from.encrypted_privacy_key());
        }
    }
}

void EncryptedClientIdentification::CopyFrom(const EncryptedClientIdentification& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool EncryptedClientIdentification::IsInitialized() const
{
    return true;
}

void EncryptedClientIdentification::Swap(EncryptedClientIdentification* other)
{
    if (other != this) {
        std::swap(service_id_, other->service_id_);
        std::swap(service_certificate_serial_number_, other->service_certificate_serial_number_);
        std::swap(encrypted_client_id_, other->encrypted_client_id_);
        std::swap(encrypted_client_id_iv_, other->encrypted_client_id_iv_);
        std::swap(encrypted_privacy_key_, other->encrypted_privacy_key_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string EncryptedClientIdentification::GetTypeName() const
{
    return "video_widevine_server.sdk.EncryptedClientIdentification";
}


// ===================================================================

bool DeviceCertificate_CertificateType_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const DeviceCertificate_CertificateType DeviceCertificate::ROOT;
const DeviceCertificate_CertificateType DeviceCertificate::INTERMEDIATE;
const DeviceCertificate_CertificateType DeviceCertificate::USER_DEVICE;
const DeviceCertificate_CertificateType DeviceCertificate::SERVICE;
const DeviceCertificate_CertificateType DeviceCertificate::CertificateType_MIN;
const DeviceCertificate_CertificateType DeviceCertificate::CertificateType_MAX;
const int DeviceCertificate::CertificateType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DeviceCertificate::kTypeFieldNumber;
const int DeviceCertificate::kSerialNumberFieldNumber;
const int DeviceCertificate::kCreationTimeSecondsFieldNumber;
const int DeviceCertificate::kPublicKeyFieldNumber;
const int DeviceCertificate::kSystemIdFieldNumber;
const int DeviceCertificate::kTestDeviceDeprecatedFieldNumber;
const int DeviceCertificate::kServiceIdFieldNumber;
#endif  // !_MSC_VER

DeviceCertificate::DeviceCertificate()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void DeviceCertificate::InitAsDefaultInstance()
{
}

DeviceCertificate::DeviceCertificate(const DeviceCertificate& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void DeviceCertificate::SharedCtor()
{
    _cached_size_ = 0;
    type_ = 0;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    creation_time_seconds_ = 0u;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    system_id_ = 0u;
    test_device_deprecated_ = false;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceCertificate::~DeviceCertificate()
{
    SharedDtor();
}

void DeviceCertificate::SharedDtor()
{
    if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
        delete serial_number_;
    }

    if (public_key_ != &::google::protobuf::internal::kEmptyString) {
        delete public_key_;
    }

    if (service_id_ != &::google::protobuf::internal::kEmptyString) {
        delete service_id_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void DeviceCertificate::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceCertificate& DeviceCertificate::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

DeviceCertificate* DeviceCertificate::default_instance_ = NULL;

DeviceCertificate* DeviceCertificate::New() const
{
    return new DeviceCertificate;
}

void DeviceCertificate::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        type_ = 0;

        if (has_serial_number()) {
            if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
                serial_number_->clear();
            }
        }

        creation_time_seconds_ = 0u;

        if (has_public_key()) {
            if (public_key_ != &::google::protobuf::internal::kEmptyString) {
                public_key_->clear();
            }
        }

        system_id_ = 0u;
        test_device_deprecated_ = false;

        if (has_service_id()) {
            if (service_id_ != &::google::protobuf::internal::kEmptyString) {
                service_id_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceCertificate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional .video_widevine_server.sdk.DeviceCertificate.CertificateType type = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::DeviceCertificate_CertificateType_IsValid(value)) {
                        set_type(static_cast< ::video_widevine_server::sdk::DeviceCertificate_CertificateType >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_serial_number;

                break;
            }

            // optional bytes serial_number = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_serial_number:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_serial_number()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(24)) goto parse_creation_time_seconds;

                break;
            }

            // optional uint32 creation_time_seconds = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_creation_time_seconds:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &creation_time_seconds_)));
                    set_has_creation_time_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_public_key;

                break;
            }

            // optional bytes public_key = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_public_key:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_public_key()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(40)) goto parse_system_id;

                break;
            }

            // optional uint32 system_id = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_system_id:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &system_id_)));
                    set_has_system_id();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(48)) goto parse_test_device_deprecated;

                break;
            }

            // optional bool test_device_deprecated = 6 [deprecated = true];
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_test_device_deprecated:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &test_device_deprecated_)));
                    set_has_test_device_deprecated();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(58)) goto parse_service_id;

                break;
            }

            // optional string service_id = 7;
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_service_id:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_service_id()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void DeviceCertificate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional .video_widevine_server.sdk.DeviceCertificate.CertificateType type = 1;
    if (has_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            1, this->type(), output);
    }

    // optional bytes serial_number = 2;
    if (has_serial_number()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->serial_number(), output);
    }

    // optional uint32 creation_time_seconds = 3;
    if (has_creation_time_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->creation_time_seconds(), output);
    }

    // optional bytes public_key = 4;
    if (has_public_key()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            4, this->public_key(), output);
    }

    // optional uint32 system_id = 5;
    if (has_system_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->system_id(), output);
    }

    // optional bool test_device_deprecated = 6 [deprecated = true];
    if (has_test_device_deprecated()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->test_device_deprecated(), output);
    }

    // optional string service_id = 7;
    if (has_service_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            7, this->service_id(), output);
    }
}

int DeviceCertificate::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional .video_widevine_server.sdk.DeviceCertificate.CertificateType type = 1;
        if (has_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
        }

        // optional bytes serial_number = 2;
        if (has_serial_number()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->serial_number());
        }

        // optional uint32 creation_time_seconds = 3;
        if (has_creation_time_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->creation_time_seconds());
        }

        // optional bytes public_key = 4;
        if (has_public_key()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->public_key());
        }

        // optional uint32 system_id = 5;
        if (has_system_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->system_id());
        }

        // optional bool test_device_deprecated = 6 [deprecated = true];
        if (has_test_device_deprecated()) {
            total_size += 1 + 1;
        }

        // optional string service_id = 7;
        if (has_service_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->service_id());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void DeviceCertificate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const DeviceCertificate*>(&from));
}

void DeviceCertificate::MergeFrom(const DeviceCertificate& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_type()) {
            set_type(from.type());
        }

        if (from.has_serial_number()) {
            set_serial_number(from.serial_number());
        }

        if (from.has_creation_time_seconds()) {
            set_creation_time_seconds(from.creation_time_seconds());
        }

        if (from.has_public_key()) {
            set_public_key(from.public_key());
        }

        if (from.has_system_id()) {
            set_system_id(from.system_id());
        }

        if (from.has_test_device_deprecated()) {
            set_test_device_deprecated(from.test_device_deprecated());
        }

        if (from.has_service_id()) {
            set_service_id(from.service_id());
        }
    }
}

void DeviceCertificate::CopyFrom(const DeviceCertificate& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool DeviceCertificate::IsInitialized() const
{
    return true;
}

void DeviceCertificate::Swap(DeviceCertificate* other)
{
    if (other != this) {
        std::swap(type_, other->type_);
        std::swap(serial_number_, other->serial_number_);
        std::swap(creation_time_seconds_, other->creation_time_seconds_);
        std::swap(public_key_, other->public_key_);
        std::swap(system_id_, other->system_id_);
        std::swap(test_device_deprecated_, other->test_device_deprecated_);
        std::swap(service_id_, other->service_id_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string DeviceCertificate::GetTypeName() const
{
    return "video_widevine_server.sdk.DeviceCertificate";
}


// ===================================================================

#ifndef _MSC_VER
const int SignedDeviceCertificate::kDeviceCertificateFieldNumber;
const int SignedDeviceCertificate::kSignatureFieldNumber;
const int SignedDeviceCertificate::kSignerFieldNumber;
#endif  // !_MSC_VER

SignedDeviceCertificate::SignedDeviceCertificate()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SignedDeviceCertificate::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    signer_ = const_cast< ::video_widevine_server::sdk::SignedDeviceCertificate*>(
                  ::video_widevine_server::sdk::SignedDeviceCertificate::internal_default_instance());
#else
    signer_ = const_cast< ::video_widevine_server::sdk::SignedDeviceCertificate*>(&::video_widevine_server::sdk::SignedDeviceCertificate::default_instance());
#endif
}

SignedDeviceCertificate::SignedDeviceCertificate(const SignedDeviceCertificate& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SignedDeviceCertificate::SharedCtor()
{
    _cached_size_ = 0;
    device_certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signer_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedDeviceCertificate::~SignedDeviceCertificate()
{
    SharedDtor();
}

void SignedDeviceCertificate::SharedDtor()
{
    if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
        delete device_certificate_;
    }

    if (signature_ != &::google::protobuf::internal::kEmptyString) {
        delete signature_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete signer_;
    }
}

void SignedDeviceCertificate::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignedDeviceCertificate& SignedDeviceCertificate::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SignedDeviceCertificate* SignedDeviceCertificate::default_instance_ = NULL;

SignedDeviceCertificate* SignedDeviceCertificate::New() const
{
    return new SignedDeviceCertificate;
}

void SignedDeviceCertificate::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_device_certificate()) {
            if (device_certificate_ != &::google::protobuf::internal::kEmptyString) {
                device_certificate_->clear();
            }
        }

        if (has_signature()) {
            if (signature_ != &::google::protobuf::internal::kEmptyString) {
                signature_->clear();
            }
        }

        if (has_signer()) {
            if (signer_ != NULL) signer_->::video_widevine_server::sdk::SignedDeviceCertificate::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignedDeviceCertificate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes device_certificate = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_device_certificate()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_signature;

                break;
            }

            // optional bytes signature = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signature:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signature()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_signer;

                break;
            }

            // optional .video_widevine_server.sdk.SignedDeviceCertificate signer = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signer:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_signer()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SignedDeviceCertificate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes device_certificate = 1;
    if (has_device_certificate()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->device_certificate(), output);
    }

    // optional bytes signature = 2;
    if (has_signature()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->signature(), output);
    }

    // optional .video_widevine_server.sdk.SignedDeviceCertificate signer = 3;
    if (has_signer()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            3, this->signer(), output);
    }
}

int SignedDeviceCertificate::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes device_certificate = 1;
        if (has_device_certificate()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->device_certificate());
        }

        // optional bytes signature = 2;
        if (has_signature()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signature());
        }

        // optional .video_widevine_server.sdk.SignedDeviceCertificate signer = 3;
        if (has_signer()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->signer());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SignedDeviceCertificate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SignedDeviceCertificate*>(&from));
}

void SignedDeviceCertificate::MergeFrom(const SignedDeviceCertificate& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_device_certificate()) {
            set_device_certificate(from.device_certificate());
        }

        if (from.has_signature()) {
            set_signature(from.signature());
        }

        if (from.has_signer()) {
            mutable_signer()->::video_widevine_server::sdk::SignedDeviceCertificate::MergeFrom(from.signer());
        }
    }
}

void SignedDeviceCertificate::CopyFrom(const SignedDeviceCertificate& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SignedDeviceCertificate::IsInitialized() const
{
    return true;
}

void SignedDeviceCertificate::Swap(SignedDeviceCertificate* other)
{
    if (other != this) {
        std::swap(device_certificate_, other->device_certificate_);
        std::swap(signature_, other->signature_);
        std::swap(signer_, other->signer_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SignedDeviceCertificate::GetTypeName() const
{
    return "video_widevine_server.sdk.SignedDeviceCertificate";
}


// ===================================================================

bool ProvisionedDeviceInfo_WvSecurityLevel_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::LEVEL_UNSPECIFIED;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::LEVEL_1;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::LEVEL_2;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::LEVEL_3;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::WvSecurityLevel_MIN;
const ProvisionedDeviceInfo_WvSecurityLevel ProvisionedDeviceInfo::WvSecurityLevel_MAX;
const int ProvisionedDeviceInfo::WvSecurityLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ProvisionedDeviceInfo::kSystemIdFieldNumber;
const int ProvisionedDeviceInfo::kSocFieldNumber;
const int ProvisionedDeviceInfo::kManufacturerFieldNumber;
const int ProvisionedDeviceInfo::kModelFieldNumber;
const int ProvisionedDeviceInfo::kDeviceTypeFieldNumber;
const int ProvisionedDeviceInfo::kModelYearFieldNumber;
const int ProvisionedDeviceInfo::kSecurityLevelFieldNumber;
const int ProvisionedDeviceInfo::kTestDeviceFieldNumber;
#endif  // !_MSC_VER

ProvisionedDeviceInfo::ProvisionedDeviceInfo()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void ProvisionedDeviceInfo::InitAsDefaultInstance()
{
}

ProvisionedDeviceInfo::ProvisionedDeviceInfo(const ProvisionedDeviceInfo& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void ProvisionedDeviceInfo::SharedCtor()
{
    _cached_size_ = 0;
    system_id_ = 0u;
    soc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    model_year_ = 0u;
    security_level_ = 0;
    test_device_ = false;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProvisionedDeviceInfo::~ProvisionedDeviceInfo()
{
    SharedDtor();
}

void ProvisionedDeviceInfo::SharedDtor()
{
    if (soc_ != &::google::protobuf::internal::kEmptyString) {
        delete soc_;
    }

    if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        delete manufacturer_;
    }

    if (model_ != &::google::protobuf::internal::kEmptyString) {
        delete model_;
    }

    if (device_type_ != &::google::protobuf::internal::kEmptyString) {
        delete device_type_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void ProvisionedDeviceInfo::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProvisionedDeviceInfo& ProvisionedDeviceInfo::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

ProvisionedDeviceInfo* ProvisionedDeviceInfo::default_instance_ = NULL;

ProvisionedDeviceInfo* ProvisionedDeviceInfo::New() const
{
    return new ProvisionedDeviceInfo;
}

void ProvisionedDeviceInfo::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        system_id_ = 0u;

        if (has_soc()) {
            if (soc_ != &::google::protobuf::internal::kEmptyString) {
                soc_->clear();
            }
        }

        if (has_manufacturer()) {
            if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
                manufacturer_->clear();
            }
        }

        if (has_model()) {
            if (model_ != &::google::protobuf::internal::kEmptyString) {
                model_->clear();
            }
        }

        if (has_device_type()) {
            if (device_type_ != &::google::protobuf::internal::kEmptyString) {
                device_type_->clear();
            }
        }

        model_year_ = 0u;
        security_level_ = 0;
        test_device_ = false;
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ProvisionedDeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional uint32 system_id = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &system_id_)));
                    set_has_system_id();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_soc;

                break;
            }

            // optional string soc = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_soc:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_soc()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(26)) goto parse_manufacturer;

                break;
            }

            // optional string manufacturer = 3;
            case 3: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_manufacturer:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_manufacturer()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_model;

                break;
            }

            // optional string model = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_model:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_model()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(42)) goto parse_device_type;

                break;
            }

            // optional string device_type = 5;
            case 5: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_device_type:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                            input, this->mutable_device_type()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(48)) goto parse_model_year;

                break;
            }

            // optional uint32 model_year = 6;
            case 6: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_model_year:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &model_year_)));
                    set_has_model_year();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(56)) goto parse_security_level;

                break;
            }

            // optional .video_widevine_server.sdk.ProvisionedDeviceInfo.WvSecurityLevel security_level = 7 [default = LEVEL_UNSPECIFIED];
            case 7: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_security_level:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel_IsValid(value)) {
                        set_security_level(static_cast< ::video_widevine_server::sdk::ProvisionedDeviceInfo_WvSecurityLevel >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(64)) goto parse_test_device;

                break;
            }

            // optional bool test_device = 8 [default = false];
            case 8: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_test_device:
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL > (
                             input, &test_device_)));
                    set_has_test_device();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void ProvisionedDeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional uint32 system_id = 1;
    if (has_system_id()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->system_id(), output);
    }

    // optional string soc = 2;
    if (has_soc()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            2, this->soc(), output);
    }

    // optional string manufacturer = 3;
    if (has_manufacturer()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            3, this->manufacturer(), output);
    }

    // optional string model = 4;
    if (has_model()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            4, this->model(), output);
    }

    // optional string device_type = 5;
    if (has_device_type()) {
        ::google::protobuf::internal::WireFormatLite::WriteString(
            5, this->device_type(), output);
    }

    // optional uint32 model_year = 6;
    if (has_model_year()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->model_year(), output);
    }

    // optional .video_widevine_server.sdk.ProvisionedDeviceInfo.WvSecurityLevel security_level = 7 [default = LEVEL_UNSPECIFIED];
    if (has_security_level()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            7, this->security_level(), output);
    }

    // optional bool test_device = 8 [default = false];
    if (has_test_device()) {
        ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->test_device(), output);
    }
}

int ProvisionedDeviceInfo::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional uint32 system_id = 1;
        if (has_system_id()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->system_id());
        }

        // optional string soc = 2;
        if (has_soc()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->soc());
        }

        // optional string manufacturer = 3;
        if (has_manufacturer()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->manufacturer());
        }

        // optional string model = 4;
        if (has_model()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->model());
        }

        // optional string device_type = 5;
        if (has_device_type()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->device_type());
        }

        // optional uint32 model_year = 6;
        if (has_model_year()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->model_year());
        }

        // optional .video_widevine_server.sdk.ProvisionedDeviceInfo.WvSecurityLevel security_level = 7 [default = LEVEL_UNSPECIFIED];
        if (has_security_level()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->security_level());
        }

        // optional bool test_device = 8 [default = false];
        if (has_test_device()) {
            total_size += 1 + 1;
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void ProvisionedDeviceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const ProvisionedDeviceInfo*>(&from));
}

void ProvisionedDeviceInfo::MergeFrom(const ProvisionedDeviceInfo& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_system_id()) {
            set_system_id(from.system_id());
        }

        if (from.has_soc()) {
            set_soc(from.soc());
        }

        if (from.has_manufacturer()) {
            set_manufacturer(from.manufacturer());
        }

        if (from.has_model()) {
            set_model(from.model());
        }

        if (from.has_device_type()) {
            set_device_type(from.device_type());
        }

        if (from.has_model_year()) {
            set_model_year(from.model_year());
        }

        if (from.has_security_level()) {
            set_security_level(from.security_level());
        }

        if (from.has_test_device()) {
            set_test_device(from.test_device());
        }
    }
}

void ProvisionedDeviceInfo::CopyFrom(const ProvisionedDeviceInfo& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool ProvisionedDeviceInfo::IsInitialized() const
{
    return true;
}

void ProvisionedDeviceInfo::Swap(ProvisionedDeviceInfo* other)
{
    if (other != this) {
        std::swap(system_id_, other->system_id_);
        std::swap(soc_, other->soc_);
        std::swap(manufacturer_, other->manufacturer_);
        std::swap(model_, other->model_);
        std::swap(device_type_, other->device_type_);
        std::swap(model_year_, other->model_year_);
        std::swap(security_level_, other->security_level_);
        std::swap(test_device_, other->test_device_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string ProvisionedDeviceInfo::GetTypeName() const
{
    return "video_widevine_server.sdk.ProvisionedDeviceInfo";
}


// ===================================================================

bool DeviceCertificateStatus_CertificateStatus_IsValid(int value)
{
    switch (value) {
        case 0:
        case 1:
            return true;

        default:
            return false;
    }
}

#ifndef _MSC_VER
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus::VALID;
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus::REVOKED;
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus::CertificateStatus_MIN;
const DeviceCertificateStatus_CertificateStatus DeviceCertificateStatus::CertificateStatus_MAX;
const int DeviceCertificateStatus::CertificateStatus_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DeviceCertificateStatus::kSerialNumberFieldNumber;
const int DeviceCertificateStatus::kStatusFieldNumber;
const int DeviceCertificateStatus::kDeviceInfoFieldNumber;
#endif  // !_MSC_VER

DeviceCertificateStatus::DeviceCertificateStatus()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void DeviceCertificateStatus::InitAsDefaultInstance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    device_info_ = const_cast< ::video_widevine_server::sdk::ProvisionedDeviceInfo*>(
                       ::video_widevine_server::sdk::ProvisionedDeviceInfo::internal_default_instance());
#else
    device_info_ = const_cast< ::video_widevine_server::sdk::ProvisionedDeviceInfo*>(&::video_widevine_server::sdk::ProvisionedDeviceInfo::default_instance());
#endif
}

DeviceCertificateStatus::DeviceCertificateStatus(const DeviceCertificateStatus& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void DeviceCertificateStatus::SharedCtor()
{
    _cached_size_ = 0;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    status_ = 0;
    device_info_ = NULL;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceCertificateStatus::~DeviceCertificateStatus()
{
    SharedDtor();
}

void DeviceCertificateStatus::SharedDtor()
{
    if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
        delete serial_number_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
        delete device_info_;
    }
}

void DeviceCertificateStatus::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceCertificateStatus& DeviceCertificateStatus::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

DeviceCertificateStatus* DeviceCertificateStatus::default_instance_ = NULL;

DeviceCertificateStatus* DeviceCertificateStatus::New() const
{
    return new DeviceCertificateStatus;
}

void DeviceCertificateStatus::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_serial_number()) {
            if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
                serial_number_->clear();
            }
        }

        status_ = 0;

        if (has_device_info()) {
            if (device_info_ != NULL) device_info_->::video_widevine_server::sdk::ProvisionedDeviceInfo::Clear();
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceCertificateStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes serial_number = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_serial_number()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(16)) goto parse_status;

                break;
            }

            // optional .video_widevine_server.sdk.DeviceCertificateStatus.CertificateStatus status = 2 [default = VALID];
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
parse_status:
                    int value;
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM > (
                             input, &value)));

                    if (::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus_IsValid(value)) {
                        set_status(static_cast< ::video_widevine_server::sdk::DeviceCertificateStatus_CertificateStatus >(value));
                    }
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(34)) goto parse_device_info;

                break;
            }

            // optional .video_widevine_server.sdk.ProvisionedDeviceInfo device_info = 4;
            case 4: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_device_info:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, mutable_device_info()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void DeviceCertificateStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes serial_number = 1;
    if (has_serial_number()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->serial_number(), output);
    }

    // optional .video_widevine_server.sdk.DeviceCertificateStatus.CertificateStatus status = 2 [default = VALID];
    if (has_status()) {
        ::google::protobuf::internal::WireFormatLite::WriteEnum(
            2, this->status(), output);
    }

    // optional .video_widevine_server.sdk.ProvisionedDeviceInfo device_info = 4;
    if (has_device_info()) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            4, this->device_info(), output);
    }
}

int DeviceCertificateStatus::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes serial_number = 1;
        if (has_serial_number()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->serial_number());
        }

        // optional .video_widevine_server.sdk.DeviceCertificateStatus.CertificateStatus status = 2 [default = VALID];
        if (has_status()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
        }

        // optional .video_widevine_server.sdk.ProvisionedDeviceInfo device_info = 4;
        if (has_device_info()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                              this->device_info());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void DeviceCertificateStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const DeviceCertificateStatus*>(&from));
}

void DeviceCertificateStatus::MergeFrom(const DeviceCertificateStatus& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_serial_number()) {
            set_serial_number(from.serial_number());
        }

        if (from.has_status()) {
            set_status(from.status());
        }

        if (from.has_device_info()) {
            mutable_device_info()->::video_widevine_server::sdk::ProvisionedDeviceInfo::MergeFrom(from.device_info());
        }
    }
}

void DeviceCertificateStatus::CopyFrom(const DeviceCertificateStatus& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool DeviceCertificateStatus::IsInitialized() const
{
    return true;
}

void DeviceCertificateStatus::Swap(DeviceCertificateStatus* other)
{
    if (other != this) {
        std::swap(serial_number_, other->serial_number_);
        std::swap(status_, other->status_);
        std::swap(device_info_, other->device_info_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string DeviceCertificateStatus::GetTypeName() const
{
    return "video_widevine_server.sdk.DeviceCertificateStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceCertificateStatusList::kCreationTimeSecondsFieldNumber;
const int DeviceCertificateStatusList::kCertificateStatusFieldNumber;
#endif  // !_MSC_VER

DeviceCertificateStatusList::DeviceCertificateStatusList()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void DeviceCertificateStatusList::InitAsDefaultInstance()
{
}

DeviceCertificateStatusList::DeviceCertificateStatusList(const DeviceCertificateStatusList& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void DeviceCertificateStatusList::SharedCtor()
{
    _cached_size_ = 0;
    creation_time_seconds_ = 0u;
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceCertificateStatusList::~DeviceCertificateStatusList()
{
    SharedDtor();
}

void DeviceCertificateStatusList::SharedDtor()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void DeviceCertificateStatusList::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceCertificateStatusList& DeviceCertificateStatusList::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

DeviceCertificateStatusList* DeviceCertificateStatusList::default_instance_ = NULL;

DeviceCertificateStatusList* DeviceCertificateStatusList::New() const
{
    return new DeviceCertificateStatusList;
}

void DeviceCertificateStatusList::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        creation_time_seconds_ = 0u;
    }

    certificate_status_.Clear();
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DeviceCertificateStatusList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional uint32 creation_time_seconds = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
                    DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive <
                         ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32 > (
                             input, &creation_time_seconds_)));
                    set_has_creation_time_seconds();
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_certificate_status;

                break;
            }

            // repeated .video_widevine_server.sdk.DeviceCertificateStatus certificate_status = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_certificate_status:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                            input, add_certificate_status()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_certificate_status;

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void DeviceCertificateStatusList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional uint32 creation_time_seconds = 1;
    if (has_creation_time_seconds()) {
        ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->creation_time_seconds(), output);
    }

    // repeated .video_widevine_server.sdk.DeviceCertificateStatus certificate_status = 2;
    for (int i = 0; i < this->certificate_status_size(); i++) {
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            2, this->certificate_status(i), output);
    }
}

int DeviceCertificateStatusList::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional uint32 creation_time_seconds = 1;
        if (has_creation_time_seconds()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::UInt32Size(
                              this->creation_time_seconds());
        }
    }

    // repeated .video_widevine_server.sdk.DeviceCertificateStatus certificate_status = 2;
    total_size += 1 * this->certificate_status_size();

    for (int i = 0; i < this->certificate_status_size(); i++) {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
                this->certificate_status(i));
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void DeviceCertificateStatusList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const DeviceCertificateStatusList*>(&from));
}

void DeviceCertificateStatusList::MergeFrom(const DeviceCertificateStatusList& from)
{
    GOOGLE_CHECK_NE(&from, this);
    certificate_status_.MergeFrom(from.certificate_status_);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_creation_time_seconds()) {
            set_creation_time_seconds(from.creation_time_seconds());
        }
    }
}

void DeviceCertificateStatusList::CopyFrom(const DeviceCertificateStatusList& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool DeviceCertificateStatusList::IsInitialized() const
{
    return true;
}

void DeviceCertificateStatusList::Swap(DeviceCertificateStatusList* other)
{
    if (other != this) {
        std::swap(creation_time_seconds_, other->creation_time_seconds_);
        certificate_status_.Swap(&other->certificate_status_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string DeviceCertificateStatusList::GetTypeName() const
{
    return "video_widevine_server.sdk.DeviceCertificateStatusList";
}


// ===================================================================

#ifndef _MSC_VER
const int SignedCertificateStatusList::kCertificateStatusListFieldNumber;
const int SignedCertificateStatusList::kSignatureFieldNumber;
#endif  // !_MSC_VER

SignedCertificateStatusList::SignedCertificateStatusList()
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
}

void SignedCertificateStatusList::InitAsDefaultInstance()
{
}

SignedCertificateStatusList::SignedCertificateStatusList(const SignedCertificateStatusList& from)
    : ::google::protobuf::MessageLite()
{
    SharedCtor();
    MergeFrom(from);
}

void SignedCertificateStatusList::SharedCtor()
{
    _cached_size_ = 0;
    certificate_status_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignedCertificateStatusList::~SignedCertificateStatusList()
{
    SharedDtor();
}

void SignedCertificateStatusList::SharedDtor()
{
    if (certificate_status_list_ != &::google::protobuf::internal::kEmptyString) {
        delete certificate_status_list_;
    }

    if (signature_ != &::google::protobuf::internal::kEmptyString) {
        delete signature_;
    }

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

    if (this != &default_instance()) {
#else

    if (this != default_instance_) {
#endif
    }
}

void SignedCertificateStatusList::SetCachedSize(int size) const
{
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SignedCertificateStatusList& SignedCertificateStatusList::default_instance()
{
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
    protobuf_AddDesc_license_5fprotocol_2eproto();
#else

    if (default_instance_ == NULL) protobuf_AddDesc_license_5fprotocol_2eproto();

#endif
    return *default_instance_;
}

SignedCertificateStatusList* SignedCertificateStatusList::default_instance_ = NULL;

SignedCertificateStatusList* SignedCertificateStatusList::New() const
{
    return new SignedCertificateStatusList;
}

void SignedCertificateStatusList::Clear()
{
    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (has_certificate_status_list()) {
            if (certificate_status_list_ != &::google::protobuf::internal::kEmptyString) {
                certificate_status_list_->clear();
            }
        }

        if (has_signature()) {
            if (signature_ != &::google::protobuf::internal::kEmptyString) {
                signature_->clear();
            }
        }
    }

    ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SignedCertificateStatusList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input)
{
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
    ::google::protobuf::uint32 tag;

    while ((tag = input->ReadTag()) != 0) {
        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
                // optional bytes certificate_status_list = 1;
            case 1: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_certificate_status_list()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectTag(18)) goto parse_signature;

                break;
            }

            // optional bytes signature = 2;
            case 2: {
                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
parse_signature:
                    DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                            input, this->mutable_signature()));
                } else {
                    goto handle_uninterpreted;
                }

                if (input->ExpectAtEnd()) return true;

                break;
            }

            default: {
handle_uninterpreted:

                if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
                    return true;
                }

                DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
                break;
            }
        }
    }

    return true;
#undef DO_
}

void SignedCertificateStatusList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const
{
    // optional bytes certificate_status_list = 1;
    if (has_certificate_status_list()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            1, this->certificate_status_list(), output);
    }

    // optional bytes signature = 2;
    if (has_signature()) {
        ::google::protobuf::internal::WireFormatLite::WriteBytes(
            2, this->signature(), output);
    }
}

int SignedCertificateStatusList::ByteSize() const
{
    int total_size = 0;

    if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        // optional bytes certificate_status_list = 1;
        if (has_certificate_status_list()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->certificate_status_list());
        }

        // optional bytes signature = 2;
        if (has_signature()) {
            total_size += 1 +
                          ::google::protobuf::internal::WireFormatLite::BytesSize(
                              this->signature());
        }
    }

    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _cached_size_ = total_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    return total_size;
}

void SignedCertificateStatusList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from)
{
    MergeFrom(*::google::protobuf::down_cast<const SignedCertificateStatusList*>(&from));
}

void SignedCertificateStatusList::MergeFrom(const SignedCertificateStatusList& from)
{
    GOOGLE_CHECK_NE(&from, this);

    if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
        if (from.has_certificate_status_list()) {
            set_certificate_status_list(from.certificate_status_list());
        }

        if (from.has_signature()) {
            set_signature(from.signature());
        }
    }
}

void SignedCertificateStatusList::CopyFrom(const SignedCertificateStatusList& from)
{
    if (&from == this) return;

    Clear();
    MergeFrom(from);
}

bool SignedCertificateStatusList::IsInitialized() const
{
    return true;
}

void SignedCertificateStatusList::Swap(SignedCertificateStatusList* other)
{
    if (other != this) {
        std::swap(certificate_status_list_, other->certificate_status_list_);
        std::swap(signature_, other->signature_);
        std::swap(_has_bits_[0], other->_has_bits_[0]);
        std::swap(_cached_size_, other->_cached_size_);
    }
}

::std::string SignedCertificateStatusList::GetTypeName() const
{
    return "video_widevine_server.sdk.SignedCertificateStatusList";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace video_widevine_server

// @@protoc_insertion_point(global_scope)
