/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the terms and
 *  conditions of a separate, written license agreement executed between you and Broadcom
 *  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 *  no license (express or implied), right to use, or waiver of any kind with respect to the
 *  Software, and Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 *  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 *  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 *  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 *  and to use this information only in connection with your use of Broadcom integrated circuit products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 *  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 *  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 *  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
 *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
 *  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
 *  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
 *  USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 *  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
 *  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
 *  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
 *  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
 *  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
 *  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
 *  ANY LIMITED REMEDY.

 ******************************************************************************/
#ifndef BWL_WL_H__
#define BWL_WL_H__

#define CAT_TX    (1<<0) /**< counter is transmit related */
#define CAT_RX    (1<<1) /**< counter is receive related */
#define CAT_ERR   (1<<2) /**< counter signals a non optimal condition */
#define CAT_UCAST (1<<3) /**< unicast specific counter */
#define CAT_MCAST (1<<4) /**< multicast or broadcast specific counter */
#define CAT_AMPDU (1<<5) /**< AMPDU specific counter */
#define CAT_UCODE (1<<6) /**< Counter is generated by ucode (contained in SHM in d11 core) */
#define CAT_CTRL  (1<<7) /**< Counters related to d11 control or mgmt frames */
#define CAT_SEC   (1<<8) /**< Counters related to security/encryption */
#define CAT_ASSOC (1<<9) /**< Counters related to authentication/association */

#define PRINIT() prcnt_init()
#define PRNL1()  prcnt_prnl1(p_cnt_filters)

#define PRFMT1(name) #name " %u "  /* converts into the 'default' counters printf format string */

/** prints one string without arguments */
#define PRSTR(name, str)                    \
    if (prcnt_filter1(p_cnt_filters, #name)) {        \
        printf("%s", str);                \
        at_start_of_line = FALSE;            \
    }

/** prints one variable with dtoh32 conversion */
#define PRVALV1(name)                        \
    if (prcnt_filter(p_cnt_filters, #name, cnt_v1->name)) {    \
        printf(PRFMT1(name), dtoh32(cnt_v1->name));    \
        at_start_of_line = FALSE;            \
    }

#define PRVAL(name)                        \
    if (prcnt_filter(p_cnt_filters, #name, cnt->name)) {    \
        printf(PRFMT1(name), dtoh32(cnt->name));    \
        at_start_of_line = FALSE;            \
    }
/** prints one variable with dtoh32 conversion */
#define PRVAL_RENAME(name, prname)                \
    if (prcnt_filter(p_cnt_filters, #name, cnt->name)) {    \
        printf(PRFMT1(prname), dtoh32(cnt->name));    \
        at_start_of_line = FALSE;            \
    }

/** Safe value print for only valid counter values, and when the counter is within len */
#define PRVALSF(name) \
    if ((dtoh32(cnt->name) != INVALID_CNT_VAL) &&        \
        (len > ((uint8 *)&cnt->name - (uint8 *)cnt)))    \
        PRVAL(name)

/** prints one variable with dtoh32 conversion */
#define PRVALSF_RENAME(varname, prname)                \
    if (dtoh32(cnt->varname) != INVALID_CNT_VAL)        \
        PRVAL_RENAME(varname, prname)

/** prints one variable with dtoh32 conversion */
#define PRVAL_FMTSTR1(varname, fmtstring, value)        \
    if (prcnt_filter(p_cnt_filters, #varname, value)) {    \
        printf(fmtstring, value);            \
        at_start_of_line = FALSE;            \
    }

/** prints two variables, no dtoh32 conversion */
#define PRVAL_FMTSTR2(varname, fmtstring, value1, value2)    \
    if (prcnt_filter(p_cnt_filters, #varname, value2)) {    \
        printf(fmtstring, value1, value2);        \
        at_start_of_line = FALSE;            \
    }

/** prints one float variable without dtoh32 conversion */
#define PRVAL_FMTSTR1F(varname, fmtstring, value1)    \
    if (prcnt_filter(p_cnt_filters, #varname, value1 != 0.0 ? TRUE : FALSE)) {    \
        printf(fmtstring, value1);                        \
        at_start_of_line = FALSE;                        \
    }

#define PRCNT_MACSTAT_TX_VER_GE11                        \
do {                                        \
    /* UCODE SHM counters */                        \
    /* tx start and those that do not end well */                \
    PRVAL(txallfrm); PRVAL(txbcnfrm); PRVAL(txrtsfrm); PRVAL(txctsfrm);    \
    PRVAL(txackfrm); PRVAL(txback); PRVAL(txdnlfrm); PRNL1();        \
    PRVAL(txampdu); PRVAL(txmpdu); PRVAL(txucast);                \
    PRVAL(rxrsptmout); PRVAL(txinrtstxop); PRVAL(txrtsfail); PRNL1();    \
    PRVAL_FMTSTR1F(txper_ucastdt, "txper_ucastdt %.1f%% ",            \
        cnt->txucast > 0 ?                        \
        (float)(1000 - ((cnt->rxackucast + cnt->rxback) * 1000        \
         / cnt->txucast))/10 : 0);                    \
    PRVAL_FMTSTR1F(txper_rts, "txper_rts %.1f%%",                \
        cnt->txrtsfrm > 0 ?                        \
        (float)(1000 - (cnt->rxctsucast * 1000                \
        / cnt->txrtsfrm))/10 : 0);                    \
    PRNL1();                                \
    PRSTR(txfunfl, "txfunfl: ");                        \
    for (i = 0; i < NFIFO; i++) {                        \
        PRVAL_FMTSTR1(txfunfl, "%u ", cnt->txfunfl[i]);            \
    }                                    \
    PRVAL(txtplunfl); PRVAL(txphyerror); PRNL1(); PRNL1();            \
} while (0)


#define PRCNT_MACSTAT_RX_VER_GE11                        \
do {                                        \
    /* rx with goodfcs */                            \
    PRVAL(rxctlucast); PRVAL(rxrtsucast); PRVAL(rxctsucast);        \
    PRVAL(rxackucast); PRVAL(rxback); PRNL1();                \
    PRVAL(rxbeaconmbss); PRVAL(rxdtucastmbss);                \
    PRVAL(rxmgucastmbss); PRNL1();                        \
    PRVAL(rxbeaconobss); PRVAL(rxdtucastobss); PRVAL(rxdtocast);        \
    PRVAL(rxmgocast); PRNL1();                        \
    PRVAL(rxctlocast); PRVAL(rxrtsocast); PRVAL(rxctsocast); PRNL1();    \
    PRVAL(rxctlmcast); PRVAL(rxdtmcast); PRVAL(rxmgmcast); PRNL1(); PRNL1();    \
                                        \
    PRVAL(rxcgprqfrm); PRVAL(rxcgprsqovfl); PRVAL(txcgprsfail);        \
    PRVAL(txcgprssuc); PRVAL(prs_timeout); PRNL1();                \
    PRVAL(pktengrxducast); PRVAL(pktengrxdmcast);                \
    PRVAL(bcntxcancl);                            \
} while (0)

/** Safe value store for only valid counter values, and when the counter is within len */
#define SAVALSF(name) wifi_counters.name = dtoh32(cnt->name)
#define PRINTVAL(name) printf("%s:%u: "#name" = %d \n", __FUNCTION__, __LINE__, wifi_counters.name )
#define SAVPCOUNTERS(name) pCounters->name=wifi_counters.name

static bool at_start_of_line; /**< prevents printing of empty lines */

/** specifies filters to apply when printing counters */
struct cnt_filters_s {
    bool nonzero;       /**< only print nonzero counter values */
    bool filters_active;    /**< FALSE when user did not supply cmd line options */
    bool invert_selection;  /**< inverts entire selection */
    uint32 filter;  /**< only print counters falling into these categorie(s). Ignored if 0. */
}cnt_filters_s;

typedef struct {
    char **pbuf_ptr;
    struct cnt_filters_s cnt_filters; /**< specifies filters to apply when printing counters */
} wl_cnt_cbfn_info_t;

/** specifies properties of each counter, so it can be optionally not printed on a criterium */
struct cnt_properties_s {
    char *name;
    uint32 categories; /**< a bitmask, '1' means that counter is a member of that category */
};

static const struct cnt_properties_s cnt_props[] = {
    {"active_ant", 0},
    {"ampdu_wds", CAT_AMPDU},
    {"auto_en", 0},
    {"avg_snr_per_ant0", 0},
    {"avg_snr_per_ant1", 0},
    {"avg_snr_per_ant2", 0},
    {"bcntxcancl",       CAT_TX | CAT_ERR | CAT_MCAST | CAT_UCODE},
    {"bphy_badplcp",     CAT_ERR | CAT_UCODE},
    {"bphy_rxcrsglitch", CAT_RX | CAT_ERR | CAT_UCODE},
    {"ccmpfmterr",       CAT_SEC | CAT_ERR},
    {"ccmpreplay",       CAT_SEC | CAT_ERR},
    {"ccmpundec",        CAT_SEC | CAT_ERR},
    {"cell_policy",      0},
    {"cfgrestore",       0},
    {"chained",          0},
    {"chainedsz1",       0},
    {"cso_normal",       0},
    {"cso_passthrough",  0},
    {"currchainsz",      0},
    {"dbgoff46", CAT_UCODE},
    {"dbgoff47", CAT_UCODE},
    {"dbgoff48", CAT_UCODE},
    {"decsuccess",       0},
    {"dma_hang",         CAT_ERR},
    {"fourwayfail",      CAT_ERR | CAT_CTRL | CAT_SEC | CAT_ASSOC},
    {"frmscons",         0},
    {"m2vmsg",           0},
    {"macxsusp",         0},
    {"maxchainsz",       0},
    {"mboxout",          0},
    {"missbcn_dbg",      CAT_ERR | CAT_MCAST | CAT_UCODE | CAT_CTRL},
    {"musnd",            CAT_CTRL},
    {"mws_antsel_ovr_rx", CAT_RX},
    {"mws_antsel_ovr_tx", CAT_TX},
    {"p2p_tbtt",       0},
    {"p2p_tbtt_miss",  CAT_ERR},
    {"pciereset",      CAT_ERR},
    {"phywatch",       CAT_UCODE},
    {"pktengrxdmcast", CAT_RX | CAT_MCAST | CAT_UCODE},
    {"pktengrxducast", CAT_RX | CAT_UCAST | CAT_UCODE},
    {"pmqovfl",        CAT_ERR | CAT_UCODE},
    {"prs_timeout",    CAT_ERR | CAT_UCODE},
    {"reinit",     CAT_ERR},
    {"reinitreason_counts",     CAT_ERR},
    {"reset",      CAT_ERR},
    {"rx11mbps",   CAT_RX},
    {"rx12mbps",   CAT_RX},
    {"rx18mbps",   CAT_RX},
    {"rx1mbps",    CAT_RX},
    {"rx24mbps",   CAT_RX},
    {"rx2mbps",    CAT_RX},
    {"rx36mbps",   CAT_RX},
    {"rx48mbps",   CAT_RX},
    {"rx54mbps",   CAT_RX},
    {"rx5mbps5",   CAT_RX},
    {"rx6mbps",    CAT_RX},
    {"rx9mbps",    CAT_RX},
    {"rx_policy",  CAT_RX},
    {"rxackucast", CAT_RX | CAT_UCAST | CAT_UCODE},
    {"rxaction",   CAT_RX | CAT_CTRL},
    {"rxanyerr",   CAT_RX | CAT_UCODE},
    {"rxassocreq", CAT_RX | CAT_CTRL | CAT_ASSOC},
    {"rxassocrsp", CAT_RX | CAT_CTRL | CAT_ASSOC},
    {"rxauth",  CAT_RX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
    {"rxback",  CAT_RX | CAT_UCODE},
    {"rxbadcm", CAT_RX | CAT_ERR | CAT_SEC},
    {"rxbadda", CAT_RX | CAT_CTRL},
    {"rxbadds", CAT_RX | CAT_CTRL},
    {"rxbadfcs",     CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxbadplcp",    CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxbadproto",   CAT_RX | CAT_ERR},
    {"rxbadsrcmac",  CAT_RX | CAT_ERR},
    {"rxbar",        CAT_RX | CAT_AMPDU | CAT_CTRL},
    {"rxbeaconmbss", CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxbeaconobss", CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxbyte",       CAT_RX},
    {"rxcfrmmcast",  CAT_RX | CAT_MCAST | CAT_CTRL},
    {"rxcfrmocast",  CAT_RX | CAT_CTRL},
    {"rxcfrmucast",  CAT_RX | CAT_UCAST | CAT_CTRL},
    {"rxcgprqfrm",   CAT_RX | CAT_UCODE},
    {"rxcgprsqovfl", CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxcount",      CAT_RX},
    {"rxcrc",        CAT_RX},
    {"rxcrsglitch",  CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxctl",        CAT_RX | CAT_CTRL},
    {"rxctlmcast",   CAT_RX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
    {"rxctlocast",      CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxctlucast",      CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
    {"rxctsocast",      CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxctsucast",      CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
    {"rxdeauth",        CAT_RX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
    {"rxdfrmmcast",     CAT_RX | CAT_MCAST},
    {"rxdfrmocast",     CAT_RX},
    {"rxdfrmucastmbss", CAT_RX | CAT_UCAST},
    {"rxdfrmucastobss", CAT_RX | CAT_UCAST},
    {"rxdisassoc",      CAT_RX | CAT_ERR | CAT_ASSOC},
    {"rxdrop20s",       CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxdtmcast",       CAT_RX | CAT_MCAST | CAT_UCODE},
    {"rxdtocast",       CAT_RX | CAT_UCODE},
    {"rxdtucastmbss",   CAT_RX | CAT_UCAST | CAT_UCODE},
    {"rxdtucastobss",   CAT_RX | CAT_UCAST | CAT_UCODE},
    {"rxdup",        CAT_RX | CAT_ERR},
    {"rxerror",      CAT_RX | CAT_ERR},
    {"rxf0ovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxf1ovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxf2ovfl",     CAT_RX | CAT_ERR},
    {"rxfilter",     CAT_RX},
    {"rxfrag",       CAT_RX},
    {"rxfragerr",    CAT_RX | CAT_ERR},
    {"rxframe",      CAT_RX},
    {"rxfrmtoolong", CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxfrmtooshrt", CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxgiant",      CAT_RX},
    {"rxhlovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxinvmachdr",  CAT_RX},
    {"rxmfrmmcast",  CAT_RX | CAT_MCAST},
    {"rxmfrmocast",  CAT_RX},
    {"rxmfrmucastmbss", CAT_RX | CAT_UCAST},
    {"rxmgmcast",       CAT_RX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
    {"rxmgocast",       CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxmgucastmbss",   CAT_RX| CAT_UCAST | CAT_UCODE | CAT_CTRL},
    {"rxmpdu_mu",    CAT_RX},
    {"rxmpdu_sgi",   CAT_RX},
    {"rxmpdu_stbc",  CAT_RX},
    {"rxmulti",      CAT_RX | CAT_MCAST},
    {"rxnack",       CAT_RX | CAT_ERR},
    {"rxnobuf",      CAT_RX | CAT_ERR},
    {"rxnodelim",    CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxnondata",    CAT_RX | CAT_ERR | CAT_CTRL},
    {"rxnoscb",      CAT_RX | CAT_ERR},
    {"rxnull",       CAT_RX | CAT_ERR},
    {"rxprobereq",   CAT_RX | CAT_CTRL},
    {"rxprobersp",   CAT_RX | CAT_CTRL},
    {"rxpspoll",     CAT_RX | CAT_CTRL},
    {"rxqosnull",    CAT_RX},
    {"rxreassocreq", CAT_RX | CAT_CTRL | CAT_ASSOC},
    {"rxreassocrsp", CAT_RX | CAT_CTRL | CAT_ASSOC},
    {"rxrsptmout",   CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxrtry",       CAT_RX | CAT_ERR},
    {"rxrtsocast",   CAT_RX | CAT_UCODE | CAT_CTRL},
    {"rxrtsucast",   CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
    {"rxrunt",       CAT_RX | CAT_ERR},
    {"rxstrt",       CAT_RX | CAT_UCODE},
    {"rxtoolate",    CAT_RX | CAT_ERR | CAT_UCODE},
    {"rxuflo",    CAT_RX | CAT_ERR},
    {"rxundec",      CAT_RX | CAT_SEC},
    {"sfb2v",        0},
    {"swap_alivecheck0",   0},
    {"swap_alivecheck1",   0},
    {"swap_ge_rxcount0",   CAT_RX},
    {"swap_ge_rxcount1",   CAT_RX},
    {"swap_ge_snrthresh0", 0},
    {"swap_ge_snrthresh1", 0},
    {"swap_snrdrop0", 0},
    {"swap_snrdrop1", 0},
    {"swap_timer0", 0},
    {"swap_timer1", 0},
    {"swap_trig_event_id", 0},
    {"swap_txfail0", CAT_TX | CAT_ERR},
    {"swap_txfail1", CAT_TX | CAT_ERR},
    {"tbtt", 0},
    {"tkipcntrmsr", CAT_SEC},
    {"tkipicverr", CAT_SEC},
    {"tkipmicfaill", CAT_ERR | CAT_SEC},
    {"tkipreplay", CAT_ERR | CAT_SEC},
    {"tx_active_ant", CAT_TX},
    {"tx_auto_en", CAT_TX},
    {"tx_policy", CAT_TX},
    {"txackfrm", CAT_TX | CAT_UCAST | CAT_UCODE},
    {"txaction", CAT_TX | CAT_CTRL},
    {"txallfrm", CAT_TX | CAT_UCODE},
    {"txampdu", CAT_TX | CAT_AMPDU | CAT_UCODE},
    {"txassocreq", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txassocrsp", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txauth", CAT_TX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
    {"txback", CAT_TX | CAT_UCODE},
    {"txbar", CAT_TX | CAT_AMPDU},
    {"txbcnfrm", CAT_TX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
    {"txbyte", CAT_TX},
    {"txcgprsfail", CAT_TX | CAT_ERR | CAT_UCODE},
    {"txcgprssuc", CAT_TX | CAT_UCODE},
    {"txchanrej", CAT_TX | CAT_ERR},
    {"txchit", CAT_TX},
    {"txcmiss", CAT_TX | CAT_ERR},
    {"txctsfrm", CAT_TX | CAT_UCODE | CAT_CTRL},
    {"txdatabcast", CAT_TX | CAT_MCAST},
    {"txdatamcast", CAT_TX | CAT_MCAST},
    {"txdeauth", CAT_TX | CAT_ERR | CAT_CTRL | CAT_SEC | CAT_ASSOC},
    {"txdisassoc", CAT_TX | CAT_ERR | CAT_CTRL | CAT_ASSOC},
    {"txdmawar", CAT_TX | CAT_ERR},
    {"txdnlfrm", CAT_TX | CAT_UCODE},
    {"txerror", CAT_TX | CAT_ERR},
    {"txfail", CAT_TX | CAT_ERR},
    {"txfbw", CAT_TX},
    {"txfrag", CAT_TX},
    {"txfrag", CAT_TX},
    {"txframe", CAT_TX},
    {"txfrmsnt", CAT_TX},
    {"txfunfl", CAT_TX | CAT_UCODE},
    {"txinrtstxop", CAT_TX | CAT_UCODE},
    {"txlost", CAT_TX | CAT_ERR},
    {"txmpdu", CAT_TX | CAT_UCODE},
    {"txmpdu_sgi", CAT_TX},
    {"txmpdu_stbc", CAT_TX},
    {"txmulti", CAT_TX | CAT_MCAST},
    {"txnack", CAT_TX | CAT_ERR | CAT_UCAST},
    {"txnoack", CAT_TX | CAT_ERR | CAT_UCAST},
    {"txnoassoc", CAT_TX | CAT_ERR | CAT_ASSOC},
    {"txnobuf", CAT_TX | CAT_ERR},
    {"txnocts", CAT_TX},
    {"txnull", CAT_TX},
    {"txper_rts", CAT_TX | CAT_ERR | CAT_CTRL},
    {"txper_ucastdt", CAT_TX | CAT_ERR | CAT_UCAST},
    {"txphycrs", CAT_TX},
    {"txphyerr", CAT_TX | CAT_ERR},
    {"txphyerror", CAT_TX | CAT_ERR | CAT_UCODE},
    {"txprobereq", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txprobersp", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txprshort", CAT_TX},
    {"txpspoll", CAT_TX | CAT_CTRL},
    {"txqosnull", CAT_TX | CAT_CTRL},
    {"txreassocreq", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txreassocrsp", CAT_TX | CAT_CTRL | CAT_ASSOC},
    {"txretrans", CAT_TX | CAT_ERR},
    {"txretrie", CAT_TX | CAT_ERR | CAT_UCAST},
    {"txretry", CAT_TX | CAT_ERR | CAT_UCAST},
    {"txrts", CAT_TX | CAT_CTRL},
    {"txrtsfail", CAT_TX | CAT_ERR | CAT_UCODE | CAT_CTRL},
    {"txrtsfrm", CAT_TX | CAT_UCODE | CAT_CTRL},
    {"txserr", CAT_TX | CAT_ERR},
    {"txsfovfl", CAT_TX | CAT_ERR},
    {"txtplunfl", CAT_TX | CAT_UCODE},
    {"txucast", CAT_TX | CAT_UCAST | CAT_UCODE},
    {"unchained", 0},
    {"v2mmsg",    0},
    {"wepicverr", CAT_ERR | CAT_SEC},
    {"wepundec", CAT_SEC},
    {NULL, 0}
};

typedef struct
{
    int reset;
    int txbyte;
    int txframe;
    int txretrans;
    int rxerror;
    int txnobuf;
    int txserr;
    int txphyerr;
    int txerror;
    int rxbyte;
    int rxframe;
    int rxnobuf;
    int rxnondata;
    int rxbadcm;
    int rxfragerr;
    int rxtoolate;
    int rxbadfcs;
    int rxfrmtooshrt;
    int rxf0ovfl;
    int rxf1ovfl;
    int pmqovfl;
} wifi_counters_t;

int wl_counters_cbfn(void *ctx, const unsigned char *data, unsigned short int type, unsigned short int len);

#endif /* BWL_WL_H__ */
