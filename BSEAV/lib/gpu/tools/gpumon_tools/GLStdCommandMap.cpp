/******************************************************************************************************
 * Copyright (C) 2018 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *****************************************************************************************************/

#include "GLStdCommandMap.h"

#include <sstream>
#include <iostream>
#include <vector>

using namespace std;

/* The argument types in the table below are defined as:
'a' : Attrib location
'b' : uint8
'B' : int8
'c' : char*
'd' : EGLDisplay
'e' : enum
'E' : EGL enum
'f' : float
'F' : float based enum
'g' : EGLimage
'h' : uint16
'H' : int16
'i' : Uniform location
'j' : Mangled texture location (TEXTURE0 + i)
'l' : EGLClientBuffer
'm' : bitmask
'M' : Framebuffer ID
'n' : EGLContext
'o' : EGLConfig
'p' : pointer
'P' : pointer for returned data
'r' : Program ID
's' : Shader ID
't' : boolean
'Y' : EGL boolean
'T' : Texture ID
'u' : EGLSurface
'w' : uint32
'W' : int32
'x' : uint32
'N' : Pipeline
'R' : Renderbuffer
'S' : Sampler
'U' : Buffer
'q' : Query
'y' : Sync
'Z' : TransformFeedback
*/

static string commandNames[] =
{
   "no_command", "v", "w", "",

   // This table content is auto-generated by running ./gen_hook_tables.py in v3dv3/tools/v3d/hook_codegen
   #include "commandmap.inc"
};

///////////////////////////////////////////////////////////////////////////////////

bool                    GLStdCommandMapper::m_inited = false;
map<string, eGLCommand> GLStdCommandMapper::m_map;

void GLStdCommandMapper::Init()
{
   if (!m_inited)
   {
      // Setup some overrides that we can't infer from the XML database
      commandNames[(int)(cmd_eglGetError * 4) + 1] = "E";      // Retcode is an EGL enum

      commandNames[(int)(cmd_glActiveTexture * 4) + 2] = "j";  // Not really an enum

      commandNames[(int)(cmd_eglQueryWaylandBufferWL * 4) + 2] = "dPEP";  // 3rd param is really an enum

      for (uint32_t a = 0; a < cmd_last; a++)
         m_map[commandNames[a * 4]] = (eGLCommand)(cmd_none + a);

      m_inited = true;
   }
}

eGLCommand GLStdCommandMapper::FromString(const string &str)
{
   Init();
   return m_map[str];
}

string GLStdCommandMapper::ToString(eGLCommand cmd)
{
   Init();
   if (cmd < NumCommands())
      return commandNames[(int)(cmd * 4)];
   return "unknown";
}

string GLStdCommandMapper::Signature(eGLCommand cmd)
{
   Init();
   if (cmd < NumCommands())
      return commandNames[(int)(cmd * 4) + 2];
   return "";
}

string GLStdCommandMapper::Signature(const string &str)
{
   return Signature(FromString(str));
}

int32_t GLStdCommandMapper::NumCommands()
{
   return cmd_last;
}

string GLStdCommandMapper::ReturnSignature(eGLCommand cmd)
{
   Init();
   if (cmd < NumCommands())
      return commandNames[(int)(cmd * 4) + 1];
   return "";
}

string GLStdCommandMapper::ReturnSignature(const string &str)
{
   return ReturnSignature(FromString(str));
}
