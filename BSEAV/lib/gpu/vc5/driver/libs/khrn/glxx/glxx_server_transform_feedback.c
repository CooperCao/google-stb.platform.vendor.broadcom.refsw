/******************************************************************************
 *  Copyright (C) 2016 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 ******************************************************************************/
#include "gl_public_api.h"
#include "../common/khrn_int_common.h"
#include "glxx_shared.h"

#include "glxx_server.h"
#include "glxx_server_internal.h"
#include "libs/util/dglenum/dglenum.h"

#include "glxx_buffer.h"
#include "../common/khrn_int_util.h"

#include "glxx_hw.h"
#include "glxx_translate.h"

#include "../gl20/gl20_shader.h"

#include "../common/khrn_render_state.h"

#include <string.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include "vcos.h"

#include "libs/platform/gmem.h"

static_assrt(V3D_MAX_TF_BUFFERS >= GLXX_CONFIG_MAX_TF_SEPARATE_ATTRIBS);

GLXX_TRANSFORM_FEEDBACK_T* glxx_get_bound_tf(GLXX_SERVER_STATE_T const* state)
{
   return state->transform_feedback.bound;
}

bool glxx_server_tf_install(GLXX_SERVER_STATE_T *state, GLXX_HW_RENDER_STATE_T *rs, bool point_size_used)
{
   bool res = true;

   if (state->transform_feedback.in_use)
   {
      GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.bound;
      const GLXX_PROGRAM_TFF_POST_LINK_T *ptf = &gl20_program_common_get(state)->transform_feedback;
      res = glxx_tf_record_enable(rs, tf, ptf, point_size_used);
   }
   else
   {
#if V3D_VER_AT_LEAST(4,0,2,0)
      res = glxx_tf_record_disable(rs);
#endif
   }
   return res;
}

bool glxx_server_tf_install_post_draw(GLXX_SERVER_STATE_T *state, GLXX_HW_RENDER_STATE_T *rs)
{
   if (!state->transform_feedback.in_use)
      return true;

   return glxx_tf_post_draw(rs, state->transform_feedback.bound);
}

/*  The error INVALID_OPERATION is generated by LinkProgram  or ProgramBinary
 *  if program is the name of a program being used by one or more transform
 *  feedback objects,  even if the objects are not currently bound or are
 *  paused
 */
typedef struct {
   GL20_PROGRAM_T  *program;
   bool             used;
} TF_PROGRAM_USED_INFO_T;

static void program_used_by_tf(khrn_map *map, uint32_t key, void *value, void *info_)
{
   TF_PROGRAM_USED_INFO_T *info = info_;
   if (info->used)
      return;

   GLXX_TRANSFORM_FEEDBACK_T *tf = value;
   if (tf->program != NULL && tf->program == info->program)
      info->used = true;
}

// add to header & add to link program
bool glxx_server_program_used_by_any_tf(GLXX_SERVER_STATE_T *state, GL20_PROGRAM_T *program)
{
   TF_PROGRAM_USED_INFO_T info;
   info.program  = program;
   info.used     = false;

   khrn_map_iterate(&state->transform_feedback.objects, program_used_by_tf, &info);
   return info.used;
}

GLXX_TRANSFORM_FEEDBACK_T *glxx_get_transform_feedback(GLXX_SERVER_STATE_T *state, uint32_t id)
{
   return khrn_map_lookup(&state->transform_feedback.objects, id);
}

GL_API void GL_APIENTRY glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   GLenum err = GL_NO_ERROR;
   int i = 0;
   uint32_t start_name = state->transform_feedback.next;

   if (n < 0)
   {
      err = GL_INVALID_VALUE;
      goto end;
   }

   if (ids)
   {
      while (i < n)
      {
         if (glxx_get_transform_feedback(state, state->transform_feedback.next) == NULL)
         {
            GLXX_TRANSFORM_FEEDBACK_T *tf = glxx_tf_create(state->transform_feedback.next);
            if (!tf)
            {
               err = GL_OUT_OF_MEMORY;
               goto end;
            }

            khrn_map_insert(&state->transform_feedback.objects, state->transform_feedback.next, tf);
            // the map has a reference, release ours
            KHRN_MEM_ASSIGN(tf, NULL);

            ids[i++] = state->transform_feedback.next;
         }
         ++state->transform_feedback.next;
      }
   }

end:
   if (err != GL_NO_ERROR)
   {
      /* delete all the newly created tf and set error */
      for (int j = 0; j < i; j++)
         khrn_map_delete(&state->queries.objects, ids[j]);

      state->queries.next_name = start_name;
      glxx_server_state_set_error(state, err);
   }

   glxx_unlock_server_state();
}

GL_API GLboolean GL_APIENTRY glIsTransformFeedback(GLuint id)
{
   GLboolean result = GL_FALSE;
   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state_unchanged(OPENGL_ES_3X);
   if (!state) return result;

   if (id == 0) goto end; /* spec says that if id is 0, this function returns false */

   tf = glxx_get_transform_feedback(state, id); /* no error is generated if the
                                                   id is not the name of a
                                                   transform feedback */
   if (tf != NULL && glxx_tf_was_created(tf))
      result = GL_TRUE;

end:
   glxx_unlock_server_state();
   return result;
}

GL_API void GL_APIENTRY glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   if (n < 0)
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
   else if (ids)
   {
      //  The error INVALID_OPERATION is generated by DeleteTransformFeedbacks
      //  if the transform feedback operation for any object named by ids is
      //  currently active.
      for (int i = 0; i < n; i++)
      {
         if (ids[i])
         {
            GLXX_TRANSFORM_FEEDBACK_T *tf = glxx_get_transform_feedback(state, ids[i]);

            if (tf != NULL && glxx_tf_is_active(tf))
            {
               glxx_server_state_set_error(state, GL_INVALID_OPERATION);
               goto unlock_out;
            }
         }
      }

      for (int i = 0; i < n; i++)
      {
         if (ids[i] == (GLuint)state->transform_feedback.bound->name) {
            KHRN_MEM_ASSIGN(state->transform_feedback.bound, state->transform_feedback.default_tf);
         }

         if (ids[i])
            khrn_map_delete(&state->transform_feedback.objects, ids[i]);
      }
   }

unlock_out:
   glxx_unlock_server_state();
}

GL_API void GL_APIENTRY glBindTransformFeedback(GLenum target, GLuint id)
{
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   if (target != GL_TRANSFORM_FEEDBACK)
   {
      glxx_server_state_set_error(state, GL_INVALID_ENUM);
      goto unlock_out;
   }

   if (state->transform_feedback.in_use)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   GLXX_TRANSFORM_FEEDBACK_T *tf = NULL;
   if (id == 0)
      tf = state->transform_feedback.default_tf;
   else
      // Set create = false, because name 'id' must have
      // been already created by GenTransformFeedbacks
      tf = glxx_get_transform_feedback(state, id);

   if (tf == NULL)
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
   else
   {
      KHRN_MEM_ASSIGN(state->transform_feedback.bound, tf);

      tf->status |= GLXX_TF_CREATED;
   }

unlock_out:
   glxx_unlock_server_state();
}

GL_API void GL_APIENTRY glBeginTransformFeedback(GLenum primitiveMode)
{
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);

   if (!state)
      return;

   if (primitiveMode != GL_TRIANGLES && primitiveMode != GL_LINES && primitiveMode != GL_POINTS)
   {
      glxx_server_state_set_error(state, GL_INVALID_ENUM);
      goto unlock_out;
   }

   //  The error INVALID_OPERATION is also generated by BeginTransformFeedback
   //  if no binding points would be used, either because no program object is
   //  active or because the active program object has specified no output
   //  variables to record.
   if (state->current_program == NULL && state->pipelines.bound == NULL)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   GL20_PROGRAM_COMMON_T *program_common = gl20_program_common_get(state);
   if (!gl20_validate_program(state, program_common))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   if (program_common->transform_feedback.varying_count == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   GLXX_TRANSFORM_FEEDBACK_T  *tf = state->transform_feedback.bound;

   if (glxx_tf_is_active(tf))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   /* we've already checked the program is linked */
   assert(program_common->link_status);
   const GLXX_PROGRAM_TFF_POST_LINK_T *ptf = &program_common->transform_feedback;
   for (unsigned i = 0; i < ptf->addr_count; ++i)
   {
      /* INVALID_OPERATION is generated by BeginTransformFeedback if any
       * binding point used in transform feedback mode does not have a buffer object bound
       */
      const GLXX_BUFFER_T *buffer = tf->binding_points[i].buffer.obj;
      if (buffer == NULL)
      {
         glxx_server_state_set_error(state, GL_INVALID_OPERATION);
         goto unlock_out;
      }
   }

   assert(tf->res == NULL);
   tf->res = khrn_resource_create_no_storage(1);
   if (tf->res == NULL)
   {
      glxx_server_state_set_error(state, GL_OUT_OF_MEMORY);
      goto unlock_out;
   }

   /* we need to lock the buffers used by binding points;
    * additional locking is needed in fmem; this way the buffers stay locked
    * during BeginTF/EndTF and also till frame completes, whatever comes last;
    * this is needed for store/load tf */
   tf->num_active_buffers = ptf->addr_count;
   for (unsigned i = 0; i < tf->num_active_buffers; ++i)
   {
      GLXX_INDEXED_BINDING_POINT_T *binding = &tf->binding_points[i];

      glxx_tf_active_buffer *active = &tf->active_buffers[i];

      active->res = binding->buffer.obj->resource;
      active->size = glxx_indexed_binding_point_get_size(binding);
      active->offset = binding->offset;
      /* if the user didn't call bindData, we end up not having a resource */
      if (active->res)
      {
         khrn_resource_refinc(active->res);
         active->addr = khrn_resource_get_addr(active->res);
      }
      else
      {
         assert(active->size == 0);
         active->addr = 0;
      }

#if !V3D_VER_AT_LEAST(4,0,2,0)
      active->stream_position = 0;
#endif
   }

   tf->status |= GLXX_TF_ACTIVE;
   tf->prim_mode = primitiveMode;

   // Record the currently program or vertex program in pipeline
   KHRN_MEM_ASSIGN(tf->program,  gl20_get_tf_program(state));
   state->transform_feedback.in_use = true;

unlock_out:
   glxx_unlock_server_state();
}

GL_API void GL_APIENTRY glPauseTransformFeedback(void)
{
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.bound;

   //  The error INVALID_OPERATION is generated by PauseTransformFeedback
   //  if the currently bound transform feedback is not active or is paused.
   if (!glxx_tf_is_active(tf))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }
   if (glxx_tf_is_paused(tf))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }

   tf->status |= GLXX_TF_PAUSED;
   state->transform_feedback.in_use = false;

out:
   glxx_unlock_server_state();
}

GL_API void GL_APIENTRY glResumeTransformFeedback(void)
{
   GLenum err = GL_NO_ERROR;
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.bound;

   //  The error INVALID_OPERATION is generated by ResumeTransformFeedback
   //  if the currently bound transform feedback is not active or is not paused
   if (!glxx_tf_is_paused(tf))
   {
      err = GL_INVALID_OPERATION;
      goto end;
   }
   assert(glxx_tf_is_active(tf)); /* paused status can be true only for an active tf */

   /* the program (or program pipeline object)  used by the tf must be the same
    * as the currently installed one */
   if (tf->program != gl20_get_tf_program(state))
   {
      err = GL_INVALID_OPERATION;
      goto end;
   }

   tf->status &= ~GLXX_TF_PAUSED;
   state->transform_feedback.in_use = true;

end:
   if (err != GL_NO_ERROR)
      glxx_server_state_set_error(state, err);
   glxx_unlock_server_state();
}

GL_API void GL_APIENTRY glEndTransformFeedback(void)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GLXX_SERVER_STATE_T *state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   tf = state->transform_feedback.bound;

   if (!glxx_tf_is_active(tf))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }

   tf->status &= ~(GLXX_TF_ACTIVE | GLXX_TF_PAUSED);
   khrn_resource_refdec(tf->res);
   tf->res = NULL;
   for (unsigned i = 0 ; i < tf->num_active_buffers; i++)
   {
      khrn_resource_refdec(tf->active_buffers[i].res);
      tf->active_buffers[i].res = NULL;
      tf->active_buffers[i].offset = 0;
      tf->active_buffers[i].size = 0;
   }
   tf->num_active_buffers = 0;
   KHRN_MEM_ASSIGN(tf->program, NULL);
   state->transform_feedback.in_use = false;

out:
   glxx_unlock_server_state();
}

//  glGetTransformFeedbackVarying() is in gl20_program.c

GL_API void GL_APIENTRY glTransformFeedbackVaryings(
   GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode)
{
   GLXX_SERVER_STATE_T *state;
   GL20_PROGRAM_T *p;
   unsigned i;

   state = glxx_lock_server_state(OPENGL_ES_3X);
   if (!state) return;

   if (bufferMode != GL_INTERLEAVED_ATTRIBS && bufferMode != GL_SEPARATE_ATTRIBS)
   {
      glxx_server_state_set_error(state, GL_INVALID_ENUM);
      goto unlock_out;
   }
   if (count < 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
      goto unlock_out;
   }
   if (bufferMode == GL_SEPARATE_ATTRIBS &&
       count > GLXX_CONFIG_MAX_TF_SEPARATE_ATTRIBS)
   {
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
      goto unlock_out;
   }

   p = gl20_get_program(state, program);

   if (p == NULL)
      /* error is set by gl20_get_program */
      goto unlock_out;

   p->transform_feedback.buffer_mode = bufferMode;
   p->transform_feedback.varying_count = count;

   for (i = 0; i < GLXX_CONFIG_MAX_TF_INTERLEAVED_COMPONENTS; ++i) {
      // In case we are re-assigning this program's TF varyings.
      free(p->transform_feedback.name[i]);
      p->transform_feedback.name[i] = NULL;
   }

   for (i = 0; i < gfx_umin(count, GLXX_CONFIG_MAX_TF_INTERLEAVED_COMPONENTS); ++i) {
      p->transform_feedback.name[i] = strdup(varyings[i]);
      if (p->transform_feedback.name[i] == NULL) {
         glxx_server_state_set_error(state, GL_OUT_OF_MEMORY);
      }
   }

unlock_out:
   glxx_unlock_server_state();
}
