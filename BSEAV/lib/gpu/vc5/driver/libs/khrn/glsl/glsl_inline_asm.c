/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 ******************************************************************************/

/* WARNING: This file is autogenerated from inline_qasm/ - DO NOT EDIT */

#include <string.h>
#include <stdint.h>

#include "glsl_inline_asm.h"
#include "libs/core/v3d/v3d_gen.h"
#include "libs/util/common.h"

static const uint64_t cs_barrier_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3de031917d838001ull, // [0x00000008] shr syncu, r0, 1
0x3c003186bb800000ull, // [0x00000010] nop
#elif V3D_HAS_RELAXED_THRSW
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3de031917d838001ull, // [0x00000008] shr syncu, r0, 1
0x3c003186bb800000ull, // [0x00000010] nop
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3de031917d838001ull, // [0x00000008] shr syncu, r0, 1
0x3c003186bb800000ull, // [0x00000010] nop
#else
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3de031917d838001ull, // [0x00000008] shr syncu, r0, 1
0x3c003186bb800000ull, // [0x00000010] nop
#endif
};
const struct inline_qasm cs_barrier = { cs_barrier_instrs, countof(cs_barrier_instrs) };

static const uint64_t cs_barrier_lthrsw_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop    ; nop ; thrsw
0x3de031917d838001ull, // [0x00000010] shr syncu, r0, 1
#elif V3D_HAS_RELAXED_THRSW
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop    ; nop ; thrsw
0x3de031917d838001ull, // [0x00000010] shr syncu, r0, 1
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop    ; nop ; thrsw
0x3de031917d838001ull, // [0x00000010] shr syncu, r0, 1
#else
0x3c203180bb80f000ull, // [0x00000000] ycd r0 ; nop ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop    ; nop ; thrsw
0x3de031917d838001ull, // [0x00000010] shr syncu, r0, 1
#endif
};
const struct inline_qasm cs_barrier_lthrsw = { cs_barrier_lthrsw_instrs, countof(cs_barrier_lthrsw_instrs) };

static const uint64_t cs_barrier_preamble_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3d10f180bb80f000ull, // [0x00000000] ycd r0                  ;  nop                   ;  ldvary
0x3c207186bb802000ull, // [0x00000008] eidx.pushz -            ;  nop                   ;  thrsw
0x3de050c07df78001ull, // [0x00000010] shr.pushz r0, r0, 1     ;  mov rf3, r5
0x3dfc80c37de3e0d0ull, // [0x00000018] shr.ifna rf3, rf3, -16  ;  mov.ifnb rf3, r0
0x3c003191b68360c0ull, // [0x00000020] mov syncu, rf3          ;  nop
#elif V3D_HAS_RELAXED_THRSW
0x3d003180bb80f000ull, // [0x00000000] ycd r0                  ;  nop                   ;  ldvary
0x3c207186bb802000ull, // [0x00000008] eidx.pushz -            ;  nop                   ;  thrsw
0x3de050c07df78001ull, // [0x00000010] shr.pushz r0, r0, 1     ;  mov rf3, r5
0x3dfc80c37de3e0d0ull, // [0x00000018] shr.ifna rf3, rf3, -16  ;  mov.ifnb rf3, r0
0x3c003191b68360c0ull, // [0x00000020] mov syncu, rf3          ;  nop
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3d003186bb800000ull, // [0x00000000] nop                     ;  nop                   ;  ldvary
0x3de47040bbfcf000ull, // [0x00000008] ycd r0                  ;  mov.pushz r1, 0
0x3c2e7306bbe42000ull, // [0x00000010] eidx.pushz -            ;  mov.ifna tmua, r1     ;  thrsw
0x3de050c07df78001ull, // [0x00000018] shr.pushz r0, r0, 1     ;  mov rf3, r5
0x3dfc80c37de3e0d0ull, // [0x00000020] shr.ifna rf3, rf3, -16  ;  mov.ifnb rf3, r0
0x3c803186bb800000ull, // [0x00000028] nop                     ;  nop                   ;  ldtmu
0x3c003191b68360c0ull, // [0x00000030] mov syncu, rf3          ;  nop
#else
0x3dc46044bbfcf000ull, // [0x00000000] ycd rf4                 ;  mov.pushz r1, 0       ; ldvary
0x3d2e7306bbe42000ull, // [0x00000008] eidx.pushz -            ;  mov.ifna tmua, r1     ; ldvary; thrsw
0x3de061847d83e101ull, // [0x00000010] shr.pushz rf4, rf4, 1   ;  nop
0x3df080c37df7d010ull, // [0x00000018] shr.ifna rf3, r5, -16   ;  mov.ifa rf3, r5
0x3c8b2183b6836100ull, // [0x00000020] mov.ifnb rf3, rf4       ;  nop                   ; ldtmu
0x3c003191b68360c0ull, // [0x00000028] mov syncu, rf3          ;  nop
#endif
};
const struct inline_qasm cs_barrier_preamble = { cs_barrier_preamble_instrs, countof(cs_barrier_preamble_instrs) };

static const uint64_t cs_one_thread_wait_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c003186bb800000ull, // [0x00000000] nop
#elif V3D_HAS_RELAXED_THRSW
0x3c003186bb800000ull, // [0x00000000] nop
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c003186bb800000ull, // [0x00000000] nop
#else
0x3c003186bb800000ull, // [0x00000000] nop
#endif
};
const struct inline_qasm cs_one_thread_wait = { cs_one_thread_wait_instrs, countof(cs_one_thread_wait_instrs) };

static const uint64_t cs_pad_setmsf_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c003186bb800000ull, // [0x00000000] nop
0x3e30f186bb800000ull, // [0x00000008] nop                     ;  ldtlbu
0x3de071867d83b00full, // [0x00000010] shr.pushz -, r3, 15
0x3dea3186ba837000ull, // [0x00000018] setmsf.ifna -, 0
#elif V3D_HAS_RELAXED_THRSW
0x3c003186bb800000ull, // [0x00000000] nop
0x3e203186bb800000ull, // [0x00000008] nop                     ;  ldtlbu
0x3de071867d83b00full, // [0x00000010] shr.pushz -, r3, 15
0x3dea3186ba837000ull, // [0x00000018] setmsf.ifna -, 0
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3e203186bb800000ull, // [0x00000000] nop                     ;  ldtlbu
0x3de071867d83b00full, // [0x00000008] shr.pushz -, r3, 15
0x3dea3186ba837000ull, // [0x00000010] setmsf.ifna -, 0
#else
0x3e203186bb800000ull, // [0x00000000] nop                     ;  ldtlbu
0x3de071867d83b00full, // [0x00000008] shr.pushz -, r3, 15
0x3dea3186ba837000ull, // [0x00000010] setmsf.ifna -, 0
#endif
};
const struct inline_qasm cs_pad_setmsf = { cs_pad_setmsf_instrs, countof(cs_pad_setmsf_instrs) };

static const uint64_t cs_pad_setmsf_with_barriers_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c003186bb800000ull, // [0x00000000] nop                     ;  nop
0x3e30f186bb800000ull, // [0x00000008] nop                     ;  nop               ;  ldtlbu
0x3de074467dfbb0cfull, // [0x00000010] shr.pushz -, r3, 15     ;  mov syncu, rf3
0x3dea3186ba837000ull, // [0x00000018] setmsf.ifna -, 0        ;  nop
#elif V3D_HAS_RELAXED_THRSW
0x3c003186bb800000ull, // [0x00000000] nop                     ;  nop
0x3e203186bb800000ull, // [0x00000008] nop                     ;  nop               ;  ldtlbu
0x3de074467dfbb0cfull, // [0x00000010] shr.pushz -, r3, 15     ;  mov syncu, rf3
0x3dea3186ba837000ull, // [0x00000018] setmsf.ifna -, 0        ;  nop
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3e203186bb800000ull, // [0x00000000] nop                     ;  nop               ;  ldtlbu
0x3de074467dfbb0cfull, // [0x00000008] shr.pushz -, r3, 15     ;  mov syncu, rf3
0x3dea3186ba837000ull, // [0x00000010] setmsf.ifna -, 0        ;  nop
#else
0x3e203186bb800000ull, // [0x00000000] nop                     ;  nop               ;  ldtlbu
0x3de074467dfbb0cfull, // [0x00000008] shr.pushz -, r3, 15     ;  mov syncu, rf3
0x3dea3186ba837000ull, // [0x00000010] setmsf.ifna -, 0        ;  nop
#endif
};
const struct inline_qasm cs_pad_setmsf_with_barriers = { cs_pad_setmsf_with_barriers_instrs, countof(cs_pad_setmsf_with_barriers_instrs) };

static const uint64_t cs_scoreboard_wait_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c203186bb800000ull, // [0x00000000] nop                  ;  thrsw
0x3c003186bb800000ull, // [0x00000008] nop
0x3c003186bb800000ull, // [0x00000010] nop
#elif V3D_HAS_RELAXED_THRSW
0x3c203186bb800000ull, // [0x00000000] nop                  ;  thrsw
0x3c003186bb800000ull, // [0x00000008] nop
0x3c003186bb800000ull, // [0x00000010] nop
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c207180b7800000ull, // [0x00000000] xor.pushz r0, r0, r0 ;  thrsw
0x3c0a318cb6800000ull, // [0x00000008] mov.ifna tmua, r0
0x3c003186bb800000ull, // [0x00000010] nop
0x3c803186bb800000ull, // [0x00000018] nop                  ;  ldtmu
#else
0x3c207180b7800000ull, // [0x00000000] xor.pushz r0, r0, r0 ;  thrsw
0x3c0a318cb6800000ull, // [0x00000008] mov.ifna tmua, r0
0x3c003186bb800000ull, // [0x00000010] nop
0x3c803186bb800000ull, // [0x00000018] nop                  ;  ldtmu
#endif
};
const struct inline_qasm cs_scoreboard_wait = { cs_scoreboard_wait_instrs, countof(cs_scoreboard_wait_instrs) };

static const uint64_t tcs_barrier_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c003186bb800000ull, // [0x00000008] nop
0x3c003186bb816000ull, // [0x00000010] vpmwt
#elif V3D_HAS_RELAXED_THRSW
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c003186bb800000ull, // [0x00000008] nop
0x3c003186bb816000ull, // [0x00000010] vpmwt
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c003186bb800000ull, // [0x00000008] nop
0x3c003186bb816000ull, // [0x00000010] vpmwt
#else
0x3c003186bb800000ull, // [0x00000000] nop
#endif
};
const struct inline_qasm tcs_barrier = { tcs_barrier_instrs, countof(tcs_barrier_instrs) };

static const uint64_t tcs_barrier_lthrsw_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop           ; thrsw
0x3c003186bb816000ull, // [0x00000010] vpmwt
#elif V3D_HAS_RELAXED_THRSW
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop           ; thrsw
0x3c003186bb816000ull, // [0x00000010] vpmwt
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c203191bb814000ull, // [0x00000000] patchid syncu ; thrsw
0x3c203186bb800000ull, // [0x00000008] nop           ; thrsw
0x3c003186bb816000ull, // [0x00000010] vpmwt
#else
0x3c003186bb800000ull, // [0x00000000] nop
#endif
};
const struct inline_qasm tcs_barrier_lthrsw = { tcs_barrier_lthrsw_instrs, countof(tcs_barrier_lthrsw_instrs) };

static const uint64_t tcs_barrier_preamble_instrs[] = {
#if V3D_HAS_SIG_TO_MAGIC
0x3c407186bb802000ull, // [0x00000000] eidx.pushz -                      ; ldunif
0x3c0c00c3bbf54000ull, // [0x00000008] patchid rf3     ; mov.ifa rf3, r5
0x3c003191b68360c0ull, // [0x00000010] mov syncu, rf3
#elif V3D_HAS_RELAXED_THRSW
0x3c407186bb802000ull, // [0x00000000] eidx.pushz -                      ; ldunif
0x3c0c00c3bbf54000ull, // [0x00000008] patchid rf3     ; mov.ifa rf3, r5
0x3c003191b68360c0ull, // [0x00000010] mov syncu, rf3
#elif V3D_VER_AT_LEAST(4,0,2,0)
0x3c407186bb802000ull, // [0x00000000] eidx.pushz -                      ; ldunif
0x3c0c00c3bbf54000ull, // [0x00000008] patchid rf3     ; mov.ifa rf3, r5
0x3c003191b68360c0ull, // [0x00000010] mov syncu, rf3
#else
0x3c003186bb800000ull, // [0x00000000] nop
#endif
};
const struct inline_qasm tcs_barrier_preamble = { tcs_barrier_preamble_instrs, countof(tcs_barrier_preamble_instrs) };


#if V3D_VER_AT_LEAST(4,0,2,0)
#define gfxh1370_tsy_op(op) (op)
#else
/* Work around GFXH-1370 by setting the high 3 bits of TSY configs. */
#define gfxh1370_tsy_op(op) (0xE0 | (op))
#endif

static const umap_entry cs_barrier_preamble_unifs[] = {
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF00 | gfxh1370_tsy_op(V3D_TSY_OP_SET_QUORUM) }
};
const struct inline_umap cs_barrier_preamble_unif = { .unifs = cs_barrier_preamble_unifs, .size = countof(cs_barrier_preamble_unifs) };

static const umap_entry tcs_barrier_preamble_unifs[] = {
   { BACKEND_UNIFORM_SPECIAL, BACKEND_SPECIAL_UNIFORM_TCS_QUORUM },
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF00 | gfxh1370_tsy_op(V3D_TSY_OP_SET_QUORUM) }
};
const struct inline_umap tcs_barrier_preamble_unif = { .unifs = tcs_barrier_preamble_unifs, .size = countof(tcs_barrier_preamble_unifs) };

static const umap_entry cs_pad_setmsf_with_barriers_unifs[] = {
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF78 },   // 1 element, I32 format from RT0
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF00 | gfxh1370_tsy_op(V3D_TSY_OP_SET_QUORUM) }
};
const struct inline_umap cs_pad_setmsf_with_barriers_unif = { .unifs = cs_pad_setmsf_with_barriers_unifs, .size = countof(cs_pad_setmsf_with_barriers_unifs) };

static const umap_entry cs_pad_setmsf_unifs[] = {
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF78 } // 1 element, I32 format from RT0
};
const struct inline_umap cs_pad_setmsf_unif = { .unifs = cs_pad_setmsf_unifs, .size = countof(cs_pad_setmsf_unifs) };

// unif for all barrier codes
static const umap_entry barrier_unifs[] = {
   /* NOTE: GFXH-1370 workaround, see above. */
   { BACKEND_UNIFORM_LITERAL, 0xFFFFFF00 | gfxh1370_tsy_op(V3D_TSY_OP_WAIT_INC_CHECK) }
};
const struct inline_umap barrier_unif = { .unifs = barrier_unifs, .size = countof(barrier_unifs) };
