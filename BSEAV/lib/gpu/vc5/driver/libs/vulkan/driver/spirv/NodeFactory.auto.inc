/******************************************************************************************************
 * Copyright (C) 2018 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *****************************************************************************************************/

/* Auto-generated by libs/vulkan/scripts/spirv/spirv.py */
/*                   DO NOT HAND EDIT                   */

switch (extr.GetOpCode())
{
case spv::Core::OpNop:
   node = m_allocator.New<NodeNop>(extr); break;
case spv::Core::OpUndef:
   node = m_allocator.New<NodeUndef>(extr); break;
case spv::Core::OpSourceContinued:
   node = m_allocator.New<NodeSourceContinued>(extr); break;
case spv::Core::OpSource:
   node = m_allocator.New<NodeSource>(extr); break;
case spv::Core::OpSourceExtension:
   node = m_allocator.New<NodeSourceExtension>(extr); break;
case spv::Core::OpName:
   node = m_allocator.New<NodeName>(extr); break;
case spv::Core::OpMemberName:
   node = m_allocator.New<NodeMemberName>(extr); break;
case spv::Core::OpString:
   node = m_allocator.New<NodeString>(extr); break;
case spv::Core::OpLine:
   node = m_allocator.New<NodeLine>(extr); break;
case spv::Core::OpExtension:
   node = m_allocator.New<NodeExtension>(extr); break;
case spv::Core::OpExtInstImport:
   node = m_allocator.New<NodeExtInstImport>(extr); break;
case spv::Core::OpExtInst:
   switch (extr.GetExtOpCode())
   {
   case spv::GLSL::Round:
      node = m_allocator.New<NodeStdRound>(extr); break;
   case spv::GLSL::RoundEven:
      node = m_allocator.New<NodeStdRoundEven>(extr); break;
   case spv::GLSL::Trunc:
      node = m_allocator.New<NodeStdTrunc>(extr); break;
   case spv::GLSL::FAbs:
      node = m_allocator.New<NodeStdFAbs>(extr); break;
   case spv::GLSL::SAbs:
      node = m_allocator.New<NodeStdSAbs>(extr); break;
   case spv::GLSL::FSign:
      node = m_allocator.New<NodeStdFSign>(extr); break;
   case spv::GLSL::SSign:
      node = m_allocator.New<NodeStdSSign>(extr); break;
   case spv::GLSL::Floor:
      node = m_allocator.New<NodeStdFloor>(extr); break;
   case spv::GLSL::Ceil:
      node = m_allocator.New<NodeStdCeil>(extr); break;
   case spv::GLSL::Fract:
      node = m_allocator.New<NodeStdFract>(extr); break;
   case spv::GLSL::Radians:
      node = m_allocator.New<NodeStdRadians>(extr); break;
   case spv::GLSL::Degrees:
      node = m_allocator.New<NodeStdDegrees>(extr); break;
   case spv::GLSL::Sin:
      node = m_allocator.New<NodeStdSin>(extr); break;
   case spv::GLSL::Cos:
      node = m_allocator.New<NodeStdCos>(extr); break;
   case spv::GLSL::Tan:
      node = m_allocator.New<NodeStdTan>(extr); break;
   case spv::GLSL::Asin:
      node = m_allocator.New<NodeStdAsin>(extr); break;
   case spv::GLSL::Acos:
      node = m_allocator.New<NodeStdAcos>(extr); break;
   case spv::GLSL::Atan:
      node = m_allocator.New<NodeStdAtan>(extr); break;
   case spv::GLSL::Sinh:
      node = m_allocator.New<NodeStdSinh>(extr); break;
   case spv::GLSL::Cosh:
      node = m_allocator.New<NodeStdCosh>(extr); break;
   case spv::GLSL::Tanh:
      node = m_allocator.New<NodeStdTanh>(extr); break;
   case spv::GLSL::Asinh:
      node = m_allocator.New<NodeStdAsinh>(extr); break;
   case spv::GLSL::Acosh:
      node = m_allocator.New<NodeStdAcosh>(extr); break;
   case spv::GLSL::Atanh:
      node = m_allocator.New<NodeStdAtanh>(extr); break;
   case spv::GLSL::Atan2:
      node = m_allocator.New<NodeStdAtan2>(extr); break;
   case spv::GLSL::Pow:
      node = m_allocator.New<NodeStdPow>(extr); break;
   case spv::GLSL::Exp:
      node = m_allocator.New<NodeStdExp>(extr); break;
   case spv::GLSL::Log:
      node = m_allocator.New<NodeStdLog>(extr); break;
   case spv::GLSL::Exp2:
      node = m_allocator.New<NodeStdExp2>(extr); break;
   case spv::GLSL::Log2:
      node = m_allocator.New<NodeStdLog2>(extr); break;
   case spv::GLSL::Sqrt:
      node = m_allocator.New<NodeStdSqrt>(extr); break;
   case spv::GLSL::InverseSqrt:
      node = m_allocator.New<NodeStdInverseSqrt>(extr); break;
   case spv::GLSL::Determinant:
      node = m_allocator.New<NodeStdDeterminant>(extr); break;
   case spv::GLSL::MatrixInverse:
      node = m_allocator.New<NodeStdMatrixInverse>(extr); break;
   case spv::GLSL::Modf:
      node = m_allocator.New<NodeStdModf>(extr); break;
   case spv::GLSL::ModfStruct:
      node = m_allocator.New<NodeStdModfStruct>(extr); break;
   case spv::GLSL::FMin:
      node = m_allocator.New<NodeStdFMin>(extr); break;
   case spv::GLSL::UMin:
      node = m_allocator.New<NodeStdUMin>(extr); break;
   case spv::GLSL::SMin:
      node = m_allocator.New<NodeStdSMin>(extr); break;
   case spv::GLSL::FMax:
      node = m_allocator.New<NodeStdFMax>(extr); break;
   case spv::GLSL::UMax:
      node = m_allocator.New<NodeStdUMax>(extr); break;
   case spv::GLSL::SMax:
      node = m_allocator.New<NodeStdSMax>(extr); break;
   case spv::GLSL::FClamp:
      node = m_allocator.New<NodeStdFClamp>(extr); break;
   case spv::GLSL::UClamp:
      node = m_allocator.New<NodeStdUClamp>(extr); break;
   case spv::GLSL::SClamp:
      node = m_allocator.New<NodeStdSClamp>(extr); break;
   case spv::GLSL::FMix:
      node = m_allocator.New<NodeStdFMix>(extr); break;
   case spv::GLSL::IMix:
      node = m_allocator.New<NodeStdIMix>(extr); break;
   case spv::GLSL::Step:
      node = m_allocator.New<NodeStdStep>(extr); break;
   case spv::GLSL::SmoothStep:
      node = m_allocator.New<NodeStdSmoothStep>(extr); break;
   case spv::GLSL::Fma:
      node = m_allocator.New<NodeStdFma>(extr); break;
   case spv::GLSL::Frexp:
      node = m_allocator.New<NodeStdFrexp>(extr); break;
   case spv::GLSL::FrexpStruct:
      node = m_allocator.New<NodeStdFrexpStruct>(extr); break;
   case spv::GLSL::Ldexp:
      node = m_allocator.New<NodeStdLdexp>(extr); break;
   case spv::GLSL::PackSnorm4x8:
      node = m_allocator.New<NodeStdPackSnorm4x8>(extr); break;
   case spv::GLSL::PackUnorm4x8:
      node = m_allocator.New<NodeStdPackUnorm4x8>(extr); break;
   case spv::GLSL::PackSnorm2x16:
      node = m_allocator.New<NodeStdPackSnorm2x16>(extr); break;
   case spv::GLSL::PackUnorm2x16:
      node = m_allocator.New<NodeStdPackUnorm2x16>(extr); break;
   case spv::GLSL::PackHalf2x16:
      node = m_allocator.New<NodeStdPackHalf2x16>(extr); break;
   case spv::GLSL::UnpackSnorm2x16:
      node = m_allocator.New<NodeStdUnpackSnorm2x16>(extr); break;
   case spv::GLSL::UnpackUnorm2x16:
      node = m_allocator.New<NodeStdUnpackUnorm2x16>(extr); break;
   case spv::GLSL::UnpackHalf2x16:
      node = m_allocator.New<NodeStdUnpackHalf2x16>(extr); break;
   case spv::GLSL::UnpackSnorm4x8:
      node = m_allocator.New<NodeStdUnpackSnorm4x8>(extr); break;
   case spv::GLSL::UnpackUnorm4x8:
      node = m_allocator.New<NodeStdUnpackUnorm4x8>(extr); break;
   case spv::GLSL::Length:
      node = m_allocator.New<NodeStdLength>(extr); break;
   case spv::GLSL::Distance:
      node = m_allocator.New<NodeStdDistance>(extr); break;
   case spv::GLSL::Cross:
      node = m_allocator.New<NodeStdCross>(extr); break;
   case spv::GLSL::Normalize:
      node = m_allocator.New<NodeStdNormalize>(extr); break;
   case spv::GLSL::FaceForward:
      node = m_allocator.New<NodeStdFaceForward>(extr); break;
   case spv::GLSL::Reflect:
      node = m_allocator.New<NodeStdReflect>(extr); break;
   case spv::GLSL::Refract:
      node = m_allocator.New<NodeStdRefract>(extr); break;
   case spv::GLSL::FindILsb:
      node = m_allocator.New<NodeStdFindILsb>(extr); break;
   case spv::GLSL::FindSMsb:
      node = m_allocator.New<NodeStdFindSMsb>(extr); break;
   case spv::GLSL::FindUMsb:
      node = m_allocator.New<NodeStdFindUMsb>(extr); break;
   case spv::GLSL::InterpolateAtCentroid:
      node = m_allocator.New<NodeStdInterpolateAtCentroid>(extr); break;
   case spv::GLSL::InterpolateAtSample:
      node = m_allocator.New<NodeStdInterpolateAtSample>(extr); break;
   case spv::GLSL::InterpolateAtOffset:
      node = m_allocator.New<NodeStdInterpolateAtOffset>(extr); break;
   case spv::GLSL::NMin:
      node = m_allocator.New<NodeStdNMin>(extr); break;
   case spv::GLSL::NMax:
      node = m_allocator.New<NodeStdNMax>(extr); break;
   case spv::GLSL::NClamp:
      node = m_allocator.New<NodeStdNClamp>(extr); break;
   default:
      log_warn("Unhandled GLSLstd450 instruction (%u)", static_cast<uint32_t>(extr.GetExtOpCode())); break;
   }
   break;
case spv::Core::OpMemoryModel:
   node = m_allocator.New<NodeMemoryModel>(extr); break;
case spv::Core::OpEntryPoint:
   node = m_allocator.New<NodeEntryPoint>(extr); break;
case spv::Core::OpExecutionMode:
   node = m_allocator.New<NodeExecutionMode>(extr); break;
case spv::Core::OpCapability:
   node = m_allocator.New<NodeCapability>(extr); break;
case spv::Core::OpTypeVoid:
   node = m_allocator.New<NodeTypeVoid>(extr); break;
case spv::Core::OpTypeBool:
   node = m_allocator.New<NodeTypeBool>(extr); break;
case spv::Core::OpTypeInt:
   node = m_allocator.New<NodeTypeInt>(extr); break;
case spv::Core::OpTypeFloat:
   node = m_allocator.New<NodeTypeFloat>(extr); break;
case spv::Core::OpTypeVector:
   node = m_allocator.New<NodeTypeVector>(extr); break;
case spv::Core::OpTypeMatrix:
   node = m_allocator.New<NodeTypeMatrix>(extr); break;
case spv::Core::OpTypeImage:
   node = m_allocator.New<NodeTypeImage>(extr); break;
case spv::Core::OpTypeSampler:
   node = m_allocator.New<NodeTypeSampler>(extr); break;
case spv::Core::OpTypeSampledImage:
   node = m_allocator.New<NodeTypeSampledImage>(extr); break;
case spv::Core::OpTypeArray:
   node = m_allocator.New<NodeTypeArray>(extr, false); break;
case spv::Core::OpTypeRuntimeArray:
   node = m_allocator.New<NodeTypeArray>(extr, true); break;
case spv::Core::OpTypeStruct:
   node = m_allocator.New<NodeTypeStruct>(extr); break;
case spv::Core::OpTypePointer:
   node = m_allocator.New<NodeTypePointer>(extr); break;
case spv::Core::OpTypeFunction:
   node = m_allocator.New<NodeTypeFunction>(extr); break;
case spv::Core::OpConstantTrue:
   node = m_allocator.New<NodeConstantTrue>(extr); break;
case spv::Core::OpConstantFalse:
   node = m_allocator.New<NodeConstantFalse>(extr); break;
case spv::Core::OpConstant:
   node = m_allocator.New<NodeConstant>(extr); break;
case spv::Core::OpConstantComposite:
   node = m_allocator.New<NodeConstantComposite>(extr); break;
case spv::Core::OpConstantNull:
   node = m_allocator.New<NodeConstantNull>(extr); break;
case spv::Core::OpSpecConstantTrue:
   node = m_allocator.New<NodeSpecConstantTrue>(extr); break;
case spv::Core::OpSpecConstantFalse:
   node = m_allocator.New<NodeSpecConstantFalse>(extr); break;
case spv::Core::OpSpecConstant:
   node = m_allocator.New<NodeSpecConstant>(extr); break;
case spv::Core::OpSpecConstantComposite:
   node = m_allocator.New<NodeSpecConstantComposite>(extr); break;
case spv::Core::OpSpecConstantOp:
   node = m_allocator.New<NodeSpecConstantOp>(extr); break;
case spv::Core::OpFunction:
   node = m_allocator.New<NodeFunction>(extr); break;
case spv::Core::OpFunctionParameter:
   node = m_allocator.New<NodeFunctionParameter>(extr); break;
case spv::Core::OpFunctionEnd:
   node = m_allocator.New<NodeFunctionEnd>(extr); break;
case spv::Core::OpFunctionCall:
   node = m_allocator.New<NodeFunctionCall>(extr); break;
case spv::Core::OpVariable:
   node = m_allocator.New<NodeVariable>(extr); break;
case spv::Core::OpImageTexelPointer:
   node = m_allocator.New<NodeImageTexelPointer>(extr); break;
case spv::Core::OpLoad:
   node = m_allocator.New<NodeLoad>(extr); break;
case spv::Core::OpStore:
   node = m_allocator.New<NodeStore>(extr); break;
case spv::Core::OpCopyMemory:
   node = m_allocator.New<NodeCopyMemory>(extr); break;
case spv::Core::OpAccessChain:
   node = m_allocator.New<NodeAccessChain>(extr, false); break;
case spv::Core::OpInBoundsAccessChain:
   node = m_allocator.New<NodeAccessChain>(extr, true); break;
case spv::Core::OpArrayLength:
   node = m_allocator.New<NodeArrayLength>(extr); break;
case spv::Core::OpDecorate:
   node = m_allocator.New<NodeDecorate>(extr); break;
case spv::Core::OpMemberDecorate:
   node = m_allocator.New<NodeMemberDecorate>(extr); break;
case spv::Core::OpDecorationGroup:
   node = m_allocator.New<NodeDecorationGroup>(extr); break;
case spv::Core::OpGroupDecorate:
   node = m_allocator.New<NodeGroupDecorate>(extr); break;
case spv::Core::OpGroupMemberDecorate:
   node = m_allocator.New<NodeGroupMemberDecorate>(extr); break;
case spv::Core::OpVectorExtractDynamic:
   node = m_allocator.New<NodeVectorExtractDynamic>(extr); break;
case spv::Core::OpVectorInsertDynamic:
   node = m_allocator.New<NodeVectorInsertDynamic>(extr); break;
case spv::Core::OpVectorShuffle:
   node = m_allocator.New<NodeVectorShuffle>(extr); break;
case spv::Core::OpCompositeConstruct:
   node = m_allocator.New<NodeCompositeConstruct>(extr); break;
case spv::Core::OpCompositeExtract:
   node = m_allocator.New<NodeCompositeExtract>(extr); break;
case spv::Core::OpCompositeInsert:
   node = m_allocator.New<NodeCompositeInsert>(extr); break;
case spv::Core::OpCopyObject:
   node = m_allocator.New<NodeCopyObject>(extr); break;
case spv::Core::OpTranspose:
   node = m_allocator.New<NodeTranspose>(extr); break;
case spv::Core::OpSampledImage:
   node = m_allocator.New<NodeSampledImage>(extr); break;
case spv::Core::OpImageSampleImplicitLod:
   node = m_allocator.New<NodeImageSampleImplicitLod>(extr); break;
case spv::Core::OpImageSampleExplicitLod:
   node = m_allocator.New<NodeImageSampleExplicitLod>(extr); break;
case spv::Core::OpImageSampleDrefImplicitLod:
   node = m_allocator.New<NodeImageSampleDrefImplicitLod>(extr); break;
case spv::Core::OpImageSampleDrefExplicitLod:
   node = m_allocator.New<NodeImageSampleDrefExplicitLod>(extr); break;
case spv::Core::OpImageSampleProjImplicitLod:
   node = m_allocator.New<NodeImageSampleProjImplicitLod>(extr); break;
case spv::Core::OpImageSampleProjExplicitLod:
   node = m_allocator.New<NodeImageSampleProjExplicitLod>(extr); break;
case spv::Core::OpImageSampleProjDrefImplicitLod:
   node = m_allocator.New<NodeImageSampleProjDrefImplicitLod>(extr); break;
case spv::Core::OpImageSampleProjDrefExplicitLod:
   node = m_allocator.New<NodeImageSampleProjDrefExplicitLod>(extr); break;
case spv::Core::OpImageFetch:
   node = m_allocator.New<NodeImageFetch>(extr); break;
case spv::Core::OpImageGather:
   node = m_allocator.New<NodeImageGather>(extr); break;
case spv::Core::OpImageDrefGather:
   node = m_allocator.New<NodeImageDrefGather>(extr); break;
case spv::Core::OpImageRead:
   node = m_allocator.New<NodeImageRead>(extr); break;
case spv::Core::OpImageWrite:
   node = m_allocator.New<NodeImageWrite>(extr); break;
case spv::Core::OpImage:
   node = m_allocator.New<NodeImage>(extr); break;
case spv::Core::OpImageQuerySizeLod:
   node = m_allocator.New<NodeImageQuerySizeLod>(extr); break;
case spv::Core::OpImageQuerySize:
   node = m_allocator.New<NodeImageQuerySize>(extr); break;
case spv::Core::OpImageQueryLod:
   node = m_allocator.New<NodeImageQueryLod>(extr); break;
case spv::Core::OpImageQueryLevels:
   node = m_allocator.New<NodeImageQueryLevels>(extr); break;
case spv::Core::OpImageQuerySamples:
   node = m_allocator.New<NodeImageQuerySamples>(extr); break;
case spv::Core::OpConvertFToU:
   node = m_allocator.New<NodeConvertFToU>(extr); break;
case spv::Core::OpConvertFToS:
   node = m_allocator.New<NodeConvertFToS>(extr); break;
case spv::Core::OpConvertSToF:
   node = m_allocator.New<NodeConvertSToF>(extr); break;
case spv::Core::OpConvertUToF:
   node = m_allocator.New<NodeConvertUToF>(extr); break;
case spv::Core::OpUConvert:
   node = m_allocator.New<NodeUConvert>(extr); break;
case spv::Core::OpSConvert:
   node = m_allocator.New<NodeSConvert>(extr); break;
case spv::Core::OpFConvert:
   node = m_allocator.New<NodeFConvert>(extr); break;
case spv::Core::OpQuantizeToF16:
   node = m_allocator.New<NodeQuantizeToF16>(extr); break;
case spv::Core::OpBitcast:
   node = m_allocator.New<NodeBitcast>(extr); break;
case spv::Core::OpSNegate:
   node = m_allocator.New<NodeSNegate>(extr); break;
case spv::Core::OpFNegate:
   node = m_allocator.New<NodeFNegate>(extr); break;
case spv::Core::OpIAdd:
   node = m_allocator.New<NodeIAdd>(extr); break;
case spv::Core::OpFAdd:
   node = m_allocator.New<NodeFAdd>(extr); break;
case spv::Core::OpISub:
   node = m_allocator.New<NodeISub>(extr); break;
case spv::Core::OpFSub:
   node = m_allocator.New<NodeFSub>(extr); break;
case spv::Core::OpIMul:
   node = m_allocator.New<NodeIMul>(extr); break;
case spv::Core::OpFMul:
   node = m_allocator.New<NodeFMul>(extr); break;
case spv::Core::OpUDiv:
   node = m_allocator.New<NodeUDiv>(extr); break;
case spv::Core::OpSDiv:
   node = m_allocator.New<NodeSDiv>(extr); break;
case spv::Core::OpFDiv:
   node = m_allocator.New<NodeFDiv>(extr); break;
case spv::Core::OpUMod:
   node = m_allocator.New<NodeUMod>(extr); break;
case spv::Core::OpSRem:
   node = m_allocator.New<NodeSRem>(extr); break;
case spv::Core::OpSMod:
   node = m_allocator.New<NodeSMod>(extr); break;
case spv::Core::OpFRem:
   node = m_allocator.New<NodeFRem>(extr); break;
case spv::Core::OpFMod:
   node = m_allocator.New<NodeFMod>(extr); break;
case spv::Core::OpVectorTimesScalar:
   node = m_allocator.New<NodeVectorTimesScalar>(extr); break;
case spv::Core::OpMatrixTimesScalar:
   node = m_allocator.New<NodeMatrixTimesScalar>(extr); break;
case spv::Core::OpVectorTimesMatrix:
   node = m_allocator.New<NodeVectorTimesMatrix>(extr); break;
case spv::Core::OpMatrixTimesVector:
   node = m_allocator.New<NodeMatrixTimesVector>(extr); break;
case spv::Core::OpMatrixTimesMatrix:
   node = m_allocator.New<NodeMatrixTimesMatrix>(extr); break;
case spv::Core::OpOuterProduct:
   node = m_allocator.New<NodeOuterProduct>(extr); break;
case spv::Core::OpDot:
   node = m_allocator.New<NodeDot>(extr); break;
case spv::Core::OpIAddCarry:
   node = m_allocator.New<NodeIAddCarry>(extr); break;
case spv::Core::OpISubBorrow:
   node = m_allocator.New<NodeISubBorrow>(extr); break;
case spv::Core::OpUMulExtended:
   node = m_allocator.New<NodeUMulExtended>(extr); break;
case spv::Core::OpSMulExtended:
   node = m_allocator.New<NodeSMulExtended>(extr); break;
case spv::Core::OpAny:
   node = m_allocator.New<NodeAny>(extr); break;
case spv::Core::OpAll:
   node = m_allocator.New<NodeAll>(extr); break;
case spv::Core::OpIsNan:
   node = m_allocator.New<NodeIsNan>(extr); break;
case spv::Core::OpIsInf:
   node = m_allocator.New<NodeIsInf>(extr); break;
case spv::Core::OpLogicalEqual:
   node = m_allocator.New<NodeLogicalEqual>(extr); break;
case spv::Core::OpLogicalNotEqual:
   node = m_allocator.New<NodeLogicalNotEqual>(extr); break;
case spv::Core::OpLogicalOr:
   node = m_allocator.New<NodeLogicalOr>(extr); break;
case spv::Core::OpLogicalAnd:
   node = m_allocator.New<NodeLogicalAnd>(extr); break;
case spv::Core::OpLogicalNot:
   node = m_allocator.New<NodeLogicalNot>(extr); break;
case spv::Core::OpSelect:
   node = m_allocator.New<NodeSelect>(extr); break;
case spv::Core::OpIEqual:
   node = m_allocator.New<NodeIEqual>(extr); break;
case spv::Core::OpINotEqual:
   node = m_allocator.New<NodeINotEqual>(extr); break;
case spv::Core::OpUGreaterThan:
   node = m_allocator.New<NodeUGreaterThan>(extr); break;
case spv::Core::OpSGreaterThan:
   node = m_allocator.New<NodeSGreaterThan>(extr); break;
case spv::Core::OpUGreaterThanEqual:
   node = m_allocator.New<NodeUGreaterThanEqual>(extr); break;
case spv::Core::OpSGreaterThanEqual:
   node = m_allocator.New<NodeSGreaterThanEqual>(extr); break;
case spv::Core::OpULessThan:
   node = m_allocator.New<NodeULessThan>(extr); break;
case spv::Core::OpSLessThan:
   node = m_allocator.New<NodeSLessThan>(extr); break;
case spv::Core::OpULessThanEqual:
   node = m_allocator.New<NodeULessThanEqual>(extr); break;
case spv::Core::OpSLessThanEqual:
   node = m_allocator.New<NodeSLessThanEqual>(extr); break;
case spv::Core::OpFOrdEqual:
   node = m_allocator.New<NodeFOrdEqual>(extr); break;
case spv::Core::OpFUnordEqual:
   node = m_allocator.New<NodeFUnordEqual>(extr); break;
case spv::Core::OpFOrdNotEqual:
   node = m_allocator.New<NodeFOrdNotEqual>(extr); break;
case spv::Core::OpFUnordNotEqual:
   node = m_allocator.New<NodeFUnordNotEqual>(extr); break;
case spv::Core::OpFOrdLessThan:
   node = m_allocator.New<NodeFOrdLessThan>(extr); break;
case spv::Core::OpFUnordLessThan:
   node = m_allocator.New<NodeFUnordLessThan>(extr); break;
case spv::Core::OpFOrdGreaterThan:
   node = m_allocator.New<NodeFOrdGreaterThan>(extr); break;
case spv::Core::OpFUnordGreaterThan:
   node = m_allocator.New<NodeFUnordGreaterThan>(extr); break;
case spv::Core::OpFOrdLessThanEqual:
   node = m_allocator.New<NodeFOrdLessThanEqual>(extr); break;
case spv::Core::OpFUnordLessThanEqual:
   node = m_allocator.New<NodeFUnordLessThanEqual>(extr); break;
case spv::Core::OpFOrdGreaterThanEqual:
   node = m_allocator.New<NodeFOrdGreaterThanEqual>(extr); break;
case spv::Core::OpFUnordGreaterThanEqual:
   node = m_allocator.New<NodeFUnordGreaterThanEqual>(extr); break;
case spv::Core::OpShiftRightLogical:
   node = m_allocator.New<NodeShiftRightLogical>(extr); break;
case spv::Core::OpShiftRightArithmetic:
   node = m_allocator.New<NodeShiftRightArithmetic>(extr); break;
case spv::Core::OpShiftLeftLogical:
   node = m_allocator.New<NodeShiftLeftLogical>(extr); break;
case spv::Core::OpBitwiseOr:
   node = m_allocator.New<NodeBitwiseOr>(extr); break;
case spv::Core::OpBitwiseXor:
   node = m_allocator.New<NodeBitwiseXor>(extr); break;
case spv::Core::OpBitwiseAnd:
   node = m_allocator.New<NodeBitwiseAnd>(extr); break;
case spv::Core::OpNot:
   node = m_allocator.New<NodeNot>(extr); break;
case spv::Core::OpBitFieldInsert:
   node = m_allocator.New<NodeBitFieldInsert>(extr); break;
case spv::Core::OpBitFieldSExtract:
   node = m_allocator.New<NodeBitFieldSExtract>(extr); break;
case spv::Core::OpBitFieldUExtract:
   node = m_allocator.New<NodeBitFieldUExtract>(extr); break;
case spv::Core::OpBitReverse:
   node = m_allocator.New<NodeBitReverse>(extr); break;
case spv::Core::OpBitCount:
   node = m_allocator.New<NodeBitCount>(extr); break;
case spv::Core::OpDPdx:
   node = m_allocator.New<NodeDPdx>(extr); break;
case spv::Core::OpDPdy:
   node = m_allocator.New<NodeDPdy>(extr); break;
case spv::Core::OpFwidth:
   node = m_allocator.New<NodeFwidth>(extr); break;
case spv::Core::OpDPdxFine:
   node = m_allocator.New<NodeDPdxFine>(extr); break;
case spv::Core::OpDPdyFine:
   node = m_allocator.New<NodeDPdyFine>(extr); break;
case spv::Core::OpFwidthFine:
   node = m_allocator.New<NodeFwidthFine>(extr); break;
case spv::Core::OpDPdxCoarse:
   node = m_allocator.New<NodeDPdxCoarse>(extr); break;
case spv::Core::OpDPdyCoarse:
   node = m_allocator.New<NodeDPdyCoarse>(extr); break;
case spv::Core::OpFwidthCoarse:
   node = m_allocator.New<NodeFwidthCoarse>(extr); break;
case spv::Core::OpControlBarrier:
   node = m_allocator.New<NodeControlBarrier>(extr); break;
case spv::Core::OpMemoryBarrier:
   node = m_allocator.New<NodeMemoryBarrier>(extr); break;
case spv::Core::OpAtomicLoad:
   node = m_allocator.New<NodeAtomicLoad>(extr); break;
case spv::Core::OpAtomicStore:
   node = m_allocator.New<NodeAtomicStore>(extr); break;
case spv::Core::OpAtomicExchange:
   node = m_allocator.New<NodeAtomicExchange>(extr); break;
case spv::Core::OpAtomicCompareExchange:
   node = m_allocator.New<NodeAtomicCompareExchange>(extr); break;
case spv::Core::OpAtomicIIncrement:
   node = m_allocator.New<NodeAtomicIIncrement>(extr); break;
case spv::Core::OpAtomicIDecrement:
   node = m_allocator.New<NodeAtomicIDecrement>(extr); break;
case spv::Core::OpAtomicIAdd:
   node = m_allocator.New<NodeAtomicIAdd>(extr); break;
case spv::Core::OpAtomicISub:
   node = m_allocator.New<NodeAtomicISub>(extr); break;
case spv::Core::OpAtomicSMin:
   node = m_allocator.New<NodeAtomicSMin>(extr); break;
case spv::Core::OpAtomicUMin:
   node = m_allocator.New<NodeAtomicUMin>(extr); break;
case spv::Core::OpAtomicSMax:
   node = m_allocator.New<NodeAtomicSMax>(extr); break;
case spv::Core::OpAtomicUMax:
   node = m_allocator.New<NodeAtomicUMax>(extr); break;
case spv::Core::OpAtomicAnd:
   node = m_allocator.New<NodeAtomicAnd>(extr); break;
case spv::Core::OpAtomicOr:
   node = m_allocator.New<NodeAtomicOr>(extr); break;
case spv::Core::OpAtomicXor:
   node = m_allocator.New<NodeAtomicXor>(extr); break;
case spv::Core::OpPhi:
   node = m_allocator.New<NodePhi>(extr); break;
case spv::Core::OpLoopMerge:
   node = m_allocator.New<NodeLoopMerge>(extr); break;
case spv::Core::OpSelectionMerge:
   node = m_allocator.New<NodeSelectionMerge>(extr); break;
case spv::Core::OpLabel:
   node = m_allocator.New<NodeLabel>(extr); break;
case spv::Core::OpBranch:
   node = m_allocator.New<NodeBranch>(extr); break;
case spv::Core::OpBranchConditional:
   node = m_allocator.New<NodeBranchConditional>(extr); break;
case spv::Core::OpSwitch:
   node = m_allocator.New<NodeSwitch>(extr); break;
case spv::Core::OpKill:
   node = m_allocator.New<NodeKill>(extr); break;
case spv::Core::OpReturn:
   node = m_allocator.New<NodeReturn>(extr); break;
case spv::Core::OpReturnValue:
   node = m_allocator.New<NodeReturnValue>(extr); break;
case spv::Core::OpUnreachable:
   node = m_allocator.New<NodeUnreachable>(extr); break;
case spv::Core::OpNoLine:
   node = m_allocator.New<NodeNoLine>(extr); break;
case spv::Core::OpModuleProcessed:
   node = m_allocator.New<NodeModuleProcessed>(extr); break;
case spv::Core::OpExecutionModeId:
   node = m_allocator.New<NodeExecutionModeId>(extr); break;
case spv::Core::OpDecorateId:
   node = m_allocator.New<NodeDecorateId>(extr); break;
case spv::Core::OpGroupNonUniformElect:
   node = m_allocator.New<NodeGroupNonUniformElect>(extr); break;
default:
   log_warn("Unhandled SPIRV instruction (%u)", static_cast<uint32_t>(extr.GetOpCode())); break;
}
