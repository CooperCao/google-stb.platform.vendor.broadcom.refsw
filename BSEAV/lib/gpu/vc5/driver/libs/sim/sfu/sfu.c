/*=============================================================================
Broadcom Proprietary and Confidential. (c)2014 Broadcom.
All rights reserved.

Project  :  sfu
=============================================================================*/

/*=============================================================================
NOTE: The tables and parameters in this function are auto generated from a
separate program. Please do not edit in this file!
=============================================================================*/

#include "sfu.h"

#include "libs/core/v3d/v3d_common.h"
#include <assert.h>

#define PROPAGATED_NAN 0x7fc00000 /* If input is NaN */
#define GENERATED_NAN  0xffc00000 /* If operation is invalid, eg rsqrt(-1) */

typedef struct {
   int m0,md,sq,c1,c2,r0,rd;
} lslutab_t;

typedef struct {
   int offs, nsub;
} lsixtab_t;

#define MAX_FUNCS 6
#define MAX_LTAB  64
#define MAX_CTAB  32
#define MAX_LOGIM 16
#define MAX_LOGTB 34
#define MAX_LOGEX 19
#define MAX_LOGXP 16
#define MAX_SINTB 100
#define MAX_SINEX 15
#define MAX_SINXP 15

static const int use_log_extrap  = 1;
static const int use_sine        = 1;
static const int lu_log_numimm   = MAX_LOGIM;
static const int lu_log_tabsiz   = MAX_LOGTB;
static const int lu_log_minexp   = 4;
static const int lu_log_maxexp   = 20;
static const int lu_log_sqexthr  = 15;
static const int lu_sin_tabsiz   = MAX_SINTB;
static const int lu_sin_minexp   = 8;
static const int lu_sin_maxexp   = 23;
static const int lu_sin_sqexthr  = 17;
static const int lu_mfr_frmsbit  = 0x10000;
static const int lu_mfr_ixshift  = 17;
static const int lu_mfr_frmask   = 0x1ffff;
static const int lu_mfr_dropb    = 17;
static const int lu_sqf_dropbin  = 0;
static const int lu_sqf_dropbmid = 19;
static const int lu_sqf_dropbout = 13;
static const int lu_sqf_mask     = 0xffff;
static const int lu_sqf_extrab   = 1;
static const int lu_ccf_ixshift  = 12;
static const int lu_ccf_frshift  = 7;
static const int lu_ccf_frmask   = 0x1f;
static const int lu_ccf_dropbtab = 5;
static const int lu_ccf_dropbout = 7;
static const int lu_ccf_extrab   = 1;
static const int lu_out_dropb    = 3;
static const int lu_out_extrab   = 6;
static const int lu_mfr_biasb    = 4;
static const int lu_mfr_biasb2   = 5;

static int lus_lm0[MAX_FUNCS][MAX_LTAB] = { {
   0xfffffbf8, 0x00080bff, 0x00103cc9, 0x00188f20, 0x002103d2, 0x00299bb7, 0x003257ab, 0x003b3894,
   0x00443f5e, 0x004d6cfe, 0x0056c271, 0x006040bb, 0x0069e8eb, 0x0073bc1a, 0x007dbb67, 0x0087e801,
   0x0092431d, 0x009ccdfb, 0x00a789ec, 0x00b27847, 0x00bd9a74, 0x00c8f1e6, 0x00d48020, 0x00e046b1,
   0x00ec473a, 0x00f8836b, 0x0104fd05, 0x0111b5dc, 0x011eafd4, 0x012bece7, 0x01396f23, 0x014738ac,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {
   0x015552f5, 0x015c78e5, 0x0163b219, 0x016afedd, 0x01725f83, 0x0179d45c, 0x01815dbb, 0x0188fbf6,
   0x0190af63, 0x0198785b, 0x01a0573b, 0x01a84c5d, 0x01b05823, 0x01b87aec, 0x01c0b51b, 0x01c90717,
   0x01d17147, 0x01d9f414, 0x01e28fee, 0x01eb4542, 0x01f41481, 0x01fcfe21, 0x02060299, 0x020f2261,
   0x02185df9, 0x0221b5de, 0x022b2a95, 0x0234bca3, 0x023e6c92, 0x02483aee, 0x02522848, 0x025c3534,
   0x02666249, 0x0270b022, 0x027b1f5f, 0x0285b0a3, 0x02906496, 0x029b3be2, 0x02a6373a, 0x02b15751,
   0x02bc9ce1, 0x02c808aa, 0x02d39b6e, 0x02df55f5, 0x02eb3911, 0x02f74592, 0x03037c54, 0x030fde37,
   0x031c6c1f, 0x032926fb, 0x03360fbd, 0x0343275d, 0x03506ee0, 0x035de74b, 0x036b91b0, 0x03796f27,
   0x038780d0, 0x0395c7d4, 0x03a44565, 0x03b2fabd, 0x03c1e923, 0x03d111e2, 0x03e07656, 0x03f017e0}, {
   0x01a82577, 0x01add61f, 0x01b39815, 0x01b96bb1, 0x01bf514f, 0x01c5494d, 0x01cb5409, 0x01d171e8,
   0x01d7a350, 0x01dde8a8, 0x01e4425d, 0x01eab0de, 0x01f1349e, 0x01f7ce13, 0x01fe7db5, 0x02054404,
   0x020c217e, 0x021316aa, 0x021a2413, 0x02214a45, 0x022889d2, 0x022fe354, 0x02375764, 0x023ee6a6,
   0x024691c0, 0x024e595f, 0x02563e35, 0x025e40fb, 0x0266626f, 0x026ea358, 0x02770483, 0x027f86c4,
   0x02882af7, 0x0290f1ff, 0x0299dccb, 0x02a2ec4e, 0x02ac2187, 0x02b57d80, 0x02bf014a, 0x02c8ae04,
   0x02d284d6, 0x02dc86f5, 0x02e6b5a2, 0x02f1122c, 0x02fb9def, 0x03065a55, 0x031148db, 0x031c6b09,
   0x0327c27d, 0x033350e3, 0x033f17ff, 0x034b19a4, 0x035757bf, 0x0363d453, 0x03709178, 0x037d9164,
   0x038ad665, 0x039862e8, 0x03a63979, 0x03b45cc4, 0x03c2cf99, 0x03d194e9, 0x03e0afd6, 0x03f023a5}, {
   0xfffffe7e, 0x00040480, 0x000816bf, 0x000c357a, 0x001060f0, 0x00149963, 0x0018df19, 0x001d3256,
   0x00219363, 0x00260289, 0x002a8016, 0x002f0c57, 0x0033a79e, 0x0038523e, 0x003d0c8d, 0x0041d6e3,
   0x0046b19e, 0x004b9d18, 0x005099b6, 0x0055a7da, 0x005ac7ed, 0x005ffa5a, 0x00653f8f, 0x006a97fe,
   0x0070041d, 0x00758468, 0x007b1959, 0x0080c377, 0x00868346, 0x008c5954, 0x00924631, 0x00984a73,
   0x009e66b6, 0x00a49b9a, 0x00aae9c8, 0x00b151ec, 0x00b7d4bc, 0x00be72f1, 0x00c52d4e, 0x00cc049d,
   0x00d2f9b1, 0x00da0d62, 0x00e14095, 0x00e89435, 0x00f0093a, 0x00f7a0a4, 0x00ff5b7f, 0x01073ae0,
   0x010f3fed, 0x01176bd5, 0x011fbfd6, 0x01283d3b, 0x0130e562, 0x0139b9b3, 0x0142bbae, 0x014becdf,
   0x01554eeb, 0x015ee387, 0x0168ac80, 0x0172abba, 0x017ce331, 0x018754fd, 0x01920351, 0x019cf07f}, {
   0xfffffc22, 0x000b22a7, 0x00166842, 0x0021cd48, 0x002d5212, 0x0038f6f8, 0x0044bc54, 0x0050a280,
   0x005ca9d8, 0x0068d2b8, 0x00751d7d, 0x00818a87, 0x008e1a35, 0x009acce6, 0x00a7a2fd, 0x00b49cde,
   0x00c1baea, 0x00cefd87, 0x00dc651c, 0x00e9f20e, 0x00f7a4c6, 0x01057dae, 0x01137d31, 0x0121a3b8,
   0x012ff1b2, 0x013e678c, 0x014d05b6, 0x015bcca0, 0x016abcbb, 0x0179d67b, 0x01891a52, 0x019888b8,
   0x01a82223, 0x01b7e709, 0x01c7d7e4, 0x01d7f530, 0x01e83f68, 0x01f8b709, 0x02095c91, 0x021a3081,
   0x022b335b, 0x023c65a0, 0x024dc7d5, 0x025f5a7f, 0x02711e27, 0x02831354, 0x02953a91, 0x02a79467,
   0x02ba2166, 0x02cce21c, 0x02dfd718, 0x02f300ed, 0x0306602d, 0x0319f56f, 0x032dc147, 0x0341c450,
   0x0355ff20, 0x036a7257, 0x037f1e8e, 0x03940467, 0x03a92482, 0x03be7f80, 0x03d41607, 0x03e9e8bb}, {
   0x00000b5d, 0x0016f29b, 0x002d8058, 0x0043b742, 0x005999ef, 0x006f2ad3, 0x00846c47, 0x0099608e,
   0x00ae09d0, 0x00c26a1f, 0x00d68376, 0x00ea57bd, 0x00fde8c9, 0x0111385c, 0x01244827, 0x013719c7,
   0x0149aed0, 0x015c08c2, 0x016e290f, 0x0180111d, 0x0191c247, 0x01a33dd8, 0x01b48510, 0x01c59927,
   0x01d67b47, 0x01e72c90, 0x01f7ae1c, 0x020800f7, 0x02182626, 0x02281ea7, 0x0237eb6f, 0x02478d69,
   0x0257057c, 0x02665486, 0x02757b5e, 0x02847ad6, 0x029353b7, 0x02a206c7, 0x02b094c4, 0x02befe68,
   0x02cd4466, 0x02db676c, 0x02e96826, 0x02f74736, 0x0305053f, 0x0312a2da, 0x032020a2, 0x032d7f27,
   0x033abefc, 0x0347e0a9, 0x0354e4ba, 0x0361cbb0, 0x036e960d, 0x037b4450, 0x0387d6f2, 0x03944e6b,
   0x03a0ab2f, 0x03acedb0, 0x03b9165b, 0x03c5259f, 0x03d11be3, 0x03dcf98e, 0x03e8bf05, 0x03f46caa} };

static int lus_lmd[MAX_FUNCS][MAX_LTAB] = { {
   0x00081020, 0x000830e4, 0x00085271, 0x000874cd, 0x00089801, 0x0008bc11, 0x0008e107, 0x000906ea,
   0x00092dc0, 0x00095594, 0x00097e6c, 0x0009a854, 0x0009d353, 0x0009ff74, 0x000a2cc1, 0x000a5b45,
   0x000a8b09, 0x000abc1d, 0x000aee89, 0x000b225c, 0x000b57a3, 0x000b8e6d, 0x000bc6c6, 0x000c00c0,
   0x000c3c6a, 0x000c79d6, 0x000cb915, 0x000cfa38, 0x000d3d57, 0x000d8282, 0x000dc9d1, 0x000e135a,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {
   0x000725fa, 0x0007393d, 0x00074cce, 0x000760b1, 0x000774e3, 0x0007896a, 0x00079e46, 0x0007b378,
   0x0007c904, 0x0007deec, 0x0007f52e, 0x00080bd2, 0x000822d5, 0x00083a3c, 0x00085209, 0x00086a3d,
   0x000882dc, 0x00089be8, 0x0008b562, 0x0008cf4e, 0x0008e9af, 0x00090487, 0x00091fd8, 0x00093ba8,
   0x000957f6, 0x000974c8, 0x0009921f, 0x0009b001, 0x0009ce6e, 0x0009ed6d, 0x000a0cff, 0x000a2d29,
   0x000a4ded, 0x000a6f52, 0x000a9159, 0x000ab408, 0x000ad763, 0x000afb6f, 0x000b202e, 0x000b45a9,
   0x000b6be1, 0x000b92dd, 0x000bbaa2, 0x000be336, 0x000c0c9d, 0x000c36df, 0x000c6200, 0x000c8e06,
   0x000cbafb, 0x000ce8e1, 0x000d17c1, 0x000d47a4, 0x000d788e, 0x000daa89, 0x000ddd9b, 0x000e11cf,
   0x000e472a, 0x000e7db9, 0x000eb582, 0x000eee90, 0x000f28eb, 0x000f64a1, 0x000fa1b8, 0x000fe040}, {
   0x0005b0b3, 0x0005c200, 0x0005d3a8, 0x0005e5aa, 0x0005f80a, 0x00060ac9, 0x00061dec, 0x00063175,
   0x00064566, 0x000659c3, 0x00066e90, 0x000683cf, 0x00069984, 0x0006afb2, 0x0006c65f, 0x0006dd8b,
   0x0006f53e, 0x00070d7b, 0x00072644, 0x00073fa1, 0x00075995, 0x00077425, 0x00078f57, 0x0007ab30,
   0x0007c7b6, 0x0007e4ed, 0x000802de, 0x0008218d, 0x00084104, 0x00086146, 0x0008825d, 0x0008a44f,
   0x0008c727, 0x0008eaeb, 0x00090fa3, 0x0009355b, 0x00095c1c, 0x000983ef, 0x0009ace0, 0x0009d6f9,
   0x000a0248, 0x000a2ed8, 0x000a5cb6, 0x000a8bf1, 0x000abc97, 0x000aeeb8, 0x000b2263, 0x000b57aa,
   0x000b8ea0, 0x000bc758, 0x000c01e4, 0x000c3e5d, 0x000c7cd9, 0x000cbd6d, 0x000d0037, 0x000d4551,
   0x000d8cd7, 0x000dd6e9, 0x000e23a7, 0x000e7335, 0x000ec5b7, 0x000f1b59, 0x000f7440, 0x000fd09e}, {
   0x0004060a, 0x00041247, 0x00041ec3, 0x00042b7e, 0x0004387c, 0x000445bf, 0x00045346, 0x00046116,
   0x00046f30, 0x00047d97, 0x00048c4b, 0x00049b52, 0x0004aaab, 0x0004ba5a, 0x0004ca62, 0x0004dac6,
   0x0004eb87, 0x0004fcab, 0x00050e31, 0x00052021, 0x0005327b, 0x00054543, 0x0005587e, 0x00056c2f,
   0x0005805a, 0x00059502, 0x0005aa2f, 0x0005bfe1, 0x0005d621, 0x0005ecf0, 0x00060455, 0x00061c57,
   0x000634fa, 0x00064e44, 0x0006683c, 0x000682e7, 0x00069e4e, 0x0006ba77, 0x0006d76a, 0x0006f52f,
   0x000713ce, 0x00073351, 0x000753c0, 0x00077526, 0x0007978c, 0x0007bafe, 0x0007df87, 0x00080534,
   0x00082c10, 0x0008542b, 0x00087d92, 0x0008a855, 0x0008d482, 0x0009022e, 0x00093167, 0x00096244,
   0x000994d7, 0x0009c937, 0x0009ff7b, 0x000a37bc, 0x000a7214, 0x000aaea0, 0x000aed7e, 0x000b2ece}, {
   0x000b2690, 0x000b45a5, 0x000b6511, 0x000b84d5, 0x000ba4f2, 0x000bc567, 0x000be638, 0x000c0763,
   0x000c28ec, 0x000c4ad1, 0x000c6d16, 0x000c8fba, 0x000cb2bd, 0x000cd624, 0x000cf9ed, 0x000d1e19,
   0x000d42aa, 0x000d67a1, 0x000d8cff, 0x000db2c6, 0x000dd8f5, 0x000dff90, 0x000e2695, 0x000e4e08,
   0x000e75e9, 0x000e9e38, 0x000ec6f8, 0x000ef029, 0x000f19ce, 0x000f43e7, 0x000f6e75, 0x000f9979,
   0x000fc4f5, 0x000ff0eb, 0x00101d5c, 0x00104a47, 0x001077b1, 0x0010a598, 0x0010d401, 0x001102ea,
   0x00113255, 0x00116246, 0x001192bc, 0x0011c3b9, 0x0011f53e, 0x0012274e, 0x001259e8, 0x00128d11,
   0x0012c0c8, 0x0012f50f, 0x001329e7, 0x00135f53, 0x00139555, 0x0013cbeb, 0x0014031c, 0x00143ae4,
   0x0014734a, 0x0014ac4c, 0x0014e5ed, 0x0015202f, 0x00155b13, 0x0015969b, 0x0015d2c9, 0x00160fa0}, {
   0x0016e797, 0x00168e10, 0x0016373b, 0x0015e2fa, 0x0015912d, 0x001541bb, 0x0014f48b, 0x0014a983,
   0x0014608d, 0x00141992, 0x0013d481, 0x00139144, 0x00134fc8, 0x00130ffd, 0x0012d1d2, 0x00129538,
   0x00125a1f, 0x00122079, 0x0011e839, 0x0011b153, 0x00117bb8, 0x0011475e, 0x0011143c, 0x0010e243,
   0x0010b16c, 0x001081ad, 0x001052fa, 0x0010254f, 0x000ff89f, 0x000fcce5, 0x000fa217, 0x000f782e,
   0x000f4f24, 0x000f26f2, 0x000eff91, 0x000ed8f9, 0x000eb328, 0x000e8e14, 0x000e69ba, 0x000e4613,
   0x000e231b, 0x000e00ce, 0x000ddf24, 0x000dbe1c, 0x000d9dae, 0x000d7dda, 0x000d5e97, 0x000d3fe6,
   0x000d21be, 0x000d0421, 0x000ce706, 0x000cca6d, 0x000cae52, 0x000c92b0, 0x000c7788, 0x000c5cd2,
   0x000c428e, 0x000c28b9, 0x000c0f51, 0x000bf650, 0x000bddb8, 0x000bc583, 0x000badb1, 0x000b963e} };

static int lus_lsq[MAX_FUNCS][MAX_LTAB] = { {
   0x00000818, 0x00000849, 0x0000087d, 0x000008b1, 0x000008e8, 0x00000920, 0x0000095a, 0x00000996,
   0x000009d5, 0x00000a16, 0x00000a58, 0x00000a9c, 0x00000ae3, 0x00000b2c, 0x00000b79, 0x00000bc8,
   0x00000c1a, 0x00000c6f, 0x00000cc8, 0x00000d23, 0x00000d81, 0x00000de4, 0x00000e4a, 0x00000eb4,
   0x00000f22, 0x00000f94, 0x0000100b, 0x00001087, 0x00001108, 0x0000118f, 0x0000121b, 0x000012ab,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {
   0x000004c8, 0x000004db, 0x000004ee, 0x00000502, 0x00000518, 0x0000052c, 0x00000542, 0x00000558,
   0x0000056e, 0x00000585, 0x0000059d, 0x000005b5, 0x000005ce, 0x000005e6, 0x00000600, 0x0000061a,
   0x00000634, 0x00000651, 0x0000066d, 0x0000068a, 0x000006a7, 0x000006c6, 0x000006e4, 0x00000704,
   0x00000724, 0x00000746, 0x00000767, 0x0000078a, 0x000007ad, 0x000007d1, 0x000007f7, 0x0000081e,
   0x00000846, 0x0000086e, 0x00000897, 0x000008c1, 0x000008ec, 0x00000919, 0x00000947, 0x00000976,
   0x000009a7, 0x000009d8, 0x00000a0a, 0x00000a3f, 0x00000a74, 0x00000aac, 0x00000ae5, 0x00000b1f,
   0x00000b5b, 0x00000b99, 0x00000bd8, 0x00000c19, 0x00000c5c, 0x00000ca2, 0x00000ce9, 0x00000d32,
   0x00000d7d, 0x00000dca, 0x00000e1a, 0x00000e6d, 0x00000ec2, 0x00000f19, 0x00000f73, 0x00000fd0}, {
   0x00000449, 0x0000045f, 0x00000474, 0x0000048c, 0x000004a4, 0x000004bc, 0x000004d5, 0x000004ef,
   0x0000050a, 0x00000525, 0x00000541, 0x0000055f, 0x0000057d, 0x0000059b, 0x000005bb, 0x000005dc,
   0x000005fd, 0x00000621, 0x00000645, 0x0000066a, 0x00000691, 0x000006b8, 0x000006e1, 0x0000070b,
   0x00000738, 0x00000765, 0x00000794, 0x000007c4, 0x000007f6, 0x0000082b, 0x00000861, 0x00000899,
   0x000008d2, 0x0000090f, 0x0000094e, 0x0000098e, 0x000009d2, 0x00000a18, 0x00000a61, 0x00000aad,
   0x00000afb, 0x00000b4e, 0x00000ba3, 0x00000bfb, 0x00000c58, 0x00000cb9, 0x00000d1e, 0x00000d87,
   0x00000df4, 0x00000e68, 0x00000ee0, 0x00000f5d, 0x00000fe1, 0x0000106b, 0x000010fb, 0x00001192,
   0x00001231, 0x000012d9, 0x00001389, 0x00001441, 0x00001502, 0x000015cf, 0x000016a7, 0x0000178a}, {
   0x00000307, 0x00000317, 0x00000327, 0x00000337, 0x00000347, 0x00000359, 0x0000036b, 0x0000037d,
   0x00000390, 0x000003a4, 0x000003b7, 0x000003cc, 0x000003e2, 0x000003f7, 0x0000040d, 0x00000425,
   0x0000043c, 0x00000455, 0x0000046f, 0x00000489, 0x000004a5, 0x000004c1, 0x000004dd, 0x000004fc,
   0x0000051b, 0x0000053a, 0x0000055b, 0x0000057e, 0x000005a2, 0x000005c7, 0x000005ed, 0x00000613,
   0x0000063c, 0x00000667, 0x00000694, 0x000006c3, 0x000006f2, 0x00000724, 0x00000757, 0x0000078d,
   0x000007c4, 0x000007fd, 0x0000083a, 0x00000879, 0x000008bb, 0x000008ff, 0x00000946, 0x00000991,
   0x000009df, 0x00000a2f, 0x00000a84, 0x00000add, 0x00000b3a, 0x00000b9c, 0x00000c02, 0x00000c6d,
   0x00000cdd, 0x00000d53, 0x00000dcf, 0x00000e52, 0x00000edb, 0x00000f6b, 0x00001004, 0x000010a4}, {
   0x000007bb, 0x000007d1, 0x000007e6, 0x000007fc, 0x00000812, 0x00000829, 0x00000840, 0x00000857,
   0x0000086e, 0x00000885, 0x0000089d, 0x000008b5, 0x000008cd, 0x000008e5, 0x000008ff, 0x00000918,
   0x00000932, 0x0000094b, 0x00000964, 0x0000097e, 0x00000999, 0x000009b3, 0x000009ce, 0x000009ea,
   0x00000a06, 0x00000a23, 0x00000a3f, 0x00000a5b, 0x00000a77, 0x00000a94, 0x00000ab3, 0x00000ad1,
   0x00000aee, 0x00000b0c, 0x00000b2c, 0x00000b4b, 0x00000b6a, 0x00000b8a, 0x00000baa, 0x00000bcb,
   0x00000bec, 0x00000c0c, 0x00000c2e, 0x00000c51, 0x00000c73, 0x00000c96, 0x00000cb8, 0x00000cdb,
   0x00000cff, 0x00000d24, 0x00000d49, 0x00000d6d, 0x00000d93, 0x00000db9, 0x00000ddf, 0x00000e06,
   0x00000e2d, 0x00000e54, 0x00000e7d, 0x00000ea5, 0x00000ece, 0x00000ef7, 0x00000f20, 0x00000f4a}, {
   0xffffe946, 0xffffe9f7, 0xffffea9e, 0xffffeb3f, 0xffffebda, 0xffffec6c, 0xffffecfa, 0xffffed81,
   0xffffee04, 0xffffee80, 0xffffeef6, 0xffffef6a, 0xffffefd9, 0xfffff043, 0xfffff0a8, 0xfffff10b,
   0xfffff169, 0xfffff1c4, 0xfffff21c, 0xfffff271, 0xfffff2c3, 0xfffff311, 0xfffff35d, 0xfffff3a7,
   0xfffff3ed, 0xfffff433, 0xfffff475, 0xfffff4b4, 0xfffff4f3, 0xfffff52f, 0xfffff56a, 0xfffff5a3,
   0xfffff5d9, 0xfffff60d, 0xfffff641, 0xfffff673, 0xfffff6a3, 0xfffff6d3, 0xfffff701, 0xfffff72d,
   0xfffff757, 0xfffff781, 0xfffff7aa, 0xfffff7d2, 0xfffff7f8, 0xfffff81d, 0xfffff842, 0xfffff865,
   0xfffff887, 0xfffff8a9, 0xfffff8ca, 0xfffff8ea, 0xfffff909, 0xfffff927, 0xfffff944, 0xfffff962,
   0xfffff97d, 0xfffff998, 0xfffff9b3, 0xfffff9cd, 0xfffff9e6, 0xfffff9ff, 0xfffffa17, 0xfffffa2f} };

static int lus_lc1[MAX_FUNCS][MAX_LTAB] = { {
   0x00000006, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000008, 0x00000008,
   0x00000008, 0x00000008, 0x00000009, 0x00000009, 0x00000009, 0x0000000a, 0x0000000a, 0x0000000a,
   0x0000000b, 0x0000000b, 0x0000000c, 0x0000000c, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000e,
   0x0000000f, 0x0000000f, 0x00000010, 0x00000010, 0x00000011, 0x00000012, 0x00000012, 0x00000013,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {
   0x00000002, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005,
   0x00000005, 0x00000005, 0x00000005, 0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000006,
   0x00000006, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000007, 0x00000008,
   0x00000008, 0x00000008, 0x00000008, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x0000000a,
   0x0000000a, 0x0000000a, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000c, 0x0000000c, 0x0000000c}, {
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000006,
   0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000007, 0x00000007, 0x00000007, 0x00000007,
   0x00000008, 0x00000008, 0x00000008, 0x00000009, 0x00000009, 0x00000009, 0x0000000a, 0x0000000a,
   0x0000000a, 0x0000000b, 0x0000000b, 0x0000000c, 0x0000000c, 0x0000000d, 0x0000000d, 0x0000000e,
   0x0000000f, 0x0000000f, 0x00000010, 0x00000011, 0x00000011, 0x00000012, 0x00000013, 0x00000014,
   0x00000015, 0x00000016, 0x00000017, 0x00000018, 0x0000001a, 0x0000001b, 0x0000001d, 0x0000001e}, {
   0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002,
   0x00000002, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005,
   0x00000005, 0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000007, 0x00000007, 0x00000007,
   0x00000007, 0x00000008, 0x00000008, 0x00000008, 0x00000009, 0x00000009, 0x00000009, 0x0000000a,
   0x0000000a, 0x0000000b, 0x0000000b, 0x0000000c, 0x0000000c, 0x0000000d, 0x0000000e, 0x0000000e,
   0x0000000f, 0x00000010, 0x00000010, 0x00000011, 0x00000012, 0x00000013, 0x00000014, 0x00000015}, {
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003,
   0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000005, 0x00000005, 0x00000005, 0x00000005,
   0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005,
   0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000006}, {
   0x00000017, 0x00000016, 0x00000015, 0x00000014, 0x00000013, 0x00000013, 0x00000012, 0x00000011,
   0x00000010, 0x00000010, 0x0000000f, 0x0000000f, 0x0000000e, 0x0000000d, 0x0000000d, 0x0000000c,
   0x0000000c, 0x0000000c, 0x0000000b, 0x0000000b, 0x0000000a, 0x0000000a, 0x0000000a, 0x00000009,
   0x00000009, 0x00000009, 0x00000008, 0x00000008, 0x00000008, 0x00000008, 0x00000007, 0x00000007,
   0x00000007, 0x00000007, 0x00000007, 0x00000006, 0x00000006, 0x00000006, 0x00000006, 0x00000006,
   0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000005, 0x00000004,
   0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004,
   0x00000004, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003} };

static int lus_lc2[MAX_FUNCS][MAX_LTAB] = { {
   0xfffffffa, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff8, 0xfffffff8,
   0xfffffff8, 0xfffffff8, 0xfffffff7, 0xfffffff7, 0xfffffff7, 0xfffffff6, 0xfffffff6, 0xfffffff6,
   0xfffffff5, 0xfffffff5, 0xfffffff4, 0xfffffff4, 0xfffffff3, 0xfffffff3, 0xfffffff2, 0xfffffff2,
   0xfffffff1, 0xfffffff1, 0xfffffff0, 0xfffffff0, 0xffffffef, 0xffffffee, 0xffffffed, 0xffffffed,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
   0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, {
   0xfffffffe, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb,
   0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa,
   0xfffffffa, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff8,
   0xfffffff8, 0xfffffff8, 0xfffffff8, 0xfffffff7, 0xfffffff7, 0xfffffff7, 0xfffffff7, 0xfffffff6,
   0xfffffff6, 0xfffffff6, 0xfffffff5, 0xfffffff5, 0xfffffff5, 0xfffffff4, 0xfffffff4, 0xfffffff4}, {
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffd, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffa,
   0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffff9,
   0xfffffff8, 0xfffffff8, 0xfffffff8, 0xfffffff7, 0xfffffff7, 0xfffffff7, 0xfffffff6, 0xfffffff6,
   0xfffffff6, 0xfffffff5, 0xfffffff5, 0xfffffff4, 0xfffffff4, 0xfffffff3, 0xfffffff3, 0xfffffff2,
   0xfffffff1, 0xfffffff1, 0xfffffff0, 0xffffffef, 0xffffffef, 0xffffffee, 0xffffffed, 0xffffffec,
   0xffffffeb, 0xffffffea, 0xffffffe9, 0xffffffe7, 0xffffffe6, 0xffffffe5, 0xffffffe3, 0xffffffe2}, {
   0xfffffffe, 0xfffffffe, 0xfffffffe, 0xfffffffe, 0xfffffffe, 0xfffffffe, 0xfffffffe, 0xfffffffe,
   0xfffffffe, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb,
   0xfffffffb, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffff9, 0xfffffff9, 0xfffffff9,
   0xfffffff9, 0xfffffff8, 0xfffffff8, 0xfffffff8, 0xfffffff7, 0xfffffff7, 0xfffffff7, 0xfffffff6,
   0xfffffff6, 0xfffffff5, 0xfffffff5, 0xfffffff4, 0xfffffff4, 0xfffffff3, 0xfffffff2, 0xfffffff2,
   0xfffffff1, 0xfffffff0, 0xffffffef, 0xffffffef, 0xffffffee, 0xffffffed, 0xffffffec, 0xffffffeb}, {
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd,
   0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffb, 0xfffffffb, 0xfffffffb,
   0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb,
   0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb}, {
   0xffffffe9, 0xffffffea, 0xffffffeb, 0xffffffec, 0xffffffed, 0xffffffed, 0xffffffee, 0xffffffef,
   0xfffffff0, 0xfffffff0, 0xfffffff1, 0xfffffff1, 0xfffffff2, 0xfffffff3, 0xfffffff3, 0xfffffff4,
   0xfffffff4, 0xfffffff4, 0xfffffff5, 0xfffffff5, 0xfffffff6, 0xfffffff6, 0xfffffff6, 0xfffffff7,
   0xfffffff7, 0xfffffff7, 0xfffffff8, 0xfffffff8, 0xfffffff8, 0xfffffff8, 0xfffffff9, 0xfffffff9,
   0xfffffff9, 0xfffffff9, 0xfffffff9, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa, 0xfffffffa,
   0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb, 0xfffffffb,
   0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc, 0xfffffffc,
   0xfffffffc, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd, 0xfffffffd} };

static int lus_cc0[MAX_CTAB] = {
   0x001, 0x013, 0x022, 0x02e, 0x036, 0x03c, 0x03f, 0x03f,
   0x03e, 0x03a, 0x035, 0x02f, 0x027, 0x01e, 0x014, 0x00a,
   0x000, 0x00a, 0x014, 0x01e, 0x027, 0x02e, 0x035, 0x03a,
   0x03e, 0x03f, 0x03f, 0x03c, 0x036, 0x02e, 0x022, 0x013};

static int lus_ccd[MAX_CTAB] = {
   0x00000012, 0x0000000f, 0x0000000c, 0x00000008, 0x00000006, 0x00000003, 0x00000000, 0xffffffff,
   0xfffffffc, 0xfffffffb, 0xfffffffa, 0xfffffff8, 0xfffffff7, 0xfffffff6, 0xfffffff6, 0xfffffff6,
   0x0000000a, 0x0000000a, 0x0000000a, 0x00000009, 0x00000007, 0x00000007, 0x00000005, 0x00000004,
   0x00000001, 0x00000000, 0xfffffffd, 0xfffffffa, 0xfffffff8, 0xfffffff4, 0xfffffff1, 0xffffffed};

// Rounding wrap thresholds for log2 outside [0.5,2]
static unsigned int lus_log_wth[2][7] = { {
   0x7fffff, 0x7ffffe, 0x7ffffd, 0x7ffffa, 0x7ffff4, 0x7fffe9, 0x7fffd3}, {
   0x000001, 0x000001, 0x000002, 0x000003, 0x000006, 0x00000c, 0x000017} };

// Direct log lookups for input extremely close to 1
static int lus_log_imm[2][MAX_LOGIM] = { {
   0x00000000, 0x3438aa3a, 0x34b8aa3a, 0x350a7fab, 0x3538aa38, 0x3566d4c5, 0x358a7fa9, 0x35a194ef,
   0x35b8aa35, 0x35cfbf7b, 0x35e6d4c1, 0x35fdea06, 0x360a7fa6, 0x36160a48, 0x362194eb, 0x362d1f8d}, {
   0x33b8aa3c, 0x3438aa3c, 0x348a7fad, 0x34b8aa3d, 0x34e6d4cc, 0x350a7fae, 0x352194f6, 0x3538aa3e,
   0x354fbf86, 0x3566d4ce, 0x357dea17, 0x358a7fb0, 0x35960a54, 0x35a194f8, 0x35ad1f9d, 0x35b8aa41} };

// Exponent increment thresholds for log in range [0.5,2]
static int lus_log_eex[2][MAX_LOGEX] = { {
   0x000016, 0x00002c, 0x000058, 0x0000b1, 0x000162, 0x0002c5, 0x00058b, 0x000b17,
   0x001630, 0x002c64, 0x0058d7, 0x00b1ed, 0x0164d1, 0x02cd86, 0x05aac3, 0x0b95c1,
   0x1837f0, 0x3504f3, 0x7fffff}, {
   0x000015, 0x00002b, 0x000057, 0x0000b0, 0x000161, 0x0002c4, 0x00058a, 0x000b15,
   0x00162c, 0x002c57, 0x0058a8, 0x00b133, 0x0161ed, 0x02c1f2, 0x057c4c, 0x0ada81,
   0x153f38, 0x28bb02, 0x4afb0b} };

// Main lookup tables for log in range [0.9375,1.125]
static lslutab_t lus_log[2][MAX_LOGTB] = { {
  {0x0171545,0x171543,0xfffffffd,0x00000000,0x00000000,0x08,0x01},
  {0x0171544,0x17153e,0xfffffffa,0x00000000,0x00000000,0x05,0x06},
  {0x0171542,0x171536,0xfffffff4,0x00000000,0x00000000,0x05,0x01},
  {0x017153d,0x171524,0xffffffe9,0x00000000,0x00000000,0x08,0x06},
  {0x0171535,0x171502,0xffffffd2,0x00000000,0x00000000,0x03,0x01},
  {0x0171524,0x1714bc,0xffffffa4,0x00000000,0x00000000,0x03,0x07},
  {0x0171502,0x171432,0xffffff47,0x00000000,0x00000000,0x01,0x04},
  {0x01714bc,0x17131d,0xfffffe8f,0x00000000,0x00000000,0x07,0x05},
  {0x02e27da,0x1711ac,0xfffffe8f,0x00000000,0x00000000,0x04,0x05},
  {0x0453987,0x17103b,0xfffffe8f,0x00000000,0x00000000,0x00,0x07},
  {0x02e2526,0x170e13,0xfffffd1f,0x00000000,0x00000000,0x03,0x00},
  {0x0453339,0x170b32,0xfffffd20,0x00000000,0x00000000,0x04,0x04},
  {0x02e1fbe,0x1706e3,0xfffffa42,0x00000000,0x00000000,0x08,0x02},
  {0x04526a2,0x170126,0xfffffa45,0x00000000,0x00000000,0x02,0x04},
  {0x02e14f5,0x16f891,0xfffffd25,0x00000001,0xffffffff,0x07,0x04},
  {0x0450d86,0x16ed28,0xfffffd27,0x00000001,0xffffffff,0x00,0x07},
  {0x02dff75,0x16dc22,0xfffffa57,0x00000003,0xfffffffd,0x03,0x08},
  {0x044db93,0x16c595,0xfffffa62,0x00000003,0xfffffffd,0x03,0x06},
  {0x05ba123,0x16af34,0xfffffa6d,0x00000003,0xfffffffd,0x01,0x07},
  {0x0725052,0x1698ff,0xfffffa78,0x00000003,0xfffffffd,0x07,0x06},
  {0x088e94c,0x1682f5,0xfffffa83,0x00000003,0xfffffffd,0x05,0x08},
  {0x09f6c3d,0x166d17,0xfffffa8e,0x00000003,0xfffffffd,0x05,0x00},
  {0x05af0af,0x164c9d,0xfffff53b,0x0000000b,0xfffffff5,0x07,0x00},
  {0x0713d38,0x1621da,0xfffff564,0x0000000a,0xfffffff6,0x07,0x01},
  {0x0875efe,0x15f7b9,0xfffff58c,0x0000000a,0xfffffff6,0x08,0x07},
  {0x09d56a4,0x15ce38,0xfffff5b3,0x0000000a,0xfffffff6,0x07,0x07},
  {0x0b324ca,0x15a553,0xfffff5da,0x0000000a,0xfffffff6,0x05,0x05},
  {0x0c8ca0b,0x157d06,0xfffff600,0x0000000a,0xfffffff6,0x04,0x05},
  {0x0de4700,0x15554e,0xfffff624,0x00000009,0xfffffff7,0x00,0x04},
  {0x0f39c3c,0x152e28,0xfffff648,0x00000009,0xfffffff7,0x04,0x02},
  {0x108ca52,0x150790,0xfffff66c,0x00000009,0xfffffff7,0x06,0x05},
  {0x11dd1d2,0x14e184,0xfffff68e,0x00000009,0xfffffff7,0x04,0x06},
  {0x132b346,0x14bc01,0xfffff6b0,0x00000009,0xfffffff7,0x01,0x04},
  {0x1476f36,0x149704,0xfffff6d1,0x00000008,0xfffffff8,0x05,0x00}}, {
  {0x018869b,0x171549,0x00000001,0x00000000,0x00000000,0x06,0x05},
  {0x017cdf2,0x17154b,0x00000003,0x00000000,0x00000000,0x02,0x07},
  {0x017719e,0x171550,0x00000006,0x00000000,0x00000000,0x05,0x01},
  {0x0174375,0x171558,0x0000000c,0x00000000,0x00000000,0x07,0x08},
  {0x0172c65,0x17156a,0x00000017,0x00000000,0x00000000,0x03,0x01},
  {0x01720e3,0x17158c,0x0000002e,0x00000000,0x00000000,0x03,0x05},
  {0x0171b2e,0x1715d1,0x0000005c,0x00000000,0x00000000,0x09,0x07},
  {0x017186e,0x17165c,0x000000b9,0x00000000,0x00000000,0x05,0x05},
  {0x02e2ecb,0x171715,0x000000b9,0x00000000,0x00000000,0x01,0x02},
  {0x04545e0,0x1717ce,0x000000b9,0x00000000,0x00000000,0x02,0x01},
  {0x02e2eb4,0x1718e3,0x00000172,0x00000000,0x00000000,0x03,0x03},
  {0x0454797,0x171a55,0x00000172,0x00000000,0x00000000,0x05,0x02},
  {0x02e30b0,0x171c80,0x000002e4,0x00000000,0x00000000,0x08,0x03},
  {0x0454d31,0x171f65,0x000002e5,0x00000000,0x00000000,0x03,0x02},
  {0x02e35bf,0x1723bd,0x00000173,0x00000000,0x00000000,0x07,0x07},
  {0x045597d,0x17298b,0x00000174,0x00000000,0x00000000,0x07,0x08},
  {0x02e406c,0x173246,0x000002ea,0x00000001,0xffffffff,0x08,0x07},
  {0x04572b1,0x173df4,0x000002ed,0x00000001,0xffffffff,0x06,0x03},
  {0x05cb0a5,0x1749ad,0x000002f0,0x00000001,0xffffffff,0x01,0x06},
  {0x073fa50,0x175572,0x000002f3,0x00000001,0xffffffff,0x08,0x08},
  {0x08b4fc2,0x176144,0x000002f6,0x00000001,0xffffffff,0x07,0x01},
  {0x0a2b104,0x176d21,0x000002f9,0x00000001,0xffffffff,0x08,0x02},
  {0x05d0cd3,0x177f05,0x000005fb,0x00000003,0xfffffffd,0x05,0x01},
  {0x0748bd2,0x179708,0x00000607,0x00000003,0xfffffffd,0x06,0x01},
  {0x08c22d4,0x17af3c,0x00000613,0x00000003,0xfffffffd,0x07,0x04},
  {0x0a3d20b,0x17c7a2,0x00000620,0x00000003,0xfffffffd,0x04,0x06},
  {0x0bb99a7,0x17e03b,0x0000062d,0x00000003,0xfffffffd,0x02,0x04},
  {0x0d379dc,0x17f907,0x00000639,0x00000003,0xfffffffd,0x07,0x03},
  {0x0eb72dd,0x181206,0x00000646,0x00000003,0xfffffffd,0x0a,0x07},
  {0x10384dd,0x182b3a,0x00000654,0x00000003,0xfffffffd,0x08,0x06},
  {0x11bb011,0x1844a3,0x00000661,0x00000003,0xfffffffd,0x06,0x05},
  {0x133f4af,0x185e42,0x0000066e,0x00000003,0xfffffffd,0x03,0x01},
  {0x14c52ea,0x187816,0x0000067c,0x00000004,0xfffffffc,0x04,0x08},
  {0x164cafa,0x189222,0x0000068a,0x00000004,0xfffffffc,0x03,0x06}} };

// Index of main lookup tables for log in range [0.9375,1.125]
static lsixtab_t lus_log_tabixs[MAX_LOGXP] = {
  { 0,0},{ 1,0},{ 2,0},{ 3,0},{ 4,0},{ 5,0},{ 6,0},{ 7,0},
  { 8,1},{10,1},{12,1},{14,1},{16,1},{18,2},{22,2},{26,3}};

// Exponent increment thresholds for sine in range [0,0.5]
static unsigned int lus_sin_eex[MAX_SINEX] = {
   0x22f982, 0x22f982, 0x22f983, 0x22f983, 0x22f984, 0x22f989, 0x22f99e, 0x22f9ef,
   0x22fb35, 0x23004e, 0x2314b8, 0x2366ee, 0x24b8ce, 0x2aaaaa, 0x7ff190 };

// Main lookup tables for sine in range [0,0.5]
static lslutab_t lus_sin[MAX_SINTB] = {
  {0x03243f6,0x1921fb,0x00000000,0x00000000,0x00000000,0x06,0x03},
  {0x04b65f1,0x1921fb,0x00000000,0x00000000,0x00000000,0x08,0x03},
  {0x03243f6,0x1921fb,0x00000000,0x00000000,0x00000000,0x06,0x03},
  {0x04b65f1,0x1921fb,0x00000000,0x00000000,0x00000000,0x08,0x02},
  {0x03243f6,0x1921fb,0x00000000,0x00000000,0x00000000,0x06,0x02},
  {0x04b65f1,0x1921fb,0x00000000,0x00000000,0x00000000,0x07,0x02},
  {0x03243f6,0x1921fb,0x00000000,0x00000000,0x00000000,0x05,0x02},
  {0x04b65f1,0x1921fa,0x00000000,0x00000000,0x00000000,0x06,0x08},
  {0x03243f6,0x1921fa,0xffffffff,0x00000000,0x00000000,0x03,0x05},
  {0x04b65f0,0x1921f9,0xffffffff,0x00000000,0x00000000,0x07,0x07},
  {0x03243f5,0x1921f8,0xfffffffe,0x00000000,0x00000000,0x04,0x02},
  {0x04b65ed,0x1921f5,0xfffffffd,0x00000000,0x00000000,0x05,0x03},
  {0x03243f2,0x1921ef,0xfffffff6,0x00000000,0x00000000,0x04,0x00},
  {0x04b65e1,0x1921e3,0xfffffff2,0x00000000,0x00000000,0x04,0x03},
  {0x03243e5,0x1921ca,0xffffffd9,0xffffffff,0x00000001,0x08,0x02},
  {0x04b65b2,0x19219b,0xffffffca,0xffffffff,0x00000001,0x02,0x06},
  {0x064874f,0x19215d,0xffffffba,0xffffffff,0x00000001,0x08,0x06},
  {0x07da8af,0x192110,0xffffffab,0xffffffff,0x00000001,0x05,0x02},
  {0x096c9c1,0x1920b3,0xffffff9b,0xffffffff,0x00000001,0x07,0x02},
  {0x0afea77,0x192046,0xffffff8c,0xffffffff,0x00000001,0x00,0x05},
  {0x064857a,0x191f84,0xffffffba,0xfffffffc,0x00000004,0x07,0x07},
  {0x07da506,0x191e4e,0xffffffab,0xfffffffc,0x00000004,0x06,0x07},
  {0x096c35d,0x191cda,0xffffff9b,0xfffffffc,0x00000004,0x05,0x07},
  {0x0afe040,0x191b28,0xffffff8c,0xfffffffc,0x00000004,0x05,0x08},
  {0x0647e22,0x191822,0xfffffee9,0xfffffff0,0x00000010,0x06,0x01},
  {0x07d9663,0x19134a,0xfffffeab,0xfffffff0,0x00000010,0x07,0x05},
  {0x096a9cd,0x190d7b,0xfffffe6d,0xfffffff0,0x00000010,0x05,0x06},
  {0x0afb768,0x1906b5,0xfffffe30,0xfffffff0,0x00000010,0x03,0x04},
  {0x0c8be3c,0x18fef8,0xfffffdf2,0xfffffff0,0x00000010,0x08,0x03},
  {0x0e1bd54,0x18f644,0xfffffdb4,0xfffffff0,0x00000010,0x02,0x04},
  {0x0fab3b6,0x18ec9a,0xfffffd77,0xfffffff0,0x00000010,0x06,0x02},
  {0x113a06f,0x18e1f9,0xfffffd39,0xfffffff0,0x00000010,0x07,0x08},
  {0x12c8288,0x18d664,0xfffffcfc,0xfffffff0,0x00000010,0x07,0x01},
  {0x145590b,0x18c9d9,0xfffffcbf,0xfffffff0,0x00000010,0x01,0x02},
  {0x15e2303,0x18bc59,0xfffffc82,0xfffffff0,0x00000010,0x02,0x05},
  {0x176df7a,0x18ade5,0xfffffc45,0xfffffff0,0x00000010,0x07,0x07},
  {0x18f8d7f,0x189e7e,0xfffffc08,0xfffffff0,0x00000010,0x07,0x05},
  {0x1a82c1c,0x188e24,0xfffffbcb,0xfffffff0,0x00000010,0x04,0x02},
  {0x1c0ba5e,0x187cd7,0xfffffb8f,0xfffffff1,0x0000000f,0x06,0x05},
  {0x1d93755,0x186a99,0xfffffb52,0xfffffff1,0x0000000f,0x04,0x03},
  {0x1f1a20c,0x18576a,0xfffffb16,0xfffffff1,0x0000000f,0x07,0x01},
  {0x209f994,0x18434a,0xfffffada,0xfffffff1,0x0000000f,0x07,0x04},
  {0x2223cfd,0x182e3b,0xfffffa9e,0xfffffff1,0x0000000f,0x04,0x05},
  {0x23a6b55,0x18183d,0xfffffa63,0xfffffff1,0x0000000f,0x08,0x09},
  {0x25283b1,0x180152,0xfffffa27,0xfffffff1,0x0000000f,0x07,0x04},
  {0x26a8522,0x17e97a,0xfffff9ec,0xfffffff1,0x0000000f,0x03,0x01},
  {0x2826eb9,0x17d0b5,0xfffff9b1,0xfffffff1,0x0000000f,0x04,0x06},
  {0x29a3f8c,0x17b706,0xfffff977,0xfffffff1,0x0000000f,0x02,0x03},
  {0x2b1f6b0,0x179c6c,0xfffff93c,0xfffffff1,0x0000000f,0x06,0x08},
  {0x2c9933a,0x1780ea,0xfffff902,0xfffffff1,0x0000000f,0x05,0x04},
  {0x2e11442,0x176480,0xfffff8c8,0xfffffff1,0x0000000f,0x01,0x00},
  {0x2f878de,0x17472e,0xfffff88f,0xfffffff1,0x0000000f,0x01,0x06},
  {0x0c3f2f8,0x0b8cb4,0xfffff839,0xffffffe3,0x0000001d,0x02,0x07},
  {0x0cf7fe6,0x0b6cb6,0xfffff7c8,0xffffffe3,0x0000001d,0x01,0x02},
  {0x0daecd4,0x0b4af4,0xfffff758,0xffffffe3,0x0000001d,0x02,0x04},
  {0x0e637ff,0x0b2774,0xfffff6e9,0xffffffe4,0x0000001c,0x06,0x08},
  {0x0f15fab,0x0b023d,0xfffff67b,0xffffffe4,0x0000001c,0x06,0x01},
  {0x0fc621e,0x0adb52,0xfffff610,0xffffffe5,0x0000001b,0x07,0x06},
  {0x1073da6,0x0ab2bb,0xfffff5a5,0xffffffe5,0x0000001b,0x05,0x05},
  {0x111f097,0x0a887e,0xfffff53c,0xffffffe5,0x0000001b,0x02,0x03},
  {0x11c7948,0x0a5ca1,0xfffff4d5,0xffffffe6,0x0000001a,0x05,0x02},
  {0x126d61c,0x0a2f2b,0xfffff470,0xffffffe6,0x0000001a,0x06,0x00},
  {0x1310579,0x0a0022,0xfffff40c,0xffffffe7,0x00000019,0x06,0x06},
  {0x13b05cd,0x09cf8f,0xfffff3aa,0xffffffe7,0x00000019,0x05,0x06},
  {0x144d58c,0x099d79,0xfffff34b,0xffffffe8,0x00000018,0x03,0x03},
  {0x14e7334,0x0969e7,0xfffff2ed,0xffffffe8,0x00000018,0x06,0x04},
  {0x157dd4a,0x0934e2,0xfffff291,0xffffffe9,0x00000017,0x02,0x00},
  {0x1611259,0x08fe71,0xfffff237,0xffffffe9,0x00000017,0x03,0x01},
  {0x16a10f6,0x08c69d,0xfffff1df,0xffffffea,0x00000016,0x03,0x01},
  {0x172d7be,0x088d6e,0xfffff18a,0xffffffea,0x00000016,0x04,0x05},
  {0x17b6557,0x0852ee,0xfffff136,0xffffffeb,0x00000015,0x01,0x05},
  {0x183b86d,0x081725,0xfffff0e5,0xffffffec,0x00000014,0x06,0x08},
  {0x18bcfba,0x07da1d,0xfffff097,0xffffffec,0x00000014,0x06,0x07},
  {0x193a9ff,0x079bdf,0xfffff04a,0xffffffed,0x00000013,0x05,0x07},
  {0x19b4603,0x075c75,0xfffff001,0xffffffed,0x00000013,0x04,0x04},
  {0x1a2a29d,0x071be8,0xffffefb9,0xffffffee,0x00000012,0x00,0x04},
  {0x1a9bea8,0x06da42,0xffffef74,0xffffffef,0x00000011,0x05,0x08},
  {0x1b0990c,0x06978e,0xffffef32,0xffffffef,0x00000011,0x04,0x07},
  {0x1b730bb,0x0653d6,0xffffeef2,0xfffffff0,0x00000010,0x03,0x04},
  {0x1bd84af,0x060f24,0xffffeeb5,0xfffffff1,0x0000000f,0x06,0x03},
  {0x1c393f1,0x05c982,0xffffee7b,0xfffffff1,0x0000000f,0x01,0x08},
  {0x1c95d90,0x0582fd,0xffffee43,0xfffffff2,0x0000000e,0x01,0x02},
  {0x1cee0a8,0x053b9d,0xffffee0e,0xfffffff3,0x0000000d,0x02,0x07},
  {0x1d41c5f,0x04f36f,0xffffeddc,0xfffffff3,0x0000000c,0x01,0x07},
  {0x1d90fe6,0x04aa7e,0xffffedac,0xfffffff4,0x0000000c,0x08,0x04},
  {0x1ddba7b,0x0460d4,0xffffed7f,0xfffffff5,0x0000000b,0x03,0x07},
  {0x1e21b65,0x04167e,0xffffed56,0xfffffff6,0x0000000a,0x02,0x04},
  {0x1e631f6,0x03cb86,0xffffed2f,0xfffffff6,0x0000000a,0x06,0x05},
  {0x1e9fd8f,0x037ff9,0xffffed0b,0xfffffff7,0x00000009,0x03,0x00},
  {0x1ed7d99,0x0333e1,0xffffecea,0xfffffff8,0x00000008,0x04,0x02},
  {0x1f0b189,0x02e74b,0xffffeccc,0xfffffff9,0x00000007,0x06,0x00},
  {0x1f398e2,0x029a42,0xffffecb0,0xfffffff9,0x00000007,0x06,0x02},
  {0x1f63330,0x024cd2,0xffffec98,0xfffffffa,0x00000006,0x08,0x05},
  {0x1f8800d,0x01ff08,0xffffec83,0xfffffffb,0x00000005,0x05,0x02},
  {0x1fa7f1e,0x01b0ef,0xffffec71,0xfffffffc,0x00000004,0x08,0x01},
  {0x1fc3016,0x016293,0xffffec62,0xfffffffc,0x00000003,0x00,0x01},
  {0x1fd92af,0x011400,0xffffec55,0xfffffffd,0x00000003,0x02,0x05},
  {0x1fea6b4,0x00c543,0xffffec4c,0xfffffffe,0x00000002,0x07,0x03},
  {0x1ff6bfb,0x007667,0xffffec46,0xffffffff,0x00000001,0x02,0x07},
  {0x1ffe264,0x002779,0xffffec43,0x00000000,0x00000000,0x00,0x08} };

// Index of main lookup tables for sine in range [0,0.5]
static lsixtab_t lus_sin_tabixs[MAX_SINXP] = {
  { 0,1},{ 2,1},{ 4,1},{ 6,1},{ 8,1},{10,1},{12,1},{14,1},
  {16,2},{20,2},{24,2},{28,3},{36,4},{52,4},{68,5}};


// This version performs the addition using all multipler output bits.
// It may generate more adder cells in the ls bits than above, but is
// probably better for synopsis data path optimisation...
static int interp_core(int frm, int lm0, int lmd, int lsq, int lc1, int lc2,
                       int bias, int round, int sqf_dropbin, int ccf_dropbin)
{
   int fr2ndhalf,frs,ixc,frc,ccfv,ccfa;
   int64_t opmant;

   // Main linear table
   fr2ndhalf = ((frm & lu_mfr_frmsbit) != 0);
   opmant = (int64_t)lmd*frm + ((int64_t)lm0<<lu_mfr_dropb);

   // Square term.
   // Note slight assymetry of abs(fr-1/2)^2 approximation that uses ~ instead of -
   frs = frm >> sqf_dropbin;
   frs = fr2ndhalf ? frs : ~frs;
   frs &= (lu_sqf_mask>>sqf_dropbin);
   frs = ((int64_t)frs*frs) >> lu_sqf_dropbmid;
   opmant += (((int64_t)frs*lsq) << (lu_mfr_dropb-lu_sqf_extrab-lu_sqf_dropbout));

   // Correction table term
   ixc = frm >> lu_ccf_ixshift;
   frc = (frm >> lu_ccf_frshift) & lu_ccf_frmask;
   // NOTE: NO round is best here - the bias helps average out table non-linearity
   ccfv = ((lus_ccd[ixc]*frc) >> lu_ccf_dropbtab) + lus_cc0[ixc];
   ccfv >>= ccf_dropbin;
   ccfa = fr2ndhalf ? lc2 : lc1;
   opmant += (int64_t)(ccfv*ccfa) << (lu_mfr_dropb-lu_ccf_extrab-lu_ccf_dropbout);

   // Bias term. Adds some fraction of linear term to compensate for 1's
   // complemented input mantissa and lost bits from denormed exp2 input.
   // 5 bits (1.4) seems is enough...
   bias = (bias * (lmd>>(lu_mfr_dropb+lu_out_dropb-lu_mfr_biasb)))>>(lu_mfr_biasb+lu_mfr_biasb2-lu_out_extrab);

   // Modify round to include the lsbs of lsq that were off the bottom of lu_lm0
   round += ((-lsq)<<(lu_out_extrab-lu_out_dropb-lu_sqf_extrab-2*sqf_dropbin)) & ((1<<(lu_out_extrab-lu_out_dropb))-1);

   opmant = (opmant>>(lu_mfr_dropb+lu_out_dropb-lu_out_extrab)) + round + bias;
   return (int)opmant;
}

static int fn_interp(int mantin, int w, int bias, int round)
{
   int ixm = mantin >> lu_mfr_ixshift;
   int frm = mantin & lu_mfr_frmask;
   int retval = interp_core(frm,lus_lm0[w][ixm],lus_lmd[w][ixm],lus_lsq[w][ixm],lus_lc1[w][ixm],lus_lc2[w][ixm],bias,round,0,0);
   return retval;
}

/*
   Following functions meet or exceed the following ES3.0 GLSL specs:
   Denorms can be flushed to 0 on input and output
   recip(x):      2.5 ULP for x in range [2^-126, 2^126].
   recipsqrt(x):  2 ULP
   log2(x):       3ULP outside [0.5,2.0], < 2^-21 inside [0.5,2.0]
   exp2(x):       (3 + 2*|x|)ULP
   Except for easily meeting the relaxations of log2,
   we achieve <1 ULP elswhere.
*/
unsigned int sfu_recip(unsigned int f, bool prop_nan)
{
   int w = 0;
   unsigned int s = f & (1u << 31);
   unsigned int m = f & ((1<<23)-1);
   int e = (f >> 23) & 0xFF;
   int round = 1<<(lu_out_extrab-1);
   round -= 1<<(lu_out_extrab-6); /* So x*recip(x) is always <=1. See GFXV-374, GFXH-913 */

   // Propagate NANs, or 0
   if (e == 0xFF && m != 0) {
      return prop_nan ? PROPAGATED_NAN : 0;
   }

   if (e == 0) {
      // Renormalise a couple of levels of denorms, as these aren't INF
      if (m < (1<<21)) {
         return s | (0xFF << 23);
      } else {
         m <<= 1;
         if (m < (1<<23)) {
            e--;
            m <<= 1;
         }
         m &= ((1<<23)-1);
      }
   } else if (e >= 255) {
      return s;
   }

   if (m==0) {
      // Make sure exact powers of 2 are correct
      if (e >= 253) {
         // Need a couple of levels of denorm
         if (e > 253)
            return s | (1<<22);
         else
            return s | (1<<23);
      }
      e = 0xFF & ((~e) + 255);
      return s | (e << 23);
   }
   if (e>=253) {
      // Tweak rounding for denormed output.
      round = (e&3)<<(lu_out_extrab);
   }

   // Special-case this rounded denorm as well, just because we can...
   //if ((m>>1)==0 && e==254)
   //   return s | (1<<22);

   // These Tables work with complemented mantissa, so the slope is +ve and
   // we don't need signed arithmetic in linear interp bit.
   // We have two tables - double res for 0<=m<0.5 and half table for rest
   if (m & (1<<22)) {
      w = 0;
      m = ~m;
      m &= (1<<22)-1;
   } else {
      w = 1;
      m = ~(m<<1);
      m &= (1<<23)-1;
   }
   m = fn_interp(m, w, 0, round)>>lu_out_extrab;

   if (e >= 253) {
      // Need a couple of levels of denorm
      // NOTE: GLSL Accuracy is only specified for the range 2^-126 to 2^126,
      // so we don't need to worry about rounding to avoid degraded accuracy.
      // It stays better than the 2ULP anyway (we are allowed 2.5)
      if (e > 253)
         m = (1<<21) | (m>>2);
      else
         m = (1<<22) | (m>>1);
      e = 0;
   } else {
      e = 0xFF & ((~e) + 254);
   }

   return s | (e << 23) | m;
}

unsigned int sfu_recipsqrt(unsigned int f, bool prop_nan)
{
   int w = 2;
   unsigned int s = f & (1 << 31);
   unsigned int m = f & ((1<<23)-1);
   int e = (f >> 23) & 0xFF;
   int round = 1<<(lu_out_extrab-1);

   // NOTE: perhaps we should really handle denorms on input here, as they produce
   // finite output. But we can't afford it timing-wise.
   // Alternative would be to have further table(s) just to handle the
   // denorms, but that just seems crazy!
   // However DirectX requires denormal input to be flushed to +-0,
   // So that's what we do!

   // Propagate NANs
   if (e == 0xFF && m != 0) {
      return prop_nan ? PROPAGATED_NAN : 0;
   }

   /* Catch all negative numbers, except -0.0 and negative denormals.  */
   if (s && (f & ~((1 << 23) - 1)) != (1U << 31)) {
      return prop_nan ? GENERATED_NAN : 0;
   }

   if (e == 0) {
      // Flush all input denormals, giving +-INF output
      // This seems to be required behaviour for DirectX10+
      // We COULD renormalise a couple of levels as for recip...
      return s | (0xFF << 23);
   } else if (e >= 255) {
      return 0;
   }

   w = (e & 1) ? 2 : 3;

   // Effort to get a single adder here...
   e = (~(e>>1))+(190|(~e&1)|(m==0));

   if (m==0 && (w==2)) {
      // Make sure exact powers of 2 are correct
      return s | (e << 23);
   }


   // These Tables work with complemented mantissa, so the slope is +ve and
   // we don't need signed arithmetic in linear interp bit.
   m = ~m;
   m &= (1<<23)-1;
   m = fn_interp(m, w, 0, round)>>lu_out_extrab;

   return s | (e << 23) | m;
}

#if V3D_VER_AT_LEAST(3,3,0,0)
// GFXH-1235 : Support for calculating sqrt(x) as x*rsqrt(x)
// rsqrt2(+/-0)=0
// rsqrt2(+/-denormal)=0
// rsqrt2(+infinity)=min float>0
// rsqrt2(any other x)=rsqrt(x)
unsigned int sfu_recipsqrt2(unsigned int f, bool prop_nan)
{
   unsigned int s = f & (1u << 31);
   unsigned int e = (f >> 23) & 0xff;
   unsigned int m = f & 0x7fffff;

   if (e == 0)
      return 0;
   else if ((e == 255) && (m == 0) && !s)
      return 0x00000001;

   return sfu_recipsqrt(f,prop_nan);
}
#endif

unsigned int sfu_exp(unsigned int f, bool prop_nan)
{
   int w = 4;
   unsigned int s = f & (1 << 31);
   unsigned int m = f & ((1<<23)-1);
   int e = (f >> 23) & 0xFF;
   unsigned int tmpshift;
   unsigned int denorm;
   int round = 1<<(lu_out_extrab-1);
   int bias = 0;
   int i;

   // Propagate NANs
   if (e == 0xFF && m != 0) {
      return prop_nan ? PROPAGATED_NAN : 0;
   }

   /* All denormals are silently changed to +0.0 on input.  This is so
   that e.g. +-0.0 will return the same value.  */
   if (e == 0) {
      f = 0;
      m = 0;
   }

   /* Infinity?  */
   if (e == 0xFF) {
      if (s)
         return 0;
      else
         return 0xFF << 23;
   }

   tmpshift = ((~e)+8) & ((1<<5)-1);
   denorm = (1 << 31) | (m << 8);
   denorm >>= tmpshift;
   i = tmpshift-8-lu_mfr_biasb2;
   if (i >= 0)
      bias = (m >> i);
   else
      bias = (m << -i);
   if (s) bias = ~bias;
   bias &= ((1<<(lu_mfr_biasb2))-1);
   //if (tmpshift <= 8 && s) bias = (1<<lu_mfr_biasb);

   if (e & (1 << 7)) {
      if (((e >> 3) & ((1 << 4) - 1))
            // NOTE: Should really produce denorms with large -ve powers...
            /* Catch >= 128 */
            || ((denorm >> 30) & 0x3)
            /* Catch >126.0 with -ve powers */
            || (denorm > (0x7e<<23) && s))
      {
         if (s)
            return 0; /* e^(-really big number) = 0 */
         else
            return 0xFF << 23; /* e^(+really big number) = inf */
      }
   } else {
      if ((e & 0x7f) < 0x68) {
         denorm = 0;
         bias = 0;
      }
   }

   if (s && (e >= 0x68)) {
      // We're using '~' here because '-' is too expensive
      // The Bias term compensates for that...
      if ((denorm&((1<<23)-1)) == 0) {
         // if the mantissa part is zero, adding the bias could wrap back to
         // zero output and we'd need the exponent part incrementing.
         // So just do it like this as a special case:
         denorm = (((~(denorm>>23))+1)<<23) & ((1 << 30) - 1);
         bias = 0;
      } else {
         denorm = (~denorm) & ((1 << 30) - 1);
      }
   }

   m = denorm & ((1 << 23) - 1);
   f = fn_interp(m, w, bias, round)>>lu_out_extrab;

   e = (denorm >> 23);
   e &= ((1 << 7) - 1);
   if (s && e>0) {
      e = (e - 1);
   } else {
      e = (e + 127);
   }

   return (e<<23) | f;
}

unsigned int sfu_log(unsigned f, bool prop_nan)
{
   int w = 5;
   unsigned int s = f & (1 << 31);
   int e = (f >> 23) & 0xFF;
   unsigned int m = f & ((1<<23)-1);
   unsigned int fraction;
   unsigned int tmp_e;
   unsigned int denorm;
   int round = 1<<(lu_out_extrab-1);
   int donexp=0;

   // Propagate NANs
   if (e == 0xFF && m != 0) {
      return prop_nan ? PROPAGATED_NAN : 0;
   }

   /* Catch all negative numbers, except -0.0 and negative denormals.  */
   if (s && (f & ~((1 << 23) - 1)) != (1U << 31)) {
      return prop_nan ? GENERATED_NAN : 0;
   }

   if (e == 255) {
      return 0xFF << 23;
   } else if (e == 0) {
      return (1 << 31) | (0xFF << 23);
   }

   if (e >= 127) {
      s = 0;
      tmp_e = e - 127;
   } else {
      s = 1;
      tmp_e = (~e)&127;
      tmp_e -= 1;
      // We may add that 1 back on again later,
      // if our rounded output is zero...
   }

   // Try squeezing out a bit more accuracy close to 1
   if (e==127 || e==126) {
      int xe;
      int xm = s ? (~m)&((1<<23)-1) : m;
      if (xm < (1<<lu_log_maxexp) && use_log_extrap) {
         int ix,nsub,eexp;
         // We use a different 'floating-point' 1+x interpolation when close to 1
         if (xm < lu_log_numimm) {
            // Direct lookup for the first few values
            return (s<<31) | lus_log_imm[s][xm];
         }
         // Get normalisation exponent of xm
         for (xe = lu_log_maxexp-1; !(xm>>xe); xe--);
         ix = xe - lu_log_minexp;
         // Lookup table parameters
         eexp = (xm > lus_log_eex[s][ix]);
         nsub = lus_log_tabixs[ix].nsub;
         ix = lus_log_tabixs[ix].offs;
         // normalise to get table index and fraction
         xm <<= lu_mfr_ixshift-xe+nsub;
         ix += (xm>>lu_mfr_ixshift) & ((1<<nsub)-1);
         xm &= lu_mfr_frmask;
         // compute round, with linear error corrections
         round = lus_log[s][ix].r0 + ((lus_log[s][ix].rd*(xm>>(lu_mfr_ixshift-4)))>>4) + ((1<<(nsub+eexp))>>1);
         // Do core interpolation
         xm = interp_core(xm,lus_log[s][ix].m0,lus_log[s][ix].md,lus_log[s][ix].sq,
                          lus_log[s][ix].c1,lus_log[s][ix].c2,0,round,(xe<lu_log_sqexthr),1);
         // Shift to correct resolution and get exponent
         xm = (xm >> (eexp+nsub)) & ((1<<23)-1);
         xe += eexp + 127-23-s;
         return (s<<31) | (xe<<23) | xm;
      }
      // Find where msb of input is to work out final shift now
      for (xe = 22; !(xm>>xe); xe--);
      // Use compare to see if the output has gone up to the next step...
      if (xm > lus_log_eex[s][xe-lu_log_minexp])
         xe++;
      e = xe-23-s;     // -ve: Consistent with e in donexp case
      if (use_log_extrap && 0) {    // POINTLESS FOR 1.4ULP VERSION
         round = (1<<(xe-24-s+lu_out_extrab));
         if (round == (4>>s)) round = 3;
      } else {
         // An adequate compromise...
         round = 3;
      }
      // As with the hardware, fold the -1 of negating the output into the
      // round term in the main sum pipeline stage, with just 1's complement
      // to be applied afterwards prior to normalisation
      if (s)
         round = -round;
      donexp = 0;
      // e==126 and m==0 is a special case
      // It should come out as tmp_e=1, fraction=0
      // So we can simply make that happen here...
      if (m==0 && s) {
         e = 0;
         donexp = 1;
         tmp_e = 1;
         //round = 0;     // This doesn't matter...
      }
   } else {
      // Non-zero tmp_e, so we can work out normalisation shift right now and
      // use it to apply round at just the bit we want it at.
      donexp = 1;
      e = 6;
      while (! (tmp_e & (1 << e))) {
         e--;
      }
      round = 1<<(lu_out_extrab-1+e);
      // Determine if we are going to have a rounding-wrap and adjust
      // exponents up accordingly. We do this now to avoid any dependency
      // on the output data for the norm shift, by using precalculated
      // thresholds on the input data...
      if (s ? (m < lus_log_wth[1][e]) : (m > lus_log_wth[0][e])) {
         tmp_e++;
         if (tmp_e & (1<<(e+1))) {
            e++;
         }
      }

      // As with the hardware, fold the -1 of negating the output into the
      // round term in the main sum pipeline stage, with just 1's complement
      // to be applied afterwards prior to normalisation
      if (s)
         round = -round;
   }

   fraction = fn_interp(m, w, 0, round);

   if (s) {
      // Since we've already subtracted 1, we can use 1's complement here.
      fraction = ~fraction;
   }
   fraction &= ((1<<(23+lu_out_extrab)) - 1);

   // Due to interpolation accuracy, 0 doesn't quite map to 0...
   // We've already ensured the (e=126,m=0)=0.5 case above works, this further
   // ensures that we hit exact integer outputs for exact powers of 2 input.
   // What it really does is make sure log2(1.0) == 0, rather than being piddly
   if (m==0) fraction = 0;

   if (!donexp)
      denorm = fraction;
   else
      denorm = (tmp_e << 23) | (fraction>>lu_out_extrab);

   if (denorm == 0) {
      return 0;
   }

   if (donexp) {
      // Have already sorted out how much to normalise
      denorm <<= (6-e);
      e += 127;
   } else {
      denorm <<= (6-lu_out_extrab-e);
      e += 127;
   }

   /* Grab msbs and lose hidden bit */
   // Ideally we should round - but that is perhaps too costly,
   // and we are managing better than 1ULP anyway
   denorm >>= 6;
   denorm &= ~(1 << 23);

   return (s<<31) | (e << 23) | denorm;
}

unsigned int sfu_sin(unsigned int f, bool prop_nan)
{
   unsigned int s = f & (1 << 31);
   int e = (f >> 23) & 0xFF;
   unsigned int m = f & ((1<<23)-1);
   int round,tix,ix,nsub,eexp,xm,xe,xfr;
   int ophalf = (e>=124);

   // Propagate NaNs and return NaN for INF input
   if (e == 0xFF) {
      return prop_nan ? ((m!=0) ? PROPAGATED_NAN : GENERATED_NAN) : 0;
   }
   // For input outside [-0.5,0.5] saturate at +-1
   if (e >= 126) {
      return s | (0x7f << 23);
   }
   // Flush denorm input to 0
   if (e == 0) {
      return s;
   }

   // Offset exponent, saturating at 0 to get table index index
   xe = e - (125-22);
   if (xe < lu_sin_minexp)
      xe = lu_sin_minexp;
   ix = xe - lu_sin_minexp;

   // Lookup table parameters
   eexp = (m > lus_sin_eex[ix]);
   nsub = lus_sin_tabixs[ix].nsub;
   ix = lus_sin_tabixs[ix].offs;

   // normalise to get table index and fraction
   xm = m << nsub;
   tix = (xm>>23) & ((1<<nsub)-1);
   ix += tix;
   xfr = xm & ((1<<(23-lu_mfr_ixshift))-1);
   xm >>= (23-lu_mfr_ixshift);
   xm &= lu_mfr_frmask;
   // Further mask lsbs in last 4 table sections, to maintain monotinicity
   // - this has a negligible effect on accuracy
   if (e==125 && tix>=((1<<nsub)-4)) {
      xfr = 0;
      if (tix==((1<<nsub)-1))
         xm &= ((1<<23)-4);
      else if (tix==((1<<nsub)-2))
         xm &= ((1<<23)-2);
   }

   // compute round, with linear error corrections
   round = lus_sin[ix].r0 + ((lus_sin[ix].rd*(xm>>(lu_mfr_ixshift-4)) + (lus_sin[ix].md>>16)*xfr)>>4) + ((1<<(nsub+eexp-ophalf))>>1);

   // Do core interpolation
   xm = interp_core(xm,lus_sin[ix].m0,lus_sin[ix].md,lus_sin[ix].sq,
                    lus_sin[ix].c1,lus_sin[ix].c2,0,round,(xe<lu_sin_sqexthr),1);

   // Shift to correct resolution and get exponent
   xm = (xm >> (nsub+eexp-ophalf)) & ((1<<23)-1);
   xe = e+eexp+1;

   return s | (xe<<23) | xm;
}
