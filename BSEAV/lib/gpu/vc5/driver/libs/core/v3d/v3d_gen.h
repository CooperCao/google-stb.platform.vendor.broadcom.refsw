/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *
 *** Do not edit this file. It is automatically generated by scripts/codegen/codegen.py ***
 ******************************************************************************/
#ifndef V3D_GEN_H
#define V3D_GEN_H
#include "libs/util/assert_helpers.h"
#include "libs/util/gfx_util/gfx_util.h"
#include "libs/util/gfx_util/gfx_util_conv.h"
#include "v3d_addr.h"
#include "v3d_cl_rw.h"
#include "v3d_printer.h"
#include "v3d_ver.h"
#ifndef EXPORT_FOR_CLIF_CC
#define EXPORT_FOR_CLIF_CC
#endif
EXTERN_C_BEGIN
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_THREADING_1       = 0,
   V3D_THREADING_2       = 1,
   V3D_THREADING_4       = 2,
   V3D_THREADING_INVALID = 4
} v3d_threading_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_threading(v3d_threading_t threading)
{
   return (uint32_t)threading <= 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_threading(v3d_threading_t threading);
extern const char *v3d_desc_threading(v3d_threading_t threading);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern v3d_threading_t v3d_translate_threading(uint32_t x);
extern uint32_t v3d_translate_from_threading(v3d_threading_t x);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_THREADING_2       = 0,
   V3D_THREADING_4       = 1,
   V3D_THREADING_INVALID = 2
} v3d_threading_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_threading(v3d_threading_t threading)
{
   return (uint32_t)threading <= 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_threading(v3d_threading_t threading);
extern const char *v3d_desc_threading(v3d_threading_t threading);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern v3d_threading_t v3d_translate_threading(uint32_t x);
extern uint32_t v3d_translate_from_threading(v3d_threading_t x);
#endif
typedef enum
{
   V3D_ATTR_TYPE_HALF_FLOAT    = 1,
   V3D_ATTR_TYPE_FLOAT         = 2,
   V3D_ATTR_TYPE_FIXED         = 3,
   V3D_ATTR_TYPE_BYTE          = 4,
   V3D_ATTR_TYPE_SHORT         = 5,
   V3D_ATTR_TYPE_INT           = 6,
   V3D_ATTR_TYPE_INT2_10_10_10 = 7,
   V3D_ATTR_TYPE_INVALID       = 8
} v3d_attr_type_t;
extern bool v3d_is_valid_attr_type(v3d_attr_type_t attr_type);
extern const char *v3d_maybe_desc_attr_type(v3d_attr_type_t attr_type);
extern const char *v3d_desc_attr_type(v3d_attr_type_t attr_type);
typedef enum
{
   V3D_TMU_TYPE_YCBCR_LUMA                      = 39,
   V3D_TMU_TYPE_YCBCR_420_CHROMA                = 40,
   V3D_TMU_TYPE_R8I                             = 96,
   V3D_TMU_TYPE_R8UI                            = 97,
   V3D_TMU_TYPE_RG8I                            = 98,
   V3D_TMU_TYPE_RG8UI                           = 99,
   V3D_TMU_TYPE_RGBA8I                          = 100,
   V3D_TMU_TYPE_RGBA8UI                         = 101,
   V3D_TMU_TYPE_R16I                            = 102,
   V3D_TMU_TYPE_R16UI                           = 103,
   V3D_TMU_TYPE_RG16I                           = 104,
   V3D_TMU_TYPE_RG16UI                          = 105,
   V3D_TMU_TYPE_RGBA16I                         = 106,
   V3D_TMU_TYPE_RGBA16UI                        = 107,
   V3D_TMU_TYPE_R32I                            = 108,
   V3D_TMU_TYPE_R32UI                           = 109,
   V3D_TMU_TYPE_RG32I                           = 110,
   V3D_TMU_TYPE_RG32UI                          = 111,
   V3D_TMU_TYPE_RGBA32I                         = 112,
   V3D_TMU_TYPE_RGBA32UI                        = 113,
   V3D_TMU_TYPE_RGB10_A2UI                      = 114,
   V3D_TMU_TYPE_R8                              = 0,
   V3D_TMU_TYPE_R8_SNORM                        = 1,
   V3D_TMU_TYPE_RG8                             = 2,
   V3D_TMU_TYPE_RG8_SNORM                       = 3,
   V3D_TMU_TYPE_RGBA8                           = 4,
   V3D_TMU_TYPE_RGBA8_SNORM                     = 5,
   V3D_TMU_TYPE_RGB565                          = 6,
   V3D_TMU_TYPE_RGBA4                           = 7,
   V3D_TMU_TYPE_RGB5_A1                         = 8,
   V3D_TMU_TYPE_RGB10_A2                        = 9,
   V3D_TMU_TYPE_R16                             = 10,
   V3D_TMU_TYPE_R16_SNORM                       = 11,
   V3D_TMU_TYPE_RG16                            = 12,
   V3D_TMU_TYPE_RG16_SNORM                      = 13,
   V3D_TMU_TYPE_RGBA16                          = 14,
   V3D_TMU_TYPE_RGBA16_SNORM                    = 15,
   V3D_TMU_TYPE_R16F                            = 16,
   V3D_TMU_TYPE_RG16F                           = 17,
   V3D_TMU_TYPE_RGBA16F                         = 18,
   V3D_TMU_TYPE_R11F_G11F_B10F                  = 19,
   V3D_TMU_TYPE_RGB9_E5                         = 20,
#if !V3D_HAS_TMU_R32F_R16_SHAD
   V3D_TMU_TYPE_DEPTH_COMP16                    = 21,
#endif
   V3D_TMU_TYPE_DEPTH_COMP24                    = 22,
#if !V3D_HAS_TMU_R32F_R16_SHAD
   V3D_TMU_TYPE_DEPTH_COMP32F                   = 23,
#endif
   V3D_TMU_TYPE_DEPTH24_X8                      = 24,
   V3D_TMU_TYPE_R4                              = 25,
   V3D_TMU_TYPE_R1                              = 26,
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_TMU_TYPE_S8                              = 27,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_TMU_TYPE_S16                             = 28,
#endif
   V3D_TMU_TYPE_R32F                            = 29,
   V3D_TMU_TYPE_RG32F                           = 30,
   V3D_TMU_TYPE_RGBA32F                         = 31,
   V3D_TMU_TYPE_C_RGB8_ETC2                     = 32,
   V3D_TMU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 33,
   V3D_TMU_TYPE_C_R11_EAC                       = 34,
   V3D_TMU_TYPE_C_SIGNED_R11_EAC                = 35,
   V3D_TMU_TYPE_C_RG11_EAC                      = 36,
   V3D_TMU_TYPE_C_SIGNED_RG11_EAC               = 37,
   V3D_TMU_TYPE_C_RGBA8_ETC2_EAC                = 38,
   V3D_TMU_TYPE_C_BC1                           = 48,
   V3D_TMU_TYPE_C_BC2                           = 49,
   V3D_TMU_TYPE_C_BC3                           = 50,
   V3D_TMU_TYPE_C_ASTC_4X4                      = 64,
   V3D_TMU_TYPE_C_ASTC_5X4                      = 65,
   V3D_TMU_TYPE_C_ASTC_5X5                      = 66,
   V3D_TMU_TYPE_C_ASTC_6X5                      = 67,
   V3D_TMU_TYPE_C_ASTC_6X6                      = 68,
   V3D_TMU_TYPE_C_ASTC_8X5                      = 69,
   V3D_TMU_TYPE_C_ASTC_8X6                      = 70,
   V3D_TMU_TYPE_C_ASTC_8X8                      = 71,
   V3D_TMU_TYPE_C_ASTC_10X5                     = 72,
   V3D_TMU_TYPE_C_ASTC_10X6                     = 73,
   V3D_TMU_TYPE_C_ASTC_10X8                     = 74,
   V3D_TMU_TYPE_C_ASTC_10X10                    = 75,
   V3D_TMU_TYPE_C_ASTC_12X10                    = 76,
   V3D_TMU_TYPE_C_ASTC_12X12                    = 77,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_TMU_TYPE_RGB5_A1_REV                     = 115,
#endif
   V3D_TMU_TYPE_INVALID                         = 128
} v3d_tmu_type_t;
extern bool v3d_is_valid_tmu_type(v3d_tmu_type_t tmu_type);
extern const char *v3d_maybe_desc_tmu_type(v3d_tmu_type_t tmu_type);
extern const char *v3d_desc_tmu_type(v3d_tmu_type_t tmu_type);
typedef enum
{
   V3D_TFU_TYPE_YUV_420_2PLANE_REC709           = 39,
   V3D_TFU_TYPE_YUV_420_2PLANE_REC601           = 40,
   V3D_TFU_TYPE_YUV_420_2PLANE_JPEG             = 41,
   V3D_TFU_TYPE_YUV_422_2PLANE_REC709           = 42,
   V3D_TFU_TYPE_YUV_422_2PLANE_REC601           = 43,
   V3D_TFU_TYPE_YUV_422_2PLANE_JPEG             = 44,
   V3D_TFU_TYPE_YUYV_422_1PLANE_REC709          = 45,
   V3D_TFU_TYPE_YUYV_422_1PLANE_REC601          = 46,
   V3D_TFU_TYPE_YUYV_422_1PLANE_JPEG            = 47,
   V3D_TFU_TYPE_YUV_420_3PLANE_REC601           = 90,
   V3D_TFU_TYPE_YUV_420_3PLANE_REC709           = 91,
   V3D_TFU_TYPE_YUV_420_3PLANE_JPEG             = 92,
   V3D_TFU_TYPE_R8                              = 0,
   V3D_TFU_TYPE_R8_SNORM                        = 1,
   V3D_TFU_TYPE_RG8                             = 2,
   V3D_TFU_TYPE_RG8_SNORM                       = 3,
   V3D_TFU_TYPE_RGBA8                           = 4,
   V3D_TFU_TYPE_RGBA8_SNORM                     = 5,
   V3D_TFU_TYPE_RGB565                          = 6,
   V3D_TFU_TYPE_RGBA4                           = 7,
   V3D_TFU_TYPE_RGB5_A1                         = 8,
   V3D_TFU_TYPE_RGB10_A2                        = 9,
   V3D_TFU_TYPE_R16                             = 10,
   V3D_TFU_TYPE_R16_SNORM                       = 11,
   V3D_TFU_TYPE_RG16                            = 12,
   V3D_TFU_TYPE_RG16_SNORM                      = 13,
   V3D_TFU_TYPE_RGBA16                          = 14,
   V3D_TFU_TYPE_RGBA16_SNORM                    = 15,
   V3D_TFU_TYPE_R16F                            = 16,
   V3D_TFU_TYPE_RG16F                           = 17,
   V3D_TFU_TYPE_RGBA16F                         = 18,
   V3D_TFU_TYPE_R11F_G11F_B10F                  = 19,
   V3D_TFU_TYPE_RGB9_E5                         = 20,
#if !V3D_HAS_TMU_R32F_R16_SHAD
   V3D_TFU_TYPE_DEPTH_COMP16                    = 21,
#endif
   V3D_TFU_TYPE_DEPTH_COMP24                    = 22,
#if !V3D_HAS_TMU_R32F_R16_SHAD
   V3D_TFU_TYPE_DEPTH_COMP32F                   = 23,
#endif
   V3D_TFU_TYPE_DEPTH24_X8                      = 24,
   V3D_TFU_TYPE_R4                              = 25,
   V3D_TFU_TYPE_R1                              = 26,
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_TFU_TYPE_S8                              = 27,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_TFU_TYPE_S16                             = 28,
#endif
   V3D_TFU_TYPE_R32F                            = 29,
   V3D_TFU_TYPE_RG32F                           = 30,
   V3D_TFU_TYPE_RGBA32F                         = 31,
   V3D_TFU_TYPE_C_RGB8_ETC2                     = 32,
   V3D_TFU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 33,
   V3D_TFU_TYPE_C_R11_EAC                       = 34,
   V3D_TFU_TYPE_C_SIGNED_R11_EAC                = 35,
   V3D_TFU_TYPE_C_RG11_EAC                      = 36,
   V3D_TFU_TYPE_C_SIGNED_RG11_EAC               = 37,
   V3D_TFU_TYPE_C_RGBA8_ETC2_EAC                = 38,
   V3D_TFU_TYPE_C_BC1                           = 48,
   V3D_TFU_TYPE_C_BC2                           = 49,
   V3D_TFU_TYPE_C_BC3                           = 50,
   V3D_TFU_TYPE_C_ASTC_4X4                      = 64,
   V3D_TFU_TYPE_C_ASTC_5X4                      = 65,
   V3D_TFU_TYPE_C_ASTC_5X5                      = 66,
   V3D_TFU_TYPE_C_ASTC_6X5                      = 67,
   V3D_TFU_TYPE_C_ASTC_6X6                      = 68,
   V3D_TFU_TYPE_C_ASTC_8X5                      = 69,
   V3D_TFU_TYPE_C_ASTC_8X6                      = 70,
   V3D_TFU_TYPE_C_ASTC_8X8                      = 71,
   V3D_TFU_TYPE_C_ASTC_10X5                     = 72,
   V3D_TFU_TYPE_C_ASTC_10X6                     = 73,
   V3D_TFU_TYPE_C_ASTC_10X8                     = 74,
   V3D_TFU_TYPE_C_ASTC_10X10                    = 75,
   V3D_TFU_TYPE_C_ASTC_12X10                    = 76,
   V3D_TFU_TYPE_C_ASTC_12X12                    = 77,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_TFU_TYPE_RGB5_A1_REV                     = 115,
#endif
   V3D_TFU_TYPE_INVALID                         = 128
} v3d_tfu_type_t;
extern bool v3d_is_valid_tfu_type(v3d_tfu_type_t tfu_type);
extern const char *v3d_maybe_desc_tfu_type(v3d_tfu_type_t tfu_type);
extern const char *v3d_desc_tfu_type(v3d_tfu_type_t tfu_type);
typedef enum
{
   V3D_TMU_WRAP_REPEAT      = 0,
   V3D_TMU_WRAP_CLAMP       = 1,
   V3D_TMU_WRAP_MIRROR      = 2,
   V3D_TMU_WRAP_BORDER      = 3,
   V3D_TMU_WRAP_MIRROR_ONCE = 4,
   V3D_TMU_WRAP_INVALID     = 8
} v3d_tmu_wrap_t;
static inline bool v3d_is_valid_tmu_wrap(v3d_tmu_wrap_t tmu_wrap)
{
   return (uint32_t)tmu_wrap <= 4;
}
extern const char *v3d_maybe_desc_tmu_wrap(v3d_tmu_wrap_t tmu_wrap);
extern const char *v3d_desc_tmu_wrap(v3d_tmu_wrap_t tmu_wrap);
typedef enum
{
   V3D_TMU_WRAP_I_CLAMP   = 0,
   V3D_TMU_WRAP_I_BORDER  = 1,
   V3D_TMU_WRAP_I_INVALID = 2
} v3d_tmu_wrap_i_t;
static inline bool v3d_is_valid_tmu_wrap_i(v3d_tmu_wrap_i_t tmu_wrap_i)
{
   return (uint32_t)tmu_wrap_i <= 1;
}
extern const char *v3d_maybe_desc_tmu_wrap_i(v3d_tmu_wrap_i_t tmu_wrap_i);
extern const char *v3d_desc_tmu_wrap_i(v3d_tmu_wrap_i_t tmu_wrap_i);
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_WRAP_CFG0_REPEAT  = 0,
   V3D_TMU_WRAP_CFG0_CLAMP   = 1,
   V3D_TMU_WRAP_CFG0_MIRROR  = 2,
   V3D_TMU_WRAP_CFG0_1D      = 3,
   V3D_TMU_WRAP_CFG0_INVALID = 4
} v3d_tmu_wrap_cfg0_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0)
{
   return (uint32_t)tmu_wrap_cfg0 <= 3;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0);
extern const char *v3d_desc_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_MAX_ANISO_2       = 0,
   V3D_MAX_ANISO_4       = 1,
   V3D_MAX_ANISO_8       = 2,
   V3D_MAX_ANISO_16      = 3,
   V3D_MAX_ANISO_INVALID = 4
} v3d_max_aniso_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_max_aniso(v3d_max_aniso_t max_aniso)
{
   return (uint32_t)max_aniso <= 3;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_max_aniso(v3d_max_aniso_t max_aniso);
extern const char *v3d_desc_max_aniso(v3d_max_aniso_t max_aniso);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern v3d_max_aniso_t v3d_translate_max_aniso(uint32_t x);
extern uint32_t v3d_translate_from_max_aniso(v3d_max_aniso_t x);
#endif
typedef enum
{
   V3D_TMU_FILTER_LINEAR  = 0,
   V3D_TMU_FILTER_NEAREST = 1,
   V3D_TMU_FILTER_INVALID = 2
} v3d_tmu_filter_t;
static inline bool v3d_is_valid_tmu_filter(v3d_tmu_filter_t tmu_filter)
{
   return (uint32_t)tmu_filter <= 1;
}
extern const char *v3d_maybe_desc_tmu_filter(v3d_tmu_filter_t tmu_filter);
extern const char *v3d_desc_tmu_filter(v3d_tmu_filter_t tmu_filter);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_MIPFILT_LINEAR  = 0,
   V3D_TMU_MIPFILT_NEAREST = 1,
   V3D_TMU_MIPFILT_INVALID = 2
} v3d_tmu_mipfilt_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt)
{
   return (uint32_t)tmu_mipfilt <= 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt);
extern const char *v3d_desc_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_MIPFILT_LINEAR  = 0,
   V3D_TMU_MIPFILT_NEAREST = 1,
   V3D_TMU_MIPFILT_BASE    = 2,
   V3D_TMU_MIPFILT_INVALID = 4
} v3d_tmu_mipfilt_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt)
{
   return (uint32_t)tmu_mipfilt <= 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt);
extern const char *v3d_desc_tmu_mipfilt(v3d_tmu_mipfilt_t tmu_mipfilt);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_FILTERS_MIN_LIN_MAG_LIN            = 0,
   V3D_TMU_FILTERS_MIN_LIN_MAG_NEAR           = 1,
   V3D_TMU_FILTERS_MIN_NEAR_MAG_LIN           = 2,
   V3D_TMU_FILTERS_MIN_NEAR_MAG_NEAR          = 3,
   V3D_TMU_FILTERS_MIN_NEAR_MIP_NEAR_MAG_LIN  = 4,
   V3D_TMU_FILTERS_MIN_NEAR_MIP_NEAR_MAG_NEAR = 5,
   V3D_TMU_FILTERS_MIN_NEAR_MIP_LIN_MAG_LIN   = 6,
   V3D_TMU_FILTERS_MIN_NEAR_MIP_LIN_MAG_NEAR  = 7,
   V3D_TMU_FILTERS_MIN_LIN_MIP_NEAR_MAG_LIN   = 8,
   V3D_TMU_FILTERS_MIN_LIN_MIP_NEAR_MAG_NEAR  = 9,
   V3D_TMU_FILTERS_MIN_LIN_MIP_LIN_MAG_LIN    = 10,
   V3D_TMU_FILTERS_MIN_LIN_MIP_LIN_MAG_NEAR   = 11,
   V3D_TMU_FILTERS_ANISOTROPIC2               = 12,
   V3D_TMU_FILTERS_ANISOTROPIC4               = 13,
   V3D_TMU_FILTERS_ANISOTROPIC8               = 14,
   V3D_TMU_FILTERS_ANISOTROPIC16              = 15,
   V3D_TMU_FILTERS_INVALID                    = 16
} v3d_tmu_filters_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_tmu_filters(v3d_tmu_filters_t tmu_filters)
{
   return (uint32_t)tmu_filters <= 15;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_filters(v3d_tmu_filters_t tmu_filters);
extern const char *v3d_desc_tmu_filters(v3d_tmu_filters_t tmu_filters);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_LTYPE_2D       = 0,
   V3D_TMU_LTYPE_2D_ARRAY = 1,
   V3D_TMU_LTYPE_3D       = 2,
   V3D_TMU_LTYPE_CUBE_MAP = 3,
   V3D_TMU_LTYPE_1D       = 4,
   V3D_TMU_LTYPE_1D_ARRAY = 5,
   V3D_TMU_LTYPE_INVALID  = 8
} v3d_tmu_ltype_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_tmu_ltype(v3d_tmu_ltype_t tmu_ltype)
{
   return (uint32_t)tmu_ltype <= 5;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_ltype(v3d_tmu_ltype_t tmu_ltype);
extern const char *v3d_desc_tmu_ltype(v3d_tmu_ltype_t tmu_ltype);
#endif
typedef enum
{
   V3D_TMU_SWIZZLE_0       = 0,
   V3D_TMU_SWIZZLE_1       = 1,
   V3D_TMU_SWIZZLE_R       = 2,
   V3D_TMU_SWIZZLE_G       = 3,
   V3D_TMU_SWIZZLE_B       = 4,
   V3D_TMU_SWIZZLE_A       = 5,
   V3D_TMU_SWIZZLE_INVALID = 8
} v3d_tmu_swizzle_t;
static inline bool v3d_is_valid_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle)
{
   return (uint32_t)tmu_swizzle <= 5;
}
extern const char *v3d_maybe_desc_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle);
extern const char *v3d_desc_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle);
typedef enum
{
   V3D_TMU_GENERAL_TYPE_S8      = 0,
   V3D_TMU_GENERAL_TYPE_S16     = 1,
   V3D_TMU_GENERAL_TYPE_VEC2    = 2,
   V3D_TMU_GENERAL_TYPE_VEC3    = 3,
   V3D_TMU_GENERAL_TYPE_VEC4    = 4,
   V3D_TMU_GENERAL_TYPE_8       = 5,
   V3D_TMU_GENERAL_TYPE_16      = 6,
   V3D_TMU_GENERAL_TYPE_32      = 7,
   V3D_TMU_GENERAL_TYPE_INVALID = 8
} v3d_tmu_general_type_t;
static inline bool v3d_is_valid_tmu_general_type(v3d_tmu_general_type_t tmu_general_type)
{
   return (uint32_t)tmu_general_type <= 7;
}
extern const char *v3d_maybe_desc_tmu_general_type(v3d_tmu_general_type_t tmu_general_type);
extern const char *v3d_desc_tmu_general_type(v3d_tmu_general_type_t tmu_general_type);
typedef enum
{
   V3D_TMU_OP_WR_ADD_RD_PREFETCH       = 0,
   V3D_TMU_OP_WR_SUB_RD_CLEAR          = 1,
   V3D_TMU_OP_WR_XCHG_RD_FLUSH         = 2,
   V3D_TMU_OP_WR_CMPXCHG_RD_CLEAN      = 3,
   V3D_TMU_OP_WR_UMIN_RD_FULL_L1_CLEAR = 4,
   V3D_TMU_OP_WR_UMAX                  = 5,
   V3D_TMU_OP_WR_SMIN                  = 6,
   V3D_TMU_OP_WR_SMAX                  = 7,
   V3D_TMU_OP_WR_AND_RD_INC            = 8,
   V3D_TMU_OP_WR_OR_RD_DEC             = 9,
   V3D_TMU_OP_WR_XOR_RD_NOT            = 10,
   V3D_TMU_OP_REGULAR                  = 15,
   V3D_TMU_OP_INVALID                  = 16
} v3d_tmu_op_t;
extern bool v3d_is_valid_tmu_op(v3d_tmu_op_t tmu_op);
extern const char *v3d_maybe_desc_tmu_op(v3d_tmu_op_t tmu_op);
extern const char *v3d_desc_tmu_op(v3d_tmu_op_t tmu_op);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_TMU_STD_BCOL_0000    = 0,
   V3D_TMU_STD_BCOL_0001    = 1,
   V3D_TMU_STD_BCOL_1111    = 2,
   V3D_TMU_STD_BCOL_NON_STD = 7,
   V3D_TMU_STD_BCOL_INVALID = 8
} v3d_tmu_std_bcol_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern bool v3d_is_valid_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol);
extern const char *v3d_desc_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol);
#endif
typedef enum
{
   V3D_SHADER_TYPE_VERTEX      = 0,
   V3D_SHADER_TYPE_TESSC       = 1,
   V3D_SHADER_TYPE_TESSE       = 2,
   V3D_SHADER_TYPE_GEOM        = 3,
   V3D_SHADER_TYPE_FRAG        = 4,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_SHADER_TYPE_COMPUTE     = 5,
#endif
   V3D_SHADER_TYPE_USER        = 7,
   V3D_SHADER_TYPE_INVALID     = 8
} v3d_shader_type_t;
extern bool v3d_is_valid_shader_type(v3d_shader_type_t shader_type);
extern const char *v3d_maybe_desc_shader_type(v3d_shader_type_t shader_type);
extern const char *v3d_desc_shader_type(v3d_shader_type_t shader_type);
typedef enum
{
   V3D_QPU_OP_NOP              = 0,
   V3D_QPU_OP_TIDX             = 1,
   V3D_QPU_OP_EIDX             = 2,
   V3D_QPU_OP_LR               = 3,
   V3D_QPU_OP_VFLA             = 4,
   V3D_QPU_OP_VFLNA            = 5,
   V3D_QPU_OP_VFLB             = 6,
   V3D_QPU_OP_VFLNB            = 7,
   V3D_QPU_OP_FXCD             = 8,
   V3D_QPU_OP_XCD              = 9,
   V3D_QPU_OP_FYCD             = 10,
   V3D_QPU_OP_YCD              = 11,
   V3D_QPU_OP_MSF              = 12,
   V3D_QPU_OP_REVF             = 13,
   V3D_QPU_OP_IID              = 14,
   V3D_QPU_OP_SAMPID           = 15,
   V3D_QPU_OP_BARRIERID        = 16,
   V3D_QPU_OP_TMUWT            = 17,
   V3D_QPU_OP_VPMWT            = 18,
   V3D_QPU_OP_FLAFIRST         = 19,
#if V3D_HAS_FLNAFIRST
   V3D_QPU_OP_FLNAFIRST        = 20,
#endif
   V3D_QPU_OP_NOT              = 256,
   V3D_QPU_OP_NEG              = 257,
   V3D_QPU_OP_FLAPUSH          = 258,
   V3D_QPU_OP_FLBPUSH          = 259,
   V3D_QPU_OP_FLPOP            = 260,
   V3D_QPU_OP_SETMSF           = 261,
   V3D_QPU_OP_SETREVF          = 262,
   V3D_QPU_OP_VPMSETUP         = 263,
   V3D_QPU_OP_FROUND           = 264,
   V3D_QPU_OP_FTOIN            = 265,
   V3D_QPU_OP_FTRUNC           = 266,
   V3D_QPU_OP_FTOIZ            = 267,
   V3D_QPU_OP_FFLOOR           = 268,
   V3D_QPU_OP_FTOUZ            = 269,
   V3D_QPU_OP_FCEIL            = 270,
   V3D_QPU_OP_FTOC             = 271,
   V3D_QPU_OP_FDX              = 272,
   V3D_QPU_OP_FDY              = 273,
   V3D_QPU_OP_ITOF             = 274,
   V3D_QPU_OP_CLZ              = 275,
   V3D_QPU_OP_UTOF             = 276,
   V3D_QPU_OP_FMOV             = 277,
   V3D_QPU_OP_MOV              = 278,
   V3D_QPU_OP_LDVPMV_IN        = 279,
   V3D_QPU_OP_LDVPMV_OUT       = 280,
   V3D_QPU_OP_LDVPMD_IN        = 281,
   V3D_QPU_OP_LDVPMD_OUT       = 282,
   V3D_QPU_OP_LDVPMP           = 283,
   V3D_QPU_OP_TMUWRCFG         = 284,
   V3D_QPU_OP_TLBWRCFG         = 285,
   V3D_QPU_OP_VPMWRCFG         = 286,
   V3D_QPU_OP_VFMOV            = 287,
   V3D_QPU_OP_VFMOVABS         = 288,
   V3D_QPU_OP_VFMOVNEG         = 289,
   V3D_QPU_OP_VFMOVNAB         = 290,
   V3D_QPU_OP_VFABSMOV         = 291,
   V3D_QPU_OP_VFABS            = 292,
   V3D_QPU_OP_VFABSNEG         = 293,
   V3D_QPU_OP_VFABSNAB         = 294,
   V3D_QPU_OP_VFNEGMOV         = 295,
   V3D_QPU_OP_VFNEGABS         = 296,
   V3D_QPU_OP_VFNEG            = 297,
   V3D_QPU_OP_VFNEGNAB         = 298,
   V3D_QPU_OP_VFNABMOV         = 299,
   V3D_QPU_OP_VFNABABS         = 300,
   V3D_QPU_OP_VFNABNEG         = 301,
   V3D_QPU_OP_VFNABS           = 302,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_RECIP            = 303,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_RSQRT            = 304,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_EXP              = 305,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_LOG              = 306,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_SIN              = 307,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_OP_RSQRT2           = 308,
#endif
   V3D_QPU_OP_FADD             = 512,
   V3D_QPU_OP_FADDNF           = 513,
   V3D_QPU_OP_FSUB             = 514,
   V3D_QPU_OP_FMIN             = 515,
   V3D_QPU_OP_FMAX             = 516,
   V3D_QPU_OP_FCMP             = 517,
   V3D_QPU_OP_FMUL             = 518,
   V3D_QPU_OP_VFPACK           = 519,
   V3D_QPU_OP_VFMIN            = 520,
   V3D_QPU_OP_VFMAX            = 521,
   V3D_QPU_OP_VFMUL            = 522,
   V3D_QPU_OP_ADD              = 523,
   V3D_QPU_OP_SUB              = 524,
   V3D_QPU_OP_MIN              = 525,
   V3D_QPU_OP_MAX              = 526,
   V3D_QPU_OP_UMIN             = 527,
   V3D_QPU_OP_UMAX             = 528,
   V3D_QPU_OP_SMUL24           = 529,
   V3D_QPU_OP_UMUL24           = 530,
   V3D_QPU_OP_MULTOP           = 531,
   V3D_QPU_OP_VADD             = 532,
   V3D_QPU_OP_VSUB             = 533,
   V3D_QPU_OP_SHL              = 534,
   V3D_QPU_OP_SHR              = 535,
   V3D_QPU_OP_ASR              = 536,
   V3D_QPU_OP_ROR              = 537,
   V3D_QPU_OP_AND              = 538,
   V3D_QPU_OP_OR               = 539,
   V3D_QPU_OP_XOR              = 540,
   V3D_QPU_OP_STVPMV           = 541,
   V3D_QPU_OP_STVPMD           = 542,
   V3D_QPU_OP_STVPMP           = 543,
   V3D_QPU_OP_LDVPMG_IN        = 544,
   V3D_QPU_OP_LDVPMG_OUT       = 545,
   V3D_QPU_OP_INVALID          = 1024
} v3d_qpu_opcode_t;
extern bool v3d_is_valid_qpu_opcode(v3d_qpu_opcode_t qpu_opcode);
extern const char *v3d_maybe_desc_qpu_opcode(v3d_qpu_opcode_t qpu_opcode);
extern const char *v3d_desc_qpu_opcode(v3d_qpu_opcode_t qpu_opcode);
typedef enum
{
   V3D_QPU_SETF_NONE    = 0,
   V3D_QPU_SETF_PUSHZ   = 1,
   V3D_QPU_SETF_PUSHN   = 2,
   V3D_QPU_SETF_PUSHC   = 3,
   V3D_QPU_SETF_ANDZ    = 4,
   V3D_QPU_SETF_ANDNZ   = 5,
   V3D_QPU_SETF_NORNZ   = 6,
   V3D_QPU_SETF_NORZ    = 7,
   V3D_QPU_SETF_ANDN    = 8,
   V3D_QPU_SETF_ANDNN   = 9,
   V3D_QPU_SETF_NORNN   = 10,
   V3D_QPU_SETF_NORN    = 11,
   V3D_QPU_SETF_ANDC    = 12,
   V3D_QPU_SETF_ANDNC   = 13,
   V3D_QPU_SETF_NORNC   = 14,
   V3D_QPU_SETF_NORC    = 15,
   V3D_QPU_SETF_INVALID = 16
} v3d_qpu_setf_t;
static inline bool v3d_is_valid_qpu_setf(v3d_qpu_setf_t qpu_setf)
{
   return (uint32_t)qpu_setf <= 15;
}
extern const char *v3d_maybe_desc_qpu_setf(v3d_qpu_setf_t qpu_setf);
extern const char *v3d_desc_qpu_setf(v3d_qpu_setf_t qpu_setf);
typedef enum
{
   V3D_QPU_COND_IFA     = 0,
   V3D_QPU_COND_IFB     = 1,
   V3D_QPU_COND_IFNA    = 2,
   V3D_QPU_COND_IFNB    = 3,
   V3D_QPU_COND_ALWAYS  = 4,
   V3D_QPU_COND_INVALID = 8
} v3d_qpu_cond_t;
static inline bool v3d_is_valid_qpu_cond(v3d_qpu_cond_t qpu_cond)
{
   return (uint32_t)qpu_cond <= 4;
}
extern const char *v3d_maybe_desc_qpu_cond(v3d_qpu_cond_t qpu_cond);
extern const char *v3d_desc_qpu_cond(v3d_qpu_cond_t qpu_cond);
typedef enum
{
   V3D_QPU_UNPACK_32F_ABS              = 0,
   V3D_QPU_UNPACK_NONE                 = 1,
   V3D_QPU_UNPACK_16F_LOW_TO_32F       = 2,
   V3D_QPU_UNPACK_16F_HIGH_TO_32F      = 3,
   V3D_QPU_UNPACK_32F_TO_16F_REPLICATE = 4,
   V3D_QPU_UNPACK_REPLICATE_LOW_16     = 5,
   V3D_QPU_UNPACK_REPLICATE_HIGH_16    = 6,
   V3D_QPU_UNPACK_SWAP_16              = 7,
   V3D_QPU_UNPACK_INVALID              = 8
} v3d_qpu_unpack_t;
static inline bool v3d_is_valid_qpu_unpack(v3d_qpu_unpack_t qpu_unpack)
{
   return (uint32_t)qpu_unpack <= 7;
}
extern const char *v3d_maybe_desc_qpu_unpack(v3d_qpu_unpack_t qpu_unpack);
extern const char *v3d_desc_qpu_unpack(v3d_qpu_unpack_t qpu_unpack);
typedef enum
{
   V3D_QPU_PACK_NONE            = 0,
   V3D_QPU_PACK_32F_TO_16F_LOW  = 1,
   V3D_QPU_PACK_32F_TO_16F_HIGH = 2,
   V3D_QPU_PACK_INVALID         = 4
} v3d_qpu_pack_t;
static inline bool v3d_is_valid_qpu_pack(v3d_qpu_pack_t qpu_pack)
{
   return (uint32_t)qpu_pack <= 2;
}
extern const char *v3d_maybe_desc_qpu_pack(v3d_qpu_pack_t qpu_pack);
extern const char *v3d_desc_qpu_pack(v3d_qpu_pack_t qpu_pack);
typedef enum
{
   V3D_QPU_MAGIC_WADDR_R0         = 0,
   V3D_QPU_MAGIC_WADDR_R1         = 1,
   V3D_QPU_MAGIC_WADDR_R2         = 2,
   V3D_QPU_MAGIC_WADDR_R3         = 3,
   V3D_QPU_MAGIC_WADDR_R4         = 4,
   V3D_QPU_MAGIC_WADDR_R5QUAD     = 5,
   V3D_QPU_MAGIC_WADDR_NOP        = 6,
   V3D_QPU_MAGIC_WADDR_TLB        = 7,
   V3D_QPU_MAGIC_WADDR_TLBU       = 8,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMU        = 9,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_UNIFA      = 9,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUL       = 10,
#endif
   V3D_QPU_MAGIC_WADDR_TMUD       = 11,
   V3D_QPU_MAGIC_WADDR_TMUA       = 12,
   V3D_QPU_MAGIC_WADDR_TMUAU      = 13,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_VPM        = 14,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_VPMU       = 15,
#endif
   V3D_QPU_MAGIC_WADDR_SYNC       = 16,
   V3D_QPU_MAGIC_WADDR_SYNCU      = 17,
#if V3D_VER_AT_LEAST(4,2,13,0)
   V3D_QPU_MAGIC_WADDR_SYNCB      = 18,
#endif
   V3D_QPU_MAGIC_WADDR_RECIP      = 19,
   V3D_QPU_MAGIC_WADDR_RSQRT      = 20,
   V3D_QPU_MAGIC_WADDR_EXP        = 21,
   V3D_QPU_MAGIC_WADDR_LOG        = 22,
   V3D_QPU_MAGIC_WADDR_SIN        = 23,
#if V3D_VER_AT_LEAST(3,3,0,0)
   V3D_QPU_MAGIC_WADDR_RSQRT2     = 24,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUC       = 32,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUS       = 33,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUT       = 34,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUR       = 35,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUI       = 36,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUB       = 37,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUDREF    = 38,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUOFF     = 39,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUSCM     = 40,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUSFETCH  = 41,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUSLOD    = 42,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUHS      = 43,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUHSCM    = 44,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUHSFETCH = 45,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_TMUHSLOD   = 46,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_QPU_MAGIC_WADDR_R5REP      = 55,
#endif
   V3D_QPU_MAGIC_WADDR_INVALID    = 64
} v3d_qpu_magic_waddr_t;
extern bool v3d_is_valid_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr);
extern const char *v3d_maybe_desc_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr);
extern const char *v3d_desc_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr);
typedef enum
{
   V3D_QPU_IN_SOURCE_R0      = 0,
   V3D_QPU_IN_SOURCE_R1      = 1,
   V3D_QPU_IN_SOURCE_R2      = 2,
   V3D_QPU_IN_SOURCE_R3      = 3,
   V3D_QPU_IN_SOURCE_R4      = 4,
   V3D_QPU_IN_SOURCE_R5      = 5,
   V3D_QPU_IN_SOURCE_A       = 6,
   V3D_QPU_IN_SOURCE_B       = 7,
   V3D_QPU_IN_SOURCE_INVALID = 8
} v3d_qpu_in_source_t;
static inline bool v3d_is_valid_qpu_in_source(v3d_qpu_in_source_t qpu_in_source)
{
   return (uint32_t)qpu_in_source <= 7;
}
extern const char *v3d_maybe_desc_qpu_in_source(v3d_qpu_in_source_t qpu_in_source);
extern const char *v3d_desc_qpu_in_source(v3d_qpu_in_source_t qpu_in_source);
typedef enum
{
   V3D_QPU_BCOND_ALWAYS  = 0,
   V3D_QPU_BCOND_A0      = 2,
   V3D_QPU_BCOND_NA0     = 3,
   V3D_QPU_BCOND_ALLA    = 4,
   V3D_QPU_BCOND_ANYNA   = 5,
   V3D_QPU_BCOND_ANYA    = 6,
   V3D_QPU_BCOND_ALLNA   = 7,
   V3D_QPU_BCOND_INVALID = 8
} v3d_qpu_bcond_t;
extern bool v3d_is_valid_qpu_bcond(v3d_qpu_bcond_t qpu_bcond);
extern const char *v3d_maybe_desc_qpu_bcond(v3d_qpu_bcond_t qpu_bcond);
extern const char *v3d_desc_qpu_bcond(v3d_qpu_bcond_t qpu_bcond);
typedef enum
{
   V3D_QPU_MSFIGN_NONE    = 0,
   V3D_QPU_MSFIGN_PIXEL   = 1,
   V3D_QPU_MSFIGN_QUAD    = 2,
   V3D_QPU_MSFIGN_INVALID = 4
} v3d_qpu_msfign_t;
static inline bool v3d_is_valid_qpu_msfign(v3d_qpu_msfign_t qpu_msfign)
{
   return (uint32_t)qpu_msfign <= 2;
}
extern const char *v3d_maybe_desc_qpu_msfign(v3d_qpu_msfign_t qpu_msfign);
extern const char *v3d_desc_qpu_msfign(v3d_qpu_msfign_t qpu_msfign);
typedef enum
{
   V3D_QPU_BDEST_ABS      = 0,
   V3D_QPU_BDEST_REL      = 1,
   V3D_QPU_BDEST_LINK_REG = 2,
   V3D_QPU_BDEST_REGFILE  = 3,
   V3D_QPU_BDEST_INVALID  = 4
} v3d_qpu_bdest_t;
static inline bool v3d_is_valid_qpu_bdest(v3d_qpu_bdest_t qpu_bdest)
{
   return (uint32_t)qpu_bdest <= 3;
}
extern const char *v3d_maybe_desc_qpu_bdest(v3d_qpu_bdest_t qpu_bdest);
extern const char *v3d_desc_qpu_bdest(v3d_qpu_bdest_t qpu_bdest);
typedef enum
{
   V3D_QPU_LDI_MODE_32          = 0,
   V3D_QPU_LDI_MODE_EL_UNSIGNED = 1,
   V3D_QPU_LDI_MODE_EL_SIGNED   = 2,
   V3D_QPU_LDI_MODE_INVALID     = 4
} v3d_qpu_ldi_mode_t;
static inline bool v3d_is_valid_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode)
{
   return (uint32_t)qpu_ldi_mode <= 2;
}
extern const char *v3d_maybe_desc_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode);
extern const char *v3d_desc_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode);
typedef enum
{
   V3D_TSY_OP_SET_QUORUM                = 0,
   V3D_TSY_OP_INC_WAITERS               = 1,
   V3D_TSY_OP_DEC_WAITERS               = 2,
   V3D_TSY_OP_INC_QUORUM                = 3,
   V3D_TSY_OP_DEC_QUORUM                = 4,
   V3D_TSY_OP_FREE_ALL                  = 5,
   V3D_TSY_OP_RELEASE                   = 6,
   V3D_TSY_OP_ACQUIRE                   = 7,
   V3D_TSY_OP_WAIT                      = 8,
   V3D_TSY_OP_WAIT_INC                  = 9,
   V3D_TSY_OP_WAIT_CHECK                = 10,
   V3D_TSY_OP_WAIT_INC_CHECK            = 11,
   V3D_TSY_OP_WAIT_CV                   = 12,
   V3D_TSY_OP_INC_SEMAPHORE             = 13,
   V3D_TSY_OP_DEC_SEMAPHORE             = 14,
   V3D_TSY_OP_SET_QUORUM_FREE_ALL       = 15,
#if V3D_VER_AT_LEAST(4,2,13,0)
   V3D_TSY_OP_SET_QUORUM_WAIT_INC_CHECK = 16,
#endif
   V3D_TSY_OP_IN_DATA                   = 31,
   V3D_TSY_OP_INVALID                   = 32
} v3d_tsy_op_t;
extern bool v3d_is_valid_tsy_op(v3d_tsy_op_t tsy_op);
extern const char *v3d_maybe_desc_tsy_op(v3d_tsy_op_t tsy_op);
extern const char *v3d_desc_tsy_op(v3d_tsy_op_t tsy_op);
typedef enum
{
   V3D_TLB_RW_TYPE_COLOR_16   = 0,
   V3D_TLB_RW_TYPE_COLOR_32   = 1,
   V3D_TLB_RW_TYPE_Z          = 2,
   V3D_TLB_RW_TYPE_ALPHA_MASK = 3,
   V3D_TLB_RW_TYPE_INVALID    = 4
} v3d_tlb_rw_type_t;
static inline bool v3d_is_valid_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type)
{
   return (uint32_t)tlb_rw_type <= 3;
}
extern const char *v3d_maybe_desc_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type);
extern const char *v3d_desc_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type);
typedef enum
{
   V3D_TLB_RW_COLOR_TYPE_16         = 0,
   V3D_TLB_RW_COLOR_TYPE_16_SWAPPED = 1,
#if V3D_VER_AT_LEAST(4,2,13,0)
   V3D_TLB_RW_COLOR_TYPE_32         = 2,
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
   V3D_TLB_RW_COLOR_TYPE_FLOAT32    = 2,
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
   V3D_TLB_RW_COLOR_TYPE_INT32      = 3,
#endif
   V3D_TLB_RW_COLOR_TYPE_INVALID    = 4
} v3d_tlb_rw_color_type_t;
extern bool v3d_is_valid_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type);
extern const char *v3d_maybe_desc_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type);
extern const char *v3d_desc_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type);
typedef enum
{
   V3D_COMPARE_FUNC_NEVER    = 0,
   V3D_COMPARE_FUNC_LESS     = 1,
   V3D_COMPARE_FUNC_EQUAL    = 2,
   V3D_COMPARE_FUNC_LEQUAL   = 3,
   V3D_COMPARE_FUNC_GREATER  = 4,
   V3D_COMPARE_FUNC_NOTEQUAL = 5,
   V3D_COMPARE_FUNC_GEQUAL   = 6,
   V3D_COMPARE_FUNC_ALWAYS   = 7,
   V3D_COMPARE_FUNC_INVALID  = 8
} v3d_compare_func_t;
static inline bool v3d_is_valid_compare_func(v3d_compare_func_t compare_func)
{
   return (uint32_t)compare_func <= 7;
}
extern const char *v3d_maybe_desc_compare_func(v3d_compare_func_t compare_func);
extern const char *v3d_desc_compare_func(v3d_compare_func_t compare_func);
typedef enum
{
   V3D_MS_1X      = 0,
   V3D_MS_4X      = 1,
   V3D_MS_16X     = 2,
   V3D_MS_INVALID = 4
} v3d_ms_t;
static inline bool v3d_is_valid_ms(v3d_ms_t ms)
{
   return (uint32_t)ms <= 2;
}
extern const char *v3d_maybe_desc_ms(v3d_ms_t ms);
extern const char *v3d_desc_ms(v3d_ms_t ms);
typedef enum
{
   V3D_PRIM_MODE_POINTS         = 0,
   V3D_PRIM_MODE_LINES          = 1,
   V3D_PRIM_MODE_LINE_LOOP      = 2,
   V3D_PRIM_MODE_LINE_STRIP     = 3,
   V3D_PRIM_MODE_TRIS           = 4,
   V3D_PRIM_MODE_TRI_STRIP      = 5,
   V3D_PRIM_MODE_TRI_FAN        = 6,
   V3D_PRIM_MODE_LINES_ADJ      = 8,
   V3D_PRIM_MODE_LINE_STRIP_ADJ = 9,
   V3D_PRIM_MODE_TRIS_ADJ       = 10,
   V3D_PRIM_MODE_TRI_STRIP_ADJ  = 11,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_POINTS_TF      = 16,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_LINES_TF       = 17,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_LINE_LOOP_TF   = 18,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_LINE_STRIP_TF  = 19,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_TRIS_TF        = 20,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_TRI_STRIP_TF   = 21,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PRIM_MODE_TRI_FAN_TF     = 22,
#endif
   V3D_PRIM_MODE_PATCH1         = 32,
   V3D_PRIM_MODE_PATCH2         = 33,
   V3D_PRIM_MODE_PATCH3         = 34,
   V3D_PRIM_MODE_PATCH4         = 35,
   V3D_PRIM_MODE_PATCH5         = 36,
   V3D_PRIM_MODE_PATCH6         = 37,
   V3D_PRIM_MODE_PATCH7         = 38,
   V3D_PRIM_MODE_PATCH8         = 39,
   V3D_PRIM_MODE_PATCH9         = 40,
   V3D_PRIM_MODE_PATCH10        = 41,
   V3D_PRIM_MODE_PATCH11        = 42,
   V3D_PRIM_MODE_PATCH12        = 43,
   V3D_PRIM_MODE_PATCH13        = 44,
   V3D_PRIM_MODE_PATCH14        = 45,
   V3D_PRIM_MODE_PATCH15        = 46,
   V3D_PRIM_MODE_PATCH16        = 47,
   V3D_PRIM_MODE_PATCH17        = 48,
   V3D_PRIM_MODE_PATCH18        = 49,
   V3D_PRIM_MODE_PATCH19        = 50,
   V3D_PRIM_MODE_PATCH20        = 51,
   V3D_PRIM_MODE_PATCH21        = 52,
   V3D_PRIM_MODE_PATCH22        = 53,
   V3D_PRIM_MODE_PATCH23        = 54,
   V3D_PRIM_MODE_PATCH24        = 55,
   V3D_PRIM_MODE_PATCH25        = 56,
   V3D_PRIM_MODE_PATCH26        = 57,
   V3D_PRIM_MODE_PATCH27        = 58,
   V3D_PRIM_MODE_PATCH28        = 59,
   V3D_PRIM_MODE_PATCH29        = 60,
   V3D_PRIM_MODE_PATCH30        = 61,
   V3D_PRIM_MODE_PATCH31        = 62,
   V3D_PRIM_MODE_PATCH32        = 63,
   V3D_PRIM_MODE_INVALID        = 64
} v3d_prim_mode_t;
extern bool v3d_is_valid_prim_mode(v3d_prim_mode_t prim_mode);
extern const char *v3d_maybe_desc_prim_mode(v3d_prim_mode_t prim_mode);
extern const char *v3d_desc_prim_mode(v3d_prim_mode_t prim_mode);
typedef enum
{
   V3D_INDEX_TYPE_8BIT    = 0,
   V3D_INDEX_TYPE_16BIT   = 1,
   V3D_INDEX_TYPE_32BIT   = 2,
   V3D_INDEX_TYPE_INVALID = 4
} v3d_index_type_t;
static inline bool v3d_is_valid_index_type(v3d_index_type_t index_type)
{
   return (uint32_t)index_type <= 2;
}
extern const char *v3d_maybe_desc_index_type(v3d_index_type_t index_type);
extern const char *v3d_desc_index_type(v3d_index_type_t index_type);
typedef enum
{
   V3D_COV_UPDATE_NONZERO = 0,
   V3D_COV_UPDATE_ODD     = 1,
   V3D_COV_UPDATE_OR      = 2,
   V3D_COV_UPDATE_ZERO    = 3,
   V3D_COV_UPDATE_INVALID = 4
} v3d_cov_update_t;
static inline bool v3d_is_valid_cov_update(v3d_cov_update_t cov_update)
{
   return (uint32_t)cov_update <= 3;
}
extern const char *v3d_maybe_desc_cov_update(v3d_cov_update_t cov_update);
extern const char *v3d_desc_cov_update(v3d_cov_update_t cov_update);
typedef enum
{
   V3D_WIREFRAME_MODE_LINES   = 0,
   V3D_WIREFRAME_MODE_POINTS  = 1,
   V3D_WIREFRAME_MODE_INVALID = 2
} v3d_wireframe_mode_t;
static inline bool v3d_is_valid_wireframe_mode(v3d_wireframe_mode_t wireframe_mode)
{
   return (uint32_t)wireframe_mode <= 1;
}
extern const char *v3d_maybe_desc_wireframe_mode(v3d_wireframe_mode_t wireframe_mode);
extern const char *v3d_desc_wireframe_mode(v3d_wireframe_mode_t wireframe_mode);
typedef enum
{
   V3D_BLEND_EQN_ADD     = 0,
   V3D_BLEND_EQN_SUB     = 1,
   V3D_BLEND_EQN_RSUB    = 2,
   V3D_BLEND_EQN_MIN     = 3,
   V3D_BLEND_EQN_MAX     = 4,
   V3D_BLEND_EQN_MUL     = 5,
   V3D_BLEND_EQN_SCREEN  = 6,
   V3D_BLEND_EQN_DARKEN  = 7,
   V3D_BLEND_EQN_LIGHTEN = 8,
   V3D_BLEND_EQN_INVALID = 16
} v3d_blend_eqn_t;
static inline bool v3d_is_valid_blend_eqn(v3d_blend_eqn_t blend_eqn)
{
   return (uint32_t)blend_eqn <= 8;
}
extern const char *v3d_maybe_desc_blend_eqn(v3d_blend_eqn_t blend_eqn);
extern const char *v3d_desc_blend_eqn(v3d_blend_eqn_t blend_eqn);
typedef enum
{
   V3D_BLEND_MUL_ZERO           = 0,
   V3D_BLEND_MUL_ONE            = 1,
   V3D_BLEND_MUL_SRC            = 2,
   V3D_BLEND_MUL_OM_SRC         = 3,
   V3D_BLEND_MUL_DST            = 4,
   V3D_BLEND_MUL_OM_DST         = 5,
   V3D_BLEND_MUL_SRC_ALPHA      = 6,
   V3D_BLEND_MUL_OM_SRC_ALPHA   = 7,
   V3D_BLEND_MUL_DST_ALPHA      = 8,
   V3D_BLEND_MUL_OM_DST_ALPHA   = 9,
   V3D_BLEND_MUL_CONST          = 10,
   V3D_BLEND_MUL_OM_CONST       = 11,
   V3D_BLEND_MUL_CONST_ALPHA    = 12,
   V3D_BLEND_MUL_OM_CONST_ALPHA = 13,
   V3D_BLEND_MUL_SRC_ALPHA_SAT  = 14,
   V3D_BLEND_MUL_INVALID        = 16
} v3d_blend_mul_t;
static inline bool v3d_is_valid_blend_mul(v3d_blend_mul_t blend_mul)
{
   return (uint32_t)blend_mul <= 14;
}
extern const char *v3d_maybe_desc_blend_mul(v3d_blend_mul_t blend_mul);
extern const char *v3d_desc_blend_mul(v3d_blend_mul_t blend_mul);
typedef enum
{
   V3D_BLEND_VG_MODE_NORMAL      = 0,
   V3D_BLEND_VG_MODE_COVERAGE    = 1,
   V3D_BLEND_VG_MODE_COVERAGE_AM = 2,
   V3D_BLEND_VG_MODE_INVALID     = 4
} v3d_blend_vg_mode_t;
static inline bool v3d_is_valid_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode)
{
   return (uint32_t)blend_vg_mode <= 2;
}
extern const char *v3d_maybe_desc_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode);
extern const char *v3d_desc_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode);
typedef enum
{
   V3D_LDST_BUF_COLOR0               = 0,
   V3D_LDST_BUF_COLOR1               = 1,
   V3D_LDST_BUF_COLOR2               = 2,
   V3D_LDST_BUF_COLOR3               = 3,
   V3D_LDST_BUF_COLOR4               = 4,
   V3D_LDST_BUF_COLOR5               = 5,
   V3D_LDST_BUF_COLOR6               = 6,
   V3D_LDST_BUF_COLOR7               = 7,
   V3D_LDST_BUF_NONE                 = 8,
   V3D_LDST_BUF_DEPTH                = 9,
   V3D_LDST_BUF_STENCIL              = 10,
   V3D_LDST_BUF_PACKED_DEPTH_STENCIL = 11,
   V3D_LDST_BUF_INVALID              = 16
} v3d_ldst_buf_t;
static inline bool v3d_is_valid_ldst_buf(v3d_ldst_buf_t ldst_buf)
{
   return (uint32_t)ldst_buf <= 11;
}
extern const char *v3d_maybe_desc_ldst_buf(v3d_ldst_buf_t ldst_buf);
extern const char *v3d_desc_ldst_buf(v3d_ldst_buf_t ldst_buf);
typedef enum
{
   V3D_TILE_ALLOC_BLOCK_SIZE_64      = 0,
   V3D_TILE_ALLOC_BLOCK_SIZE_128     = 1,
   V3D_TILE_ALLOC_BLOCK_SIZE_256     = 2,
   V3D_TILE_ALLOC_BLOCK_SIZE_INVALID = 4
} v3d_tile_alloc_block_size_t;
static inline bool v3d_is_valid_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size)
{
   return (uint32_t)tile_alloc_block_size <= 2;
}
extern const char *v3d_maybe_desc_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size);
extern const char *v3d_desc_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size);
extern v3d_tile_alloc_block_size_t v3d_translate_tile_alloc_block_size(uint32_t x);
extern uint32_t v3d_translate_from_tile_alloc_block_size(v3d_tile_alloc_block_size_t x);
typedef enum
{
   V3D_RT_BPP_32      = 0,
   V3D_RT_BPP_64      = 1,
   V3D_RT_BPP_128     = 2,
   V3D_RT_BPP_INVALID = 4
} v3d_rt_bpp_t;
static inline bool v3d_is_valid_rt_bpp(v3d_rt_bpp_t rt_bpp)
{
   return (uint32_t)rt_bpp <= 2;
}
extern const char *v3d_maybe_desc_rt_bpp(v3d_rt_bpp_t rt_bpp);
extern const char *v3d_desc_rt_bpp(v3d_rt_bpp_t rt_bpp);
extern v3d_rt_bpp_t v3d_translate_rt_bpp(uint32_t x);
extern uint32_t v3d_translate_from_rt_bpp(v3d_rt_bpp_t x);
typedef enum
{
   V3D_RT_TYPE_8I      = 0,
   V3D_RT_TYPE_8UI     = 1,
   V3D_RT_TYPE_8       = 2,
   V3D_RT_TYPE_16I     = 4,
   V3D_RT_TYPE_16UI    = 5,
   V3D_RT_TYPE_16F     = 6,
   V3D_RT_TYPE_32I     = 8,
   V3D_RT_TYPE_32UI    = 9,
   V3D_RT_TYPE_32F     = 10,
   V3D_RT_TYPE_INVALID = 16
} v3d_rt_type_t;
extern bool v3d_is_valid_rt_type(v3d_rt_type_t rt_type);
extern const char *v3d_maybe_desc_rt_type(v3d_rt_type_t rt_type);
extern const char *v3d_desc_rt_type(v3d_rt_type_t rt_type);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_RT_CLAMP_NONE           = 0,
   V3D_RT_CLAMP_NORM           = 1,
   V3D_RT_CLAMP_POS            = 2,
#if V3D_VER_AT_LEAST(4,2,13,0)
   V3D_RT_CLAMP_INT            = 3,
#endif
   V3D_RT_CLAMP_INVALID        = 4
} v3d_rt_clamp_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern bool v3d_is_valid_rt_clamp(v3d_rt_clamp_t rt_clamp);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_rt_clamp(v3d_rt_clamp_t rt_clamp);
extern const char *v3d_desc_rt_clamp(v3d_rt_clamp_t rt_clamp);
#endif
typedef enum
{
   V3D_DEPTH_TYPE_32F     = 0,
   V3D_DEPTH_TYPE_24      = 1,
   V3D_DEPTH_TYPE_16      = 2,
   V3D_DEPTH_TYPE_INVALID = 16
} v3d_depth_type_t;
static inline bool v3d_is_valid_depth_type(v3d_depth_type_t depth_type)
{
   return (uint32_t)depth_type <= 2;
}
extern const char *v3d_maybe_desc_depth_type(v3d_depth_type_t depth_type);
extern const char *v3d_desc_depth_type(v3d_depth_type_t depth_type);
typedef enum
{
   V3D_EZ_DIRECTION_LT_LE   = 0,
   V3D_EZ_DIRECTION_GT_GE   = 1,
   V3D_EZ_DIRECTION_INVALID = 2
} v3d_ez_direction_t;
static inline bool v3d_is_valid_ez_direction(v3d_ez_direction_t ez_direction)
{
   return (uint32_t)ez_direction <= 1;
}
extern const char *v3d_maybe_desc_ez_direction(v3d_ez_direction_t ez_direction);
extern const char *v3d_desc_ez_direction(v3d_ez_direction_t ez_direction);
typedef enum
{
   V3D_DECIMATE_SAMPLE0     = 0,
   V3D_DECIMATE_4X          = 1,
   V3D_DECIMATE_16X         = 2,
   V3D_DECIMATE_ALL_SAMPLES = 3,
   V3D_DECIMATE_INVALID     = 4
} v3d_decimate_t;
static inline bool v3d_is_valid_decimate(v3d_decimate_t decimate)
{
   return (uint32_t)decimate <= 3;
}
extern const char *v3d_maybe_desc_decimate(v3d_decimate_t decimate);
extern const char *v3d_desc_decimate(v3d_decimate_t decimate);
typedef enum
{
   V3D_DITHER_OFF     = 0,
   V3D_DITHER_RGB     = 1,
   V3D_DITHER_A       = 2,
   V3D_DITHER_RGBA    = 3,
   V3D_DITHER_INVALID = 4
} v3d_dither_t;
static inline bool v3d_is_valid_dither(v3d_dither_t dither)
{
   return (uint32_t)dither <= 3;
}
extern const char *v3d_maybe_desc_dither(v3d_dither_t dither);
extern const char *v3d_desc_dither(v3d_dither_t dither);
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_DEPTH_FORMAT_32F         = 0,
   V3D_DEPTH_FORMAT_24          = 1,
   V3D_DEPTH_FORMAT_16          = 2,
   V3D_DEPTH_FORMAT_24_STENCIL8 = 3,
   V3D_DEPTH_FORMAT_INVALID     = 64
} v3d_depth_format_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_depth_format(v3d_depth_format_t depth_format)
{
   return (uint32_t)depth_format <= 3;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_depth_format(v3d_depth_format_t depth_format);
extern const char *v3d_desc_depth_format(v3d_depth_format_t depth_format);
#endif
typedef enum
{
   V3D_PIXEL_FORMAT_SRGB8_ALPHA8   = 0,
   V3D_PIXEL_FORMAT_SRGB8          = 1,
   V3D_PIXEL_FORMAT_RGB10_A2UI     = 2,
   V3D_PIXEL_FORMAT_RGB10_A2       = 3,
   V3D_PIXEL_FORMAT_A1_BGR5        = 4,
   V3D_PIXEL_FORMAT_A1_BGR5_AM     = 5,
   V3D_PIXEL_FORMAT_ABGR4          = 6,
   V3D_PIXEL_FORMAT_BGR565         = 7,
   V3D_PIXEL_FORMAT_R11F_G11F_B10F = 8,
   V3D_PIXEL_FORMAT_RGBA32F        = 9,
   V3D_PIXEL_FORMAT_RG32F          = 10,
   V3D_PIXEL_FORMAT_R32F           = 11,
   V3D_PIXEL_FORMAT_RGBA32I        = 12,
   V3D_PIXEL_FORMAT_RG32I          = 13,
   V3D_PIXEL_FORMAT_R32I           = 14,
   V3D_PIXEL_FORMAT_RGBA32UI       = 15,
   V3D_PIXEL_FORMAT_RG32UI         = 16,
   V3D_PIXEL_FORMAT_R32UI          = 17,
   V3D_PIXEL_FORMAT_RGBA16F        = 18,
   V3D_PIXEL_FORMAT_RG16F          = 19,
   V3D_PIXEL_FORMAT_R16F           = 20,
   V3D_PIXEL_FORMAT_RGBA16I        = 21,
   V3D_PIXEL_FORMAT_RG16I          = 22,
   V3D_PIXEL_FORMAT_R16I           = 23,
   V3D_PIXEL_FORMAT_RGBA16UI       = 24,
   V3D_PIXEL_FORMAT_RG16UI         = 25,
   V3D_PIXEL_FORMAT_R16UI          = 26,
   V3D_PIXEL_FORMAT_RGBA8          = 27,
   V3D_PIXEL_FORMAT_RGB8           = 28,
   V3D_PIXEL_FORMAT_RG8            = 29,
   V3D_PIXEL_FORMAT_R8             = 30,
   V3D_PIXEL_FORMAT_RGBA8I         = 31,
   V3D_PIXEL_FORMAT_RG8I           = 32,
   V3D_PIXEL_FORMAT_R8I            = 33,
   V3D_PIXEL_FORMAT_RGBA8UI        = 34,
   V3D_PIXEL_FORMAT_RG8UI          = 35,
   V3D_PIXEL_FORMAT_R8UI           = 36,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_SRGBX8         = 37,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_RGBX8          = 38,
#endif
   V3D_PIXEL_FORMAT_BSTC           = 39,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_D32F           = 40,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_D24            = 41,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_D16            = 42,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_D24S8          = 43,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_S8             = 44,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_PIXEL_FORMAT_RGB5_A1        = 45,
#endif
   V3D_PIXEL_FORMAT_INVALID        = 64
} v3d_pixel_format_t;
extern bool v3d_is_valid_pixel_format(v3d_pixel_format_t pixel_format);
extern const char *v3d_maybe_desc_pixel_format(v3d_pixel_format_t pixel_format);
extern const char *v3d_desc_pixel_format(v3d_pixel_format_t pixel_format);
typedef enum
{
   V3D_MEMORY_FORMAT_RASTER     = 0,
   V3D_MEMORY_FORMAT_LINEARTILE = 1,
   V3D_MEMORY_FORMAT_UBLINEAR_1 = 2,
   V3D_MEMORY_FORMAT_UBLINEAR_2 = 3,
   V3D_MEMORY_FORMAT_UIF_NO_XOR = 4,
   V3D_MEMORY_FORMAT_UIF_XOR    = 5,
   V3D_MEMORY_FORMAT_INVALID    = 8
} v3d_memory_format_t;
static inline bool v3d_is_valid_memory_format(v3d_memory_format_t memory_format)
{
   return (uint32_t)memory_format <= 5;
}
extern const char *v3d_maybe_desc_memory_format(v3d_memory_format_t memory_format);
extern const char *v3d_desc_memory_format(v3d_memory_format_t memory_format);
typedef enum
{
   V3D_LDST_MEMORY_FORMAT_UIF_NO_XOR = 0,
   V3D_LDST_MEMORY_FORMAT_UIF_XOR    = 1,
   V3D_LDST_MEMORY_FORMAT_INVALID    = 2
} v3d_ldst_memory_format_t;
static inline bool v3d_is_valid_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format)
{
   return (uint32_t)ldst_memory_format <= 1;
}
extern const char *v3d_maybe_desc_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format);
extern const char *v3d_desc_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format);
typedef enum
{
   V3D_STENCIL_OP_ZERO    = 0,
   V3D_STENCIL_OP_KEEP    = 1,
   V3D_STENCIL_OP_REPLACE = 2,
   V3D_STENCIL_OP_INCR    = 3,
   V3D_STENCIL_OP_DECR    = 4,
   V3D_STENCIL_OP_INVERT  = 5,
   V3D_STENCIL_OP_INCWRAP = 6,
   V3D_STENCIL_OP_DECWRAP = 7,
   V3D_STENCIL_OP_INVALID = 8
} v3d_stencil_op_t;
static inline bool v3d_is_valid_stencil_op(v3d_stencil_op_t stencil_op)
{
   return (uint32_t)stencil_op <= 7;
}
extern const char *v3d_maybe_desc_stencil_op(v3d_stencil_op_t stencil_op);
extern const char *v3d_desc_stencil_op(v3d_stencil_op_t stencil_op);
typedef enum
{
   V3D_FLAGS_ACTION_KEEP    = 0,
   V3D_FLAGS_ACTION_ZERO    = 1,
   V3D_FLAGS_ACTION_SET     = 2,
   V3D_FLAGS_ACTION_INVALID = 4
} v3d_flags_action_t;
static inline bool v3d_is_valid_flags_action(v3d_flags_action_t flags_action)
{
   return (uint32_t)flags_action <= 2;
}
extern const char *v3d_maybe_desc_flags_action(v3d_flags_action_t flags_action);
extern const char *v3d_desc_flags_action(v3d_flags_action_t flags_action);
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_BCFG_TYPE_PART1   = 0,
   V3D_BCFG_TYPE_PART2   = 1,
   V3D_BCFG_TYPE_INVALID = 2
} v3d_bcfg_type_t;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_bcfg_type(v3d_bcfg_type_t bcfg_type)
{
   return (uint32_t)bcfg_type <= 1;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_bcfg_type(v3d_bcfg_type_t bcfg_type);
extern const char *v3d_desc_bcfg_type(v3d_bcfg_type_t bcfg_type);
#endif
typedef enum
{
   V3D_RCFG_TYPE_COMMON             = 0,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_RCFG_TYPE_Z_STENCIL          = 1,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_RCFG_TYPE_SEPARATE_STENCIL   = 2,
#endif
   V3D_RCFG_TYPE_COLOR              = 3,
   V3D_RCFG_TYPE_ZS_CLEAR_VALUES    = 4,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART1 = 5,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART2 = 6,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART3 = 7,
   V3D_RCFG_TYPE_INVALID            = 16
} v3d_rcfg_type_t;
extern bool v3d_is_valid_rcfg_type(v3d_rcfg_type_t rcfg_type);
extern const char *v3d_maybe_desc_rcfg_type(v3d_rcfg_type_t rcfg_type);
extern const char *v3d_desc_rcfg_type(v3d_rcfg_type_t rcfg_type);
typedef enum
{
   V3D_SUPERTILE_ORDER_MORTON  = 0,
   V3D_SUPERTILE_ORDER_RASTER  = 1,
   V3D_SUPERTILE_ORDER_INVALID = 2
} v3d_supertile_order_t;
static inline bool v3d_is_valid_supertile_order(v3d_supertile_order_t supertile_order)
{
   return (uint32_t)supertile_order <= 1;
}
extern const char *v3d_maybe_desc_supertile_order(v3d_supertile_order_t supertile_order);
extern const char *v3d_desc_supertile_order(v3d_supertile_order_t supertile_order);
typedef enum
{
   V3D_TFU_RGBORD_RGBA_OR_RG_YUYV_OR_UV = 0,
   V3D_TFU_RGBORD_ABGR_OR_GR_VYUY_OR_VU = 1,
   V3D_TFU_RGBORD_ARGB_OR_YYUV          = 2,
   V3D_TFU_RGBORD_BGRA_OR_VUYY          = 3,
   V3D_TFU_RGBORD_INVALID               = 4
} v3d_tfu_rgbord_t;
static inline bool v3d_is_valid_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord)
{
   return (uint32_t)tfu_rgbord <= 3;
}
extern const char *v3d_maybe_desc_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord);
extern const char *v3d_desc_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord);
typedef enum
{
   V3D_TFU_IFORMAT_RASTER     = 0,
   V3D_TFU_IFORMAT_SAND_128   = 1,
   V3D_TFU_IFORMAT_SAND_256   = 2,
   V3D_TFU_IFORMAT_LINEARTILE = 11,
   V3D_TFU_IFORMAT_UBLINEAR_1 = 12,
   V3D_TFU_IFORMAT_UBLINEAR_2 = 13,
   V3D_TFU_IFORMAT_UIF_NO_XOR = 14,
   V3D_TFU_IFORMAT_UIF_XOR    = 15,
   V3D_TFU_IFORMAT_INVALID    = 16
} v3d_tfu_iformat_t;
extern bool v3d_is_valid_tfu_iformat(v3d_tfu_iformat_t tfu_iformat);
extern const char *v3d_maybe_desc_tfu_iformat(v3d_tfu_iformat_t tfu_iformat);
extern const char *v3d_desc_tfu_iformat(v3d_tfu_iformat_t tfu_iformat);
typedef enum
{
   V3D_TFU_OFORMAT_LINEARTILE = 3,
   V3D_TFU_OFORMAT_UBLINEAR_1 = 4,
   V3D_TFU_OFORMAT_UBLINEAR_2 = 5,
   V3D_TFU_OFORMAT_UIF_NO_XOR = 6,
   V3D_TFU_OFORMAT_UIF_XOR    = 7,
   V3D_TFU_OFORMAT_INVALID    = 8
} v3d_tfu_oformat_t;
extern bool v3d_is_valid_tfu_oformat(v3d_tfu_oformat_t tfu_oformat);
extern const char *v3d_maybe_desc_tfu_oformat(v3d_tfu_oformat_t tfu_oformat);
extern const char *v3d_desc_tfu_oformat(v3d_tfu_oformat_t tfu_oformat);
typedef enum
{
   V3D_L2T_FLUSH_MODE_FLUSH   = 0,
   V3D_L2T_FLUSH_MODE_CLEAR   = 1,
   V3D_L2T_FLUSH_MODE_CLEAN   = 2,
   V3D_L2T_FLUSH_MODE_INVALID = 4
} v3d_l2t_flush_mode_t;
static inline bool v3d_is_valid_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode)
{
   return (uint32_t)l2t_flush_mode <= 2;
}
extern const char *v3d_maybe_desc_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode);
extern const char *v3d_desc_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_PCF_OPERATION_ST_PRIM_COUNTS          = 0,
   V3D_PCF_OPERATION_ST_PRIM_COUNTS_AND_ZERO = 1,
   V3D_PCF_OPERATION_ST_BUF_STATE_RAW        = 4,
   V3D_PCF_OPERATION_ST_BUF_STATE_CL         = 5,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT0      = 8,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT1      = 9,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT2      = 10,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT3      = 11,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT4      = 12,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT5      = 13,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT6      = 14,
   V3D_PCF_OPERATION_LD_BUF_STATE_WAIT7      = 15,
   V3D_PCF_OPERATION_INVALID                 = 16
} v3d_pcf_operation_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern bool v3d_is_valid_pcf_operation(v3d_pcf_operation_t pcf_operation);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_pcf_operation(v3d_pcf_operation_t pcf_operation);
extern const char *v3d_desc_pcf_operation(v3d_pcf_operation_t pcf_operation);
#endif
typedef enum
{
   V3D_VRI_SIZE_HALF    = 0,
   V3D_VRI_SIZE_FULL    = 1,
   V3D_VRI_SIZE_INVALID = 16
} v3d_vri_size_t;
static inline bool v3d_is_valid_vri_size(v3d_vri_size_t vri_size)
{
   return (uint32_t)vri_size <= 1;
}
extern const char *v3d_maybe_desc_vri_size(v3d_vri_size_t vri_size);
extern const char *v3d_desc_vri_size(v3d_vri_size_t vri_size);
typedef enum
{
   V3D_TLB_SIZE_QUARTER = 0,
   V3D_TLB_SIZE_HALF    = 1,
   V3D_TLB_SIZE_FULL    = 2,
   V3D_TLB_SIZE_INVALID = 16
} v3d_tlb_size_t;
static inline bool v3d_is_valid_tlb_size(v3d_tlb_size_t tlb_size)
{
   return (uint32_t)tlb_size <= 2;
}
extern const char *v3d_maybe_desc_tlb_size(v3d_tlb_size_t tlb_size);
extern const char *v3d_desc_tlb_size(v3d_tlb_size_t tlb_size);
typedef enum
{
   V3D_IUC_SIZE_1KB     = 6,
   V3D_IUC_SIZE_2KB     = 7,
   V3D_IUC_SIZE_4KB     = 8,
   V3D_IUC_SIZE_INVALID = 16
} v3d_iuc_size_t;
extern bool v3d_is_valid_iuc_size(v3d_iuc_size_t iuc_size);
extern const char *v3d_maybe_desc_iuc_size(v3d_iuc_size_t iuc_size);
extern const char *v3d_desc_iuc_size(v3d_iuc_size_t iuc_size);
typedef enum
{
   V3D_IP_RECIPIENT_NONE     = 0,
   V3D_IP_RECIPIENT_7260     = 1,
   V3D_IP_RECIPIENT_TAHITI_B = 7,
   V3D_IP_RECIPIENT_ARUBA    = 9,
   V3D_IP_RECIPIENT_TAHITI_P = 10,
   V3D_IP_RECIPIENT_BCG      = 11,
   V3D_IP_RECIPIENT_INVALID  = 256
} v3d_ip_recipient_t;
extern bool v3d_is_valid_ip_recipient(v3d_ip_recipient_t ip_recipient);
extern const char *v3d_maybe_desc_ip_recipient(v3d_ip_recipient_t ip_recipient);
extern const char *v3d_desc_ip_recipient(v3d_ip_recipient_t ip_recipient);
typedef enum
{
   V3D_CTSUBSRUN_STOPPED_AT_END   = 0,
   V3D_CTSUBSRUN_STOPPED_AT_HALT  = 1,
   V3D_CTSUBSRUN_RUNNING_NORMALLY = 2,
   V3D_CTSUBSRUN_STALLED          = 3,
   V3D_CTSUBSRUN_INVALID          = 4
} v3d_ctsubsrun_t;
static inline bool v3d_is_valid_ctsubsrun(v3d_ctsubsrun_t ctsubsrun)
{
   return (uint32_t)ctsubsrun <= 3;
}
extern const char *v3d_maybe_desc_ctsubsrun(v3d_ctsubsrun_t ctsubsrun);
extern const char *v3d_desc_ctsubsrun(v3d_ctsubsrun_t ctsubsrun);
typedef enum
{
   V3D_CL_COMPR_TYPE_C0           = 0,
   V3D_CL_COMPR_TYPE_C1           = 1,
   V3D_CL_COMPR_TYPE_C2           = 2,
   V3D_CL_COMPR_TYPE_C3           = 3,
   V3D_CL_COMPR_TYPE_C4           = 4,
   V3D_CL_COMPR_TYPE_C5           = 5,
   V3D_CL_COMPR_TYPE_C6           = 6,
   V3D_CL_COMPR_TYPE_IID8         = 7,
   V3D_CL_COMPR_TYPE_IID32        = 8,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_COMPR_TYPE_REL_BRANCH   = 9,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_COMPR_TYPE_BRANCH       = 10,
#endif
   V3D_CL_COMPR_TYPE_ESCAPE       = 11,
   V3D_CL_COMPR_TYPE_NOT_COMMON   = 12,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_COMPR_TYPE_PRIM_ID8     = 13,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_COMPR_TYPE_PRIM_ID32    = 14,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_COMPR_TYPE_CLIPPED_PRIM = 15,
#endif
   V3D_CL_COMPR_TYPE_INVALID      = 16
} v3d_cl_compr_type_t;
extern bool v3d_is_valid_cl_compr_type(v3d_cl_compr_type_t cl_compr_type);
extern const char *v3d_maybe_desc_cl_compr_type(v3d_cl_compr_type_t cl_compr_type);
extern const char *v3d_desc_cl_compr_type(v3d_cl_compr_type_t cl_compr_type);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
   V3D_CL_COMPR_SERIAL_TYPE_C0           = 0,
   V3D_CL_COMPR_SERIAL_TYPE_C1           = 1,
   V3D_CL_COMPR_SERIAL_TYPE_C2           = 2,
   V3D_CL_COMPR_SERIAL_TYPE_C3           = 3,
   V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM = 4,
   V3D_CL_COMPR_SERIAL_TYPE_TG_MODE      = 5,
   V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL    = 6,
   V3D_CL_COMPR_SERIAL_TYPE_INVALID      = 16
} v3d_cl_compr_serial_type_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline bool v3d_is_valid_cl_compr_serial_type(v3d_cl_compr_serial_type_t cl_compr_serial_type)
{
   return (uint32_t)cl_compr_serial_type <= 6;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_cl_compr_serial_type(v3d_cl_compr_serial_type_t cl_compr_serial_type);
extern const char *v3d_desc_cl_compr_serial_type(v3d_cl_compr_serial_type_t cl_compr_serial_type);
#endif
typedef enum
{
   V3D_CL_VPM_PACK_X16     = 0,
   V3D_CL_VPM_PACK_X8      = 1,
   V3D_CL_VPM_PACK_X4      = 2,
   V3D_CL_VPM_PACK_INVALID = 4
} v3d_cl_vpm_pack_t;
static inline bool v3d_is_valid_cl_vpm_pack(v3d_cl_vpm_pack_t cl_vpm_pack)
{
   return (uint32_t)cl_vpm_pack <= 2;
}
extern const char *v3d_maybe_desc_cl_vpm_pack(v3d_cl_vpm_pack_t cl_vpm_pack);
extern const char *v3d_desc_cl_vpm_pack(v3d_cl_vpm_pack_t cl_vpm_pack);
typedef enum
{
   V3D_CL_TESS_TYPE_TRIANGLE = 0,
   V3D_CL_TESS_TYPE_QUAD     = 1,
   V3D_CL_TESS_TYPE_ISOLINES = 2,
   V3D_CL_TESS_TYPE_INVALID  = 4
} v3d_cl_tess_type_t;
static inline bool v3d_is_valid_cl_tess_type(v3d_cl_tess_type_t cl_tess_type)
{
   return (uint32_t)cl_tess_type <= 2;
}
extern const char *v3d_maybe_desc_cl_tess_type(v3d_cl_tess_type_t cl_tess_type);
extern const char *v3d_desc_cl_tess_type(v3d_cl_tess_type_t cl_tess_type);
typedef enum
{
   V3D_CL_TESS_EDGE_SPACING_EQUAL           = 0,
   V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_EVEN = 1,
   V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_ODD  = 2,
   V3D_CL_TESS_EDGE_SPACING_INVALID         = 4
} v3d_cl_tess_edge_spacing_t;
static inline bool v3d_is_valid_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing)
{
   return (uint32_t)cl_tess_edge_spacing <= 2;
}
extern const char *v3d_maybe_desc_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing);
extern const char *v3d_desc_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing);
typedef enum
{
   V3D_CL_TCS_BATCH_FLUSH_MODE_FULLY_PACKED            = 0,
   V3D_CL_TCS_BATCH_FLUSH_MODE_SINGLE_PATCH            = 1,
   V3D_CL_TCS_BATCH_FLUSH_MODE_PACKED_COMPLETE_PATCHES = 2,
   V3D_CL_TCS_BATCH_FLUSH_MODE_INVALID                 = 4
} v3d_cl_tcs_batch_flush_mode_t;
static inline bool v3d_is_valid_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode)
{
   return (uint32_t)cl_tcs_batch_flush_mode <= 2;
}
extern const char *v3d_maybe_desc_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode);
extern const char *v3d_desc_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode);
typedef enum
{
   V3D_CL_GEOM_PRIM_TYPE_POINTS         = 0,
   V3D_CL_GEOM_PRIM_TYPE_LINE_STRIP     = 1,
   V3D_CL_GEOM_PRIM_TYPE_TRIANGLE_STRIP = 2,
   V3D_CL_GEOM_PRIM_TYPE_INVALID        = 4
} v3d_cl_geom_prim_type_t;
static inline bool v3d_is_valid_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type)
{
   return (uint32_t)cl_geom_prim_type <= 2;
}
extern const char *v3d_maybe_desc_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type);
extern const char *v3d_desc_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type);
typedef enum
{
   V3D_CL_GEOM_OUTPUT_PACK_X16     = 0,
   V3D_CL_GEOM_OUTPUT_PACK_X8      = 1,
   V3D_CL_GEOM_OUTPUT_PACK_X4      = 2,
   V3D_CL_GEOM_OUTPUT_PACK_X1      = 3,
   V3D_CL_GEOM_OUTPUT_PACK_INVALID = 4
} v3d_cl_geom_output_pack_t;
static inline bool v3d_is_valid_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack)
{
   return (uint32_t)cl_geom_output_pack <= 3;
}
extern const char *v3d_maybe_desc_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack);
extern const char *v3d_desc_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack);
typedef enum
{
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_21 = 0,
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_02 = 1,
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_10 = 2,
   V3D_TRI_IND_REUSE_INVALID           = 4
} v3d_tri_ind_reuse_t;
static inline bool v3d_is_valid_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse)
{
   return (uint32_t)tri_ind_reuse <= 2;
}
extern const char *v3d_maybe_desc_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse);
extern const char *v3d_desc_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse);
typedef enum
{
   V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_1 = 0,
   V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_0 = 1,
   V3D_LINE_IND_REUSE_INVALID         = 4
} v3d_line_ind_reuse_t;
static inline bool v3d_is_valid_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse)
{
   return (uint32_t)line_ind_reuse <= 1;
}
extern const char *v3d_maybe_desc_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse);
extern const char *v3d_desc_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse);
#if V3D_VER_AT_LEAST(3,3,0,0)
typedef enum
{
   V3D_DRAM_MAP_VERSION_2       = 0,
   V3D_DRAM_MAP_VERSION_5       = 1,
   V3D_DRAM_MAP_VERSION_8       = 2,
   V3D_DRAM_MAP_VERSION_INVALID = 16
} v3d_dram_map_version_t;
#endif
#if V3D_VER_AT_LEAST(3,3,0,0)
static inline bool v3d_is_valid_dram_map_version(v3d_dram_map_version_t dram_map_version)
{
   return (uint32_t)dram_map_version <= 2;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0)
extern const char *v3d_maybe_desc_dram_map_version(v3d_dram_map_version_t dram_map_version);
extern const char *v3d_desc_dram_map_version(v3d_dram_map_version_t dram_map_version);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0)
extern v3d_dram_map_version_t v3d_translate_dram_map_version(uint32_t x);
extern uint32_t v3d_translate_from_dram_map_version(v3d_dram_map_version_t x);
#endif
typedef enum
{
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_L2T                                     = 0,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_PTB                                     = 1,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_PSE                                     = 2,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_TLB                                     = 3,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_CLE                                     = 4,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_TFU                                     = 5,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_MMU                                     = 6,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_AXI_MASTER_ID_GMP                                     = 7,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_L2T                                     = 0,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_CLE                                     = 1,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_PTB                                     = 2,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_PSE                                     = 3,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_TLB                                     = 4,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_GMP                                     = 7,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0) && V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_TFU                                     = 8,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_L2C                                     = 0,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_CLE                                     = 1,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_PTB                                     = 2,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_PSE                                     = 3,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_VCD                                     = 4,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_VDW                                     = 5,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_L2T                                     = 6,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_TLB                                     = 7,
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_AXI_MASTER_ID_TFU                                     = 8,
#endif
   V3D_AXI_MASTER_ID_INVALID                                 = 16
} v3d_axi_master_id_t;
extern bool v3d_is_valid_axi_master_id(v3d_axi_master_id_t axi_master_id);
extern const char *v3d_maybe_desc_axi_master_id(v3d_axi_master_id_t axi_master_id);
extern const char *v3d_desc_axi_master_id(v3d_axi_master_id_t axi_master_id);
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef enum
{
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_TMU        = 0,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_VCD        = 1,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_TMU_CONFIG = 2,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL0_CACHE  = 3,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL1_CACHE  = 4,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL2_CACHE  = 5,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_TMU        = 0,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_CLE        = 1,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_VCD        = 2,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_TMU_CONFIG = 3,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL0_CACHE  = 4,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL1_CACHE  = 5,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_L2T_MASTER_ID_SL2_CACHE  = 6,
#endif
   V3D_L2T_MASTER_ID_INVALID    = 16
} v3d_l2t_master_id_t;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern bool v3d_is_valid_l2t_master_id(v3d_l2t_master_id_t l2t_master_id);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern const char *v3d_maybe_desc_l2t_master_id(v3d_l2t_master_id_t l2t_master_id);
extern const char *v3d_desc_l2t_master_id(v3d_l2t_master_id_t l2t_master_id);
#endif
typedef enum
{
   V3D_CL_HALT                               = 0,
   V3D_CL_NOP                                = 1,
   V3D_CL_FLUSH                              = 4,
   V3D_CL_FLUSH_ALL_STATE                    = 5,
   V3D_CL_START_TILE_BINNING                 = 6,
   V3D_CL_INCR_SEMAPHORE                     = 7,
   V3D_CL_WAIT_SEMAPHORE                     = 8,
   V3D_CL_WAIT_PREV_FRAME                    = 9,
   V3D_CL_ENABLE_Z_ONLY                      = 10,
   V3D_CL_DISABLE_Z_ONLY                     = 11,
   V3D_CL_END_Z_ONLY                         = 12,
   V3D_CL_END_RENDER                         = 13,
   V3D_CL_WAIT_TRANSFORM_FEEDBACK            = 14,
   V3D_CL_BRANCH_SUB_AUTOCHAIN               = 15,
   V3D_CL_BRANCH                             = 16,
   V3D_CL_BRANCH_SUB                         = 17,
   V3D_CL_RETURN                             = 18,
   V3D_CL_CLEAR_VCD_CACHE                    = 19,
   V3D_CL_GENERIC_TILE_LIST                  = 20,
   V3D_CL_BRANCH_IMPLICIT_TILE               = 21,
   V3D_CL_BRANCH_EXPLICIT_SUPERTILE          = 22,
   V3D_CL_SUPERTILE_COORDS                   = 23,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLEAR                              = 25,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_END_LOADS                          = 26,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_END_TILE                           = 27,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_STORE                              = 29,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_LOAD                               = 30,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_STORE_SUBSAMPLE                    = 24,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_STORE_SUBSAMPLE_EX                 = 25,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_LOAD                               = 26,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_END_TILE                           = 27,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_STORE_GENERAL                      = 29,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_LOAD_GENERAL                       = 30,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TF_DRAW_FLUSH_AND_COUNT            = 31,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDEXED_PRIM_LIST                  = 32,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDEXED_PRIM_LIST                  = 32,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDIRECT_INDEXED_PRIM_LIST         = 33,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDIRECT_INDEXED_PRIM_LIST         = 33,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDEXED_INSTANCED_PRIM_LIST        = 34,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDEXED_INSTANCED_PRIM_LIST        = 34,
#endif
   V3D_CL_VERTEX_ARRAY_PRIMS                 = 36,
   V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS        = 37,
   V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS       = 38,
   V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS = 39,
   V3D_CL_BASE_VERTEX_BASE_INSTANCE          = 43,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDEX_BUFFER_SETUP                 = 44,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_INDIRECT_PRIMITIVE_LIMITS          = 44,
#endif
   V3D_CL_VG_COORD_ARRAY_PRIMS               = 41,
   V3D_CL_VG_INLINE_PRIMS                    = 42,
   V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO      = 48,
   V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID   = 49,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLIPPED_PRIM_IID_ZERO              = 52,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLIPPED_PRIM_CURRENT_IID           = 53,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_SET_INSTANCE_ID                    = 54,
#endif
   V3D_CL_SET_PRIMITIVE_ID                   = 55,
   V3D_CL_PRIM_LIST_FORMAT                   = 56,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_SERIAL_NUMBER_LIST_START           = 57,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_GL_SHADER                          = 64,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_NV_SHADER                          = 68,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_GL_SHADER                          = 64,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_GL_T_SHADER                        = 65,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_GL_G_SHADER                        = 66,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_GL_TG_SHADER                       = 67,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_NV_SHADER                          = 68,
#endif
   V3D_CL_VG_SHADER                          = 69,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VG_INLINE_SHADER                   = 70,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VG_INLINE_SHADER                   = 70,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VCM_CACHE_SIZE                     = 71,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_PRIM_COUNTS_FEEDBACK               = 72,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TRANSFORM_FEEDBACK_BUFFER          = 73,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TRANSFORM_FEEDBACK_SPECS           = 74,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VCM_CACHE_SIZE                     = 73,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TRANSFORM_FEEDBACK_ENABLE          = 74,
#endif
   V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA      = 75,
   V3D_CL_CLEAR_SLICE_CACHES                 = 76,
   V3D_CL_FLUSH_L2T                          = 77,
#if !V3D_VER_AT_LEAST(3,3,0,0)
   V3D_CL_CLEAR_L2C                          = 78,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLEAN_L1TD_DEFERRED                = 78,
#endif
   V3D_CL_STENCIL_CFG                        = 80,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_BLEND_CFG                          = 84,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_BLEND_ENABLES                      = 83,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_BLEND_CFG                          = 84,
#endif
   V3D_CL_BLEND_CCOLOR                       = 86,
   V3D_CL_COLOR_WMASKS                       = 87,
   V3D_CL_ZERO_ALL_CENTROID_FLAGS            = 88,
   V3D_CL_ZERO_ALL_FLATSHADE_FLAGS           = 97,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_ZERO_ALL_NOPERSPECTIVE_FLAGS       = 99,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CENTROID_FLAGS                     = 89,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_FLATSHADE_FLAGS                    = 98,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CENTROID_FLAGS                     = 89,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_FLATSHADE_FLAGS                    = 98,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_NOPERSPECTIVE_FLAGS                = 100,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_SAMPLE_STATE                       = 91,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_SAMPLE_STATE                       = 91,
#endif
   V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE     = 92,
   V3D_CL_CFG_BITS                           = 96,
   V3D_CL_POINT_SIZE                         = 104,
   V3D_CL_LINE_WIDTH                         = 105,
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_DEPTH_OFFSET                       = 106,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_DEPTH_OFFSET                       = 106,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLIP                               = 107,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VIEWPORT_OFFSET                    = 108,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_CLIP                               = 107,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_VIEWPORT_OFFSET                    = 108,
#endif
   V3D_CL_CLIPZ                              = 109,
   V3D_CL_CLIPPER_XY                         = 110,
   V3D_CL_CLIPPER_Z                          = 111,
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_NUM_LAYERS                         = 119,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TILE_BINNING_MODE_CFG              = 120,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TILE_BINNING_MODE_CFG              = 120,
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TILE_RENDERING_MODE_CFG            = 121,
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
   V3D_CL_TILE_RENDERING_MODE_CFG            = 121,
#endif
   V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG  = 122,
   V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE = 123,
   V3D_CL_TILE_COORDS                        = 124,
   V3D_CL_IMPLICIT_TILE_COORDS               = 125,
   V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE       = 126,
   V3D_CL_INVALID                            = 256
} v3d_cl_opcode_t;
extern bool v3d_is_valid_cl_opcode(v3d_cl_opcode_t cl_opcode);
extern const char *v3d_maybe_desc_cl_opcode(v3d_cl_opcode_t cl_opcode);
extern const char *v3d_desc_cl_opcode(v3d_cl_opcode_t cl_opcode);
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_threading_t threading;
   bool propagate_nans;
   v3d_addr_t addr;
   v3d_addr_t unifs_addr;
} V3D_SHADER_ARGS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_threading_t threading;
   bool single_seg;
   bool propagate_nans;
   v3d_addr_t addr;
   v3d_addr_t unifs_addr;
} V3D_SHADER_ARGS_T;
#endif
typedef struct
{
   uint32_t size_sectors;
   v3d_cl_vpm_pack_t pack;
} V3D_SEG_ARGS_T;
typedef struct
{
   uint32_t sectors;
   uint32_t min_extra_req;
} V3D_OUT_SEG_ARGS_T;
typedef struct
{
   uint32_t sectors;
   uint32_t min_req;
} V3D_IN_SEG_ARGS_T;
typedef struct
{
   uint32_t size_sectors;
   v3d_cl_geom_output_pack_t pack;
} V3D_GEOM_SEG_ARGS_T;
typedef struct
{
   v3d_cl_tcs_batch_flush_mode_t tcs_batch_flush;
   uint32_t per_patch_depth;
   V3D_SEG_ARGS_T tcs_output;
   V3D_SEG_ARGS_T tes_output;
   V3D_GEOM_SEG_ARGS_T geom_output;
   uint32_t max_patches_per_tcs_batch;
   uint32_t max_extra_vert_segs_per_tcs_batch;
   uint32_t min_tcs_segs;
   uint32_t min_per_patch_segs;
   uint32_t max_patches_per_tes_batch;
   uint32_t max_extra_vert_segs_per_tes_batch;
   uint32_t max_tcs_segs_per_tes_batch;
   uint32_t min_tes_segs;
   uint32_t max_extra_vert_segs_per_gs_batch;
   uint32_t min_gs_segs;
} V3D_VPM_CFG_TG_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_rt_bpp_t bpp;
   v3d_rt_type_t type;
} V3D_RT_FORMAT_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_rt_bpp_t bpp;
   v3d_rt_type_t type;
   v3d_rt_clamp_t clamp;
} V3D_RT_FORMAT_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool point_size_included;
   bool clipping;
   bool cs_vertex_id;
   bool cs_instance_id;
   bool vs_vertex_id;
   bool vs_instance_id;
   bool z_write;
   bool no_ez;
   bool cs_separate_blocks;
   bool vs_separate_blocks;
   bool fs_needs_w;
   bool scb_wait_on_first_thrsw;
   bool disable_scb;
   uint32_t num_varys;
   uint32_t cs_output_size;
   uint32_t cs_input_size;
   uint32_t vs_output_size;
   uint32_t vs_input_size;
   v3d_addr_t defaults;
   V3D_SHADER_ARGS_T fs;
   V3D_SHADER_ARGS_T vs;
   V3D_SHADER_ARGS_T cs;
} V3D_SHADREC_GL_MAIN_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_HAS_IMPLICIT_ATTR_DEFAULTS
typedef struct
{
   bool point_size_included;
   bool clipping;
   bool cs_vertex_id;
   bool cs_instance_id;
   bool cs_baseinstance;
   bool vs_vertex_id;
   bool vs_instance_id;
   bool vs_baseinstance;
   bool z_write;
   bool no_ez;
   bool cs_separate_blocks;
   bool vs_separate_blocks;
   bool fs_needs_w;
   bool sample_rate_shading;
   bool prim_id_used;
   bool prim_id_to_fs;
   bool disable_scb;
   bool scb_wait_on_first_thrsw;
   bool disable_implicit_varys;
   bool no_prim_pack;
   uint32_t num_varys;
   V3D_OUT_SEG_ARGS_T cs_output_size;
   V3D_IN_SEG_ARGS_T cs_input_size;
   V3D_OUT_SEG_ARGS_T vs_output_size;
   V3D_IN_SEG_ARGS_T vs_input_size;
   v3d_addr_t defaults;
   V3D_SHADER_ARGS_T fs;
   V3D_SHADER_ARGS_T vs;
   V3D_SHADER_ARGS_T cs;
} V3D_SHADREC_GL_MAIN_T;
#endif
#if V3D_HAS_IMPLICIT_ATTR_DEFAULTS
typedef struct
{
   bool point_size_included;
   bool clipping;
   bool cs_vertex_id;
   bool cs_instance_id;
   bool cs_baseinstance;
   bool vs_vertex_id;
   bool vs_instance_id;
   bool vs_baseinstance;
   bool z_write;
   bool no_ez;
   bool cs_separate_blocks;
   bool vs_separate_blocks;
   bool fs_needs_w;
   bool sample_rate_shading;
   bool prim_id_used;
   bool prim_id_to_fs;
   bool disable_scb;
   bool scb_wait_on_first_thrsw;
   bool disable_implicit_varys;
   bool no_prim_pack;
   uint32_t num_varys;
   V3D_OUT_SEG_ARGS_T cs_output_size;
   V3D_IN_SEG_ARGS_T cs_input_size;
   V3D_OUT_SEG_ARGS_T vs_output_size;
   V3D_IN_SEG_ARGS_T vs_input_size;
   V3D_SHADER_ARGS_T fs;
   V3D_SHADER_ARGS_T vs;
   V3D_SHADER_ARGS_T cs;
} V3D_SHADREC_GL_MAIN_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T gs_bin;
   V3D_SHADER_ARGS_T gs_render;
} V3D_SHADREC_GL_GEOM_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T tcs_bin;
   V3D_SHADER_ARGS_T tcs_render;
   V3D_SHADER_ARGS_T tes_bin;
   V3D_SHADER_ARGS_T tes_render;
} V3D_SHADREC_GL_TESS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_cl_tess_type_t tess_type;
   bool tess_point_mode;
   v3d_cl_tess_edge_spacing_t tess_edge_spacing;
   bool tess_clockwise;
   bool tcs_bypass;
   bool tcs_bypass_render;
   bool tes_no_inp_verts;
   uint32_t num_tcs_invocations;
   v3d_cl_geom_prim_type_t geom_output;
   uint32_t geom_num_instances;
   V3D_VPM_CFG_TG_T bin;
   V3D_VPM_CFG_TG_T render;
} V3D_SHADREC_GL_TESS_OR_GEOM_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_addr_t addr;
   uint32_t size;
   v3d_attr_type_t type;
   bool signed_int;
   bool normalised_int;
   bool read_as_int;
   uint32_t cs_num_reads;
   uint32_t vs_num_reads;
   uint32_t divisor;
   uint32_t stride;
   uint32_t max_index;
} V3D_SHADREC_GL_ATTR_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_addr_t addr;
   uint32_t size;
   v3d_attr_type_t type;
   bool signed_int;
   bool normalised_int;
   bool read_as_int;
   uint32_t cs_num_reads;
   uint32_t vs_num_reads;
   uint32_t divisor;
   uint32_t stride;
} V3D_SHADREC_GL_ATTR_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_SHADREC_VG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_SHADREC_VG_T;
#endif
typedef struct
{
   uint32_t unif;
} V3D_UNIF_RAW_T;
typedef struct
{
   v3d_addr_t addr;
} V3D_UNIF_ADDR_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tmu_type_t type;
   bool srgb;
   bool pix_mask;
   uint32_t width;
   uint32_t height;
} V3D_TMU_PARAM0_CFG0_T;
typedef struct
{
   v3d_tmu_ltype_t ltype;
   bool fetch;
   bool gather;
   bool bias;
   bool bslod;
   bool shadow;
   v3d_tmu_wrap_t wrap_s;
   v3d_tmu_wrap_t wrap_t;
   v3d_tmu_wrap_t wrap_r;
   int32_t tex_off_s;
   int32_t tex_off_t;
   int32_t tex_off_r;
   bool pix_mask;
} V3D_TMU_PARAM0_CFG1_T;
typedef union
{
   V3D_TMU_PARAM0_CFG0_T cfg0;
   V3D_TMU_PARAM0_CFG1_T cfg1;
} V3D_TMU_PARAM0_U_T;
typedef struct
{
   uint32_t cfg;
   V3D_TMU_PARAM0_U_T u;
} V3D_TMU_PARAM0_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tmu_wrap_cfg0_t wrap_s;
   v3d_tmu_wrap_cfg0_t wrap_t;
   v3d_tmu_filters_t filters;
   bool bslod;
   v3d_addr_t base;
} V3D_TMU_PARAM1_CFG0_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool word0_en;
   bool word1_en;
   bool word2_en;
   bool word3_en;
   bool unnorm;
   v3d_addr_t ts_base;
} V3D_TMU_PARAM1_CFG1_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef bool V3D_TMU_PARAM0_WORD_EN_T[4];
typedef struct
{
   V3D_TMU_PARAM0_WORD_EN_T word_en;
   v3d_addr_t tex_state_addr;
} V3D_TMU_PARAM0_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool output_32;
   bool unnorm;
   bool pix_mask;
   v3d_addr_t sampler_addr;
} V3D_TMU_PARAM1_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
typedef int32_t V3D_TMU_PARAM2_OFFSETS_T[3];
typedef struct
{
   bool tmuoff_4x;
   bool bslod;
   uint32_t sample_num;
   uint32_t gather_comp;
   bool gather;
   V3D_TMU_PARAM2_OFFSETS_T offsets;
   v3d_tmu_op_t op;
} V3D_TMU_PARAM2_T;
#endif
#if V3D_VER_AT_LEAST(4,2,13,0) && !V3D_HAS_SAMPLER_LOD_DIS
typedef int32_t V3D_TMU_PARAM2_OFFSETS_T[3];
typedef struct
{
   bool tmuoff_4x;
   bool bslod;
   uint32_t sample_num;
   uint32_t gather_comp;
   bool gather;
   V3D_TMU_PARAM2_OFFSETS_T offsets;
   v3d_tmu_op_t op;
   bool lod_query;
} V3D_TMU_PARAM2_T;
#endif
#if V3D_HAS_SAMPLER_LOD_DIS
typedef int32_t V3D_TMU_PARAM2_OFFSETS_T[3];
typedef struct
{
   bool tmuoff_4x;
   bool bslod;
   uint32_t sample_num;
   bool sampler_lod_dis;
   uint32_t gather_comp;
   bool gather;
   V3D_TMU_PARAM2_OFFSETS_T offsets;
   v3d_tmu_op_t op;
   bool lod_query;
} V3D_TMU_PARAM2_T;
#endif
typedef struct
{
   v3d_tmu_general_type_t type;
   v3d_tmu_op_t op;
   bool per_pixel_enable;
} V3D_TMU_GENERAL_CONFIG_T;
typedef struct
{
   v3d_tsy_op_t op;
   uint32_t gfxh_1370_do_not_change;
} V3D_TSY_CONFIG_T;
#if V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   uint32_t num_words;
   bool no_swap;
   bool all_samples_same_data;
   uint32_t rt;
} V3D_TLB_CONFIG_COLOR_16_T;
typedef struct
{
   uint32_t num_words;
   bool all_samples_same_data;
   uint32_t rt;
} V3D_TLB_CONFIG_COLOR_32_T;
typedef struct
{
   bool all_samples_same_data;
   bool use_written_z;
} V3D_TLB_CONFIG_Z_T;
typedef struct
{
   bool all_samples_same_data;
} V3D_TLB_CONFIG_ALPHA_MASK_T;
typedef union
{
   V3D_TLB_CONFIG_COLOR_16_T color_16;
   V3D_TLB_CONFIG_COLOR_32_T color_32;
   V3D_TLB_CONFIG_Z_T z;
   V3D_TLB_CONFIG_ALPHA_MASK_T alpha_mask;
} V3D_TLB_CONFIG_U_T;
typedef struct
{
   v3d_tlb_rw_type_t type;
   V3D_TLB_CONFIG_U_T u;
} V3D_TLB_CONFIG_T;
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   uint32_t num_words;
   bool no_swap;
   bool all_samples_same_data;
   uint32_t rt;
} V3D_TLB_CONFIG_COLOR_16_T;
typedef struct
{
   uint32_t num_words;
   bool all_samples_same_data;
   uint32_t rt;
   bool as_int;
} V3D_TLB_CONFIG_COLOR_32_T;
typedef struct
{
   bool use_written_z;
} V3D_TLB_CONFIG_Z_T;
typedef union
{
   V3D_TLB_CONFIG_COLOR_16_T color_16;
   V3D_TLB_CONFIG_COLOR_32_T color_32;
   V3D_TLB_CONFIG_Z_T z;
} V3D_TLB_CONFIG_U_T;
typedef struct
{
   v3d_tlb_rw_type_t type;
   V3D_TLB_CONFIG_U_T u;
} V3D_TLB_CONFIG_T;
#endif
typedef struct
{
   v3d_qpu_bcond_t bcond;
   v3d_qpu_msfign_t msfign;
   bool ulr;
   int32_t rel_i_addr;
   int32_t rel_u_addr;
} V3D_UNIF_BRANCH_T;
#if !V3D_VER_AT_LEAST(3,3,0,0)
typedef v3d_tmu_swizzle_t V3D_TMU_INDIRECT_SWIZZLES_T[4];
typedef struct
{
   v3d_tmu_filters_t filters;
   bool border_rrra;
   v3d_addr_t base;
   uint32_t arr_str;
   uint32_t width;
   uint32_t height;
   uint32_t depth;
   v3d_tmu_type_t ttype;
   bool srgb;
   bool ahdr;
   v3d_compare_func_t compare_func;
   V3D_TMU_INDIRECT_SWIZZLES_T swizzles;
   bool flipx;
   bool flipy;
   uint64_t bcolour;
   int32_t min_lod;
   int32_t max_lod;
   int32_t fixed_bias;
   uint32_t base_level;
   uint32_t samp_num;
   uint32_t ub_pad;
   bool ub_xor;
   bool uif_top;
   bool xor_dis;
} V3D_TMU_INDIRECT_T;
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
typedef v3d_tmu_swizzle_t V3D_TMU_INDIRECT_SWIZZLES_T[4];
typedef struct
{
   v3d_tmu_filters_t filters;
   bool border_rrra;
   v3d_addr_t base;
   uint32_t arr_str;
   uint32_t width;
   uint32_t height;
   uint32_t depth;
   v3d_tmu_type_t ttype;
   bool srgb;
   bool ahdr;
   v3d_compare_func_t compare_func;
   V3D_TMU_INDIRECT_SWIZZLES_T swizzles;
   bool flipx;
   bool flipy;
   uint64_t bcolour;
   int32_t min_lod;
   int32_t max_lod;
   int32_t fixed_bias;
   uint32_t base_level;
   uint32_t samp_num;
   bool output_32;
   uint32_t ub_pad;
   bool ub_xor;
   bool uif_top;
   bool xor_dis;
} V3D_TMU_INDIRECT_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef v3d_tmu_swizzle_t V3D_TMU_TEX_STATE_SWIZZLES_T[4];
typedef struct
{
   bool flipx;
   bool flipy;
   bool srgb;
   bool ahdr;
   bool reverse_std_bcol;
   v3d_addr_t l0_addr;
   uint32_t arr_str;
   uint32_t width;
   uint32_t height;
   uint32_t depth;
   v3d_tmu_type_t type;
   bool extended;
   V3D_TMU_TEX_STATE_SWIZZLES_T swizzles;
   uint32_t max_level;
   uint32_t base_level;
} V3D_TMU_TEX_STATE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t ub_pad;
   bool ub_xor;
   bool uif_top;
   bool xor_dis;
} V3D_TMU_TEX_EXTENSION_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tmu_filter_t magfilt;
   v3d_tmu_filter_t minfilt;
   v3d_tmu_mipfilt_t mipfilt;
   bool aniso_en;
   v3d_compare_func_t compare_func;
   bool srgb_override;
   uint32_t min_lod;
   uint32_t max_lod;
   int32_t fixed_bias;
   v3d_tmu_wrap_t wrap_s;
   v3d_tmu_wrap_t wrap_t;
   v3d_tmu_wrap_t wrap_r;
   v3d_tmu_wrap_i_t wrap_i;
   v3d_tmu_std_bcol_t std_bcol;
   v3d_max_aniso_t max_aniso;
} V3D_TMU_SAMPLER_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t first;
   uint32_t count;
   uint32_t buffer;
} V3D_TF_SPEC_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t first;
   uint32_t count;
   uint32_t buffer;
   uint32_t stream;
} V3D_TF_SPEC_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef uint32_t V3D_BIN_TILE_STATE_PREV_INDICES_T[3];
typedef struct
{
   v3d_addr_t cl_pos;
   V3D_BIN_TILE_STATE_PREV_INDICES_T prev_indices;
   bool curr_xy_mode;
   bool prev_reverse_flag;
   uint32_t ctr;
   v3d_tile_alloc_block_size_t blksize;
   bool halfwrt;
} V3D_BIN_TILE_STATE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
typedef uint32_t V3D_BIN_TILE_STATE_PREV_INDICES_T[3];
typedef uint32_t V3D_BIN_TILE_STATE_PREV_SERIALS_T[3];
typedef struct
{
   v3d_addr_t cl_pos;
   v3d_addr_t sn_pos;
   V3D_BIN_TILE_STATE_PREV_INDICES_T prev_indices;
   V3D_BIN_TILE_STATE_PREV_SERIALS_T prev_serials;
   uint32_t prev_prim_id;
   bool curr_xy_mode;
   bool in_generic_ind_list;
   bool in_prim_list;
   bool prev_reverse_flag;
   uint32_t ctr;
   v3d_tile_alloc_block_size_t blksize;
   bool halfwrt;
   uint32_t deferred_sn;
   uint32_t cur_sn_level;
   bool tg_tess;
   bool tg_geom;
   bool tg_geom_inst;
} V3D_BIN_TILE_STATE_T;
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
typedef uint32_t V3D_BIN_TILE_STATE_PREV_INDICES_T[3];
typedef uint32_t V3D_BIN_TILE_STATE_PREV_SERIALS_T[3];
typedef struct
{
   v3d_addr_t cl_pos;
   v3d_addr_t sn_pos;
   V3D_BIN_TILE_STATE_PREV_INDICES_T prev_indices;
   V3D_BIN_TILE_STATE_PREV_SERIALS_T prev_serials;
   uint32_t prev_prim_id;
   bool curr_xy_mode;
   bool in_generic_ind_list;
   bool in_prim_list;
   uint32_t ctr;
   v3d_tile_alloc_block_size_t blksize;
   bool halfwrt;
   uint32_t deferred_sn;
   uint32_t cur_sn_level;
   bool tg_tess;
   bool tg_geom;
   bool tg_geom_inst;
} V3D_BIN_TILE_STATE_T;
#endif
typedef struct
{
   uint32_t num_indices;
   uint32_t num_instances;
   uint32_t index_of_first_index;
   int32_t base_vertex;
   uint32_t base_instance;
} V3D_INDIRECT_INDEXED_RECORD_T;
typedef struct
{
   uint32_t num_vertices;
   uint32_t num_instances;
   uint32_t first_index;
   uint32_t base_instance;
} V3D_INDIRECT_ARRAYS_RECORD_T;
#if !V3D_VER_AT_LEAST(4,2,13,0)
typedef float V3D_CLIP_RECORD_VCOEFF_T[3];
typedef struct
{
   int32_t xs;
   int32_t ys;
   float zs;
   float rw;
   V3D_CLIP_RECORD_VCOEFF_T vcoeff;
} V3D_CLIP_RECORD_T;
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
typedef float V3D_CLIP_RECORD_VCOEFF_T[3];
typedef struct
{
   int32_t xs;
   int32_t ys;
   float zs;
   float rw;
   V3D_CLIP_RECORD_VCOEFF_T vcoeff;
   uint32_t intedges;
} V3D_CLIP_RECORD_T;
#endif
typedef struct
{
   v3d_tile_alloc_block_size_t next_block_size;
   bool more;
   v3d_addr_t next_block_addr;
} V3D_AUTOCHAIN_LINK_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID8_T;
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID32_T;
typedef struct
{
   int32_t rel_addr;
} V3D_CL_COMPR_IND_COMMON_REL_BRANCH_T;
typedef struct
{
   v3d_addr_t addr;
} V3D_CL_COMPR_IND_COMMON_BRANCH_T;
typedef union
{
   V3D_CL_COMPR_IND_COMMON_IID8_T iid8;
   V3D_CL_COMPR_IND_COMMON_IID32_T iid32;
   V3D_CL_COMPR_IND_COMMON_REL_BRANCH_T rel_branch;
   V3D_CL_COMPR_IND_COMMON_BRANCH_T branch;
} V3D_CL_COMPR_IND_COMMON_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_COMMON_U_T u;
} V3D_CL_COMPR_IND_COMMON_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID8_T;
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID32_T;
typedef struct
{
   uint32_t rel_id;
} V3D_CL_COMPR_IND_COMMON_PRIM_ID8_T;
typedef struct
{
   uint32_t id;
} V3D_CL_COMPR_IND_COMMON_PRIM_ID32_T;
typedef bool V3D_CL_COMPR_IND_COMMON_CLIPPED_PRIM_CLIP_VERT_T[3];
typedef struct
{
   bool is_first;
   V3D_CL_COMPR_IND_COMMON_CLIPPED_PRIM_CLIP_VERT_T clip_vert;
   bool flat_zw;
   bool is_first2;
   v3d_addr_t addr;
} V3D_CL_COMPR_IND_COMMON_CLIPPED_PRIM_T;
typedef union
{
   V3D_CL_COMPR_IND_COMMON_IID8_T iid8;
   V3D_CL_COMPR_IND_COMMON_IID32_T iid32;
   V3D_CL_COMPR_IND_COMMON_PRIM_ID8_T prim_id8;
   V3D_CL_COMPR_IND_COMMON_PRIM_ID32_T prim_id32;
   V3D_CL_COMPR_IND_COMMON_CLIPPED_PRIM_T clipped_prim;
} V3D_CL_COMPR_IND_COMMON_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_COMMON_U_T u;
} V3D_CL_COMPR_IND_COMMON_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool is_last;
   uint32_t rel_value;
} V3D_CL_COMPR_SERIAL_C0_T;
typedef struct
{
   bool is_last;
   uint32_t rel_value;
} V3D_CL_COMPR_SERIAL_C1_T;
typedef struct
{
   uint32_t count;
} V3D_CL_COMPR_SERIAL_C2_T;
typedef struct
{
   bool is_last;
   uint32_t value;
} V3D_CL_COMPR_SERIAL_C3_T;
typedef bool V3D_CL_COMPR_SERIAL_CLIPPED_PRIM_CLIP_VERT_T[3];
typedef struct
{
   bool is_first;
   V3D_CL_COMPR_SERIAL_CLIPPED_PRIM_CLIP_VERT_T clip_vert;
   bool flat_zw;
   bool is_first2;
   v3d_addr_t addr;
} V3D_CL_COMPR_SERIAL_CLIPPED_PRIM_T;
typedef struct
{
   bool tess;
   bool geom;
   bool geom_iid;
} V3D_CL_COMPR_SERIAL_TG_MODE_T;
typedef union
{
   V3D_CL_COMPR_SERIAL_C0_T c0;
   V3D_CL_COMPR_SERIAL_C1_T c1;
   V3D_CL_COMPR_SERIAL_C2_T c2;
   V3D_CL_COMPR_SERIAL_C3_T c3;
   V3D_CL_COMPR_SERIAL_CLIPPED_PRIM_T clipped_prim;
   V3D_CL_COMPR_SERIAL_TG_MODE_T tg_mode;
} V3D_CL_COMPR_SERIAL_U_T;
typedef struct
{
   v3d_cl_compr_serial_type_t type;
   V3D_CL_COMPR_SERIAL_U_T u;
} V3D_CL_COMPR_SERIAL_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_GENERIC_C0_T;
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_GENERIC_C1_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_C2_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_C3_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_C4_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_C5_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_C6_T;
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_GENERIC_IID8_T;
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_GENERIC_IID32_T;
typedef struct
{
   uint32_t diff;
} V3D_CL_COMPR_IND_GENERIC_PRIM_ID8_T;
typedef struct
{
   uint32_t value;
} V3D_CL_COMPR_IND_GENERIC_PRIM_ID32_T;
typedef union
{
   V3D_CL_COMPR_IND_GENERIC_C0_T c0;
   V3D_CL_COMPR_IND_GENERIC_C1_T c1;
   V3D_CL_COMPR_IND_GENERIC_C2_T c2;
   V3D_CL_COMPR_IND_GENERIC_C3_T c3;
   V3D_CL_COMPR_IND_GENERIC_C4_T c4;
   V3D_CL_COMPR_IND_GENERIC_C5_T c5;
   V3D_CL_COMPR_IND_GENERIC_C6_T c6;
   V3D_CL_COMPR_IND_GENERIC_IID8_T iid8;
   V3D_CL_COMPR_IND_GENERIC_IID32_T iid32;
   V3D_CL_COMPR_IND_GENERIC_PRIM_ID8_T prim_id8;
   V3D_CL_COMPR_IND_GENERIC_PRIM_ID32_T prim_id32;
} V3D_CL_COMPR_IND_GENERIC_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_GENERIC_U_T u;
} V3D_CL_COMPR_IND_GENERIC_T;
#endif
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t diff2;
} V3D_CL_COMPR_IND_TRI_C0_T;
typedef struct
{
   int32_t diff0;
   int32_t diff1;
   int32_t diff2;
} V3D_CL_COMPR_IND_TRI_C1_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
} V3D_CL_COMPR_IND_TRI_C2_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
} V3D_CL_COMPR_IND_TRI_C3_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_TRI_C4_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_TRI_C5_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_TRI_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_TRI_C0_T c0;
   V3D_CL_COMPR_IND_TRI_C1_T c1;
   V3D_CL_COMPR_IND_TRI_C2_T c2;
   V3D_CL_COMPR_IND_TRI_C3_T c3;
   V3D_CL_COMPR_IND_TRI_C4_T c4;
   V3D_CL_COMPR_IND_TRI_C5_T c5;
   V3D_CL_COMPR_IND_TRI_C6_T c6;
} V3D_CL_COMPR_IND_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_TRI_U_T u;
} V3D_CL_COMPR_IND_TRI_T;
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t diff2;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C0_T;
typedef struct
{
   int32_t diff0;
   uint32_t prov_vtx;
   int32_t diff1;
   int32_t diff2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C1_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C2_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C3_T;
typedef struct
{
   uint32_t prov_vtx;
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C4_T;
typedef struct
{
   uint32_t prov_vtx;
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C5_T;
typedef struct
{
   uint32_t prov_vtx;
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C0_T c0;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C1_T c1;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C2_T c2;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C3_T c3;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C4_T c4;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C5_T c5;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C6_T c6;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_U_T u;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_T;
#if !V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   v3d_line_ind_reuse_t reuse;
   int32_t diff1;
} V3D_CL_COMPR_IND_LINE_C0_T;
typedef struct
{
   int32_t diff0;
   int32_t diff1;
   bool reversed;
} V3D_CL_COMPR_IND_LINE_C1_T;
typedef struct
{
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C2_T;
typedef struct
{
   bool reversed;
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C3_T;
typedef struct
{
   bool reversed;
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C4_T;
typedef struct
{
   bool reversed;
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C5_T;
typedef struct
{
   bool reversed;
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_LINE_C0_T c0;
   V3D_CL_COMPR_IND_LINE_C1_T c1;
   V3D_CL_COMPR_IND_LINE_C2_T c2;
   V3D_CL_COMPR_IND_LINE_C3_T c3;
   V3D_CL_COMPR_IND_LINE_C4_T c4;
   V3D_CL_COMPR_IND_LINE_C5_T c5;
   V3D_CL_COMPR_IND_LINE_C6_T c6;
} V3D_CL_COMPR_IND_LINE_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_LINE_U_T u;
} V3D_CL_COMPR_IND_LINE_T;
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   v3d_line_ind_reuse_t reuse;
   int32_t diff1;
} V3D_CL_COMPR_IND_LINE_C0_T;
typedef struct
{
   int32_t diff0;
   int32_t diff1;
} V3D_CL_COMPR_IND_LINE_C1_T;
typedef struct
{
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C2_T;
typedef struct
{
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C3_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C4_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C5_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_LINE_C0_T c0;
   V3D_CL_COMPR_IND_LINE_C1_T c1;
   V3D_CL_COMPR_IND_LINE_C2_T c2;
   V3D_CL_COMPR_IND_LINE_C3_T c3;
   V3D_CL_COMPR_IND_LINE_C4_T c4;
   V3D_CL_COMPR_IND_LINE_C5_T c5;
   V3D_CL_COMPR_IND_LINE_C6_T c6;
} V3D_CL_COMPR_IND_LINE_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_LINE_U_T u;
} V3D_CL_COMPR_IND_LINE_T;
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_POINT_C0_T;
typedef struct
{
   int32_t diff;
   bool reversed;
} V3D_CL_COMPR_IND_POINT_C1_T;
typedef struct
{
   int32_t diff;
   uint32_t count;
   bool reversed;
} V3D_CL_COMPR_IND_POINT_C2_T;
typedef struct
{
   bool reversed;
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C4_T;
typedef struct
{
   bool reversed;
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C5_T;
typedef struct
{
   bool reversed;
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_POINT_C0_T c0;
   V3D_CL_COMPR_IND_POINT_C1_T c1;
   V3D_CL_COMPR_IND_POINT_C2_T c2;
   V3D_CL_COMPR_IND_POINT_C4_T c4;
   V3D_CL_COMPR_IND_POINT_C5_T c5;
   V3D_CL_COMPR_IND_POINT_C6_T c6;
} V3D_CL_COMPR_IND_POINT_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_POINT_U_T u;
} V3D_CL_COMPR_IND_POINT_T;
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_POINT_C0_T;
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_POINT_C1_T;
typedef struct
{
   int32_t diff;
   uint32_t count;
} V3D_CL_COMPR_IND_POINT_C2_T;
typedef struct
{
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C4_T;
typedef struct
{
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C5_T;
typedef struct
{
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C6_T;
typedef union
{
   V3D_CL_COMPR_IND_POINT_C0_T c0;
   V3D_CL_COMPR_IND_POINT_C1_T c1;
   V3D_CL_COMPR_IND_POINT_C2_T c2;
   V3D_CL_COMPR_IND_POINT_C4_T c4;
   V3D_CL_COMPR_IND_POINT_C5_T c5;
   V3D_CL_COMPR_IND_POINT_C6_T c6;
} V3D_CL_COMPR_IND_POINT_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_POINT_U_T u;
} V3D_CL_COMPR_IND_POINT_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C0_T;
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C1_T;
typedef struct
{
   int32_t dx1;
   int32_t dy1;
   int32_t dx2;
   int32_t dy2;
   uint32_t x0;
   uint32_t y0;
} V3D_CL_COMPR_XY_TRI_C2_T;
typedef struct
{
   uint32_t x0;
   uint32_t y0;
   uint32_t x1;
   uint32_t y1;
   uint32_t x2;
   uint32_t y2;
} V3D_CL_COMPR_XY_TRI_C3_T;
typedef union
{
   V3D_CL_COMPR_XY_TRI_C0_T c0;
   V3D_CL_COMPR_XY_TRI_C1_T c1;
   V3D_CL_COMPR_XY_TRI_C2_T c2;
   V3D_CL_COMPR_XY_TRI_C3_T c3;
} V3D_CL_COMPR_XY_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_XY_TRI_U_T u;
} V3D_CL_COMPR_XY_TRI_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C0_T;
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C1_T;
typedef struct
{
   int32_t dx1;
   int32_t dy1;
   int32_t dx2;
   int32_t dy2;
   uint32_t x0;
   uint32_t y0;
} V3D_CL_COMPR_XY_TRI_C2_T;
typedef struct
{
   uint32_t x0;
   uint32_t y0;
   uint32_t x1;
   uint32_t y1;
   uint32_t x2;
   uint32_t y2;
} V3D_CL_COMPR_XY_TRI_C3_T;
typedef struct
{
   int32_t rel_addr;
} V3D_CL_COMPR_XY_TRI_REL_BRANCH_T;
typedef union
{
   V3D_CL_COMPR_XY_TRI_C0_T c0;
   V3D_CL_COMPR_XY_TRI_C1_T c1;
   V3D_CL_COMPR_XY_TRI_C2_T c2;
   V3D_CL_COMPR_XY_TRI_C3_T c3;
   V3D_CL_COMPR_XY_TRI_REL_BRANCH_T rel_branch;
} V3D_CL_COMPR_XY_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_XY_TRI_U_T u;
} V3D_CL_COMPR_XY_TRI_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool start_prim;
   uint32_t stream_idx;
   uint32_t length;
   uint32_t layer_idx;
   uint32_t viewport_idx;
} V3D_GS_VPM_FMT_T;
#endif
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max_a;
   uint32_t min_a;
   uint32_t max_b;
   uint32_t min_b;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_WEIGHTS_T weights;
   uint32_t max_a;
   uint32_t min_a;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_THREE_PLANE_BA_U_T u;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_WEIGHTS_T weights;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_U_T u;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_T;
typedef V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_T V3D_BSTC_BLOCK_THREE_PLANE_RG_T[2];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_T ba;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_T rg;
} V3D_BSTC_BLOCK_THREE_PLANE_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_A_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_A_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_FOUR_PLANE_A_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_WEIGHTS_T weights;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_U_T u;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_T;
typedef V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_T V3D_BSTC_BLOCK_FOUR_PLANE_RGB_T[3];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_A_T a;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_T rgb;
} V3D_BSTC_BLOCK_FOUR_PLANE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_T three_plane;
   V3D_BSTC_BLOCK_FOUR_PLANE_T four_plane;
} V3D_BSTC_BLOCK_U_T;
typedef struct
{
   bool four_plane;
   V3D_BSTC_BLOCK_U_T u;
} V3D_BSTC_BLOCK_T;
#if V3D_HAS_L3C
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_l3c;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
} V3D_HUB_IDENT1_T;
#endif
#if V3D_HAS_L3C
typedef struct
{
   bool has_mmu;
} V3D_HUB_IDENT2_T;
#endif
#if V3D_HAS_L3C
typedef struct
{
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
   uint32_t compat_rev;
} V3D_HUB_IDENT3_T;
#endif
#if V3D_HAS_L3C
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_l3c;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
   bool has_mmu;
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
   uint32_t compat_rev;
} V3D_HUB_IDENT_T;
#endif
#if !V3D_HAS_L3C
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
} V3D_HUB_IDENT1_T;
#endif
#if !V3D_HAS_L3C
typedef struct
{
   bool has_mmu;
} V3D_HUB_IDENT2_T;
#endif
#if !V3D_HAS_L3C
typedef struct
{
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
   uint32_t compat_rev;
} V3D_HUB_IDENT3_T;
#endif
#if !V3D_HAS_L3C
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
   bool has_mmu;
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
   uint32_t compat_rev;
} V3D_HUB_IDENT_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t tech_version;
} V3D_IDENT0_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
} V3D_IDENT1_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
} V3D_IDENT2_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
} V3D_IDENT3_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
   v3d_ip_recipient_t ip_recipient;
   uint32_t sub_rev;
} V3D_IDENT_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t tech_version;
} V3D_IDENT0_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
} V3D_IDENT1_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
} V3D_IDENT2_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t l2t_ways;
   uint32_t l2t_way_depth;
} V3D_IDENT3_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t tech_version;
   uint32_t revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
   uint32_t l2t_ways;
   uint32_t l2t_way_depth;
} V3D_IDENT_T;
#endif
typedef struct
{
   uint32_t cle;
   uint32_t gbg;
   uint32_t tpg;
} V3D_GS_INST_FIFO_THRSH_T;
typedef struct
{
   uint32_t cle;
   uint32_t tpg;
} V3D_GS_TESS_FIFO_THRSH_T;
typedef struct
{
   bool tfu_fifo_free_over_threshold;
   bool tfu_conv_complete;
   bool mso_obj_reached_state;
   bool mmu_cap;
   bool mmu_pti;
   bool mmu_wrv;
} V3D_HUB_INTR_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef bool V3D_INTR_QPU_T[16];
typedef struct
{
   bool render_done;
   bool bin_done;
   bool outomem;
   bool spilluse;
   bool trfb;
   bool gmpv;
   V3D_INTR_QPU_T qpu;
} V3D_INTR_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef bool V3D_INTR_QPU_T[16];
typedef struct
{
   bool render_done;
   bool bin_done;
   bool outomem;
   bool spilluse;
   bool trfb;
   bool gmpv;
   bool pctr;
   bool compute_done;
   V3D_INTR_QPU_T qpu;
} V3D_INTR_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool cterr;
   v3d_ctsubsrun_t ctsubsrun;
   uint32_t ctqdep;
   uint32_t ctrtsd;
   uint32_t ctsema;
   bool ctrsta;
} V3D_CT0CS_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool ctooberr;
   bool cterr;
   v3d_ctsubsrun_t ctsubsrun;
   uint32_t ctqdep;
   uint32_t ctrtsd;
   uint32_t ctsema;
   bool ctrsta;
} V3D_CT0CS_T;
#endif
typedef struct
{
   bool ctetstop;
   bool cterr;
   v3d_ctsubsrun_t ctsubsrun;
   uint32_t ctqdep;
   uint32_t ctrtsd;
   uint32_t ctsema;
   bool ctrsta;
} V3D_CT1CS_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool disable_multicore;
   bool ets_flush;
   uint32_t max_tiles_in_flight;
   uint32_t mcs_mask_set;
   uint32_t mcs_frame_id;
   bool fill_empty_tiles;
   bool skip_empty_tiles;
} V3D_CT1CFG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool disable_multicore;
   bool ets_flush;
   uint32_t max_tiles_in_flight;
   uint32_t mcs_mask_set;
   uint32_t mcs_frame_id;
} V3D_CT1CFG_T;
#endif
typedef struct
{
   uint32_t tiles_completed_in_curr_st;
   uint32_t supertiles_completed;
   uint32_t tiles_in_flight;
} V3D_CT1TILECT_T;
typedef struct
{
   uint32_t tiles_completed_in_curr_st;
   uint32_t supertiles_completed;
   uint32_t mcs_mask_set;
   uint32_t mcs_frame_id;
   bool etstop;
} V3D_CT1PTCT_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool enable;
   v3d_addr_t tile_state_addr;
} V3D_CT0QTS_T;
#endif
typedef struct
{
   bool bmactive;
   bool rmactive;
   bool bmoom;
} V3D_PCS_T;
typedef struct
{
   bool busy;
   uint32_t nfree;
   uint32_t cvtct;
   bool tfurst;
} V3D_TFUCS_T;
typedef struct
{
   uint32_t throttle;
   uint32_t fintthr;
} V3D_TFUSU_T;
typedef struct
{
   bool ioc;
   v3d_tfu_rgbord_t rgbord;
   bool flipy;
   bool srgb;
   uint32_t nummm;
   v3d_tfu_type_t ttype;
   v3d_tfu_iformat_t iformat;
   uint32_t opad;
} V3D_TFUICFG_T;
typedef struct
{
   uint32_t stride0;
   uint32_t stride1;
} V3D_TFUIIS_T;
typedef struct
{
   bool dimtw;
   v3d_tfu_oformat_t oformat;
   v3d_addr_t oaddr;
} V3D_TFUIOA_T;
typedef struct
{
   uint32_t xsize;
   uint32_t ysize;
} V3D_TFUIOS_T;
typedef struct
{
   uint32_t ay;
   uint32_t arc;
   bool usecoef;
} V3D_TFUCOEF0_T;
typedef struct
{
   uint32_t agc;
   uint32_t abc;
} V3D_TFUCOEF1_T;
typedef struct
{
   uint32_t agr;
   uint32_t arr;
} V3D_TFUCOEF2_T;
typedef struct
{
   uint32_t abb;
   uint32_t agb;
} V3D_TFUCOEF3_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_threading_t threading;
   bool single_seg;
   bool propagate_nans;
   v3d_addr_t addr;
} V3D_SRQPC_T;
#endif
typedef struct
{
   uint32_t num_queued;
   bool queue_error;
   uint32_t num_requests;
   uint32_t num_completed;
} V3D_SRQCS_T;
typedef struct
{
   uint32_t page_size;
   uint32_t num_banks;
   uint32_t xor_addr;
} V3D_UIFCFG_T;
#if V3D_VER_AT_LEAST(3,3,0,0)
typedef struct
{
   v3d_dram_map_version_t version;
} V3D_DRAM_MAP_VERSION_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool ovrtmuout;
} V3D_MISCCFG_T;
#endif
typedef struct
{
   bool flush;
   v3d_l2t_flush_mode_t mode;
   bool flush_write_combiner;
} V3D_L2T_CACTL_T;
#if V3D_HAS_L2T_LOCAL_MEM
typedef struct
{
   bool enable;
} V3D_L2T_LOCAL_CTRL_T;
#endif
typedef struct
{
   bool enable;
   bool stats_enable;
   bool tlb_clear;
   bool stats_clear;
   bool tlb_clearing;
   bool wrv_exception;
   bool wrv_interrupt;
   bool wrv_abort;
   bool wrv;
   bool pti_enable;
   bool pti_exception;
   bool pti_interrupt;
   bool pti_abort;
   bool pti;
   bool capex_exception;
   bool capex_interrupt;
   bool capex_abort;
   bool capex;
} V3D_MMU_CTRL_T;
typedef struct
{
   uint32_t mpage;
   bool enable;
} V3D_MMU_ADDR_CAP_T;
typedef struct
{
   uint32_t mpage;
   bool enable;
} V3D_MMU_BYPASS_T;
typedef struct
{
   uint32_t page;
   bool enable;
} V3D_MMU_ILLEGAL_T;
typedef struct
{
   uint32_t version;
   uint32_t va_width;
   uint32_t pa_width;
} V3D_MMU_DEBUG_INFO_T;
typedef struct
{
   bool enable;
   bool flush;
   bool flushing;
   bool clear_stats;
   uint32_t cache_size;
} V3D_MMUC_CONTROL_T;
#if !V3D_VER_AT_LEAST(3,3,0,0)
typedef struct
{
   bool enable;
   bool stop_request;
   bool page_cross_detect_enable;
   bool clear_prot_bits;
} V3D_GMP_CFG_T;
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool enable;
   bool stop_request;
   bool page_cross_detect_enable;
   bool long_burst_detect_enable;
} V3D_GMP_CFG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool enable;
   bool stop_request;
   bool page_cross_detect_enable;
   bool long_burst_detect_enable;
   bool reset;
} V3D_GMP_CFG_T;
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
typedef struct
{
   bool read_vio;
   bool write_vio;
   bool invalid_table;
   bool counter_overflow;
   bool load_busy;
   bool ardwait;
   bool arost;
   bool arqbusy;
   bool awbwait;
   bool awost;
   bool awqbusy;
   bool awburst;
   bool stop_request;
   bool clear_prot_bits;
   bool reset;
} V3D_GMP_CS_T;
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool violation;
   bool invalid_table;
   bool counter_overflow;
   bool cfg_busy;
   bool read_active;
   bool write_active;
   uint32_t read_count;
   uint32_t write_count;
   bool reset;
} V3D_GMP_STATUS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool violation;
   bool invalid_table;
   bool counter_overflow;
   bool cfg_busy;
   bool read_active;
   bool write_active;
   uint32_t read_count;
   uint32_t write_count;
} V3D_GMP_STATUS_T;
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
typedef struct
{
   uint32_t length;
   uint32_t axi_internal_id;
   v3d_axi_master_id_t axi_master_id;
} V3D_GMP_VIO_TYPE_T;
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t length;
   uint32_t axi_internal_id;
   v3d_axi_master_id_t axi_master_id;
   bool write;
   bool valid;
} V3D_GMP_VIO_TYPE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t length;
   v3d_l2t_master_id_t l2t_master_id;
   uint32_t axi_internal_id;
   v3d_axi_master_id_t axi_master_id;
   bool write;
   bool valid;
} V3D_GMP_VIO_TYPE_T;
#endif
typedef struct
{
   uint32_t version;
} V3D_TSY_CONFIG0_T;
typedef struct
{
   uint32_t num_objects;
   uint32_t num_threads;
} V3D_TSY_CONFIG1_T;
typedef bool V3D_TSY_CONTROL_CORE_ENABLE_T[16];
typedef struct
{
   V3D_TSY_CONTROL_CORE_ENABLE_T core_enable;
} V3D_TSY_CONTROL_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool busy;
} V3D_TSY_STATUS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool busy;
   bool apb_busy;
} V3D_TSY_STATUS_T;
#endif
typedef struct
{
   uint32_t num_waiting;
   uint32_t quorum;
} V3D_TSY_TSO_DATA_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool have_queued_dispatch;
   bool have_current_dispatch;
   uint32_t num_active_dispatches;
   uint32_t num_completed_dispatches;
} V3D_CSD_STATUS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_x_offset;
   uint32_t num_wgs_x;
} V3D_CSD_CFG0_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_y_offset;
   uint32_t num_wgs_y;
} V3D_CSD_CFG1_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_z_offset;
   uint32_t num_wgs_z;
} V3D_CSD_CFG2_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_size;
   uint32_t wgs_per_sg;
   uint32_t batches_per_sg;
   uint32_t max_sg_id;
   bool overlap_with_prev;
} V3D_CSD_CFG3_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint64_t num_batches;
} V3D_CSD_CFG4_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_threading_t threading;
   bool single_seg;
   bool propagate_nans;
   v3d_addr_t shader_addr;
} V3D_CSD_CFG5_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_addr_t unifs_addr;
} V3D_CSD_CFG6_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_x_offset;
   uint32_t num_wgs_x;
   uint32_t wg_y_offset;
   uint32_t num_wgs_y;
   uint32_t wg_z_offset;
   uint32_t num_wgs_z;
   uint32_t wg_size;
   uint32_t wgs_per_sg;
   uint32_t batches_per_sg;
   uint32_t max_sg_id;
   bool overlap_with_prev;
   uint64_t num_batches;
   v3d_threading_t threading;
   bool single_seg;
   bool propagate_nans;
   v3d_addr_t shader_addr;
   v3d_addr_t unifs_addr;
} V3D_CSD_CFG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t l_idx;
   uint32_t wg_in_sg;
   uint32_t wg_x;
} V3D_CSD_ID0_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t wg_y;
   uint32_t wg_z;
} V3D_CSD_ID1_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t l_idx;
   uint32_t wg_in_sg;
   uint32_t wg_x;
   uint32_t wg_y;
   uint32_t wg_z;
} V3D_CSD_ID_T;
#endif
typedef struct
{
   uint32_t reg_data;
   uint32_t reg_addr;
   bool write;
} V3D_UMR_AXI_CONTROL_T;
typedef struct
{
   uint32_t axi_len;
   uint32_t axi_size;
} V3D_UMR_AXI_BURST_T;
typedef struct
{
   uint32_t axi_id;
   uint32_t axi_prot;
} V3D_UMR_AXI_ID_T;
typedef struct
{
   bool write;
   bool read;
   bool rd_fifo_almost_full;
   bool wr_fifo_almost_empty;
   uint32_t fpga_num;
   bool master_error;
   bool axi_idle;
} V3D_UMR_AXI_STATUS_T;
typedef struct
{
   uint32_t axi_response;
   bool axi_timeout;
   bool rd_fifo_missed;
   bool rd_fifo_rd;
   bool rd_fifo_wr;
   bool wr_fifo_rd;
   bool wr_fifo_wr;
   bool wr_data_left;
   bool wr_no_data;
   bool rd_data_left;
   bool start_when_busy;
   bool start_error;
   bool fifo_error;
   bool axi_error;
} V3D_UMR_AXI_ERROR_T;
typedef struct
{
   bool read_req;
   bool write_req;
   bool clear_error;
   bool fifo_reset;
} V3D_UMR_AXI_FLAGS_T;
typedef struct
{
   bool wr_full;
   bool wr_empty;
   bool wr_almost_empty;
   bool wr_data_left;
   bool rd_full;
   bool rd_empty;
   bool rd_almost_full;
   bool rd_data_left;
   bool resetting;
} V3D_UMR_AXI_FIFO_FLAGS_T;
typedef struct
{
   uint32_t slave_error;
   uint32_t mastr_done;
   uint32_t num_slaves;
   bool design_reset;
   bool local_done;
   bool iodely_rdy;
   uint32_t reset_state;
   bool parity_error;
   bool pll_locked;
   bool infra_error;
} V3D_UMR_SYSMON_INFRA_STATUS_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_HAS_IMPLICIT_ATTR_DEFAULTS
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed);
#endif
#if V3D_HAS_IMPLICIT_ATTR_DEFAULTS
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_geom(V3D_SHADREC_GL_GEOM_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_tess(V3D_SHADREC_GL_TESS_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_tess_or_geom(V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_attr(V3D_SHADREC_GL_ATTR_T *unpacked, const uint32_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_attr(V3D_SHADREC_GL_ATTR_T *unpacked, const uint32_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_vg(V3D_SHADREC_VG_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_vg(V3D_SHADREC_VG_T *unpacked, const uint32_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_raw(V3D_UNIF_RAW_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_addr(V3D_UNIF_ADDR_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1_cfg0(V3D_TMU_PARAM1_CFG0_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1_cfg1(V3D_TMU_PARAM1_CFG1_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1(V3D_TMU_PARAM1_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0) && !V3D_HAS_SAMPLER_LOD_DIS
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0);
#endif
#if V3D_HAS_SAMPLER_LOD_DIS
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_general_config(V3D_TMU_GENERAL_CONFIG_T *unpacked, uint8_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_config(V3D_TSY_CONFIG_T *unpacked, uint8_t packed0);
#if V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tlb_config(V3D_TLB_CONFIG_T *unpacked, uint8_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tlb_config(V3D_TLB_CONFIG_T *unpacked, uint8_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_branch(V3D_UNIF_BRANCH_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(3,3,0,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_indirect(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_indirect(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_tex_state(V3D_TMU_TEX_STATE_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_tex_extension(V3D_TMU_TEX_EXTENSION_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_sampler(V3D_TMU_SAMPLER_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tf_spec(V3D_TF_SPEC_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tf_spec(V3D_TF_SPEC_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_indirect_indexed_record(V3D_INDIRECT_INDEXED_RECORD_T *unpacked, const uint32_t *packed);
EXPORT_FOR_CLIF_CC void v3d_unpack_indirect_arrays_record(V3D_INDIRECT_ARRAYS_RECORD_T *unpacked, const uint32_t *packed);
#if !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_clip_record(V3D_CLIP_RECORD_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_clip_record(V3D_CLIP_RECORD_T *unpacked, const uint32_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_autochain_link(V3D_AUTOCHAIN_LINK_T *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_common(V3D_CL_COMPR_IND_COMMON_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_common(V3D_CL_COMPR_IND_COMMON_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_serial(V3D_CL_COMPR_SERIAL_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_generic(V3D_CL_COMPR_IND_GENERIC_T *unpacked, const uint8_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_tri(V3D_CL_COMPR_IND_TRI_T *unpacked, const uint8_t *packed);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_d3dpvsf_tri(V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_line(V3D_CL_COMPR_IND_LINE_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_line(V3D_CL_COMPR_IND_LINE_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_point(V3D_CL_COMPR_IND_POINT_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_point(V3D_CL_COMPR_IND_POINT_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_xy_tri(V3D_CL_COMPR_XY_TRI_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_xy_tri(V3D_CL_COMPR_XY_TRI_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gs_vpm_fmt(V3D_GS_VPM_FMT_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_bstc_block(V3D_BSTC_BLOCK_T *unpacked, const uint8_t *packed);
#if V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident0(uint32_t packed0);
#endif
#if V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident1(V3D_HUB_IDENT1_T *unpacked, uint32_t packed0);
#endif
#if V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident2(V3D_HUB_IDENT2_T *unpacked, uint32_t packed0);
#endif
#if V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident3(V3D_HUB_IDENT3_T *unpacked, uint32_t packed0);
#endif
#if V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident(V3D_HUB_IDENT_T *unpacked, const uint32_t *packed);
#endif
#if !V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident0(uint32_t packed0);
#endif
#if !V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident1(V3D_HUB_IDENT1_T *unpacked, uint32_t packed0);
#endif
#if !V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident2(V3D_HUB_IDENT2_T *unpacked, uint32_t packed0);
#endif
#if !V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident3(V3D_HUB_IDENT3_T *unpacked, uint32_t packed0);
#endif
#if !V3D_HAS_L3C
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident(V3D_HUB_IDENT_T *unpacked, const uint32_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident0(V3D_IDENT0_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident1(V3D_IDENT1_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident2(V3D_IDENT2_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident3(V3D_IDENT3_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident(V3D_IDENT_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident0(V3D_IDENT0_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident1(V3D_IDENT1_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident2(V3D_IDENT2_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident3(V3D_IDENT3_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ident(V3D_IDENT_T *unpacked, const uint32_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_gs_inst_fifo_thrsh(V3D_GS_INST_FIFO_THRSH_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_gs_tess_fifo_thrsh(V3D_GS_TESS_FIFO_THRSH_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_intr(V3D_HUB_INTR_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_intr(V3D_INTR_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_intr(V3D_INTR_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ct0cs(V3D_CT0CS_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ct0cs(V3D_CT0CS_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1cs(V3D_CT1CS_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1cfg(V3D_CT1CFG_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1cfg(V3D_CT1CFG_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1tilect(V3D_CT1TILECT_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1ptct(V3D_CT1PTCT_T *unpacked, uint32_t packed0);
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_ct0qts(V3D_CT0QTS_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_pcs(V3D_PCS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucs(V3D_TFUCS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfusu(V3D_TFUSU_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuicfg(V3D_TFUICFG_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuiis(V3D_TFUIIS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuioa(V3D_TFUIOA_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuios(V3D_TFUIOS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef0(V3D_TFUCOEF0_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef1(V3D_TFUCOEF1_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef2(V3D_TFUCOEF2_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef3(V3D_TFUCOEF3_T *unpacked, uint32_t packed0);
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_srqpc(V3D_SRQPC_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_srqcs(V3D_SRQCS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_uifcfg(V3D_UIFCFG_T *unpacked, uint32_t packed0);
#if V3D_VER_AT_LEAST(3,3,0,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_dram_map_version(V3D_DRAM_MAP_VERSION_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_misccfg(V3D_MISCCFG_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_l2t_cactl(V3D_L2T_CACTL_T *unpacked, uint32_t packed0);
#if V3D_HAS_L2T_LOCAL_MEM
EXPORT_FOR_CLIF_CC void v3d_unpack_l2t_local_ctrl(V3D_L2T_LOCAL_CTRL_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_ctrl(V3D_MMU_CTRL_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_addr_cap(V3D_MMU_ADDR_CAP_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_bypass(V3D_MMU_BYPASS_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_illegal(V3D_MMU_ILLEGAL_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_debug_info(V3D_MMU_DEBUG_INFO_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmuc_control(V3D_MMUC_CONTROL_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(3,3,0,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_cfg(V3D_GMP_CFG_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_cfg(V3D_GMP_CFG_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_cfg(V3D_GMP_CFG_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_cs(V3D_GMP_CS_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_status(V3D_GMP_STATUS_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_status(V3D_GMP_STATUS_T *unpacked, uint32_t packed0);
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_vio_type(V3D_GMP_VIO_TYPE_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_vio_type(V3D_GMP_VIO_TYPE_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_vio_type(V3D_GMP_VIO_TYPE_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_config0(V3D_TSY_CONFIG0_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_config1(V3D_TSY_CONFIG1_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_control(V3D_TSY_CONTROL_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_status(V3D_TSY_STATUS_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_status(V3D_TSY_STATUS_T *unpacked, uint32_t packed0);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_tso_data(V3D_TSY_TSO_DATA_T *unpacked, uint32_t packed0);
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_status(V3D_CSD_STATUS_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg0(V3D_CSD_CFG0_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg1(V3D_CSD_CFG1_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg2(V3D_CSD_CFG2_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg3(V3D_CSD_CFG3_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg4(V3D_CSD_CFG4_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg5(V3D_CSD_CFG5_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg6(V3D_CSD_CFG6_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_cfg(V3D_CSD_CFG_T *unpacked, const uint32_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_id0(V3D_CSD_ID0_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_id1(V3D_CSD_ID1_T *unpacked, uint32_t packed0);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
EXPORT_FOR_CLIF_CC void v3d_unpack_csd_id(V3D_CSD_ID_T *unpacked, const uint32_t *packed);
#endif
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_control(V3D_UMR_AXI_CONTROL_T *unpacked, uint32_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_burst(V3D_UMR_AXI_BURST_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_id(V3D_UMR_AXI_ID_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_status(V3D_UMR_AXI_STATUS_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_error(V3D_UMR_AXI_ERROR_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_flags(V3D_UMR_AXI_FLAGS_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_fifo_flags(V3D_UMR_AXI_FIFO_FLAGS_T *unpacked, uint16_t packed0);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_sysmon_infra_status(V3D_UMR_SYSMON_INFRA_STATUS_T *unpacked, uint32_t packed0);
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 4 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 5 |
      gfx_bits((*unpacked).z_write, 1) << 6 | gfx_bits((*unpacked).no_ez, 1) << 7 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 8 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 9 |
      gfx_bits((*unpacked).fs_needs_w, 1) << 10 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 12 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 16;
   packed[1] = gfx_bits((*unpacked).cs_output_size, 8) |
      gfx_bits((*unpacked).cs_input_size, 8) << 8 |
      gfx_bits((*unpacked).vs_output_size, 8) << 16 |
      gfx_bits((*unpacked).vs_input_size, 8) << 24;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_HAS_IMPLICIT_ATTR_DEFAULTS
static inline void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).fs_needs_w, 1) << 12 |
      gfx_bits((*unpacked).sample_rate_shading, 1) << 13 |
      gfx_bits((*unpacked).prim_id_used, 1) << 14 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 15 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_bits((*unpacked).disable_implicit_varys, 1) << 18 |
      gfx_bits((*unpacked).no_prim_pack, 1) << 19 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 1) |
      gfx_bits((*unpacked).fs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 1) |
      gfx_bits((*unpacked).vs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 1) |
      gfx_bits((*unpacked).cs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_IMPLICIT_ATTR_DEFAULTS
static inline void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).fs_needs_w, 1) << 12 |
      gfx_bits((*unpacked).sample_rate_shading, 1) << 13 |
      gfx_bits((*unpacked).prim_id_used, 1) << 14 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 15 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_bits((*unpacked).disable_implicit_varys, 1) << 18 |
      gfx_bits((*unpacked).no_prim_pack, 1) << 19 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = gfx_bits((*unpacked).fs.threading, 1) |
      gfx_bits((*unpacked).fs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[3] = (*unpacked).fs.unifs_addr;
   packed[4] = gfx_bits((*unpacked).vs.threading, 1) |
      gfx_bits((*unpacked).vs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[5] = (*unpacked).vs.unifs_addr;
   packed[6] = gfx_bits((*unpacked).cs.threading, 1) |
      gfx_bits((*unpacked).cs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[7] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_geom(uint32_t *packed, const V3D_SHADREC_GL_GEOM_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).gs_bin.threading, 1) |
      gfx_bits((*unpacked).gs_bin.single_seg, 1) << 1 |
      gfx_bits((*unpacked).gs_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).gs_bin.addr, 3) << 3;
   packed[1] = (*unpacked).gs_bin.unifs_addr;
   packed[2] = gfx_bits((*unpacked).gs_render.threading, 1) |
      gfx_bits((*unpacked).gs_render.single_seg, 1) << 1 |
      gfx_bits((*unpacked).gs_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).gs_render.addr, 3) << 3;
   packed[3] = (*unpacked).gs_render.unifs_addr;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_tess(uint32_t *packed, const V3D_SHADREC_GL_TESS_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).tcs_bin.threading, 1) |
      gfx_bits((*unpacked).tcs_bin.single_seg, 1) << 1 |
      gfx_bits((*unpacked).tcs_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tcs_bin.addr, 3) << 3;
   packed[1] = (*unpacked).tcs_bin.unifs_addr;
   packed[2] = gfx_bits((*unpacked).tcs_render.threading, 1) |
      gfx_bits((*unpacked).tcs_render.single_seg, 1) << 1 |
      gfx_bits((*unpacked).tcs_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tcs_render.addr, 3) << 3;
   packed[3] = (*unpacked).tcs_render.unifs_addr;
   packed[4] = gfx_bits((*unpacked).tes_bin.threading, 1) |
      gfx_bits((*unpacked).tes_bin.single_seg, 1) << 1 |
      gfx_bits((*unpacked).tes_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tes_bin.addr, 3) << 3;
   packed[5] = (*unpacked).tes_bin.unifs_addr;
   packed[6] = gfx_bits((*unpacked).tes_render.threading, 1) |
      gfx_bits((*unpacked).tes_render.single_seg, 1) << 1 |
      gfx_bits((*unpacked).tes_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tes_render.addr, 3) << 3;
   packed[7] = (*unpacked).tes_render.unifs_addr;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_tess_or_geom(uint32_t *packed, const V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).tess_type, 2) << 1 |
      gfx_bits((*unpacked).tess_point_mode, 1) << 3 |
      gfx_bits((*unpacked).tess_edge_spacing, 2) << 4 |
      gfx_bits((*unpacked).tess_clockwise, 1) << 6 |
      gfx_bits((*unpacked).tcs_bypass, 1) << 7 |
      gfx_bits((*unpacked).tcs_bypass_render, 1) << 8 |
      gfx_bits((*unpacked).tes_no_inp_verts, 1) << 11 |
      gfx_pack_uint_0_is_max((*unpacked).num_tcs_invocations, 5) << 12 |
      gfx_bits((*unpacked).geom_output, 2) << 17 |
      gfx_pack_uint_0_is_max((*unpacked).geom_num_instances, 5) << 19;
   packed[1] = gfx_bits((*unpacked).bin.tcs_batch_flush, 2) |
      gfx_pack_uint_0_is_max((*unpacked).bin.per_patch_depth, 4) << 2 |
      gfx_check_urange((*unpacked).bin.tcs_output.size_sectors, 0, 16) << 8 |
      gfx_bits((*unpacked).bin.tcs_output.pack, 2) << 14 | gfx_check_urange(
      (*unpacked).bin.tes_output.size_sectors, 0, 16) << 16 |
      gfx_bits((*unpacked).bin.tes_output.pack, 2) << 22 | gfx_check_urange(
      (*unpacked).bin.geom_output.size_sectors, 0, 16) << 24 |
      gfx_bits((*unpacked).bin.geom_output.pack, 2) << 30;
   packed[2] = gfx_pack_uint_minus_1((*unpacked).bin.max_patches_per_tcs_batch,
      4) | gfx_bits((*unpacked).bin.max_extra_vert_segs_per_tcs_batch, 2) << 4 |
      gfx_pack_uint_minus_1((*unpacked).bin.min_tcs_segs, 3) << 6 |
      gfx_pack_uint_minus_1((*unpacked).bin.min_per_patch_segs, 2) << 9 |
      gfx_pack_uint_minus_1((*unpacked).bin.max_patches_per_tes_batch, 4) << 13 |
      gfx_bits((*unpacked).bin.max_extra_vert_segs_per_tes_batch, 2) << 17 |
      gfx_pack_uint_minus_1((*unpacked).bin.max_tcs_segs_per_tes_batch, 3) << 19 |
      gfx_pack_uint_minus_1((*unpacked).bin.min_tes_segs, 3) << 22 | gfx_bits(
      (*unpacked).bin.max_extra_vert_segs_per_gs_batch, 2) << 25 |
      gfx_pack_uint_minus_1((*unpacked).bin.min_gs_segs, 3) << 27;
   packed[3] = gfx_bits((*unpacked).render.tcs_batch_flush, 2) |
      gfx_pack_uint_0_is_max((*unpacked).render.per_patch_depth, 4) << 2 |
      gfx_check_urange((*unpacked).render.tcs_output.size_sectors, 0, 16) << 8 |
      gfx_bits((*unpacked).render.tcs_output.pack, 2) << 14 | gfx_check_urange(
      (*unpacked).render.tes_output.size_sectors, 0, 16) << 16 |
      gfx_bits((*unpacked).render.tes_output.pack, 2) << 22 | gfx_check_urange(
      (*unpacked).render.geom_output.size_sectors, 0, 16) << 24 |
      gfx_bits((*unpacked).render.geom_output.pack, 2) << 30;
   packed[4] = gfx_pack_uint_minus_1((*unpacked).render.max_patches_per_tcs_batch,
      4) | gfx_bits((*unpacked).render.max_extra_vert_segs_per_tcs_batch, 2) << 4 |
      gfx_pack_uint_minus_1((*unpacked).render.min_tcs_segs, 3) << 6 |
      gfx_pack_uint_minus_1((*unpacked).render.min_per_patch_segs, 2) << 9 |
      gfx_pack_uint_minus_1((*unpacked).render.max_patches_per_tes_batch, 4) << 13 |
      gfx_bits((*unpacked).render.max_extra_vert_segs_per_tes_batch, 2) << 17 |
      gfx_pack_uint_minus_1((*unpacked).render.max_tcs_segs_per_tes_batch, 3) << 19 |
      gfx_pack_uint_minus_1((*unpacked).render.min_tes_segs, 3) << 22 | gfx_bits(
      (*unpacked).render.max_extra_vert_segs_per_gs_batch, 2) << 25 |
      gfx_pack_uint_minus_1((*unpacked).render.min_gs_segs, 3) << 27;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_attr(uint32_t *packed, const V3D_SHADREC_GL_ATTR_T *unpacked)
{
   packed[0] = (*unpacked).addr;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).size, 2) |
      gfx_bits((*unpacked).type, 3) << 2 | gfx_bits((*unpacked).signed_int, 1) << 5 |
      gfx_bits((*unpacked).normalised_int, 1) << 6 |
      gfx_bits((*unpacked).read_as_int, 1) << 7 |
      gfx_check_urange((*unpacked).cs_num_reads, 0, 4) << 8 |
      gfx_check_urange((*unpacked).vs_num_reads, 0, 4) << 12 |
      gfx_bits((*unpacked).divisor, 16) << 16;
   packed[2] = (*unpacked).stride;
   packed[3] = gfx_bits((*unpacked).max_index, 24);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_gl_attr(uint32_t *packed, const V3D_SHADREC_GL_ATTR_T *unpacked)
{
   packed[0] = (*unpacked).addr;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).size, 2) |
      gfx_bits((*unpacked).type, 3) << 2 | gfx_bits((*unpacked).signed_int, 1) << 5 |
      gfx_bits((*unpacked).normalised_int, 1) << 6 |
      gfx_bits((*unpacked).read_as_int, 1) << 7 |
      gfx_check_urange((*unpacked).cs_num_reads, 0, 4) << 8 |
      gfx_check_urange((*unpacked).vs_num_reads, 0, 4) << 12 |
      gfx_bits((*unpacked).divisor, 16) << 16;
   packed[2] = (*unpacked).stride;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_vg(uint32_t *packed, const V3D_SHADREC_VG_T *unpacked)
{
   packed[0] = 0;
   packed[1] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[2] = (*unpacked).fs.unifs_addr;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_shadrec_vg(uint32_t *packed, const V3D_SHADREC_VG_T *unpacked)
{
   packed[0] = 0;
   packed[1] = gfx_bits((*unpacked).fs.threading, 1) |
      gfx_bits((*unpacked).fs.single_seg, 1) << 1 |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[2] = (*unpacked).fs.unifs_addr;
}
#endif
static inline uint32_t v3d_pack_unif_raw(const V3D_UNIF_RAW_T *unpacked)
{
   return (*unpacked).unif;
}
static inline uint32_t v3d_pack_unif_addr(const V3D_UNIF_ADDR_T *unpacked)
{
   return (*unpacked).addr;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param0_cfg0(const V3D_TMU_PARAM0_CFG0_T *unpacked)
{
   return gfx_bits((*unpacked).type, 7) | gfx_bits((*unpacked).srgb, 1) << 7 |
      gfx_bits((*unpacked).pix_mask, 1) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).width, 11) << 10 |
      gfx_pack_uint_0_is_max((*unpacked).height, 11) << 21;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param0_cfg1(const V3D_TMU_PARAM0_CFG1_T *unpacked)
{
   return gfx_bits((*unpacked).ltype, 3) | gfx_bits((*unpacked).fetch, 1) << 3 |
      gfx_bits((*unpacked).gather, 1) << 4 | gfx_bits((*unpacked).bias, 1) << 5 |
      gfx_bits((*unpacked).bslod, 1) << 6 | gfx_bits((*unpacked).shadow, 1) << 8 |
      1 << 9 | gfx_bits((*unpacked).wrap_s, 3) << 10 |
      gfx_bits((*unpacked).wrap_t, 3) << 13 | gfx_bits((*unpacked).wrap_r, 3) << 16 |
      gfx_pack_sint((*unpacked).tex_off_s, 4) << 19 |
      gfx_pack_sint((*unpacked).tex_off_t, 4) << 23 |
      gfx_pack_sint((*unpacked).tex_off_r, 4) << 27 |
      gfx_bits((*unpacked).pix_mask, 1) << 31;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param1_cfg0(const V3D_TMU_PARAM1_CFG0_T *unpacked)
{
   return gfx_bits((*unpacked).wrap_s, 2) | gfx_bits((*unpacked).wrap_t, 2) << 2 |
      gfx_bits((*unpacked).filters, 4) << 4 | gfx_bits((*unpacked).bslod, 1) << 8 |
      gfx_exact_lsr((*unpacked).base, 9) << 9;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param1_cfg1(const V3D_TMU_PARAM1_CFG1_T *unpacked)
{
   return gfx_bits((*unpacked).word0_en, 1) |
      gfx_bits((*unpacked).word1_en, 1) << 1 |
      gfx_bits((*unpacked).word2_en, 1) << 2 |
      gfx_bits((*unpacked).word3_en, 1) << 3 | gfx_bits((*unpacked).unnorm, 1) << 4 |
      gfx_exact_lsr((*unpacked).ts_base, 5) << 5;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param0(const V3D_TMU_PARAM0_T *unpacked)
{
   return gfx_bits((*unpacked).word_en[0], 1) |
      gfx_bits((*unpacked).word_en[1], 1) << 1 |
      gfx_bits((*unpacked).word_en[2], 1) << 2 |
      gfx_bits((*unpacked).word_en[3], 1) << 3 |
      gfx_exact_lsr((*unpacked).tex_state_addr, 4) << 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tmu_param1(const V3D_TMU_PARAM1_T *unpacked)
{
   return gfx_bits((*unpacked).output_32, 1) |
      gfx_bits((*unpacked).unnorm, 1) << 1 | gfx_bits((*unpacked).pix_mask, 1) << 2 |
      gfx_exact_lsr((*unpacked).sampler_addr, 3) << 3;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
static inline uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked)
{
   return gfx_bits((*unpacked).tmuoff_4x, 1) |
      gfx_bits((*unpacked).bslod, 1) << 1 |
      gfx_bits((*unpacked).sample_num, 2) << 2 |
      gfx_bits((*unpacked).gather_comp, 2) << 5 |
      gfx_bits((*unpacked).gather, 1) << 7 |
      gfx_pack_sint((*unpacked).offsets[0], 4) << 8 |
      gfx_pack_sint((*unpacked).offsets[1], 4) << 12 |
      gfx_pack_sint((*unpacked).offsets[2], 4) << 16 |
      gfx_bits((*unpacked).op, 4) << 20;
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0) && !V3D_HAS_SAMPLER_LOD_DIS
static inline uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked)
{
   return gfx_bits((*unpacked).tmuoff_4x, 1) |
      gfx_bits((*unpacked).bslod, 1) << 1 |
      gfx_bits((*unpacked).sample_num, 2) << 2 |
      gfx_bits((*unpacked).gather_comp, 2) << 5 |
      gfx_bits((*unpacked).gather, 1) << 7 |
      gfx_pack_sint((*unpacked).offsets[0], 4) << 8 |
      gfx_pack_sint((*unpacked).offsets[1], 4) << 12 |
      gfx_pack_sint((*unpacked).offsets[2], 4) << 16 |
      gfx_bits((*unpacked).op, 4) << 20 | gfx_bits((*unpacked).lod_query, 1) << 24;
}
#endif
#if V3D_HAS_SAMPLER_LOD_DIS
static inline uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked)
{
   return gfx_bits((*unpacked).tmuoff_4x, 1) |
      gfx_bits((*unpacked).bslod, 1) << 1 |
      gfx_bits((*unpacked).sample_num, 2) << 2 |
      gfx_bits((*unpacked).sampler_lod_dis, 1) << 4 |
      gfx_bits((*unpacked).gather_comp, 2) << 5 |
      gfx_bits((*unpacked).gather, 1) << 7 |
      gfx_pack_sint((*unpacked).offsets[0], 4) << 8 |
      gfx_pack_sint((*unpacked).offsets[1], 4) << 12 |
      gfx_pack_sint((*unpacked).offsets[2], 4) << 16 |
      gfx_bits((*unpacked).op, 4) << 20 | gfx_bits((*unpacked).lod_query, 1) << 24;
}
#endif
static inline uint8_t v3d_pack_tmu_general_config(const V3D_TMU_GENERAL_CONFIG_T *unpacked)
{
   return (uint8_t)gfx_bits((*unpacked).type, 3) |
      (uint8_t)(gfx_bits((*unpacked).op, 4) << 3) |
      (uint8_t)(gfx_bits((*unpacked).per_pixel_enable, 1) << 7);
}
static inline uint8_t v3d_pack_tsy_config(const V3D_TSY_CONFIG_T *unpacked)
{
   return (uint8_t)gfx_bits((*unpacked).op, 5) |
      (uint8_t)(gfx_bits((*unpacked).gfxh_1370_do_not_change, 3) << 5);
}
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_color_16(const V3D_TLB_CONFIG_COLOR_16_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 1) |
      (uint8_t)(gfx_bits((*unpacked).no_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) | (uint8_t)(3 << 6);
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_color_32(const V3D_TLB_CONFIG_COLOR_32_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 2) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) | (uint8_t)0 |
      (uint8_t)0;
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_z(const V3D_TLB_CONFIG_Z_T *unpacked)
{
   return (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).use_written_z, 1) << 3) | (uint8_t)(8 << 4);
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_alpha_mask(const V3D_TLB_CONFIG_ALPHA_MASK_T *unpacked)
{
   return (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) | (uint8_t)0 |
      (uint8_t)(9 << 4);
}
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_color_16(const V3D_TLB_CONFIG_COLOR_16_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 1) |
      (uint8_t)(gfx_bits((*unpacked).no_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) | (uint8_t)(3 << 6);
}
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_color_32(const V3D_TLB_CONFIG_COLOR_32_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 2) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) |
      (uint8_t)(gfx_bits((*unpacked).as_int, 1) << 6) | (uint8_t)0;
}
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_z(const V3D_TLB_CONFIG_Z_T *unpacked)
{
   return (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).use_written_z, 1) << 2) |
      (uint8_t)0 | (uint8_t)(8 << 4);
}
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline uint8_t v3d_pack_tlb_config_alpha_mask(void)
{
   return (uint8_t)0 | (uint8_t)(9 << 4);
}
#endif
static inline uint32_t v3d_pack_unif_branch(const V3D_UNIF_BRANCH_T *unpacked)
{
   return gfx_bits((*unpacked).bcond, 3) | gfx_bits((*unpacked).msfign, 2) << 7 |
      gfx_bits((*unpacked).ulr, 1) << 9 |
      gfx_pack_sint(gfx_exact_asr((*unpacked).rel_i_addr, 3), 11) << 10 |
      gfx_pack_sint(gfx_exact_asr((*unpacked).rel_u_addr, 2), 11) << 21;
}
#if !V3D_VER_AT_LEAST(3,3,0,0)
static inline void v3d_pack_tmu_indirect(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).filters, 4) |
      gfx_bits((*unpacked).border_rrra, 1) << 5 |
      gfx_exact_lsr((*unpacked).base, 6) << 6;
   packed[1] = gfx_exact_lsr((*unpacked).arr_str, 6) |
      gfx_pack_uint_0_is_max((*unpacked).width, 14) << 26;
   packed[2] = gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6 |
      gfx_pack_uint_0_is_max((*unpacked).height, 14) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 22;
   packed[3] = gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10 |
      gfx_bits((*unpacked).ttype, 7) << 4 | gfx_bits((*unpacked).srgb, 1) << 11 |
      gfx_bits((*unpacked).ahdr, 1) << 12 |
      gfx_bits((*unpacked).compare_func, 3) << 13 |
      gfx_bits((*unpacked).swizzles[0], 3) << 16 |
      gfx_bits((*unpacked).swizzles[1], 3) << 19 |
      gfx_bits((*unpacked).swizzles[2], 3) << 22 |
      gfx_bits((*unpacked).swizzles[3], 3) << 25 |
      gfx_bits((*unpacked).flipx, 1) << 28 | gfx_bits((*unpacked).flipy, 1) << 29 |
      1 << 30;
   packed[4] = (uint32_t)(*unpacked).bcolour;
   packed[5] = (uint32_t)((*unpacked).bcolour >> 32);
   packed[6] = gfx_pack_sint((*unpacked).min_lod, 16) |
      gfx_pack_sint((*unpacked).max_lod, 16) << 16;
   packed[7] = gfx_pack_sint((*unpacked).fixed_bias, 16) |
      gfx_bits((*unpacked).base_level, 4) << 16 |
      gfx_bits((*unpacked).samp_num, 2) << 20 |
      gfx_bits((*unpacked).ub_pad, 4) << 24 | gfx_bits((*unpacked).ub_xor, 1) << 28 |
      gfx_bits((*unpacked).uif_top, 1) << 30 | gfx_bits((*unpacked).xor_dis, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tmu_indirect(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).filters, 4) |
      gfx_bits((*unpacked).border_rrra, 1) << 5 |
      gfx_exact_lsr((*unpacked).base, 6) << 6;
   packed[1] = gfx_exact_lsr((*unpacked).arr_str, 6) |
      gfx_pack_uint_0_is_max((*unpacked).width, 14) << 26;
   packed[2] = gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6 |
      gfx_pack_uint_0_is_max((*unpacked).height, 14) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 22;
   packed[3] = gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10 |
      gfx_bits((*unpacked).ttype, 7) << 4 | gfx_bits((*unpacked).srgb, 1) << 11 |
      gfx_bits((*unpacked).ahdr, 1) << 12 |
      gfx_bits((*unpacked).compare_func, 3) << 13 |
      gfx_bits((*unpacked).swizzles[0], 3) << 16 |
      gfx_bits((*unpacked).swizzles[1], 3) << 19 |
      gfx_bits((*unpacked).swizzles[2], 3) << 22 |
      gfx_bits((*unpacked).swizzles[3], 3) << 25 |
      gfx_bits((*unpacked).flipx, 1) << 28 | gfx_bits((*unpacked).flipy, 1) << 29 |
      1 << 30;
   packed[4] = (uint32_t)(*unpacked).bcolour;
   packed[5] = (uint32_t)((*unpacked).bcolour >> 32);
   packed[6] = gfx_pack_sint((*unpacked).min_lod, 16) |
      gfx_pack_sint((*unpacked).max_lod, 16) << 16;
   packed[7] = gfx_pack_sint((*unpacked).fixed_bias, 16) |
      gfx_bits((*unpacked).base_level, 4) << 16 |
      gfx_bits((*unpacked).samp_num, 2) << 20 |
      gfx_bits((*unpacked).output_32, 1) << 22 |
      gfx_bits((*unpacked).ub_pad, 4) << 24 | gfx_bits((*unpacked).ub_xor, 1) << 28 |
      gfx_bits((*unpacked).uif_top, 1) << 30 | gfx_bits((*unpacked).xor_dis, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tmu_tex_state(uint8_t *packed, const V3D_TMU_TEX_STATE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).flipx, 1) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).srgb, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).ahdr, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).reverse_std_bcol, 1) << 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) << 6);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 2);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 10);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 18);
   packed[4] = (uint8_t)gfx_exact_lsr((*unpacked).arr_str, 6);
   packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 8);
   packed[6] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 16);
   packed[7] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 24) |
      (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).width, 14) << 2);
   packed[8] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6);
   packed[9] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).height, 14);
   packed[10] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).height, 14) >> 8) |
      (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 6);
   packed[11] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 2);
   packed[12] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10) |
      (uint8_t)(gfx_bits((*unpacked).type, 7) << 4);
   packed[13] = (uint8_t)(gfx_bits((*unpacked).type, 7) >> 4) |
      (uint8_t)(gfx_bits((*unpacked).extended, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[0], 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[1], 3) << 7);
   packed[14] = (uint8_t)(gfx_bits((*unpacked).swizzles[1], 3) >> 1) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[2], 3) << 2) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[3], 3) << 5);
   packed[15] = (uint8_t)gfx_bits((*unpacked).max_level, 4) |
      (uint8_t)(gfx_bits((*unpacked).base_level, 4) << 4);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tmu_tex_extension(uint8_t *packed, const V3D_TMU_TEX_EXTENSION_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).ub_pad, 4) |
      (uint8_t)(gfx_bits((*unpacked).ub_xor, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).uif_top, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).xor_dis, 1) << 7);
   packed[1] = (uint8_t)0;
   packed[2] = (uint8_t)0;
   packed[3] = (uint8_t)0;
   packed[4] = (uint8_t)0;
   packed[5] = (uint8_t)0;
   packed[6] = (uint8_t)0;
   packed[7] = (uint8_t)0;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tmu_sampler(uint8_t *packed, const V3D_TMU_SAMPLER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).magfilt, 1) |
      (uint8_t)(gfx_bits((*unpacked).minfilt, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).mipfilt, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).aniso_en, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).compare_func, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).srgb_override, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).min_lod, 12);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).min_lod, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).max_lod, 12) << 4);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).max_lod, 12) >> 4);
   packed[4] = (uint8_t)gfx_pack_sint((*unpacked).fixed_bias, 16);
   packed[5] = (uint8_t)(gfx_pack_sint((*unpacked).fixed_bias, 16) >> 8);
   packed[6] = (uint8_t)gfx_bits((*unpacked).wrap_s, 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_t, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) << 6);
   packed[7] = (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).wrap_i, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).std_bcol, 3) << 2) |
      (uint8_t)(gfx_bits((*unpacked).max_aniso, 2) << 5) | (uint8_t)0;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tf_spec(uint8_t *packed, const V3D_TF_SPEC_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).first, 8);
   packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).count, 4) |
      (uint8_t)(gfx_bits((*unpacked).buffer, 2) << 4) | (uint8_t)0;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_tf_spec(uint8_t *packed, const V3D_TF_SPEC_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).first, 8);
   packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).count, 4) |
      (uint8_t)(gfx_bits((*unpacked).buffer, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).stream, 2) << 6);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).prev_indices[0];
   packed[2] = (*unpacked).prev_indices[1];
   packed[3] = (*unpacked).prev_indices[2];
   packed[4] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 1 |
      gfx_bits((*unpacked).ctr, 15) << 2 | gfx_bits((*unpacked).blksize, 2) << 17 |
      gfx_bits((*unpacked).halfwrt, 1) << 19;
   packed[5] = 0;
   packed[6] = 0;
   packed[7] = 0;
   packed[8] = 0;
   packed[9] = 0;
   packed[10] = 0;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).sn_pos;
   packed[2] = (*unpacked).prev_indices[0];
   packed[3] = (*unpacked).prev_indices[1];
   packed[4] = (*unpacked).prev_indices[2];
   packed[5] = (*unpacked).prev_serials[0];
   packed[6] = (*unpacked).prev_serials[1];
   packed[7] = (*unpacked).prev_serials[2];
   packed[8] = (*unpacked).prev_prim_id;
   packed[9] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).in_generic_ind_list, 1) << 1 |
      gfx_bits((*unpacked).in_prim_list, 1) << 2 |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 3 |
      gfx_bits((*unpacked).ctr, 24) << 4 | gfx_bits((*unpacked).blksize, 2) << 28 |
      gfx_bits((*unpacked).halfwrt, 1) << 30 |
      gfx_bits((*unpacked).deferred_sn, 24) << 31;
   packed[10] = gfx_bits((*unpacked).deferred_sn, 24) >> 1 |
      gfx_bits((*unpacked).cur_sn_level, 2) << 23 |
      gfx_bits((*unpacked).tg_tess, 1) << 25 |
      gfx_bits((*unpacked).tg_geom, 1) << 26 |
      gfx_bits((*unpacked).tg_geom_inst, 1) << 27;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).sn_pos;
   packed[2] = (*unpacked).prev_indices[0];
   packed[3] = (*unpacked).prev_indices[1];
   packed[4] = (*unpacked).prev_indices[2];
   packed[5] = (*unpacked).prev_serials[0];
   packed[6] = (*unpacked).prev_serials[1];
   packed[7] = (*unpacked).prev_serials[2];
   packed[8] = (*unpacked).prev_prim_id;
   packed[9] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).in_generic_ind_list, 1) << 1 |
      gfx_bits((*unpacked).in_prim_list, 1) << 2 |
      gfx_bits((*unpacked).ctr, 24) << 3 | gfx_bits((*unpacked).blksize, 2) << 27 |
      gfx_bits((*unpacked).halfwrt, 1) << 29 |
      gfx_bits((*unpacked).deferred_sn, 24) << 30;
   packed[10] = gfx_bits((*unpacked).deferred_sn, 24) >> 2 |
      gfx_bits((*unpacked).cur_sn_level, 2) << 22 |
      gfx_bits((*unpacked).tg_tess, 1) << 24 |
      gfx_bits((*unpacked).tg_geom, 1) << 25 |
      gfx_bits((*unpacked).tg_geom_inst, 1) << 26;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
static inline void v3d_pack_indirect_indexed_record(uint32_t *packed, const V3D_INDIRECT_INDEXED_RECORD_T *unpacked)
{
   packed[0] = (*unpacked).num_indices;
   packed[1] = (*unpacked).num_instances;
   packed[2] = (*unpacked).index_of_first_index;
   packed[3] = (uint32_t)(*unpacked).base_vertex;
   packed[4] = (*unpacked).base_instance;
}
static inline void v3d_pack_indirect_arrays_record(uint32_t *packed, const V3D_INDIRECT_ARRAYS_RECORD_T *unpacked)
{
   packed[0] = (*unpacked).num_vertices;
   packed[1] = (*unpacked).num_instances;
   packed[2] = (*unpacked).first_index;
   packed[3] = (*unpacked).base_instance;
}
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_clip_record(uint32_t *packed, const V3D_CLIP_RECORD_T *unpacked)
{
   packed[0] = (uint32_t)(*unpacked).xs;
   packed[1] = (uint32_t)(*unpacked).ys;
   packed[2] = gfx_float_to_bits((*unpacked).zs);
   packed[3] = gfx_float_to_bits((*unpacked).rw);
   packed[4] = gfx_float_to_bits((*unpacked).vcoeff[0]);
   packed[5] = gfx_float_to_bits((*unpacked).vcoeff[1]);
   packed[6] = gfx_float_to_bits((*unpacked).vcoeff[2]);
   packed[7] = 0;
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_clip_record(uint32_t *packed, const V3D_CLIP_RECORD_T *unpacked)
{
   packed[0] = (uint32_t)(*unpacked).xs;
   packed[1] = (uint32_t)(*unpacked).ys;
   packed[2] = gfx_float_to_bits((*unpacked).zs);
   packed[3] = gfx_float_to_bits((*unpacked).rw);
   packed[4] = gfx_float_to_bits((*unpacked).vcoeff[0]);
   packed[5] = gfx_float_to_bits((*unpacked).vcoeff[1]);
   packed[6] = gfx_float_to_bits((*unpacked).vcoeff[2]);
   packed[7] = gfx_bits((*unpacked).intedges, 3);
}
#endif
static inline void v3d_pack_autochain_link(uint8_t *packed, const V3D_AUTOCHAIN_LINK_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).next_block_size, 2) |
      (uint8_t)(gfx_bits((*unpacked).more, 1) << 2) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) << 6);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 2);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 10);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 18);
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_ind_common(uint8_t *packed, const V3D_CL_COMPR_IND_COMMON_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)3;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)35;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH);
      packed[0] = (uint8_t)19;
      packed[1] = (uint8_t)gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16);
      packed[2] = (uint8_t)(gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_BRANCH);
      packed[0] = (uint8_t)195;
      packed[1] = (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)227;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_ind_common(uint8_t *packed, const V3D_CL_COMPR_IND_COMMON_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)3;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)35;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8);
      packed[0] = (uint8_t)19;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.prim_id8.rel_id, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32);
      packed[0] = (uint8_t)195;
      packed[1] = (uint8_t)(*unpacked).u.prim_id32.id;
      packed[2] = (uint8_t)((*unpacked).u.prim_id32.id >> 8);
      packed[3] = (uint8_t)((*unpacked).u.prim_id32.id >> 16);
      packed[4] = (uint8_t)((*unpacked).u.prim_id32.id >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_CLIPPED_PRIM)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_CLIPPED_PRIM);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first, 1) << 4) |
         (uint8_t)(3 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.clipped_prim.clip_vert[0], 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[1], 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[2], 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.flat_zw, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first2, 1) << 4) |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)227;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_serial(uint8_t *packed, const V3D_CL_COMPR_SERIAL_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C0);
      packed[0] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.c0.is_last, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.c0.rel_value, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_bits((*unpacked).u.c1.is_last, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.rel_value, 13) << 3);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c1.rel_value, 13) >> 5);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C2);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c2.count, 5) << 3);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C3);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_bits((*unpacked).u.c3.is_last, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) << 5);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) >> 3);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) >> 11);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first, 1) << 4) | (uint8_t)0;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.clipped_prim.clip_vert[0], 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[1], 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[2], 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.flat_zw, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first2, 1) << 4) |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_TG_MODE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_TG_MODE);
      packed[0] = (uint8_t)47;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.tg_mode.tess, 1) |
         (uint8_t)(gfx_bits((*unpacked).u.tg_mode.geom, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.tg_mode.geom_iid, 1) << 2) | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL);
      packed[0] = (uint8_t)15 | (uint8_t)(3 << 4);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_ind_generic(uint8_t *packed, const V3D_CL_COMPR_IND_GENERIC_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 14) << 2);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 14) >> 6);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c2.value, 5) << 3);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)7 | (uint8_t)(gfx_bits((*unpacked).u.c3.value, 12) << 4);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 12) >> 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) << 5);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) >> 3);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) >> 11);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)31;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.value, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.value, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.value, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)63;
      packed[1] = (uint8_t)(*unpacked).u.c6.value;
      packed[2] = (uint8_t)((*unpacked).u.c6.value >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.value >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.value >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)95;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)127;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8);
      packed[0] = (uint8_t)159;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.prim_id8.diff, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32);
      packed[0] = (uint8_t)191;
      packed[1] = (uint8_t)(*unpacked).u.prim_id32.value;
      packed[2] = (uint8_t)((*unpacked).u.prim_id32.value >> 8);
      packed[3] = (uint8_t)((*unpacked).u.prim_id32.value >> 16);
      packed[4] = (uint8_t)((*unpacked).u.prim_id32.value >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)255;
   }
   else
   {
      unreachable();
   }
}
#endif
static inline void v3d_pack_cl_compr_ind_tri(uint8_t *packed, const V3D_CL_COMPR_IND_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff2, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 4) << 4);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff2, 4) << 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)11 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 16);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 24);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 8);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)131;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c4.idx2, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)163;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c5.idx2, 24);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 8);
      packed[9] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)67;
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
      packed[9] = (uint8_t)(*unpacked).u.c6.idx2;
      packed[10] = (uint8_t)((*unpacked).u.c6.idx2 >> 8);
      packed[11] = (uint8_t)((*unpacked).u.c6.idx2 >> 16);
      packed[12] = (uint8_t)((*unpacked).u.c6.idx2 >> 24);
   }
   else
   {
      unreachable();
   }
}
static inline void v3d_pack_cl_compr_ind_d3dpvsf_tri(uint8_t *packed, const V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff2, 5) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.c0.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.prov_vtx, 1) << 7);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff2, 4) << 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)11 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 15);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 15) >> 8) |
         (uint8_t)(gfx_bits((*unpacked).u.c2.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 23);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 23) >> 8);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 23) >> 16) |
         (uint8_t)(gfx_bits((*unpacked).u.c3.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.prov_vtx, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c4.idx2, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.prov_vtx, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c5.idx2, 24);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 8);
      packed[9] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.prov_vtx, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
      packed[9] = (uint8_t)(*unpacked).u.c6.idx2;
      packed[10] = (uint8_t)((*unpacked).u.c6.idx2 >> 8);
      packed[11] = (uint8_t)((*unpacked).u.c6.idx2 >> 16);
      packed[12] = (uint8_t)((*unpacked).u.c6.idx2 >> 24);
   }
   else
   {
      unreachable();
   }
}
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_cl_compr_ind_line(uint8_t *packed, const V3D_CL_COMPR_IND_LINE_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff1, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 4) << 4);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.reversed, 1) << 4) | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 2);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c3.reversed, 1) << 2) | (uint8_t)(1 << 3) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 4) << 4);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.reversed, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.reversed, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.reversed, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_cl_compr_ind_line(uint8_t *packed, const V3D_CL_COMPR_IND_LINE_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff1, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 4) << 4);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 2);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(1 << 3) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 4) << 4);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_cl_compr_ind_point(uint8_t *packed, const V3D_CL_COMPR_IND_POINT_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) << 2);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) >> 6) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.reversed, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff, 6) << 2);
      packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).u.c2.count, 7) |
         (uint8_t)(gfx_bits((*unpacked).u.c2.reversed, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.reversed, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.reversed, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.reversed, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx >> 24);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
static inline void v3d_pack_cl_compr_ind_point(uint8_t *packed, const V3D_CL_COMPR_IND_POINT_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) << 2);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) >> 6) |
         (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff, 6) << 2);
      packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).u.c2.count, 7) |
         (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 | (uint8_t)0 | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx >> 24);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_xy_tri(uint8_t *packed, const V3D_CL_COMPR_XY_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) << 2);
      packed[1] = (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) >>
         6) | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.dy2, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c1.reuse, 2) << 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) << 6);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) >> 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) << 3);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) >> 5) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) << 2);
      packed[3] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) >> 6) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy2, 7) << 1);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c2.x0, 16);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c2.x0, 16) >> 8);
      packed[6] = (uint8_t)gfx_bits((*unpacked).u.c2.y0, 16);
      packed[7] = (uint8_t)(gfx_bits((*unpacked).u.c2.y0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)129;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.x0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.x0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c3.y0, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.y0, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c3.x1, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c3.x1, 16) >> 8);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c3.y1, 16);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c3.y1, 16) >> 8);
      packed[9] = (uint8_t)gfx_bits((*unpacked).u.c3.x2, 16);
      packed[10] = (uint8_t)(gfx_bits((*unpacked).u.c3.x2, 16) >> 8);
      packed[11] = (uint8_t)gfx_bits((*unpacked).u.c3.y2, 16);
      packed[12] = (uint8_t)(gfx_bits((*unpacked).u.c3.y2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)128;
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_cl_compr_xy_tri(uint8_t *packed, const V3D_CL_COMPR_XY_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) << 2);
      packed[1] = (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) >>
         6) | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.dy2, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c1.reuse, 2) << 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) << 6);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) >> 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) << 3);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) >> 5) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) << 2);
      packed[3] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) >> 6) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy2, 7) << 1);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c2.x0, 16);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c2.x0, 16) >> 8);
      packed[6] = (uint8_t)gfx_bits((*unpacked).u.c2.y0, 16);
      packed[7] = (uint8_t)(gfx_bits((*unpacked).u.c2.y0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)129;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.x0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.x0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c3.y0, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.y0, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c3.x1, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c3.x1, 16) >> 8);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c3.y1, 16);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c3.y1, 16) >> 8);
      packed[9] = (uint8_t)gfx_bits((*unpacked).u.c3.x2, 16);
      packed[10] = (uint8_t)(gfx_bits((*unpacked).u.c3.x2, 16) >> 8);
      packed[11] = (uint8_t)gfx_bits((*unpacked).u.c3.y2, 16);
      packed[12] = (uint8_t)(gfx_bits((*unpacked).u.c3.y2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH);
      packed[0] = (uint8_t)130;
      packed[1] = (uint8_t)gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16);
      packed[2] = (uint8_t)(gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)128;
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_gs_vpm_fmt(uint32_t *packed, const V3D_GS_VPM_FMT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).start_prim, 1) |
      gfx_bits((*unpacked).stream_idx, 2) << 1 |
      gfx_bits((*unpacked).length, 8) << 8 |
      gfx_bits((*unpacked).layer_idx, 8) << 16 |
      gfx_bits((*unpacked).viewport_idx, 4) << 24;
}
#endif
static inline void v3d_pack_bstc_block(uint8_t *packed, const V3D_BSTC_BLOCK_T *unpacked)
{
   if ((*unpacked).four_plane == false &&
      ((*unpacked).u.three_plane.ba.max_range == false ||
      (*unpacked).u.three_plane.ba.max_range == true) &&
      (((*unpacked).u.three_plane.rg[0].max_range == false ||
      (*unpacked).u.three_plane.rg[0].max_range == true) &&
      ((*unpacked).u.three_plane.rg[1].max_range == false ||
      (*unpacked).u.three_plane.rg[1].max_range == true)))
   {
      packed[3] = (uint8_t)0 | (packed[3] & ~128);
      if ((*unpacked).u.three_plane.rg[0].max_range == false)
      {
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[15], 4) << 6) |
            (packed[9] & ~192);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[13], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[14],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[15], 4) >> 2);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[11], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[12],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[13], 4) >> 2);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[9], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[10],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[11], 4) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[7], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[8],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[9], 4) >> 2);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[5], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[6],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[7], 4) >> 2);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[3], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[4],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[5], 4) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[1], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[2],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[3], 4) >> 2);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.max, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[0],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[1], 4) >> 2);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.min, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.max, 8) >> 2);
         packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.min, 8) >> 2) |
            (packed[3] & ~127);
         assert((*unpacked).u.three_plane.rg[0].max_range == false);
      }
      else if ((*unpacked).u.three_plane.rg[0].max_range == true)
      {
         assert((*unpacked).u.three_plane.rg[0].max_range == true);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[15], 5) << 6) |
            (packed[9] & ~192);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[14], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[15],
            5) >> 2);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[12], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[13], 5);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[10], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[11],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[12], 5) >> 3);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[9], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[10],
            5) >> 1);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[7], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[8],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[9], 5) >> 4);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[6], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[7],
            5) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[4], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[5], 5);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[2], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[3],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[4], 5) >> 3);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[1], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[2],
            5) >> 1);
         packed[3] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[0], 5) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[1],
            5) >> 4) | (uint8_t)(1 << 6) | (packed[3] & ~127);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.three_plane.rg[1].max_range == false)
      {
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[15], 4) << 5) |
            (packed[23] & ~224);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[13], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[14],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[15], 4) >> 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[11], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[12],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[13], 4) >> 3);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[9], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[10],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[11], 4) >> 3);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[7], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[8],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[9], 4) >> 3);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[5], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[6],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[7], 4) >> 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[3], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[4],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[5], 4) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[1], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[2],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[3], 4) >> 3);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.max, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[0],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[1], 4) >> 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.min, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.max, 8) >> 3);
         packed[9] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.min, 8) >> 3) | (packed[9] & ~63);
         assert((*unpacked).u.three_plane.rg[1].max_range == false);
      }
      else if ((*unpacked).u.three_plane.rg[1].max_range == true)
      {
         assert((*unpacked).u.three_plane.rg[1].max_range == true);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[15], 5) << 5) |
            (packed[23] & ~224);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[13], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[14],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[15], 5) >> 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[12], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[13],
            5) >> 1);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[10], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[11],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[12], 5) >> 4);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[9], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[10],
            5) >> 2);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[7], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[8], 5);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[5], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[6],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[7], 5) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[4], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[5],
            5) >> 1);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[2], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[3],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[4], 5) >> 4);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[1], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[2],
            5) >> 2);
         packed[9] = (uint8_t)gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[0], 5) |
            (uint8_t)(1 << 5) | (packed[9] & ~63);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.three_plane.ba.max_range == false)
      {
         packed[28] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[14], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[15], 4);
         packed[29] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[12], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[13], 4);
         packed[30] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[10], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[11], 4);
         packed[31] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[8], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[9], 4);
         packed[24] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[6], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[7], 4);
         packed[25] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[4], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[5], 4);
         packed[26] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[2], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[3], 4);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[0], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[1], 4);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_a, 6) << 6) | (uint8_t)gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.max_a, 6);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.max_b, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.min_a, 6) >> 2);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_b, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.max_b, 8) >> 4);
         packed[23] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_b, 8) >> 4) | (packed[23] & ~31);
         assert((*unpacked).u.three_plane.ba.max_range == false);
      }
      else if ((*unpacked).u.three_plane.ba.max_range == true)
      {
         packed[28] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[14], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[15], 5);
         packed[29] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[12], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[13], 5) <<
            2) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[14],
            5) >> 3);
         packed[30] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[11], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[12], 5) >>
            1);
         packed[31] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[9], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[10], 5) <<
            1) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[11],
            5) >> 4);
         packed[24] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[8], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[9], 5) >> 2);
         packed[25] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[6], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[7], 5);
         packed[26] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[4], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[5], 5) <<
            2) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[6],
            5) >> 3);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[3], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[4], 5) >> 1);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[1], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[2], 5) <<
            1) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[3],
            5) >> 4);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[0], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[1], 5) >> 2);
         packed[22] =
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.min_a, 6) << 6) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.max_a, 6);
         packed[23] = (uint8_t)(1 << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.min_a, 6) >> 2) |
            (packed[23] & ~31);
         assert((*unpacked).u.three_plane.ba.max_range == true);
      }
      else
      {
         unreachable();
      }
      assert((*unpacked).four_plane == false);
   }
   else if ((*unpacked).four_plane == true &&
      (((*unpacked).u.four_plane.rgb[0].max_range == false ||
      (*unpacked).u.four_plane.rgb[0].max_range == true) &&
      ((*unpacked).u.four_plane.rgb[1].max_range == false ||
      (*unpacked).u.four_plane.rgb[1].max_range == true) &&
      ((*unpacked).u.four_plane.rgb[2].max_range == false ||
      (*unpacked).u.four_plane.rgb[2].max_range == true)))
   {
      packed[3] = (uint8_t)(1 << 7) | (packed[3] & ~128);
      if ((*unpacked).u.four_plane.rgb[0].max_range == false)
      {
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[15], 3) << 6) |
            (packed[11] & ~192);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[12], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[13],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[14], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[15],
            3) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[10], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[11],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[12], 3) >> 1);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[7], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[8],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[9], 3);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[4], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[5],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[6], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[7],
            3) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[2], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[3],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[4], 3) >> 1);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.max, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[0],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[1], 3);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.min, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.max, 8) >> 2);
         packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.min, 8) >> 2) |
            (packed[3] & ~127);
         assert((*unpacked).u.four_plane.rgb[0].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[0].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[0].max_range == true);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[15], 4) << 6) |
            (packed[11] & ~192);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[13], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[14],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[15], 4) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[11], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[12],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[13], 4) >> 2);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[9], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[10],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[11], 4) >> 2);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[7], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[8],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[9], 4) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[5], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[6],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[7], 4) >> 2);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[3], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[4],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[5], 4) >> 2);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[1], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[2],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[3], 4) >> 2);
         packed[3] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[0], 4) << 2) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[1],
            4) >> 2) | (uint8_t)(1 << 6) | (packed[3] & ~127);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.four_plane.rgb[1].max_range == false)
      {
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[15], 3) << 5) |
            (packed[19] & ~224);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[12], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[13],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[14], 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[9], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[10],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[11], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[12],
            3) >> 2);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[7], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[8],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[9], 3) >> 1);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[4], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[5],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[6], 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[1], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[2],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[3], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[4],
            3) >> 2);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.max, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[0],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[1], 3) >> 1);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.min, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.max, 8) >> 3);
         packed[11] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.min, 8) >> 3) |
            (packed[11] & ~63);
         assert((*unpacked).u.four_plane.rgb[1].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[1].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[1].max_range == true);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[15], 4) << 5) |
            (packed[19] & ~224);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[13], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[14],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[15], 4) >> 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[11], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[12],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[13], 4) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[9], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[10],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[11], 4) >> 3);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[7], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[8],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[9], 4) >> 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[5], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[6],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[7], 4) >> 3);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[3], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[4],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[5], 4) >> 3);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[1], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[2],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[3], 4) >> 3);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[0], 4) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[1],
            4) >> 3) | (uint8_t)(1 << 5) | (packed[11] & ~63);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.four_plane.rgb[2].max_range == false)
      {
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[14], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[15],
            3) << 4) | (packed[27] & ~240);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[12], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[13],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[14], 3) >> 1);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[9], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[10],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[11], 3);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[6], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[7],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[8], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[9],
            3) >> 2);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[4], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[5],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[6], 3) >> 1);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[1], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[2],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[3], 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.max, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[0],
            3) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[1], 3) >> 2);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.min, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.max, 8) >> 4);
         packed[19] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.min, 8) >> 4) |
            (packed[19] & ~31);
         assert((*unpacked).u.four_plane.rgb[2].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[2].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[2].max_range == true);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[15], 4) << 4) |
            (packed[27] & ~240);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[13], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[14], 4);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[11], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[12], 4);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[9], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[10], 4);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[7], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[8], 4);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[5], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[6], 4);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[3], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[4], 4);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[1], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[2], 4);
         packed[19] = (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[0], 4) |
            (uint8_t)(1 << 4) | (packed[19] & ~31);
      }
      else
      {
         unreachable();
      }
      packed[28] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[13], 3) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[14], 3) << 3) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.weights[15], 3);
      packed[29] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[10], 3) << 7) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[11], 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[12], 3) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[13], 3) >> 2);
      packed[30] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[8], 3) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[9], 3) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[10], 3) >> 1);
      packed[31] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[5], 3) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[6], 3) << 3) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.weights[7], 3);
      packed[24] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[2], 3) << 7) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[3], 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[4], 3) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[5], 3) >> 2);
      packed[25] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[0], 3) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[1], 3) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[2], 3) >> 1);
      packed[26] = (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.min, 6) << 6) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.max, 6);
      packed[27] = (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.min, 6) >> 2) |
         (packed[27] & ~15);
      assert((*unpacked).four_plane == true);
   }
   else
   {
      unreachable();
   }
}
#if V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident0(void)
{
   return 0x42554856;
}
#endif
#if V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident1(const V3D_HUB_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).tech_version, 4) |
      gfx_bits((*unpacked).revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_l3c, 1) << 16 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 | gfx_bits((*unpacked).has_mso, 1) << 19;
}
#endif
#if V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident2(const V3D_HUB_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).has_mmu, 1) << 8;
}
#endif
#if V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident3(const V3D_HUB_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8 |
      gfx_bits((*unpacked).compat_rev, 8) << 16;
}
#endif
#if V3D_HAS_L3C
static inline void v3d_pack_hub_ident(uint32_t *packed, const V3D_HUB_IDENT_T *unpacked)
{
   packed[0] = 0x42554856;
   packed[1] = gfx_bits((*unpacked).tech_version, 4) |
      gfx_bits((*unpacked).revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_l3c, 1) << 16 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 | gfx_bits((*unpacked).has_mso, 1) << 19;
   packed[2] = gfx_bits((*unpacked).has_mmu, 1) << 8;
   packed[3] = gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8 |
      gfx_bits((*unpacked).compat_rev, 8) << 16;
}
#endif
#if !V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident0(void)
{
   return 0x42554856;
}
#endif
#if !V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident1(const V3D_HUB_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).tech_version, 4) |
      gfx_bits((*unpacked).revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 | gfx_bits((*unpacked).has_mso, 1) << 19;
}
#endif
#if !V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident2(const V3D_HUB_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).has_mmu, 1) << 8;
}
#endif
#if !V3D_HAS_L3C
static inline uint32_t v3d_pack_hub_ident3(const V3D_HUB_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8 |
      gfx_bits((*unpacked).compat_rev, 8) << 16;
}
#endif
#if !V3D_HAS_L3C
static inline void v3d_pack_hub_ident(uint32_t *packed, const V3D_HUB_IDENT_T *unpacked)
{
   packed[0] = 0x42554856;
   packed[1] = gfx_bits((*unpacked).tech_version, 4) |
      gfx_bits((*unpacked).revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 | gfx_bits((*unpacked).has_mso, 1) << 19;
   packed[2] = gfx_bits((*unpacked).has_mmu, 1) << 8;
   packed[3] = gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8 |
      gfx_bits((*unpacked).compat_rev, 8) << 16;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident0(const V3D_IDENT0_T *unpacked)
{
   return 0x443356 | gfx_bits((*unpacked).tech_version, 8) << 24;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident1(const V3D_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident2(const V3D_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident3(const V3D_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_ident(uint32_t *packed, const V3D_IDENT_T *unpacked)
{
   packed[0] = 0x443356 | gfx_bits((*unpacked).tech_version, 8) << 24;
   packed[1] = gfx_bits((*unpacked).revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
   packed[2] = gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
   packed[3] = gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).sub_rev, 8) << 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident0(const V3D_IDENT0_T *unpacked)
{
   return 0x443356 | gfx_bits((*unpacked).tech_version, 8) << 24;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident1(const V3D_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident2(const V3D_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ident3(const V3D_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).l2t_ways, 4) |
      gfx_bits((*unpacked).l2t_way_depth, 4) << 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_ident(uint32_t *packed, const V3D_IDENT_T *unpacked)
{
   packed[0] = 0x443356 | gfx_bits((*unpacked).tech_version, 8) << 24;
   packed[1] = gfx_bits((*unpacked).revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
   packed[2] = gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
   packed[3] = gfx_bits((*unpacked).l2t_ways, 4) |
      gfx_bits((*unpacked).l2t_way_depth, 4) << 4;
}
#endif
static inline uint32_t v3d_pack_gs_inst_fifo_thrsh(const V3D_GS_INST_FIFO_THRSH_T *unpacked)
{
   return gfx_bits((*unpacked).cle, 8) | gfx_bits((*unpacked).gbg, 8) << 8 |
      gfx_bits((*unpacked).tpg, 8) << 16;
}
static inline uint32_t v3d_pack_gs_tess_fifo_thrsh(const V3D_GS_TESS_FIFO_THRSH_T *unpacked)
{
   return gfx_bits((*unpacked).cle, 8) | gfx_bits((*unpacked).tpg, 8) << 8;
}
static inline uint32_t v3d_pack_hub_intr(const V3D_HUB_INTR_T *unpacked)
{
   return gfx_bits((*unpacked).tfu_fifo_free_over_threshold, 1) |
      gfx_bits((*unpacked).tfu_conv_complete, 1) << 1 |
      gfx_bits((*unpacked).mso_obj_reached_state, 1) << 2 |
      gfx_bits((*unpacked).mmu_cap, 1) << 3 | gfx_bits((*unpacked).mmu_pti, 1) << 4 |
      gfx_bits((*unpacked).mmu_wrv, 1) << 5;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_intr(const V3D_INTR_T *unpacked)
{
   return gfx_bits((*unpacked).render_done, 1) |
      gfx_bits((*unpacked).bin_done, 1) << 1 |
      gfx_bits((*unpacked).outomem, 1) << 2 |
      gfx_bits((*unpacked).spilluse, 1) << 3 | gfx_bits((*unpacked).trfb, 1) << 4 |
      gfx_bits((*unpacked).gmpv, 1) << 5 | gfx_bits((*unpacked).qpu[0], 1) << 16 |
      gfx_bits((*unpacked).qpu[1], 1) << 17 | gfx_bits((*unpacked).qpu[2], 1) << 18 |
      gfx_bits((*unpacked).qpu[3], 1) << 19 | gfx_bits((*unpacked).qpu[4], 1) << 20 |
      gfx_bits((*unpacked).qpu[5], 1) << 21 | gfx_bits((*unpacked).qpu[6], 1) << 22 |
      gfx_bits((*unpacked).qpu[7], 1) << 23 | gfx_bits((*unpacked).qpu[8], 1) << 24 |
      gfx_bits((*unpacked).qpu[9], 1) << 25 |
      gfx_bits((*unpacked).qpu[10], 1) << 26 |
      gfx_bits((*unpacked).qpu[11], 1) << 27 |
      gfx_bits((*unpacked).qpu[12], 1) << 28 |
      gfx_bits((*unpacked).qpu[13], 1) << 29 |
      gfx_bits((*unpacked).qpu[14], 1) << 30 | gfx_bits((*unpacked).qpu[15], 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_intr(const V3D_INTR_T *unpacked)
{
   return gfx_bits((*unpacked).render_done, 1) |
      gfx_bits((*unpacked).bin_done, 1) << 1 |
      gfx_bits((*unpacked).outomem, 1) << 2 |
      gfx_bits((*unpacked).spilluse, 1) << 3 | gfx_bits((*unpacked).trfb, 1) << 4 |
      gfx_bits((*unpacked).gmpv, 1) << 5 | gfx_bits((*unpacked).pctr, 1) << 6 |
      gfx_bits((*unpacked).compute_done, 1) << 7 |
      gfx_bits((*unpacked).qpu[0], 1) << 16 | gfx_bits((*unpacked).qpu[1], 1) << 17 |
      gfx_bits((*unpacked).qpu[2], 1) << 18 | gfx_bits((*unpacked).qpu[3], 1) << 19 |
      gfx_bits((*unpacked).qpu[4], 1) << 20 | gfx_bits((*unpacked).qpu[5], 1) << 21 |
      gfx_bits((*unpacked).qpu[6], 1) << 22 | gfx_bits((*unpacked).qpu[7], 1) << 23 |
      gfx_bits((*unpacked).qpu[8], 1) << 24 | gfx_bits((*unpacked).qpu[9], 1) << 25 |
      gfx_bits((*unpacked).qpu[10], 1) << 26 |
      gfx_bits((*unpacked).qpu[11], 1) << 27 |
      gfx_bits((*unpacked).qpu[12], 1) << 28 |
      gfx_bits((*unpacked).qpu[13], 1) << 29 |
      gfx_bits((*unpacked).qpu[14], 1) << 30 | gfx_bits((*unpacked).qpu[15], 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ct0cs(const V3D_CT0CS_T *unpacked)
{
   return gfx_bits((*unpacked).cterr, 1) << 3 |
      gfx_bits((*unpacked).ctsubsrun, 2) << 4 |
      gfx_bits((*unpacked).ctqdep, 1) << 6 | gfx_bits((*unpacked).ctrtsd, 2) << 8 |
      gfx_bits((*unpacked).ctsema, 3) << 12 | gfx_bits((*unpacked).ctrsta, 1) << 15;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ct0cs(const V3D_CT0CS_T *unpacked)
{
   return gfx_bits((*unpacked).ctooberr, 1) << 2 |
      gfx_bits((*unpacked).cterr, 1) << 3 | gfx_bits((*unpacked).ctsubsrun, 2) << 4 |
      gfx_bits((*unpacked).ctqdep, 1) << 6 | gfx_bits((*unpacked).ctrtsd, 2) << 8 |
      gfx_bits((*unpacked).ctsema, 3) << 12 | gfx_bits((*unpacked).ctrsta, 1) << 15;
}
#endif
static inline uint32_t v3d_pack_ct1cs(const V3D_CT1CS_T *unpacked)
{
   return gfx_bits((*unpacked).ctetstop, 1) << 2 |
      gfx_bits((*unpacked).cterr, 1) << 3 | gfx_bits((*unpacked).ctsubsrun, 2) << 4 |
      gfx_bits((*unpacked).ctqdep, 1) << 6 | gfx_bits((*unpacked).ctrtsd, 2) << 8 |
      gfx_bits((*unpacked).ctsema, 3) << 12 | gfx_bits((*unpacked).ctrsta, 1) << 15;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ct1cfg(const V3D_CT1CFG_T *unpacked)
{
   return gfx_bits((*unpacked).disable_multicore, 1) |
      gfx_bits((*unpacked).ets_flush, 1) << 1 |
      gfx_bits((*unpacked).max_tiles_in_flight, 2) << 2 |
      gfx_bits((*unpacked).mcs_mask_set, 1) << 4 |
      gfx_bits((*unpacked).mcs_frame_id, 1) << 5 |
      gfx_bits((*unpacked).fill_empty_tiles, 1) << 6 |
      gfx_bits((*unpacked).skip_empty_tiles, 1) << 7;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ct1cfg(const V3D_CT1CFG_T *unpacked)
{
   return gfx_bits((*unpacked).disable_multicore, 1) |
      gfx_bits((*unpacked).ets_flush, 1) << 1 |
      gfx_bits((*unpacked).max_tiles_in_flight, 2) << 2 |
      gfx_bits((*unpacked).mcs_mask_set, 1) << 4 |
      gfx_bits((*unpacked).mcs_frame_id, 1) << 5;
}
#endif
static inline uint32_t v3d_pack_ct1tilect(const V3D_CT1TILECT_T *unpacked)
{
   return gfx_bits((*unpacked).tiles_completed_in_curr_st, 16) |
      gfx_bits((*unpacked).supertiles_completed, 9) << 16 |
      gfx_bits((*unpacked).tiles_in_flight, 2) << 25;
}
static inline uint32_t v3d_pack_ct1ptct(const V3D_CT1PTCT_T *unpacked)
{
   return gfx_bits((*unpacked).tiles_completed_in_curr_st, 16) |
      gfx_bits((*unpacked).supertiles_completed, 9) << 16 |
      gfx_bits((*unpacked).mcs_mask_set, 1) << 28 |
      gfx_bits((*unpacked).mcs_frame_id, 1) << 29 |
      gfx_bits((*unpacked).etstop, 1) << 31;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_ct0qts(const V3D_CT0QTS_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) << 1 |
      gfx_exact_lsr((*unpacked).tile_state_addr, 6) << 6;
}
#endif
static inline uint32_t v3d_pack_pcs(const V3D_PCS_T *unpacked)
{
   return gfx_bits((*unpacked).bmactive, 1) |
      gfx_bits((*unpacked).rmactive, 1) << 2 | gfx_bits((*unpacked).bmoom, 1) << 8;
}
static inline uint32_t v3d_pack_tfucs(const V3D_TFUCS_T *unpacked)
{
   return gfx_bits((*unpacked).busy, 1) | gfx_bits((*unpacked).nfree, 6) << 8 |
      gfx_bits((*unpacked).cvtct, 8) << 16 | gfx_bits((*unpacked).tfurst, 1) << 31;
}
static inline uint32_t v3d_pack_tfusu(const V3D_TFUSU_T *unpacked)
{
   return gfx_bits((*unpacked).throttle, 2) | gfx_bits((*unpacked).fintthr, 6) << 8;
}
static inline uint32_t v3d_pack_tfuicfg(const V3D_TFUICFG_T *unpacked)
{
   return gfx_bits((*unpacked).ioc, 1) | gfx_bits((*unpacked).rgbord, 2) << 1 |
      gfx_bits((*unpacked).flipy, 1) << 3 | gfx_bits((*unpacked).srgb, 1) << 4 |
      gfx_pack_uint_minus_1((*unpacked).nummm, 4) << 5 |
      gfx_bits((*unpacked).ttype, 7) << 9 | gfx_bits((*unpacked).iformat, 4) << 18 |
      gfx_bits((*unpacked).opad, 10) << 22;
}
static inline uint32_t v3d_pack_tfuiis(const V3D_TFUIIS_T *unpacked)
{
   return gfx_bits((*unpacked).stride0, 16) |
      gfx_bits((*unpacked).stride1, 16) << 16;
}
static inline uint32_t v3d_pack_tfuioa(const V3D_TFUIOA_T *unpacked)
{
   return gfx_bits((*unpacked).dimtw, 1) | gfx_bits((*unpacked).oformat, 3) << 3 |
      gfx_exact_lsr((*unpacked).oaddr, 6) << 6;
}
static inline uint32_t v3d_pack_tfuios(const V3D_TFUIOS_T *unpacked)
{
   return gfx_check_urange((*unpacked).xsize, 0, 0x4000) |
      gfx_check_urange((*unpacked).ysize, 0, 0x4000) << 16;
}
static inline uint32_t v3d_pack_tfucoef0(const V3D_TFUCOEF0_T *unpacked)
{
   return gfx_bits((*unpacked).ay, 12) | gfx_bits((*unpacked).arc, 12) << 16 |
      gfx_bits((*unpacked).usecoef, 1) << 31;
}
static inline uint32_t v3d_pack_tfucoef1(const V3D_TFUCOEF1_T *unpacked)
{
   return gfx_bits((*unpacked).agc, 12) | gfx_bits((*unpacked).abc, 12) << 16;
}
static inline uint32_t v3d_pack_tfucoef2(const V3D_TFUCOEF2_T *unpacked)
{
   return gfx_bits((*unpacked).agr, 12) | gfx_bits((*unpacked).arr, 12) << 16;
}
static inline uint32_t v3d_pack_tfucoef3(const V3D_TFUCOEF3_T *unpacked)
{
   return gfx_bits((*unpacked).abb, 12) | gfx_bits((*unpacked).agb, 12) << 16;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_srqpc(const V3D_SRQPC_T *unpacked)
{
   return gfx_bits((*unpacked).threading, 1) |
      gfx_bits((*unpacked).single_seg, 1) << 1 |
      gfx_bits((*unpacked).propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).addr, 3) << 3;
}
#endif
static inline uint32_t v3d_pack_srqcs(const V3D_SRQCS_T *unpacked)
{
   return gfx_bits((*unpacked).num_queued, 6) |
      gfx_bits((*unpacked).queue_error, 1) << 7 |
      gfx_bits((*unpacked).num_requests, 8) << 8 |
      gfx_bits((*unpacked).num_completed, 8) << 16;
}
static inline uint32_t v3d_pack_uifcfg(const V3D_UIFCFG_T *unpacked)
{
   return gfx_check_urange((*unpacked).page_size, 0, 2) |
      gfx_bits((*unpacked).num_banks, 2) << 2 | gfx_bits((*unpacked).xor_addr, 4) << 4;
}
#if V3D_VER_AT_LEAST(3,3,0,0)
static inline uint32_t v3d_pack_dram_map_version(const V3D_DRAM_MAP_VERSION_T *unpacked)
{
   return gfx_bits((*unpacked).version, 4);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_misccfg(const V3D_MISCCFG_T *unpacked)
{
   return gfx_bits((*unpacked).ovrtmuout, 1);
}
#endif
static inline uint32_t v3d_pack_l2t_cactl(const V3D_L2T_CACTL_T *unpacked)
{
   return gfx_bits((*unpacked).flush, 1) | gfx_bits((*unpacked).mode, 2) << 1 |
      gfx_bits((*unpacked).flush_write_combiner, 1) << 8;
}
#if V3D_HAS_L2T_LOCAL_MEM
static inline uint32_t v3d_pack_l2t_local_ctrl(const V3D_L2T_LOCAL_CTRL_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1);
}
#endif
static inline uint32_t v3d_pack_mmu_ctrl(const V3D_MMU_CTRL_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stats_enable, 1) << 1 |
      gfx_bits((*unpacked).tlb_clear, 1) << 2 |
      gfx_bits((*unpacked).stats_clear, 1) << 3 |
      gfx_bits((*unpacked).tlb_clearing, 1) << 7 |
      gfx_bits((*unpacked).wrv_exception, 1) << 9 |
      gfx_bits((*unpacked).wrv_interrupt, 1) << 10 |
      gfx_bits((*unpacked).wrv_abort, 1) << 11 | gfx_bits((*unpacked).wrv, 1) << 12 |
      gfx_bits((*unpacked).pti_enable, 1) << 16 |
      gfx_bits((*unpacked).pti_exception, 1) << 17 |
      gfx_bits((*unpacked).pti_interrupt, 1) << 18 |
      gfx_bits((*unpacked).pti_abort, 1) << 19 | gfx_bits((*unpacked).pti, 1) << 20 |
      gfx_bits((*unpacked).capex_exception, 1) << 24 |
      gfx_bits((*unpacked).capex_interrupt, 1) << 25 |
      gfx_bits((*unpacked).capex_abort, 1) << 26 |
      gfx_bits((*unpacked).capex, 1) << 27;
}
static inline uint32_t v3d_pack_mmu_addr_cap(const V3D_MMU_ADDR_CAP_T *unpacked)
{
   return gfx_bits((*unpacked).mpage, 12) | gfx_bits((*unpacked).enable, 1) << 31;
}
static inline uint32_t v3d_pack_mmu_bypass(const V3D_MMU_BYPASS_T *unpacked)
{
   return gfx_bits((*unpacked).mpage, 12) | gfx_bits((*unpacked).enable, 1) << 31;
}
static inline uint32_t v3d_pack_mmu_illegal(const V3D_MMU_ILLEGAL_T *unpacked)
{
   return gfx_bits((*unpacked).page, 31) | gfx_bits((*unpacked).enable, 1) << 31;
}
static inline uint32_t v3d_pack_mmu_debug_info(const V3D_MMU_DEBUG_INFO_T *unpacked)
{
   return gfx_bits((*unpacked).version, 4) |
      gfx_bits((*unpacked).va_width, 4) << 4 | gfx_bits((*unpacked).pa_width, 4) << 8;
}
static inline uint32_t v3d_pack_mmuc_control(const V3D_MMUC_CONTROL_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) | gfx_bits((*unpacked).flush, 1) << 1 |
      gfx_bits((*unpacked).flushing, 1) << 2 |
      gfx_bits((*unpacked).clear_stats, 1) << 3 |
      gfx_bits((*unpacked).cache_size, 2) << 4;
}
#if !V3D_VER_AT_LEAST(3,3,0,0)
static inline uint32_t v3d_pack_gmp_cfg(const V3D_GMP_CFG_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stop_request, 1) << 1 |
      gfx_bits((*unpacked).page_cross_detect_enable, 1) << 2 |
      gfx_bits((*unpacked).clear_prot_bits, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_cfg(const V3D_GMP_CFG_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stop_request, 1) << 1 |
      gfx_bits((*unpacked).page_cross_detect_enable, 1) << 2 |
      gfx_bits((*unpacked).long_burst_detect_enable, 1) << 3;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_cfg(const V3D_GMP_CFG_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stop_request, 1) << 1 |
      gfx_bits((*unpacked).page_cross_detect_enable, 1) << 2 |
      gfx_bits((*unpacked).long_burst_detect_enable, 1) << 3 |
      gfx_bits((*unpacked).reset, 1) << 31;
}
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
static inline uint32_t v3d_pack_gmp_cs(const V3D_GMP_CS_T *unpacked)
{
   return gfx_bits((*unpacked).read_vio, 1) |
      gfx_bits((*unpacked).write_vio, 1) << 1 |
      gfx_bits((*unpacked).invalid_table, 1) << 2 |
      gfx_bits((*unpacked).counter_overflow, 1) << 3 |
      gfx_bits((*unpacked).load_busy, 1) << 7 |
      gfx_bits((*unpacked).ardwait, 1) << 8 | gfx_bits((*unpacked).arost, 1) << 9 |
      gfx_bits((*unpacked).arqbusy, 1) << 10 |
      gfx_bits((*unpacked).awbwait, 1) << 12 | gfx_bits((*unpacked).awost, 1) << 13 |
      gfx_bits((*unpacked).awqbusy, 1) << 14 |
      gfx_bits((*unpacked).awburst, 1) << 15 |
      gfx_bits((*unpacked).stop_request, 1) << 16 |
      gfx_bits((*unpacked).clear_prot_bits, 1) << 30 |
      gfx_bits((*unpacked).reset, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_status(const V3D_GMP_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).violation, 1) |
      gfx_bits((*unpacked).invalid_table, 1) << 1 |
      gfx_bits((*unpacked).counter_overflow, 1) << 2 |
      gfx_bits((*unpacked).cfg_busy, 1) << 3 |
      gfx_bits((*unpacked).read_active, 1) << 4 |
      gfx_bits((*unpacked).write_active, 1) << 5 |
      gfx_bits((*unpacked).read_count, 7) << 16 |
      gfx_bits((*unpacked).write_count, 7) << 24 |
      gfx_bits((*unpacked).reset, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_status(const V3D_GMP_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).violation, 1) |
      gfx_bits((*unpacked).invalid_table, 1) << 1 |
      gfx_bits((*unpacked).counter_overflow, 1) << 2 |
      gfx_bits((*unpacked).cfg_busy, 1) << 3 |
      gfx_bits((*unpacked).read_active, 1) << 4 |
      gfx_bits((*unpacked).write_active, 1) << 5 |
      gfx_bits((*unpacked).read_count, 8) << 16 |
      gfx_bits((*unpacked).write_count, 8) << 24;
}
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
static inline uint32_t v3d_pack_gmp_vio_type(const V3D_GMP_VIO_TYPE_T *unpacked)
{
   return gfx_pack_uint_minus_1((*unpacked).length, 4) |
      gfx_bits((*unpacked).axi_internal_id, 5) << 16 |
      gfx_bits((*unpacked).axi_master_id, 4) << 21;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_vio_type(const V3D_GMP_VIO_TYPE_T *unpacked)
{
   return gfx_pack_uint_minus_1((*unpacked).length, 4) |
      gfx_bits((*unpacked).axi_internal_id, 5) << 16 |
      gfx_bits((*unpacked).axi_master_id, 4) << 21 |
      gfx_bits((*unpacked).write, 1) << 30 | gfx_bits((*unpacked).valid, 1) << 31;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_gmp_vio_type(const V3D_GMP_VIO_TYPE_T *unpacked)
{
   return gfx_pack_uint_minus_1((*unpacked).length, 4) |
      gfx_bits((*unpacked).l2t_master_id, 4) << 4 |
      gfx_bits((*unpacked).axi_internal_id, 5) << 16 |
      gfx_bits((*unpacked).axi_master_id, 4) << 21 |
      gfx_bits((*unpacked).write, 1) << 30 | gfx_bits((*unpacked).valid, 1) << 31;
}
#endif
static inline uint32_t v3d_pack_tsy_config0(const V3D_TSY_CONFIG0_T *unpacked)
{
   return gfx_bits((*unpacked).version, 8);
}
static inline uint32_t v3d_pack_tsy_config1(const V3D_TSY_CONFIG1_T *unpacked)
{
   return gfx_bits((*unpacked).num_objects, 16) |
      gfx_bits((*unpacked).num_threads, 16) << 16;
}
static inline uint32_t v3d_pack_tsy_control(const V3D_TSY_CONTROL_T *unpacked)
{
   return gfx_bits((*unpacked).core_enable[0], 1) |
      gfx_bits((*unpacked).core_enable[1], 1) << 1 |
      gfx_bits((*unpacked).core_enable[2], 1) << 2 |
      gfx_bits((*unpacked).core_enable[3], 1) << 3 |
      gfx_bits((*unpacked).core_enable[4], 1) << 4 |
      gfx_bits((*unpacked).core_enable[5], 1) << 5 |
      gfx_bits((*unpacked).core_enable[6], 1) << 6 |
      gfx_bits((*unpacked).core_enable[7], 1) << 7 |
      gfx_bits((*unpacked).core_enable[8], 1) << 8 |
      gfx_bits((*unpacked).core_enable[9], 1) << 9 |
      gfx_bits((*unpacked).core_enable[10], 1) << 10 |
      gfx_bits((*unpacked).core_enable[11], 1) << 11 |
      gfx_bits((*unpacked).core_enable[12], 1) << 12 |
      gfx_bits((*unpacked).core_enable[13], 1) << 13 |
      gfx_bits((*unpacked).core_enable[14], 1) << 14 |
      gfx_bits((*unpacked).core_enable[15], 1) << 15;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tsy_status(const V3D_TSY_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).busy, 1);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_tsy_status(const V3D_TSY_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).busy, 1) | gfx_bits((*unpacked).apb_busy, 1) << 1;
}
#endif
static inline uint32_t v3d_pack_tsy_tso_data(const V3D_TSY_TSO_DATA_T *unpacked)
{
   return gfx_bits((*unpacked).num_waiting, 16) |
      gfx_bits((*unpacked).quorum, 16) << 16;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_status(const V3D_CSD_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).have_queued_dispatch, 1) |
      gfx_bits((*unpacked).have_current_dispatch, 1) << 1 |
      gfx_bits((*unpacked).num_active_dispatches, 2) << 2 |
      gfx_bits((*unpacked).num_completed_dispatches, 8) << 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg0(const V3D_CSD_CFG0_T *unpacked)
{
   return gfx_bits((*unpacked).wg_x_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_x, 16) << 16;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg1(const V3D_CSD_CFG1_T *unpacked)
{
   return gfx_bits((*unpacked).wg_y_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_y, 16) << 16;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg2(const V3D_CSD_CFG2_T *unpacked)
{
   return gfx_bits((*unpacked).wg_z_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_z, 16) << 16;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg3(const V3D_CSD_CFG3_T *unpacked)
{
   return gfx_pack_uint_0_is_max((*unpacked).wg_size, 8) |
      gfx_pack_uint_0_is_max((*unpacked).wgs_per_sg, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).batches_per_sg, 8) << 12 |
      gfx_bits((*unpacked).max_sg_id, 6) << 20 |
      gfx_bits((*unpacked).overlap_with_prev, 1) << 26;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg4(const V3D_CSD_CFG4_T *unpacked)
{
   return (uint32_t)gfx_pack_uint64_minus_1((*unpacked).num_batches, 32);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg5(const V3D_CSD_CFG5_T *unpacked)
{
   return gfx_bits((*unpacked).threading, 1) |
      gfx_bits((*unpacked).single_seg, 1) << 1 |
      gfx_bits((*unpacked).propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).shader_addr, 3) << 3;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_cfg6(const V3D_CSD_CFG6_T *unpacked)
{
   return gfx_exact_lsr((*unpacked).unifs_addr, 2) << 2;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_csd_cfg(uint32_t *packed, const V3D_CSD_CFG_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).wg_x_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_x, 16) << 16;
   packed[1] = gfx_bits((*unpacked).wg_y_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_y, 16) << 16;
   packed[2] = gfx_bits((*unpacked).wg_z_offset, 16) |
      gfx_pack_uint_0_is_max((*unpacked).num_wgs_z, 16) << 16;
   packed[3] = gfx_pack_uint_0_is_max((*unpacked).wg_size, 8) |
      gfx_pack_uint_0_is_max((*unpacked).wgs_per_sg, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).batches_per_sg, 8) << 12 |
      gfx_bits((*unpacked).max_sg_id, 6) << 20 |
      gfx_bits((*unpacked).overlap_with_prev, 1) << 26;
   packed[4] = (uint32_t)gfx_pack_uint64_minus_1((*unpacked).num_batches, 32);
   packed[5] = gfx_bits((*unpacked).threading, 1) |
      gfx_bits((*unpacked).single_seg, 1) << 1 |
      gfx_bits((*unpacked).propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).shader_addr, 3) << 3;
   packed[6] = gfx_exact_lsr((*unpacked).unifs_addr, 2) << 2;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_id0(const V3D_CSD_ID0_T *unpacked)
{
   return gfx_bits((*unpacked).l_idx, 8) |
      gfx_bits((*unpacked).wg_in_sg, 4) << 8 | gfx_bits((*unpacked).wg_x, 16) << 16;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline uint32_t v3d_pack_csd_id1(const V3D_CSD_ID1_T *unpacked)
{
   return gfx_bits((*unpacked).wg_y, 16) | gfx_bits((*unpacked).wg_z, 16) << 16;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_pack_csd_id(uint32_t *packed, const V3D_CSD_ID_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).l_idx, 8) |
      gfx_bits((*unpacked).wg_in_sg, 4) << 8 | gfx_bits((*unpacked).wg_x, 16) << 16;
   packed[1] = gfx_bits((*unpacked).wg_y, 16) |
      gfx_bits((*unpacked).wg_z, 16) << 16;
}
#endif
static inline uint32_t v3d_pack_umr_axi_control(const V3D_UMR_AXI_CONTROL_T *unpacked)
{
   return gfx_bits((*unpacked).reg_data, 16) |
      gfx_bits((*unpacked).reg_addr, 5) << 24 | gfx_bits((*unpacked).write, 1) << 31;
}
static inline uint16_t v3d_pack_umr_axi_burst(const V3D_UMR_AXI_BURST_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_len, 10) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).axi_size, 3) << 13);
}
static inline uint16_t v3d_pack_umr_axi_id(const V3D_UMR_AXI_ID_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_id, 13) |
      (uint16_t)(gfx_bits((*unpacked).axi_prot, 3) << 13);
}
static inline uint16_t v3d_pack_umr_axi_status(const V3D_UMR_AXI_STATUS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).write, 1) |
      (uint16_t)(gfx_bits((*unpacked).read, 1) << 1) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_almost_full, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_almost_empty, 1) << 5) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).fpga_num, 4) << 8) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).master_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).axi_idle, 1) << 15);
}
static inline uint16_t v3d_pack_umr_axi_error(const V3D_UMR_AXI_ERROR_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_response, 2) |
      (uint16_t)(gfx_bits((*unpacked).axi_timeout, 1) << 2) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_missed, 1) << 3) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_rd, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_wr, 1) << 5) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_rd, 1) << 6) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_wr, 1) << 7) |
      (uint16_t)(gfx_bits((*unpacked).wr_data_left, 1) << 8) |
      (uint16_t)(gfx_bits((*unpacked).wr_no_data, 1) << 9) |
      (uint16_t)(gfx_bits((*unpacked).rd_data_left, 1) << 10) |
      (uint16_t)(gfx_bits((*unpacked).start_when_busy, 1) << 11) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).start_error, 1) << 13) |
      (uint16_t)(gfx_bits((*unpacked).fifo_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).axi_error, 1) << 15);
}
static inline uint16_t v3d_pack_umr_axi_flags(const V3D_UMR_AXI_FLAGS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).read_req, 1) |
      (uint16_t)(gfx_bits((*unpacked).write_req, 1) << 1) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).clear_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).fifo_reset, 1) << 15);
}
static inline uint16_t v3d_pack_umr_axi_fifo_flags(const V3D_UMR_AXI_FIFO_FLAGS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).wr_full, 1) |
      (uint16_t)(gfx_bits((*unpacked).wr_empty, 1) << 1) |
      (uint16_t)(gfx_bits((*unpacked).wr_almost_empty, 1) << 2) |
      (uint16_t)(gfx_bits((*unpacked).wr_data_left, 1) << 3) |
      (uint16_t)(gfx_bits((*unpacked).rd_full, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).rd_empty, 1) << 5) |
      (uint16_t)(gfx_bits((*unpacked).rd_almost_full, 1) << 6) |
      (uint16_t)(gfx_bits((*unpacked).rd_data_left, 1) << 7) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).resetting, 1) << 15);
}
static inline uint32_t v3d_pack_umr_sysmon_infra_status(const V3D_UMR_SYSMON_INFRA_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).slave_error, 8) |
      gfx_bits((*unpacked).mastr_done, 8) << 8 |
      gfx_bits((*unpacked).num_slaves, 4) << 16 |
      gfx_bits((*unpacked).design_reset, 1) << 21 |
      gfx_bits((*unpacked).local_done, 1) << 22 |
      gfx_bits((*unpacked).iodely_rdy, 1) << 23 |
      gfx_bits((*unpacked).reset_state, 4) << 24 |
      gfx_bits((*unpacked).parity_error, 1) << 29 |
      gfx_bits((*unpacked).pll_locked, 1) << 30 |
      gfx_bits((*unpacked).infra_error, 1) << 31;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_MAIN_PACKED_SIZE 36
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_HAS_IMPLICIT_ATTR_DEFAULTS
#define V3D_SHADREC_GL_MAIN_PACKED_SIZE 36
#endif
#if V3D_HAS_IMPLICIT_ATTR_DEFAULTS
#define V3D_SHADREC_GL_MAIN_PACKED_SIZE 32
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_GEOM_PACKED_SIZE 16
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_TESS_PACKED_SIZE 32
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_TESS_OR_GEOM_PACKED_SIZE 20
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_ATTR_PACKED_SIZE 16
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_GL_ATTR_PACKED_SIZE 12
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_VG_PACKED_SIZE 12
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SHADREC_VG_PACKED_SIZE 12
#endif
#define V3D_UNIF_RAW_PACKED_SIZE 4
#define V3D_UNIF_ADDR_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_PARAM0_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_PARAM1_CFG0_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_PARAM1_CFG1_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_PARAM0_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_PARAM1_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_TMU_PARAM2_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,2,13,0) && !V3D_HAS_SAMPLER_LOD_DIS
#define V3D_TMU_PARAM2_PACKED_SIZE 4
#endif
#if V3D_HAS_SAMPLER_LOD_DIS
#define V3D_TMU_PARAM2_PACKED_SIZE 4
#endif
#define V3D_TMU_GENERAL_CONFIG_PACKED_SIZE 1
#define V3D_TSY_CONFIG_PACKED_SIZE 1
#if V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_TLB_CONFIG_PACKED_SIZE 1
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_TLB_CONFIG_PACKED_SIZE 1
#endif
#define V3D_UNIF_BRANCH_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_TMU_INDIRECT_PACKED_SIZE 32
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_INDIRECT_PACKED_SIZE 32
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_TEX_STATE_PACKED_SIZE 16
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_TEX_EXTENSION_PACKED_SIZE 8
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TMU_SAMPLER_PACKED_SIZE 8
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TF_SPEC_PACKED_SIZE 2
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TF_SPEC_PACKED_SIZE 2
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_BIN_TILE_STATE_PACKED_SIZE 64
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_BIN_TILE_STATE_PACKED_SIZE 256
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_BIN_TILE_STATE_PACKED_SIZE 256
#endif
#define V3D_INDIRECT_INDEXED_RECORD_PACKED_SIZE 20
#define V3D_INDIRECT_ARRAYS_RECORD_PACKED_SIZE 16
#if !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CLIP_RECORD_PACKED_SIZE 32
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CLIP_RECORD_PACKED_SIZE 32
#endif
#define V3D_AUTOCHAIN_LINK_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_IND_COMMON_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_common_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_IND_COMMON_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_common_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_SERIAL_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_serial_packed_size(v3d_cl_compr_serial_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_IND_GENERIC_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_generic_packed_size(v3d_cl_compr_type_t type);
#endif
#define V3D_CL_COMPR_IND_TRI_MAX_PACKED_SIZE 13
uint32_t v3d_cl_compr_ind_tri_packed_size(v3d_cl_compr_type_t type);
#define V3D_CL_COMPR_IND_D3DPVSF_TRI_MAX_PACKED_SIZE 13
uint32_t v3d_cl_compr_ind_d3dpvsf_tri_packed_size(v3d_cl_compr_type_t type);
#if !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CL_COMPR_IND_LINE_MAX_PACKED_SIZE 9
uint32_t v3d_cl_compr_ind_line_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CL_COMPR_IND_LINE_MAX_PACKED_SIZE 9
uint32_t v3d_cl_compr_ind_line_packed_size(v3d_cl_compr_type_t type);
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CL_COMPR_IND_POINT_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_point_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
#define V3D_CL_COMPR_IND_POINT_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_point_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_XY_TRI_MAX_PACKED_SIZE 13
uint32_t v3d_cl_compr_xy_tri_packed_size(v3d_cl_compr_type_t type);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_COMPR_XY_TRI_MAX_PACKED_SIZE 13
uint32_t v3d_cl_compr_xy_tri_packed_size(v3d_cl_compr_type_t type);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GS_VPM_FMT_PACKED_SIZE 4
#endif
#define V3D_BSTC_BLOCK_PACKED_SIZE 32
#if V3D_HAS_L3C
#define V3D_HUB_IDENT0_PACKED_SIZE 4
#endif
#if V3D_HAS_L3C
#define V3D_HUB_IDENT1_PACKED_SIZE 4
#endif
#if V3D_HAS_L3C
#define V3D_HUB_IDENT2_PACKED_SIZE 4
#endif
#if V3D_HAS_L3C
#define V3D_HUB_IDENT3_PACKED_SIZE 4
#endif
#if V3D_HAS_L3C
#define V3D_HUB_IDENT_PACKED_SIZE 16
#endif
#if !V3D_HAS_L3C
#define V3D_HUB_IDENT0_PACKED_SIZE 4
#endif
#if !V3D_HAS_L3C
#define V3D_HUB_IDENT1_PACKED_SIZE 4
#endif
#if !V3D_HAS_L3C
#define V3D_HUB_IDENT2_PACKED_SIZE 4
#endif
#if !V3D_HAS_L3C
#define V3D_HUB_IDENT3_PACKED_SIZE 4
#endif
#if !V3D_HAS_L3C
#define V3D_HUB_IDENT_PACKED_SIZE 16
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT0_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT1_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT2_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT3_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT_PACKED_SIZE 16
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT0_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT1_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT2_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT3_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_IDENT_PACKED_SIZE 16
#endif
#define V3D_GS_INST_FIFO_THRSH_PACKED_SIZE 4
#define V3D_GS_TESS_FIFO_THRSH_PACKED_SIZE 4
#define V3D_HUB_INTR_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_INTR_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_INTR_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CT0CS_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CT0CS_PACKED_SIZE 4
#endif
#define V3D_CT1CS_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CT1CFG_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CT1CFG_PACKED_SIZE 4
#endif
#define V3D_CT1TILECT_PACKED_SIZE 4
#define V3D_CT1PTCT_PACKED_SIZE 4
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CT0QTS_PACKED_SIZE 4
#endif
#define V3D_PCS_PACKED_SIZE 4
#define V3D_TFUCS_PACKED_SIZE 4
#define V3D_TFUSU_PACKED_SIZE 4
#define V3D_TFUICFG_PACKED_SIZE 4
#define V3D_TFUIIS_PACKED_SIZE 4
#define V3D_TFUIOA_PACKED_SIZE 4
#define V3D_TFUIOS_PACKED_SIZE 4
#define V3D_TFUCOEF0_PACKED_SIZE 4
#define V3D_TFUCOEF1_PACKED_SIZE 4
#define V3D_TFUCOEF2_PACKED_SIZE 4
#define V3D_TFUCOEF3_PACKED_SIZE 4
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_SRQPC_PACKED_SIZE 4
#endif
#define V3D_SRQCS_PACKED_SIZE 4
#define V3D_UIFCFG_PACKED_SIZE 4
#if V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_DRAM_MAP_VERSION_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_MISCCFG_PACKED_SIZE 4
#endif
#define V3D_L2T_CACTL_PACKED_SIZE 4
#if V3D_HAS_L2T_LOCAL_MEM
#define V3D_L2T_LOCAL_CTRL_PACKED_SIZE 4
#endif
#define V3D_MMU_CTRL_PACKED_SIZE 4
#define V3D_MMU_ADDR_CAP_PACKED_SIZE 4
#define V3D_MMU_BYPASS_PACKED_SIZE 4
#define V3D_MMU_ILLEGAL_PACKED_SIZE 4
#define V3D_MMU_DEBUG_INFO_PACKED_SIZE 4
#define V3D_MMUC_CONTROL_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_GMP_CFG_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_CFG_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_CFG_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_GMP_CS_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_STATUS_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_STATUS_PACKED_SIZE 4
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_GMP_VIO_TYPE_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_VIO_TYPE_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_GMP_VIO_TYPE_PACKED_SIZE 4
#endif
#define V3D_TSY_CONFIG0_PACKED_SIZE 4
#define V3D_TSY_CONFIG1_PACKED_SIZE 4
#define V3D_TSY_CONTROL_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TSY_STATUS_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_TSY_STATUS_PACKED_SIZE 4
#endif
#define V3D_TSY_TSO_DATA_PACKED_SIZE 4
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_STATUS_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG0_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG1_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG2_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG3_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG4_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG5_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG6_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_CFG_PACKED_SIZE 28
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_ID0_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_ID1_PACKED_SIZE 4
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CSD_ID_PACKED_SIZE 8
#endif
#define V3D_UMR_AXI_CONTROL_PACKED_SIZE 4
#define V3D_UMR_AXI_BURST_PACKED_SIZE 2
#define V3D_UMR_AXI_ID_PACKED_SIZE 2
#define V3D_UMR_AXI_STATUS_PACKED_SIZE 2
#define V3D_UMR_AXI_ERROR_PACKED_SIZE 2
#define V3D_UMR_AXI_FLAGS_PACKED_SIZE 2
#define V3D_UMR_AXI_FIFO_FLAGS_PACKED_SIZE 2
#define V3D_UMR_SYSMON_INFRA_STATUS_PACKED_SIZE 4
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_HAS_IMPLICIT_ATTR_DEFAULTS
extern void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_HAS_IMPLICIT_ATTR_DEFAULTS
extern void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_geom(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_tess(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_tess_or_geom(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_attr(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_gl_attr(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_vg(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_shadrec_vg(const uint32_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_unif_raw(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_unif_addr(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_param1_cfg0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_param1_cfg1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_param1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0) && !V3D_HAS_SAMPLER_LOD_DIS
extern void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_SAMPLER_LOD_DIS
extern void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_tmu_general_config(uint8_t packed0, struct v3d_printer *printer);
extern void v3d_print_tsy_config(uint8_t packed0, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_tlb_config(uint8_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_tlb_config(uint8_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_unif_branch(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_print_tmu_indirect(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_indirect(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_tex_state(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_tex_extension(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tmu_sampler(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tf_spec(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tf_spec(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0) && !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_indirect_indexed_record(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_indirect_arrays_record(const uint32_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_clip_record(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_clip_record(const uint32_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_autochain_link(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_ind_common(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_ind_common(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_serial(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_ind_generic(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_cl_compr_ind_tri(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_d3dpvsf_tri(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_cl_compr_ind_line(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_cl_compr_ind_line(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_cl_compr_ind_point(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,2,13,0)
extern void v3d_print_cl_compr_ind_point(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_xy_tri(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_cl_compr_xy_tri(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gs_vpm_fmt(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_bstc_block(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_HAS_L3C
extern void v3d_print_hub_ident0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_L3C
extern void v3d_print_hub_ident1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_L3C
extern void v3d_print_hub_ident2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_L3C
extern void v3d_print_hub_ident3(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_L3C
extern void v3d_print_hub_ident(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_HAS_L3C
extern void v3d_print_hub_ident0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_L3C
extern void v3d_print_hub_ident1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_L3C
extern void v3d_print_hub_ident2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_L3C
extern void v3d_print_hub_ident3(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_L3C
extern void v3d_print_hub_ident(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident3(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident3(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ident(const uint32_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_gs_inst_fifo_thrsh(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_gs_tess_fifo_thrsh(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_hub_intr(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_intr(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_intr(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ct0cs(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ct0cs(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_ct1cs(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ct1cfg(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ct1cfg(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_ct1tilect(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct1ptct(uint32_t packed0, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_ct0qts(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_pcs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfusu(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuicfg(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuiis(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuioa(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuios(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef0(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef1(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef2(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef3(uint32_t packed0, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_srqpc(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_srqcs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_uifcfg(uint32_t packed0, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_print_dram_map_version(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_misccfg(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_l2t_cactl(uint32_t packed0, struct v3d_printer *printer);
#if V3D_HAS_L2T_LOCAL_MEM
extern void v3d_print_l2t_local_ctrl(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_mmu_ctrl(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_addr_cap(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_bypass(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_illegal(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_debug_info(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmuc_control(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_print_gmp_cfg(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_cfg(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_cfg(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_print_gmp_cs(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_status(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_status(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_print_gmp_vio_type(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(3,3,0,0) && !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_vio_type(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_gmp_vio_type(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_tsy_config0(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tsy_config1(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tsy_control(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tsy_status(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_tsy_status(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_tsy_tso_data(uint32_t packed0, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_status(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg2(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg3(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg4(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg5(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg6(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_cfg(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_id0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_id1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_print_csd_id(const uint32_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_umr_axi_control(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_burst(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_id(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_status(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_error(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_flags(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_fifo_flags(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_sysmon_infra_status(uint32_t packed0, struct v3d_printer *printer);
#define V3D_CL_HALT_SIZE 1
#define V3D_CL_NOP_SIZE 1
#define V3D_CL_FLUSH_SIZE 1
#define V3D_CL_FLUSH_ALL_STATE_SIZE 1
#define V3D_CL_START_TILE_BINNING_SIZE 1
#define V3D_CL_INCR_SEMAPHORE_SIZE 1
#define V3D_CL_WAIT_SEMAPHORE_SIZE 1
#define V3D_CL_WAIT_PREV_FRAME_SIZE 1
#define V3D_CL_ENABLE_Z_ONLY_SIZE 1
#define V3D_CL_DISABLE_Z_ONLY_SIZE 1
#define V3D_CL_END_Z_ONLY_SIZE 1
#define V3D_CL_END_RENDER_SIZE 1
#define V3D_CL_WAIT_TRANSFORM_FEEDBACK_SIZE 2
#define V3D_CL_BRANCH_SIZE 5
#define V3D_CL_BRANCH_ADDR_OFFSET 1
#define V3D_CL_BRANCH_ADDR_SHIFT 0
#define V3D_CL_RETURN_SIZE 1
#define V3D_CL_CLEAR_VCD_CACHE_SIZE 1
#define V3D_CL_GENERIC_TILE_LIST_SIZE 9
#define V3D_CL_GENERIC_TILE_LIST_ADDR_OFFSET 1
#define V3D_CL_GENERIC_TILE_LIST_ADDR_SHIFT 0
#define V3D_CL_GENERIC_TILE_LIST_END_OFFSET 5
#define V3D_CL_GENERIC_TILE_LIST_END_SHIFT 0
#define V3D_CL_BRANCH_IMPLICIT_TILE_SIZE 2
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_SIZE 8
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_ADDR_OFFSET 4
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_ADDR_SHIFT 0
#define V3D_CL_SUPERTILE_COORDS_SIZE 3
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_CLEAR_SIZE 2
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_END_LOADS_SIZE 1
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_END_TILE_SIZE 1
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_STORE_SIZE 13
#define V3D_CL_STORE_ADDR_OFFSET 9
#define V3D_CL_STORE_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_LOAD_SIZE 13
#define V3D_CL_LOAD_ADDR_OFFSET 9
#define V3D_CL_LOAD_ADDR_SHIFT 0
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_STORE_SUBSAMPLE_SIZE 1
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_STORE_SUBSAMPLE_EX_SIZE 3
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_LOAD_SIZE 3
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_END_TILE_SIZE 1
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_STORE_GENERAL_SIZE 7
#define V3D_CL_STORE_GENERAL_ADDR_OFFSET 3
#define V3D_CL_STORE_GENERAL_ADDR_SHIFT 8
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_LOAD_GENERAL_SIZE 7
#define V3D_CL_LOAD_GENERAL_ADDR_OFFSET 3
#define V3D_CL_LOAD_GENERAL_ADDR_SHIFT 8
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TF_DRAW_FLUSH_AND_COUNT_SIZE 1
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDEXED_PRIM_LIST_SIZE 10
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDEXED_PRIM_LIST_SIZE 18
#define V3D_CL_INDEXED_PRIM_LIST_INDICES_ADDR_OFFSET 6
#define V3D_CL_INDEXED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_SIZE 11
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_OFFSET 6
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_SHIFT 0
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_SIZE 15
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_OFFSET 6
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_SHIFT 0
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDICES_ADDR_OFFSET 10
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_SIZE 14
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_SIZE 18
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_INDICES_ADDR_OFFSET 10
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#endif
#define V3D_CL_VERTEX_ARRAY_PRIMS_SIZE 10
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_SIZE 11
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_INDIRECT_ADDR_OFFSET 6
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_INDIRECT_ADDR_SHIFT 0
#define V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_SIZE 14
#define V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_SIZE 14
#define V3D_CL_BASE_VERTEX_BASE_INSTANCE_SIZE 9
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDEX_BUFFER_SETUP_SIZE 9
#define V3D_CL_INDEX_BUFFER_SETUP_ADDR_OFFSET 1
#define V3D_CL_INDEX_BUFFER_SETUP_ADDR_SHIFT 0
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_INDIRECT_PRIMITIVE_LIMITS_SIZE 12
#endif
#define V3D_CL_VG_COORD_ARRAY_PRIMS_SIZE 10
#define V3D_CL_VG_COORD_ARRAY_PRIMS_COORDS_ADDR_OFFSET 6
#define V3D_CL_VG_COORD_ARRAY_PRIMS_COORDS_ADDR_SHIFT 0
#define V3D_CL_VG_INLINE_PRIMS_SIZE 2
#define V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO_SIZE 1
#define V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID_SIZE 1
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_CLIPPED_PRIM_SIZE 5
#define V3D_CL_CLIPPED_PRIM_CLIP_NUM 3
#define V3D_CL_CLIPPED_PRIM_ADDR_OFFSET 1
#define V3D_CL_CLIPPED_PRIM_ADDR_SHIFT 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_SET_INSTANCE_ID_SIZE 5
#endif
#define V3D_CL_SET_PRIMITIVE_ID_SIZE 5
#define V3D_CL_PRIM_LIST_FORMAT_SIZE 2
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_SERIAL_NUMBER_LIST_START_SIZE 5
#define V3D_CL_SERIAL_NUMBER_LIST_START_ADDRESS_OFFSET 1
#define V3D_CL_SERIAL_NUMBER_LIST_START_ADDRESS_SHIFT 2
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_GL_SHADER_SIZE 5
#define V3D_CL_GL_SHADER_ADDR_OFFSET 1
#define V3D_CL_GL_SHADER_ADDR_SHIFT 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_GL_SHADER_SIZE 5
#define V3D_CL_GL_SHADER_ADDR_OFFSET 1
#define V3D_CL_GL_SHADER_ADDR_SHIFT 5
#endif
#define V3D_CL_VG_SHADER_SIZE 5
#define V3D_CL_VG_SHADER_ADDR_OFFSET 1
#define V3D_CL_VG_SHADER_ADDR_SHIFT 0
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VG_INLINE_SHADER_SIZE 9
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_OFFSET 1
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_SHIFT 3
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_OFFSET 5
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VG_INLINE_SHADER_SIZE 9
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_OFFSET 1
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_SHIFT 3
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_OFFSET 5
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VCM_CACHE_SIZE_SIZE 2
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_PRIM_COUNTS_FEEDBACK_SIZE 5
#define V3D_CL_PRIM_COUNTS_FEEDBACK_ADDR_OFFSET 1
#define V3D_CL_PRIM_COUNTS_FEEDBACK_ADDR_SHIFT 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TRANSFORM_FEEDBACK_BUFFER_SIZE 9
#define V3D_CL_TRANSFORM_FEEDBACK_BUFFER_BUFFER_ADDR_OFFSET 5
#define V3D_CL_TRANSFORM_FEEDBACK_BUFFER_BUFFER_ADDR_SHIFT 0
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TRANSFORM_FEEDBACK_SPECS_SIZE 2
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VCM_CACHE_SIZE_SIZE 2
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TRANSFORM_FEEDBACK_ENABLE_SIZE 3
#endif
#define V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA_SIZE 1
#define V3D_CL_CLEAR_SLICE_CACHES_SIZE 3
#define V3D_CL_FLUSH_L2T_SIZE 10
#define V3D_CL_FLUSH_L2T_START_ADDR_OFFSET 1
#define V3D_CL_FLUSH_L2T_START_ADDR_SHIFT 0
#define V3D_CL_FLUSH_L2T_END_ADDR_OFFSET 5
#define V3D_CL_FLUSH_L2T_END_ADDR_SHIFT 0
#if !V3D_VER_AT_LEAST(3,3,0,0)
#define V3D_CL_CLEAR_L2C_SIZE 1
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_CLEAN_L1TD_DEFERRED_SIZE 1
#endif
#define V3D_CL_STENCIL_CFG_SIZE 6
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_BLEND_CFG_SIZE 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_BLEND_ENABLES_SIZE 2
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_BLEND_CFG_SIZE 5
#endif
#define V3D_CL_BLEND_CCOLOR_SIZE 9
#define V3D_CL_COLOR_WMASKS_SIZE 5
#define V3D_CL_ZERO_ALL_CENTROID_FLAGS_SIZE 1
#define V3D_CL_ZERO_ALL_FLATSHADE_FLAGS_SIZE 1
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_ZERO_ALL_NOPERSPECTIVE_FLAGS_SIZE 1
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VARY_FLAGS_SIZE 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VARY_FLAGS_SIZE 5
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_SAMPLE_STATE_SIZE 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_SAMPLE_STATE_SIZE 5
#endif
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_SIZE 5
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_ADDR_OFFSET 1
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_ADDR_SHIFT 0
#define V3D_CL_CFG_BITS_SIZE 4
#define V3D_CL_POINT_SIZE_SIZE 5
#define V3D_CL_LINE_WIDTH_SIZE 5
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_DEPTH_OFFSET_SIZE 5
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_DEPTH_OFFSET_SIZE 9
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_CLIP_SIZE 9
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VIEWPORT_OFFSET_SIZE 9
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_CLIP_SIZE 9
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_VIEWPORT_OFFSET_SIZE 9
#endif
#define V3D_CL_CLIPZ_SIZE 9
#define V3D_CL_CLIPPER_XY_SIZE 9
#define V3D_CL_CLIPPER_Z_SIZE 9
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_NUM_LAYERS_SIZE 2
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TILE_BINNING_MODE_CFG_SIZE 9
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TILE_BINNING_MODE_CFG_SIZE 9
#define V3D_CL_TILE_BINNING_MODE_CFG_PART1_TILE_STATE_ADDR_OFFSET 1
#define V3D_CL_TILE_BINNING_MODE_CFG_PART1_TILE_STATE_ADDR_SHIFT 6
#define V3D_CL_TILE_BINNING_MODE_CFG_PART2_TILE_ALLOC_ADDR_OFFSET 5
#define V3D_CL_TILE_BINNING_MODE_CFG_PART2_TILE_ALLOC_ADDR_SHIFT 6
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TILE_RENDERING_MODE_CFG_SIZE 9
#define V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_RT_FORMATS_NUM 4
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
#define V3D_CL_TILE_RENDERING_MODE_CFG_SIZE 9
#define V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_ADDR_SHIFT 6
#define V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_ADDR_SHIFT 6
#define V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_ADDR_SHIFT 0
#endif
#define V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_SIZE 9
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_SIZE 5
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_ADDR_OFFSET 1
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_ADDR_SHIFT 6
#define V3D_CL_TILE_COORDS_SIZE 4
#define V3D_CL_IMPLICIT_TILE_COORDS_SIZE 1
#define V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_SIZE 2
#define V3D_CL_MAX_INSTR_SIZE 18
extern uint32_t v3d_cl_instr_size(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_bin(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_render(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_tile_list(v3d_cl_opcode_t opcode);
static inline void v3d_cl_halt(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_HALT);
}
static inline void v3d_cl_nop(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_NOP);
}
static inline void v3d_cl_flush(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH);
}
static inline void v3d_cl_flush_all_state(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_ALL_STATE);
}
static inline void v3d_cl_start_tile_binning(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_START_TILE_BINNING);
}
static inline void v3d_cl_incr_semaphore(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_INCR_SEMAPHORE);
}
static inline void v3d_cl_wait_semaphore(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_SEMAPHORE);
}
static inline void v3d_cl_wait_prev_frame(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_PREV_FRAME);
}
static inline void v3d_cl_enable_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ENABLE_Z_ONLY);
}
static inline void v3d_cl_disable_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_DISABLE_Z_ONLY);
}
static inline void v3d_cl_end_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_Z_ONLY);
}
static inline void v3d_cl_end_render(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_RENDER);
}
static inline void v3d_cl_wait_transform_feedback(uint8_t **cl,
   uint32_t num)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_TRANSFORM_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits(num, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_sub_autochain(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB_AUTOCHAIN);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_sub(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_return(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_RETURN);
}
static inline void v3d_cl_clear_vcd_cache(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR_VCD_CACHE);
}
static inline void v3d_cl_generic_tile_list(uint8_t **cl,
   v3d_addr_t addr,
   v3d_addr_t end)
{
   v3d_cl_add_8(cl, V3D_CL_GENERIC_TILE_LIST);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   (*cl)[4] = (uint8_t)end;
   (*cl)[5] = (uint8_t)(end >> 8);
   (*cl)[6] = (uint8_t)(end >> 16);
   (*cl)[7] = (uint8_t)(end >> 24);
   *cl += 8;
}
static inline void v3d_cl_branch_implicit_tile(uint8_t **cl,
   uint32_t set)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_IMPLICIT_TILE);
   (*cl)[0] = (uint8_t)gfx_bits(set, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_explicit_supertile(uint8_t **cl,
   uint32_t x,
   uint32_t y,
   uint32_t supertile,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_EXPLICIT_SUPERTILE);
   (*cl)[0] = (uint8_t)gfx_bits(x, 8);
   (*cl)[1] = (uint8_t)gfx_bits(y, 8);
   (*cl)[2] = (uint8_t)gfx_bits(supertile, 8);
   (*cl)[3] = (uint8_t)addr;
   (*cl)[4] = (uint8_t)(addr >> 8);
   (*cl)[5] = (uint8_t)(addr >> 16);
   (*cl)[6] = (uint8_t)(addr >> 24);
   *cl += 7;
}
static inline void v3d_cl_supertile_coords(uint8_t **cl,
   uint32_t x,
   uint32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_SUPERTILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits(x, 8);
   (*cl)[1] = (uint8_t)gfx_bits(y, 8);
   *cl += 2;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clear(uint8_t **cl,
   bool rts,
   bool depth_stencil)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR);
   (*cl)[0] = (uint8_t)gfx_bits(rts, 1) |
      (uint8_t)(gfx_bits(depth_stencil, 1) << 1) | (uint8_t)0;
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_end_loads(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_LOADS);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_end_tile(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_TILE);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   v3d_memory_format_t memory_format,
   bool flipy,
   v3d_dither_t dither,
   v3d_decimate_t decimate,
   v3d_pixel_format_t pixel_format,
   bool clear,
   bool chan_reverse,
   bool rb_swap,
   uint32_t stride,
   uint32_t height,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_STORE);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(memory_format, 3) << 4) | (uint8_t)(gfx_bits(flipy, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(dither, 2) |
      (uint8_t)(gfx_bits(decimate, 2) << 2) |
      (uint8_t)(gfx_bits(pixel_format, 6) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits(pixel_format, 6) >> 4) |
      (uint8_t)(gfx_bits(clear, 1) << 2) |
      (uint8_t)(gfx_bits(chan_reverse, 1) << 3) |
      (uint8_t)(gfx_bits(rb_swap, 1) << 4) | (uint8_t)0;
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits(stride, 20) << 4);
   (*cl)[4] = (uint8_t)(gfx_bits(stride, 20) >> 4);
   (*cl)[5] = (uint8_t)(gfx_bits(stride, 20) >> 12);
   (*cl)[6] = (uint8_t)gfx_bits(height, 16);
   (*cl)[7] = (uint8_t)(gfx_bits(height, 16) >> 8);
   (*cl)[8] = (uint8_t)addr;
   (*cl)[9] = (uint8_t)(addr >> 8);
   (*cl)[10] = (uint8_t)(addr >> 16);
   (*cl)[11] = (uint8_t)(addr >> 24);
   *cl += 12;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   v3d_memory_format_t memory_format,
   bool flipy,
   v3d_decimate_t decimate,
   v3d_pixel_format_t pixel_format,
   bool alpha_to_one,
   bool chan_reverse,
   bool rb_swap,
   uint32_t stride,
   uint32_t height,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(memory_format, 3) << 4) | (uint8_t)(gfx_bits(flipy, 1) << 7);
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(decimate, 2) << 2) |
      (uint8_t)(gfx_bits(pixel_format, 6) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits(pixel_format, 6) >> 4) |
      (uint8_t)(gfx_bits(alpha_to_one, 1) << 2) |
      (uint8_t)(gfx_bits(chan_reverse, 1) << 3) |
      (uint8_t)(gfx_bits(rb_swap, 1) << 4) | (uint8_t)0;
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits(stride, 20) << 4);
   (*cl)[4] = (uint8_t)(gfx_bits(stride, 20) >> 4);
   (*cl)[5] = (uint8_t)(gfx_bits(stride, 20) >> 12);
   (*cl)[6] = (uint8_t)gfx_bits(height, 16);
   (*cl)[7] = (uint8_t)(gfx_bits(height, 16) >> 8);
   (*cl)[8] = (uint8_t)addr;
   (*cl)[9] = (uint8_t)(addr >> 8);
   (*cl)[10] = (uint8_t)(addr >> 16);
   (*cl)[11] = (uint8_t)(addr >> 24);
   *cl += 12;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_subsample(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_subsample_ex(uint8_t **cl,
   bool eof,
   bool disable_owo_or_double_buf_swap,
   bool disable_depth_clear,
   bool disable_stencil_clear,
   bool disable_color_clear,
   bool stencil_store,
   bool depth_store,
   uint32_t disable_rt_store_mask)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE_EX);
   (*cl)[0] = (uint8_t)gfx_bits(eof, 1) |
      (uint8_t)(gfx_bits(disable_owo_or_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits(disable_depth_clear, 1) << 2) |
      (uint8_t)(gfx_bits(disable_stencil_clear, 1) << 3) |
      (uint8_t)(gfx_bits(disable_color_clear, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits(stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits(depth_store, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(disable_rt_store_mask, 8);
   *cl += 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load(uint8_t **cl,
   bool stencil_load,
   bool depth_load,
   uint32_t disable_rt_load_mask)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits(stencil_load, 1) << 6) |
      (uint8_t)(gfx_bits(depth_load, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(disable_rt_load_mask, 8);
   *cl += 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_end_tile(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_TILE);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_general(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   bool raw_mode,
   bool disable_depth_clear,
   bool disable_stencil_clear,
   bool disable_color_clear,
   bool eof,
   bool disable_double_buf_swap,
   v3d_ldst_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(raw_mode, 1) << 4) |
      (uint8_t)(gfx_bits(disable_depth_clear, 1) << 5) |
      (uint8_t)(gfx_bits(disable_stencil_clear, 1) << 6) |
      (uint8_t)(gfx_bits(disable_color_clear, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(eof, 1) |
      (uint8_t)(gfx_bits(disable_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits(memory_format, 1) << 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr(addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 16);
   *cl += 6;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load_general(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   bool raw_mode,
   v3d_ldst_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(raw_mode, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(memory_format, 1) << 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr(addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 16);
   *cl += 6;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tf_draw_flush_and_count(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_TF_DRAW_FLUSH_AND_COUNT);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   bool prim_restart,
   uint32_t indices_offset)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(num_indices, 31);
   (*cl)[2] = (uint8_t)(gfx_bits(num_indices, 31) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(num_indices, 31) >> 16);
   (*cl)[4] = (uint8_t)(gfx_bits(num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)indices_offset;
   (*cl)[6] = (uint8_t)(indices_offset >> 8);
   (*cl)[7] = (uint8_t)(indices_offset >> 16);
   (*cl)[8] = (uint8_t)(indices_offset >> 24);
   *cl += 9;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   v3d_addr_t indices_addr,
   uint32_t max_index,
   bool prim_restart,
   uint32_t min_index)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)num_indices;
   (*cl)[2] = (uint8_t)(num_indices >> 8);
   (*cl)[3] = (uint8_t)(num_indices >> 16);
   (*cl)[4] = (uint8_t)(num_indices >> 24);
   (*cl)[5] = (uint8_t)indices_addr;
   (*cl)[6] = (uint8_t)(indices_addr >> 8);
   (*cl)[7] = (uint8_t)(indices_addr >> 16);
   (*cl)[8] = (uint8_t)(indices_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(max_index, 31);
   (*cl)[10] = (uint8_t)(gfx_bits(max_index, 31) >> 8);
   (*cl)[11] = (uint8_t)(gfx_bits(max_index, 31) >> 16);
   (*cl)[12] = (uint8_t)(gfx_bits(max_index, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[13] = (uint8_t)min_index;
   (*cl)[14] = (uint8_t)(min_index >> 8);
   (*cl)[15] = (uint8_t)(min_index >> 16);
   (*cl)[16] = (uint8_t)(min_index >> 24);
   *cl += 17;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indirect,
   bool prim_restart,
   v3d_addr_t indirect_addr,
   uint32_t indirect_stride)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange(num_indirect, 1, 0x7fffffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)indirect_addr;
   (*cl)[6] = (uint8_t)(indirect_addr >> 8);
   (*cl)[7] = (uint8_t)(indirect_addr >> 16);
   (*cl)[8] = (uint8_t)(indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr(indirect_stride, 2), 8);
   *cl += 10;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indirect,
   bool prim_restart,
   v3d_addr_t indirect_addr,
   v3d_addr_t indices_addr,
   uint32_t indirect_stride)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange(num_indirect, 1, 0x7fffffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)indirect_addr;
   (*cl)[6] = (uint8_t)(indirect_addr >> 8);
   (*cl)[7] = (uint8_t)(indirect_addr >> 16);
   (*cl)[8] = (uint8_t)(indirect_addr >> 24);
   (*cl)[9] = (uint8_t)indices_addr;
   (*cl)[10] = (uint8_t)(indices_addr >> 8);
   (*cl)[11] = (uint8_t)(indices_addr >> 16);
   (*cl)[12] = (uint8_t)(indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(gfx_exact_lsr(indirect_stride, 2), 8);
   *cl += 14;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_instanced_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   bool prim_restart,
   uint32_t num_instances,
   uint32_t indices_offset)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(num_indices, 31);
   (*cl)[2] = (uint8_t)(gfx_bits(num_indices, 31) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(num_indices, 31) >> 16);
   (*cl)[4] = (uint8_t)(gfx_bits(num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)num_instances;
   (*cl)[6] = (uint8_t)(num_instances >> 8);
   (*cl)[7] = (uint8_t)(num_instances >> 16);
   (*cl)[8] = (uint8_t)(num_instances >> 24);
   (*cl)[9] = (uint8_t)indices_offset;
   (*cl)[10] = (uint8_t)(indices_offset >> 8);
   (*cl)[11] = (uint8_t)(indices_offset >> 16);
   (*cl)[12] = (uint8_t)(indices_offset >> 24);
   *cl += 13;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_instanced_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   uint32_t num_instances,
   v3d_addr_t indices_addr,
   uint32_t max_index,
   bool prim_restart)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)num_indices;
   (*cl)[2] = (uint8_t)(num_indices >> 8);
   (*cl)[3] = (uint8_t)(num_indices >> 16);
   (*cl)[4] = (uint8_t)(num_indices >> 24);
   (*cl)[5] = (uint8_t)num_instances;
   (*cl)[6] = (uint8_t)(num_instances >> 8);
   (*cl)[7] = (uint8_t)(num_instances >> 16);
   (*cl)[8] = (uint8_t)(num_instances >> 24);
   (*cl)[9] = (uint8_t)indices_addr;
   (*cl)[10] = (uint8_t)(indices_addr >> 8);
   (*cl)[11] = (uint8_t)(indices_addr >> 16);
   (*cl)[12] = (uint8_t)(indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits(max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits(max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits(max_index, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   *cl += 17;
}
#endif
static inline void v3d_cl_vertex_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)first_index;
   (*cl)[6] = (uint8_t)(first_index >> 8);
   (*cl)[7] = (uint8_t)(first_index >> 16);
   (*cl)[8] = (uint8_t)(first_index >> 24);
   *cl += 9;
}
static inline void v3d_cl_indirect_vertex_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_indirect,
   v3d_addr_t indirect_addr,
   uint32_t indirect_stride)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_check_urange(num_indirect, 1, 0xffffffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 8);
   (*cl)[3] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 16);
   (*cl)[4] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 24);
   (*cl)[5] = (uint8_t)indirect_addr;
   (*cl)[6] = (uint8_t)(indirect_addr >> 8);
   (*cl)[7] = (uint8_t)(indirect_addr >> 16);
   (*cl)[8] = (uint8_t)(indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr(indirect_stride, 2), 8);
   *cl += 10;
}
static inline void v3d_cl_vertex_array_instanced_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t num_instances,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)num_instances;
   (*cl)[6] = (uint8_t)(num_instances >> 8);
   (*cl)[7] = (uint8_t)(num_instances >> 16);
   (*cl)[8] = (uint8_t)(num_instances >> 24);
   (*cl)[9] = (uint8_t)first_index;
   (*cl)[10] = (uint8_t)(first_index >> 8);
   (*cl)[11] = (uint8_t)(first_index >> 16);
   (*cl)[12] = (uint8_t)(first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_vertex_array_single_instance_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t instance_id,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)instance_id;
   (*cl)[6] = (uint8_t)(instance_id >> 8);
   (*cl)[7] = (uint8_t)(instance_id >> 16);
   (*cl)[8] = (uint8_t)(instance_id >> 24);
   (*cl)[9] = (uint8_t)first_index;
   (*cl)[10] = (uint8_t)(first_index >> 8);
   (*cl)[11] = (uint8_t)(first_index >> 16);
   (*cl)[12] = (uint8_t)(first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_base_vertex_base_instance(uint8_t **cl,
   int32_t base_vertex,
   uint32_t base_instance)
{
   v3d_cl_add_8(cl, V3D_CL_BASE_VERTEX_BASE_INSTANCE);
   (*cl)[0] = (uint8_t)(uint32_t)base_vertex;
   (*cl)[1] = (uint8_t)((uint32_t)base_vertex >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)base_vertex >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)base_vertex >> 24);
   (*cl)[4] = (uint8_t)base_instance;
   (*cl)[5] = (uint8_t)(base_instance >> 8);
   (*cl)[6] = (uint8_t)(base_instance >> 16);
   (*cl)[7] = (uint8_t)(base_instance >> 24);
   *cl += 8;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_index_buffer_setup(uint8_t **cl,
   v3d_addr_t addr,
   uint32_t size)
{
   v3d_cl_add_8(cl, V3D_CL_INDEX_BUFFER_SETUP);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   (*cl)[4] = (uint8_t)size;
   (*cl)[5] = (uint8_t)(size >> 8);
   (*cl)[6] = (uint8_t)(size >> 16);
   (*cl)[7] = (uint8_t)(size >> 24);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_primitive_limits(uint8_t **cl,
   uint32_t max_index,
   uint32_t max_instance,
   uint32_t index_buffer_size)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_PRIMITIVE_LIMITS);
   (*cl)[0] = (uint8_t)gfx_bits(max_index, 24);
   (*cl)[1] = (uint8_t)(gfx_bits(max_index, 24) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits(max_index, 24) >> 16);
   (*cl)[3] = (uint8_t)max_instance;
   (*cl)[4] = (uint8_t)(max_instance >> 8);
   (*cl)[5] = (uint8_t)(max_instance >> 16);
   (*cl)[6] = (uint8_t)(max_instance >> 24);
   (*cl)[7] = (uint8_t)index_buffer_size;
   (*cl)[8] = (uint8_t)(index_buffer_size >> 8);
   (*cl)[9] = (uint8_t)(index_buffer_size >> 16);
   (*cl)[10] = (uint8_t)(index_buffer_size >> 24);
   *cl += 11;
}
#endif
static inline void v3d_cl_vg_coord_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   bool continuation,
   uint32_t num_vertices,
   v3d_addr_t coords_addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_COORD_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 4) |
      (uint8_t)(gfx_bits(continuation, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)coords_addr;
   (*cl)[6] = (uint8_t)(coords_addr >> 8);
   (*cl)[7] = (uint8_t)(coords_addr >> 16);
   (*cl)[8] = (uint8_t)(coords_addr >> 24);
   *cl += 9;
}
static inline void v3d_cl_vg_inline_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   bool continuation)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 4) |
      (uint8_t)(gfx_bits(continuation, 1) << 4) | (uint8_t)0;
   *cl += 1;
}
static inline void v3d_cl_compressed_prim_list_iid_zero(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO);
}
static inline void v3d_cl_compressed_prim_list_current_iid(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID);
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clipped_prim_iid_zero(uint8_t **cl,
   bool clip_0,
   bool clip_1,
   bool clip_2,
   bool flat_zw,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_IID_ZERO);
   (*cl)[0] = (uint8_t)gfx_bits(clip_0, 1) | (uint8_t)(gfx_bits(clip_1, 1) << 1) |
      (uint8_t)(gfx_bits(clip_2, 1) << 2) | (uint8_t)(gfx_bits(flat_zw, 1) << 3) |
      (uint8_t)0 | (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_clipped_prim_current_iid(uint8_t **cl,
   bool clip_0,
   bool clip_1,
   bool clip_2,
   bool flat_zw,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_CURRENT_IID);
   (*cl)[0] = (uint8_t)gfx_bits(clip_0, 1) | (uint8_t)(gfx_bits(clip_1, 1) << 1) |
      (uint8_t)(gfx_bits(clip_2, 1) << 2) | (uint8_t)(gfx_bits(flat_zw, 1) << 3) |
      (uint8_t)0 | (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_set_instance_id(uint8_t **cl,
   uint32_t instance_id)
{
   v3d_cl_add_8(cl, V3D_CL_SET_INSTANCE_ID);
   (*cl)[0] = (uint8_t)instance_id;
   (*cl)[1] = (uint8_t)(instance_id >> 8);
   (*cl)[2] = (uint8_t)(instance_id >> 16);
   (*cl)[3] = (uint8_t)(instance_id >> 24);
   *cl += 4;
}
#endif
static inline void v3d_cl_set_primitive_id(uint8_t **cl,
   uint32_t initial_prim_id)
{
   v3d_cl_add_8(cl, V3D_CL_SET_PRIMITIVE_ID);
   (*cl)[0] = (uint8_t)initial_prim_id;
   (*cl)[1] = (uint8_t)(initial_prim_id >> 8);
   (*cl)[2] = (uint8_t)(initial_prim_id >> 16);
   (*cl)[3] = (uint8_t)(initial_prim_id >> 24);
   *cl += 4;
}
static inline void v3d_cl_prim_list_format(uint8_t **cl,
   uint32_t n_verts,
   bool xy,
   bool d3dpvsf)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_LIST_FORMAT);
   (*cl)[0] =
      (uint8_t)gfx_pack_uint_minus_1(gfx_check_urange(n_verts, 1, 32), 6) |
      (uint8_t)(gfx_bits(xy, 1) << 6) | (uint8_t)(gfx_bits(d3dpvsf, 1) << 7);
   *cl += 1;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_serial_number_list_start(uint8_t **cl,
   v3d_tile_alloc_block_size_t initial_block_size,
   v3d_addr_t address)
{
   v3d_cl_add_8(cl, V3D_CL_SERIAL_NUMBER_LIST_START);
   (*cl)[0] = (uint8_t)gfx_bits(initial_block_size, 2) |
      (uint8_t)(gfx_exact_lsr(address, 2) << 2);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(address, 2) >> 6);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(address, 2) >> 14);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(address, 2) >> 22);
   *cl += 4;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_gl_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_gl_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_t_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_T_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_g_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_G_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_tg_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_TG_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
#endif
static inline void v3d_cl_vg_shader(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_SHADER);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vg_inline_shader(uint8_t **cl,
   v3d_threading_t fs_threading,
   bool fs_propagate_nans,
   v3d_addr_t fs_addr,
   v3d_addr_t fs_unifs_addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits(fs_threading, 2) |
      (uint8_t)(gfx_bits(fs_propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr(fs_addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 21);
   (*cl)[4] = (uint8_t)fs_unifs_addr;
   (*cl)[5] = (uint8_t)(fs_unifs_addr >> 8);
   (*cl)[6] = (uint8_t)(fs_unifs_addr >> 16);
   (*cl)[7] = (uint8_t)(fs_unifs_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vg_inline_shader(uint8_t **cl,
   v3d_threading_t fs_threading,
   bool fs_single_seg,
   bool fs_propagate_nans,
   v3d_addr_t fs_addr,
   v3d_addr_t fs_unifs_addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits(fs_threading, 1) |
      (uint8_t)(gfx_bits(fs_single_seg, 1) << 1) |
      (uint8_t)(gfx_bits(fs_propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr(fs_addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 21);
   (*cl)[4] = (uint8_t)fs_unifs_addr;
   (*cl)[5] = (uint8_t)(fs_unifs_addr >> 8);
   (*cl)[6] = (uint8_t)(fs_unifs_addr >> 16);
   (*cl)[7] = (uint8_t)(fs_unifs_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vcm_cache_size(uint8_t **cl,
   uint32_t num_batches_bin,
   uint32_t num_batches_render)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange(num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange(num_batches_render, 1, 4) << 4);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_prim_counts_feedback(uint8_t **cl,
   v3d_pcf_operation_t operation,
   bool rw64,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_COUNTS_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits(operation, 4) |
      (uint8_t)(gfx_bits(rw64, 1) << 4) | (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_buffer(uint8_t **cl,
   uint32_t buffer_num,
   uint32_t size_words,
   v3d_addr_t buffer_addr)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_BUFFER);
   (*cl)[0] = (uint8_t)gfx_check_urange(buffer_num, 0, 3) |
      (uint8_t)(gfx_bits(size_words, 30) << 2);
   (*cl)[1] = (uint8_t)(gfx_bits(size_words, 30) >> 6);
   (*cl)[2] = (uint8_t)(gfx_bits(size_words, 30) >> 14);
   (*cl)[3] = (uint8_t)(gfx_bits(size_words, 30) >> 22);
   (*cl)[4] = (uint8_t)buffer_addr;
   (*cl)[5] = (uint8_t)(buffer_addr >> 8);
   (*cl)[6] = (uint8_t)(buffer_addr >> 16);
   (*cl)[7] = (uint8_t)(buffer_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_specs(uint8_t **cl,
   uint32_t num_specs,
   bool enable)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_SPECS);
   (*cl)[0] = (uint8_t)gfx_check_urange(num_specs, 0, 16) | (uint8_t)0 |
      (uint8_t)(gfx_bits(enable, 1) << 7);
   *cl += 1;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vcm_cache_size(uint8_t **cl,
   uint32_t num_batches_bin,
   uint32_t num_batches_render)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange(num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange(num_batches_render, 1, 4) << 4);
   *cl += 1;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_enable(uint8_t **cl,
   uint32_t id,
   uint32_t num_addrs,
   uint32_t num_specs)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_ENABLE);
   (*cl)[0] = (uint8_t)gfx_bits(id, 8);
   (*cl)[1] = (uint8_t)gfx_check_urange(num_addrs, 0, 4) |
      (uint8_t)(gfx_check_urange(num_specs, 1, 16) << 3);
   *cl += 2;
}
#endif
static inline void v3d_cl_flush_transform_feedback_data(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA);
}
static inline void v3d_cl_clear_slice_caches(uint8_t **cl,
   uint32_t sic,
   uint32_t suc,
   uint32_t l1td,
   uint32_t l1tc)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR_SLICE_CACHES);
   (*cl)[0] = (uint8_t)gfx_bits(sic, 4) | (uint8_t)(gfx_bits(suc, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(l1td, 4) | (uint8_t)(gfx_bits(l1tc, 4) << 4);
   *cl += 2;
}
static inline void v3d_cl_flush_l2t(uint8_t **cl,
   v3d_addr_t start_addr,
   v3d_addr_t end_addr,
   v3d_l2t_flush_mode_t mode,
   bool deferred)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_L2T);
   (*cl)[0] = (uint8_t)start_addr;
   (*cl)[1] = (uint8_t)(start_addr >> 8);
   (*cl)[2] = (uint8_t)(start_addr >> 16);
   (*cl)[3] = (uint8_t)(start_addr >> 24);
   (*cl)[4] = (uint8_t)end_addr;
   (*cl)[5] = (uint8_t)(end_addr >> 8);
   (*cl)[6] = (uint8_t)(end_addr >> 16);
   (*cl)[7] = (uint8_t)(end_addr >> 24);
   (*cl)[8] = (uint8_t)gfx_bits(mode, 2) | (uint8_t)(gfx_bits(deferred, 1) << 2) |
      (uint8_t)0;
   *cl += 9;
}
#if !V3D_VER_AT_LEAST(3,3,0,0)
static inline void v3d_cl_clear_l2c(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR_L2C);
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clean_l1td_deferred(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAN_L1TD_DEFERRED);
}
#endif
static inline void v3d_cl_stencil_cfg(uint8_t **cl,
   uint32_t reference,
   uint32_t mask,
   v3d_compare_func_t func,
   v3d_stencil_op_t fail_op,
   v3d_stencil_op_t depth_fail_op,
   v3d_stencil_op_t pass_op,
   bool front_cfg,
   bool back_cfg,
   uint32_t write_mask)
{
   v3d_cl_add_8(cl, V3D_CL_STENCIL_CFG);
   (*cl)[0] = (uint8_t)gfx_bits(reference, 8);
   (*cl)[1] = (uint8_t)gfx_bits(mask, 8);
   (*cl)[2] = (uint8_t)gfx_bits(func, 3) | (uint8_t)(gfx_bits(fail_op, 3) << 3) |
      (uint8_t)(gfx_bits(depth_fail_op, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(depth_fail_op, 3) >> 2) |
      (uint8_t)(gfx_bits(pass_op, 3) << 1) | (uint8_t)(gfx_bits(front_cfg, 1) << 4) |
      (uint8_t)(gfx_bits(back_cfg, 1) << 5) | (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_bits(write_mask, 8);
   *cl += 5;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_cfg(uint8_t **cl,
   v3d_blend_eqn_t a_eqn,
   v3d_blend_mul_t a_src,
   v3d_blend_mul_t a_dst,
   v3d_blend_eqn_t c_eqn,
   v3d_blend_mul_t c_src,
   v3d_blend_mul_t c_dst,
   v3d_blend_vg_mode_t vg_mode)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits(a_eqn, 4) | (uint8_t)(gfx_bits(a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(a_dst, 4) | (uint8_t)(gfx_bits(c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits(c_src, 4) | (uint8_t)(gfx_bits(c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits(vg_mode, 2) << 4) | (uint8_t)0;
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_enables(uint8_t **cl,
   uint32_t rt_enable_mask)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_ENABLES);
   (*cl)[0] = (uint8_t)gfx_bits(rt_enable_mask, 8);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_cfg(uint8_t **cl,
   v3d_blend_eqn_t a_eqn,
   v3d_blend_mul_t a_src,
   v3d_blend_mul_t a_dst,
   v3d_blend_eqn_t c_eqn,
   v3d_blend_mul_t c_src,
   v3d_blend_mul_t c_dst,
   uint32_t rt_mask,
   v3d_blend_vg_mode_t vg_mode)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits(a_eqn, 4) | (uint8_t)(gfx_bits(a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(a_dst, 4) | (uint8_t)(gfx_bits(c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits(c_src, 4) | (uint8_t)(gfx_bits(c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)gfx_bits(rt_mask, 4) |
      (uint8_t)(gfx_bits(vg_mode, 2) << 4) | (uint8_t)0;
   *cl += 4;
}
#endif
static inline void v3d_cl_blend_ccolor(uint8_t **cl,
   float r,
   float g,
   float b,
   float a)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CCOLOR);
   (*cl)[0] = (uint8_t)gfx_float_to_float16(r);
   (*cl)[1] = (uint8_t)(gfx_float_to_float16(r) >> 8);
   (*cl)[2] = (uint8_t)gfx_float_to_float16(g);
   (*cl)[3] = (uint8_t)(gfx_float_to_float16(g) >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_float16(b);
   (*cl)[5] = (uint8_t)(gfx_float_to_float16(b) >> 8);
   (*cl)[6] = (uint8_t)gfx_float_to_float16(a);
   (*cl)[7] = (uint8_t)(gfx_float_to_float16(a) >> 8);
   *cl += 8;
}
static inline void v3d_cl_color_wmasks(uint8_t **cl,
   uint32_t w_disable_mask)
{
   v3d_cl_add_8(cl, V3D_CL_COLOR_WMASKS);
   (*cl)[0] = (uint8_t)gfx_check_urange(w_disable_mask, 0, 0xffff);
   (*cl)[1] = (uint8_t)(gfx_check_urange(w_disable_mask, 0, 0xffff) >> 8);
   (*cl)[2] = (uint8_t)(gfx_check_urange(w_disable_mask, 0, 0xffff) >> 16);
   (*cl)[3] = (uint8_t)(gfx_check_urange(w_disable_mask, 0, 0xffff) >> 24);
   *cl += 4;
}
static inline void v3d_cl_zero_all_centroid_flags(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ZERO_ALL_CENTROID_FLAGS);
}
static inline void v3d_cl_zero_all_flatshade_flags(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ZERO_ALL_FLATSHADE_FLAGS);
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_zero_all_noperspective_flags(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ZERO_ALL_NOPERSPECTIVE_FLAGS);
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_centroid_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_centroid_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_noperspective_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_NOPERSPECTIVE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_sample_state(uint8_t **cl,
   float coverage)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_STATE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(coverage);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(coverage) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(coverage) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(coverage) >> 24);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_sample_state(uint8_t **cl,
   uint32_t mask,
   float coverage)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_STATE);
   (*cl)[0] = (uint8_t)gfx_bits(mask, 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0;
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(coverage) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(coverage) >> 16 >> 8);
   *cl += 4;
}
#endif
static inline void v3d_cl_occlusion_query_counter_enable(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_cfg_bits(uint8_t **cl,
   bool front_prims,
   bool back_prims,
   bool cwise_is_front,
   bool depth_offset,
   bool aa_lines,
   v3d_ms_t rast_oversample,
   bool cov_pipe,
   v3d_cov_update_t cov_update,
   bool wireframe_tris,
   v3d_compare_func_t depth_test,
   bool depth_update,
   bool ez,
   bool ez_update,
   bool stencil,
   bool blend,
   v3d_wireframe_mode_t wireframe_mode,
   bool d3d_prov_vtx)
{
   v3d_cl_add_8(cl, V3D_CL_CFG_BITS);
   (*cl)[0] = (uint8_t)gfx_bits(front_prims, 1) |
      (uint8_t)(gfx_bits(back_prims, 1) << 1) |
      (uint8_t)(gfx_bits(cwise_is_front, 1) << 2) |
      (uint8_t)(gfx_bits(depth_offset, 1) << 3) |
      (uint8_t)(gfx_bits(aa_lines, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits(rast_oversample, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(cov_pipe, 1) |
      (uint8_t)(gfx_bits(cov_update, 2) << 1) |
      (uint8_t)(gfx_bits(wireframe_tris, 1) << 3) |
      (uint8_t)(gfx_bits(depth_test, 3) << 4) |
      (uint8_t)(gfx_bits(depth_update, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits(ez, 1) | (uint8_t)(gfx_bits(ez_update, 1) << 1) |
      (uint8_t)(gfx_bits(stencil, 1) << 2) | (uint8_t)(gfx_bits(blend, 1) << 3) |
      (uint8_t)(gfx_bits(wireframe_mode, 1) << 4) |
      (uint8_t)(gfx_bits(d3d_prov_vtx, 1) << 5) | (uint8_t)0;
   *cl += 3;
}
static inline void v3d_cl_point_size(uint8_t **cl,
   float point_size)
{
   v3d_cl_add_8(cl, V3D_CL_POINT_SIZE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(point_size);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(point_size) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(point_size) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(point_size) >> 24);
   *cl += 4;
}
static inline void v3d_cl_line_width(uint8_t **cl,
   float line_width)
{
   v3d_cl_add_8(cl, V3D_CL_LINE_WIDTH);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(line_width);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(line_width) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(line_width) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(line_width) >> 24);
   *cl += 4;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_depth_offset(uint8_t **cl,
   float factor,
   float units)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits(factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(units) >> 16 >> 8);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_depth_offset(uint8_t **cl,
   float factor,
   float units,
   float limit)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits(factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(units) >> 16 >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(limit);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(limit) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(limit) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(limit) >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clip(uint8_t **cl,
   uint32_t x,
   uint32_t y,
   uint32_t width,
   uint32_t height)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits(x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits(y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits(y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange(width, 0, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange(width, 0, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange(height, 0, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange(height, 0, 0x1000) >> 8);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_viewport_offset(uint8_t **cl,
   uint32_t x,
   int32_t coarse_x,
   uint32_t y,
   int32_t coarse_y)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)gfx_bits(x, 22);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 22) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits(x, 22) >> 16) |
      (uint8_t)(gfx_pack_sint(coarse_x, 10) << 6);
   (*cl)[3] = (uint8_t)(gfx_pack_sint(coarse_x, 10) >> 2);
   (*cl)[4] = (uint8_t)gfx_bits(y, 22);
   (*cl)[5] = (uint8_t)(gfx_bits(y, 22) >> 8);
   (*cl)[6] = (uint8_t)(gfx_bits(y, 22) >> 16) |
      (uint8_t)(gfx_pack_sint(coarse_y, 10) << 6);
   (*cl)[7] = (uint8_t)(gfx_pack_sint(coarse_y, 10) >> 2);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clip(uint8_t **cl,
   uint32_t x,
   uint32_t y,
   uint32_t width,
   uint32_t height)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits(x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits(y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits(y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange(width, 1, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange(width, 1, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange(height, 1, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange(height, 1, 0x1000) >> 8);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_viewport_offset(uint8_t **cl,
   int32_t x,
   int32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)(uint32_t)x;
   (*cl)[1] = (uint8_t)((uint32_t)x >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)x >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)x >> 24);
   (*cl)[4] = (uint8_t)(uint32_t)y;
   (*cl)[5] = (uint8_t)((uint32_t)y >> 8);
   (*cl)[6] = (uint8_t)((uint32_t)y >> 16);
   (*cl)[7] = (uint8_t)((uint32_t)y >> 24);
   *cl += 8;
}
#endif
static inline void v3d_cl_clipz(uint8_t **cl,
   float min,
   float max)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPZ);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(min);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(min) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(min) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(min) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(max);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(max) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(max) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(max) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_xy(uint8_t **cl,
   float scale_x,
   float scale_y)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_XY);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(scale_x);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(scale_x) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(scale_x) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(scale_x) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(scale_y);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(scale_y) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(scale_y) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(scale_y) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_z(uint8_t **cl,
   float scale,
   float offset)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_Z);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(scale);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(scale) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(scale) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(scale) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(offset);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(offset) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(offset) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(offset) >> 24);
   *cl += 8;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_num_layers(uint8_t **cl,
   uint32_t num_layers)
{
   v3d_cl_add_8(cl, V3D_CL_NUM_LAYERS);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1(num_layers, 8);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_binning_mode_cfg(uint8_t **cl,
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size,
   v3d_tile_alloc_block_size_t tile_alloc_block_size,
   uint32_t num_rts,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer,
   uint32_t w_in_pixels,
   uint32_t h_in_pixels)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 |
      (uint8_t)(gfx_bits(tile_alloc_initial_block_size, 2) << 2) |
      (uint8_t)(gfx_bits(tile_alloc_block_size, 2) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1(gfx_check_urange(num_rts, 1, 4), 4) |
      (uint8_t)(gfx_bits(max_bpp, 2) << 4) | (uint8_t)(gfx_bits(ms_mode, 1) << 6) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 7);
   (*cl)[2] = (uint8_t)0;
   (*cl)[3] = (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_pack_uint_minus_1(w_in_pixels, 16);
   (*cl)[5] = (uint8_t)(gfx_pack_uint_minus_1(w_in_pixels, 16) >> 8);
   (*cl)[6] = (uint8_t)gfx_pack_uint_minus_1(h_in_pixels, 16);
   (*cl)[7] = (uint8_t)(gfx_pack_uint_minus_1(h_in_pixels, 16) >> 8);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_binning_mode_cfg_part1(uint8_t **cl,
   bool auto_init_tile_state,
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size,
   v3d_tile_alloc_block_size_t tile_alloc_block_size,
   v3d_addr_t tile_state_addr,
   uint32_t w_in_tiles,
   uint32_t h_in_tiles,
   uint32_t num_rts,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits(auto_init_tile_state, 1) << 1) |
      (uint8_t)(gfx_bits(tile_alloc_initial_block_size, 2) << 2) |
      (uint8_t)(gfx_bits(tile_alloc_block_size, 2) << 4) |
      (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 18);
   (*cl)[4] = (uint8_t)gfx_check_urange(w_in_tiles, 1, 0xfff);
   (*cl)[5] = (uint8_t)(gfx_check_urange(w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange(h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] = (uint8_t)(gfx_check_urange(h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_check_urange(num_rts, 0, 4) |
      (uint8_t)(gfx_bits(max_bpp, 2) << 4) | (uint8_t)(gfx_bits(ms_mode, 1) << 6) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 7);
   *cl += 8;
}
static inline void v3d_cl_tile_binning_mode_cfg_part2(uint8_t **cl,
   uint32_t tile_alloc_size,
   v3d_addr_t tile_alloc_addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 18);
   (*cl)[4] = (uint8_t)0 | (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 18);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_rendering_mode_cfg_common(uint8_t **cl,
   uint32_t num_rts,
   uint32_t frame_width,
   uint32_t frame_height,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer,
   bool cov_mode,
   v3d_ez_direction_t ez_direction,
   bool ez_disable,
   v3d_depth_type_t internal_depth_type,
   bool early_ds_clear)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 |
      (uint8_t)(gfx_pack_uint_minus_1(gfx_check_urange(num_rts, 1, 4), 4) << 4);
   (*cl)[1] = (uint8_t)gfx_check_urange(frame_width, 1, 0xffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(frame_width, 1, 0xffff) >> 8);
   (*cl)[3] = (uint8_t)gfx_check_urange(frame_height, 1, 0xffff);
   (*cl)[4] = (uint8_t)(gfx_check_urange(frame_height, 1, 0xffff) >> 8);
   (*cl)[5] = (uint8_t)gfx_bits(max_bpp, 2) |
      (uint8_t)(gfx_bits(ms_mode, 1) << 2) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 3) |
      (uint8_t)(gfx_bits(cov_mode, 1) << 4) |
      (uint8_t)(gfx_bits(ez_direction, 1) << 5) |
      (uint8_t)(gfx_bits(ez_disable, 1) << 6) |
      (uint8_t)(gfx_bits(internal_depth_type, 4) << 7);
   (*cl)[6] = (uint8_t)(gfx_bits(internal_depth_type, 4) >> 1) |
      (uint8_t)(gfx_bits(early_ds_clear, 1) << 3) | (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_color(uint8_t **cl,
   v3d_rt_bpp_t rt_formats_0_bpp,
   v3d_rt_type_t rt_formats_0_type,
   v3d_rt_clamp_t rt_formats_0_clamp,
   v3d_rt_bpp_t rt_formats_1_bpp,
   v3d_rt_type_t rt_formats_1_type,
   v3d_rt_clamp_t rt_formats_1_clamp,
   v3d_rt_bpp_t rt_formats_2_bpp,
   v3d_rt_type_t rt_formats_2_type,
   v3d_rt_clamp_t rt_formats_2_clamp,
   v3d_rt_bpp_t rt_formats_3_bpp,
   v3d_rt_type_t rt_formats_3_type,
   v3d_rt_clamp_t rt_formats_3_clamp)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)(gfx_bits(rt_formats_0_bpp, 2) << 4) |
      (uint8_t)(gfx_bits(rt_formats_0_type, 4) << 6);
   (*cl)[1] = (uint8_t)(gfx_bits(rt_formats_0_type, 4) >> 2) |
      (uint8_t)(gfx_bits(rt_formats_0_clamp, 2) << 2) |
      (uint8_t)(gfx_bits(rt_formats_1_bpp, 2) << 4) |
      (uint8_t)(gfx_bits(rt_formats_1_type, 4) << 6);
   (*cl)[2] = (uint8_t)(gfx_bits(rt_formats_1_type, 4) >> 2) |
      (uint8_t)(gfx_bits(rt_formats_1_clamp, 2) << 2) |
      (uint8_t)(gfx_bits(rt_formats_2_bpp, 2) << 4) |
      (uint8_t)(gfx_bits(rt_formats_2_type, 4) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(rt_formats_2_type, 4) >> 2) |
      (uint8_t)(gfx_bits(rt_formats_2_clamp, 2) << 2) |
      (uint8_t)(gfx_bits(rt_formats_3_bpp, 2) << 4) |
      (uint8_t)(gfx_bits(rt_formats_3_type, 4) << 6);
   (*cl)[4] = (uint8_t)(gfx_bits(rt_formats_3_type, 4) >> 2) |
      (uint8_t)(gfx_bits(rt_formats_3_clamp, 2) << 2) | (uint8_t)0;
   (*cl)[5] = (uint8_t)0;
   (*cl)[6] = (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_zs_clear_values(uint8_t **cl,
   uint32_t stencil_clear,
   float depth_clear)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)2 | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_bits(stencil_clear, 8);
   (*cl)[2] = (uint8_t)gfx_float_to_bits(depth_clear);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 8);
   (*cl)[4] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 16);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 24);
   (*cl)[6] = (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part1(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_0,
   uint32_t clear_col_1_andm24)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)3 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)clear_col_0;
   (*cl)[2] = (uint8_t)(clear_col_0 >> 8);
   (*cl)[3] = (uint8_t)(clear_col_0 >> 16);
   (*cl)[4] = (uint8_t)(clear_col_0 >> 24);
   (*cl)[5] = (uint8_t)gfx_bits(clear_col_1_andm24, 24);
   (*cl)[6] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 8);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 16);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part2(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_1_shift24,
   uint32_t clear_col_2,
   uint32_t clear_col_3_andm16)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)4 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_1_shift24, 8);
   (*cl)[2] = (uint8_t)clear_col_2;
   (*cl)[3] = (uint8_t)(clear_col_2 >> 8);
   (*cl)[4] = (uint8_t)(clear_col_2 >> 16);
   (*cl)[5] = (uint8_t)(clear_col_2 >> 24);
   (*cl)[6] = (uint8_t)gfx_bits(clear_col_3_andm16, 16);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_3_andm16, 16) >> 8);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part3(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_3_shift16)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)5 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_3_shift16, 16);
   (*cl)[2] = (uint8_t)(gfx_bits(clear_col_3_shift16, 16) >> 8);
   (*cl)[3] = (uint8_t)0;
   (*cl)[4] = (uint8_t)0;
   (*cl)[5] = (uint8_t)0;
   (*cl)[6] = (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_rendering_mode_cfg_common(uint8_t **cl,
   uint32_t num_rts,
   uint32_t frame_width,
   uint32_t frame_height,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer,
   bool cov_mode,
   v3d_ez_direction_t ez_direction,
   bool ez_disable,
   bool stencil_store,
   bool depth_store,
   uint32_t disable_rt_store_mask)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 |
      (uint8_t)(gfx_pack_uint_minus_1(gfx_check_urange(num_rts, 1, 4), 4) << 4);
   (*cl)[1] = (uint8_t)gfx_check_urange(frame_width, 1, 0xffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(frame_width, 1, 0xffff) >> 8);
   (*cl)[3] = (uint8_t)gfx_check_urange(frame_height, 1, 0xffff);
   (*cl)[4] = (uint8_t)(gfx_check_urange(frame_height, 1, 0xffff) >> 8);
   (*cl)[5] = (uint8_t)gfx_bits(max_bpp, 2) |
      (uint8_t)(gfx_bits(ms_mode, 1) << 2) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 3) |
      (uint8_t)(gfx_bits(cov_mode, 1) << 4) |
      (uint8_t)(gfx_bits(ez_direction, 1) << 5) |
      (uint8_t)(gfx_bits(ez_disable, 1) << 6) | (uint8_t)0;
   (*cl)[6] = (uint8_t)0 | (uint8_t)(gfx_bits(stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits(depth_store, 1) << 7);
   (*cl)[7] = (uint8_t)gfx_bits(disable_rt_store_mask, 8);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_z_stencil(uint8_t **cl,
   v3d_depth_type_t internal_type,
   v3d_decimate_t decimate_mode,
   v3d_depth_format_t output_format,
   v3d_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(internal_type, 4) << 2) |
      (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)gfx_bits(output_format, 6) |
      (uint8_t)(gfx_bits(memory_format, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(memory_format, 3) >> 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 1);
   (*cl)[4] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 7) |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_separate_stencil(uint8_t **cl,
   v3d_decimate_t decimate_mode,
   v3d_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)(1 << 4);
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)0 | (uint8_t)(gfx_bits(memory_format, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(memory_format, 3) >> 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 1);
   (*cl)[4] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 7) |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_color(uint8_t **cl,
   uint32_t rt,
   v3d_rt_bpp_t internal_bpp,
   v3d_rt_type_t internal_type,
   v3d_decimate_t decimate_mode,
   v3d_pixel_format_t output_format,
   v3d_dither_t dither_mode,
   v3d_memory_format_t memory_format,
   bool flipy,
   uint32_t pad,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)2 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(internal_bpp, 2) |
      (uint8_t)(gfx_bits(internal_type, 4) << 2) |
      (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)gfx_bits(output_format, 6) |
      (uint8_t)(gfx_bits(dither_mode, 2) << 6);
   (*cl)[3] = (uint8_t)gfx_bits(memory_format, 3) |
      (uint8_t)(gfx_bits(flipy, 1) << 3) | (uint8_t)(gfx_bits(pad, 4) << 4);
   (*cl)[4] = (uint8_t)addr;
   (*cl)[5] = (uint8_t)(addr >> 8);
   (*cl)[6] = (uint8_t)(addr >> 16);
   (*cl)[7] = (uint8_t)(addr >> 24);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_zs_clear_values(uint8_t **cl,
   uint32_t stencil_clear,
   float depth_clear)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)3 | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_bits(stencil_clear, 8);
   (*cl)[2] = (uint8_t)gfx_float_to_bits(depth_clear);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 8);
   (*cl)[4] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 16);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 24);
   (*cl)[6] = (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part1(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_0,
   uint32_t clear_col_1_andm24)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)4 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)clear_col_0;
   (*cl)[2] = (uint8_t)(clear_col_0 >> 8);
   (*cl)[3] = (uint8_t)(clear_col_0 >> 16);
   (*cl)[4] = (uint8_t)(clear_col_0 >> 24);
   (*cl)[5] = (uint8_t)gfx_bits(clear_col_1_andm24, 24);
   (*cl)[6] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 8);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 16);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part2(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_1_shift24,
   uint32_t clear_col_2,
   uint32_t clear_col_3_andm16)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)5 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_1_shift24, 8);
   (*cl)[2] = (uint8_t)clear_col_2;
   (*cl)[3] = (uint8_t)(clear_col_2 >> 8);
   (*cl)[4] = (uint8_t)(clear_col_2 >> 16);
   (*cl)[5] = (uint8_t)(clear_col_2 >> 24);
   (*cl)[6] = (uint8_t)gfx_bits(clear_col_3_andm16, 16);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_3_andm16, 16) >> 8);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part3(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_3_shift16,
   uint32_t raster_padded_width_or_nonraster_height,
   uint32_t uif_height_in_ub)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)6 | (uint8_t)(gfx_check_urange(rt, 0, 3) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_3_shift16, 16);
   (*cl)[2] = (uint8_t)(gfx_bits(clear_col_3_shift16, 16) >> 8);
   (*cl)[3] = (uint8_t)gfx_check_urange(raster_padded_width_or_nonraster_height,
      0, 0x1fff);
   (*cl)[4] = (uint8_t)(gfx_check_urange(raster_padded_width_or_nonraster_height,
      0, 0x1fff) >> 8);
   (*cl)[5] = (uint8_t)gfx_bits(uif_height_in_ub, 13);
   (*cl)[6] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 8) | (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
#endif
static inline void v3d_cl_multicore_rendering_supertile_cfg(uint8_t **cl,
   uint32_t supertile_w_in_tiles,
   uint32_t supertile_h_in_tiles,
   uint32_t frame_w_in_supertiles,
   uint32_t frame_h_in_supertiles,
   uint32_t frame_w_in_tiles,
   uint32_t frame_h_in_tiles,
   bool multicore,
   v3d_supertile_order_t supertile_order,
   uint32_t num_bin_tile_lists)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1(supertile_w_in_tiles, 8);
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1(supertile_h_in_tiles, 8);
   (*cl)[2] = (uint8_t)gfx_check_urange(frame_w_in_supertiles, 1, 255);
   (*cl)[3] = (uint8_t)gfx_check_urange(frame_h_in_supertiles, 1, 255);
   (*cl)[4] = (uint8_t)gfx_check_urange(frame_w_in_tiles, 1, 0xfff);
   (*cl)[5] = (uint8_t)(gfx_check_urange(frame_w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange(frame_h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] = (uint8_t)(gfx_check_urange(frame_h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_bits(multicore, 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits(supertile_order, 1) << 4) |
      (uint8_t)(gfx_pack_uint_minus_1(num_bin_tile_lists, 3) << 5);
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_tile_list_base(uint8_t **cl,
   uint32_t set,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE);
   (*cl)[0] = (uint8_t)gfx_bits(set, 4) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 4;
}
static inline void v3d_cl_tile_coords(uint8_t **cl,
   uint32_t x,
   uint32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits(x, 12);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 12) >> 8) | (uint8_t)(gfx_bits(y, 12) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits(y, 12) >> 4);
   *cl += 3;
}
static inline void v3d_cl_implicit_tile_coords(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_IMPLICIT_TILE_COORDS);
}
static inline void v3d_cl_tile_list_initial_block_size(uint8_t **cl,
   v3d_tile_alloc_block_size_t block_size,
   bool chain)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE);
   (*cl)[0] = (uint8_t)gfx_bits(block_size, 2) |
      (uint8_t)(gfx_bits(chain, 1) << 2) | (uint8_t)0;
   *cl += 1;
}
extern void v3d_cl_print_halt(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_nop(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush_all_state(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_start_tile_binning(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_incr_semaphore(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_semaphore(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_prev_frame(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_enable_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_disable_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_end_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_end_render(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_transform_feedback(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_return(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clear_vcd_cache(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_generic_tile_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch_implicit_tile(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch_explicit_supertile(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_supertile_coords(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_clear(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_end_loads(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_end_tile(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_store(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_load(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_store_subsample(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_store_subsample_ex(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_load(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_end_tile(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_store_general(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_load_general(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_tf_draw_flush_and_count(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indirect_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indirect_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indexed_instanced_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indexed_instanced_prim_list(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indirect_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vertex_array_instanced_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vertex_array_single_instance_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_base_vertex_base_instance(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_index_buffer_setup(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_indirect_primitive_limits(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_vg_coord_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vg_inline_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_compressed_prim_list_iid_zero(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_compressed_prim_list_current_iid(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_clipped_prim(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_set_instance_id(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_set_primitive_id(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_prim_list_format(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_serial_number_list_start(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_gl_shader(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_gl_shader(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_vg_shader(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vg_inline_shader(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vg_inline_shader(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vcm_cache_size(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_prim_counts_feedback(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_transform_feedback_buffer(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_transform_feedback_specs(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vcm_cache_size(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_transform_feedback_enable(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_flush_transform_feedback_data(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clear_slice_caches(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush_l2t(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(3,3,0,0)
extern void v3d_cl_print_clear_l2c(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_clean_l1td_deferred(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_stencil_cfg(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_blend_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_blend_enables(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_blend_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_blend_ccolor(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_color_wmasks(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_zero_all_centroid_flags(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_zero_all_flatshade_flags(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_zero_all_noperspective_flags(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vary_flags(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_vary_flags(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_sample_state(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_sample_state(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_occlusion_query_counter_enable(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_cfg_bits(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_point_size(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_line_width(const uint8_t *packed, struct v3d_printer *printer);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_depth_offset(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_depth_offset(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_clip(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_viewport_offset(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_clip(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_viewport_offset(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_clipz(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipper_xy(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipper_z(const uint8_t *packed, struct v3d_printer *printer);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_num_layers(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_tile_binning_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_tile_binning_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_tile_rendering_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_print_tile_rendering_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_cl_print_multicore_rendering_supertile_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_multicore_rendering_tile_list_base(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_coords(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_implicit_tile_coords(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_list_initial_block_size(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_instr(const uint8_t *packed_instr, struct v3d_printer *printer);
typedef struct
{
   v3d_addr_t addr;
   v3d_addr_t end;
} V3D_CL_GENERIC_TILE_LIST_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
   uint32_t supertile;
   v3d_addr_t addr;
} V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
} V3D_CL_SUPERTILE_COORDS_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool rts;
   bool depth_stencil;
} V3D_CL_CLEAR_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_ldst_buf_t buffer;
   v3d_memory_format_t memory_format;
   bool flipy;
   v3d_dither_t dither;
   v3d_decimate_t decimate;
   v3d_pixel_format_t pixel_format;
   bool clear;
   bool chan_reverse;
   bool rb_swap;
   uint32_t stride;
   uint32_t height;
   v3d_addr_t addr;
} V3D_CL_STORE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_ldst_buf_t buffer;
   v3d_memory_format_t memory_format;
   bool flipy;
   v3d_decimate_t decimate;
   v3d_pixel_format_t pixel_format;
   bool alpha_to_one;
   bool chan_reverse;
   bool rb_swap;
   uint32_t stride;
   uint32_t height;
   v3d_addr_t addr;
} V3D_CL_LOAD_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool eof;
   bool disable_owo_or_double_buf_swap;
   bool disable_depth_clear;
   bool disable_stencil_clear;
   bool disable_color_clear;
   bool stencil_store;
   bool depth_store;
   uint32_t disable_rt_store_mask;
} V3D_CL_STORE_SUBSAMPLE_EX_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool stencil_load;
   bool depth_load;
   uint32_t disable_rt_load_mask;
} V3D_CL_LOAD_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_ldst_buf_t buffer;
   bool raw_mode;
   bool disable_depth_clear;
   bool disable_stencil_clear;
   bool disable_color_clear;
   bool eof;
   bool disable_double_buf_swap;
   v3d_ldst_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_STORE_GENERAL_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_ldst_buf_t buffer;
   bool raw_mode;
   v3d_ldst_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_LOAD_GENERAL_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   bool prim_restart;
   uint32_t indices_offset;
} V3D_CL_INDEXED_PRIM_LIST_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   v3d_addr_t indices_addr;
   uint32_t max_index;
   bool prim_restart;
   uint32_t min_index;
} V3D_CL_INDEXED_PRIM_LIST_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indirect;
   bool prim_restart;
   v3d_addr_t indirect_addr;
   uint32_t indirect_stride;
} V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indirect;
   bool prim_restart;
   v3d_addr_t indirect_addr;
   v3d_addr_t indices_addr;
   uint32_t indirect_stride;
} V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   bool prim_restart;
   uint32_t num_instances;
   uint32_t indices_offset;
} V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   uint32_t num_instances;
   v3d_addr_t indices_addr;
   uint32_t max_index;
   bool prim_restart;
} V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T;
#endif
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_indirect;
   v3d_addr_t indirect_addr;
   uint32_t indirect_stride;
} V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t num_instances;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t instance_id;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T;
typedef struct
{
   int32_t base_vertex;
   uint32_t base_instance;
} V3D_CL_BASE_VERTEX_BASE_INSTANCE_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_addr_t addr;
   uint32_t size;
} V3D_CL_INDEX_BUFFER_SETUP_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t max_index;
   uint32_t max_instance;
   uint32_t index_buffer_size;
} V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T;
#endif
typedef struct
{
   v3d_prim_mode_t prim_mode;
   bool continuation;
   uint32_t num_vertices;
   v3d_addr_t coords_addr;
} V3D_CL_VG_COORD_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   bool continuation;
} V3D_CL_VG_INLINE_PRIMS_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef bool V3D_CL_CLIPPED_PRIM_CLIP_T[3];
typedef struct
{
   V3D_CL_CLIPPED_PRIM_CLIP_T clip;
   bool flat_zw;
   v3d_addr_t addr;
} V3D_CL_CLIPPED_PRIM_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t instance_id;
} V3D_CL_SET_INSTANCE_ID_T;
#endif
typedef struct
{
   uint32_t initial_prim_id;
} V3D_CL_SET_PRIMITIVE_ID_T;
typedef struct
{
   uint32_t n_verts;
   bool xy;
   bool d3dpvsf;
} V3D_CL_PRIM_LIST_FORMAT_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tile_alloc_block_size_t initial_block_size;
   v3d_addr_t address;
} V3D_CL_SERIAL_NUMBER_LIST_START_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_attr_arrays;
   v3d_addr_t addr;
} V3D_CL_GL_SHADER_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_attr_arrays;
   v3d_addr_t addr;
} V3D_CL_GL_SHADER_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_CL_VG_INLINE_SHADER_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_CL_VG_INLINE_SHADER_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_batches_bin;
   uint32_t num_batches_render;
} V3D_CL_VCM_CACHE_SIZE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_pcf_operation_t operation;
   bool rw64;
   v3d_addr_t addr;
} V3D_CL_PRIM_COUNTS_FEEDBACK_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t buffer_num;
   uint32_t size_words;
   v3d_addr_t buffer_addr;
} V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_specs;
   bool enable;
} V3D_CL_TRANSFORM_FEEDBACK_SPECS_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_batches_bin;
   uint32_t num_batches_render;
} V3D_CL_VCM_CACHE_SIZE_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t id;
   uint32_t num_addrs;
   uint32_t num_specs;
} V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T;
#endif
typedef struct
{
   uint32_t sic;
   uint32_t suc;
   uint32_t l1td;
   uint32_t l1tc;
} V3D_CL_CLEAR_SLICE_CACHES_T;
typedef struct
{
   v3d_addr_t start_addr;
   v3d_addr_t end_addr;
   v3d_l2t_flush_mode_t mode;
   bool deferred;
} V3D_CL_FLUSH_L2T_T;
typedef struct
{
   uint32_t reference;
   uint32_t mask;
   v3d_compare_func_t func;
   v3d_stencil_op_t fail_op;
   v3d_stencil_op_t depth_fail_op;
   v3d_stencil_op_t pass_op;
   bool front_cfg;
   bool back_cfg;
   uint32_t write_mask;
} V3D_CL_STENCIL_CFG_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_blend_eqn_t a_eqn;
   v3d_blend_mul_t a_src;
   v3d_blend_mul_t a_dst;
   v3d_blend_eqn_t c_eqn;
   v3d_blend_mul_t c_src;
   v3d_blend_mul_t c_dst;
   v3d_blend_vg_mode_t vg_mode;
} V3D_CL_BLEND_CFG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_blend_eqn_t a_eqn;
   v3d_blend_mul_t a_src;
   v3d_blend_mul_t a_dst;
   v3d_blend_eqn_t c_eqn;
   v3d_blend_mul_t c_src;
   v3d_blend_mul_t c_dst;
   uint32_t rt_mask;
   v3d_blend_vg_mode_t vg_mode;
} V3D_CL_BLEND_CFG_T;
#endif
typedef struct
{
   float r;
   float g;
   float b;
   float a;
} V3D_CL_BLEND_CCOLOR_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t offset;
   v3d_flags_action_t lower_action;
   v3d_flags_action_t higher_action;
   uint32_t flags;
} V3D_CL_VARY_FLAGS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t offset;
   v3d_flags_action_t lower_action;
   v3d_flags_action_t higher_action;
   uint32_t flags;
} V3D_CL_VARY_FLAGS_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   float coverage;
} V3D_CL_SAMPLE_STATE_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t mask;
   float coverage;
} V3D_CL_SAMPLE_STATE_T;
#endif
typedef struct
{
   bool front_prims;
   bool back_prims;
   bool cwise_is_front;
   bool depth_offset;
   bool aa_lines;
   v3d_ms_t rast_oversample;
   bool cov_pipe;
   v3d_cov_update_t cov_update;
   bool wireframe_tris;
   v3d_compare_func_t depth_test;
   bool depth_update;
   bool ez;
   bool ez_update;
   bool stencil;
   bool blend;
   v3d_wireframe_mode_t wireframe_mode;
   bool d3d_prov_vtx;
} V3D_CL_CFG_BITS_T;
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   float factor;
   float units;
} V3D_CL_DEPTH_OFFSET_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   float factor;
   float units;
   float limit;
} V3D_CL_DEPTH_OFFSET_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t x;
   uint32_t y;
   uint32_t width;
   uint32_t height;
} V3D_CL_CLIP_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t x;
   int32_t coarse_x;
   uint32_t y;
   int32_t coarse_y;
} V3D_CL_VIEWPORT_OFFSET_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t x;
   uint32_t y;
   uint32_t width;
   uint32_t height;
} V3D_CL_CLIP_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   int32_t x;
   int32_t y;
} V3D_CL_VIEWPORT_OFFSET_T;
#endif
typedef struct
{
   float min;
   float max;
} V3D_CL_CLIPZ_T;
typedef struct
{
   float scale_x;
   float scale_y;
} V3D_CL_CLIPPER_XY_T;
typedef struct
{
   float scale;
   float offset;
} V3D_CL_CLIPPER_Z_T;
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_layers;
} V3D_CL_NUM_LAYERS_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size;
   v3d_tile_alloc_block_size_t tile_alloc_block_size;
   uint32_t num_rts;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
   uint32_t w_in_pixels;
   uint32_t h_in_pixels;
} V3D_CL_TILE_BINNING_MODE_CFG_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   bool auto_init_tile_state;
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size;
   v3d_tile_alloc_block_size_t tile_alloc_block_size;
   v3d_addr_t tile_state_addr;
   uint32_t w_in_tiles;
   uint32_t h_in_tiles;
   uint32_t num_rts;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
} V3D_CL_TILE_BINNING_MODE_CFG_PART1_T;
typedef struct
{
   uint32_t tile_alloc_size;
   v3d_addr_t tile_alloc_addr;
} V3D_CL_TILE_BINNING_MODE_CFG_PART2_T;
typedef union
{
   V3D_CL_TILE_BINNING_MODE_CFG_PART1_T part1;
   V3D_CL_TILE_BINNING_MODE_CFG_PART2_T part2;
} V3D_CL_TILE_BINNING_MODE_CFG_U_T;
typedef struct
{
   v3d_bcfg_type_t type;
   V3D_CL_TILE_BINNING_MODE_CFG_U_T u;
} V3D_CL_TILE_BINNING_MODE_CFG_T;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_rts;
   uint32_t frame_width;
   uint32_t frame_height;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
   bool cov_mode;
   v3d_ez_direction_t ez_direction;
   bool ez_disable;
   v3d_depth_type_t internal_depth_type;
   bool early_ds_clear;
} V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T;
typedef V3D_RT_FORMAT_T V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_RT_FORMATS_T[4];
typedef struct
{
   V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_RT_FORMATS_T rt_formats;
} V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T;
typedef struct
{
   uint32_t stencil_clear;
   float depth_clear;
} V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_0;
   uint32_t clear_col_1_andm24;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_1_shift24;
   uint32_t clear_col_2;
   uint32_t clear_col_3_andm16;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_3_shift16;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T;
typedef union
{
   V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T common;
   V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T color;
   V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T zs_clear_values;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T clear_colors_part1;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T clear_colors_part2;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T clear_colors_part3;
} V3D_CL_TILE_RENDERING_MODE_CFG_U_T;
typedef struct
{
   v3d_rcfg_type_t type;
   V3D_CL_TILE_RENDERING_MODE_CFG_U_T u;
} V3D_CL_TILE_RENDERING_MODE_CFG_T;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
typedef struct
{
   uint32_t num_rts;
   uint32_t frame_width;
   uint32_t frame_height;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
   bool cov_mode;
   v3d_ez_direction_t ez_direction;
   bool ez_disable;
   bool stencil_store;
   bool depth_store;
   uint32_t disable_rt_store_mask;
} V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T;
typedef struct
{
   v3d_depth_type_t internal_type;
   v3d_decimate_t decimate_mode;
   v3d_depth_format_t output_format;
   v3d_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_T;
typedef struct
{
   v3d_decimate_t decimate_mode;
   v3d_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_T;
typedef struct
{
   uint32_t rt;
   v3d_rt_bpp_t internal_bpp;
   v3d_rt_type_t internal_type;
   v3d_decimate_t decimate_mode;
   v3d_pixel_format_t output_format;
   v3d_dither_t dither_mode;
   v3d_memory_format_t memory_format;
   bool flipy;
   uint32_t pad;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T;
typedef struct
{
   uint32_t stencil_clear;
   float depth_clear;
} V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_0;
   uint32_t clear_col_1_andm24;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_1_shift24;
   uint32_t clear_col_2;
   uint32_t clear_col_3_andm16;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_3_shift16;
   uint32_t raster_padded_width_or_nonraster_height;
   uint32_t uif_height_in_ub;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T;
typedef union
{
   V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T common;
   V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_T z_stencil;
   V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_T separate_stencil;
   V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T color;
   V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T zs_clear_values;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T clear_colors_part1;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T clear_colors_part2;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T clear_colors_part3;
} V3D_CL_TILE_RENDERING_MODE_CFG_U_T;
typedef struct
{
   v3d_rcfg_type_t type;
   V3D_CL_TILE_RENDERING_MODE_CFG_U_T u;
} V3D_CL_TILE_RENDERING_MODE_CFG_T;
#endif
typedef struct
{
   uint32_t supertile_w_in_tiles;
   uint32_t supertile_h_in_tiles;
   uint32_t frame_w_in_supertiles;
   uint32_t frame_h_in_supertiles;
   uint32_t frame_w_in_tiles;
   uint32_t frame_h_in_tiles;
   bool multicore;
   v3d_supertile_order_t supertile_order;
   uint32_t num_bin_tile_lists;
} V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T;
typedef struct
{
   uint32_t set;
   v3d_addr_t addr;
} V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
} V3D_CL_TILE_COORDS_T;
typedef struct
{
   v3d_tile_alloc_block_size_t block_size;
   bool chain;
} V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T;
static inline void v3d_cl_wait_transform_feedback_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_TRANSFORM_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits(*unpacked, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_sub_autochain_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB_AUTOCHAIN);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_sub_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_generic_tile_list_indirect(uint8_t **cl, const V3D_CL_GENERIC_TILE_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GENERIC_TILE_LIST);
   (*cl)[0] = (uint8_t)(*unpacked).addr;
   (*cl)[1] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).addr >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).end;
   (*cl)[5] = (uint8_t)((*unpacked).end >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).end >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).end >> 24);
   *cl += 8;
}
static inline void v3d_cl_branch_implicit_tile_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_IMPLICIT_TILE);
   (*cl)[0] = (uint8_t)gfx_bits(*unpacked, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_explicit_supertile_indirect(uint8_t **cl, const V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_EXPLICIT_SUPERTILE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).supertile, 8);
   (*cl)[3] = (uint8_t)(*unpacked).addr;
   (*cl)[4] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[5] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[6] = (uint8_t)((*unpacked).addr >> 24);
   *cl += 7;
}
static inline void v3d_cl_supertile_coords_indirect(uint8_t **cl, const V3D_CL_SUPERTILE_COORDS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SUPERTILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
   *cl += 2;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clear_indirect(uint8_t **cl, const V3D_CL_CLEAR_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).rts, 1) |
      (uint8_t)(gfx_bits((*unpacked).depth_stencil, 1) << 1) | (uint8_t)0;
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_indirect(uint8_t **cl, const V3D_CL_STORE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STORE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).dither, 2) |
      (uint8_t)(gfx_bits((*unpacked).decimate, 2) << 2) |
      (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) >> 4) |
      (uint8_t)(gfx_bits((*unpacked).clear, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).chan_reverse, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).rb_swap, 1) << 4) | (uint8_t)0;
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stride, 20) << 4);
   (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 4);
   (*cl)[5] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 12);
   (*cl)[6] = (uint8_t)gfx_bits((*unpacked).height, 16);
   (*cl)[7] = (uint8_t)(gfx_bits((*unpacked).height, 16) >> 8);
   (*cl)[8] = (uint8_t)(*unpacked).addr;
   (*cl)[9] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[10] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[11] = (uint8_t)((*unpacked).addr >> 24);
   *cl += 12;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load_indirect(uint8_t **cl, const V3D_CL_LOAD_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 7);
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).decimate, 2) << 2) |
      (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) >> 4) |
      (uint8_t)(gfx_bits((*unpacked).alpha_to_one, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).chan_reverse, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).rb_swap, 1) << 4) | (uint8_t)0;
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stride, 20) << 4);
   (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 4);
   (*cl)[5] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 12);
   (*cl)[6] = (uint8_t)gfx_bits((*unpacked).height, 16);
   (*cl)[7] = (uint8_t)(gfx_bits((*unpacked).height, 16) >> 8);
   (*cl)[8] = (uint8_t)(*unpacked).addr;
   (*cl)[9] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[10] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[11] = (uint8_t)((*unpacked).addr >> 24);
   *cl += 12;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_subsample_ex_indirect(uint8_t **cl, const V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE_EX);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_owo_or_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_store, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_store_mask, 8);
   *cl += 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load_indirect(uint8_t **cl, const V3D_CL_LOAD_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stencil_load, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_load, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_load_mask, 8);
   *cl += 2;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_store_general_indirect(uint8_t **cl, const V3D_CL_STORE_GENERAL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
   *cl += 6;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_load_general_indirect(uint8_t **cl, const V3D_CL_LOAD_GENERAL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
   *cl += 6;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).num_indices, 31);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 16);
   (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)(*unpacked).indices_offset;
   (*cl)[6] = (uint8_t)((*unpacked).indices_offset >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indices_offset >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indices_offset >> 24);
   *cl += 9;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)(*unpacked).num_indices;
   (*cl)[2] = (uint8_t)((*unpacked).num_indices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_indices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_indices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   (*cl)[10] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   (*cl)[11] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   (*cl)[12] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[13] = (uint8_t)(*unpacked).min_index;
   (*cl)[14] = (uint8_t)((*unpacked).min_index >> 8);
   (*cl)[15] = (uint8_t)((*unpacked).min_index >> 16);
   (*cl)[16] = (uint8_t)((*unpacked).min_index >> 24);
   *cl += 17;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff);
   (*cl)[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)(*unpacked).indirect_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
   *cl += 10;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff);
   (*cl)[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)(*unpacked).indirect_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
   *cl += 14;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_instanced_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).num_indices, 31);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 16);
   (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)(*unpacked).num_instances;
   (*cl)[6] = (uint8_t)((*unpacked).num_instances >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).num_instances >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).num_instances >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_offset;
   (*cl)[10] = (uint8_t)((*unpacked).indices_offset >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_offset >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_offset >> 24);
   *cl += 13;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indexed_instanced_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)(*unpacked).num_indices;
   (*cl)[2] = (uint8_t)((*unpacked).num_indices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_indices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_indices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).num_instances;
   (*cl)[6] = (uint8_t)((*unpacked).num_instances >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).num_instances >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).num_instances >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   *cl += 17;
}
#endif
static inline void v3d_cl_vertex_array_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).first_index;
   (*cl)[6] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 9;
}
static inline void v3d_cl_indirect_vertex_array_prims_indirect(uint8_t **cl, const V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff);
   (*cl)[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 8);
   (*cl)[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 16);
   (*cl)[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).indirect_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
   *cl += 10;
}
static inline void v3d_cl_vertex_array_instanced_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).num_instances;
   (*cl)[6] = (uint8_t)((*unpacked).num_instances >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).num_instances >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).num_instances >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).first_index;
   (*cl)[10] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_vertex_array_single_instance_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).instance_id;
   (*cl)[6] = (uint8_t)((*unpacked).instance_id >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).instance_id >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).instance_id >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).first_index;
   (*cl)[10] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_base_vertex_base_instance_indirect(uint8_t **cl, const V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BASE_VERTEX_BASE_INSTANCE);
   (*cl)[0] = (uint8_t)(uint32_t)(*unpacked).base_vertex;
   (*cl)[1] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).base_instance;
   (*cl)[5] = (uint8_t)((*unpacked).base_instance >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).base_instance >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).base_instance >> 24);
   *cl += 8;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_index_buffer_setup_indirect(uint8_t **cl, const V3D_CL_INDEX_BUFFER_SETUP_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEX_BUFFER_SETUP);
   (*cl)[0] = (uint8_t)(*unpacked).addr;
   (*cl)[1] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).addr >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).size;
   (*cl)[5] = (uint8_t)((*unpacked).size >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).size >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).size >> 24);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_indirect_primitive_limits_indirect(uint8_t **cl, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_PRIMITIVE_LIMITS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).max_index, 24);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 16);
   (*cl)[3] = (uint8_t)(*unpacked).max_instance;
   (*cl)[4] = (uint8_t)((*unpacked).max_instance >> 8);
   (*cl)[5] = (uint8_t)((*unpacked).max_instance >> 16);
   (*cl)[6] = (uint8_t)((*unpacked).max_instance >> 24);
   (*cl)[7] = (uint8_t)(*unpacked).index_buffer_size;
   (*cl)[8] = (uint8_t)((*unpacked).index_buffer_size >> 8);
   (*cl)[9] = (uint8_t)((*unpacked).index_buffer_size >> 16);
   (*cl)[10] = (uint8_t)((*unpacked).index_buffer_size >> 24);
   *cl += 11;
}
#endif
static inline void v3d_cl_vg_coord_array_prims_indirect(uint8_t **cl, const V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_COORD_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).coords_addr;
   (*cl)[6] = (uint8_t)((*unpacked).coords_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).coords_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).coords_addr >> 24);
   *cl += 9;
}
static inline void v3d_cl_vg_inline_prims_indirect(uint8_t **cl, const V3D_CL_VG_INLINE_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
   *cl += 1;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clipped_prim_iid_zero_indirect(uint8_t **cl, const V3D_CL_CLIPPED_PRIM_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_IID_ZERO);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).clip[0], 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[1], 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[2], 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).flat_zw, 1) << 3) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_clipped_prim_current_iid_indirect(uint8_t **cl, const V3D_CL_CLIPPED_PRIM_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_CURRENT_IID);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).clip[0], 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[1], 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[2], 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).flat_zw, 1) << 3) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_set_instance_id_indirect(uint8_t **cl, const V3D_CL_SET_INSTANCE_ID_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SET_INSTANCE_ID);
   (*cl)[0] = (uint8_t)(*unpacked).instance_id;
   (*cl)[1] = (uint8_t)((*unpacked).instance_id >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).instance_id >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).instance_id >> 24);
   *cl += 4;
}
#endif
static inline void v3d_cl_set_primitive_id_indirect(uint8_t **cl, const V3D_CL_SET_PRIMITIVE_ID_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SET_PRIMITIVE_ID);
   (*cl)[0] = (uint8_t)(*unpacked).initial_prim_id;
   (*cl)[1] = (uint8_t)((*unpacked).initial_prim_id >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).initial_prim_id >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).initial_prim_id >> 24);
   *cl += 4;
}
static inline void v3d_cl_prim_list_format_indirect(uint8_t **cl, const V3D_CL_PRIM_LIST_FORMAT_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_LIST_FORMAT);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1(
      gfx_check_urange((*unpacked).n_verts, 1, 32), 6) |
      (uint8_t)(gfx_bits((*unpacked).xy, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).d3dpvsf, 1) << 7);
   *cl += 1;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_serial_number_list_start_indirect(uint8_t **cl, const V3D_CL_SERIAL_NUMBER_LIST_START_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SERIAL_NUMBER_LIST_START);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).initial_block_size, 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) << 2);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 6);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 14);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 22);
   *cl += 4;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_gl_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_gl_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_t_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_T_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_g_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_G_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_tg_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_TG_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
#endif
static inline void v3d_cl_vg_shader_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_SHADER);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vg_inline_shader_indirect(uint8_t **cl, const V3D_CL_VG_INLINE_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).fs.threading, 2) |
      (uint8_t)(gfx_bits((*unpacked).fs.propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 21);
   (*cl)[4] = (uint8_t)(*unpacked).fs.unifs_addr;
   (*cl)[5] = (uint8_t)((*unpacked).fs.unifs_addr >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).fs.unifs_addr >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).fs.unifs_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vg_inline_shader_indirect(uint8_t **cl, const V3D_CL_VG_INLINE_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).fs.threading, 1) |
      (uint8_t)(gfx_bits((*unpacked).fs.single_seg, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).fs.propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 21);
   (*cl)[4] = (uint8_t)(*unpacked).fs.unifs_addr;
   (*cl)[5] = (uint8_t)((*unpacked).fs.unifs_addr >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).fs.unifs_addr >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).fs.unifs_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vcm_cache_size_indirect(uint8_t **cl, const V3D_CL_VCM_CACHE_SIZE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_batches_render, 1, 4) << 4);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_prim_counts_feedback_indirect(uint8_t **cl, const V3D_CL_PRIM_COUNTS_FEEDBACK_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_COUNTS_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).operation, 4) |
      (uint8_t)(gfx_bits((*unpacked).rw64, 1) << 4) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_buffer_indirect(uint8_t **cl, const V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_BUFFER);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).buffer_num, 0, 3) |
      (uint8_t)(gfx_bits((*unpacked).size_words, 30) << 2);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 6);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 14);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 22);
   (*cl)[4] = (uint8_t)(*unpacked).buffer_addr;
   (*cl)[5] = (uint8_t)((*unpacked).buffer_addr >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).buffer_addr >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).buffer_addr >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_specs_indirect(uint8_t **cl, const V3D_CL_TRANSFORM_FEEDBACK_SPECS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_SPECS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).num_specs, 0, 16) |
      (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).enable, 1) << 7);
   *cl += 1;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_vcm_cache_size_indirect(uint8_t **cl, const V3D_CL_VCM_CACHE_SIZE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_batches_render, 1, 4) << 4);
   *cl += 1;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_transform_feedback_enable_indirect(uint8_t **cl, const V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_ENABLE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).id, 8);
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_addrs, 0, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_specs, 1, 16) << 3);
   *cl += 2;
}
#endif
static inline void v3d_cl_clear_slice_caches_indirect(uint8_t **cl, const V3D_CL_CLEAR_SLICE_CACHES_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLEAR_SLICE_CACHES);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).sic, 4) |
      (uint8_t)(gfx_bits((*unpacked).suc, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).l1td, 4) |
      (uint8_t)(gfx_bits((*unpacked).l1tc, 4) << 4);
   *cl += 2;
}
static inline void v3d_cl_flush_l2t_indirect(uint8_t **cl, const V3D_CL_FLUSH_L2T_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_L2T);
   (*cl)[0] = (uint8_t)(*unpacked).start_addr;
   (*cl)[1] = (uint8_t)((*unpacked).start_addr >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).start_addr >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).start_addr >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).end_addr;
   (*cl)[5] = (uint8_t)((*unpacked).end_addr >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).end_addr >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).end_addr >> 24);
   (*cl)[8] = (uint8_t)gfx_bits((*unpacked).mode, 2) |
      (uint8_t)(gfx_bits((*unpacked).deferred, 1) << 2) | (uint8_t)0;
   *cl += 9;
}
static inline void v3d_cl_stencil_cfg_indirect(uint8_t **cl, const V3D_CL_STENCIL_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STENCIL_CFG);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).reference, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).mask, 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).func, 3) |
      (uint8_t)(gfx_bits((*unpacked).fail_op, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).pass_op, 3) << 1) |
      (uint8_t)(gfx_bits((*unpacked).front_cfg, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).back_cfg, 1) << 5) | (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_bits((*unpacked).write_mask, 8);
   *cl += 5;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_cfg_indirect(uint8_t **cl, const V3D_CL_BLEND_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).a_eqn, 4) |
      (uint8_t)(gfx_bits((*unpacked).a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).a_dst, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).c_src, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).vg_mode, 2) << 4) |
      (uint8_t)0;
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_enables_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_ENABLES);
   (*cl)[0] = (uint8_t)gfx_bits(*unpacked, 8);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_blend_cfg_indirect(uint8_t **cl, const V3D_CL_BLEND_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).a_eqn, 4) |
      (uint8_t)(gfx_bits((*unpacked).a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).a_dst, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).c_src, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)gfx_bits((*unpacked).rt_mask, 4) |
      (uint8_t)(gfx_bits((*unpacked).vg_mode, 2) << 4) | (uint8_t)0;
   *cl += 4;
}
#endif
static inline void v3d_cl_blend_ccolor_indirect(uint8_t **cl, const V3D_CL_BLEND_CCOLOR_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CCOLOR);
   (*cl)[0] = (uint8_t)gfx_float_to_float16((*unpacked).r);
   (*cl)[1] = (uint8_t)(gfx_float_to_float16((*unpacked).r) >> 8);
   (*cl)[2] = (uint8_t)gfx_float_to_float16((*unpacked).g);
   (*cl)[3] = (uint8_t)(gfx_float_to_float16((*unpacked).g) >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_float16((*unpacked).b);
   (*cl)[5] = (uint8_t)(gfx_float_to_float16((*unpacked).b) >> 8);
   (*cl)[6] = (uint8_t)gfx_float_to_float16((*unpacked).a);
   (*cl)[7] = (uint8_t)(gfx_float_to_float16((*unpacked).a) >> 8);
   *cl += 8;
}
static inline void v3d_cl_color_wmasks_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_COLOR_WMASKS);
   (*cl)[0] = (uint8_t)gfx_check_urange(*unpacked, 0, 0xffff);
   (*cl)[1] = (uint8_t)(gfx_check_urange(*unpacked, 0, 0xffff) >> 8);
   (*cl)[2] = (uint8_t)(gfx_check_urange(*unpacked, 0, 0xffff) >> 16);
   (*cl)[3] = (uint8_t)(gfx_check_urange(*unpacked, 0, 0xffff) >> 24);
   *cl += 4;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_centroid_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_centroid_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_noperspective_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_NOPERSPECTIVE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_sample_state_indirect(uint8_t **cl, const V3D_CL_SAMPLE_STATE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_STATE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).coverage);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).coverage) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).coverage) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).coverage) >> 24);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_sample_state_indirect(uint8_t **cl, const V3D_CL_SAMPLE_STATE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_STATE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).mask, 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0;
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).coverage) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).coverage) >> 16 >> 8);
   *cl += 4;
}
#endif
static inline void v3d_cl_occlusion_query_counter_enable_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_cfg_bits_indirect(uint8_t **cl, const V3D_CL_CFG_BITS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CFG_BITS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).front_prims, 1) |
      (uint8_t)(gfx_bits((*unpacked).back_prims, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).cwise_is_front, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).depth_offset, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).aa_lines, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).rast_oversample, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).cov_pipe, 1) |
      (uint8_t)(gfx_bits((*unpacked).cov_update, 2) << 1) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_tris, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_test, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).depth_update, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).ez, 1) |
      (uint8_t)(gfx_bits((*unpacked).ez_update, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).stencil, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).blend, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).d3d_prov_vtx, 1) << 5) | (uint8_t)0;
   *cl += 3;
}
static inline void v3d_cl_point_size_indirect(uint8_t **cl, const float *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_POINT_SIZE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
   *cl += 4;
}
static inline void v3d_cl_line_width_indirect(uint8_t **cl, const float *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LINE_WIDTH);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
   *cl += 4;
}
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_depth_offset_indirect(uint8_t **cl, const V3D_CL_DEPTH_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16 >> 8);
   *cl += 4;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_depth_offset_indirect(uint8_t **cl, const V3D_CL_DEPTH_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16 >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).limit);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).limit) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).limit) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).limit) >> 24);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clip_indirect(uint8_t **cl, const V3D_CL_CLIP_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).width, 0, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange((*unpacked).width, 0, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange((*unpacked).height, 0, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange((*unpacked).height, 0, 0x1000) >> 8);
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_viewport_offset_indirect(uint8_t **cl, const V3D_CL_VIEWPORT_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 22);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 22) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).x, 22) >> 16) |
      (uint8_t)(gfx_pack_sint((*unpacked).coarse_x, 10) << 6);
   (*cl)[3] = (uint8_t)(gfx_pack_sint((*unpacked).coarse_x, 10) >> 2);
   (*cl)[4] = (uint8_t)gfx_bits((*unpacked).y, 22);
   (*cl)[5] = (uint8_t)(gfx_bits((*unpacked).y, 22) >> 8);
   (*cl)[6] = (uint8_t)(gfx_bits((*unpacked).y, 22) >> 16) |
      (uint8_t)(gfx_pack_sint((*unpacked).coarse_y, 10) << 6);
   (*cl)[7] = (uint8_t)(gfx_pack_sint((*unpacked).coarse_y, 10) >> 2);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_clip_indirect(uint8_t **cl, const V3D_CL_CLIP_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).width, 1, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange((*unpacked).width, 1, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange((*unpacked).height, 1, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange((*unpacked).height, 1, 0x1000) >> 8);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_viewport_offset_indirect(uint8_t **cl, const V3D_CL_VIEWPORT_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)(uint32_t)(*unpacked).x;
   (*cl)[1] = (uint8_t)((uint32_t)(*unpacked).x >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)(*unpacked).x >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)(*unpacked).x >> 24);
   (*cl)[4] = (uint8_t)(uint32_t)(*unpacked).y;
   (*cl)[5] = (uint8_t)((uint32_t)(*unpacked).y >> 8);
   (*cl)[6] = (uint8_t)((uint32_t)(*unpacked).y >> 16);
   (*cl)[7] = (uint8_t)((uint32_t)(*unpacked).y >> 24);
   *cl += 8;
}
#endif
static inline void v3d_cl_clipz_indirect(uint8_t **cl, const V3D_CL_CLIPZ_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPZ);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).min);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).max);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_xy_indirect(uint8_t **cl, const V3D_CL_CLIPPER_XY_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_XY);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale_x);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).scale_y);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_z_indirect(uint8_t **cl, const V3D_CL_CLIPPER_Z_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_Z);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).offset);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 24);
   *cl += 8;
}
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_num_layers_indirect(uint8_t **cl, const V3D_CL_NUM_LAYERS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_NUM_LAYERS);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_layers, 8);
   *cl += 1;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_binning_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).tile_alloc_initial_block_size, 2) << 2) |
      (uint8_t)(gfx_bits((*unpacked).tile_alloc_block_size, 2) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1(
      gfx_check_urange((*unpacked).num_rts, 1, 4), 4) |
      (uint8_t)(gfx_bits((*unpacked).max_bpp, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).ms_mode, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).double_buffer, 1) << 7);
   (*cl)[2] = (uint8_t)0;
   (*cl)[3] = (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).w_in_pixels, 16);
   (*cl)[5] = (uint8_t)(gfx_pack_uint_minus_1((*unpacked).w_in_pixels, 16) >> 8);
   (*cl)[6] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).h_in_pixels, 16);
   (*cl)[7] = (uint8_t)(gfx_pack_uint_minus_1((*unpacked).h_in_pixels, 16) >> 8);
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_binning_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   if ((*unpacked).type == V3D_BCFG_TYPE_PART1)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART1);
      (*cl)[0] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.part1.auto_init_tile_state, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_initial_block_size, 2) <<
         2) | (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_block_size, 2) << 4) |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) << 6);
      (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >> 2);
      (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         10);
      (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         18);
      (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff);
      (*cl)[5] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff) >> 8) |
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) << 4);
      (*cl)[6] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) >> 4);
      (*cl)[7] = (uint8_t)gfx_check_urange((*unpacked).u.part1.num_rts, 0, 4) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.max_bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.ms_mode, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.double_buffer, 1) << 7);
   }
   else if ((*unpacked).type == V3D_BCFG_TYPE_PART2)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART2);
      (*cl)[0] = (uint8_t)1 | (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) << 6);
      (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >> 2);
      (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         10);
      (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         18);
      (*cl)[4] = (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) << 6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         18);
   }
   else
   {
      unreachable();
   }
   *cl += 8;
}
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_rendering_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   if ((*unpacked).type == V3D_RCFG_TYPE_COMMON)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COMMON);
      (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_pack_uint_minus_1(
         gfx_check_urange((*unpacked).u.common.num_rts, 1, 4), 4) << 4);
      (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff);
      (*cl)[2] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff) >> 8);
      (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff);
      (*cl)[4] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff) >> 8);
      (*cl)[5] = (uint8_t)gfx_bits((*unpacked).u.common.max_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ms_mode, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.double_buffer, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.common.cov_mode, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_direction, 1) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_disable, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.common.internal_depth_type, 4) << 7);
      (*cl)[6] = (uint8_t)(gfx_bits((*unpacked).u.common.internal_depth_type, 4) >>
         1) | (uint8_t)(gfx_bits((*unpacked).u.common.early_ds_clear, 1) << 3) |
         (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_COLOR)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COLOR);
      (*cl)[0] = (uint8_t)1 |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[0].bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[0].type, 4) << 6);
      (*cl)[1] =
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[0].type, 4) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[0].clamp, 2) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[1].bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[1].type, 4) << 6);
      (*cl)[2] =
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[1].type, 4) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[1].clamp, 2) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[2].bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[2].type, 4) << 6);
      (*cl)[3] =
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[2].type, 4) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[2].clamp, 2) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[3].bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[3].type, 4) << 6);
      (*cl)[4] =
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[3].type, 4) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rt_formats[3].clamp, 2) << 2) |
         (uint8_t)0;
      (*cl)[5] = (uint8_t)0;
      (*cl)[6] = (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES);
      (*cl)[0] = (uint8_t)2 | (uint8_t)0;
      (*cl)[1] = (uint8_t)gfx_bits((*unpacked).u.zs_clear_values.stencil_clear, 8);
      (*cl)[2] = (uint8_t)gfx_float_to_bits((*unpacked).u.zs_clear_values.depth_clear);
      (*cl)[3] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 8);
      (*cl)[4] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 16);
      (*cl)[5] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 24);
      (*cl)[6] = (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1);
      (*cl)[0] = (uint8_t)3 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part1.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)(*unpacked).u.clear_colors_part1.clear_col_0;
      (*cl)[2] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 8);
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 16);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 24);
      (*cl)[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24);
      (*cl)[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 8);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2);
      (*cl)[0] = (uint8_t)4 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part2.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_1_shift24, 8);
      (*cl)[2] = (uint8_t)(*unpacked).u.clear_colors_part2.clear_col_2;
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 8);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 16);
      (*cl)[5] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 24);
      (*cl)[6] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3);
      (*cl)[0] = (uint8_t)5 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16);
      (*cl)[2] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16) >> 8);
      (*cl)[3] = (uint8_t)0;
      (*cl)[4] = (uint8_t)0;
      (*cl)[5] = (uint8_t)0;
      (*cl)[6] = (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else
   {
      unreachable();
   }
   *cl += 8;
}
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
static inline void v3d_cl_tile_rendering_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   if ((*unpacked).type == V3D_RCFG_TYPE_COMMON)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COMMON);
      (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_pack_uint_minus_1(
         gfx_check_urange((*unpacked).u.common.num_rts, 1, 4), 4) << 4);
      (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff);
      (*cl)[2] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff) >> 8);
      (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff);
      (*cl)[4] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff) >> 8);
      (*cl)[5] = (uint8_t)gfx_bits((*unpacked).u.common.max_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ms_mode, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.double_buffer, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.common.cov_mode, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_direction, 1) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_disable, 1) << 6) | (uint8_t)0;
      (*cl)[6] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.common.stencil_store, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.common.depth_store, 1) << 7);
      (*cl)[7] = (uint8_t)gfx_bits((*unpacked).u.common.disable_rt_store_mask, 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL);
      (*cl)[0] = (uint8_t)1 | (uint8_t)0;
      (*cl)[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)gfx_bits((*unpacked).u.z_stencil.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) << 6);
      (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) << 1);
      (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) >>
         7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) << 6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL);
      (*cl)[0] = (uint8_t)1 | (uint8_t)(1 << 4);
      (*cl)[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) << 6);
      (*cl)[3] =
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub, 13) << 1);
      (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub,
         13) >> 7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) <<
         6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_COLOR)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COLOR);
      (*cl)[0] = (uint8_t)2 |
         (uint8_t)(gfx_check_urange((*unpacked).u.color.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)gfx_bits((*unpacked).u.color.internal_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)gfx_bits((*unpacked).u.color.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.color.dither_mode, 2) << 6);
      (*cl)[3] = (uint8_t)gfx_bits((*unpacked).u.color.memory_format, 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.flipy, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.pad, 4) << 4);
      (*cl)[4] = (uint8_t)(*unpacked).u.color.addr;
      (*cl)[5] = (uint8_t)((*unpacked).u.color.addr >> 8);
      (*cl)[6] = (uint8_t)((*unpacked).u.color.addr >> 16);
      (*cl)[7] = (uint8_t)((*unpacked).u.color.addr >> 24);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES);
      (*cl)[0] = (uint8_t)3 | (uint8_t)0;
      (*cl)[1] = (uint8_t)gfx_bits((*unpacked).u.zs_clear_values.stencil_clear, 8);
      (*cl)[2] = (uint8_t)gfx_float_to_bits((*unpacked).u.zs_clear_values.depth_clear);
      (*cl)[3] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 8);
      (*cl)[4] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 16);
      (*cl)[5] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 24);
      (*cl)[6] = (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1);
      (*cl)[0] = (uint8_t)4 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part1.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)(*unpacked).u.clear_colors_part1.clear_col_0;
      (*cl)[2] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 8);
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 16);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 24);
      (*cl)[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24);
      (*cl)[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 8);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2);
      (*cl)[0] = (uint8_t)5 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part2.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_1_shift24, 8);
      (*cl)[2] = (uint8_t)(*unpacked).u.clear_colors_part2.clear_col_2;
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 8);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 16);
      (*cl)[5] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 24);
      (*cl)[6] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3);
      (*cl)[0] = (uint8_t)6 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.rt, 0, 3) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16);
      (*cl)[2] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16) >> 8);
      (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff);
      (*cl)[4] = (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff) >> 8);
      (*cl)[5] = (uint8_t)gfx_bits((*unpacked).u.clear_colors_part3.uif_height_in_ub,
         13);
      (*cl)[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.uif_height_in_ub, 13) >> 8) | (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else
   {
      unreachable();
   }
   *cl += 8;
}
#endif
static inline void v3d_cl_multicore_rendering_supertile_cfg_indirect(uint8_t **cl, const V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_w_in_tiles, 8);
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_h_in_tiles, 8);
   (*cl)[2] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_supertiles, 1, 255);
   (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).frame_h_in_supertiles, 1, 255);
   (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff);
   (*cl)[5] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_bits((*unpacked).multicore, 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).supertile_order, 1) << 4) |
      (uint8_t)(gfx_pack_uint_minus_1((*unpacked).num_bin_tile_lists, 3) << 5);
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_tile_list_base_indirect(uint8_t **cl, const V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).set, 4) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 18);
   *cl += 4;
}
static inline void v3d_cl_tile_coords_indirect(uint8_t **cl, const V3D_CL_TILE_COORDS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 12);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).y, 12) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).y, 12) >> 4);
   *cl += 3;
}
static inline void v3d_cl_tile_list_initial_block_size_indirect(uint8_t **cl, const V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).block_size, 2) |
      (uint8_t)(gfx_bits((*unpacked).chain, 1) << 2) | (uint8_t)0;
   *cl += 1;
}
extern void v3d_cl_pack_wait_transform_feedback(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_wait_transform_feedback(uint32_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_branch(v3d_addr_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_generic_tile_list(uint8_t *packed, const V3D_CL_GENERIC_TILE_LIST_T *unpacked);
extern void v3d_cl_unpack_generic_tile_list(V3D_CL_GENERIC_TILE_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch_implicit_tile(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_branch_implicit_tile(uint32_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch_explicit_supertile(uint8_t *packed, const V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked);
extern void v3d_cl_unpack_branch_explicit_supertile(V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_supertile_coords(uint8_t *packed, const V3D_CL_SUPERTILE_COORDS_T *unpacked);
extern void v3d_cl_unpack_supertile_coords(V3D_CL_SUPERTILE_COORDS_T *unpacked, const uint8_t *packed);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_clear(uint8_t *packed, const V3D_CL_CLEAR_T *unpacked);
extern void v3d_cl_unpack_clear(V3D_CL_CLEAR_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_store(uint8_t *packed, const V3D_CL_STORE_T *unpacked);
extern void v3d_cl_unpack_store(V3D_CL_STORE_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_load(uint8_t *packed, const V3D_CL_LOAD_T *unpacked);
extern void v3d_cl_unpack_load(V3D_CL_LOAD_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_store_subsample_ex(uint8_t *packed, const V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked);
extern void v3d_cl_unpack_store_subsample_ex(V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_load(uint8_t *packed, const V3D_CL_LOAD_T *unpacked);
extern void v3d_cl_unpack_load(V3D_CL_LOAD_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_store_general(uint8_t *packed, const V3D_CL_STORE_GENERAL_T *unpacked);
extern void v3d_cl_unpack_store_general(V3D_CL_STORE_GENERAL_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_load_general(uint8_t *packed, const V3D_CL_LOAD_GENERAL_T *unpacked);
extern void v3d_cl_unpack_load_general(V3D_CL_LOAD_GENERAL_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indexed_prim_list(uint8_t *packed, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_prim_list(V3D_CL_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indexed_prim_list(uint8_t *packed, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_prim_list(V3D_CL_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indirect_indexed_prim_list(uint8_t *packed, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indirect_indexed_prim_list(V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indirect_indexed_prim_list(uint8_t *packed, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indirect_indexed_prim_list(V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indexed_instanced_prim_list(uint8_t *packed, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_instanced_prim_list(V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indexed_instanced_prim_list(uint8_t *packed, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_instanced_prim_list(V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_vertex_array_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_prims(V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indirect_vertex_array_prims(uint8_t *packed, const V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_indirect_vertex_array_prims(V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vertex_array_instanced_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_instanced_prims(V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vertex_array_single_instance_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_single_instance_prims(V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_base_vertex_base_instance(uint8_t *packed, const V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked);
extern void v3d_cl_unpack_base_vertex_base_instance(V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked, const uint8_t *packed);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_index_buffer_setup(uint8_t *packed, const V3D_CL_INDEX_BUFFER_SETUP_T *unpacked);
extern void v3d_cl_unpack_index_buffer_setup(V3D_CL_INDEX_BUFFER_SETUP_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_indirect_primitive_limits(uint8_t *packed, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked);
extern void v3d_cl_unpack_indirect_primitive_limits(V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_vg_coord_array_prims(uint8_t *packed, const V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vg_coord_array_prims(V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vg_inline_prims(uint8_t *packed, const V3D_CL_VG_INLINE_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vg_inline_prims(V3D_CL_VG_INLINE_PRIMS_T *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_clipped_prim(uint8_t *packed, const V3D_CL_CLIPPED_PRIM_T *unpacked);
extern void v3d_cl_unpack_clipped_prim(V3D_CL_CLIPPED_PRIM_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_set_instance_id(uint8_t *packed, const V3D_CL_SET_INSTANCE_ID_T *unpacked);
extern void v3d_cl_unpack_set_instance_id(V3D_CL_SET_INSTANCE_ID_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_set_primitive_id(uint8_t *packed, const V3D_CL_SET_PRIMITIVE_ID_T *unpacked);
extern void v3d_cl_unpack_set_primitive_id(V3D_CL_SET_PRIMITIVE_ID_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_prim_list_format(uint8_t *packed, const V3D_CL_PRIM_LIST_FORMAT_T *unpacked);
extern void v3d_cl_unpack_prim_list_format(V3D_CL_PRIM_LIST_FORMAT_T *unpacked, const uint8_t *packed);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_serial_number_list_start(uint8_t *packed, const V3D_CL_SERIAL_NUMBER_LIST_START_T *unpacked);
extern void v3d_cl_unpack_serial_number_list_start(V3D_CL_SERIAL_NUMBER_LIST_START_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_gl_shader(uint8_t *packed, const V3D_CL_GL_SHADER_T *unpacked);
extern void v3d_cl_unpack_gl_shader(V3D_CL_GL_SHADER_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_gl_shader(uint8_t *packed, const V3D_CL_GL_SHADER_T *unpacked);
extern void v3d_cl_unpack_gl_shader(V3D_CL_GL_SHADER_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_vg_shader(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_vg_shader(v3d_addr_t *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vg_inline_shader(uint8_t *packed, const V3D_CL_VG_INLINE_SHADER_T *unpacked);
extern void v3d_cl_unpack_vg_inline_shader(V3D_CL_VG_INLINE_SHADER_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vg_inline_shader(uint8_t *packed, const V3D_CL_VG_INLINE_SHADER_T *unpacked);
extern void v3d_cl_unpack_vg_inline_shader(V3D_CL_VG_INLINE_SHADER_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vcm_cache_size(uint8_t *packed, const V3D_CL_VCM_CACHE_SIZE_T *unpacked);
extern void v3d_cl_unpack_vcm_cache_size(V3D_CL_VCM_CACHE_SIZE_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_prim_counts_feedback(uint8_t *packed, const V3D_CL_PRIM_COUNTS_FEEDBACK_T *unpacked);
extern void v3d_cl_unpack_prim_counts_feedback(V3D_CL_PRIM_COUNTS_FEEDBACK_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_transform_feedback_buffer(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T *unpacked);
extern void v3d_cl_unpack_transform_feedback_buffer(V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_transform_feedback_specs(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_SPECS_T *unpacked);
extern void v3d_cl_unpack_transform_feedback_specs(V3D_CL_TRANSFORM_FEEDBACK_SPECS_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vcm_cache_size(uint8_t *packed, const V3D_CL_VCM_CACHE_SIZE_T *unpacked);
extern void v3d_cl_unpack_vcm_cache_size(V3D_CL_VCM_CACHE_SIZE_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_transform_feedback_enable(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked);
extern void v3d_cl_unpack_transform_feedback_enable(V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_clear_slice_caches(uint8_t *packed, const V3D_CL_CLEAR_SLICE_CACHES_T *unpacked);
extern void v3d_cl_unpack_clear_slice_caches(V3D_CL_CLEAR_SLICE_CACHES_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_flush_l2t(uint8_t *packed, const V3D_CL_FLUSH_L2T_T *unpacked);
extern void v3d_cl_unpack_flush_l2t(V3D_CL_FLUSH_L2T_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_stencil_cfg(uint8_t *packed, const V3D_CL_STENCIL_CFG_T *unpacked);
extern void v3d_cl_unpack_stencil_cfg(V3D_CL_STENCIL_CFG_T *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_blend_cfg(uint8_t *packed, const V3D_CL_BLEND_CFG_T *unpacked);
extern void v3d_cl_unpack_blend_cfg(V3D_CL_BLEND_CFG_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_blend_enables(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_blend_enables(uint32_t *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_blend_cfg(uint8_t *packed, const V3D_CL_BLEND_CFG_T *unpacked);
extern void v3d_cl_unpack_blend_cfg(V3D_CL_BLEND_CFG_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_blend_ccolor(uint8_t *packed, const V3D_CL_BLEND_CCOLOR_T *unpacked);
extern void v3d_cl_unpack_blend_ccolor(V3D_CL_BLEND_CCOLOR_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_color_wmasks(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_color_wmasks(uint32_t *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vary_flags(uint8_t *packed, const V3D_CL_VARY_FLAGS_T *unpacked);
extern void v3d_cl_unpack_vary_flags(V3D_CL_VARY_FLAGS_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_vary_flags(uint8_t *packed, const V3D_CL_VARY_FLAGS_T *unpacked);
extern void v3d_cl_unpack_vary_flags(V3D_CL_VARY_FLAGS_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_sample_state(uint8_t *packed, const V3D_CL_SAMPLE_STATE_T *unpacked);
extern void v3d_cl_unpack_sample_state(V3D_CL_SAMPLE_STATE_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_sample_state(uint8_t *packed, const V3D_CL_SAMPLE_STATE_T *unpacked);
extern void v3d_cl_unpack_sample_state(V3D_CL_SAMPLE_STATE_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_occlusion_query_counter_enable(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_occlusion_query_counter_enable(v3d_addr_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_cfg_bits(uint8_t *packed, const V3D_CL_CFG_BITS_T *unpacked);
extern void v3d_cl_unpack_cfg_bits(V3D_CL_CFG_BITS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_point_size(uint8_t *packed, const float *unpacked);
extern void v3d_cl_unpack_point_size(float *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_line_width(uint8_t *packed, const float *unpacked);
extern void v3d_cl_unpack_line_width(float *unpacked, const uint8_t *packed);
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_depth_offset(uint8_t *packed, const V3D_CL_DEPTH_OFFSET_T *unpacked);
extern void v3d_cl_unpack_depth_offset(V3D_CL_DEPTH_OFFSET_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_depth_offset(uint8_t *packed, const V3D_CL_DEPTH_OFFSET_T *unpacked);
extern void v3d_cl_unpack_depth_offset(V3D_CL_DEPTH_OFFSET_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_clip(uint8_t *packed, const V3D_CL_CLIP_T *unpacked);
extern void v3d_cl_unpack_clip(V3D_CL_CLIP_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_viewport_offset(uint8_t *packed, const V3D_CL_VIEWPORT_OFFSET_T *unpacked);
extern void v3d_cl_unpack_viewport_offset(V3D_CL_VIEWPORT_OFFSET_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_clip(uint8_t *packed, const V3D_CL_CLIP_T *unpacked);
extern void v3d_cl_unpack_clip(V3D_CL_CLIP_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_viewport_offset(uint8_t *packed, const V3D_CL_VIEWPORT_OFFSET_T *unpacked);
extern void v3d_cl_unpack_viewport_offset(V3D_CL_VIEWPORT_OFFSET_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_clipz(uint8_t *packed, const V3D_CL_CLIPZ_T *unpacked);
extern void v3d_cl_unpack_clipz(V3D_CL_CLIPZ_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipper_xy(uint8_t *packed, const V3D_CL_CLIPPER_XY_T *unpacked);
extern void v3d_cl_unpack_clipper_xy(V3D_CL_CLIPPER_XY_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipper_z(uint8_t *packed, const V3D_CL_CLIPPER_Z_T *unpacked);
extern void v3d_cl_unpack_clipper_z(V3D_CL_CLIPPER_Z_T *unpacked, const uint8_t *packed);
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_num_layers(uint8_t *packed, const V3D_CL_NUM_LAYERS_T *unpacked);
extern void v3d_cl_unpack_num_layers(V3D_CL_NUM_LAYERS_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_tile_binning_mode_cfg(uint8_t *packed, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_binning_mode_cfg(V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_tile_binning_mode_cfg(uint8_t *packed, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_binning_mode_cfg(V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked, const uint8_t *packed);
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_tile_rendering_mode_cfg(uint8_t *packed, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_rendering_mode_cfg(V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked, const uint8_t *packed);
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
extern void v3d_cl_pack_tile_rendering_mode_cfg(uint8_t *packed, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_rendering_mode_cfg(V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked, const uint8_t *packed);
#endif
extern void v3d_cl_pack_multicore_rendering_supertile_cfg(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked);
extern void v3d_cl_unpack_multicore_rendering_supertile_cfg(V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_multicore_rendering_tile_list_base(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked);
extern void v3d_cl_unpack_multicore_rendering_tile_list_base(V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_coords(uint8_t *packed, const V3D_CL_TILE_COORDS_T *unpacked);
extern void v3d_cl_unpack_tile_coords(V3D_CL_TILE_COORDS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_list_initial_block_size(uint8_t *packed, const V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked);
extern void v3d_cl_unpack_tile_list_initial_block_size(V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked, const uint8_t *packed);
typedef struct {
   v3d_cl_opcode_t opcode;
   union {
      uint32_t wait_transform_feedback;
      v3d_addr_t branch;
      V3D_CL_GENERIC_TILE_LIST_T generic_tile_list;
      uint32_t branch_implicit_tile;
      V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T branch_explicit_supertile;
      V3D_CL_SUPERTILE_COORDS_T supertile_coords;
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_CLEAR_T clear;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_STORE_T store;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_LOAD_T load;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_STORE_SUBSAMPLE_EX_T store_subsample_ex;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_LOAD_T load;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_STORE_GENERAL_T store_general;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_LOAD_GENERAL_T load_general;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDEXED_PRIM_LIST_T indexed_prim_list;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDEXED_PRIM_LIST_T indexed_prim_list;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T indirect_indexed_prim_list;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T indirect_indexed_prim_list;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T indexed_instanced_prim_list;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T indexed_instanced_prim_list;
#endif
      V3D_CL_VERTEX_ARRAY_PRIMS_T vertex_array_prims;
      V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T indirect_vertex_array_prims;
      V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T vertex_array_instanced_prims;
      V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T vertex_array_single_instance_prims;
      V3D_CL_BASE_VERTEX_BASE_INSTANCE_T base_vertex_base_instance;
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDEX_BUFFER_SETUP_T index_buffer_setup;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T indirect_primitive_limits;
#endif
      V3D_CL_VG_COORD_ARRAY_PRIMS_T vg_coord_array_prims;
      V3D_CL_VG_INLINE_PRIMS_T vg_inline_prims;
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_CLIPPED_PRIM_T clipped_prim;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_SET_INSTANCE_ID_T set_instance_id;
#endif
      V3D_CL_SET_PRIMITIVE_ID_T set_primitive_id;
      V3D_CL_PRIM_LIST_FORMAT_T prim_list_format;
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_SERIAL_NUMBER_LIST_START_T serial_number_list_start;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_GL_SHADER_T gl_shader;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_GL_SHADER_T gl_shader;
#endif
      v3d_addr_t vg_shader;
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VG_INLINE_SHADER_T vg_inline_shader;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VG_INLINE_SHADER_T vg_inline_shader;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VCM_CACHE_SIZE_T vcm_cache_size;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_PRIM_COUNTS_FEEDBACK_T prim_counts_feedback;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T transform_feedback_buffer;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TRANSFORM_FEEDBACK_SPECS_T transform_feedback_specs;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VCM_CACHE_SIZE_T vcm_cache_size;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T transform_feedback_enable;
#endif
      V3D_CL_CLEAR_SLICE_CACHES_T clear_slice_caches;
      V3D_CL_FLUSH_L2T_T flush_l2t;
      V3D_CL_STENCIL_CFG_T stencil_cfg;
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_BLEND_CFG_T blend_cfg;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      uint32_t blend_enables;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_BLEND_CFG_T blend_cfg;
#endif
      V3D_CL_BLEND_CCOLOR_T blend_ccolor;
      uint32_t color_wmasks;
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VARY_FLAGS_T vary_flags;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VARY_FLAGS_T vary_flags;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_SAMPLE_STATE_T sample_state;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_SAMPLE_STATE_T sample_state;
#endif
      v3d_addr_t occlusion_query_counter_enable;
      V3D_CL_CFG_BITS_T cfg_bits;
      float point_size;
      float line_width;
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_DEPTH_OFFSET_T depth_offset;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_DEPTH_OFFSET_T depth_offset;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_CLIP_T clip;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VIEWPORT_OFFSET_T viewport_offset;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_CLIP_T clip;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_VIEWPORT_OFFSET_T viewport_offset;
#endif
      V3D_CL_CLIPZ_T clipz;
      V3D_CL_CLIPPER_XY_T clipper_xy;
      V3D_CL_CLIPPER_Z_T clipper_z;
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_NUM_LAYERS_T num_layers;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TILE_BINNING_MODE_CFG_T tile_binning_mode_cfg;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TILE_BINNING_MODE_CFG_T tile_binning_mode_cfg;
#endif
#if V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TILE_RENDERING_MODE_CFG_T tile_rendering_mode_cfg;
#endif
#if !V3D_VER_AT_LEAST(4,1,34,0)
      V3D_CL_TILE_RENDERING_MODE_CFG_T tile_rendering_mode_cfg;
#endif
      V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T multicore_rendering_supertile_cfg;
      V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T multicore_rendering_tile_list_base;
      V3D_CL_TILE_COORDS_T tile_coords;
      V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T tile_list_initial_block_size;
   } u;
} V3D_CL_INSTR_T;
extern void v3d_cl_pack_instr(uint8_t *packed_instr, const V3D_CL_INSTR_T *instr);
extern void v3d_cl_unpack_instr(V3D_CL_INSTR_T *instr, const uint8_t *packed_instr);
EXTERN_C_END
#endif
