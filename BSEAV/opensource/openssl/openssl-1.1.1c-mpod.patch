diff -rNup openssl-1.1.1c.orig/apps/apps.c openssl-1.1.1c/apps/apps.c
--- openssl-1.1.1c.orig/apps/apps.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/apps/apps.c	2019-08-20 18:03:11.597668752 -0700
@@ -705,6 +705,49 @@ X509_CRL *load_crl(const char *infile, i
     return x;
 }
 
+/* yexu 10/8/2014 */
+/********************************************************************************/
+X509 *load_cert_buffer(BIO *err,  unsigned long buffer_len, const char *buffer, int format,
+	const char *pass, ENGINE *e, const char *cert_descrip)
+	{
+	X509 *x=NULL;
+	BIO *cert;
+
+	if ((cert=BIO_new(BIO_s_file())) == NULL)
+		{
+		ERR_print_errors(err);
+		goto end;
+		}
+
+	if 	(format == FORMAT_ASN1)
+		x=d2i_X509_bio_buffer(buffer_len, buffer, NULL);
+	else if (format == FORMAT_PEM)
+		x=PEM_read_bio_buffer_X509_AUX(cert,NULL,
+			(pem_password_cb *)password_callback, NULL, buffer_len, buffer);
+	else if (format == FORMAT_PKCS12)
+		{
+		PKCS12 *p12 = d2i_PKCS12_bio(cert, NULL);
+
+		PKCS12_parse(p12, NULL, NULL, &x, NULL);
+		PKCS12_free(p12);
+		p12 = NULL;
+		}
+	else	{
+		BIO_printf(err,"bad input format specified for %s\n",
+			cert_descrip);
+		goto end;
+		}
+end:
+	if (x == NULL)
+		{
+		BIO_printf(err,"unable to load certificate\n");
+		ERR_print_errors(err);
+		}
+	if (cert != NULL) BIO_free(cert);
+	return(x);
+	}
+/********************************************************************************/
+
 EVP_PKEY *load_key(const char *file, int format, int maybe_stdin,
                    const char *pass, ENGINE *e, const char *key_descrip)
 {
diff -rNup openssl-1.1.1c.orig/apps/apps.h openssl-1.1.1c/apps/apps.h
--- openssl-1.1.1c.orig/apps/apps.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/apps/apps.h	2019-08-20 18:03:11.597668752 -0700
@@ -461,6 +461,11 @@ int copy_extensions(X509 *x, X509_REQ *r
 int app_passwd(const char *arg1, const char *arg2, char **pass1, char **pass2);
 int add_oid_section(CONF *conf);
 X509 *load_cert(const char *file, int format, const char *cert_descrip);
+/* yexu 10/8/2014 */
+/********************************************************************************/
+X509 *load_cert_buffer(BIO *err, unsigned long buffer_len, const char *buffer, int format,
+	const char *pass, ENGINE *e, const char *cert_descrip);
+/********************************************************************************/
 X509_CRL *load_crl(const char *infile, int format);
 EVP_PKEY *load_key(const char *file, int format, int maybe_stdin,
                    const char *pass, ENGINE *e, const char *key_descrip);
diff -rNup openssl-1.1.1c.orig/apps/openssl.cnf openssl-1.1.1c/apps/openssl.cnf
--- openssl-1.1.1c.orig/apps/openssl.cnf	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/apps/openssl.cnf	2019-08-20 18:03:11.597668752 -0700
@@ -42,7 +42,8 @@ default_ca	= CA_default		# The default c
 ####################################################################
 [ CA_default ]
 
-dir		= ./demoCA		# Where everything is kept
+# yexu 10/8/2014 
+dir		= ../apps/demoCA		# Where everything is kept       BSYT
 certs		= $dir/certs		# Where the issued certs are kept
 crl_dir		= $dir/crl		# Where the issued crl are kept
 database	= $dir/index.txt	# database index file.
@@ -50,12 +51,14 @@ database	= $dir/index.txt	# database ind
 					# several certs with same subject.
 new_certs_dir	= $dir/newcerts		# default place for new certs.
 
-certificate	= $dir/cacert.pem 	# The CA certificate
+# yexu 10/8/2014 
+certificate	= $dir/CAcert.pem 	# The CA certificate
 serial		= $dir/serial 		# The current serial number
 crlnumber	= $dir/crlnumber	# the current crl number
 					# must be commented out to leave a V1 CRL
 crl		= $dir/crl.pem 		# The current CRL
-private_key	= $dir/private/cakey.pem# The private key
+# yexu 10/8/2014
+private_key	= $dir/private/CAkey.pem# The private key
 
 x509_extensions	= usr_cert		# The extensions to add to the cert
 
@@ -128,30 +131,40 @@ string_mask = utf8only
 
 [ req_distinguished_name ]
 countryName			= Country Name (2 letter code)
-countryName_default		= AU
+# yexu 10/8/2014
+countryName_default		= US   # BSYT
 countryName_min			= 2
 countryName_max			= 2
 
 stateOrProvinceName		= State or Province Name (full name)
-stateOrProvinceName_default	= Some-State
+# yexu 10/8/2014 
+stateOrProvinceName_default	= California  # BSYT
 
 localityName			= Locality Name (eg, city)
+# yexu 10/8/2014 
+localityName_default			= Irvine    # BSYT
 
 0.organizationName		= Organization Name (eg, company)
-0.organizationName_default	= Internet Widgits Pty Ltd
+# yexu 10/8/2014 
+0.organizationName_default	= Broadcom Corp. # BSYT
 
 # we can do this but it is not needed normally :-)
 #1.organizationName		= Second Organization Name (eg, company)
 #1.organizationName_default	= World Wide Web Pty Ltd
 
 organizationalUnitName		= Organizational Unit Name (eg, section)
-#organizationalUnitName_default	=
+# yexu 10/8/2014
+organizationalUnitName_default	= BroadBand Engineering Systems # BSYT
 
 commonName			= Common Name (e.g. server FQDN or YOUR name)
 commonName_max			= 64
+# yexu 10/8/2014
+commonName_default			= Bryant Tan  # BSYT
 
 emailAddress			= Email Address
-emailAddress_max		= 64
+# yexu 10/8/2014 
+emailAddress_max		= 40
+emailAddress_default	= btan@broadcom.com
 
 # SET-ex3			= SET extension number 3
 
diff -rNup openssl-1.1.1c.orig/crypto/asn1/a_d2i_fp.c openssl-1.1.1c/crypto/asn1/a_d2i_fp.c
--- openssl-1.1.1c.orig/crypto/asn1/a_d2i_fp.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/asn1/a_d2i_fp.c	2019-08-20 18:03:11.597668752 -0700
@@ -14,6 +14,9 @@
 #include <openssl/buffer.h>
 #include <openssl/asn1.h>
 #include "internal/asn1_int.h"
+/* yexu 10/8/2014 */
+int buf_read (int buffer_len, const char *buffer, void *out, int outl);
+static int asn1_d2i_read_bio_buffer(int buffer_len, const char *buffer, BUF_MEM **pb);
 
 #ifndef NO_OLD_ASN1
 # ifndef OPENSSL_NO_STDIO
@@ -54,6 +57,24 @@ void *ASN1_d2i_bio(void *(*xnew) (void),
 
 #endif
 
+/* yexu 10/8/2014 */
+void *ASN1_item_d2i_bio_buffer(const ASN1_ITEM *it, int buffer_len, const char *buffer, void *x)
+{
+	BUF_MEM *b = NULL;
+	const unsigned char *p;
+	void *ret=NULL;
+	int len;
+
+	len = asn1_d2i_read_bio_buffer(buffer_len, buffer, &b);
+	if(len < 0) goto err;
+
+	p=(const unsigned char *)b->data;
+	ret=ASN1_item_d2i(x,&p,len, it);
+err:
+	if (b != NULL) BUF_MEM_free(b);
+	return(ret);
+}
+
 void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)
 {
     BUF_MEM *b = NULL;
@@ -232,3 +253,111 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM *
     BUF_MEM_free(b);
     return -1;
 }
+
+/* yexu 10/8/2014 */
+/********************************************************************************/
+static int asn1_d2i_read_bio_buffer(int buffer_len, const char *buffer, BUF_MEM **pb)
+{
+	BUF_MEM *b;
+	unsigned char *p;
+	int i;
+	int ret=-1;
+	int want=HEADER_SIZE;
+	uint32_t eos=0;
+    size_t off = 0;
+    size_t len = 0;
+
+    const unsigned char *q;
+    long slen;
+    int inf, tag, xclass;
+
+	b=BUF_MEM_new();
+	if (b == NULL) {
+		ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);
+		return -1;
+	}
+
+	ERR_clear_error();
+	for (;;) {
+		if (want >= (len-off)) {
+			want-=(len-off);
+
+			if (!BUF_MEM_grow_clean(b,len+want)) {
+				ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);
+				goto err;
+			}
+			/*BSYT i=BIO_read(in,&(b->data[len]),want);*/
+			i = buf_read(buffer_len, buffer, &(b->data[len]),want);
+			if ((i < 0) && ((len-off) == 0)) {
+				ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ASN1_R_NOT_ENOUGH_DATA);
+				goto err;
+			}
+			if (i > 0)
+				len+=i;
+		}
+		/* else data already loaded */
+
+		p=(unsigned char *)&(b->data[off]);
+        q = p;
+        inf = ASN1_get_object(&q, &slen, &tag, &xclass, len - off);
+        if (inf & 0x80) {
+			unsigned long e;
+
+			e=ERR_GET_REASON(ERR_peek_error());
+			if (e != ASN1_R_TOO_LONG)
+				goto err;
+			else
+				ERR_clear_error(); /* clear error */
+		}
+        i = q - p;            /* header length */
+		off+=i;	/* end of data */
+
+		if (inf & 1) {
+			/* no data body so go round again */
+			eos++;
+			want=HEADER_SIZE;
+		}
+        else if (eos && (slen == 0) && (tag == V_ASN1_EOC)) {
+			/* eos value, so go back and read another header */
+			eos--;
+            if (eos == 0)
+				break;
+			else
+				want=HEADER_SIZE;
+		}
+		else {
+			/* suck in slen bytes of data */
+            want = slen;
+			if (want > (len-off)) {
+				want-=(len-off);
+				if (!BUF_MEM_grow_clean(b,len+want)) {
+					ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);
+					goto err;
+				}
+				while (want > 0) {
+					//BSYT i=BIO_read(in,&(b->data[len]),want);
+					i = buf_read(buffer_len, buffer+len, &(b->data[len]),want);
+					if (i <= 0) {
+						ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ASN1_R_NOT_ENOUGH_DATA);
+						goto err;
+					}
+					len+=i;
+					want -= i;
+				}
+			}
+			off+=slen;
+			if (eos <= 0) {
+				break;
+			}
+			else
+				want=HEADER_SIZE;
+		}
+	}
+
+	*pb = b;
+	return off;
+err:
+	if (b != NULL) BUF_MEM_free(b);
+	return(ret);
+}
+/********************************************************************************/
diff -rNup openssl-1.1.1c.orig/crypto/bio/bio_lib.c openssl-1.1.1c/crypto/bio/bio_lib.c
--- openssl-1.1.1c.orig/crypto/bio/bio_lib.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/bio/bio_lib.c	2019-08-20 18:03:11.597668752 -0700
@@ -187,6 +187,14 @@ int BIO_up_ref(BIO *a)
     return ((i > 1) ? 1 : 0);
 }
 
+/* yexu 10/8/2014 */
+/* simulate BIO_read */
+int buf_read (int buffer_len, const char *buffer, void *out, int outl)
+{
+	memcpy(out, buffer, outl);
+	return(outl);
+}
+
 void BIO_clear_flags(BIO *b, int flags)
 {
     b->flags &= ~flags;
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_info.c openssl-1.1.1c/crypto/pem/pem_info.c
--- openssl-1.1.1c.orig/crypto/pem/pem_info.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_info.c	2019-08-20 18:03:11.597668752 -0700
@@ -35,19 +35,231 @@ STACK_OF(X509_INFO) *PEM_X509_INFO_read(
 }
 #endif
 
-STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk,
-                                            pem_password_cb *cb, void *u)
-{
-    X509_INFO *xi = NULL;
-    char *name = NULL, *header = NULL;
-    void *pp;
-    unsigned char *data = NULL;
+/* yexu 10/8/2014 */
+/**********************************************************************************/
+/* Modified PEM_X509_INFO_read_bio to create PEM_X509_INFO_read_bio_from_buffer */
+STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio_from_buffer(unsigned long buffer_len, const char *buffer, 
+STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
+	{
+	X509_INFO *xi=NULL;
+	char *name=NULL,*header=NULL;
+	void *pp;
+	unsigned char *data=NULL;
     const unsigned char *p;
-    long len, error = 0;
-    int ok = 0;
-    STACK_OF(X509_INFO) *ret = NULL;
-    unsigned int i, raw, ptype;
-    d2i_of_void *d2i = 0;
+	long len,error=0;
+	int ok=0;
+	unsigned long curr_pos=0;
+	STACK_OF(X509_INFO) *ret=NULL;
+	unsigned int i,raw,ptype;
+	d2i_of_void *d2i = 0;
+
+	if (sk == NULL) {
+		if ((ret=sk_X509_INFO_new_null()) == NULL) {
+			PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_MALLOC_FAILURE);
+			goto err;
+		}
+	} else
+		ret=sk;
+
+	if ((xi=X509_INFO_new()) == NULL)
+        goto err;
+	for (;;) {
+		raw=0;
+        ptype = 0;
+		i=PEM_read_bio_buffer(buffer_len, buffer, &curr_pos, &name,&header,&data,&len);
+		if (i == 0) {
+			error=ERR_GET_REASON(ERR_peek_last_error());
+			if (error == PEM_R_NO_START_LINE) {
+				ERR_clear_error();
+				break;
+			}
+			goto err;
+		}
+start:
+		if ((strcmp(name,PEM_STRING_X509) == 0) ||
+			(strcmp(name,PEM_STRING_X509_OLD) == 0)) {
+			d2i=(D2I_OF(void)) d2i_X509;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret,xi))
+                    goto err;
+				if ((xi=X509_INFO_new()) == NULL)
+                    goto err;
+				goto start;
+			}
+			pp = &(xi->x509);
+		} else if ((strcmp(name,PEM_STRING_X509_TRUSTED) == 0)) {
+            d2i = (D2I_OF(void)) d2i_X509_AUX;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret,xi))
+                    goto err;
+				if ((xi=X509_INFO_new()) == NULL)
+                    goto err;
+				goto start;
+			}
+            pp = &(xi->x509);
+		} else if (strcmp(name,PEM_STRING_X509_CRL) == 0) {
+            d2i = (D2I_OF(void)) d2i_X509_CRL;
+			if (xi->crl != NULL) {
+				if (!sk_X509_INFO_push(ret,xi))
+                    goto err;
+				if ((xi=X509_INFO_new()) == NULL)
+                    goto err;
+				goto start;
+			}
+            pp = &(xi->crl);
+		} else
+#ifndef OPENSSL_NO_RSA
+			if (strcmp(name,PEM_STRING_RSA) == 0) {
+            d2i = (D2I_OF(void)) d2i_RSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret,xi))
+                    goto err;
+				if ((xi=X509_INFO_new()) == NULL)
+                    goto err;
+				goto start;
+			}
+
+			xi->enc_data=NULL;
+			xi->enc_len=0;
+
+			xi->x_pkey=X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+				goto err;
+            ptype = EVP_PKEY_RSA;
+            pp = &xi->x_pkey->dec_pkey;
+			if ((int)strlen(header) > 10) /* assume encrypted */
+				raw=1;
+		} else
+#endif
+#ifndef OPENSSL_NO_DSA
+			if (strcmp(name,PEM_STRING_DSA) == 0) {
+            d2i = (D2I_OF(void)) d2i_DSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret,xi))
+                    goto err;
+				if ((xi=X509_INFO_new()) == NULL)
+                    goto err;
+				goto start;
+			}
+
+			xi->enc_data=NULL;
+			xi->enc_len=0;
+
+			xi->x_pkey=X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_DSA;
+            pp = &xi->x_pkey->dec_pkey;
+			if ((int)strlen(header) > 10) /* assume encrypted */
+				raw=1;
+		} else
+#endif
+#ifndef OPENSSL_NO_EC
+        if (strcmp(name, PEM_STRING_ECPRIVATEKEY) == 0) {
+            d2i = (D2I_OF(void)) d2i_ECPrivateKey;
+            if (xi->x_pkey != NULL) {
+                if (!sk_X509_INFO_push(ret, xi))
+                    goto err;
+                if ((xi = X509_INFO_new()) == NULL)
+                    goto err;
+                goto start;
+            }
+
+            xi->enc_data = NULL;
+            xi->enc_len = 0;
+
+            xi->x_pkey = X509_PKEY_new();
+            if (xi->x_pkey == NULL)
+                goto err;
+            ptype = EVP_PKEY_EC;
+            pp = &xi->x_pkey->dec_pkey;
+            if ((int)strlen(header) > 10) /* assume encrypted */
+                raw = 1;
+        } else
+#endif
+		{
+			d2i=NULL;
+			pp=NULL;
+		}
+
+		if (d2i != NULL) {
+			if (!raw) {
+				EVP_CIPHER_INFO cipher;
+
+				if (!PEM_get_EVP_CIPHER_INFO(header,&cipher))
+					goto err;
+				if (!PEM_do_header(&cipher,data,&len,cb,u))
+					goto err;
+				p=data;
+                if (ptype) {
+                    if (!d2i_PrivateKey(ptype, pp, &p, len)) {
+                        PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
+                        goto err;
+                    }
+                } else if (d2i(pp, &p, len) == NULL) {
+                    PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
+                    goto err;
+                }
+            } else {            /* encrypted RSA data */
+                if (!PEM_get_EVP_CIPHER_INFO(header, &xi->enc_cipher))
+                    goto err;
+                xi->enc_data = (char *)data;
+                xi->enc_len = (int)len;
+                data = NULL;
+            }
+        } else {
+            /* unknown */
+        }
+        OPENSSL_free(name);
+        name = NULL;
+        OPENSSL_free(header);
+        header = NULL;
+        OPENSSL_free(data);
+        data = NULL;
+	}
+
+	/* if the last one hasn't been pushed yet and there is anything
+	 * in it then add it to the stack ... 
+	 */
+	if ((xi->x509 != NULL) || (xi->crl != NULL) ||
+		(xi->x_pkey != NULL) || (xi->enc_data != NULL)) {
+		if (!sk_X509_INFO_push(ret,xi))
+            goto err;
+		xi=NULL;
+	}
+	ok=1;
+err:
+	if (xi != NULL)
+        X509_INFO_free(xi);
+	if (!ok) {
+		for (i=0; ((int)i)<sk_X509_INFO_num(ret); i++) {
+			xi=sk_X509_INFO_value(ret,i);
+			X509_INFO_free(xi);
+		}
+		if (ret != sk)
+            sk_X509_INFO_free(ret);
+		ret=NULL;
+	}
+		
+    OPENSSL_free(name);
+    OPENSSL_free(header);
+    OPENSSL_free(data);
+    return ret;
+}
+/**********************************************************************************/
+
+STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
+	{
+	X509_INFO *xi=NULL;
+	char *name=NULL,*header=NULL;
+	void *pp;
+	unsigned char *data=NULL;
+	const unsigned char *p;
+	long len,error=0;
+	int ok=0;
+	STACK_OF(X509_INFO) *ret=NULL;
+	unsigned int i,raw,ptype;
+	d2i_of_void *d2i = 0;
 
     if (sk == NULL) {
         if ((ret = sk_X509_INFO_new_null()) == NULL) {
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_lib.c openssl-1.1.1c/crypto/pem/pem_lib.c
--- openssl-1.1.1c.orig/crypto/pem/pem_lib.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_lib.c	2019-08-20 18:03:11.597668752 -0700
@@ -28,6 +28,23 @@ static int load_iv(char **fromp, unsigne
 static int check_pem(const char *nm, const char *name);
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
+/* yexu 10/8/2014 */
+/* simulate fgets */
+int buf_gets(char *result, unsigned int size, const char *source, unsigned long source_len)
+{
+   unsigned int count = 0;
+
+   while( (count < size) && (count <= source_len) ) {
+      result[count] = source[count];
+      if (source[count++] == '\n') {
+         break;
+      }
+   }
+   return count;
+
+}
+
+
 int PEM_def_callback(char *buf, int num, int rwflag, void *userdata)
 {
     int i, min_len;
@@ -118,6 +135,23 @@ void *PEM_ASN1_read(d2i_of_void *d2i, co
     BIO_free(b);
     return ret;
 }
+
+/* yexu 10/8/2014 */
+char *PEM_ASN1_read_buffer(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
+	     pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer)
+{
+    BIO *b;
+    char *ret;
+
+	if ((b=BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);
+        return(0);
+	}
+    /*BIO_set_fp(b,fp,BIO_NOCLOSE);*/
+    ret=PEM_ASN1_read_bio_buffer(d2i, name, b, x, cb, u, buffer_len, buffer);
+    BIO_free(b);
+    return(ret);
+	}
 #endif
 
 static int check_pem(const char *nm, const char *name)
@@ -272,6 +306,50 @@ static int pem_bytes_read_bio_flags(unsi
     return ret;
 }
 
+/* yexu 10/8/2014 */
+int PEM_bytes_read_bio_buffer(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
+	     pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer)
+{
+	EVP_CIPHER_INFO cipher;
+	char *nm=NULL,*header=NULL;
+	unsigned char *data=NULL;
+	long len;
+	int ret = 0;
+	unsigned long curr_pos =0;
+	/*BSYT  bad
+	  unsigned char *pBuffer = NULL;
+	  int buffer_len = 0; */
+
+	for (;;) {
+		if (!PEM_read_bio_buffer(buffer_len, buffer, &curr_pos,&nm,&header,&data,&len)) {
+			if(ERR_GET_REASON(ERR_peek_error()) ==
+				PEM_R_NO_START_LINE)
+				ERR_add_error_data(2, "Expecting: ", name);
+			return 0;
+		}
+		if(check_pem(nm, name)) break;
+		OPENSSL_free(nm);
+		OPENSSL_free(header);
+		OPENSSL_free(data);
+	}
+	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
+	if (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;
+
+	*pdata = data;
+	*plen = len;
+
+	if (pnm)
+		*pnm = nm;
+
+	ret = 1;
+
+err:
+	if (!ret || !pnm) OPENSSL_free(nm);
+	OPENSSL_free(header);
+	if (!ret) OPENSSL_free(data);
+	return ret;
+}
+
 int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
                        const char *name, BIO *bp, pem_password_cb *cb,
                        void *u) {
@@ -303,6 +381,24 @@ int PEM_ASN1_write(i2d_of_void *i2d, con
     BIO_free(b);
     return ret;
 }
+
+/* yexu 10/8/2014 */
+int PEM_ASN1_write_buffer(i2d_of_void *i2d, const char *name, FILE *fp, void *x,
+	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+	     pem_password_cb *callback, void *u)
+{
+    BIO *b;
+    int ret;
+
+    if ((b=BIO_new(BIO_s_file())) == NULL) {
+        PEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);
+        return (0);
+    }
+    BIO_set_fp(b, fp, BIO_NOCLOSE);
+    ret = PEM_ASN1_write_bio(i2d, name, b, x, enc, kstr, klen, callback, u);
+    BIO_free(b);
+    return (ret);
+}
 #endif
 
 int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
@@ -405,6 +501,106 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d,
     return ret;
 }
 
+/* yexu 10/8/2014 */
+/*******************************************************************************/
+int PEM_ASN1_write_bio_buffer(i2d_of_void *i2d, const char *name, BIO *bp, char *x,
+	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+	     pem_password_cb *callback, void *u)
+{
+    EVP_CIPHER_CTX *ctx = NULL;
+    int dsize = 0, i = 0, j = 0, ret = 0;
+    unsigned char *p, *data = NULL;
+    const char *objstr = NULL;
+    char buf[PEM_BUFSIZE];
+    unsigned char key[EVP_MAX_KEY_LENGTH];
+    unsigned char iv[EVP_MAX_IV_LENGTH];
+	
+    if (enc != NULL) {
+        objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
+        if (objstr == NULL || EVP_CIPHER_iv_length(enc) == 0
+                || EVP_CIPHER_iv_length(enc) > (int)sizeof(iv)
+                   /*
+                    * Check "Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n"
+                    * fits into buf
+                    */
+                || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13)
+                   > sizeof(buf)) {
+            PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER);
+            goto err;
+        }
+    }
+
+	if ((dsize=i2d(x,NULL)) < 0) {
+        PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);
+		dsize=0;
+		goto err;
+	}
+	/* dzise + 8 bytes are needed */
+	/* actually it needs the cipher block size extra... */
+	data=(unsigned char *)OPENSSL_malloc((unsigned int)dsize+20);
+	if (data == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	p=data;
+	i=i2d(x,&p);
+
+	if (enc != NULL) {
+		if (kstr == NULL) {
+			if (callback == NULL)
+				klen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);
+			else
+				klen=(*callback)(buf,PEM_BUFSIZE,1,u);
+			if (klen <= 0) {
+				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);
+				goto err;
+			}
+#ifdef CHARSET_EBCDIC
+			/* Convert the pass phrase from EBCDIC */
+			ebcdic2ascii(buf, buf, klen);
+#endif
+			kstr=(unsigned char *)buf;
+		}
+        if (RAND_bytes(iv, EVP_CIPHER_iv_length(enc)) <= 0) /* Generate a salt */
+            goto err;
+		/* The 'iv' is used as the iv and as a salt.  It is
+		 * NOT taken from the BytesToKey function */
+		EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL);
+
+		if (kstr == (unsigned char *)buf)
+            OPENSSL_cleanse(buf,PEM_BUFSIZE);
+
+		buf[0]='\0';
+		PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
+        PEM_dek_info(buf, objstr, EVP_CIPHER_iv_length(enc), (char *)iv);
+		/* k=strlen(buf); */
+
+        ret = 1;
+        if ((ctx = EVP_CIPHER_CTX_new()) == NULL
+            || !EVP_EncryptInit_ex(ctx, enc, NULL, key, iv)
+            || !EVP_EncryptUpdate(ctx, data, &j, data, i)
+            || !EVP_EncryptFinal_ex(ctx, &(data[j]), &i))
+            ret = 0;
+        if (ret == 0)
+            goto err;
+        i += j;
+    } else {
+		ret=1;
+		buf[0]='\0';
+	}
+	i=PEM_write_bio(bp,name,buf,data,i);
+	if (i <= 0)
+        ret=0;
+err:
+    OPENSSL_cleanse(key, sizeof(key));
+    OPENSSL_cleanse(iv, sizeof(iv));
+    EVP_CIPHER_CTX_free(ctx);
+    OPENSSL_cleanse(buf, PEM_BUFSIZE);
+    OPENSSL_clear_free(data, (unsigned int)dsize);
+    return ret;
+}
+/*******************************************************************************/
+
 int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
                   pem_password_cb *callback, void *u)
 {
@@ -959,6 +1155,236 @@ end:
     return ret;
 }
 
+
+/* yexu 10/8/2014 */
+/*******************************************************************************/
+int PEM_read_bio_buffer(unsigned long buffer_len, const char *buffer, unsigned long *curr_pos, 
+char **name, char **header, unsigned char **data,
+	     long *len)
+{
+    EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();
+	int end=0,i=0,k,bl=0,hl=0,nohead=0; // length=0;
+	char buf[256];
+    unsigned long SourceLen = buffer_len;
+	BUF_MEM *nameB;
+	BUF_MEM *headerB;
+	BUF_MEM *dataB,*tmpB;
+
+    if (ctx == NULL) {
+        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+	
+	nameB=BUF_MEM_new();
+	headerB=BUF_MEM_new();
+	dataB=BUF_MEM_new();
+	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))
+		{
+		PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+		return(0);
+		}
+
+	buf[254]='\0';
+	for (;;)
+		{
+		//BSYT i=BIO_gets(bp,buf,254);
+
+		if ((*curr_pos) >= buffer_len)
+			{
+			PEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);
+			goto err;
+			}
+
+        i = buf_gets(buf, 254, buffer+(*curr_pos), SourceLen);
+	(*curr_pos) += i;		
+        //length = i--;
+        //SourceLen -= length;
+        SourceLen -= i;
+        
+		buf[i] = '\0';
+
+		while ((i >= 0) && (buf[i] <= ' ')) i--;
+		buf[++i]='\n'; buf[++i]='\0';
+
+		if (strncmp(buf,"-----BEGIN ",11) == 0)
+			{
+			i=strlen(&(buf[11]));
+
+			if (strncmp(&(buf[11+i-6]),"-----\n",6) != 0)
+				continue;
+			if (!BUF_MEM_grow(nameB,i+9))
+				{
+				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+				goto err;
+				}
+			memcpy(nameB->data,&(buf[11]),i-6);
+			nameB->data[i-6]='\0';
+			break;
+			}
+		}
+	hl=0;
+	if (!BUF_MEM_grow(headerB,256))
+		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
+	headerB->data[0]='\0';
+	for (;;)
+		{
+		//BSYT i=BIO_gets(bp,buf,254);
+        //i = buf_gets(buf, 254, buffer+length, SourceLen);
+
+		if ((*curr_pos) >= buffer_len)
+			{
+			break;
+			}
+        i = buf_gets(buf, 254, buffer+(*curr_pos), SourceLen);
+        //length += i;
+	(*curr_pos) += i;	                
+        SourceLen -= i;
+
+        //if (SourceLen == 0)
+           buf[i] = '\0';
+		if (i <= 0) break;
+
+		while ((i >= 0) && (buf[i] <= ' ')) i--;
+		buf[++i]='\n'; buf[++i]='\0';
+
+		if (buf[0] == '\n') break;
+		if (!BUF_MEM_grow(headerB,hl+i+9))
+			{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
+		if (strncmp(buf,"-----END ",9) == 0)
+			{
+			nohead=1;
+			break;
+			}
+		memcpy(&(headerB->data[hl]),buf,i);
+		headerB->data[hl+i]='\0';
+
+		hl+=i;
+		}
+
+#ifdef BCM_POD_DEBUG
+{
+ int mycounter;
+ for (mycounter=0; mycounter<headerB->length; mycounter++) {
+
+   printf("%c", headerB->data[mycounter]);
+
+ }
+}
+#endif
+
+	bl=0;
+	if (!BUF_MEM_grow(dataB,1024))
+		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
+	dataB->data[0]='\0';
+	if (!nohead)
+		{
+		for (;;)
+			{
+			//BSYT i=BIO_gets(bp,buf,254);
+				
+		if ((*curr_pos) >= buffer_len)
+			{
+			break;
+			}
+            i = buf_gets(buf, 254, buffer+(*curr_pos), SourceLen);
+           //length += i;
+  	   (*curr_pos) += i;	              
+           SourceLen -= i;
+	   
+           if (SourceLen == 0)
+              buf[i] = '\0';
+			//if (i <= 0) break;
+
+			while ((i >= 0) && (buf[i] <= ' ')) i--;
+			buf[++i]='\n'; buf[++i]='\0';
+
+			if (i != 65) end=1;
+			if (strncmp(buf,"-----END ",9) == 0)
+				break;
+			if (i > 65) break;
+			if (!BUF_MEM_grow_clean(dataB,i+bl+9))
+				{
+				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+				goto err;
+				}
+			memcpy(&(dataB->data[bl]),buf,i);
+			dataB->data[bl+i]='\0';
+			bl+=i;
+			if (end)
+				{
+				buf[0]='\0';
+//BSYT 				i=BIO_gets(bp,buf,254);
+				if ((*curr_pos) >= buffer_len)
+				{
+					break;
+				}
+                i = buf_gets(buf, 254, buffer+(*curr_pos), SourceLen);
+				(*curr_pos) += i;	
+                 //length += i;
+                
+                 SourceLen -= i;				 
+                 if (SourceLen == 0)
+                    buf[i] = '\0';
+				if (i <= 0) break;
+
+				while ((i >= 0) && (buf[i] <= ' ')) i--;
+				buf[++i]='\n'; buf[++i]='\0';
+
+				break;
+				}
+			}
+		}
+	else
+		{
+		tmpB=headerB;
+		headerB=dataB;
+		dataB=tmpB;
+		bl=hl;
+		}
+	i=strlen(nameB->data);
+	if (	(strncmp(buf,"-----END ",9) != 0) ||
+		(strncmp(nameB->data,&(buf[9]),i) != 0) ||
+		(strncmp(&(buf[9+i]),"-----\n",6) != 0))
+		{
+		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);
+		goto err;
+		}
+
+	EVP_DecodeInit(ctx);
+	i=EVP_DecodeUpdate(ctx,
+		(unsigned char *)dataB->data,&bl,
+		(unsigned char *)dataB->data,bl);
+	if (i < 0)
+		{
+		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+		goto err;
+		}
+	i=EVP_DecodeFinal(ctx,(unsigned char *)&(dataB->data[bl]),&k);
+	if (i < 0)
+		{
+		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+		goto err;
+		}
+	bl+=k;
+
+	if (bl == 0) goto err;
+	*name=nameB->data;
+	*header=headerB->data;
+	*data=(unsigned char *)dataB->data;
+	*len=bl;
+    EVP_ENCODE_CTX_free(ctx);
+	OPENSSL_free(nameB);
+	OPENSSL_free(headerB);
+	OPENSSL_free(dataB);
+	return(1);
+err:
+	BUF_MEM_free(nameB);
+	BUF_MEM_free(headerB);
+	BUF_MEM_free(dataB);
+	return(0);
+}
+/*******************************************************************************/
+
 int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
                  long *len)
 {
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_oth.c openssl-1.1.1c/crypto/pem/pem_oth.c
--- openssl-1.1.1c.orig/crypto/pem/pem_oth.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_oth.c	2019-08-20 18:03:11.597668752 -0700
@@ -17,6 +17,25 @@
 
 /* Handle 'other' PEMs: not private keys */
 
+/* yexu 10/8/2014 */
+char *PEM_ASN1_read_bio_buffer(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
+	     pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer)
+{
+	const unsigned char *p=NULL;
+	unsigned char *data=NULL;
+	long len;
+	char *ret=NULL;
+
+	if (!PEM_bytes_read_bio_buffer(&data, &len, NULL, name, bp, cb, u,  buffer_len, buffer))
+		return NULL;
+	p = data;
+	ret=d2i(x,&p,len);
+	if (ret == NULL)
+		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
+	OPENSSL_free(data);
+	return(ret);
+}
+
 void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
                         pem_password_cb *cb, void *u)
 {
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_pkey.c openssl-1.1.1c/crypto/pem/pem_pkey.c
--- openssl-1.1.1c.orig/crypto/pem/pem_pkey.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_pkey.c	2019-08-20 18:03:11.597668752 -0700
@@ -162,7 +162,66 @@ int PEM_write_bio_Parameters(BIO *bp, EV
                               pem_str, bp, x, NULL, NULL, 0, 0, NULL);
 }
 
-#ifndef OPENSSL_NO_STDIO
+/* yexu 10/8/2014 */
+/*********************************************************************************/
+EVP_PKEY *PEM_read_bio_buffer_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u, 
+	unsigned long buffer_len, const char *buffer)
+	{
+	char *nm=NULL;
+	const unsigned char *p=NULL;
+	unsigned char *data=NULL;
+	long len;
+	EVP_PKEY *ret=NULL;
+
+	if (!PEM_bytes_read_bio_buffer(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u, buffer_len, buffer))
+		return NULL;
+	p = data;
+
+	if (strcmp(nm,PEM_STRING_RSA) == 0)
+		ret=d2i_PrivateKey(EVP_PKEY_RSA,x,&p,len);
+	else if (strcmp(nm,PEM_STRING_DSA) == 0)
+		ret=d2i_PrivateKey(EVP_PKEY_DSA,x,&p,len);
+	else if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {
+		PKCS8_PRIV_KEY_INFO *p8inf;
+		p8inf=d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
+		if(!p8inf) goto p8err;
+		ret = EVP_PKCS82PKEY(p8inf);
+		PKCS8_PRIV_KEY_INFO_free(p8inf);
+	} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {
+		PKCS8_PRIV_KEY_INFO *p8inf;
+		X509_SIG *p8;
+		int klen;
+		char psbuf[PEM_BUFSIZE];
+		p8 = d2i_X509_SIG(NULL, &p, len);
+		if(!p8) goto p8err;
+		if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
+		else klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
+		if (klen <= 0) {
+			PEMerr(PEM_F_PEM_ASN1_READ_BIO,
+					PEM_R_BAD_PASSWORD_READ);
+			goto err;
+		}
+		p8inf = PKCS8_decrypt(p8, psbuf, klen);
+		X509_SIG_free(p8);
+		if(!p8inf) goto p8err;
+		ret = EVP_PKCS82PKEY(p8inf);
+		if(x) {
+			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+			*x = ret;
+		}
+		PKCS8_PRIV_KEY_INFO_free(p8inf);
+	}
+p8err:
+	if (ret == NULL)
+		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
+err:
+	OPENSSL_free(nm);
+	OPENSSL_free(data);
+	return(ret);
+	}
+/*********************************************************************************/
+
+#ifndef OPENSSL_NO_FP_API
 EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
                               void *u)
 {
@@ -176,7 +235,25 @@ EVP_PKEY *PEM_read_PrivateKey(FILE *fp,
     BIO_set_fp(b, fp, BIO_NOCLOSE);
     ret = PEM_read_bio_PrivateKey(b, x, cb, u);
     BIO_free(b);
-    return ret;
+    return(ret);
+}
+
+/* yexu 10/8/2014 */
+EVP_PKEY *PEM_read_buffer_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u, 
+	unsigned long buffer_len, const char *buffer)
+{
+    BIO *b;
+    EVP_PKEY *ret;
+
+    if ((b=BIO_new(BIO_s_file())) == NULL)
+	{
+		PEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);
+                return(0);
+	}
+    /*BIO_set_fp(b,fp,BIO_NOCLOSE); */
+    ret=PEM_read_bio_buffer_PrivateKey(b,x,cb,u, buffer_len, buffer);
+    BIO_free(b);
+    return(ret);
 }
 
 int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_x509.c openssl-1.1.1c/crypto/pem/pem_x509.c
--- openssl-1.1.1c.orig/crypto/pem/pem_x509.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_x509.c	2019-08-20 18:03:11.597668752 -0700
@@ -16,3 +16,5 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509, X509, PEM_STRING_X509, X509)
+/* yexu 10/8/2014 */
+IMPLEMENT_PEM_rw_buffer(X509, X509, PEM_STRING_X509, X509)
diff -rNup openssl-1.1.1c.orig/crypto/pem/pem_xaux.c openssl-1.1.1c/crypto/pem/pem_xaux.c
--- openssl-1.1.1c.orig/crypto/pem/pem_xaux.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/pem/pem_xaux.c	2019-08-20 18:03:11.597668752 -0700
@@ -16,3 +16,5 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509_AUX, X509, PEM_STRING_X509_TRUSTED, X509_AUX)
+/* yexu 10/8/2014 */
+IMPLEMENT_PEM_rw_buffer(X509_AUX, X509, PEM_STRING_X509_TRUSTED, X509_AUX)
diff -rNup openssl-1.1.1c.orig/crypto/rsa/rsa_gen.c openssl-1.1.1c/crypto/rsa/rsa_gen.c
--- openssl-1.1.1c.orig/crypto/rsa/rsa_gen.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/rsa/rsa_gen.c	2019-08-20 18:03:11.597668752 -0700
@@ -390,4 +390,148 @@ static int rsa_builtin_keygen(RSA *rsa,
     BN_CTX_end(ctx);
     BN_CTX_free(ctx);
     return ok;
+ }
+
+/* yexu 10/8/2014 */
+/********************************************************************************/
+RSA *RSA_generate_key_big_exponent(int bits, BIGNUM  *e_value,
+	     void (*callback)(int,int,void *), void *cb_arg)
+	{
+	RSA *rsa=NULL;
+	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
+	int bitsp,bitsq,ok= -1,n=0;
+	BN_CTX *ctx=NULL,*ctx2=NULL;
+    BN_GENCB *cb = BN_GENCB_new();
+    BN_GENCB_set_old(cb, callback, cb_arg);
+
+	ctx=BN_CTX_new();
+	if (ctx == NULL) goto err;
+	ctx2=BN_CTX_new();
+	if (ctx2 == NULL) goto err;
+	BN_CTX_start(ctx);
+	r0 = BN_CTX_get(ctx);
+	r1 = BN_CTX_get(ctx);
+	r2 = BN_CTX_get(ctx);
+	r3 = BN_CTX_get(ctx);
+	if (r3 == NULL) goto err;
+
+	bitsp=(bits+1)/2;
+	bitsq=bits-bitsp;
+	rsa=RSA_new();
+	if (rsa == NULL) goto err;
+
+    
+#if BSYT_COMMENT_OUT_FOR_BIG_E
+	/* set e */ 
+	rsa->e=BN_new();
+	if (rsa->e == NULL) goto err;
+
+#if 1
+	/* The problem is when building with 8, 16, or 32 BN_ULONG,
+	 * unsigned long can be larger */
+	for (i=0; i<sizeof(unsigned long)*8; i++)
+		{
+		if (e_value & (1UL<<i))
+			BN_set_bit(rsa->e,i);
+		}
+#else
+	if (!BN_set_word(rsa->e,e_value)) goto err;
+#endif
+#endif /* COMMENT_OUT_FOR_BIG_E */
+
+    rsa->e=e_value;
+
+
+	/* generate p and q */
+	for (;;)
+		{
+		if (!BN_generate_prime_ex(rsa->p,bitsp,0,NULL,NULL,cb))
+            goto err;
+		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
+		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
+		if (BN_is_one(r1)) break;
+		if (callback != NULL) callback(2,n++,cb_arg);
+		BN_free(rsa->p);
+		}
+	if (callback != NULL) callback(3,0,cb_arg);
+	for (;;)
+		{
+		if (!BN_generate_prime_ex(rsa->q,bitsq,0,NULL,NULL,cb))
+            goto err;
+		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
+		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
+		if (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))
+			break;
+		if (callback != NULL) callback(2,n++,cb_arg);
+		BN_free(rsa->q);
+		}
+	if (callback != NULL) callback(3,1,cb_arg);
+	if (BN_cmp(rsa->p,rsa->q) < 0)
+		{
+		tmp=rsa->p;
+		rsa->p=rsa->q;
+		rsa->q=tmp;
+		}
+
+	/* calculate n */
+	rsa->n=BN_new();
+	if (rsa->n == NULL) goto err;
+	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;
+
+	/* calculate d */
+	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
+	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
+	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */
+
+/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */
+/*	for (;;)
+		{
+		if (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;
+		if (BN_is_one(r3)) break;
+
+		if (1)
+			{
+			if (!BN_add_word(rsa->e,2L)) goto err;
+			continue;
+			}
+		RSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);
+		goto err;
+		}
+*/
+	rsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);	/* d */
+	if (rsa->d == NULL) goto err;
+
+	/* calculate d mod (p-1) */
+	rsa->dmp1=BN_new();
+	if (rsa->dmp1 == NULL) goto err;
+	if (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;
+
+	/* calculate d mod (q-1) */
+	rsa->dmq1=BN_new();
+	if (rsa->dmq1 == NULL) goto err;
+	if (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;
+
+	/* calculate inverse of q mod p */
+	rsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);
+	if (rsa->iqmp == NULL) goto err;
+
+	ok=1;
+err:
+	if (ok == -1)
+		{
+		RSAerr(RSA_F_RSA_BUILTIN_KEYGEN,RSA_R_BAD_E_VALUE); /*Could handle more precisely elsewhere?*/
+		ok=0;
+		}
+	BN_CTX_end(ctx);
+	BN_CTX_free(ctx);
+	BN_CTX_free(ctx2);
+    BN_GENCB_free(cb);
+	if (!ok)
+		{
+		if (rsa != NULL) RSA_free(rsa);
+		return(NULL);
+		}
+	else
+		return(rsa);
 }
+/********************************************************************************/
diff -rNup openssl-1.1.1c.orig/crypto/x509/by_file.c openssl-1.1.1c/crypto/x509/by_file.c
--- openssl-1.1.1c.orig/crypto/x509/by_file.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/x509/by_file.c	2019-08-20 18:03:11.597668752 -0700
@@ -19,6 +19,12 @@
 
 static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc,
                         long argl, char **ret);
+
+/* yexu 10/8/2014 */
+static int by_buffer_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc,
+	long argl, char **ret);
+
+
 static X509_LOOKUP_METHOD x509_file_lookup = {
     "Load file into cache",
     NULL,                       /* new_item */
@@ -32,11 +38,50 @@ static X509_LOOKUP_METHOD x509_file_look
     NULL,                       /* get_by_alias */
 };
 
+/* yexu 10/8/2014 */
+X509_LOOKUP_METHOD x509_buffer_lookup=
+{
+	"Load file into cache",
+	NULL,		/* new */
+	NULL,		/* free */
+	NULL, 		/* init */
+	NULL,		/* shutdown */
+	by_buffer_ctrl,	/* ctrl */
+	NULL,		/* get_by_subject */
+	NULL,		/* get_by_issuer_serial */
+	NULL,		/* get_by_fingerprint */
+	NULL,		/* get_by_alias */
+};
+
+X509_LOOKUP_METHOD *X509_LOOKUP_buffer(void)
+{
+	return(&x509_buffer_lookup);
+}
+
 X509_LOOKUP_METHOD *X509_LOOKUP_file(void)
 {
     return &x509_file_lookup;
 }
 
+/* yexu 10/8/2014 */
+static int by_buffer_ctrl(X509_LOOKUP *ctx, int buffer_len, const char *buffer, long argl,
+	     char **ret)
+{
+	int ok=0;
+	//char *file;
+
+
+		
+	if(argl == X509_FILETYPE_PEM)
+		ok = (X509_load_cert_crl_buffer(ctx,buffer_len, buffer,  
+			X509_FILETYPE_PEM) != 0);
+	else
+		ok = (X509_load_cert_buffer(ctx,buffer_len, buffer,(int)argl) != 0);
+
+	
+	return(ok);
+}
+
 static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp,
                         long argl, char **ret)
 {
@@ -71,6 +116,78 @@ static int by_file_ctrl(X509_LOOKUP *ctx
     return ok;
 }
 
+/* yexu 10/8/2014 */
+/********************************************************************************/
+int X509_load_cert_buffer(X509_LOOKUP *ctx, int buffer_len, const char *buffer, int type)
+	{
+	int ret=0;
+	BIO *in=NULL;
+	int i,count=0;
+	X509 *x=NULL;
+
+	//if (file == NULL) return(1);
+	in=BIO_new(BIO_s_file_internal());
+
+/*
+	if ((in == NULL) || (BIO_read_filename(in,file) <= 0))
+		{
+		X509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_SYS_LIB);
+		goto err;
+		}
+*/		
+
+	if (type == X509_FILETYPE_PEM)
+		{
+		for (;;)
+			{
+			x=PEM_read_bio_X509_AUX(in,NULL,NULL,NULL);
+			if (x == NULL)
+				{
+				if ((ERR_GET_REASON(ERR_peek_error()) ==
+					PEM_R_NO_START_LINE) && (count > 0))
+					{
+					ERR_clear_error();
+					break;
+					}
+				else
+					{
+					X509err(X509_F_X509_LOAD_CERT_FILE,
+						ERR_R_PEM_LIB);
+					goto err;
+					}
+				}
+			i=X509_STORE_add_cert(ctx->store_ctx,x);
+			if (!i) goto err;
+			count++;
+			X509_free(x);
+			x=NULL;
+			}
+		ret=count;
+		}
+	else if (type == X509_FILETYPE_ASN1)
+		{
+		x=d2i_X509_bio_buffer( buffer_len, buffer,NULL);
+		if (x == NULL)
+			{
+			X509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_ASN1_LIB);
+			goto err;
+			}
+		i=X509_STORE_add_cert(ctx->store_ctx,x);
+		if (!i) goto err;
+		ret=i;
+		}
+	else
+		{
+		X509err(X509_F_X509_LOAD_CERT_FILE,X509_R_BAD_X509_FILETYPE);
+		goto err;
+		}
+err:
+	if (x != NULL) X509_free(x);
+	if (in != NULL) BIO_free(in);
+	return(ret);
+	}
+/********************************************************************************/
+
 int X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type)
 {
     int ret = 0;
@@ -225,3 +342,54 @@ int X509_load_cert_crl_file(X509_LOOKUP
     sk_X509_INFO_pop_free(inf, X509_INFO_free);
     return count;
 }
+
+
+/* yexu 10/8/2014 */
+/********************************************************************************/
+int X509_load_cert_crl_buffer(X509_LOOKUP *ctx, int buffer_len, const char *buffer, int type)
+{
+	STACK_OF(X509_INFO) *inf;
+	X509_INFO *itmp;
+
+#if 0
+	BIO *in;
+#endif
+
+	int i, count = 0;
+
+#if 0
+	if(type != X509_FILETYPE_PEM)
+		return X509_load_cert_file(ctx, file, type);
+	in = BIO_new_file(file, "r");
+	if(!in) {
+		X509err(X509_F_X509_LOAD_CERT_CRL_FILE,ERR_R_SYS_LIB);
+		return 0;
+	}
+#endif
+
+	inf = PEM_X509_INFO_read_bio_from_buffer(buffer_len, buffer, NULL, NULL, NULL);
+
+#if 0
+	BIO_free(in);
+#endif
+
+	if(!inf) {
+		X509err(X509_F_X509_LOAD_CERT_CRL_FILE,ERR_R_PEM_LIB);
+		return 0;
+	}
+	for(i = 0; i < sk_X509_INFO_num(inf); i++) {
+		itmp = sk_X509_INFO_value(inf, i);
+		if(itmp->x509) {
+			X509_STORE_add_cert(ctx->store_ctx, itmp->x509);
+			count++;
+		}
+		if(itmp->crl) {
+			X509_STORE_add_crl(ctx->store_ctx, itmp->crl);
+			count++;
+		}
+	}
+	sk_X509_INFO_pop_free(inf, X509_INFO_free);
+	return count;
+}
+/********************************************************************************/
+
diff -rNup openssl-1.1.1c.orig/crypto/x509/x_all.c openssl-1.1.1c/crypto/x509/x_all.c
--- openssl-1.1.1c.orig/crypto/x509/x_all.c	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/crypto/x509/x_all.c	2019-08-20 18:03:11.597668752 -0700
@@ -123,6 +123,12 @@ X509 *d2i_X509_bio(BIO *bp, X509 **x509)
     return ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509), bp, x509);
 }
 
+/* yexu 10/8/2014 */
+X509 *d2i_X509_bio_buffer(int buffer_len, const char *buffer, X509 **x509)
+	{
+	return ASN1_item_d2i_bio_buffer(ASN1_ITEM_rptr(X509), buffer_len, buffer, x509);
+	}
+
 int i2d_X509_bio(BIO *bp, X509 *x509)
 {
     return ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);
diff -rNup openssl-1.1.1c.orig/include/openssl/asn1.h openssl-1.1.1c/include/openssl/asn1.h
--- openssl-1.1.1c.orig/include/openssl/asn1.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/asn1.h	2019-08-20 18:03:11.597668752 -0700
@@ -742,6 +742,11 @@ void *ASN1_d2i_bio(void *(*xnew) (void),
                           CHECKED_PPTR_OF(type, x)))
 
 void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x);
+
+/* yexu 10/8/2014 */
+
+void *ASN1_item_d2i_bio_buffer(const ASN1_ITEM *it, int buffer_len,
+                               const char *buffer, void *x);
 int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x);
 
 #  define ASN1_i2d_bio_of(type,i2d,out,x) \
@@ -768,8 +773,6 @@ int ASN1_parse_dump(BIO *bp, const unsig
                     int dump);
 const char *ASN1_tag2str(int tag);
 
-/* Used to load and write Netscape format cert */
-
 int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s);
 
 int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len);
diff -rNup openssl-1.1.1c.orig/include/openssl/bio.h openssl-1.1.1c/include/openssl/bio.h
--- openssl-1.1.1c.orig/include/openssl/bio.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/bio.h	2019-08-20 18:03:11.597668752 -0700
@@ -548,6 +548,7 @@ const BIO_METHOD *BIO_s_file(void);
 BIO *BIO_new_file(const char *filename, const char *mode);
 # ifndef OPENSSL_NO_STDIO
 BIO *BIO_new_fp(FILE *stream, int close_flag);
+#  define BIO_s_file_internal    BIO_s_file
 # endif
 BIO *BIO_new(const BIO_METHOD *type);
 int BIO_free(BIO *a);
diff -rNup openssl-1.1.1c.orig/include/openssl/pem.h openssl-1.1.1c/include/openssl/pem.h
--- openssl-1.1.1c.orig/include/openssl/pem.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/pem.h	2019-08-20 18:03:11.601668875 -0700
@@ -63,7 +63,11 @@ extern "C" {
 # ifdef OPENSSL_NO_STDIO
 
 #  define IMPLEMENT_PEM_read_fp(name, type, str, asn1) /**/
+/* yexu 10/8/2014 */
+#  define IMPLEMENT_PEM_read_fp_buffer(name, type, str, asn1) /**/
 #  define IMPLEMENT_PEM_write_fp(name, type, str, asn1) /**/
+/* yexu 10/8/2014 */
+#  define IMPLEMENT_PEM_write_fp_buffer(name, type, str, asn1) /**/
 #  define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) /**/
 #  define IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) /**/
 #  define IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) /**/
@@ -74,6 +78,13 @@ type *PEM_read_##name(FILE *fp, type **x
 { \
 return PEM_ASN1_read((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,cb,u); \
 }
+/* yexu 10/8/2014 */
+#  define IMPLEMENT_PEM_read_fp_buffer(name, type, str, asn1) \
+type *PEM_read_buffer_##name(FILE *fp, type **x, pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer)\
+{ \
+return((type *)PEM_ASN1_read_buffer((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,\
+	cb,u, buffer_len, buffer)); \
+} 
 
 #  define IMPLEMENT_PEM_write_fp(name, type, str, asn1) \
 int PEM_write_##name(FILE *fp, type *x) \
@@ -81,6 +92,15 @@ int PEM_write_##name(FILE *fp, type *x)
 return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,NULL,NULL,0,NULL,NULL); \
 }
 
+/* yexu 10/8/2014 */
+#  define IMPLEMENT_PEM_write_fp_buffer(name, type, str, asn1) \
+int PEM_write_buffer##name(FILE *fp, type *x) \
+{ \
+return(PEM_ASN1_write_buffer((i2d_of_void *)i2d_##asn1,str,fp, (char *)x, \
+							 NULL,NULL,0,NULL,NULL)); \
+} 
+
+
 #  define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) \
 int PEM_write_##name(FILE *fp, const type *x) \
 { \
@@ -111,12 +131,28 @@ type *PEM_read_bio_##name(BIO *bp, type
 return PEM_ASN1_read_bio((d2i_of_void *)d2i_##asn1, str,bp,(void **)x,cb,u); \
 }
 
+/* yexu 10/8/2014 */
+# define IMPLEMENT_PEM_read_bio_buffer(name, type, str, asn1) \
+type *PEM_read_bio_buffer_##name(BIO *bp, type **x, pem_password_cb *cb, void *u, unsigned long  buffer_len, const char *buffer)\
+{ \
+return((type *)PEM_ASN1_read_bio_buffer((d2i_of_void *)d2i_##asn1, str,  bp, \
+							(void **)x,cb,u, buffer_len, buffer)); \
+}
+
 # define IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
 int PEM_write_bio_##name(BIO *bp, type *x) \
 { \
 return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,x,NULL,NULL,0,NULL,NULL); \
 }
 
+/* yexu 10/8/2014 */
+# define IMPLEMENT_PEM_write_bio_buffer(name, type, str, asn1) \
+int PEM_write_bio_buffer##name(BIO *bp, type *x) \
+{ \
+return(PEM_ASN1_write_bio_buffer((i2d_of_void *)i2d_##asn1,str,bp, (char *)x, \
+							 NULL,NULL,0,NULL,NULL)); \
+}
+
 # define IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
 int PEM_write_bio_##name(BIO *bp, const type *x) \
 { \
@@ -141,6 +177,11 @@ int PEM_write_bio_##name(BIO *bp, type *
         IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
         IMPLEMENT_PEM_write_fp(name, type, str, asn1)
 
+/* yexu 10/8/2014 */
+# define IMPLEMENT_PEM_write_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_write_bio_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_write_fp_buffer(name, type, str, asn1) 
+
 # define IMPLEMENT_PEM_write_const(name, type, str, asn1) \
         IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
         IMPLEMENT_PEM_write_fp_const(name, type, str, asn1)
@@ -157,10 +198,20 @@ int PEM_write_bio_##name(BIO *bp, type *
         IMPLEMENT_PEM_read_bio(name, type, str, asn1) \
         IMPLEMENT_PEM_read_fp(name, type, str, asn1)
 
+/* yexu 10/8/2014 */
+# define IMPLEMENT_PEM_read_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_read_bio_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_read_fp_buffer(name, type, str, asn1) 
+
 # define IMPLEMENT_PEM_rw(name, type, str, asn1) \
         IMPLEMENT_PEM_read(name, type, str, asn1) \
         IMPLEMENT_PEM_write(name, type, str, asn1)
 
+/* yexu 10/8/2014 */
+# define IMPLEMENT_PEM_rw_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_read_buffer(name, type, str, asn1) \
+        IMPLEMENT_PEM_write_buffer(name, type, str, asn1)
+
 # define IMPLEMENT_PEM_rw_const(name, type, str, asn1) \
         IMPLEMENT_PEM_read(name, type, str, asn1) \
         IMPLEMENT_PEM_write_const(name, type, str, asn1)
@@ -174,17 +225,31 @@ int PEM_write_bio_##name(BIO *bp, type *
 # if defined(OPENSSL_NO_STDIO)
 
 #  define DECLARE_PEM_read_fp(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_read_fp_buffer(name, type) /**/
 #  define DECLARE_PEM_write_fp(name, type) /**/
-#  define DECLARE_PEM_write_fp_const(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_fp_buffer(name, type) /**/
 #  define DECLARE_PEM_write_cb_fp(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_cb_fp_buffer(name, type) /**/
+
 # else
 
 #  define DECLARE_PEM_read_fp(name, type) \
         type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_read_fp_buffer(name, type) \
+        type *PEM_read_buffer_##name(FILE *fp, type **x, pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer);
+
 #  define DECLARE_PEM_write_fp(name, type) \
         int PEM_write_##name(FILE *fp, type *x);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_fp_buffer(name, type) \
+        int PEM_write_buffer_##name(FILE *fp, type *x);
+
 #  define DECLARE_PEM_write_fp_const(name, type) \
         int PEM_write_##name(FILE *fp, const type *x);
 
@@ -192,14 +257,28 @@ int PEM_write_bio_##name(BIO *bp, type *
         int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \
              unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_cb_fp_buffer(name, type) \
+        int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \
+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
+
 # endif
 
+# ifndef OPENSSL_NO_BIO
 #  define DECLARE_PEM_read_bio(name, type) \
         type *PEM_read_bio_##name(BIO *bp, type **x, pem_password_cb *cb, void *u);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_read_bio_buffer(name, type) \
+        type *PEM_read_bio_buffer_##name(BIO *bp, type **x, pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer);
+
 #  define DECLARE_PEM_write_bio(name, type) \
         int PEM_write_bio_##name(BIO *bp, type *x);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_bio_buffer(name, type) \
+        int PEM_write_bio_buffer_##name(BIO *bp, type *x);
+
 #  define DECLARE_PEM_write_bio_const(name, type) \
         int PEM_write_bio_##name(BIO *bp, const type *x);
 
@@ -207,33 +286,85 @@ int PEM_write_bio_##name(BIO *bp, type *
         int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
              unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
 
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_cb_bio_buffer(name, type) \
+        int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
+
+# else
+
+#  define DECLARE_PEM_read_bio(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_read_bio_buffer(name, type) /**/
+#  define DECLARE_PEM_write_bio(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_bio_buffer(name, type) /**/
+#  define DECLARE_PEM_write_bio_const(name, type) /**/
+#  define DECLARE_PEM_write_cb_bio(name, type) /**/
+/* yexu 10/8/2014 */
+#  define DECLARE_PEM_write_cb_bio_buffer(name, type) /**/
+
+# endif
+
 # define DECLARE_PEM_write(name, type) \
         DECLARE_PEM_write_bio(name, type) \
         DECLARE_PEM_write_fp(name, type)
+
+/* yexu 10/8/2014 */
+# define DECLARE_PEM_write_buffer(name, type) \
+        DECLARE_PEM_write_bio_buffer(name, type) \
+        DECLARE_PEM_write_fp_buffer(name, type) 
+
 # define DECLARE_PEM_write_const(name, type) \
         DECLARE_PEM_write_bio_const(name, type) \
         DECLARE_PEM_write_fp_const(name, type)
 # define DECLARE_PEM_write_cb(name, type) \
         DECLARE_PEM_write_cb_bio(name, type) \
         DECLARE_PEM_write_cb_fp(name, type)
+
+/* yexu 10/8/2014 */
+# define DECLARE_PEM_write_cb_buffer(name, type) \
+        DECLARE_PEM_write_cb_bio_buffer(name, type) \
+        DECLARE_PEM_write_cb_fp_buffer(name, type) 
+
 # define DECLARE_PEM_read(name, type) \
         DECLARE_PEM_read_bio(name, type) \
         DECLARE_PEM_read_fp(name, type)
+
+/* yexu 10/8/2014 */
+# define DECLARE_PEM_read_buffer(name, type) \
+        DECLARE_PEM_read_bio_buffer(name, type) \
+        DECLARE_PEM_read_fp_buffer(name, type)
+
 # define DECLARE_PEM_rw(name, type) \
         DECLARE_PEM_read(name, type) \
         DECLARE_PEM_write(name, type)
+
+/* yexu 10/8/2014 */
+# define DECLARE_PEM_rw_buffer(name, type) \
+        DECLARE_PEM_read_buffer(name, type) \
+        DECLARE_PEM_write_buffer(name, type)
+
 # define DECLARE_PEM_rw_const(name, type) \
         DECLARE_PEM_read(name, type) \
         DECLARE_PEM_write_const(name, type)
 # define DECLARE_PEM_rw_cb(name, type) \
         DECLARE_PEM_read(name, type) \
         DECLARE_PEM_write_cb(name, type)
+
+/* yexu 10/8/2014 */
+# define DECLARE_PEM_rw_cb_buffer(name, type) \
+        DECLARE_PEM_read_buffer(name, type) \
+        DECLARE_PEM_write_cb_buffer(name, type)
+
+
 typedef int pem_password_cb (char *buf, int size, int rwflag, void *userdata);
 
 int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
 int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *len,
                   pem_password_cb *callback, void *u);
 
+# ifndef OPENSSL_NO_BIO
 int PEM_read_bio(BIO *bp, char **name, char **header,
                  unsigned char **data, long *len);
 #   define PEM_FLAG_SECURE             0x1
@@ -244,23 +375,39 @@ int PEM_read_bio_ex(BIO *bp, char **name
 int PEM_bytes_read_bio_secmem(unsigned char **pdata, long *plen, char **pnm,
                               const char *name, BIO *bp, pem_password_cb *cb,
                               void *u);
+/* yexu 10/8/2014 */
+int PEM_read_bio_buffer(unsigned long buffer_len, const char *buffer, unsigned long *curr_pos, char **name, 
+	char **header, unsigned char **data,
+	     long *len);
 int PEM_write_bio(BIO *bp, const char *name, const char *hdr,
                   const unsigned char *data, long len);
 int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
                        const char *name, BIO *bp, pem_password_cb *cb,
                        void *u);
+/* yexu 10/8/2014 */
+int PEM_bytes_read_bio_buffer(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
+	     pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer);
 void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
                         pem_password_cb *cb, void *u);
+/* yexu 10/8/2014 */
+char *PEM_ASN1_read_bio_buffer(d2i_of_void *d2i,const char *name,BIO *bp,void **x,
+		pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer);
 int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
                        const EVP_CIPHER *enc, unsigned char *kstr, int klen,
                        pem_password_cb *cb, void *u);
 
+/* yexu 10/8/2014 */
+int	PEM_ASN1_write_bio_buffer(i2d_of_void *i2d,const char *name,BIO *bp,char *x,
+			   const EVP_CIPHER *enc,unsigned char *kstr,int klen,
+			   pem_password_cb *cb, void *u);
 STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk,
                                             pem_password_cb *cb, void *u);
+/* yexu 10/8/2014 */
+STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio_from_buffer(unsigned long buffer_len, const char *buffer, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
 int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
                             unsigned char *kstr, int klen,
                             pem_password_cb *cd, void *u);
-
+# endif
 #ifndef OPENSSL_NO_STDIO
 int PEM_read(FILE *fp, char **name, char **header,
              unsigned char **data, long *len);
@@ -268,9 +415,16 @@ int PEM_write(FILE *fp, const char *name
               const unsigned char *data, long len);
 void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
                     pem_password_cb *cb, void *u);
+/* yexu 10/8/2014 */
+char *	PEM_ASN1_read_buffer(d2i_of_void *d2i,const char *name,FILE *fp,void **x,
+	pem_password_cb *cb, void *u, unsigned long buffer_len, const char *buffer);
 int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
                    void *x, const EVP_CIPHER *enc, unsigned char *kstr,
                    int klen, pem_password_cb *callback, void *u);
+/* yexu 10/8/2014 */
+int	PEM_ASN1_write_buffer(i2d_of_void *i2d,const char *name,FILE *fp,void *x,
+		       const EVP_CIPHER *enc,unsigned char *kstr,int klen,
+		       pem_password_cb *callback, void *u);
 STACK_OF(X509_INFO) *PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,
                                         pem_password_cb *cb, void *u);
 #endif
@@ -288,7 +442,13 @@ void PEM_dek_info(char *buf, const char
 # include <openssl/symhacks.h>
 
 DECLARE_PEM_rw(X509, X509)
+/* yexu 10/8/2014 */
+DECLARE_PEM_rw_buffer(X509, X509)
+
 DECLARE_PEM_rw(X509_AUX, X509)
+/* yexu 10/8/2014 */
+DECLARE_PEM_rw_buffer(X509_AUX, X509)
+
 DECLARE_PEM_rw(X509_REQ, X509_REQ)
 DECLARE_PEM_write(X509_REQ_NEW, X509_REQ)
 DECLARE_PEM_rw(X509_CRL, X509_CRL)
@@ -316,6 +476,9 @@ DECLARE_PEM_rw_const(DHparams, DH)
 DECLARE_PEM_write_const(DHxparams, DH)
 # endif
 DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
+/* yexu 10/8/2014 */
+DECLARE_PEM_rw_cb_buffer(PrivateKey, EVP_PKEY)
+
 DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
 
 int PEM_write_bio_PrivateKey_traditional(BIO *bp, EVP_PKEY *x,
diff -rNup openssl-1.1.1c.orig/include/openssl/rsa.h openssl-1.1.1c/include/openssl/rsa.h
--- openssl-1.1.1c.orig/include/openssl/rsa.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/rsa.h	2019-08-20 18:03:11.601668875 -0700
@@ -247,7 +247,9 @@ int RSA_X931_derive_ex(RSA *rsa, BIGNUM
                        const BIGNUM *Xq, const BIGNUM *e, BN_GENCB *cb);
 int RSA_X931_generate_key_ex(RSA *rsa, int bits, const BIGNUM *e,
                              BN_GENCB *cb);
-
+/* yexu 10/8/2014 */
+RSA *	RSA_generate_key_big_exponent(int bits, BIGNUM  *e_value,void
+		(*callback)(int,int,void *),void *cb_arg);
 int RSA_check_key(const RSA *);
 int RSA_check_key_ex(const RSA *, BN_GENCB *cb);
         /* next 4 return -1 on error */
diff -rNup openssl-1.1.1c.orig/include/openssl/x509.h openssl-1.1.1c/include/openssl/x509.h
--- openssl-1.1.1c.orig/include/openssl/x509.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/x509.h	2019-08-20 18:03:11.601668875 -0700
@@ -429,6 +429,8 @@ EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PK
 # endif
 
 X509 *d2i_X509_bio(BIO *bp, X509 **x509);
+/* yexu 10/8/2014 */
+X509 *d2i_X509_bio_buffer(int buffer_len,const char *buffer,X509 **x509);
 int i2d_X509_bio(BIO *bp, X509 *x509);
 X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl);
 int i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl);
diff -rNup openssl-1.1.1c.orig/include/openssl/x509_vfy.h openssl-1.1.1c/include/openssl/x509_vfy.h
--- openssl-1.1.1c.orig/include/openssl/x509_vfy.h	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/include/openssl/x509_vfy.h	2019-08-20 18:03:11.601668875 -0700
@@ -93,6 +93,10 @@ void X509_STORE_CTX_set_depth(X509_STORE
 # define X509_LOOKUP_load_file(x,name,type) \
                 X509_LOOKUP_ctrl((x),X509_L_FILE_LOAD,(name),(long)(type),NULL)
 
+/* yexu 10/8/2014 */
+#define X509_LOOKUP_load_buffer(x,size,buffer,type) \
+		X509_LOOKUP_ctrl((x),(size),(buffer),(long)(type),NULL)
+
 # define X509_LOOKUP_add_dir(x,name,type) \
                 X509_LOOKUP_ctrl((x),X509_L_ADD_DIR,(name),(long)(type),NULL)
 
@@ -373,6 +377,8 @@ X509_STORE_CTX_cleanup_fn X509_STORE_CTX
 X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m);
 X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void);
 X509_LOOKUP_METHOD *X509_LOOKUP_file(void);
+/* yexu 10/8/2014 */
+X509_LOOKUP_METHOD *X509_LOOKUP_buffer(void);
 
 typedef int (*X509_LOOKUP_ctrl_fn)(X509_LOOKUP *ctx, int cmd, const char *argc,
                                    long argl, char **ret);
@@ -457,8 +463,12 @@ int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, i
                      long argl, char **ret);
 
 int X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type);
+/* yexu 10/8/2014 */
+int X509_load_cert_buffer(X509_LOOKUP *ctx, int buffer_len, const char *buffer, int type);
 int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type);
 int X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type);
+/* yexu 10/8/2014 */
+int X509_load_cert_crl_buffer(X509_LOOKUP *ctx, int buffer_len, const char *buffer, int type);
 
 X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method);
 void X509_LOOKUP_free(X509_LOOKUP *ctx);
diff -rNup openssl-1.1.1c.orig/util/libcrypto.num openssl-1.1.1c/util/libcrypto.num
--- openssl-1.1.1c.orig/util/libcrypto.num	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/util/libcrypto.num	2019-08-20 18:11:42.705508993 -0700
@@ -4580,3 +4580,128 @@ EVP_PKEY_meth_get_digest_custom
 OPENSSL_INIT_set_config_filename        4534	1_1_1b	EXIST::FUNCTION:STDIO
 OPENSSL_INIT_set_config_file_flags      4535	1_1_1b	EXIST::FUNCTION:STDIO
 EVP_PKEY_get0_engine                    4536	1_1_1c	EXIST::FUNCTION:ENGINE
+ASN1_item_d2i_bio_buffer                8000	1_1_0	EXIST::FUNCTION:
+PEM_ASN1_read_buffer                    8001	1_1_0	EXIST::FUNCTION:STDIO
+PEM_ASN1_write_buffer                   8002	1_1_0	EXIST::FUNCTION:STDIO
+PEM_ASN1_read_bio_buffer                8003	1_1_0	EXIST::FUNCTION:
+PEM_ASN1_write_bio_buffer               8004	1_1_0	EXIST::FUNCTION:
+PEM_read_bio_buffer                     8005	1_1_0	EXIST::FUNCTION:
+PEM_bytes_read_bio_buffer               8006	1_1_0	EXIST::FUNCTION:
+PEM_ASN1_read_bio_buffer                8007	1_1_0	EXIST::FUNCTION:
+PEM_ASN1_write_bio_buffer               8008	1_1_0	EXIST::FUNCTION:
+PEM_X509_INFO_read_bio_from_buffer      8009	1_1_0	EXIST::FUNCTION:
+PEM_ASN1_read_buffer                    8010	1_1_0	EXIST::FUNCTION:STDIO
+PEM_ASN1_write_buffer                   8011	1_1_0	EXIST::FUNCTION:STDIO
+RSA_generate_key_big_exponent           8012	1_1_0	EXIST::FUNCTION:RSA
+d2i_X509_bio_buffer                     8013	1_1_0	EXIST::FUNCTION:
+X509_LOOKUP_buffer                      8014	1_1_0	EXIST::FUNCTION:
+X509_load_cert_buffer                   8015	1_1_0	EXIST::FUNCTION:
+X509_load_cert_crl_buffer               8016	1_1_0	EXIST::FUNCTION:
+PEM_read_bio_buffer_X509_AUX            8017	1_1_0	EXIST::FUNCTION:
+PEM_read_bio_buffer_CMS            	8018	1_1_0	EXIST::FUNCTION:CMS
+PEM_read_bio_buffer_DHparams            8019	1_1_0	EXIST::FUNCTION:DH
+PEM_read_bio_buffer_DSAPrivateKey       8020	1_1_0	EXIST::FUNCTION:DSA
+PEM_read_bio_buffer_DSA_PUBKEY          8021	1_1_0	EXIST::FUNCTION:DSA
+PEM_read_bio_buffer_DSAparams           8022	1_1_0	EXIST::FUNCTION:DSA
+PEM_read_bio_buffer_ECPKParameters      8023	1_1_0	EXIST::FUNCTION:EC
+PEM_read_bio_buffer_ECPrivateKey        8024    1_1_0   EXIST::FUNCTION:EC
+PEM_read_bio_buffer_EC_PUBKEY           8025    1_1_0   EXIST::FUNCTION:EC
+PEM_read_bio_buffer_NETSCAPE_CERT_SEQUENCE     8026    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_PKCS7               8027    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_PKCS8               8028    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_PKCS8_PRIV_KEY_INFO 8029    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_PUBKEY              8030    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_X509_CRL            8031    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_RSAPrivateKey       8032    1_1_0   EXIST::FUNCTION:RSA
+PEM_read_bio_buffer_PrivateKey          8033    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_X509_REQ            8034    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_RSA_PUBKEY          8035    1_1_0   EXIST::FUNCTION:RSA
+PEM_read_bio_buffer_X509                8036    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_DSAPrivateKey       8037    1_1_0   EXIST::FUNCTION:DSA
+PEM_read_bio_buffer_Parameters          8038    1_1_0   EXIST::FUNCTION:
+PEM_read_bio_buffer_RSAPublicKey        8039    1_1_0   EXIST::FUNCTION:RSA
+PEM_read_bio_buffer_ex                  8040    1_1_1   EXIST::FUNCTION:
+PEM_read_buffer_DHparams                8041    1_1_0   EXIST::FUNCTION:DH,STDIO
+PEM_read_buffer_X509_CRL                8042    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_PKCS8                   8043    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_RSA_PUBKEY              8044    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_read_buffer_EC_PUBKEY               8045    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_read_buffer_X509                    8046    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_NETSCAPE_CERT_SEQUENCE  8047    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_X509_REQ                8048    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_RSAPrivateKey           8049    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_read_buffer_PrivateKey              8050    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_DSAparams               8051    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_read_buffer_X509_AUX                8052    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_ECPrivateKey            8053    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_read_buffer_PKCS7                   8054    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_DSAPrivateKey           8055    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_read_buffer_CMS                     8056    1_1_0   EXIST::FUNCTION:CMS,STDIO
+PEM_read_buffer_RSAPublicKey            8057    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_read_buffer_DSA_PUBKEY              8058    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_read_buffer_PKCS8_PRIV_KEY_INFO     8059    1_1_0   EXIST::FUNCTION:STDIO
+PEM_read_buffer_ECPKParameters          8060    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_read_buffer_PUBKEY                  8061    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_Parameters         8062    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_ASN1_stream        8063    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_ECPrivateKey       8064    1_1_0   EXIST::FUNCTION:EC
+PEM_write_bio_buffer_ECPKParameters     8065    1_1_0   EXIST::FUNCTION:EC
+PEM_write_buffer_PKCS8_PRIV_KEY_INFO    8066    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_DSA_PUBKEY         8067    1_1_0   EXIST::FUNCTION:DSA
+PEM_write_bio_buffer_PKCS7_stream       8068    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_CMS                8069    1_1_0   EXIST::FUNCTION:CMS
+PEM_write_bio_buffer_DHparams           8070    1_1_0   EXIST::FUNCTION:DH
+PEM_write_buffer_CMS                    8071    1_1_0   EXIST::FUNCTION:CMS,STDIO
+PEM_write_bio_buffer_RSAPrivateKey      8072    1_1_0   EXIST::FUNCTION:RSA
+PEM_write_buffer_X509_REQ               8073    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_ECPrivateKey           8074    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_write_bio_buffer_RSA_PUBKEY         8075    1_1_0   EXIST::FUNCTION:RSA
+PEM_write_buffer_PKCS8PrivateKey_nid    8076    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_X509_CRL           8077    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_PKCS8              8078    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_PKCS7              8079    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_RSA_PUBKEY             8080    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_write_buffer_DSA_PUBKEY             8081    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_write_bio_buffer_CMS_stream         8082    1_1_0   EXIST::FUNCTION:CMS
+PEM_write_bio_buffer_X509               8083    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_X509_REQ_NEW           8084    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_NETSCAPE_CERT_SEQUENCE 8085    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_PKCS7                  8086    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_X509_AUX           8087    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_PKCS8PrivateKey    8088    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_PKCS8                  8089    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_X509_AUX               8090    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_X509_REQ_NEW       8091    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_PUBKEY                 8092    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_DHparams               8093    1_1_0   EXIST::FUNCTION:DH,STDIO
+PEM_write_buffer_X509                   8094    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_NETSCAPE_CERT_SEQUENCE    8095    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_PKCS8_PRIV_KEY_INFO 8095   1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_X509_CRL               8097    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_PUBKEY             8098    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_bio                    8099    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_DHxparams          8100    1_1_0   EXIST::FUNCTION:DH
+PEM_write_bio_buffer_DSAparams          8101    1_1_0   EXIST::FUNCTION:DSA
+PEM_write_buffer_ECPKParameters         8102    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_write_buffer_PKCS8PrivateKey        8103    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_PrivateKey         8104    1_1_0   EXIST::FUNCTION:
+PEM_write_bio_buffer_EC_PUBKEY          8105    1_1_0   EXIST::FUNCTION:EC
+PEM_write_buffer_RSAPrivateKey          8106    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_write_bio_buffer_PKCS8PrivateKey_nid 8107   1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_PrivateKey             8108    1_1_0   EXIST::FUNCTION:STDIO
+PEM_write_buffer_DSAparams              8109    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_write_buffer_RSAPublicKey           8110    1_1_0   EXIST::FUNCTION:RSA,STDIO
+PEM_write_buffer_EC_PUBKEY              8111    1_1_0   EXIST::FUNCTION:EC,STDIO
+PEM_write_bio_buffer_DSAPrivateKey      8112    1_1_0   EXIST::FUNCTION:DSA
+PEM_write_bio_buffer_RSAPublicKey       8113    1_1_0   EXIST::FUNCTION:RSA
+PEM_write_bio_buffer_X509_REQ           8114    1_1_0   EXIST::FUNCTION:
+PEM_write_buffer_DHxparams              8115    1_1_0   EXIST::FUNCTION:DH,STDIO
+PEM_write_buffer_DSAPrivateKey          8116    1_1_0   EXIST::FUNCTION:DSA,STDIO
+PEM_write_bio_buffer_PrivateKey_traditional    8117    1_1_0   EXIST::FUNCTION:
+
+
+
+
+
+
+
diff -rNup openssl-1.1.1c.orig/util/libssl.num openssl-1.1.1c/util/libssl.num
--- openssl-1.1.1c.orig/util/libssl.num	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/util/libssl.num	2019-08-20 18:03:11.601668875 -0700
@@ -498,3 +498,9 @@ SSL_CTX_get_recv_max_early_data
 SSL_CTX_set_recv_max_early_data         499	1_1_1	EXIST::FUNCTION:
 SSL_CTX_set_post_handshake_auth         500	1_1_1	EXIST::FUNCTION:
 SSL_get_signature_type_nid              501	1_1_1a	EXIST::FUNCTION:
+PEM_read_bio_buffer_SSL_SESSION         8000	1_1_0	EXIST::FUNCTION:
+PEM_read_buffer_SSL_SESSION             8001	1_1_0	EXIST::FUNCTION:STDIO
+PEM_write_buffer_SSL_SESSION            8002	1_1_0	EXIST::FUNCTION:STDIO
+PEM_write_bio_buffer_SSL_SESSION        8003	1_1_0	EXIST::FUNCTION:
+
+
diff -rNup openssl-1.1.1c.orig/util/mkdef.pl openssl-1.1.1c/util/mkdef.pl
--- openssl-1.1.1c.orig/util/mkdef.pl	2019-05-28 06:12:21.000000000 -0700
+++ openssl-1.1.1c/util/mkdef.pl	2019-08-20 18:03:11.601668875 -0700
@@ -774,7 +774,9 @@ sub do_defs
 				} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
 					next;
 				} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_rw_buffer\s*\(\s*(\w*)\s*,/ ||
 					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ||
+					 /^DECLARE_PEM_rw_cb_buffer\s*\(\s*(\w*)\s*,/ ||
 					 /^DECLARE_PEM_rw_const\s*\(\s*(\w*)\s*,/ ) {
 					$def .=
 					    "#INFO:"
@@ -782,6 +784,8 @@ sub do_defs
 						    .join(',',"STDIO",@current_algorithms).";";
 					$def .= "int PEM_read_$1(void);";
 					$def .= "int PEM_write_$1(void);";
+					$def .= "int PEM_read_buffer_$1(void);";
+					$def .= "int PEM_write_buffer_$1(void);";
 					$def .=
 					    "#INFO:"
 						.join(',',@current_platforms).":"
@@ -789,6 +793,8 @@ sub do_defs
 					# Things that are everywhere
 					$def .= "int PEM_read_bio_$1(void);";
 					$def .= "int PEM_write_bio_$1(void);";
+					$def .= "int PEM_read_bio_buffer_$1(void);";
+					$def .= "int PEM_write_bio_buffer_$1(void);";
 					next;
 				} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
 					/^DECLARE_PEM_write_const\s*\(\s*(\w*)\s*,/ ||
