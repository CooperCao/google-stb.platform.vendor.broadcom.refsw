#!/bin/bash

cpufreq_sysfs=/sys/devices/system/cpu/cpu0/cpufreq
stats_sysfs=$cpufreq_sysfs/stats/time_in_state

avail_freq=`cat $cpufreq_sysfs/scaling_available_frequencies`
freq_arr=($avail_freq);
num_p_states=${#freq_arr[@]}

poll_interval_us=200000
timeout=60
load=100
ramp=0
mode=1
auto=0
verify=0
governor=conservative

trap ctrl_c INT

function ctrl_c {
    echo -e '\n'
	end_stats=`get_stats`
    print_stats "$begin_stats" "$end_stats"
    exit
}

function get_stats {
	stats=`cat $stats_sysfs`

	for frequency in $avail_freq; do
		stats=${stats/$frequency}
	done

	echo $stats;
}

function print_stats {
	local begin_arr=($1);
	local end_arr=($2);
	local total_time=0;
	local i;


    if [ $auto -eq 0 ] && [ $mode -eq 1 ]; then
        echo -e '\n'=======================================
        echo -e State'\t\t'Frequency'\t'Voltage
        echo -e =======================================
        for ((i=0; i<$num_p_states; i++));
        do
            echo -e P$i'\t\t'${actual_freq_arr[$i]}'\t\t'${actual_volt_arr[$i]}
        done
        echo -e ======================================='\n'
    else
        for ((i=0; i<$num_p_states; i++));
        do
            total_time=$(($total_time + ${end_arr[$i]} - ${begin_arr[$i]}))
        done

        echo -e '\n'===========================================================
        echo -e State'\t\t'Frequency'\t'Voltage'\t\t'Duration[%]
        echo -e ===========================================================
        for ((i=0; i<$num_p_states; i++));
        do
            local percent=$((100*(${end_arr[$i]} - ${begin_arr[$i]})/$total_time))
            echo -e P$i'\t\t'${actual_freq_arr[$i]}'\t\t'${actual_volt_arr[$i]}'\t\t'$percent%
        done
        echo -e ==========================================================='\n'
    fi
}

function print_stats3 {
	local begin_arr=($1);
	local end_arr=($2);
	local total_time=0;
	local i;

	for ((i=0; i<$num_p_states; i++));
	do
		total_time=$(($total_time + ${end_arr[$i]} - ${begin_arr[$i]}))
	done

	for ((i=0; i<$num_p_states; i++));
	do
		local percent=$((100*(${end_arr[$i]} - ${begin_arr[$i]})/$total_time))
        echo -ne "P$i(${actual_freq_arr[$i]}) : $percent%, "
	done
}

function reset_stats {
	local i;

	for ((i=0; i<$num_p_states; i++));
	do
		unset actual_freq_arr[$i]
		unset actual_volt_arr[$i]
	done
}

function get_one_cpu_usage {
	echo `cat /proc/stat | grep 'cpu\s' | awk '{print $2,$3,$4}'`
}

function get_cpu_usage {
	local start=`get_one_cpu_usage`
	sleep 1
	local end=`get_one_cpu_usage`

	start_arr=($start)
	end_arr=($end)

	local usage=0
	for ((i=0; i<${#start_arr[@]}; i++));
	do
		usage=$(($usage + ${end_arr[$i]} - ${start_arr[$i]}))
	done
	echo $usage;
}

function usage {
	echo -e "Usage: dvfs [-mMODE] [-lLOAD] [-tN] [-h]"
	echo -e "\t-mMODE   - Select the test to run"
	echo -e "\t\t1 : Uses user-space governor. User puts the CPU in each P state to collect stats. Use -a option to automatically transition states"
	echo -e "\t\t2 : Uses conservative governor. Linearly ramp up CPU usage causing the CPU to transition through all P states automatically"
	echo -e "\t\t3 : Default governor is used. Custom application running in background"
	echo -e "\t-lLOAD   - Max CPU load. Default is 100%"
	echo -e "\t-tN      - Duration of this test in seconds. Default is 60s"
	echo -e "\t-gGOV    - Cpu freq governot to use for Test Mode 3. Default is performance"
    echo -e "\t-a       - Automatically transition through the P states in mode 1"
    echo -e "\t-v       - Verify the frequency and voltage in each P state"
	echo -e "\t-h       - Print Usage"
}

function get_pstate {
    pstate=`cat /sys/devices/system/cpu/cpu0/cpufreq/brcm_avs_pstate`
    cur_volt=`cat /sys/devices/system/cpu/cpu0/cpufreq/brcm_avs_voltage`;
    cur_volt=$(($cur_volt));
    actual_volt_arr[$pstate]=$cur_volt
    cur_freq=`cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq`
    actual_freq_arr[$pstate]=$cur_freq
}

function wait_for_pid {
    #Wait for pid to exit
    local cnt=0;
    while sleep 1; do
        kill -0 $1 2>/dev/null || break;
        ((cnt++));
        if [ "$cnt" -ge 10 ]; then
            break;
        fi
    done
}

function set_freq {
    local freq=${freq_arr[$1]}
    echo $freq > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed

}

function start_test_manual {
    if [ $mode -ne 1 ]; then
        echo Test is not available for test mode $mode. Quitting...
        exit
    fi

    cur_p_state=0;
    set_freq $cur_p_state
    echo Press Enter for next PState

    if [ $mode -ne 3 ]; then
        cpuload -l $load -t -1&
		pid=$!
		echo Started CPU load test [PID:$pid] with $timeout second timeout
	fi

    while true; do
        get_pstate

		#cpu=`top -bn1 -p $pid | grep "cpuload" | awk '{print $9}'`
		#cpu=`get_cpu_usage`
		echo -ne PState : $pstate, Frequency : $cur_freq Hz, Voltage : $cur_volt mV'\r'

        read

        ((cur_p_state++));
        if [ "$cur_p_state" -lt "$(($num_p_states))" ]; then
            set_freq $cur_p_state
        else
            break;
        fi
	done

	print_stats

	if [[ $pid ]]; then
        kill -9 $1 2>/dev/null;
	fi
}

function start_test_auto {
    if [ $mode -eq 3 ]; then
        echo Test is not available for test mode $mode. Quitting...
        exit
    fi
    echo Press Ctrl + C to quit

	if [ $mode -eq 1 ]; then
		step=$(($timeout/$num_p_states))
		cur_p_state=0;
        set_freq $cur_p_state
	fi

	begin_stats=`get_stats`

    cpuload -l $load -t $timeout -r $ramp&
    pid=$!
    echo Started CPU load test [PID:$pid] with $timeout second timeout

	start_time=`date +%s`
	if [ $mode -eq 1 ]; then
		next_time=$(($start_time+$step))
	fi

	while true; do
		end_time=`date +%s`
		diff=$(($end_time-$start_time))
		if [ "$diff" -ge "$timeout" ]; then
			break;
		fi
		if [ $mode -eq 1 ]; then
			if [ "$end_time" -ge "$next_time" ]; then
				if [ "$cur_p_state" -lt "$(($num_p_states-1))" ]; then
					((cur_p_state++));
				fi
                set_freq $cur_p_state
				next_time=$(($next_time+$step))
			fi
		fi
		percent=$((100*($diff)/$timeout))
        get_pstate

		#cpu=`top -bn1 -p $pid | grep "cpuload" | awk '{print $9}'`
		#cpu=`get_cpu_usage`
		echo -ne PState : $pstate, Frequency : $cur_freq Hz, Voltage : $cur_volt mV [$percent% Test Complete]'\r'

        usleep $poll_interval_us
	done

	end_stats=`get_stats`

	echo PState : $pstate, Frequency : $cur_freq Hz, Voltage : $cur_volt mV [100% Test Complete]

	print_stats "$begin_stats" "$end_stats"

	if [[ $pid ]]; then
        wait_for_pid $pid
	fi
}

function start_test_custom {
    echo Press Ctrl + C to quit

	begin_stats=`get_stats`
	while true; do
        get_pstate
        end_stats=`get_stats`
		echo PState : $pstate, Frequency : $cur_freq, Voltage : $cur_volt
        print_stats3 "$begin_stats" "$end_stats"
        echo ""
        echo -ne "\033[2A"
        sleep 1
	done
}

function verify_pmap {
    file=/proc/device-tree/bolt/pmap
    while read -n1 char
    do
        pmap=`printf '%u\n' "'$char"`
    done <"$file"

    platform=`cat /proc/device-tree/bolt/board`
    platform=${platform:3:5}
    file=$platform"_Pmap"$pmap".txt"
    local p_state=0
    while read -r f1 f2 f3
    do
        p_state=${f1:1:${#f1}}
        pmap_freq_arr[$p_state]=$f2
        pmap_volt_arr[$p_state]=$f3
    done <"$file"

    if [ "${pmap_freq_arr[*]}" = "${actual_freq_arr[*]}" ]  && [ "${pmap_volt_arr[*]}" = "${actual_volt_arr[*]}" ]; then
        echo PASS
    else
        echo FAIL
    fi
}

function verify_dvfs {
    local pass=1
    for ((i=0; i<$num_p_states; i++));
    do
        if [ "${actual_freq_arr[$i]}" = "" ] || [ "${actual_volt_arr[$i]}" = "" ]; then
            echo  CPU did not enter P$i
            pass=0
        fi
    done
    if [ $pass -eq 1 ]; then
        echo PASS
    else
        echo FAIL
    fi
}

if [ ! -f /sys/devices/system/cpu/cpu0/cpufreq/brcm_avs_pstate ] || [ ! -f /sys/devices/system/cpu/cpu0/cpufreq/brcm_avs_voltage ]; then
        echo Not Supported
        exit
fi

while getopts "t:m:hl:g:av" option
do
	case $option in
	t)
		timeout=$OPTARG;;
    m)
		mode=$OPTARG;;
    l)
		load=$OPTARG;;
	g)
		governor=$OPTARG;;
	a)
		auto=1;;
	v)
		verify=1;;
	h|*)
		usage
		exit;;
	esac
done

echo -e '\n'

killall cpuload 2>/dev/null

reset_stats

echo Starting test in Mode $mode
if [ $mode -eq 1 ]; then
	ramp=0
	echo userspace > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
	echo Setting Governor to `cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor`
    if [ $auto -eq 1 ]; then
        start_test_auto
    else
        start_test_manual
    fi
elif [ $mode -eq 2 ]; then
	ramp=1
	echo conservative > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
	echo Setting Governor to `cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor`
    start_test_auto
elif [ $mode -eq 3 ]; then
	ramp=0
	echo $governor > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
	echo Setting Governor to `cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor`
    start_test_custom
fi

if [ $verify -eq 1 ]; then
    verify_dvfs
fi
