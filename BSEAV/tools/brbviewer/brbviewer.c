/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the terms and
 *  conditions of a separate, written license agreement executed between you and Broadcom
 *  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 *  no license (express or implied), right to use, or waiver of any kind with respect to the
 *  Software, and Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 *  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 *  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 *  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 *  and to use this information only in connection with your use of Broadcom integrated circuit products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 *  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 *  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 *  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
 *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
 *  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
 *  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
 *  USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 *  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
 *  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
 *  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
 *  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
 *  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
 *  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
 *  ANY LIMITED REMEDY.

 ******************************************************************************/
#include "bmemperf_types64.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <stdbool.h>
#include <fcntl.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <sys/utsname.h>
#include "bstd.h"
#include "bdbg.h"
#include "bkni.h"
#include "bmemperf_info.h"
#include "bmemperf.h"
#include "bmemperf_utils.h"
#include "bmemperf_lib.h"
#include "bbase64.h"
#include "bchp_pwr.h"
#include "bchp_pwr_resources.h"
#include "brbviewer_regs_autogen.h"                        /* this file is auto-generated by awk script during compile time */

char         *g_client_name[BMEMPERF_MAX_NUM_CLIENT];
int           g_MegaBytes           = 0;                   /* set to 1 when user wants data displayed in megabytes instead of megabits (default) */
int           g_MegaBytesDivisor[2] = {1, 8};
char         *g_MegaBytesStr[2] = {"Mbps", "MBps"};
bmemperf_info g_bmemperf_info;
bsysperf_netStatistics g_netStats[NET_STATS_MAX];
int                    g_netStatsIdx = -1;                 /* index to entries added to g_netStats array */

#define PRINTFLOG noprintf
#define BCHP_ACQUIRE_BVN 0

static int get_bvn_register_values(
    unsigned int *regValues,
    int           regValuesNumber
    )
{
    unsigned int idx           = 0;
    int          registerCount = 0;

    PRINTFLOG( "%s:%u\n", __FILE__, __LINE__ );

#if BCHP_ACQUIRE_BVN
    BCHP_Handle       chp     = 0;
    unsigned int      clkRate = 0;
    BCHP_OpenSettings chpSettings;

    PRINTFLOG( "%s:%u - calling BCHP_GetDefaultOpenSettings() \n", __FILE__, __LINE__ );
    BCHP_GetDefaultOpenSettings( &chpSettings );
    chpSettings.reg = reg;
    PRINTFLOG( "%s:%u - calling BCHP_Open() \n", __FILE__, __LINE__ );
    BCHP_Open( &chp, &chpSettings );
    PRINTFLOG( "%s:%u - after BCHP_Open() chp %ld\n", __FILE__, __LINE__, (unsigned long int) chp );
    BCHP_PWR_GetClockRate( chp, BCHP_PWR_RESOURCE_BVN, &clkRate );
    PRINTFLOG( "%s:%u - clkRate %u\n", __FILE__, __LINE__, clkRate );

#if BCHP_PWR_RESOURCE_BVN
    BCHP_PWR_AcquireResource( chp, BCHP_PWR_RESOURCE_BVN );
#endif /* BCHP_PWR_RESOURCE_BVN */
#endif /* BCHP_ACQUIRE_BVN */

    PRINTFLOG( "%s:%u - reading VNET_B_REGISTER ... %d regs\n", __FILE__, __LINE__, (int) (sizeof( VNET_B_REGISTERS )/sizeof( VNET_B_REGISTERS[0] )));
    for (idx = 0; idx<sizeof( VNET_B_REGISTERS )/sizeof( VNET_B_REGISTERS[0] ); idx++, registerCount++)
    {
        if (registerCount < regValuesNumber)
        {
            regValues[registerCount] = htonl( bmemperf_readReg32( VNET_B_REGISTERS[idx] ));
            PRINTFLOG( "idx: %-3d ... offset 0x%lx = 0x%lx\n", registerCount, VNET_B_REGISTERS[idx], regValues[registerCount] );
        }
    }

    PRINTFLOG( "%s:%u - reading VNET_F_REGISTER ... %d regs\n", __FILE__, __LINE__, (int) (sizeof( VNET_F_REGISTERS )/sizeof( VNET_F_REGISTERS[0] )) );
    for (idx = 0; idx<sizeof( VNET_F_REGISTERS )/sizeof( VNET_F_REGISTERS[0] ); idx++, registerCount++)
    {
        if (registerCount < regValuesNumber)
        {
            regValues[registerCount] = htonl( bmemperf_readReg32( VNET_F_REGISTERS[idx] ));
            PRINTFLOG( "idx: %-3d ... offset 0x%lx = 0x%lx\n", registerCount, VNET_F_REGISTERS[idx], regValues[registerCount] );
        }
    }

    PRINTFLOG( "%s:%u\n", __FILE__, __LINE__ );

#if BCHP_ACQUIRE_BVN
#if BCHP_PWR_RESOURCE_BVN
    BCHP_PWR_ReleaseResource( chp, BCHP_PWR_RESOURCE_BVN );
#endif /* BCHP_PWR_RESOURCE_BVN */
#endif /* BCHP_ACQUIRE_BVN */

    return( 0 );
} /* get_bvn_register_values */

int main(
    void
    )
{
    unsigned int      idx         = 0;
    char             *queryString = NULL;
    char             *contentType;
    char             *contentLength;
    unsigned int      contentLengthInt = 0;
    unsigned int      regValues[ BCHP_VNET_B_SCRATCH_REGISTER_MAX + BCHP_VNET_F_SCRATCH_REGISTER_MAX ];
    char              regValuesBase64Encoded[ ( BCHP_VNET_B_SCRATCH_REGISTER_MAX + BCHP_VNET_F_SCRATCH_REGISTER_MAX ) *4*8];
    int               regErrors[5];
    char              regErrorsBase64Encoded[sizeof( regErrors )*2];
    char             *pos = NULL;

    #if 1
    printf( "Content-type: text/xml%c%c", 10, 10 );
    #else
    printf( "Content-type: text/html%c%c", 10, 10 );
    #endif
    fflush( stdout );
    fflush( stderr );

    BKNI_Init();
    BDBG_Init();

    queryString   = getenv( "QUERY_STRING" );
    contentType   = getenv( "CONTENT_TYPE" );
    contentLength = getenv( "CONTENT_LENGTH" );

    get_bvn_register_values( &regValues[0], sizeof(regValues)/sizeof(regValues[0]) );

    memset( regValuesBase64Encoded, 0, sizeof( regValuesBase64Encoded ));
    memset( regErrorsBase64Encoded, 0, sizeof( regErrorsBase64Encoded ));

    bbase64_encode((unsigned char *) &regValues, sizeof( regValues ), regValuesBase64Encoded, sizeof( regValuesBase64Encoded ));
    PRINTFLOG("bbase64_encode len (%d) ... max (%d) \n", (int) strlen(regValuesBase64Encoded), (int) sizeof(regValuesBase64Encoded) );
    PRINTFLOG("bbase64_encode (%s)\n", regValuesBase64Encoded );
    bbase64_encode((unsigned char *) &regErrors, sizeof( regErrors ), regErrorsBase64Encoded, sizeof( regErrorsBase64Encoded ));
    do
    {
        if (( pos = strchr( regValuesBase64Encoded, ' ' )))
        {
            *pos = 0;
        }
    } while (pos);

    /*printf("queryString %p; contentType %p; contentLength %p\n", queryString, contentType, contentLength );*/
    if (contentType)
    {
        /*printf("contentType (%s) \n", contentType );*/
    }

    if (contentLength)
    {
        char *xml_contents = NULL;

        contentLengthInt = atoi( contentLength );

        xml_contents = malloc( contentLengthInt + 1 );
        PRINTF( "malloc'ed space for %d bytes<br>\n", contentLengthInt + 1 );

        if (xml_contents == NULL)
        {
            PRINTF( "could not malloc(%d) bytes<br>\n", contentLengthInt + 1 );
        }
        else
        {
            {
                char          *boltVersion  = NULL;
                struct utsname uname_info;
                memset( &uname_info, 0, sizeof(uname_info));

                boltVersion = getFileContents( "/proc/device-tree/bolt/tag" );
                uname(&uname_info);

                printf( "<?xml version=\"1.0\" encoding=\"utf-8\"?><s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" " );
                printf( "s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">" );
                printf( "<s:Body><u:GetRegisterCollectionWithElmErrsResponse xmlns:u=\"urn:schemas-upnp-org:service:RegSvc:1\">" );

                printf( "<PlatformType>%s</PlatformType>", getPlatform());
                printf( "<PlatformVersion>%s</PlatformVersion>", getPlatformVersion());
                printf( "<PlatformVariant>(Variant: %s)</PlatformVariant>", getProductIdStr() );
                printf( "<PlatformUname>Kernel: %d-bit %s %s</PlatformUname>", (sizeof(char*) == 8)?64:32, uname_info.machine , uname_info.release );
                if ( boltVersion )
                {
                    printf( "<PlatformBoltVer>Bolt: %s</PlatformBoltVer>", boltVersion );
                    Bsysperf_Free( boltVersion );
                }
                printf( "<StbTime>%s</StbTime>", DayMonDateYear( 0 ));


                printf( "<RegisterValues>" );
                printf( "%s", regValuesBase64Encoded );
                printf( "</RegisterValues>" );

                printf( "<RegisterErrs>" );
                printf( "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==" );
                printf( "</RegisterErrs>" );

                printf( "<box1_srcs>%s</box1_srcs>", box1_srcs );
                {
                    char *pos_tntd = NULL;
                    char *pos_dnr0 = NULL;
                    /* the tntd value needs to be listed before the dnr values */
                    pos_tntd = strstr( box23_srcs, "tntd_0" );
                    pos_dnr0 = strstr( box23_srcs, "dnr_0" );
                    if (pos_tntd && ( pos_tntd > pos_dnr0 ))
                    {
                        unsigned int len      = pos_tntd - pos_dnr0;
                        char        *temp_str = (char *) malloc( len + 1 );
                        if (temp_str)
                        {
                            /*       pos_dnr0                            pos_tntd */
                            /*       |                                   | */
                            /* mvp_5,dnr_0,dnr_1,dnr_2,dnr_3,dnr_4,dnr_5,tntd_0,fch_0,fch_1,fch_2,fch_3,fch_4,fch_5,fch_6,fch_7,fch_8,fch_9 */
                            strncpy( temp_str, pos_dnr0, len );      /* save the dnr string values */
                            strncpy( pos_dnr0+0, "tntd_0\",\"", 9 ); /* copy the tntd_0 string to before dnr_0 */
                            strncpy( pos_dnr0+9, temp_str, len );    /* copy the original dnr_0 strings to AFTER tntd_0 string */
                            Bsysperf_Free( temp_str );
                        }
                    }
                }
                printf( "<box23_srcs>%s</box23_srcs>", box23_srcs );

                printf( "<javascript_boxes_0>%s</javascript_boxes_0>", javascript_boxes_0 );
                printf( "<javascript_boxes_1>%s</javascript_boxes_1>", javascript_boxes_1 );
                printf( "<javascript_boxes_2>%s</javascript_boxes_2>", javascript_boxes_2 );
                printf( "<javascript_boxes_3>%s</javascript_boxes_3>", javascript_boxes_3 );
                {
                    int len = strlen( bvnview_addrs_1_b ) + strlen( bvnview_addrs_2_b ) + strlen( bvnview_addrs_3_b ) + strlen( bvnview_addrs_1_f ) + strlen( bvnview_addrs_2_f ) + strlen( bvnview_addrs_3_f );
                    printf( "<DEBUG>len %d</DEBUG>", len );
                    if (len)
                    {
                        char *bvnview_addrs = (char *) malloc( len + 1 );
                        if (bvnview_addrs)
                        {
                            memset( bvnview_addrs, 0, len + 1 );
                            strncat( bvnview_addrs, &bvnview_addrs_1_b[1], len - strlen( bvnview_addrs )); /* skip the first character ... it is a comma */
                            strncat( bvnview_addrs, &bvnview_addrs_2_b[0], len - strlen( bvnview_addrs ));
                            strncat( bvnview_addrs, &bvnview_addrs_3_b[0], len - strlen( bvnview_addrs ));
                            strncat( bvnview_addrs, &bvnview_addrs_1_f[0], len - strlen( bvnview_addrs ));
                            strncat( bvnview_addrs, &bvnview_addrs_2_f[0], len - strlen( bvnview_addrs ));
                            strncat( bvnview_addrs, &bvnview_addrs_3_f[0], len - strlen( bvnview_addrs ));
                            printf( "<bvnview_addrs>%s</bvnview_addrs>", bvnview_addrs );
                            Bsysperf_Free( bvnview_addrs );
                        }
                        else
                        {
                            printf( "<DEBUG>could not malloc %d bytes</DEBUG>", len );
                        }
                    }
                }

                printf( "<h_info>" );
                for (idx = 0; idx<H_INFO_MAX; idx++)
                {
                    printf( "%s", h_info[idx] );
                }
                printf( "</h_info>" );

                printf( "</u:GetRegisterCollectionWithElmErrsResponse></s:Body></s:Envelope>" );
            }
            Bsysperf_Free( xml_contents );
        }
    }

    if (queryString && strlen( queryString ))
    {
        printf( "~DEBUG~queryString (%s)~", queryString );
    }
    else
    {
        /*printf("queryString is NULL\n");*/
    }

    return( 0 );
}                                                          /* main */
