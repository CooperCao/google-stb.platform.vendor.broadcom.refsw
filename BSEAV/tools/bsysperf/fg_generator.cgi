#!/usr/bin/perl

##############################################################################
#  Broadcom Proprietary and Confidential. (c)2016 Broadcom. All rights reserved.
#
#  This program is the proprietary software of Broadcom and/or its licensors,
#  and may only be used, duplicated, modified or distributed pursuant to the terms and
#  conditions of a separate, written license agreement executed between you and Broadcom
#  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
#  no license (express or implied), right to use, or waiver of any kind with respect to the
#  Software, and Broadcom expressly reserves all rights in and to the Software and all
#  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
#  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
#  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
#
#  Except as expressly set forth in the Authorized License,
#
#  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
#  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
#  and to use this information only in connection with your use of Broadcom integrated circuit products.
#
#  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
#  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
#  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
#  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
#  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
#  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
#  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
#  USE OR PERFORMANCE OF THE SOFTWARE.
#
#  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
#  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
#  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
#  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
#  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
#  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
#  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
#  ANY LIMITED REMEDY.
##############################################################################

##############################################################################
#
# How to use this CGI:
#
# The query string passed to this CGI needs two name/value pairs:
#
#     ipaddr   - the IP address of the STB under test
#     perf_out - the name of the file generated by the
#                perf script command. This file must reside
#                in the boa directory by default.
#
# The file we need for the perf_out is generated on the STB as follows:
#
#     perf record -a -g -F 999 -- <the test we're running>
#     perf script > <output filename>
#
# Once the file generated by perf script exists the CGI is invoked from a
# browser directly or by the bsysperf page as follows:
#
# <FlameGraph Generator IP Addr>/fg_generator.cgi?ipaddr=<STB IP Addr>&perf_out=<generated filename>
#
# At this point fg_generator.cgi will get the file generated by perf script from the STB,
# rename it then perform the two steps necessary to create the flame graph. The flame graph
# will be directly output to the browser and all the generated files will be deleted from the
# FlameGraph server.
#
##############################################################################

use Time::localtime;

#
# See if a local temp directory exists in public_html.
# If not, create it with the appropriate permissions.
# For this to work properly the public_html directory
# needs to have a permissions mask of 0777.
#
if (! -d "temp"){
   $oldmask = umask(0);
   mkdir(temp, 0777) or die "Can't create temp directory: $!";
   umask($oldmask);
}

#
# Create the new local filenames. We can't
# use UUID values since the UUID module may
# not exist on all perl installations so we
# use date & time.
#
$tm = localtime;
my $string = sprintf '%4d-%02d-%02d_%02d:%02d:%02d', $tm->year+1900, ($tm->mon+1), $tm->mday, $tm->hour,$tm->min, $tm->sec ;
$newinfilenm = $string . ".out";
$newclfilenm = $string . ".collapsed";
$newfgfilenm = $string . ".svg";

print  "Content-type: image/svg+xml\n\n";

if (length ($ENV{'QUERY_STRING'}) > 0){
      $buffer = $ENV{'QUERY_STRING'};
      $ipaddr = "";
      @pairs = split(/&/, $buffer);
      foreach $pair (@pairs){
           ($name, $value) = split(/=/, $pair);
           $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
           $in{$name} = $value;

           if ( $name eq "ipaddr" ) {
               $ipaddr = $value;
           } else {
               if ( $name eq "perf_out" ) {
                   #
                   # Get the perf script file from the STB's boa directory
                   #
                   $cmd = '(cd temp && wget http://' . $ipaddr . '/' . $value . ')';
                   system ($cmd) == 0 or die "system $cmd failed: $?";
                   rename('temp/' . $value, 'temp/' . $newinfilenm) or die "Can't rename $value to $newinfilenm";

                   #
                   # Generate the collapsed stack first
                   #
                   $cmd = '(cat temp/' . $newinfilenm . '| ./stackcollapse-perf.pl > temp/' . $newclfilenm . ')';
                   system ($cmd) == 0 or die "system $cmd failed: $?";

                   #
                   # Now generate the actual flame graph
                   #
                   $tm = localtime;
                   my $ldate = sprintf '%4d-%02d-%02d ', $tm->year+1900, ($tm->mon+1), $tm->mday;
                   my $ltime = sprintf '%02d:%02d:%02d', $tm->hour,$tm->min, $tm->sec;
                   $cmd = '(./flamegraph.pl -title "' . $ldate . $ltime . '" temp/' . $newclfilenm . '> temp/' . $newfgfilenm . ')';
                   system ($cmd) == 0 or die "system $cmd failed: $?";

                   #
                   # Write the generated .svg file back to the invoking browser
                   #
                   open (FILE,'temp/' . $newfgfilenm)  or die "Can't open file $newfgfilenm: $!\n";
                   while ($l = <FILE>)
                   {
                       print($l);
                   }
                   close(FILE);

                   #
                   # Delete the local files
                   #
                   unlink 'temp/' . $newinfilenm;
                   unlink 'temp/' . $newclfilenm;
                   unlink 'temp/' . $newfgfilenm;
               }
           }
      }
}
