diff -rupN net-snmp-5.0.9-original/agent/Makefile.in net-snmp-5.0.9-patched/agent/Makefile.in
--- net-snmp-5.0.9-original/agent/Makefile.in	2003-05-08 07:06:08.000000000 -0700
+++ net-snmp-5.0.9-patched/agent/Makefile.in	2015-04-13 16:47:19.587645366 -0700
@@ -9,7 +9,7 @@ top_builddir	= ..
 #
 SUBDIRS=helpers mibgroup
 
-INSTALLSBINPROGS= snmpd$(EXEEXT)
+INSTALLSBINPROGS=libsnmpd.a libsnmpd.so
 INSTALLLIBS	= libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION) \
 		libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION)
 
@@ -67,7 +67,9 @@ WRAPLIBS	= @WRAPLIBS@
 OUR_AGENT_LIBS	= $(INSTALLLIBS) $(HELPERLIB) $(WRAPLIBS) $(LIBS) @DLLIBS@
 CPPFLAGS	= -I../include -I$(top_srcdir)/include \
 		  -I.. -I$(srcdir)/.. -I$(srcdir)/../snmplib \
-		  -I$(srcdir) -I. -I$(srcdir)/mibgroup -Imibgroup @CPPFLAGS@
+		  -I$(srcdir) -I. -I$(srcdir)/mibgroup -Imibgroup \
+		  -Imibgroup/ocmib -Imibgroup/ocmib/home_network -Imibgroup/ocmib/stb_host \
+		  @CPPFLAGS@
 
 #
 # Objects
@@ -113,9 +115,11 @@ getmibstat: getmibstat.o
 getmibstat.o: mibgroup/kernel_sunos5.c
 	$(CC) $(CFLAGS) -o $@ -D_GETMIBSTAT_TEST -DDODEBUG -c $? 
 
-snmpd$(EXEEXT):	${LAGENTOBJS} $(USELIBS) $(HELPERLIB) $(LIBTARG) ${INSTALLLIBS}
-	$(LINK) $(CFLAGS) -o $@ ${LAGENTOBJS} $(LOCAL_LIBS) ${LDFLAGS} ${OUR_AGENT_LIBS}
+libsnmpd.a:	${LAGENTOBJS} $(USELIBS) $(HELPERLIB) $(LIBTARG) ${INSTALLLIBS}
+	$(AR) -cvr libsnmpd.a ${AGENTOBJS}
 
+libsnmpd.so:	${LAGENTOBJS} $(USELIBS) $(HELPERLIB) $(LIBTARG) ${INSTALLLIBS}
+	$(CC) -shared -fPIC -o libsnmpd.so ${LAGENTOBJS} -lc
 
 libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION):    ${LLIBAGENTOBJS} libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION)
 	$(LIB_LD_CMD) libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION) ${LLIBAGENTOBJS}  $(LIB_LD_LIBS)
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/Makefile.in net-snmp-5.0.9-patched/agent/mibgroup/Makefile.in
--- net-snmp-5.0.9-original/agent/mibgroup/Makefile.in	2002-04-20 00:30:00.000000000 -0700
+++ net-snmp-5.0.9-patched/agent/mibgroup/Makefile.in	2015-03-20 11:55:17.580482541 -0700
@@ -2,7 +2,9 @@ top_builddir=../..
 
 CPPFLAGS=-I../../include -I$(top_srcdir)/include \
 	-I. -I../.. -I$(srcdir) -I$(srcdir)/../.. \
-	-I$(srcdir)/../../snmplib -I$(srcdir)/.. -I.. @CPPFLAGS@ $(LIB_CFLAGS)
+	-I$(srcdir)/../../snmplib -I$(srcdir)/.. -I.. \
+	-Iocmib/home_network -Iocmib -Iocmib/stb_host \
+	@CPPFLAGS@ $(LIB_CFLAGS)
 
 # Need a special .c -> .o definition here to make sure we place the
 # object files in the sub directory.
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,296 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+int B_SNMP_ProxyMibInit(void)
+{
+	mibObjects *pMibObj;
+	mibObjectIdentifier id;
+	int i;
+
+	for (id=ocStbHostNotifications; id<ocStbHostTotalMibOjects; id++)
+	{
+		pMibObj = &gMibObjs[id];
+
+		pMibObj->id = id;
+		pMibObj->opened = false;
+		pMibObj->registered = false;
+
+		switch (id)
+		{
+			case ocStbHostNotifications:
+				break;
+			case ocStbHostHWIdentifiers:
+				pMibObj->obj = malloc(sizeof(mibObjectHwIdentifiers));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectHwIdentifiers));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostAVInterfaceTable:
+				pMibObj->obj = NULL;
+				pMibObj->opened = true;
+				break;
+			case ocStbHostIEEE1394Table:
+				pMibObj->obj = malloc(sizeof(mibObjectIeee1394Table));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectIeee1394Table));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostIEEE1394ConnectedDevicesTable:
+				pMibObj->obj = malloc(sizeof(mibObjectIeee1394ConnectedDevicesTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectIeee1394ConnectedDevicesTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostDVIHDMITable:
+				pMibObj->obj = malloc(sizeof(mibObjectDviHdmiTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectDviHdmiTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostDVIHDMIAvailableVideoFormatTable:
+				pMibObj->obj = malloc(sizeof(mibObjectDviHdmiAvailableVideoFormatTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectDviHdmiAvailableVideoFormatTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostComponentVideoTable:
+				pMibObj->obj = malloc(sizeof(mibObjectComponentVideoTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectComponentVideoTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostRFChannelOutTable:
+				pMibObj->obj = malloc(sizeof(mibObjectRfChannelOutTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectRfChannelOutTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostInBandTunerTable:
+				pMibObj->obj = malloc(sizeof(mibObjectInBandTunerTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectInBandTunerTable));
+				for (i=0; i<NUM_INBAND_TUNERS; i++)
+				{
+					((mibObjectInBandTunerTable *) pMibObj->obj)->timebase[i] = NEXUS_Timebase_eInvalid;
+				}
+				pMibObj->opened = true;
+				break;
+			case ocStbHostProgramStatusTable:
+                pMibObj->obj = malloc(sizeof(mibObjectProgramStatusTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectProgramStatusTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostMpeg2ContentTable:
+                pMibObj->obj = malloc(sizeof(mibObjectMpeg2ContentTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectMpeg2ContentTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostAnalogVideoTable:
+	            pMibObj->obj = malloc(sizeof(mibObjectAnalogVideoTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectAnalogVideoTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostQpskObjects:
+				pMibObj->obj = malloc(sizeof(mibObjectQpskObjects));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectQpskObjects));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSPDIfTable:
+                pMibObj->obj = malloc(sizeof(mibObjectSPDIfTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSPDIfTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostEasCodes:
+				pMibObj->obj = malloc(sizeof(mibObjectEasCodes));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectEasCodes));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostDeviceSoftwareBase:
+				pMibObj->obj = malloc(sizeof(mibObjectDeviceSoftwareBase));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectDeviceSoftwareBase));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostFirmwareDownloadStatus:
+				pMibObj->obj = malloc(sizeof(mibObjectFwDownloadStatus));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectFwDownloadStatus));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSoftwareApplicationInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectSwAppInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSwAppInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSoftwareApplicationInfoTable:
+				pMibObj->obj = malloc(sizeof(mibObjectSwAppInfoTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSwAppInfoTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSecuritySubSystem:
+				pMibObj->obj = malloc(sizeof(mibObjectSecuritySubSystem));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSecuritySubSystem));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostPower:
+				pMibObj->obj = malloc(sizeof(mibObjectPower));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectPower));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostUserSettings:
+				pMibObj->obj = malloc(sizeof(mibObjectUserSettings));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectUserSettings));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSystemTempTable: /* Optional, NOT supported */
+				break;
+			case ocStbHostSystemHomeNetworkTable: /* Deprecated, NOT supported */
+				break;
+			case ocStbHostSystemMemoryReportTable:
+				pMibObj->obj = malloc(sizeof(mibObjectSystemMemoryReportTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSystemMemoryReportTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbCardInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectCardInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectCardInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostCardCpInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectCardCpInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectCardCpInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostCCAppInfoTable:
+				pMibObj->obj = malloc(sizeof(mibObjectCCAppInfoTable));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectCCAppInfoTable));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSnmpProxyInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectSnmpProxyInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSnmpProxyInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectHostInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectHostInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostSpecificationsInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectSpecInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectSpecInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostDumpTrapInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectDumpTrapInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectDumpTrapInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostContentErrorSummaryInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectContentErrorSummaryInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectContentErrorSummaryInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostRebootInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectRebootInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectRebootInfo));
+				pMibObj->opened = true;
+				break;
+			case ocStbHostMemoryInfo:
+				pMibObj->obj = NULL;
+				pMibObj->opened = true;
+				break;
+			case ocStbHostJVMInfo:
+				pMibObj->obj = malloc(sizeof(mibObjectJvmInfo));
+				if (!pMibObj->obj) goto malloc_err;
+				memset(pMibObj->obj, 0, sizeof(mibObjectJvmInfo));
+				pMibObj->opened = true;
+				break;
+			default:
+				break;
+		}
+	}
+
+	return 0;
+
+malloc_err:
+	BDBG_ERR(("Memory allocation error"));
+	return -1;
+}
+
+void B_SNMP_ProxyMibUninit(void)
+{
+	mibObjects *pMibObj;
+	mibObjectIdentifier id;
+
+	for (id=ocStbHostNotifications; id<ocStbHostTotalMibOjects; id++)
+	{
+		pMibObj = &gMibObjs[id];
+
+		if (pMibObj->opened)
+		{
+			pMibObj->opened = false;
+			pMibObj->registered = false;
+
+			if (pMibObj->obj)
+			{
+				free(pMibObj->obj);
+			}
+		}
+	}
+
+	return;
+}
+
+void B_SNMP_ProxyMibRegister(mibObjectIdentifier id)
+{
+	mibObjects *pMibObj = &gMibObjs[id];
+
+	if (pMibObj->opened && !pMibObj->registered)
+	{
+		pMibObj->registered = true;
+    }
+
+	return;
+}
+
+void B_SNMP_ProxyMibUnregister(mibObjectIdentifier id)
+{
+	mibObjects *pMibObj = &gMibObjs[id];
+
+	if (pMibObj->opened && pMibObj->registered)
+	{
+		pMibObj->registered = false;
+	}
+
+	return;
+}
+
+void B_SNMP_ProxyMibGetDefault(mibObjectIdentifier id, void **pObj)
+{
+	*pObj = gMibObjs[id].obj;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,1099 @@
+#ifndef SNMPPROXYIF_H
+#define SNMPPROXYIF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+
+
+#include "nexus_platform.h"
+#include "nexus_frontend.h"
+#include "nexus_hdmi_output.h"
+#include "nexus_hdmi_output_hdcp.h"
+#include "nexus_audio_decoder.h"
+#include "nexus_audio_output.h"
+#include "nexus_audio_types.h"
+#include "nexus_video_decoder.h"
+#include "nexus_video_decoder_types.h"
+#include "nexus_display.h"
+#include "nexus_display_types.h"
+#include "nexus_display_vbi.h"
+#if NEXUS_NUM_RFM_OUTPUTS
+#include "nexus_rfm.h"
+#endif
+#include "nexus_types.h"
+#include "nexus_memory.h"
+#include "nexus_timebase.h"
+#include "nexus_parser_band.h"
+#include "nexus_core_utils.h"
+
+#include "avInterfaceTable.h"
+
+#define NUM_IEEE1394_OUTPUTS 1
+#define NUM_INBAND_TUNERS (NEXUS_MAX_FRONTENDS-1)
+#define NUM_SW_APPS 4
+#define NUM_CCAPPINFO 10
+#define NUM_MEMORY_TYPE 3
+#define NUM_HDMI_AVAIL_VIDEO_FORMATS 64 /* could be up to 128 */
+
+#define DUMP_EVENT_COUNT 0
+#define DUMP_NOW 1
+#define DUMP_EVENT_TIMEOUT 2
+
+#define UNSUPPORTED_MIB 0xdeadbeef
+
+typedef enum
+{
+	/* OpenCable Host Device 2.X MIB Specification */
+	/* OC-SP-MIB-HOST2.X-I11-110204   */
+	/* Put all the OpenCable MIB here */
+    ocStbHostNotifications = 0,
+    ocStbHostHWIdentifiers,
+    ocStbHostAVInterfaceTable,
+    ocStbHostIEEE1394Table,
+    ocStbHostIEEE1394ConnectedDevicesTable,
+    ocStbHostDVIHDMITable,
+    ocStbHostDVIHDMIAvailableVideoFormatTable,
+    ocStbHostComponentVideoTable,
+    ocStbHostRFChannelOutTable,
+    ocStbHostInBandTunerTable,
+    ocStbHostProgramStatusTable,
+    ocStbHostMpeg2ContentTable,
+    ocStbHostAnalogVideoTable,
+    ocStbHostQpskObjects,
+    ocStbHostSPDIfTable,
+    ocStbHostEasCodes,
+    ocStbHostDeviceSoftwareBase,
+    ocStbHostFirmwareDownloadStatus,
+    ocStbHostSoftwareApplicationInfo,
+	ocStbHostSoftwareApplicationInfoTable,
+    ocStbHostSecuritySubSystem,
+    ocStbHostPower,
+    ocStbHostUserSettings,
+    ocStbHostSystemTempTable,
+    ocStbHostSystemHomeNetworkTable,
+    ocStbHostSystemMemoryReportTable,
+    ocStbCardInfo,
+    ocStbHostCardCpInfo,
+    ocStbHostCCAppInfoTable,
+    ocStbHostSnmpProxyInfo,
+    ocStbHostInfo,
+    ocStbHostSpecificationsInfo,
+    ocStbHostDumpTrapInfo,
+    ocStbHostContentErrorSummaryInfo,
+    ocStbHostRebootInfo,
+    ocStbHostMemoryInfo,
+    ocStbHostJVMInfo,
+
+	/* Put all other MIB below this line */
+
+	ocStbHostTotalMibOjects
+} mibObjectIdentifier;
+
+enum /* TruthValue */
+{
+	oc_true = 1,
+	oc_false
+};
+
+enum
+{
+	oc_enabled = 1,
+	oc_disabled
+};
+
+enum /* VideoOutputFormat */
+{
+	oc_videoOutputFormat_format480i = 1,
+	oc_videoOutputFormat_format480p,
+	oc_videoOutputFormat_format720p,
+	oc_videoOutputFormat_format1080i,
+	oc_videoOutputFormat_format1080p
+};
+
+enum /* AudioOutputFormat */
+{
+	oc_audioOutputFormat_other = 1,
+	oc_audioOutputFormat_lpcm, /* CD-A, DVD-A */
+	oc_audioOutputFormat_ac3, /* Dobly Digital */
+	oc_audioOutputFormat_eac3, /* Dobly Digital Plus */
+	oc_audioOutputFormat_mpeg1L1L2, /* MPEG-1 Layers 1 & 2 */
+	oc_audioOutputFormat_mpeg1L3, /* MPEG-1 Layer 3 */
+	oc_audioOutputFormat_mpeg2, /* Advanced Audio Coding (AAC-LC) */
+	oc_audioOutputFormat_mpeg4, /* MPEG-4 Advanced Audio Coding, High Efficiency (AAC Plus) */
+	oc_audioOutputFormat_dts, /* Digital Theater Sound */
+	oc_audioOutputFormat_atrac /* Adaptive Transform Acoustic Coding */
+};
+
+enum /* VideoAspectRatio */
+{
+	oc_videoAspectRatio_other = 1,
+	oc_videoAspectRatio_fourByThree,
+	oc_videoAspectRatio_sixteenByNine
+};
+
+enum /* hostCapabilities */
+{
+	oc_hostCapabilities_other = 1,
+	oc_hostCapabilities_ochd2,
+	oc_hostCapabilities_embedded,
+	oc_hostCapabilities_dcas,
+	oc_hostCapabilities_ochd21,
+	oc_hostCapabilities_bocr,
+	oc_hostCapabilities_ochdtc
+};
+
+enum /* 1394ConnectedDevicesSubUnitType */
+{
+	oc_1394ConnectedDevicesSubUnitType_monitor = 0,
+	oc_1394ConnectedDevicesSubUnitType_audio,
+	oc_1394ConnectedDevicesSubUnitType_printer,
+	oc_1394ConnectedDevicesSubUnitType_disc,
+	oc_1394ConnectedDevicesSubUnitType_tape,
+	oc_1394ConnectedDevicesSubUnitType_tuner,
+	oc_1394ConnectedDevicesSubUnitType_ca,
+	oc_1394ConnectedDevicesSubUnitType_camera,
+	oc_1394ConnectedDevicesSubUnitType_reserved,
+	oc_1394ConnectedDevicesSubUnitType_panel,
+	oc_1394ConnectedDevicesSubUnitType_other
+};
+
+enum /* OutputType */
+{
+	oc_outputType_dvi = 1,
+	oc_outputType_hdmi
+};
+
+enum /* hdcpStatus */
+{
+	oc_hdcpStatus_nonHDCPdevice = 1,
+	oc_hdcpStatus_compliantHDCPdevice,
+	oc_hdcpStatus_revokedHDCPdevice
+};
+
+enum /* AudioSampleRate */
+{
+	oc_audioSampleRate_other = 1,
+	oc_audioSampleRate_samplerate32kHz,
+	oc_audioSampleRate_samplerate44kHz,
+	oc_audioSampleRate_samplerate48kHz,
+	oc_audioSampleRate_samplerate88kHz,
+	oc_audioSampleRate_samplerate96kHz,
+	oc_audioSampleRate_samplerate176kHz,
+	oc_audioSampleRate_samplerate192kHz
+};
+
+enum /* AudioSampleSize */
+{
+	oc_audioSampleSize_notValid = 0,
+	oc_audioSampleSize_sample16Bit,
+	oc_audioSampleSize_sample20Bit,
+	oc_audioSampleSize_sample24Bit
+};
+
+enum /* ColorSpace */
+{
+	oc_colorSpace_rgb = 0,
+	oc_colorSpace_ycc422,
+	oc_colorSpace_ycc444
+};
+
+enum /* Frame Rates for HDMI outputs as defined in CCIF spec */
+{
+	oc_frameRateCode1 = 1, /* 23.976 Hz */
+	oc_frameRateCode2,	/* 24.0 Hz */
+	oc_frameRateCode3, /* 29.97 Hz */
+	oc_frameRateCode4,	/* 30.0 Hz */
+	oc_frameRateCode5, /* 59.94 Hz */
+	oc_frameRateCode6	 /* 60.0 Hz */
+};
+
+enum /* AttachedDeviceType */
+{
+	oc_attachedDeviceType_tv = 0,
+	oc_attachedDeviceType_recordingDevice,
+	oc_attachedDeviceType_tuner = 3,
+	oc_attachedDeviceType_playbackDevice,
+	oc_attachedDeviceType_audioSystem,
+	oc_attachedDeviceType_other
+};
+
+enum /* CecFeatures */
+{
+	oc_cecFeatures_oneTouchPlay = 0x0080,
+	oc_cecFeatures_systemStandby = 0x0040,
+	oc_cecFeatures_oneTouchRecord = 0x0020,
+	oc_cecFeatures_timerProgramming = 0x0010,
+	oc_cecFeatures_deckControl = 0x0008,
+	oc_cecFeatures_tunerControl = 0x0004,
+	oc_cecFeatures_deviceMenuControl = 0x0002,
+	oc_cecFeatures_remoteControlPassThrough = 0x0001,
+	oc_cecFeatures_systemAudioControl = 0x8000,
+	oc_cecFeatures_deviceOsdNameTransfer = 0x4000,
+	oc_cecFeatures_devicePowerStatus = 0x2000,
+	oc_cecFeatures_osdDisplay = 0x1000,
+	oc_cecFeatures_routingControl = 0x0800,
+	oc_cecFeatures_systemInformation = 0x0400,
+	oc_cecFeatures_vendorSpecificCommands = 0x0200,
+	oc_cecFeatures_audioRateControl = 0x0100
+};
+
+enum /* hdmiFeatures */
+{
+	oc_hdmiFeatures_deepColor = 0x80,
+	oc_hdmiFeatures_extendedColorGamut = 0x40,
+	oc_hdmiFeatures_oneBitAudio = 0x20,
+	oc_hdmiFeatures_lipSync = 0x10,
+	oc_hdmiFeatures_cec = 0x8
+};
+
+enum /* 3DCompatibilityControl */
+{
+	oc_3DCompatibilityControl_other = 0,
+	oc_3DCompatibilityControl_passthru3D,
+	oc_3DCompatibilityControl_block3D
+};
+
+enum /* Supported3DStructures */
+{
+	oc_supported3DStructures_framePacking = 0x0080,
+	oc_supported3DStructures_fieldAlternative = 0x0040,
+	oc_supported3DStructures_lineAlternative = 0x0020,
+	oc_supported3DStructures_sideBySideFull = 0x0010,
+	oc_supported3DStructures_leftPlusDepth = 0x0008,
+	oc_supported3DStructures_leftPlusDepthPlusGraphicsPlusGraphicsDepth = 0x0004,
+	oc_supported3DStructures_topAndBottom = 0x0002,
+	oc_supported3DStructures_sideBySideHalf = 0x0001,
+	oc_supported3DStructures_sideBySideHalfQuincunx = 0x8000
+};
+
+enum /* Active3DStructures */
+{
+	oc_active3DStructures_other = 0,
+	oc_active3DStructures_na,
+	oc_active3DStructures_framePacking,
+	oc_active3DStructures_fieldAlternative,
+	oc_active3DStructures_lineAlternative,
+	oc_active3DStructures_sideBySideFull,
+	oc_active3DStructures_leftPlusDepth,
+	oc_active3DStructures_leftPlusDepthPlusGraphicsPlusGraphicsDepth,
+	oc_active3DStructures_topAndBottom,
+	oc_active3DStructures_sideBySideHalf,
+	oc_active3DStructures_sideBySideHalfQuincunx,
+	oc_active3DStructures_noAdditionalHDMIInfo = 17,
+	oc_active3DStructures_no3DInforamtion,
+	oc_active3DStructures_infoFrameNotAvailable
+};
+
+enum /* TunerModulationMode */
+{
+	oc_tunerModulationMode_other = 1,
+	oc_tunerModulationMode_analog,
+	oc_tunerModulationMode_qam64,
+	oc_tunerModulationMode_qam256
+};
+
+enum /* TunerInterleaver */
+{
+	oc_tunerInterleaver_unknown = 1,
+	oc_tunerInterleaver_other,
+	oc_tunerInterleaver_taps64Increment2,
+	oc_tunerInterleaver_taps128Increment1,
+	oc_tunerInterleaver_taps128Increment2,
+	oc_tunerInterleaver_taps128Increment3,
+	oc_tunerInterleaver_taps128Increment4,
+	oc_tunerInterleaver_taps32Increment4,
+	oc_tunerInterleaver_taps16Increment8,
+	oc_tunerInterleaver_taps8Increment16
+};
+
+enum /* TunerState */
+{
+	oc_tunerState_ready = 1,
+	oc_tunerState_waitingSync,
+	oc_tunerState_waitingQam,
+	oc_tunerState_foundSync,
+	oc_tunerState_foundQam,
+	oc_tunerState_unknown,
+	oc_tunerState_standby
+};
+
+enum /*TunerBER */
+{
+	oc_berGreaterThan10e2 = 1,
+	oc_berRange10e2ToGreaterThan10e4,
+	oc_berRange10e4ToGreaterThan10e6,
+	oc_berRange10e6ToGreaterThan10e8,
+	oc_berRange10e8ToGreaterThan10e10,
+	oc_berEqualToOrLessThan10e12,
+	oc_berNotApplicable
+};
+
+enum /* TunerBandwidth */
+{
+	oc_tunerBandwidth_other = 1,
+	oc_tunerBandwidth_mHz864,
+	oc_tunerBandwidth_mHz1002
+};
+
+enum /* qpskFDCLockStatus */
+{
+	oc_qpskFDCLockStatus_notLocked = 1,
+	oc_qpskFDCLockStatus_locked
+};
+
+enum /* qpskRDCDataRate */
+{
+	oc_qpskRDCDataRate_kbps256 = 1,
+	oc_qpskRDCDataRate_kbps1544,
+	oc_qpskRDCDataRate_kbps3088
+};
+
+enum /* imageStatus */
+{
+	oc_imageStatus_imageAuthorized = 1,
+	oc_imageStatus_imageCorrupted,
+	oc_imageStatus_imageCertFailure,
+	oc_imageStatus_imageMaxDownloadRetry,
+	oc_imageStatus_imageMaxRebootRetry
+};
+
+enum /* codeDownloadStatus */
+{
+	oc_codeDownloadStatus_dowloadingStarted = 1,
+	oc_codeDownloadStatus_dowloadingComplete,
+	oc_codeDownloadStatus_dowloadingFailed,
+	oc_codeDownloadStatus_other
+};
+
+enum /* downloadFailedStatus */
+{
+	oc_downloadFailedStatus_cdlError1 = 1,
+	oc_downloadFailedStatus_cdlError2,
+	oc_downloadFailedStatus_cdlError3,
+	oc_downloadFailedStatus_cdlError4,
+	oc_downloadFailedStatus_cdlError5,
+	oc_downloadFailedStatus_cdlError6,
+	oc_downloadFailedStatus_cdlError7,
+	oc_downloadFailedStatus_cdlError8,
+	oc_downloadFailedStatus_cdlError9,
+	oc_downloadFailedStatus_cdlError10,
+	oc_downloadFailedStatus_cdlError11,
+	oc_downloadFailedStatus_cdlError12,
+	oc_downloadFailedStatus_cdlError13,
+	oc_downloadFailedStatus_cdlError14,
+	oc_downloadFailedStatus_cdlError15,
+	oc_downloadFailedStatus_cdlError16,
+	oc_downloadFailedStatus_cdlError17,
+	oc_downloadFailedStatus_cdlError18,
+	oc_downloadFailedStatus_cdlError19,
+	oc_downloadFailedStatus_cdlError20,
+	oc_downloadFailedStatus_cdlError21,
+	oc_downloadFailedStatus_cdlError22,
+	oc_downloadFailedStatus_cdlError23,
+	oc_downloadFailedStatus_cdlError24,
+	oc_downloadFailedStatus_cdlError25
+};
+
+enum /* swStatus */
+{
+	oc_swStatus_loaded = 4,
+	oc_swStatus_notLoaded,
+	oc_swStatus_paused,
+	oc_swStatus_running,
+	oc_swStatus_destroyed
+};
+
+enum /* sigStatus */
+{
+	oc_sigStatus_other = 0,
+	oc_sigStatus_okay,
+	oc_sigStatus_error
+};
+
+enum /* sigLastReadStatus */
+{
+	oc_sigLastReadStatus_unknown = 0,
+	oc_sigLastReadStatus_okay,
+	oc_sigLastReadStatus_error
+};
+
+enum /* PowerStatus */
+{
+	oc_powerStatus_powerOn = 1,
+	oc_powerStatus_standby
+};
+
+enum /* MemoryType */
+{
+	oc_memoryType_rom = 1,
+	oc_memoryType_dram = 2,
+	oc_memoryType_sram = 3,
+	oc_memoryType_flash = 4,
+	oc_memoryType_nvm = 5,
+	oc_memoryType_videomemory = 7,
+	oc_memoryType_othermemory = 8,
+	oc_memoryType_reserved = 9,
+	oc_memoryType_internalHardDrive = 10,
+	oc_memoryType_externalHardDrive = 11,
+	oc_memoryType_opticalMedia = 12
+};
+
+enum /* bootStatus */
+{
+	oc_bootStatus_completedSuccessfully = 1,
+	oc_bootStatus_completeWithErrors,
+	oc_bootStatus_inProgressWithCodeDownload,
+	oc_bootStatus_inProgressNoCodeDownload,
+	oc_bootStatus_inProgressAwaitingNonitorApp,
+	oc_bootStatus_unknown
+};
+
+enum /* RebootType */
+{
+	oc_rebootType_unknown = 0,
+	oc_rebootType_davicDocsis,
+	oc_rebootType_user,
+	oc_rebootType_system,
+	oc_rebootType_trap,
+	oc_rebootType_silentWatchdog,
+	oc_rebootType_bootloader,
+	oc_rebootType_powerup,
+	oc_rebootType_hostUpgrade,
+	oc_rebootType_hardware,
+	oc_rebootType_cablecardError
+};
+
+enum /* Host CA Type */
+{
+	oc_hostSecurityType_other = 1,
+	oc_hostSecurityType_embedded,
+	oc_hostSecurityType_cablecard,
+	oc_hostSecurityType_dcas
+};
+
+enum /* Host OOB Mesage Type */
+{
+	oc_hostOOBType_scte55 = 1,
+	oc_hostOOBType_dsg,
+	oc_hostOOBType_other
+};
+
+enum /* Host Card Binding Status */
+{
+	oc_cardBinding_unknown = 1,
+	oc_cardBinding_invalidCertificate,
+	oc_cardBinding_otherAuthFailure,
+	oc_cardBinding_bound
+};
+
+enum /* Host Card CP Authentication Key Status */
+{
+	oc_cardCpAuthKeyStatus_ready = 1,
+	oc_cardCpAuthKeyStatus_notReady
+};
+
+enum /* Host Card CP Certification Check */
+{
+	oc_cardCpCertCheck_ok = 1,
+	oc_cardCpCertCheck_failed
+};
+
+enum /* InetAddress Type*/
+{
+ 	oc_inetAddrType_unknown = 0,
+	oc_inetAddrType_ipv4 = 1,
+	oc_inetAddrType_ipv6 = 2,
+	oc_inetAddrType_ipv4z = 3,
+	oc_inetAddrType_ipv6z = 4,
+	oc_inetAddrType_dns = 16
+};
+
+typedef enum
+{
+	oc_Mpeg2ContentTable_cciCopyFreely = 0,
+	oc_Mpeg2ContentTable_cciCopyNoMore,
+	oc_Mpeg2ContentTable_cciCopyOneGeneration,
+	oc_Mpeg2ContentTable_cciCopyNever,
+	oc_Mpeg2ContentTable_cciNotDefined
+} Mpeg2ContentTable_cciValue;
+
+typedef enum
+{
+	oc_Mpeg2ContentTable_apsType1 = 1, /* AGC on, split burst off */
+	oc_Mpeg2ContentTable_apsType2,     /* AGC on, 2-line split burst */
+	oc_Mpeg2ContentTable_apsType3,     /* AGC on, 4-line split burst */
+	oc_Mpeg2ContentTable_apsNone,
+	oc_Mpeg2ContentTable_apsNotDefined
+} Mpeg2ContentTable_apsValue;
+
+typedef enum
+{
+	oc_Mpeg2ContentTable_UnLocked = 1,
+	oc_Mpeg2ContentTable_Locked
+} Mpeg2ContentTable_pcrLockStatus;
+
+
+typedef struct
+{
+	char serialNumber[256]; /* SnmpAdminString (SIZE (0..255)), must be NULL terminated */
+	char hostId[18];  /* DisplayString (SIZE(17)), must be NULL terminated */
+	int capabilities; /* INTEGER */
+	int avcSupport;	/* TruthValue */
+} containerHwIdentifiers;
+
+typedef struct
+{
+	int activeNodes; /* Integer32 (-1|0..64) */
+	bool dataXMission; /* TruthValue */
+	bool dtcpStatus; /* TruthValue */
+	bool loopStatus; /* TruthValue */
+	bool rootStatus; /* TruthValue */
+	bool cycleIsMaster; /* TruthValue */
+	bool irmStatus; /* TruthValue */
+	bool audioMuteStatus; /* TruthValue */
+	bool videoMuteStatus; /* TruthValue */
+} containerIeee1394Table;
+
+typedef struct
+{
+	int subUnitType; /* INTEGER */
+	unsigned char eui64[8]; /* OCTET STRING (SIZE(8)) */
+	bool analogDigitalSourceSelection; /* TruthValue */
+} containerIeee1394ConnectedDevicesTable;
+
+typedef struct
+{
+	bool hdmiDevice; /* for OutputType, True if HDMI, false if DVI */
+	bool connectionStatus; /* TruthValue */
+	bool repeaterStatus; /* TruthValue */
+	bool videoXMissionStatus; /* TruthValue */
+	bool hdcpStatus; /* TruthValue */
+	bool videoMuteStatus; /* TruthValue */
+	NEXUS_VideoFormat outputFormat; /* VideoOutputFormat */
+	NEXUS_AspectRatio aspectRatio; /* VideoAspectRatio */
+	bool hostDeviceHdcpStatus; /* INTEGER */
+	NEXUS_AudioCodec audioFormat; /* AudioOutputFormat */
+	unsigned audioSampleRate; /* INTEGER */
+	unsigned audioChannelCount; /* Unsigned32 (0..10) */
+	bool audioMuteStatus; /* TruthValue */
+	unsigned audioSampleSize; /* INTEGER */
+	NEXUS_ColorSpace colorSpace; /* INTEGER */
+	NEXUS_VideoFrameRate frameRate; /* INTEGER */
+	int attachedDeviceType; /* INTEGER */
+	unsigned char edid[128]; /* OCTET STRING */
+	unsigned lipSyncDelay; /* Integer32 */
+	short cecFeatures; /* BITS */
+	char features; /* BITS */
+	unsigned maxDeviceCount; /* Integer32 */
+	unsigned preferredVideoFormat; /* INTEGER (0..127), CEA-861 Video Identification Code (VIC) */
+	char edidVersion[6]; /* SnmpAdminString */
+	int threeDCompatibilityControl; /* INTEGER */
+	bool threeDCompatibilityMsgDisplay; /* TruthValue */
+} containerDviHdmiTable;
+
+typedef struct
+{
+	unsigned numSupportedVideoDescriptors;
+	unsigned availableVideoFormat; /* INTEGER (0..127), CEA-861 Video Identification Code (VIC) */
+	short supported3DStructures; /* BITS */
+	int active3DStructure; /* INTEGER */
+} containerDviHdmiAvailableVideoFormatTable;
+
+typedef struct
+{
+	bool constrainedStatus; /* TruthValue */
+	NEXUS_VideoFormat outputFormat; /* VideoOutputFormat */
+	NEXUS_DisplayAspectRatio aspectRatio; /* VideoAspectRatio */
+	bool videoMuteStatus; /* TruthValue */
+} containerComponentVideoTable;
+
+typedef struct
+{
+	int channelOut; /* Unsigned32 (3..99) */
+	bool audioMuteStatus; /* TruthValue */
+	bool videoMuteStatus; /* TruthValue */
+} containerRfChannelOutTable;
+
+typedef enum
+{
+	tuner_idle,
+	tuner_tuning,
+	tuner_locked,
+	tuner_failed
+} tunerState;
+
+typedef struct
+{
+	NEXUS_FrontendQamMode modulationMode; /* INTEGER */
+	unsigned frequency; /* Unsigned32 */
+	int interleaver; /* INTEGER */
+	int tunerPower; /* TenthdBmV */
+	unsigned agcValue; /* Unsigned32 (0..100) */
+	unsigned snrValue; /* TenthdB */
+	unsigned unerroreds; /* Counter32 */
+	unsigned correcteds; /* Counter32 */
+	unsigned uncorrectables; /* Counter32 */
+	unsigned carrierLockLost; /* Counter32 */
+	unsigned pcrErrors; /* Counter32 */
+	unsigned ptsErrors; /* Counter32 */
+	tunerState state; /* INTEGER */
+	int ber; /* INTEGER */
+	unsigned secSinceLock; /* Unsigned32 */
+	unsigned eqGain; /* Integer32 */
+	unsigned mainTap; /* INTEGER (1..32767) */
+	unsigned totalTuneCount; /* Counter32 */
+	unsigned tuneFailureCount; /* Counter32 */
+	unsigned tuneFailFreq; /* Counter32 */
+	unsigned bandwidth; /* INTEGER */
+} containerInBandTunerTable;
+
+typedef struct
+{
+    int programNumber; /* Unsigned32 */
+    int transportStreamId; /* Unsigned32 */
+    int totalStreams; /* Unsigned32 */
+    int selectedVideoPid; /* Integer32 (-1|1..8191) */
+    int selectedAudioPid; /* Integer32 (-1|1..8191) */
+    bool otherAudioPids; /* TruthValue */
+    int cciValue; /* INTEGER */
+    int apsValue; /* INTEGER */
+    bool citStatus; /* TruthValue */
+    bool broadcastFlagStatus; /* TruthValue */
+    bool epnStatus; /* TruthValue */
+    int pcrPid; /* Integer32 (-1|1..8191) */
+    int pcrLockStatus; /* INTEGER */
+    unsigned int decoderPts; /* Integer32 */
+    int discontinuities; /* Integer32 */
+    int pktErrors; /* Counter32 */
+    int pipelineErrors; /* Counter32 */
+    int decoderRestarts; /* Counter32 */
+} containerMpeg2ContentTable;
+
+typedef struct
+{
+   int avSource; /* RowPointer */
+   int avDestination; /* RowPointer */
+   int contentSource; /* RowPointer */
+   int contentDestination; /* RowPointer */
+}containerProgramStatusTable;
+
+typedef struct
+{
+	avIfTypes avIfType;
+	int avIfInterfaceIndex;
+	int potectionStatus; /* INTEGER */
+} containerAnalogVideoTable;
+
+typedef struct
+{
+	unsigned fdcFreq; /* Unsigned32 */
+	unsigned rdcFreq; /* Unsigned32 */
+	int fdcBer; /* INTEGER */
+	tunerState state; /* INTEGER */
+	unsigned fdcBytesRead; /* Unsigned32 */
+	int fdcPower; /* TenthdBmV */
+	unsigned lockedTime; /* Unsigned32 */
+	int fdcSNR; /* TenthdB */
+	unsigned agc; /* Unsigned32 */
+	unsigned rdcPower; /* TenthdBmV */
+	unsigned rdcDataRate; /* INTEGER */
+} containerQpskObjects;
+
+typedef struct
+{
+	NEXUS_AudioCodec audioFormat; /* AudioOutputFormat */
+    int muteStatus; /* TruthValue */
+} containerSPDIfTable;
+
+typedef struct
+{
+	int stateCode; /* Unsigned32 (0..99) */
+	int countyCode; /* Unsigned32 (0..99) */
+	int subDivisionCode; /* Unsigned32 (0..99) */
+} containerEasCodes;
+
+typedef struct
+{
+	char firmwareVersion[256]; /* SnmpAdminString */
+	char OCAPVersion[256]; /* SnmpAdminString */
+	char releaseDate[8]; /* DateAndTime */
+} containerDeviceSoftwareBase;
+
+typedef struct
+{
+	int imageStatus; /* INTEGER */
+	int codeDownloadStatus; /* INTEGER */
+	char name[256]; /* SnmpAdminString */
+	int downloadFailedStatus; /* INTEGER */
+	int downloadFailedCount; /* Counter32 */
+	int downloadGroupId; /* Unsigned32 (0..65535) */
+} containerFwDownloadStatus;
+
+typedef struct
+{
+	char sigLastReceivedTime[8]; /* DateAndTime */
+	int sigLastReadStatus; /* INTEGER */
+	int sigLastNetworkVersionRead; /* Integer32 */
+	int sigVersionInUse; /* Integer32 */
+} containerSwAppInfo;
+
+typedef struct
+{
+	char name[256]; /* SnmpAdminString */
+	char version[32]; /* SnmpAdminString */
+	unsigned char orgId[4]; /* OCTET STRING (SIZE(4)) */
+	unsigned char appId[2]; /* OCTET STRING (SIZE(2)) */
+} containerSwAppInfoTable;
+
+typedef struct
+{
+	char caId[256]; /* SnmpAdminString */
+	int caType; /* INTEGER */
+} containerSecuritySubSystem;
+
+typedef struct
+{
+	int powerStatus; /* INTEGER */
+} containerPower;
+
+typedef struct
+{
+	char preferredLanguage[4];  /* DisplayString (SIZE(3)), must be NULL terminated */
+} containerUserSettings;
+
+typedef struct
+{
+	int memoryType; /* INTEGER */
+	int memorySize; /* Integer32 */
+} containerSystemMemoryReportTable;
+
+typedef struct
+{
+	char macAddr[6]; /* MacAddress */
+	int ipType; /* InetAddressType */
+	char ipAddr[16]; /* InetAddress */
+	char cardId[18];  /* DisplayString (SIZE(17)), must be NULL terminated */
+	int cardBindingStatus; /* INTEGER */
+	unsigned char opendGenericResource[4]; /* OCTET STRING (SIZE(4)) */
+	int timeZoneOffset; /* INTEGER (-12..12) */
+	unsigned char daylightSavingsTimeDelta; /* OCTET STRING (SIZE(1)) */
+	unsigned daylightSavingsTimeEntry; /* Unsigned32 */
+	unsigned daylightSavingsTimeExit; /* Unsigned32 */
+	unsigned char eaLocationCode[3]; /* OCTET STRING (SIZE(3)) */
+	unsigned char vctId[2]; /* OCTET STRING (SIZE(2)) */
+} containerCardInfo;
+
+typedef struct
+{
+	unsigned authKeyStatus; /* INTEGER */
+	unsigned certCheck; /* INTEGER */
+	unsigned cciCount; /* Counter32 */
+	unsigned keyGenReqCount; /* Counter32 */
+	unsigned char idList[4]; /* OCTET STRING (SIZE(4)) */
+} containerCardCpInfo;
+
+typedef struct
+{
+	int appInfoIndex; /* Unsigned32 */
+	int appType; /* Unsigned32 (0..4294967295) */
+	char appName[256];  /* SnmpAdminString */
+	int appVersion; /* Unsigned32 */
+	char *appInfoPage; /* OCTET STRING */
+	int appInfoLen;
+} containerCCAppInfoTable;
+
+typedef struct
+{
+	unsigned char cardMfgId[2]; /* OCTET STRING (SIZE(2)) */
+	unsigned char cardVersion[2]; /* OCTET STRING (SIZE(2)) */
+	oid cardRootOid[MAX_OID_LEN]; /* OBJECT IDENTIFIER */
+	unsigned int rootOidLen;
+	char cardSerialNum[256]; /* SnmpAdminString (SIZE (0..255)), must be NULL terminated */
+	bool discardCardSnmpAccessControl; /* TruthValue */
+} containerSnmpProxyInfo;
+
+typedef struct
+{
+	int ipType; /* InetAddressType */
+	char subNetMask[16]; /* InetAddress */
+	int oobMessageMode; /* INTEGER */
+	int bootStatus; /* INTEGER */
+} containerHostInfo;
+
+typedef struct
+{
+	int dumpEventCount; /* INTEGER (0..32) */
+	bool dumpNow; /* TruthValue */
+	unsigned dumpEventTimeout; /* Unsigned32 (1..120) */
+	char dumpFilePath[256];  /* SnmpAdminString */
+} containerDumpTrapInfo;
+
+typedef struct
+{
+	char cfrSpecIssue[64];   /* SnmpAdminString */
+	char mibSpecIssue[64];   /* SnmpAdminString */
+} containerSpecInfo;
+
+typedef struct
+{
+	unsigned patTimeoutCount; /* Counter32 */
+	unsigned pmtTimeoutCount; /* Counter32 */
+	unsigned oobCarouselTimeoutCount; /* Counter32 */
+	unsigned inbandCarouselTimeoutCount; /* Counter32 */
+} containerContentErrorSummaryInfo;
+
+typedef struct
+{
+	unsigned rebootType; /* INTEGER */
+} containerRebootInfo;
+
+typedef struct
+{
+	int heapSize; /* Integer32 */
+	int availHeap; /* Integer32 */
+	int liveObjects; /* Integer32 */
+	int deadObjects; /* Integer32 */
+} containerJvmInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerHwIdentifiers container;
+} mibObjectHwIdentifiers;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerIeee1394Table *pContainer[NUM_IEEE1394_OUTPUTS];
+} mibObjectIeee1394Table;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerIeee1394ConnectedDevicesTable *pContainer[NUM_IEEE1394_OUTPUTS];
+} mibObjectIeee1394ConnectedDevicesTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+#if NEXUS_NUM_HDMI_OUTPUTS
+	containerDviHdmiTable *pContainer[NEXUS_NUM_HDMI_OUTPUTS];
+	NEXUS_VideoDecoderHandle videoDecoder[NEXUS_NUM_HDMI_OUTPUTS];
+	NEXUS_AudioDecoderHandle audioDecoder[NEXUS_NUM_HDMI_OUTPUTS];
+	NEXUS_DisplayHandle display[NEXUS_NUM_HDMI_OUTPUTS];
+#endif
+} mibObjectDviHdmiTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerDviHdmiAvailableVideoFormatTable *pContainer[NUM_HDMI_AVAIL_VIDEO_FORMATS];
+} mibObjectDviHdmiAvailableVideoFormatTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+#if NEXUS_NUM_COMPONENT_OUTPUTS
+	containerComponentVideoTable *pContainer[NEXUS_NUM_COMPONENT_OUTPUTS];
+	NEXUS_DisplayHandle display[NEXUS_NUM_COMPONENT_OUTPUTS];
+#endif
+} mibObjectComponentVideoTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+#if NEXUS_NUM_RFM_OUTPUTS
+	containerRfChannelOutTable *pContainer[NEXUS_NUM_RFM_OUTPUTS];
+#endif
+} mibObjectRfChannelOutTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerInBandTunerTable *pContainer[NUM_INBAND_TUNERS];
+	NEXUS_Timebase timebase[NUM_INBAND_TUNERS];
+	NEXUS_VideoDecoderHandle videoDecoder[NUM_INBAND_TUNERS];
+	NEXUS_AudioDecoderHandle audioDecoder[NUM_INBAND_TUNERS];
+	NEXUS_FrontendHandle tuner[NUM_INBAND_TUNERS];
+	NEXUS_FrontendQamAnnex annex;
+	bool qam;
+	bool analog;
+} mibObjectInBandTunerTable;
+
+typedef struct
+{
+   	NEXUS_ParserBand  parser_band[NEXUS_NUM_VIDEO_DECODERS];
+	NEXUS_VideoDecoderHandle video_decode[NEXUS_NUM_VIDEO_DECODERS];
+	NEXUS_Timebase timebase[NEXUS_NUM_VIDEO_DECODERS];
+	containerMpeg2ContentTable *pContainer[NEXUS_NUM_VIDEO_DECODERS];
+    NEXUS_Callback callback;
+} mibObjectMpeg2ContentTable;
+
+
+typedef struct
+{
+  int decode_index;
+  NEXUS_Callback callback;
+}mibObjectProgramStatusTable;
+
+typedef struct
+{
+	/* spothana : Hardcoding the number of displays supported on a BCM97456 to 3. This value
+	* should be coming from VDC MAX DISPLAYS supported.
+	*/
+    NEXUS_Callback callback;
+	NEXUS_DisplayHandle display[3];
+	containerAnalogVideoTable *pContainer[NEXUS_NUM_SVIDEO_OUTPUTS + NEXUS_NUM_COMPOSITE_OUTPUTS + NEXUS_NUM_COMPONENT_OUTPUTS]; /* cache the results from the callback */
+} mibObjectAnalogVideoTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerQpskObjects container;
+	NEXUS_FrontendHandle oobTuner;
+	NEXUS_FrontendHandle upstreamTuner;
+} mibObjectQpskObjects;
+
+typedef struct
+{
+#if NEXUS_NUM_SPDIF_OUTPUTS
+	NEXUS_AudioOutput audio_output[NEXUS_NUM_SPDIF_OUTPUTS];
+	containerSPDIfTable *pContainer[NEXUS_NUM_SPDIF_OUTPUTS];
+#endif
+    NEXUS_Callback callback;
+} mibObjectSPDIfTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerEasCodes container;
+} mibObjectEasCodes;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerDeviceSoftwareBase container;
+} mibObjectDeviceSoftwareBase;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerFwDownloadStatus container;
+} mibObjectFwDownloadStatus;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerSwAppInfo container;
+} mibObjectSwAppInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerSwAppInfoTable *pContainer[NUM_SW_APPS];
+} mibObjectSwAppInfoTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerSecuritySubSystem container;
+} mibObjectSecuritySubSystem;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerPower container;
+} mibObjectPower;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerUserSettings container;
+} mibObjectUserSettings;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerSystemMemoryReportTable *pContainer[NUM_MEMORY_TYPE];
+} mibObjectSystemMemoryReportTable;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerCardInfo container;
+} mibObjectCardInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerCardCpInfo container;
+} mibObjectCardCpInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerCCAppInfoTable *pContainer[NUM_CCAPPINFO]; /* cache the results from the callback */
+} mibObjectCCAppInfoTable;
+
+typedef struct
+{
+	NEXUS_Callback get_callback;
+	NEXUS_Callback set_callback;
+	containerSnmpProxyInfo container;
+} mibObjectSnmpProxyInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerHostInfo container;
+} mibObjectHostInfo;
+
+typedef struct
+{
+	NEXUS_Callback get_callback;
+	NEXUS_Callback set_callback;
+	containerDumpTrapInfo container;
+} mibObjectDumpTrapInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerSpecInfo container;
+} mibObjectSpecInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerContentErrorSummaryInfo container;
+} mibObjectContentErrorSummaryInfo;
+
+typedef struct
+{
+	containerRebootInfo container;
+	NEXUS_Callback get_callback;
+	NEXUS_Callback set_callback;
+} mibObjectRebootInfo;
+
+typedef struct
+{
+	NEXUS_Callback callback;
+	containerJvmInfo container;
+} mibObjectJvmInfo;
+
+
+/* -= SNMP Proxy Interfaces */
+int B_SNMP_ProxyMibInit(void);
+void B_SNMP_ProxyMibUninit(void);
+void B_SNMP_ProxyMibRegister(mibObjectIdentifier id);
+void B_SNMP_ProxyMibUnregister(mibObjectIdentifier id);
+void B_SNMP_ProxyMibGetDefault(mibObjectIdentifier id, void **pObj);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SNMPPROXYIF_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf_priv.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf_priv.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/snmpProxyIf_priv.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/snmpProxyIf_priv.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,26 @@
+#ifndef SNMPPROXYIF_PRIV_H
+#define SNMPPROXYIF_PRIV_H
+
+#include "bdbg.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/times.h>
+#include <sys/types.h>
+#include <dirent.h>
+
+#define ELAPSED_TIME 200 /* 2 seconds, in unit of 10ms */
+
+typedef struct
+{
+	mibObjectIdentifier id;
+	bool opened;
+    bool registered;
+	void *obj;
+} mibObjects;
+
+mibObjects gMibObjs[ocStbHostTotalMibOjects];
+
+#endif /* SNMPPROXYIF_PRIV_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/analogVideoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/analogVideoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/analogVideoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/analogVideoTable.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,83 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "analogVideoTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+static struct analogVideoData analogVideoTblData[SNMP_ANALOG_NUM_OUTPUTS];
+static struct analogVideoEntry analogVideoList[SNMP_ANALOG_NUM_OUTPUTS];
+
+void
+activateAnalogVideo (void) 
+{
+	struct analogVideoEntry *tmpEntry;
+	NEXUS_PlatformConfiguration configuration;
+	int i, AVInterfaceIndex[SNMP_ANALOG_NUM_OUTPUTS];
+
+	/*
+	* Assuming that AV interface table is ready to be ready.
+	* Check the sequence of MIB initialization to ensure that AV interface init 
+	* is done before the Analog interface MIB init.
+	*/
+
+	i=0;
+#if NEXUS_NUM_COMPONENT_OUTPUTS
+	checkAVInterfaceExistence(ocStbHostComponentOut,&AVInterfaceIndex[i]);
+	while(i < NEXUS_NUM_COMPONENT_OUTPUTS)
+	{
+		analogVideoTblData[i].index = i;
+		analogVideoTblData[i].container.avIfType = ocStbHostComponentOut;
+		analogVideoTblData[i].container.avIfInterfaceIndex =  AVInterfaceIndex[i];
+		i++;
+	}
+#endif
+
+#if NEXUS_NUM_COMPOSITE_OUTPUTS
+	checkAVInterfaceExistence(ocStbHostBbVideoOut,&AVInterfaceIndex[i]);
+	while(i < NEXUS_NUM_COMPONENT_OUTPUTS + NEXUS_NUM_COMPOSITE_OUTPUTS )
+	{
+		analogVideoTblData[i].index = i;    
+		analogVideoTblData[i].container.avIfType = ocStbHostBbVideoOut;
+		analogVideoTblData[i].container.avIfInterfaceIndex =  AVInterfaceIndex[i];
+		i++;
+	}
+#endif
+
+#if NEXUS_NUM_SVIDEO_OUTPUTS
+	checkAVInterfaceExistence(ocStbHostSVideoOut,&AVInterfaceIndex[i]);
+	while (i< SNMP_ANALOG_NUM_OUTPUTS) 
+	{
+		analogVideoTblData[i].index = i;
+		analogVideoTblData[i].container.avIfType = ocStbHostSVideoOut;
+		analogVideoTblData[i].container.avIfInterfaceIndex =  AVInterfaceIndex[i];
+		i++;
+	}
+#endif
+	  
+	for (i=0; i<SNMP_ANALOG_NUM_OUTPUTS; i++)
+	{
+		tmpEntry = &analogVideoList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &analogVideoTblData[i];
+	}
+
+	return;
+}
+
+struct analogVideoEntry *
+getAnalogVideoEntry(int index) 
+{
+	struct analogVideoEntry *foundEntry =NULL;
+
+	if (index >=0 && index < SNMP_ANALOG_NUM_OUTPUTS) 
+	{
+		foundEntry=  &analogVideoList[index];
+	}
+	else
+	{
+		BDBG_WRN(("Could not find the entry"));
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/analogVideoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/analogVideoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/analogVideoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/analogVideoTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,38 @@
+#ifndef ANALOGVIDEOTABLE_H
+#define ANALOGVIDEOTABLE_H
+
+/* These are the data structures for analogVideo info.  */
+#include "avInterfaceTable.h"
+struct analogVideoData
+{
+	int index ;
+    containerAnalogVideoTable container;
+};
+
+struct analogVideoEntry
+{
+	int index;
+	struct analogVideoData *data;
+};
+
+void
+activateAnalogVideo (void);
+
+struct analogVideoEntry *
+getAnalogVideoEntry(int index);
+
+/*
+ * Broadcom created virtual objects called Display and each display object can drive 
+ * multiple display outputs. Typically, Broadcom defined virtual objects are classified 
+ * into 3 categories -
+ * 1. HD Display -> Drives HDMI output + Component outputs.
+ * 2. SD Display -> Drives Composite + RF Outputs.
+ * 3. SVideo Display -> Drives SVideo output
+ * 
+ * Analog protection is applicable to Component, Composite and SVideo outputs.
+ * So for Broadcom STB platforms only analog outputs that require analog protection are Component, Composite and SVideo.   
+ */
+
+#define SNMP_ANALOG_NUM_OUTPUTS  (NEXUS_NUM_COMPOSITE_OUTPUTS + NEXUS_NUM_COMPONENT_OUTPUTS + NEXUS_NUM_SVIDEO_OUTPUTS)
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/avInterfaceTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/avInterfaceTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/avInterfaceTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/avInterfaceTable.c	2015-04-13 16:46:26.850449784 -0700
@@ -0,0 +1,240 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+static struct AVInterfaceData avIfTblData[TOTAL_PLATFORM_INTERFACES];
+static struct AVInterfaceEntry avIfList[TOTAL_PLATFORM_INTERFACES];
+static unsigned avIfTotalEntry = TOTAL_PLATFORM_INTERFACES;
+
+void activateAVInterfaces(void)
+{
+	struct AVInterfaceEntry *tmpEntry;
+	NEXUS_PlatformConfiguration configuration;
+	int i=0, j=0;
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+	BDBG_MSG(("activateAVInterfaces..."));
+	for (i=0; i<NEXUS_MAX_FRONTENDS; i++)
+	{
+		BDBG_MSG(("**** configuration.frontend[%d]: 0x%x", i, configuration.frontend[i]));
+	}
+	for (i=0; i<NEXUS_NUM_HDMI_OUTPUTS; i++)
+	{
+		BDBG_MSG(("**** configuration.outputs.hdmi[%d]: 0x%x", i, configuration.outputs.hdmi[i]));
+	}
+
+#if NEXUS_MAX_FRONTENDS
+	for (i=0; i<NEXUS_MAX_FRONTENDS; i++)
+	{
+		NEXUS_FrontendCapabilities capabilities;
+
+		if (configuration.frontend[i] == NULL) continue;
+		/* ignore Docsis reserved tuner*/
+#if (BCHP_CHIP != 7425 && BCHP_CHIP != 7429 && BCHP_CHIP != 7435 && BCHP_CHIP != 7445)
+#if (BCHP_CHIP == 7125)
+		if (i==3) continue;
+#else
+		if (i==2) continue;
+#endif
+#endif
+
+		NEXUS_Frontend_GetCapabilities(configuration.frontend[i], &capabilities);
+		if (capabilities.qam)
+		{
+			avIfTblData[j].index = j;
+			avIfTblData[j].ifType = ocStbHostScte40FatRx;
+			sprintf(avIfTblData[j].desc,   "%s", "SCTE-40 FAT Receiver (In-band video tuner)");
+			avIfTblData[j].status = oc_enabled;
+			j++;
+		}
+		else
+		{
+			if (capabilities.outOfBand)
+			{
+				avIfTblData[j].index = j;
+				avIfTblData[j].ifType = ocStbHostScte55FdcRx;
+				sprintf(avIfTblData[j].desc, "%s",   "SCTE-55 FDC Receiver (Out-of-band downstream tuner)");
+				avIfTblData[j].status = oc_enabled;
+				j++;
+			}
+			if (capabilities.upstream)
+			{
+				avIfTblData[j].index = j;
+				avIfTblData[j].ifType = ocStbHostScte55RdcTx;
+				sprintf(avIfTblData[j].desc, "%s",   "SCTE-55 RDC Transmitter (Out-of-band upstream transmitter)");
+				avIfTblData[j].status = oc_enabled;
+				j++;
+			}
+		}
+	}
+#endif
+#if NEXUS_NUM_COMPONENT_OUTPUTS
+	for (i=0; i<NEXUS_NUM_COMPONENT_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostComponentOut;
+		sprintf(avIfTblData[j].desc, "%s",    "Component output");
+		avIfTblData[j].status = configuration.outputs.component[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_COMPOSITE_OUTPUTS
+	for (i=0; i<NEXUS_NUM_COMPOSITE_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostBbVideoOut;
+		sprintf(avIfTblData[j].desc, "%s",   "Base band video output");
+		avIfTblData[j].status = configuration.outputs.composite[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_RFM_OUTPUTS
+	for (i=0; i<NEXUS_NUM_RFM_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostRfOutCh;
+		sprintf(avIfTblData[j].desc, "%s",   "Analog RF output");
+		avIfTblData[j].status = configuration.outputs.rfm[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_SVIDEO_OUTPUTS
+	for (i=0; i<NEXUS_NUM_SVIDEO_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostSVideoOut;
+		sprintf(avIfTblData[j].desc, "%s",   "SVideo output");
+		avIfTblData[j].status = configuration.outputs.svideo[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_AUDIO_DACS
+	for (i=0; i<NEXUS_NUM_AUDIO_DACS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostBbAudioOut;
+		sprintf(avIfTblData[j].desc, "%s",   "Base band audio output");
+		avIfTblData[j].status = configuration.outputs.audioDacs[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_SPDIF_OUTPUTS
+	for (i=0; i<NEXUS_NUM_SPDIF_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHostRcaSpdifOut;
+		sprintf(avIfTblData[j].desc, "%s",   "RCA SPDIF output");
+		avIfTblData[j].status = configuration.outputs.spdif[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NEXUS_NUM_HDMI_OUTPUTS
+	for (i=0; i<NEXUS_NUM_HDMI_OUTPUTS; i++)
+	{
+		NEXUS_HdmiOutputStatus status;
+
+		NEXUS_HdmiOutput_GetStatus(configuration.outputs.hdmi[i], &status);
+
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = status.hdmiDevice ? ocStbHostHdmiOut : ocStbHostDviOut;
+		sprintf(avIfTblData[j].desc, "%s", status.hdmiDevice ?   "HDMI output" : "DVI output");
+		avIfTblData[j].status = configuration.outputs.hdmi[i] ? oc_enabled : oc_disabled;
+		j++;
+	}
+#endif
+#if NUM_IEEE1394_OUTPUTS
+	for (i=0; i<NUM_IEEE1394_OUTPUTS; i++)
+	{
+		avIfTblData[j].index = j;
+		avIfTblData[j].ifType = ocStbHost1394Out;
+		sprintf(avIfTblData[j].desc, "%s", "IEEE-1394 output");
+		avIfTblData[j].status = oc_disabled;
+		j++;
+	}
+#endif
+
+    BDBG_ASSERT(j <= TOTAL_PLATFORM_INTERFACES);
+	avIfTotalEntry = j;
+
+	for (i=0; i<avIfTotalEntry; i++)
+	{
+		tmpEntry = &avIfList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &avIfTblData[i];
+	}
+
+	return;
+}
+
+void checkAVInterfacesStatus(void)
+{
+	NEXUS_PlatformConfiguration configuration;
+	int i, j, k=0;
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+#if NEXUS_NUM_HDMI_OUTPUTS
+	for (i=0; i<NEXUS_NUM_HDMI_OUTPUTS; i++)
+	{
+		for (j=k; j<avIfTotalEntry; j++)
+		{
+			if (avIfTblData[j].ifType == ocStbHostDviOut || avIfTblData[j].ifType == ocStbHostHdmiOut)
+			{
+				NEXUS_HdmiOutputStatus status;
+
+				NEXUS_HdmiOutput_GetStatus(configuration.outputs.hdmi[i], &status);
+
+				avIfTblData[j].ifType = status.hdmiDevice ? ocStbHostHdmiOut : ocStbHostDviOut;
+				sprintf(avIfTblData[j].desc, "%s", status.hdmiDevice ?	 "HDMI output" : "DVI output");
+				avIfTblData[j].status = configuration.outputs.hdmi[i] ? oc_enabled : oc_disabled;
+				k=j+1;
+				break;
+			}
+		}
+	}
+#endif
+
+	return;
+}
+
+bool checkAVInterfaceExistence(avIfTypes ifType, int *pAvIfIndex)
+{
+	bool existence = false;
+	int i, j=0;
+
+	for (i=0; i<avIfTotalEntry; i++)
+	{
+		if (avIfTblData[i].ifType == ifType)
+		{
+			existence = true;
+
+			if (pAvIfIndex)
+			{
+				*(pAvIfIndex+j) = i+1;
+				j++;
+			}
+		}
+	}
+
+	return existence;
+}
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct AVInterfaceEntry *
+getAVInterfaceEntry(int index)
+{
+	struct AVInterfaceEntry *foundEntry = NULL;
+
+	if (index >=0 && index < avIfTotalEntry)
+	{
+		foundEntry = &avIfList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/avInterfaceTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/avInterfaceTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/avInterfaceTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/avInterfaceTable.h	2015-04-13 16:46:48.558275090 -0700
@@ -0,0 +1,84 @@
+#ifndef AVINTERFACETABLE_H
+#define AVINTERFACETABLE_H
+
+/* These are the data structures for AVInterface info.  */
+
+#if (BCHP_CHIP == 7425 || BCHP_CHIP == 7429 || BCHP_CHIP == 7435 || BCHP_CHIP == 7445)
+#define TOTAL_PLATFORM_INTERFACES (NEXUS_MAX_FRONTENDS+1 \
+                                      +NEXUS_NUM_COMPONENT_OUTPUTS \
+                                      +NEXUS_NUM_COMPOSITE_OUTPUTS \
+                                      +NEXUS_NUM_RFM_OUTPUTS \
+                                      +NEXUS_NUM_SVIDEO_OUTPUTS \
+                                      +NEXUS_NUM_AUDIO_DACS \
+                                      +NEXUS_NUM_SPDIF_OUTPUTS \
+                                      +NEXUS_NUM_HDMI_OUTPUTS \
+                                      +NUM_IEEE1394_OUTPUTS)
+#else
+#define TOTAL_PLATFORM_INTERFACES (NEXUS_MAX_FRONTENDS \
+                                      +NEXUS_NUM_COMPONENT_OUTPUTS \
+                                      +NEXUS_NUM_COMPOSITE_OUTPUTS \
+                                      +NEXUS_NUM_RFM_OUTPUTS \
+                                      +NEXUS_NUM_SVIDEO_OUTPUTS \
+                                      +NEXUS_NUM_AUDIO_DACS \
+                                      +NEXUS_NUM_SPDIF_OUTPUTS \
+                                      +NEXUS_NUM_HDMI_OUTPUTS \
+                                      +NUM_IEEE1394_OUTPUTS)
+#endif
+
+/* Enum for the types appropriate for use when designating devices and interfaces related to OpenCable Hosts */
+typedef enum   
+{
+	ocStbHostOther, /* undefined interface in the OpenCable MIB */
+	ocStbHostScte55FdcRx, /* SCTE-55 FDC Receiver, out-of-band downstream tuner */
+	ocStbHostScte55RdcTx, /* SCTE-55 RDC Transmitter, out-of-band upstream transmitter */
+	ocStbHostScte40FatRx, /* SCTE-40 FAT Receiver, in-band video tuner */
+	ocStbHostBbVideoIn, /* Baseband video input */
+	ocStbHostBbAudioIn, /* Baseband audio input */
+	ocStbHostBbVideoOut, /* Baseband video output */
+	ocStbHostBbAudioOut, /* Baseband audio output */
+	ocStbHostRfOutCh, /* Analog RF output */
+	ocStbHostSVideoIn, /* SVideo input */
+	ocStbHostSVideoOut, /* SVideo output */
+	ocStbHostComponentIn, /* SVideo inpput */
+	ocStbHostComponentOut, /* SVideo output */
+	ocStbHostDviIn, /* DVI input */
+	ocStbHostDviOut, /* DVI output */
+	ocStbHostHdmiIn, /* HDMI input */
+	ocStbHostHdmiOut, /* HDMI output */
+	ocStbHostRcaSpdifIn, /* RCA SPDIF input */
+	ocStbHostRcaSpdifOut, /* RCA SPDIF output */
+	ocStbHostToslinkSpdifIn, /* Toslink SPDIF input */
+	ocStbHostToslinkSpdifOut, /* Toslink SPDIF output */
+	ocStbHostDisplayOut, /* Television screen output */
+	ocStbHost1394In, /* IEEE-1394 input */
+	ocStbHost1394Out, /* IEEE-1394 output */
+	ocStbHostDRIInterface /* DRI interface */
+} avIfTypes;
+ 
+struct AVInterfaceData 
+{
+	int index; /* index of the table entry */
+	avIfTypes ifType; /* enum of the A/V interface type */
+	char desc[256]; /*  the textual description of the A/V interface */
+	int status; /* status of the interface */
+};
+
+struct AVInterfaceEntry 
+{
+	int index;
+	struct AVInterfaceData *data;
+};
+
+void
+activateAVInterfaces(void);
+
+void 
+checkAVInterfacesStatus(void);
+
+bool 
+checkAVInterfaceExistence(avIfTypes ifType, int *numInstance);
+
+struct AVInterfaceEntry *
+getAVInterfaceEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,39 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ccAppInfoTable.h"
+
+static struct ccAppInfoTableData ccAppInfoTblData[NUM_CCAPPINFO];
+static struct ccAppInfoTableEntry ccAppInfoList[NUM_CCAPPINFO];
+
+void
+activateCCAppInfoTable(void)
+{
+	struct ccAppInfoTableEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_CCAPPINFO; i++)
+	{
+		memset(&ccAppInfoTblData[i], 0, sizeof(struct ccAppInfoTableData));
+		ccAppInfoTblData[i].index = i;
+
+		tmpEntry = &ccAppInfoList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &ccAppInfoTblData[i];
+	}
+
+	return;
+}
+
+struct ccAppInfoTableEntry *
+getCCAppInfoTableEntry(int index)
+{
+	struct ccAppInfoTableEntry *foundEntry = NULL;
+
+	if (index >=0 && index < NUM_CCAPPINFO)
+	{
+		foundEntry = &ccAppInfoList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ccAppInfoTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,24 @@
+#ifndef CCAPPINFOTABLE_H
+#define CCAPPINFOTABLE_H
+
+/* These are the data structures for CCAPPINFOTABLE info.  */
+
+struct ccAppInfoTableData
+{
+	int index; /* index of the table entry */
+	containerCCAppInfoTable container;
+};
+
+struct ccAppInfoTableEntry
+{
+	int index;
+	struct ccAppInfoTableData *data;
+};
+
+void
+activateCCAppInfoTable(void);
+
+struct ccAppInfoTableEntry *
+getCCAppInfoTableEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/componentVideoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/componentVideoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/componentVideoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/componentVideoTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "componentVideoTable.h"
+
+static struct componentVideoData componentVideoTblData[NEXUS_NUM_COMPONENT_OUTPUTS];
+static struct componentVideoEntry componentVideoList[NEXUS_NUM_COMPONENT_OUTPUTS];
+
+void
+activateComponentVideo(void)
+{
+	struct componentVideoEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NEXUS_NUM_COMPONENT_OUTPUTS; i++)
+	{
+		componentVideoTblData[i].index = i;
+
+		tmpEntry = &componentVideoList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &componentVideoTblData[i];
+	}
+
+	return;
+}
+
+struct componentVideoEntry *
+getComponentVideoEntry(int index)
+{
+	struct componentVideoEntry *foundEntry =NULL;
+
+	if (index >=0 && index < NEXUS_NUM_COMPONENT_OUTPUTS)
+	{
+		foundEntry = &componentVideoList[index];
+	}
+	
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/componentVideoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/componentVideoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/componentVideoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/componentVideoTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,24 @@
+#ifndef COMPONENTVIDEOTABLE_H
+#define COMPONENTVIDEOTABLE_H
+
+/* These are the data structures for component video info.  */
+
+struct componentVideoData 
+{
+	int index; /* index of the table entry */
+	containerComponentVideoTable container;
+};
+
+struct componentVideoEntry 
+{
+	int index;
+	struct componentVideoData *data;
+};
+
+void
+activateComponentVideo(void);
+
+struct componentVideoEntry *
+getComponentVideoEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "dviHdmiAvailableVideoFormatTable.h"
+
+static struct dviHdmiAvailableVideoFormatData dviHdmiAvailableVideoFormatTblData[NUM_HDMI_AVAIL_VIDEO_FORMATS];
+static struct dviHdmiAvailableVideoFormatEntry dviHdmiAvailableVideoFormatList[NUM_HDMI_AVAIL_VIDEO_FORMATS];
+
+void
+activateDviHdmiAvailableVideoFormat(void)
+{
+	struct dviHdmiAvailableVideoFormatEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_HDMI_AVAIL_VIDEO_FORMATS; i++)
+	{
+		dviHdmiAvailableVideoFormatTblData[i].index = i;
+
+		tmpEntry = &dviHdmiAvailableVideoFormatList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &dviHdmiAvailableVideoFormatTblData[i];
+	}
+
+	return;
+}
+
+struct dviHdmiAvailableVideoFormatEntry *
+getDviHdmiAvailableVideoFormatEntry(int index)
+{
+	struct dviHdmiAvailableVideoFormatEntry *foundEntry = NULL;
+
+	if (index >=0 && index < NUM_HDMI_AVAIL_VIDEO_FORMATS)
+	{
+		foundEntry = &dviHdmiAvailableVideoFormatList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiAvailableVideoFormatTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,24 @@
+#ifndef DVIHDMIAVAILABLEVIDEOFORMATTABLE_H
+#define DVIHDMIAVAILABLEVIDEOFORMATTABLE_H
+
+/* These are the data structures for DVIHDMIAvailableVideoFormat info.  */
+
+struct dviHdmiAvailableVideoFormatData
+{
+	int index; /* index of the table entry */
+	containerDviHdmiAvailableVideoFormatTable container;
+};
+
+struct dviHdmiAvailableVideoFormatEntry
+{
+	int index;
+	struct dviHdmiAvailableVideoFormatData *data;
+};
+
+void
+activateDviHdmiAvailableVideoFormat(void);
+
+struct dviHdmiAvailableVideoFormatEntry *
+getDviHdmiAvailableVideoFormatEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "dviHdmiTable.h"
+
+static struct dviHdmiData dviHdmiTblData[NEXUS_NUM_HDMI_OUTPUTS];
+static struct dviHdmiEntry dviHdmiList[NEXUS_NUM_HDMI_OUTPUTS];
+
+void
+activateDviHdmi(void)
+{
+	struct dviHdmiEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NEXUS_NUM_HDMI_OUTPUTS; i++)
+	{
+		dviHdmiTblData[i].index = i;
+
+		tmpEntry = &dviHdmiList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &dviHdmiTblData[i];
+	}
+
+	return;
+}
+
+struct dviHdmiEntry *
+getDviHdmiEntry(int index)
+{
+	struct dviHdmiEntry *foundEntry =NULL;
+
+	if (index >=0 && index < NEXUS_NUM_HDMI_OUTPUTS)
+	{
+		foundEntry = &dviHdmiList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/dviHdmiTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/dviHdmiTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,24 @@
+#ifndef DVIHDMITABLE_H
+#define DVIHDMITABLE_H
+
+/* These are the data structures for DVIHDMI info.  */
+
+struct dviHdmiData 
+{
+	int index; /* index of the table entry */ 
+	containerDviHdmiTable container;
+};
+
+struct dviHdmiEntry 
+{
+	int index;
+	struct dviHdmiData *data;
+};
+
+void
+activateDviHdmi(void);
+
+struct dviHdmiEntry *
+getDviHdmiEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ibTunerTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ibTunerTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ibTunerTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ibTunerTable.c	2015-04-13 16:46:57.318379831 -0700
@@ -0,0 +1,83 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ibTunerTable.h"
+
+static struct ibTunerData tunerTblData[NUM_INBAND_TUNERS];
+static struct ibTunerEntry tunerList[NUM_INBAND_TUNERS];
+static unsigned int ibTunerTotalEntry = NUM_INBAND_TUNERS;
+
+BDBG_MODULE(snmpProxy);
+
+void
+activateIBTuners(void)
+{
+	struct ibTunerEntry *tmpEntry;
+	NEXUS_PlatformConfiguration configuration;
+	int i=0, j=0;
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+	BDBG_MSG(("activateIBTuners..."));
+	for (i=0; i<NEXUS_MAX_FRONTENDS; i++)
+	{
+		BDBG_MSG(("**** configuration.frontend[%d]: 0x%x", i, configuration.frontend[i]));
+	}
+
+#if NEXUS_MAX_FRONTENDS
+	for (i=0; i<NEXUS_MAX_FRONTENDS; i++)
+	{
+		NEXUS_FrontendCapabilities capabilities;
+
+		if (configuration.frontend[i] == NULL) continue;
+
+		/* ignore Docsis reserved tuner for the following chips */
+#if (BCHP_CHIP != 7425 && BCHP_CHIP != 7429 && BCHP_CHIP != 7435 && BCHP_CHIP != 7445)
+#if (BCHP_CHIP == 7125)
+		if (i == 3) continue;
+#else
+		if (i == 2) continue;
+#endif
+#endif
+
+		NEXUS_Frontend_GetCapabilities(configuration.frontend[i], &capabilities);
+		if (capabilities.qam)
+		{
+			j++;
+		}
+	}
+#endif
+
+	BDBG_ASSERT(j<=NUM_INBAND_TUNERS);
+	ibTunerTotalEntry = j;
+
+	for (i=0; i<ibTunerTotalEntry; i++)
+	{
+		tunerTblData[i].index = i;
+
+		tmpEntry = &tunerList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &tunerTblData[i];
+	}
+
+	return;
+}
+
+struct ibTunerEntry *
+getIBTunerEntry(int index)
+{
+	struct ibTunerEntry *foundEntry =NULL;
+
+	if (index >= 0 && index < ibTunerTotalEntry)
+	{
+		foundEntry = &tunerList[index];
+	}
+
+	return foundEntry;
+}
+
+unsigned int
+getIBTunerTotalEntry(void)
+{
+	return ibTunerTotalEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ibTunerTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ibTunerTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ibTunerTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ibTunerTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,27 @@
+#ifndef IBTUNERTABLE_H
+#define IBTUNERTABLE_H
+
+/* These are the data structures for tuner info.  */
+
+struct ibTunerData
+{
+	int index; /* index of the table entry */
+	containerInBandTunerTable container;
+};
+
+struct ibTunerEntry
+{
+	int index;
+	struct ibTunerData *data;
+};
+
+void
+activateIBTuners(void);
+
+struct ibTunerEntry *
+getIBTunerEntry(int index);
+
+unsigned int
+getIBTunerTotalEntry(void);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ieee1394ConnectedDevicesTable.h"
+
+static struct ieee1394ConnectedDevicesData ieee1394ConDevTblData[NUM_IEEE1394_OUTPUTS];
+static struct ieee1394ConnectedDevicesEntry ieee1394ConDevList[NUM_IEEE1394_OUTPUTS];
+
+void
+activateIeee1394ConnectedDevices(void)
+{
+	struct ieee1394ConnectedDevicesEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_IEEE1394_OUTPUTS; i++)
+	{
+		ieee1394ConDevTblData[i].index = i;
+
+		tmpEntry = &ieee1394ConDevList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &ieee1394ConDevTblData[i];
+	}
+
+	return;
+}
+
+struct ieee1394ConnectedDevicesEntry *
+getIeee1394ConnectedDevicesEntry(int index)
+{
+	struct ieee1394ConnectedDevicesEntry *foundEntry = NULL;
+
+	if (index >=0 && index < NUM_IEEE1394_OUTPUTS)
+	{
+		foundEntry = &ieee1394ConDevList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394ConnectedDevicesTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,24 @@
+#ifndef IEEE1394CONNECTEDDEVICESTABLE_H
+#define IEEE1394CONNECTEDDEVICESTABLE_H
+
+/* These are the data structures for IEEE1394ConnectedDevicesTable info.  */
+
+struct ieee1394ConnectedDevicesData 
+{
+	int index;
+	containerIeee1394ConnectedDevicesTable container;
+};
+
+struct ieee1394ConnectedDevicesEntry 
+{
+	int index;
+	struct ieee1394ConnectedDevicesData *data;
+};
+
+void
+activateIeee1394ConnectedDevices(void);
+
+struct ieee1394ConnectedDevicesEntry *
+getIeee1394ConnectedDevicesEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394Table.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394Table.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394Table.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394Table.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ieee1394Table.h"
+
+static struct ieee1394Data ieee1394TblData[NUM_IEEE1394_OUTPUTS];
+static struct ieee1394Entry ieee1394List[NUM_IEEE1394_OUTPUTS];
+
+void
+activateIeee1394(void)
+{
+	struct ieee1394Entry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_IEEE1394_OUTPUTS; i++)
+	{
+		ieee1394TblData[i].index = i;
+
+		tmpEntry = &ieee1394List[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &ieee1394TblData[i];
+	}
+
+	return;
+}
+
+struct ieee1394Entry *
+getIeee1394Entry(int index) {
+
+	struct ieee1394Entry *foundEntry =NULL;
+
+	if (index >=0 && index < NUM_IEEE1394_OUTPUTS)
+	{
+		foundEntry = &ieee1394List[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394Table.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394Table.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ieee1394Table.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ieee1394Table.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,24 @@
+#ifndef IEEE1394TABLE_H
+#define IEEE1394TABLE_H
+
+/* These are the data structures for IEEE1394Table info.  */
+
+struct ieee1394Data 
+{
+	int index;
+	containerIeee1394Table container;
+};
+
+struct ieee1394Entry 
+{
+	int index;
+	struct ieee1394Data *data;
+};
+
+void
+activateIeee1394(void);
+
+struct ieee1394Entry *
+getIeee1394Entry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.c	2015-04-13 16:47:03.918389240 -0700
@@ -0,0 +1,56 @@
+/* This is the data storage for mpeg2Content info. It is expected that this info changes
+   all the time, but for this demo, it is static.
+ */
+
+#include "mpeg2ContentTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+static struct mpeg2ContentData mpeg2ContentData1[NEXUS_NUM_VIDEO_DECODERS];
+
+static struct mpeg2ContentEntry ListOfMpeg2Content[NEXUS_NUM_VIDEO_DECODERS];
+
+static unsigned int TotalMpeg2ContentEntry = NEXUS_NUM_VIDEO_DECODERS;
+
+void
+activateMpeg2Content (void) {
+int i;
+
+#if (BCHP_CHIP == 7405)
+	TotalMpeg2ContentEntry = 1;
+#elif (BCHP_CHIP == 7425 || BCHP_CHIP == 7429 || BCHP_CHIP == 7435 || BCHP_CHIP == 7445)
+	TotalMpeg2ContentEntry = 2;
+#endif
+
+	for (i=0;i<TotalMpeg2ContentEntry;i++)
+	{
+	  mpeg2ContentData1[i].index = i;
+	  ListOfMpeg2Content[i].index = i+1;
+	  ListOfMpeg2Content[i].data = &mpeg2ContentData1[i];
+
+	}
+
+  	return;
+
+}
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct mpeg2ContentEntry *
+getMpeg2ContentEntry(int index) {
+
+	struct mpeg2ContentEntry *foundEntry =NULL;
+
+	if (index >= 0 && index < TotalMpeg2ContentEntry )
+	{
+	   foundEntry = &ListOfMpeg2Content[index];
+	}
+	return foundEntry;
+}
+
+unsigned int getMpeg2ContentTotalEntry(void)
+{
+	return TotalMpeg2ContentEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/mpeg2ContentTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,32 @@
+#ifndef MPEG2CONTENTTABLE_H
+#define MPEG2CONTENTTABLE_H
+#include "snmpProxyIf.h"
+/* These are the data structures for mpeg2Content info.  */
+
+struct mpeg2ContentData {
+        int index;
+        containerMpeg2ContentTable container;
+
+};
+
+struct mpeg2ContentEntry {
+         int index;
+         struct mpeg2ContentData *data;
+};
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+void
+activateMpeg2Content (void);
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct mpeg2ContentEntry *
+getMpeg2ContentEntry(int index);
+
+unsigned int getMpeg2ContentTotalEntry(void);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,1258 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbCardInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbCardInfo module */
+void
+init_ocStbCardInfo(void)
+{
+#if 0
+    static oid      ocStbHostCardSerialNumber_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 4, 0 };
+#endif
+    static oid      ocStbHostCardDaylightSavingsTimeEntry_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 12, 0 };
+    static oid      ocStbHostCardEaLocationCode_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 14, 0 };
+#if 0
+    static oid      ocStbHostCardCpCertificateCheck_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 2, 0 };
+    static oid      ocStbHostCardCpAuthKeyStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 1, 0 };
+#endif
+    static oid      ocStbHostCardTimeZoneOffset_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 10, 0 };
+#if 0
+    static oid      ocStbHostCardMfgId_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 1, 0 };
+	static oid		ocStbHostCardSnmpAccessControl_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 5, 0 };
+#endif
+    static oid      ocStbHostCardDaylightSavingsTimeDelta_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 11, 0 };
+    static oid      ocStbHostCardIpAddress_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 3, 0 };
+    static oid      ocStbHostCardVctId_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 15, 0 };
+#if 0
+    static oid      ocStbHostCardCpCciChallengeCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 3, 0 };
+#endif
+    static oid      ocStbHostCardIpAddressType_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 2, 0 };
+#if 0
+    static oid      ocStbHostCardCpIdList_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 5, 0 };
+    static oid      ocStbHostCardCpKeyGenerationReqCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 4, 0 };
+#endif
+    static oid      ocStbHostCardDaylightSavingsTimeExit_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 13, 0 };
+    static oid      ocStbHostCardBindingStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 8, 0 };
+    static oid      ocStbHostCardId_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 7, 0 };
+    static oid      ocStbHostCardOpenedGenericResource_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 9, 0 };
+#if 0
+    static oid      ocStbHostCardVersion_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 2, 0 };
+    static oid      ocStbHostCardRootOid_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 3, 0 };
+#endif
+    static oid      ocStbHostCardMacAddress_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 1, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbCardInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbCardInfo", "Initializing\n"));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardSerialNumber",
+	                                         get_ocStbHostCardSerialNumber,
+	                                         ocStbHostCardSerialNumber_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardSerialNumber_oid),
+	                                         HANDLER_CAN_RONLY));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardDaylightSavingsTimeEntry",
+	                                         get_ocStbHostCardDaylightSavingsTimeEntry,
+	                                         ocStbHostCardDaylightSavingsTimeEntry_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardDaylightSavingsTimeEntry_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardEaLocationCode",
+	                                         get_ocStbHostCardEaLocationCode,
+	                                         ocStbHostCardEaLocationCode_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardEaLocationCode_oid),
+	                                         HANDLER_CAN_RONLY));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardCpCertificateCheck",
+	                                         get_ocStbHostCardCpCertificateCheck,
+	                                         ocStbHostCardCpCertificateCheck_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardCpCertificateCheck_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardCpAuthKeyStatus",
+	                                         get_ocStbHostCardCpAuthKeyStatus,
+	                                         ocStbHostCardCpAuthKeyStatus_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardCpAuthKeyStatus_oid),
+	                                         HANDLER_CAN_RONLY));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardTimeZoneOffset",
+	                                         get_ocStbHostCardTimeZoneOffset,
+	                                         ocStbHostCardTimeZoneOffset_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardTimeZoneOffset_oid),
+	                                         HANDLER_CAN_RONLY));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardMfgId",
+	                                         get_ocStbHostCardMfgId,
+	                                         ocStbHostCardMfgId_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardMfgId_oid),
+	                                         HANDLER_CAN_RONLY));
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostCardSnmpAccessControl",
+								   do_ocStbHostCardSnmpAccessControl,
+								   ocStbHostCardSnmpAccessControl_oid,
+								   OID_LENGTH
+								   (ocStbHostCardSnmpAccessControl_oid),
+								   HANDLER_CAN_RWRITE));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardDaylightSavingsTimeDelta",
+	                                         get_ocStbHostCardDaylightSavingsTimeDelta,
+	                                         ocStbHostCardDaylightSavingsTimeDelta_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardDaylightSavingsTimeDelta_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardIpAddress",
+	                                         get_ocStbHostCardIpAddress,
+	                                         ocStbHostCardIpAddress_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardIpAddress_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardVctId",
+	                                         get_ocStbHostCardVctId,
+	                                         ocStbHostCardVctId_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardVctId_oid),
+	                                         HANDLER_CAN_RONLY));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardCpCciChallengeCount",
+	                                         get_ocStbHostCardCpCciChallengeCount,
+	                                         ocStbHostCardCpCciChallengeCount_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardCpCciChallengeCount_oid),
+	                                         HANDLER_CAN_RONLY));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardIpAddressType",
+	                                         get_ocStbHostCardIpAddressType,
+	                                         ocStbHostCardIpAddressType_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardIpAddressType_oid),
+	                                         HANDLER_CAN_RONLY));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardCpIdList",
+	                                         get_ocStbHostCardCpIdList,
+	                                         ocStbHostCardCpIdList_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardCpIdList_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardCpKeyGenerationReqCount",
+	                                         get_ocStbHostCardCpKeyGenerationReqCount,
+	                                         ocStbHostCardCpKeyGenerationReqCount_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardCpKeyGenerationReqCount_oid),
+	                                         HANDLER_CAN_RONLY));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardDaylightSavingsTimeExit",
+	                                         get_ocStbHostCardDaylightSavingsTimeExit,
+	                                         ocStbHostCardDaylightSavingsTimeExit_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardDaylightSavingsTimeExit_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardBindingStatus",
+	                                         get_ocStbHostCardBindingStatus,
+	                                         ocStbHostCardBindingStatus_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardBindingStatus_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardId",
+	                                         get_ocStbHostCardId,
+	                                         ocStbHostCardId_oid,
+	                                         OID_LENGTH(ocStbHostCardId_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardOpenedGenericResource",
+	                                         get_ocStbHostCardOpenedGenericResource,
+	                                         ocStbHostCardOpenedGenericResource_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardOpenedGenericResource_oid),
+	                                         HANDLER_CAN_RONLY));
+#if 0
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardVersion",
+	                                         get_ocStbHostCardVersion,
+	                                         ocStbHostCardVersion_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardVersion_oid),
+	                                         HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardRootOid",
+	                                         get_ocStbHostCardRootOid,
+	                                         ocStbHostCardRootOid_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardRootOid_oid),
+	                                         HANDLER_CAN_RONLY));
+#endif
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostCardMacAddress",
+	                                         get_ocStbHostCardMacAddress,
+	                                         ocStbHostCardMacAddress_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostCardMacAddress_oid),
+	                                         HANDLER_CAN_RONLY));
+	}
+}
+
+
+#if 0
+int
+get_ocStbHostCardSerialNumber(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCardDaylightSavingsTimeEntry(netsnmp_mib_handler *handler,
+                                          netsnmp_handler_registration
+                                          *reginfo,
+                                          netsnmp_agent_request_info
+                                          *reqinfo,
+                                          netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.daylightSavingsTimeEntry)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardEaLocationCode(netsnmp_mib_handler *handler,
+                                netsnmp_handler_registration *reginfo,
+                                netsnmp_agent_request_info *reqinfo,
+                                netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.eaLocationCode)
+                                 ,
+                                 sizeof(pObj->container.eaLocationCode)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostCardCpCertificateCheck(netsnmp_mib_handler *handler,
+                                    netsnmp_handler_registration *reginfo,
+                                    netsnmp_agent_request_info *reqinfo,
+                                    netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpAuthKeyStatus(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCardTimeZoneOffset(netsnmp_mib_handler *handler,
+                                netsnmp_handler_registration *reginfo,
+                                netsnmp_agent_request_info *reqinfo,
+                                netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.timeZoneOffset)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostCardMfgId(netsnmp_mib_handler *handler,
+                       netsnmp_handler_registration *reginfo,
+                       netsnmp_agent_request_info *reqinfo,
+                       netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostCardSnmpAccessControl(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
+                                      );
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        /*
+         * XXX malloc "undo" storage buffer
+         */
+        if ( /* XXX if malloc, or whatever, failed: */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_RESOURCESUNAVAILABLE);
+        }
+        break;
+
+    case MODE_SET_FREE:
+        /*
+         * XXX: free resources allocated in RESERVE1 and/or
+         * RESERVE2.  Something failed somewhere, and the states
+         * below won't be called.
+         */
+        break;
+
+    case MODE_SET_ACTION:
+        /*
+         * XXX: perform the value change here
+         */
+        if ( /* XXX: error? */ ) {
+            netsnmp_set_request_error(reqinfo, requests, /* some error */
+                                      );
+        }
+        break;
+
+    case MODE_SET_COMMIT:
+        /*
+         * XXX: delete temporary storage
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_COMMITFAILED);
+        }
+        break;
+
+    case MODE_SET_UNDO:
+        /*
+         * XXX: UNDO and return to previous value for the object
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_UNDOFAILED);
+        }
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCardDaylightSavingsTimeDelta(netsnmp_mib_handler *handler,
+                                          netsnmp_handler_registration
+                                          *reginfo,
+                                          netsnmp_agent_request_info
+                                          *reqinfo,
+                                          netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 &(pObj->container.daylightSavingsTimeDelta)
+                                 ,
+                                 sizeof(unsigned char)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardIpAddress(netsnmp_mib_handler *handler,
+                           netsnmp_handler_registration *reginfo,
+                           netsnmp_agent_request_info *reqinfo,
+                           netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.ipAddr)
+                                 ,
+                                 (pObj->container.ipType == oc_inetAddrType_ipv6)
+                                 ? 16 : 4
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardVctId(netsnmp_mib_handler *handler,
+                       netsnmp_handler_registration *reginfo,
+                       netsnmp_agent_request_info *reqinfo,
+                       netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.vctId)
+                                 ,
+                                 sizeof(pObj->container.vctId)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostCardCpCciChallengeCount(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCardIpAddressType(netsnmp_mib_handler *handler,
+                               netsnmp_handler_registration *reginfo,
+                               netsnmp_agent_request_info *reqinfo,
+                               netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.ipType)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostCardCpIdList(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpKeyGenerationReqCount(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCardDaylightSavingsTimeExit(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.daylightSavingsTimeExit)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardBindingStatus(netsnmp_mib_handler *handler,
+                               netsnmp_handler_registration *reginfo,
+                               netsnmp_agent_request_info *reqinfo,
+                               netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.cardBindingStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardId(netsnmp_mib_handler *handler,
+                    netsnmp_handler_registration *reginfo,
+                    netsnmp_agent_request_info *reqinfo,
+                    netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.cardId)
+                                 ,
+                                 strlen(pObj->container.cardId)
+                                 );
+        break;
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardOpenedGenericResource(netsnmp_mib_handler *handler,
+                                       netsnmp_handler_registration
+                                       *reginfo,
+                                       netsnmp_agent_request_info *reqinfo,
+                                       netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.opendGenericResource)
+                                 ,
+                                 sizeof(pObj->container.opendGenericResource)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostCardVersion(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardRootOid(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#endif
+
+int
+get_ocStbHostCardMacAddress(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+	mibObjectCardInfo *pObj = (mibObjectCardInfo *)gMibObjs[ocStbCardInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.macAddr)
+                                 ,
+                                 6 /* mac address contains 6 octet bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbCardInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,46 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBCARDINFO_H
+#define OCSTBCARDINFO_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbCardInfo(void);
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardSerialNumber;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardDaylightSavingsTimeEntry;
+Netsnmp_Node_Handler get_ocStbHostCardEaLocationCode;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardCpCertificateCheck;
+Netsnmp_Node_Handler get_ocStbHostCardCpAuthKeyStatus;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardTimeZoneOffset;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardMfgId;
+Netsnmp_Node_Handler do_ocStbHostCardSnmpAccessControl;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardDaylightSavingsTimeDelta;
+Netsnmp_Node_Handler get_ocStbHostCardIpAddress;
+Netsnmp_Node_Handler get_ocStbHostCardVctId;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardCpCciChallengeCount;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardIpAddressType;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardCpIdList;
+Netsnmp_Node_Handler get_ocStbHostCardCpKeyGenerationReqCount;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardDaylightSavingsTimeExit;
+Netsnmp_Node_Handler get_ocStbHostCardBindingStatus;
+Netsnmp_Node_Handler get_ocStbHostCardId;
+Netsnmp_Node_Handler get_ocStbHostCardOpenedGenericResource;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostCardVersion;
+Netsnmp_Node_Handler get_ocStbHostCardRootOid;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCardMacAddress;
+#endif                          /* OCSTBCARDINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,319 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostAnalogVideoTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "analogVideoTable.h"
+
+/** Initialize the ocStbHostAnalogVideoTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostAnalogVideoTable(void)
+{
+    static oid      ocStbHostAnalogVideoTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 4 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+    snmp_log(LOG_INFO, "initialize_table_ocStbHostAnalogVideoTable() enter\n");
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostAnalogVideoTable",
+                                            ocStbHostAnalogVideoTable_handler,
+                                            ocStbHostAnalogVideoTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostAnalogVideoTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostAnalogVideoIndex */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 1;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostAnalogVideoTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostAnalogVideoTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostAnalogVideoTable",
+                "Registering table ocStbHostAnalogVideoTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostAnalogVideoTable module */
+void
+init_ocStbHostAnalogVideoTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostAnalogVideoTable];
+    mibObjectAnalogVideoTable *pTblObj = (mibObjectAnalogVideoTable *)pObj->obj;
+    struct analogVideoEntry *pEntry;
+	int i;
+	
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostAnalogVideoTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (   checkAVInterfaceExistence(ocStbHostComponentOut, NULL)
+			|| checkAVInterfaceExistence(ocStbHostBbVideoOut, NULL)
+			|| checkAVInterfaceExistence(ocStbHostSVideoOut, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting 
+			 */
+			activateAnalogVideo();	  /* MOE initialize analogVideo instrumentation */
+			initialize_table_ocStbHostAnalogVideoTable();
+            for (i=0;i<SNMP_ANALOG_NUM_OUTPUTS;i++) 
+            {
+                pEntry = getAnalogVideoEntry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+            }
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostAnalogVideoTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostAnalogVideoTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostAnalogVideoTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct analogVideoEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostAnalogVideoTable_get_first_data_point() enter\n"); */
+	
+    tmpPtr = getAnalogVideoEntry(0);
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostAnalogVideoTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostAnalogVideoTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct analogVideoEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostAnalogVideoTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct analogVideoEntry *) *my_loop_context;
+    if (tmpPtr) {
+      tmpPtr = getAnalogVideoEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostAnalogVideoTable table, if anything else needs to be done */
+int
+ocStbHostAnalogVideoTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+	netsnmp_request_info *request;
+	netsnmp_table_request_info *table_info;
+	netsnmp_variable_list *var;
+	struct analogVideoData *tmpAnalogVideoDataPtr;          /* MOE a pointer to some analogVideo data */
+	mibObjectAnalogVideoTable *pObj = (mibObjectAnalogVideoTable *)gMibObjs[ocStbHostAnalogVideoTable].obj;
+
+	BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostAnalogVideoTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostAnalogVideoTable table in question 
+         */
+		/* MOE extract the data pointer */
+		tmpAnalogVideoDataPtr = ( struct analogVideoData *) netsnmp_extract_iterator_context(request);
+		if ( tmpAnalogVideoDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        
+        if (table_info == NULL) {
+            continue;
+        }
+         
+        pObj->callback((void *)pObj, tmpAnalogVideoDataPtr->index);
+ 
+      
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTANALOGVIDEOPROTECTIONSTATUS:
+                 /*It's initialized above. Need to check if caching in a container is required */
+                
+                  snmp_log(LOG_INFO,"pAnalogVideoDataPtr->potectionStatus %d\n",
+                       "AnalogVideoDataPtr->container.avIfType %d\n",
+                       "AnalogVideoDataPtr->index %d\n",
+                       "AnalogVideoDataPtr->container.avIfInterfaceIndex %d\n",
+                       tmpAnalogVideoDataPtr->container.potectionStatus,
+                       tmpAnalogVideoDataPtr->container.avIfType,
+                       tmpAnalogVideoDataPtr->index,
+                       tmpAnalogVideoDataPtr->container.avIfInterfaceIndex);
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpAnalogVideoDataPtr->container.potectionStatus)
+                                         , sizeof(int) );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostAnalogVideoTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostAnalogVideoTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAnalogVideoTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,22 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTANALOGVIDEOTABLE_H
+#define OCSTBHOSTANALOGVIDEOTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostAnalogVideoTable(void);
+void            initialize_table_ocStbHostAnalogVideoTable(void);
+Netsnmp_Node_Handler ocStbHostAnalogVideoTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostAnalogVideoTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostAnalogVideoTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostAnalogVideoTable 
+ */
+#define COLUMN_OCSTBHOSTANALOGVIDEOPROTECTIONSTATUS		1
+#endif                          /* OCSTBHOSTANALOGVIDEOTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,343 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostAVInterfaceTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "avInterfaceTable.h"   /* MOE this is where we get our AVInterface info */
+
+BDBG_MODULE(snmpProxy);
+
+static oid avTableId[25][15] = 
+{
+    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  1 }, /* ocStbHostOther */
+    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  2 }, /* ocStbHostScte55FdcRx */
+    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  3 }, /* ocStbHostScte55RdcTx */
+    { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  4 }, /* ocStbHostScte40FatRx */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  5 }, /* ocStbHostBbVideoIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  6 }, /* ocStbHostBbAudioIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  7 }, /* ocStbHostBbVideoOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  8 }, /* ocStbHostBbAudioOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1,  9 }, /* ocStbHostRfOutCh */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 10 }, /* ocStbHostSVideoIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 11 }, /* ocStbHostSVideoOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 12 }, /* ocStbHostComponentIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 13 }, /* ocStbHostComponentOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 14 }, /* ocStbHostDviIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 15 }, /* ocStbHostDviOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 16 }, /* ocStbHostHdmiIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 17 }, /* ocStbHostHdmiOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 18 }, /* ocStbHostRcaSpdifIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 19 }, /* ocStbHostRcaSpdifOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 20 }, /* ocStbHostToslinkSpdifIn */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 21 }, /* ocStbHostToslinkSpdifOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 22 }, /* ocStbHostDisplayOut */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 23 }, /* ocStbHost1394In */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 24 }, /* ocStbHost1394Out */
+	{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 1, 25 }  /* ocStbHostDRIInterface */
+};
+
+static clock_t prevtime = 0; /* in unit of 10 ms */
+static clock_t currtime = 0; /* in unit of 10 ms */
+
+/** Initialize the ocStbHostAVInterfaceTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostAVInterfaceTable(void)
+{
+    static oid      ocStbHostAVInterfaceTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostAVInterfaceTable",
+                                            ocStbHostAVInterfaceTable_handler,
+                                            ocStbHostAVInterfaceTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostAVInterfaceTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostAVInterfaceIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 4;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostAVInterfaceTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostAVInterfaceTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostAVInterfaceTable",
+                "Registering table ocStbHostAVInterfaceTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostAVInterfaceTable module */
+void
+init_ocStbHostAVInterfaceTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostAVInterfaceTable];
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostAVInterfaceTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		/*
+		 * here we initialize all the tables we're planning on supporting 
+		 */
+		activateAVInterfaces(); 	  /* MOE initialize AVInterface instrumentation */
+		initialize_table_ocStbHostAVInterfaceTable();
+	}
+}
+
+/** returns the first data point within the ocStbHostAVInterfaceTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostAVInterfaceTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostAVInterfaceTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct AVInterfaceEntry *tmpPtr;            /* MOE a pointer to the first entry */
+
+    tmpPtr = getAVInterfaceEntry(0);      		/* go ahead and get the first entry */
+    if (tmpPtr == NULL) {                     	/* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;  				/* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          	/* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)        /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostAVInterfaceTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostAVInterfaceTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct AVInterfaceEntry *tmpPtr;				/* MOE a pointer to the first entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostAVInterfaceTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct AVInterfaceEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getAVInterfaceEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)        /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostAVInterfaceTable table, if anything else needs to be done */
+int
+ocStbHostAVInterfaceTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct AVInterfaceData *tmpAVInterfaceDataPtr;          /* MOE a pointer to some AVInterface data */
+	struct tms _tms;
+
+    /* snmp_log(LOG_INFO, "ocStbHostAVInterfaceTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostAVInterfaceTable table in question 
+         */
+         /* MOE extract the data pointer */
+        tmpAVInterfaceDataPtr = (struct AVInterfaceData *) netsnmp_extract_iterator_context(request);
+        if (tmpAVInterfaceDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		currtime = times(&_tms);
+		if (labs(currtime-prevtime) >= ELAPSED_TIME)
+		{
+			checkAVInterfacesStatus();
+			prevtime = currtime;
+		}
+		
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTAVINTERFACETYPE:
+                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
+                                         (u_char *) (avTableId[tmpAVInterfaceDataPtr->ifType])
+                                         , sizeof(avTableId[tmpAVInterfaceDataPtr->ifType]));
+                break; 
+
+            case COLUMN_OCSTBHOSTAVINTERFACEDESC:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpAVInterfaceDataPtr->desc)
+                                         , strlen(tmpAVInterfaceDataPtr->desc));
+                break; 
+
+            case COLUMN_OCSTBHOSTAVINTERFACESTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpAVInterfaceDataPtr->status)
+                                         , sizeof(int));
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostAVInterfaceTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostAVInterfaceTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostAVInterfaceTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,25 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTAVINTERFACETABLE_H
+#define OCSTBHOSTAVINTERFACETABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostAVInterfaceTable(void);
+void            initialize_table_ocStbHostAVInterfaceTable(void);
+Netsnmp_Node_Handler ocStbHostAVInterfaceTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostAVInterfaceTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostAVInterfaceTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostAVInterfaceTable 
+ */
+#define COLUMN_OCSTBHOSTAVINTERFACEINDEX		1
+#define COLUMN_OCSTBHOSTAVINTERFACETYPE		2
+#define COLUMN_OCSTBHOSTAVINTERFACEDESC		3
+#define COLUMN_OCSTBHOSTAVINTERFACESTATUS		4
+#endif                          /* OCSTBHOSTAVINTERFACETABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,304 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostCardCpInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostCardCpInfo module */
+void
+init_ocStbHostCardCpInfo(void)
+{
+    static oid      ocStbHostCardCpAuthKeyStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 1, 0 };
+    static oid      ocStbHostCardCpIdList_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 5, 0 };
+    static oid      ocStbHostCardCpKeyGenerationReqCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 4, 0 };
+    static oid      ocStbHostCardCpCciChallengeCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 3, 0 };
+    static oid      ocStbHostCardCpCertificateCheck_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 16, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostCardCpInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostCardCpInfo", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardCpAuthKeyStatus",
+											 get_ocStbHostCardCpAuthKeyStatus,
+											 ocStbHostCardCpAuthKeyStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostCardCpAuthKeyStatus_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardCpIdList",
+											 get_ocStbHostCardCpIdList,
+											 ocStbHostCardCpIdList_oid,
+											 OID_LENGTH
+											 (ocStbHostCardCpIdList_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardCpKeyGenerationReqCount",
+											 get_ocStbHostCardCpKeyGenerationReqCount,
+											 ocStbHostCardCpKeyGenerationReqCount_oid,
+											 OID_LENGTH
+											 (ocStbHostCardCpKeyGenerationReqCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardCpCciChallengeCount",
+											 get_ocStbHostCardCpCciChallengeCount,
+											 ocStbHostCardCpCciChallengeCount_oid,
+											 OID_LENGTH
+											 (ocStbHostCardCpCciChallengeCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardCpCertificateCheck",
+											 get_ocStbHostCardCpCertificateCheck,
+											 ocStbHostCardCpCertificateCheck_oid,
+											 OID_LENGTH
+											 (ocStbHostCardCpCertificateCheck_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostCardCpAuthKeyStatus(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+	mibObjectCardCpInfo *pObj = (mibObjectCardCpInfo *)gMibObjs[ocStbHostCardCpInfo].obj;
+	int authKeyStatus;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+	{
+		authKeyStatus = pObj->container.authKeyStatus ? oc_cardCpAuthKeyStatus_ready : oc_cardCpAuthKeyStatus_notReady;
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(authKeyStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+    }
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpIdList(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectCardCpInfo *pObj = (mibObjectCardCpInfo *)gMibObjs[ocStbHostCardCpInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.idList)
+                                 ,
+                                 sizeof(pObj->container.idList)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpKeyGenerationReqCount(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+	mibObjectCardCpInfo *pObj = (mibObjectCardCpInfo *)gMibObjs[ocStbHostCardCpInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.keyGenReqCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpCciChallengeCount(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+	mibObjectCardCpInfo *pObj = (mibObjectCardCpInfo *)gMibObjs[ocStbHostCardCpInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.cciCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardCpCertificateCheck(netsnmp_mib_handler *handler,
+                                    netsnmp_handler_registration *reginfo,
+                                    netsnmp_agent_request_info *reqinfo,
+                                    netsnmp_request_info *requests)
+{
+	mibObjectCardCpInfo *pObj = (mibObjectCardCpInfo *)gMibObjs[ocStbHostCardCpInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.certCheck)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCardCpInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,18 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTCARDCPINFO_H
+#define OCSTBHOSTCARDCPINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostCardCpInfo(void);
+Netsnmp_Node_Handler get_ocStbHostCardCpAuthKeyStatus;
+Netsnmp_Node_Handler get_ocStbHostCardCpIdList;
+Netsnmp_Node_Handler get_ocStbHostCardCpKeyGenerationReqCount;
+Netsnmp_Node_Handler get_ocStbHostCardCpCciChallengeCount;
+Netsnmp_Node_Handler get_ocStbHostCardCpCertificateCheck;
+
+#endif                          /* OCSTBHOSTCARDCPINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,334 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostCCAppInfoTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ccAppInfoTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostCCAppInfoTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostCCAppInfoTable(void)
+{
+    static oid      ocStbHostCCAppInfoTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 5, 1, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostCCAppInfoTable",
+                                            ocStbHostCCAppInfoTable_handler,
+                                            ocStbHostCCAppInfoTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostCCAppInfoTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostCCApplicationType */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 5;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostCCAppInfoTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostCCAppInfoTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostCCAppInfoTable",
+                "Registering table ocStbHostCCAppInfoTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostCCMMI module */
+void
+init_ocStbHostCCAppInfoTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostCCAppInfoTable];
+	mibObjectCCAppInfoTable *pTblObj = (mibObjectCCAppInfoTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostCCMMI() enter\n"); */
+
+	if (pObj->registered)
+	{
+		/*
+		 * here we initialize all the tables we're planning on supporting
+		 */
+		activateCCAppInfoTable();	  /* MOE initialize CCAppInfoTable instrumentation */
+		initialize_table_ocStbHostCCAppInfoTable();
+
+		for (i=0; i<NUM_CCAPPINFO; i++)
+		{
+			struct ccAppInfoTableEntry *pEntry = getCCAppInfoTableEntry(i);
+			pTblObj->pContainer[i] = &pEntry->data->container;
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostCCAppInfoTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostCCAppInfoTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostCCAppInfoTable_get_first_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ccAppInfoTableEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    tmpPtr = getCCAppInfoTableEntry(0);  		   /* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostCCAppInfoTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostCCAppInfoTable_get_next_data_point(void **my_loop_context,
+                                            void **my_data_context,
+                                            netsnmp_variable_list *
+                                            put_index_data,
+                                            netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ccAppInfoTableEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostCCAppInfoTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct ccAppInfoTableEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getCCAppInfoTableEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostCCAppInfoTable table, if anything else needs to be done */
+int
+ocStbHostCCAppInfoTable_handler(netsnmp_mib_handler *handler,
+                                netsnmp_handler_registration *reginfo,
+                                netsnmp_agent_request_info *reqinfo,
+                                netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct ccAppInfoTableData *tmpCCAppInfoTableDataPtr;          /* MOE a pointer to some CCAppInfoTable data */
+	mibObjectCCAppInfoTable *pObj = (mibObjectCCAppInfoTable *)gMibObjs[ocStbHostCCAppInfoTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostCCAppInfoTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostCCAppInfoTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpCCAppInfoTableDataPtr = ( struct ccAppInfoTableData *) netsnmp_extract_iterator_context(request);
+		if ( tmpCCAppInfoTableDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpCCAppInfoTableDataPtr->index);
+
+        if (tmpCCAppInfoTableDataPtr->container.appName[0] == '\0')
+        {
+           netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
+           continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTCCAPPINFOINDEX:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpCCAppInfoTableDataPtr->container.appInfoIndex)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTCCAPPLICATIONTYPE:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpCCAppInfoTableDataPtr->container.appType)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTCCAPPLICATIONNAME:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpCCAppInfoTableDataPtr->container.appName)
+                                         , strlen(tmpCCAppInfoTableDataPtr->container.appName) );
+                break;
+
+            case COLUMN_OCSTBHOSTCCAPPLICATIONVERSION:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpCCAppInfoTableDataPtr->container.appVersion)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTCCAPPINFOPAGE:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpCCAppInfoTableDataPtr->container.appInfoPage)
+                                         , tmpCCAppInfoTableDataPtr->container.appInfoLen );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostCCAppInfoTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostCCAppInfoTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostCCAppInfoTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,26 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTCCAPPINFOTABLE_H
+#define OCSTBHOSTCCAPPINFOTABLE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostCCAppInfoTable(void);
+void            initialize_table_ocStbHostCCAppInfoTable(void);
+Netsnmp_Node_Handler ocStbHostCCAppInfoTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostCCAppInfoTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostCCAppInfoTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostCCAppInfoTable
+ */
+#define COLUMN_OCSTBHOSTCCAPPINFOINDEX		1
+#define COLUMN_OCSTBHOSTCCAPPLICATIONTYPE		2
+#define COLUMN_OCSTBHOSTCCAPPLICATIONNAME		3
+#define COLUMN_OCSTBHOSTCCAPPLICATIONVERSION		4
+#define COLUMN_OCSTBHOSTCCAPPINFOPAGE		5
+#endif                          /* OCSTBHOSTCCAPPINFOTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,411 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostComponentVideoTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "componentVideoTable.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostComponentVideoTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostComponentVideoTable(void)
+{
+    static oid      ocStbHostComponentVideoTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 5, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostComponentVideoTable",
+                                            ocStbHostComponentVideoTable_handler,
+                                            ocStbHostComponentVideoTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostComponentVideoTable_oid),
+											HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostComponentVideoIndex */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 4;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostComponentVideoTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostComponentVideoTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostComponentVideoTable",
+                "Registering table ocStbHostComponentVideoTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostComponentVideoTable module */
+void
+init_ocStbHostComponentVideoTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostComponentVideoTable];
+	mibObjectComponentVideoTable *pTblObj = (mibObjectComponentVideoTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostComponentVideoTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (checkAVInterfaceExistence(ocStbHostComponentOut, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateComponentVideo();	  /* MOE initialize ComponentVideo instrumentation */
+			initialize_table_ocStbHostComponentVideoTable();
+
+#if NEXUS_NUM_COMPONENT_OUTPUTS
+			for (i=0; i<NEXUS_NUM_COMPONENT_OUTPUTS; i++)
+			{
+	 			struct componentVideoEntry *pEntry = getComponentVideoEntry(i);
+	 			pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+#endif
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostComponentVideoTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostComponentVideoTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostComponentVideoTable_get_first_data_point(void **my_loop_context,
+                                                  void **my_data_context,
+                                                  netsnmp_variable_list *
+                                                  put_index_data,
+                                                  netsnmp_iterator_info
+                                                  *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct componentVideoEntry *tmpPtr;       /* MOE a pointer to the first entry */
+
+    tmpPtr = getComponentVideoEntry(0);       /* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostComponentVideoTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostComponentVideoTable_get_next_data_point(void **my_loop_context,
+                                                 void **my_data_context,
+                                                 netsnmp_variable_list *
+                                                 put_index_data,
+                                                 netsnmp_iterator_info
+                                                 *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct componentVideoEntry *tmpPtr;					/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostComponentVideoTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct componentVideoEntry *) *my_loop_context;
+
+	if (tmpPtr) {
+      tmpPtr = getComponentVideoEntry(tmpPtr->index);	/* get the next entry after this one */
+    }
+
+	if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)		  /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostComponentVideoTable table, if anything else needs to be done */
+int
+ocStbHostComponentVideoTable_handler(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct componentVideoData *tmpComponentVideoDataPtr;          /* MOE a pointer to some component video data */
+	mibObjectComponentVideoTable *pObj = (mibObjectComponentVideoTable *)gMibObjs[ocStbHostComponentVideoTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostComponentVideoTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostComponentVideoTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpComponentVideoDataPtr = ( struct componentVideoData *) netsnmp_extract_iterator_context(request);
+		if ( tmpComponentVideoDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpComponentVideoDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTCOMPONENTVIDEOCONSTRAINEDSTATUS:
+			{
+				int constrainedStatus = tmpComponentVideoDataPtr->container.constrainedStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(constrainedStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTCOMPONENTOUTPUTFORMAT:
+			{
+				int outputFormat;
+				switch (tmpComponentVideoDataPtr->container.outputFormat)
+				{
+					case NEXUS_VideoFormat_eNtsc:
+					case NEXUS_VideoFormat_eNtsc443:
+					case NEXUS_VideoFormat_eNtscJapan:
+						outputFormat = oc_videoOutputFormat_format480i;
+						break;
+					case NEXUS_VideoFormat_e480p:
+						outputFormat = oc_videoOutputFormat_format480p;
+						break;
+					case NEXUS_VideoFormat_e720p:
+					case NEXUS_VideoFormat_e720p50hz:
+					case NEXUS_VideoFormat_e720p24hz:
+						outputFormat = oc_videoOutputFormat_format720p;
+						break;
+					case NEXUS_VideoFormat_e1080i:
+					case NEXUS_VideoFormat_e1080i50hz:
+						outputFormat = oc_videoOutputFormat_format1080i;
+						break;
+					case NEXUS_VideoFormat_e1080p24hz:
+					case NEXUS_VideoFormat_e1080p25hz:
+					case NEXUS_VideoFormat_e1080p30hz:
+					case NEXUS_VideoFormat_e1080p50hz:
+					case NEXUS_VideoFormat_e1080p60hz:
+						outputFormat = oc_videoOutputFormat_format1080p;
+						break;
+					default:
+						/* ?? How to handle other NEXUS video formats ?? */
+						BDBG_WRN(("Unsupported video output format for the component video output found"));
+                        /* ?? set it to 1080i ?? */
+						outputFormat = oc_videoOutputFormat_format1080i;
+						break;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(outputFormat)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTCOMPONENTASPECTRATIO:
+			{
+				int aspectRatio;
+				switch (tmpComponentVideoDataPtr->container.aspectRatio)
+				{
+					case NEXUS_DisplayAspectRatio_e4x3:
+						aspectRatio = oc_videoAspectRatio_fourByThree;
+						break;
+					case NEXUS_DisplayAspectRatio_e16x9:
+						aspectRatio = oc_videoAspectRatio_sixteenByNine;
+						break;
+                    case NEXUS_DisplayAspectRatio_eAuto:
+                        switch (tmpComponentVideoDataPtr->container.outputFormat)
+                        {
+                            case NEXUS_VideoFormat_eNtsc:
+                            case NEXUS_VideoFormat_eNtsc443:
+                            case NEXUS_VideoFormat_eNtscJapan:
+                            case NEXUS_VideoFormat_e480p:
+                                aspectRatio = oc_videoAspectRatio_fourByThree;
+                                break;
+                            case NEXUS_VideoFormat_e720p:
+                            case NEXUS_VideoFormat_e720p50hz:
+                            case NEXUS_VideoFormat_e720p24hz:
+                            case NEXUS_VideoFormat_e1080i:
+                            case NEXUS_VideoFormat_e1080i50hz:
+                            case NEXUS_VideoFormat_e1080p24hz:
+                            case NEXUS_VideoFormat_e1080p25hz:
+                            case NEXUS_VideoFormat_e1080p30hz:
+                            case NEXUS_VideoFormat_e1080p50hz:
+                            case NEXUS_VideoFormat_e1080p60hz:
+                                aspectRatio = oc_videoAspectRatio_sixteenByNine;
+                                break;
+                            default:
+                                /* ?? set it 16x9 ?? */
+                                aspectRatio = oc_videoAspectRatio_sixteenByNine;
+                                break;
+                        }
+                        break;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(aspectRatio)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTCOMPONENTVIDEOMUTESTATUS:
+			{
+				int videoMuteStatus = tmpComponentVideoDataPtr->container.videoMuteStatus   ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(videoMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostComponentVideoTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostComponentVideoTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostComponentVideoTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,25 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTCOMPONENTVIDEOTABLE_H
+#define OCSTBHOSTCOMPONENTVIDEOTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostComponentVideoTable(void);
+void            initialize_table_ocStbHostComponentVideoTable(void);
+Netsnmp_Node_Handler ocStbHostComponentVideoTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostComponentVideoTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostComponentVideoTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostComponentVideoTable 
+ */
+#define COLUMN_OCSTBHOSTCOMPONENTVIDEOCONSTRAINEDSTATUS		1
+#define COLUMN_OCSTBHOSTCOMPONENTOUTPUTFORMAT		2
+#define COLUMN_OCSTBHOSTCOMPONENTASPECTRATIO		3
+#define COLUMN_OCSTBHOSTCOMPONENTVIDEOMUTESTATUS		4
+#endif                          /* OCSTBHOSTCOMPONENTVIDEOTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,246 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostContentErrorSummaryInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostContentErrorSummaryInfo module */
+void
+init_ocStbHostContentErrorSummaryInfo(void)
+{
+    static oid      ocStbHostPmtTimeoutCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 2, 0 };
+    static oid      ocStbHostInbandCarouselTimeoutCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 4, 0 };
+    static oid      ocStbHostPatTimeoutCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 1, 0 };
+    static oid      ocStbHostOobCarouselTimeoutCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 3, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostContentErrorSummaryInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostContentErrorSummaryInfo", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostPmtTimeoutCount",
+											 get_ocStbHostPmtTimeoutCount,
+											 ocStbHostPmtTimeoutCount_oid,
+											 OID_LENGTH
+											 (ocStbHostPmtTimeoutCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostInbandCarouselTimeoutCount",
+											 get_ocStbHostInbandCarouselTimeoutCount,
+											 ocStbHostInbandCarouselTimeoutCount_oid,
+											 OID_LENGTH
+											 (ocStbHostInbandCarouselTimeoutCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostPatTimeoutCount",
+											 get_ocStbHostPatTimeoutCount,
+											 ocStbHostPatTimeoutCount_oid,
+											 OID_LENGTH
+											 (ocStbHostPatTimeoutCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostOobCarouselTimeoutCount",
+											 get_ocStbHostOobCarouselTimeoutCount,
+											 ocStbHostOobCarouselTimeoutCount_oid,
+											 OID_LENGTH
+											 (ocStbHostOobCarouselTimeoutCount_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostPmtTimeoutCount(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+	mibObjectContentErrorSummaryInfo *pObj = (mibObjectContentErrorSummaryInfo *)gMibObjs[ocStbHostContentErrorSummaryInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.pmtTimeoutCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostInbandCarouselTimeoutCount(netsnmp_mib_handler *handler,
+                                        netsnmp_handler_registration
+                                        *reginfo,
+                                        netsnmp_agent_request_info
+                                        *reqinfo,
+                                        netsnmp_request_info *requests)
+{
+	mibObjectContentErrorSummaryInfo *pObj = (mibObjectContentErrorSummaryInfo *)gMibObjs[ocStbHostContentErrorSummaryInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.inbandCarouselTimeoutCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostPatTimeoutCount(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+	mibObjectContentErrorSummaryInfo *pObj = (mibObjectContentErrorSummaryInfo *)gMibObjs[ocStbHostContentErrorSummaryInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.patTimeoutCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostOobCarouselTimeoutCount(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+	mibObjectContentErrorSummaryInfo *pObj = (mibObjectContentErrorSummaryInfo *)gMibObjs[ocStbHostContentErrorSummaryInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.oobCarouselTimeoutCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostContentErrorSummaryInfo.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,17 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTCONTENTERRORSUMMARYINFO_H
+#define OCSTBHOSTCONTENTERRORSUMMARYINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostContentErrorSummaryInfo(void);
+Netsnmp_Node_Handler get_ocStbHostPmtTimeoutCount;
+Netsnmp_Node_Handler get_ocStbHostInbandCarouselTimeoutCount;
+Netsnmp_Node_Handler get_ocStbHostPatTimeoutCount;
+Netsnmp_Node_Handler get_ocStbHostOobCarouselTimeoutCount;
+
+#endif                          /* OCSTBHOSTCONTENTERRORSUMMARYINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,192 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostDeviceSoftwareBase.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostDeviceSoftwareBase module */
+void
+init_ocStbHostDeviceSoftwareBase(void)
+{
+    static oid      ocStbHostSoftwareFirmwareReleaseDate_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 1, 3, 0 };
+    static oid      ocStbHostSoftwareFirmwareVersion_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 1, 1, 0 };
+    static oid      ocStbHostSoftwareOCAPVersion_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 1, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostDeviceSoftwareBase];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostDeviceSoftwareBase", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostSoftwareFirmwareReleaseDate",
+											 get_ocStbHostSoftwareFirmwareReleaseDate,
+											 ocStbHostSoftwareFirmwareReleaseDate_oid,
+											 OID_LENGTH
+											 (ocStbHostSoftwareFirmwareReleaseDate_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostSoftwareFirmwareVersion",
+											 get_ocStbHostSoftwareFirmwareVersion,
+											 ocStbHostSoftwareFirmwareVersion_oid,
+											 OID_LENGTH
+											 (ocStbHostSoftwareFirmwareVersion_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostSoftwareOCAPVersion",
+											 get_ocStbHostSoftwareOCAPVersion,
+											 ocStbHostSoftwareOCAPVersion_oid,
+											 OID_LENGTH
+											 (ocStbHostSoftwareOCAPVersion_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostSoftwareFirmwareReleaseDate(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+	mibObjectDeviceSoftwareBase *pObj = (mibObjectDeviceSoftwareBase *)gMibObjs[ocStbHostDeviceSoftwareBase].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.releaseDate)
+                                 ,
+                                 8
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostSoftwareFirmwareVersion(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+	mibObjectDeviceSoftwareBase *pObj = (mibObjectDeviceSoftwareBase *)gMibObjs[ocStbHostDeviceSoftwareBase].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.firmwareVersion)
+                                 ,
+                                 strlen(pObj->container.firmwareVersion)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostSoftwareOCAPVersion(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+	mibObjectDeviceSoftwareBase *pObj = (mibObjectDeviceSoftwareBase *)gMibObjs[ocStbHostDeviceSoftwareBase].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.OCAPVersion)
+                                 ,
+                                 strlen(pObj->container.OCAPVersion)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDeviceSoftwareBase.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTDEVICESOFTWAREBASE_H
+#define OCSTBHOSTDEVICESOFTWAREBASE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostDeviceSoftwareBase(void);
+Netsnmp_Node_Handler get_ocStbHostSoftwareFirmwareReleaseDate;
+Netsnmp_Node_Handler get_ocStbHostSoftwareFirmwareVersion;
+Netsnmp_Node_Handler get_ocStbHostSoftwareOCAPVersion;
+
+#endif                          /* OCSTBHOSTDEVICESOFTWAREBASE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,390 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostDumpTrapInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostDumpTrapInfo module */
+void
+init_ocStbHostDumpTrapInfo(void)
+{
+    static oid      ocStbHostDumpEventTimeout_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 3, 0 };
+    static oid      ocStbHostDumpEventCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 1, 0 };
+    static oid      ocStbHostDumpNow_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 2, 0 };
+    static oid      ocStbHostDumpFilePath_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 4, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostDumpTrapInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostDumpTrapInfo", "Initializing\n"));
+
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostDumpEventTimeout",
+								   do_ocStbHostDumpEventTimeout,
+								   ocStbHostDumpEventTimeout_oid,
+								   OID_LENGTH(ocStbHostDumpEventTimeout_oid),
+								   HANDLER_CAN_RWRITE));
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostDumpEventCount",
+								   do_ocStbHostDumpEventCount,
+								   ocStbHostDumpEventCount_oid,
+								   OID_LENGTH(ocStbHostDumpEventCount_oid),
+								   HANDLER_CAN_RWRITE));
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostDumpNow",
+								   do_ocStbHostDumpNow,
+								   ocStbHostDumpNow_oid,
+								   OID_LENGTH(ocStbHostDumpNow_oid),
+								   HANDLER_CAN_RWRITE));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostDumpFilePath",
+											 get_ocStbHostDumpFilePath,
+											 ocStbHostDumpFilePath_oid,
+											 OID_LENGTH
+											 (ocStbHostDumpFilePath_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+do_ocStbHostDumpEventTimeout(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+	mibObjectDumpTrapInfo *pObj = (mibObjectDumpTrapInfo *)gMibObjs[ocStbHostDumpTrapInfo].obj;
+	unsigned newDumpEventTimeout = 0;
+	static unsigned oldDumpEventTimeout = 0;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+    BDBG_ASSERT(pObj->set_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.dumpEventTimeout)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         */
+    case MODE_SET_RESERVE1:
+        /*
+         * check type
+         */
+        if (requests->requestvb->type != ASN_UNSIGNED) {
+            /*
+             * not an integer.  Bad dog, no bone.
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGTYPE);
+			return;
+        }
+		/*
+		 * check value
+		 */
+		if ( *requests->requestvb->val.integer < 1 || *requests->requestvb->val.integer > 120 ) {
+			/*
+			 * the value must be in the range of (1..120).
+			 */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGVALUE
+                                      );
+			return;
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        break;
+
+    case MODE_SET_FREE:
+        break;
+
+    case MODE_SET_ACTION:
+		oldDumpEventTimeout = pObj->container.dumpEventTimeout;
+		newDumpEventTimeout = *requests->requestvb->val.integer;
+		pObj->set_callback((void *) &newDumpEventTimeout, DUMP_EVENT_TIMEOUT);
+        break;
+
+    case MODE_SET_COMMIT:
+        break;
+
+    case MODE_SET_UNDO:
+		newDumpEventTimeout = oldDumpEventTimeout;
+		oldDumpEventTimeout = 0;
+		pObj->set_callback((void *) &newDumpEventTimeout, DUMP_EVENT_TIMEOUT);
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostDumpEventCount(netsnmp_mib_handler *handler,
+                           netsnmp_handler_registration *reginfo,
+                           netsnmp_agent_request_info *reqinfo,
+                           netsnmp_request_info *requests)
+{
+	mibObjectDumpTrapInfo *pObj = (mibObjectDumpTrapInfo *)gMibObjs[ocStbHostDumpTrapInfo].obj;
+	int newDumpEventCount = 0;
+	static int oldDumpEventCount = 0;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+    BDBG_ASSERT(pObj->set_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.dumpEventCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         */
+    case MODE_SET_RESERVE1:
+        /*
+         * check type
+         */
+        if (requests->requestvb->type != ASN_INTEGER) {
+            /*
+             * not an integer.  Bad dog, no bone.
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGTYPE);
+			return;
+        }
+		/*
+		 * check value
+		 */
+		if ( *requests->requestvb->val.integer < 0 || *requests->requestvb->val.integer > 32 ) {
+			/*
+			 * the value must be in the range of (0..32).
+			 */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGVALUE
+                                      );
+			return;
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        break;
+
+    case MODE_SET_FREE:
+        break;
+
+    case MODE_SET_ACTION:
+		oldDumpEventCount = pObj->container.dumpEventCount;
+		newDumpEventCount = *requests->requestvb->val.integer;
+		pObj->set_callback((void *) &newDumpEventCount, DUMP_EVENT_COUNT);
+        break;
+
+    case MODE_SET_COMMIT:
+        break;
+
+    case MODE_SET_UNDO:
+		newDumpEventCount = oldDumpEventCount;
+		oldDumpEventCount = 0;
+		pObj->set_callback((void *) &newDumpEventCount, DUMP_EVENT_COUNT);
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostDumpNow(netsnmp_mib_handler *handler,
+                    netsnmp_handler_registration *reginfo,
+                    netsnmp_agent_request_info *reqinfo,
+                    netsnmp_request_info *requests)
+{
+	mibObjectDumpTrapInfo *pObj = (mibObjectDumpTrapInfo *)gMibObjs[ocStbHostDumpTrapInfo].obj;
+	int dumpNow = oc_false; /* always return false when query */
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+    BDBG_ASSERT(pObj->set_callback);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(dumpNow)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         */
+    case MODE_SET_RESERVE1:
+        /*
+         * check type
+         */
+        if (requests->requestvb->type != ASN_INTEGER) {
+            /*
+             * not an integer.  Bad dog, no bone.
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGTYPE);
+			return;
+        }
+		/*
+		 * check value
+		 */
+		if ( *requests->requestvb->val.integer != 1 ) {
+			/*
+			 * the value must be 1.
+			 */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGVALUE
+                                      );
+			return;
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        break;
+
+    case MODE_SET_FREE:
+        break;
+
+    case MODE_SET_ACTION:
+		pObj->set_callback(NULL, DUMP_NOW);
+        break;
+
+    case MODE_SET_COMMIT:
+        break;
+
+    case MODE_SET_UNDO:
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostDumpFilePath(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectDumpTrapInfo *pObj = (mibObjectDumpTrapInfo *)gMibObjs[ocStbHostDumpTrapInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+    BDBG_ASSERT(pObj->set_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.dumpFilePath)
+                                 ,
+                                 strlen(pObj->container.dumpFilePath)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDumpTrapInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,17 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTDUMPTRAPINFO_H
+#define OCSTBHOSTDUMPTRAPINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostDumpTrapInfo(void);
+Netsnmp_Node_Handler do_ocStbHostDumpEventTimeout;
+Netsnmp_Node_Handler do_ocStbHostDumpEventCount;
+Netsnmp_Node_Handler do_ocStbHostDumpNow;
+Netsnmp_Node_Handler get_ocStbHostDumpFilePath;
+
+#endif                          /* OCSTBHOSTDUMPTRAPINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,333 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostDVIHDMIAvailableVideoFormatTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "dviHdmiAvailableVideoFormatTable.h"
+
+/** Initialize the ocStbHostDVIHDMIAvailableVideoFormatTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostDVIHDMIAvailableVideoFormatTable(void)
+{
+    static oid      ocStbHostDVIHDMIAvailableVideoFormatTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 4, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostDVIHDMIAvailableVideoFormatTable",
+         ocStbHostDVIHDMIAvailableVideoFormatTable_handler,
+         ocStbHostDVIHDMIAvailableVideoFormatTable_oid,
+         OID_LENGTH(ocStbHostDVIHDMIAvailableVideoFormatTable_oid),
+         HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ocStbHostDVIHDMIAvailableVideoFormatIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 4;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostDVIHDMIAvailableVideoFormatTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostDVIHDMIAvailableVideoFormatTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostDVIHDMIAvailableVideoFormatTable", "Registering table ocStbHostDVIHDMIAvailableVideoFormatTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostDVIHDMIAvailableVideoFormatTable module */
+void
+init_ocStbHostDVIHDMIAvailableVideoFormatTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostDVIHDMIAvailableVideoFormatTable];
+	mibObjectDviHdmiAvailableVideoFormatTable *pTblObj = (mibObjectDviHdmiAvailableVideoFormatTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostDVIHDMIAvailableVideoFormatTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (   checkAVInterfaceExistence(ocStbHostDviOut, NULL)
+			|| checkAVInterfaceExistence(ocStbHostHdmiOut, NULL))
+		{
+		    /*
+		     * here we initialize all the tables we're planning on supporting
+		     */
+            activateDviHdmiAvailableVideoFormat();	  /* MOE initialize DVIHDMIAvailableVideoFormat instrumentation */
+		    initialize_table_ocStbHostDVIHDMIAvailableVideoFormatTable();
+
+			for (i=0; i<NUM_HDMI_AVAIL_VIDEO_FORMATS; i++)
+			{
+				struct dviHdmiAvailableVideoFormatEntry *pEntry = getDviHdmiAvailableVideoFormatEntry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostDVIHDMIAvailableVideoFormatTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostDVIHDMIAvailableVideoFormatTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostDVIHDMIAvailableVideoFormatTable_get_first_data_point(void
+                                                               **my_loop_context,
+                                                               void
+                                                               **my_data_context,
+                                                               netsnmp_variable_list
+                                                               *
+                                                               put_index_data,
+                                                               netsnmp_iterator_info
+                                                               *mydata)
+{
+    netsnmp_variable_list *vptr;
+    struct dviHdmiAvailableVideoFormatEntry *tmpPtr;  			/* MOE a pointer to the first entry */
+
+    tmpPtr = getDviHdmiAvailableVideoFormatEntry(0);         	/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                   					/* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		/* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostDVIHDMIAvailableVideoFormatTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostDVIHDMIAvailableVideoFormatTable_get_next_data_point(void
+                                                              **my_loop_context,
+                                                              void
+                                                              **my_data_context,
+                                                              netsnmp_variable_list
+                                                              *
+                                                              put_index_data,
+                                                              netsnmp_iterator_info
+                                                              *mydata)
+{
+    netsnmp_variable_list *vptr;
+    struct dviHdmiAvailableVideoFormatEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostDVIHDMIAvailableVideoFormatTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct dviHdmiAvailableVideoFormatEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getDviHdmiAvailableVideoFormatEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		  /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostDVIHDMIAvailableVideoFormatTable table, if anything else needs to be done */
+int
+ocStbHostDVIHDMIAvailableVideoFormatTable_handler(netsnmp_mib_handler
+                                                  *handler,
+                                                  netsnmp_handler_registration
+                                                  *reginfo,
+                                                  netsnmp_agent_request_info
+                                                  *reqinfo,
+                                                  netsnmp_request_info
+                                                  *requests)
+{
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct dviHdmiAvailableVideoFormatData *tmpDviHdmiAvailableVideoFormatDataPtr;          /* MOE a pointer to some DVIHDMIAvailableVideoFormat data */
+	mibObjectDviHdmiAvailableVideoFormatTable *pObj = (mibObjectDviHdmiAvailableVideoFormatTable *)gMibObjs[ocStbHostDVIHDMIAvailableVideoFormatTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostDVIHDMIAvailableVideoFormatTable_handler() enter\n"); */
+
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostDVIHDMIAvailableVideoFormatTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpDviHdmiAvailableVideoFormatDataPtr = ( struct dviHdmiAvailableVideoFormatData *) netsnmp_extract_iterator_context(request);
+		if ( tmpDviHdmiAvailableVideoFormatDataPtr	== NULL) {
+		   if (reqinfo->mode == MODE_GET) {
+			   netsnmp_set_request_error(reqinfo, request,
+										 SNMP_NOSUCHINSTANCE);
+			   continue;
+		   }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpDviHdmiAvailableVideoFormatDataPtr->index);
+
+        if (tmpDviHdmiAvailableVideoFormatDataPtr->index >= tmpDviHdmiAvailableVideoFormatDataPtr->container.numSupportedVideoDescriptors)
+        {
+           netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
+           continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMAT:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpDviHdmiAvailableVideoFormatDataPtr->container.availableVideoFormat)
+                                         , sizeof(unsigned) );
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMISUPPORTED3DSTRUCTURES:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) &(tmpDviHdmiAvailableVideoFormatDataPtr->container.supported3DStructures)
+                                         , sizeof(short) );
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIACTIVE3DSTRUCTURE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpDviHdmiAvailableVideoFormatDataPtr->container.active3DStructure)
+                                         , sizeof(int) );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostDVIHDMIAvailableVideoFormatTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostDVIHDMIAvailableVideoFormatTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,28 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMATTABLE_H
+#define OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMATTABLE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostDVIHDMIAvailableVideoFormatTable(void);
+void
+initialize_table_ocStbHostDVIHDMIAvailableVideoFormatTable(void);
+Netsnmp_Node_Handler ocStbHostDVIHDMIAvailableVideoFormatTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostDVIHDMIAvailableVideoFormatTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostDVIHDMIAvailableVideoFormatTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostDVIHDMIAvailableVideoFormatTable
+ */
+#define COLUMN_OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMATINDEX		1
+#define COLUMN_OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMAT		2
+#define COLUMN_OCSTBHOSTDVIHDMISUPPORTED3DSTRUCTURES		3
+#define COLUMN_OCSTBHOSTDVIHDMIACTIVE3DSTRUCTURE		4
+#endif                          /* OCSTBHOSTDVIHDMIAVAILABLEVIDEOFORMATTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,724 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostDVIHDMITable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "dviHdmiTable.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostDVIHDMITable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostDVIHDMITable(void)
+{
+    static oid      ocStbHostDVIHDMITable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 4, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostDVIHDMITable",
+                                            ocStbHostDVIHDMITable_handler,
+                                            ocStbHostDVIHDMITable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostDVIHDMITable_oid),
+											HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostDVIHDMIIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 27;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostDVIHDMITable_get_first_data_point;
+    iinfo->get_next_data_point = ocStbHostDVIHDMITable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostDVIHDMITable",
+                "Registering table ocStbHostDVIHDMITable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostDVIHDMITable module */
+void
+init_ocStbHostDVIHDMITable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostDVIHDMITable];
+	mibObjectDviHdmiTable *pTblObj = (mibObjectDviHdmiTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostDVIHDMITable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (   checkAVInterfaceExistence(ocStbHostDviOut, NULL)
+			|| checkAVInterfaceExistence(ocStbHostHdmiOut, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateDviHdmi();	  /* MOE initialize DVIHDMI instrumentation */
+			initialize_table_ocStbHostDVIHDMITable();
+
+#if NEXUS_NUM_HDMI_OUTPUTS
+			for (i=0; i<NEXUS_NUM_HDMI_OUTPUTS; i++)
+			{
+	 			struct dviHdmiEntry *pEntry = getDviHdmiEntry(i);
+ 				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+#endif
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostDVIHDMITable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostDVIHDMITable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostDVIHDMITable_get_first_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct dviHdmiEntry *tmpPtr;  			/* MOE a pointer to the first entry */
+
+    tmpPtr = getDviHdmiEntry(0);         	/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                   /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+					   (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)	    /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostDVIHDMITable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostDVIHDMITable_get_next_data_point(void **my_loop_context,
+                                          void **my_data_context,
+                                          netsnmp_variable_list *
+                                          put_index_data,
+                                          netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct dviHdmiEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostDVIHDMITable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct dviHdmiEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getDviHdmiEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)		  /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostDVIHDMITable table, if anything else needs to be done */
+int
+ocStbHostDVIHDMITable_handler(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct dviHdmiData *tmpDviHdmiDataPtr;          /* MOE a pointer to some DVIHDMI data */
+	mibObjectDviHdmiTable *pObj = (mibObjectDviHdmiTable *)gMibObjs[ocStbHostDVIHDMITable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostDVIHDMITable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostDVIHDMITable table in question
+         */
+	     /* MOE extract the data pointer */
+		 tmpDviHdmiDataPtr = ( struct dviHdmiData *) netsnmp_extract_iterator_context(request);
+		 if ( tmpDviHdmiDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpDviHdmiDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTDVIHDMIOUTPUTTYPE:
+			{
+				int outputType = tmpDviHdmiDataPtr->container.hdmiDevice ? oc_outputType_hdmi : oc_outputType_dvi;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(outputType)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMICONNECTIONSTATUS:
+			{
+				int connectionStatus = tmpDviHdmiDataPtr->container.connectionStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(connectionStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIREPEATERSTATUS:
+			{
+				int repeaterStatus = tmpDviHdmiDataPtr->container.hdcpStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(repeaterStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIVIDEOXMISSIONSTATUS:
+			{
+				int videoXMissionStatus = tmpDviHdmiDataPtr->container.videoXMissionStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(videoXMissionStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIHDCPSTATUS:
+			{
+				int hdcpStatus = tmpDviHdmiDataPtr->container.hdcpStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(hdcpStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIVIDEOMUTESTATUS:
+			{
+				int videoMuteStatus = tmpDviHdmiDataPtr->container.videoMuteStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(videoMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIOUTPUTFORMAT:
+			{
+				int outputFormat;
+				switch (tmpDviHdmiDataPtr->container.outputFormat)
+				{
+					case NEXUS_VideoFormat_eNtsc:
+					case NEXUS_VideoFormat_eNtsc443:
+					case NEXUS_VideoFormat_eNtscJapan:
+						outputFormat = oc_videoOutputFormat_format480i;
+						break;
+					case NEXUS_VideoFormat_e480p:
+						outputFormat = oc_videoOutputFormat_format480p;
+						break;
+					case NEXUS_VideoFormat_e720p:
+					case NEXUS_VideoFormat_e720p50hz:
+					case NEXUS_VideoFormat_e720p24hz:
+						outputFormat = oc_videoOutputFormat_format720p;
+						break;
+					case NEXUS_VideoFormat_e1080i:
+					case NEXUS_VideoFormat_e1080i50hz:
+						outputFormat = oc_videoOutputFormat_format1080i;
+						break;
+					case NEXUS_VideoFormat_e1080p24hz:
+					case NEXUS_VideoFormat_e1080p25hz:
+					case NEXUS_VideoFormat_e1080p30hz:
+					case NEXUS_VideoFormat_e1080p50hz:
+					case NEXUS_VideoFormat_e1080p60hz:
+						outputFormat = oc_videoOutputFormat_format1080p;
+						break;
+					default:
+						break;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(outputFormat)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIASPECTRATIO:
+			{
+				int aspectRatio;
+				switch (tmpDviHdmiDataPtr->container.aspectRatio)
+				{
+					case NEXUS_AspectRatio_e4x3:
+						aspectRatio = oc_videoAspectRatio_fourByThree;
+						break;
+					case NEXUS_AspectRatio_e16x9:
+						aspectRatio = oc_videoAspectRatio_sixteenByNine;
+						break;
+					default:
+						aspectRatio = oc_videoAspectRatio_other;
+						break;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(aspectRatio)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIHOSTDEVICEHDCPSTATUS:
+			{
+				/*
+				 * What does 'compliantHDCPdevice' mean?
+				 * If the spec is referring to the real meaning of HDCP compliance,
+				 * there is no way our STB can tell whether the device is compliant.
+				 * Again, that is where the HDCP compliance test labs come in.
+				 *
+				 * Now, the only thing we can do here is to check if the attached device is HDCP capable.
+				 * If NEXUS_HdmiOutput_GetHdcpStatus successfully retuns, we can read the device BCaps
+				 * which means the device is capable of HDCP.
+				 *
+				 * Again, what does 'revokedHDCPdevice' mean?
+				 * The driver/PI does not have any knowledge of this.
+				 * The application supposes to pass the revoked KSV list down to the driver-->PI,
+				 * not the other way around. (We don't even know how to handle this case!)
+				 */
+
+				int hostDeviceHdcpStatus = tmpDviHdmiDataPtr->container.hostDeviceHdcpStatus ? oc_hdcpStatus_compliantHDCPdevice : oc_hdcpStatus_nonHDCPdevice;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(hostDeviceHdcpStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIAUDIOFORMAT:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int audioFormat;
+					switch (tmpDviHdmiDataPtr->container.audioFormat)
+					{
+						case NEXUS_AudioCodec_ePcm:
+							audioFormat = oc_audioOutputFormat_lpcm;
+							break;
+						case NEXUS_AudioCodec_eAc3:
+							audioFormat = oc_audioOutputFormat_ac3;
+							break;
+						case NEXUS_AudioCodec_eAc3Plus:
+							audioFormat = oc_audioOutputFormat_eac3;
+							break;
+						case NEXUS_AudioCodec_eMpeg:
+							audioFormat = oc_audioOutputFormat_mpeg1L1L2;
+							break;
+						case NEXUS_AudioCodec_eMp3:
+							audioFormat = oc_audioOutputFormat_mpeg1L3;
+							break;
+						case NEXUS_AudioCodec_eAac:
+							audioFormat = oc_audioOutputFormat_mpeg2;
+							break;
+						case NEXUS_AudioCodec_eAacPlus:
+							audioFormat = oc_audioOutputFormat_mpeg4;
+							break;
+						case NEXUS_AudioCodec_eDts:
+							audioFormat = oc_audioOutputFormat_dts;
+							break;
+#if 0
+						/*
+						 * The following codec is not supported yet, see NEXUS_HdmiOutput_GetStatus()
+						 * for more information.
+						 */
+						case NEXUS_AudioCodec_eAtrac:
+							audioFormat = oc_audioOutputFormat_atrac;
+							break;
+#endif
+						default:
+							audioFormat = oc_audioOutputFormat_other;
+							break;
+					}
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(audioFormat)
+											 , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIAUDIOSAMPLERATE:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int audioSampleRate;
+					switch (tmpDviHdmiDataPtr->container.audioSampleRate)
+					{
+						case 32000:
+							audioSampleRate = oc_audioSampleRate_samplerate32kHz;
+							break;
+						case 44100:
+							audioSampleRate = oc_audioSampleRate_samplerate44kHz;
+							break;
+						case 48000:
+							audioSampleRate = oc_audioSampleRate_samplerate48kHz;
+							break;
+						case 88200:
+							audioSampleRate = oc_audioSampleRate_samplerate88kHz;
+							break;
+						case 96000:
+							audioSampleRate = oc_audioSampleRate_samplerate96kHz;
+							break;
+						case 176400:
+							audioSampleRate = oc_audioSampleRate_samplerate176kHz;
+							break;
+						case 192000:
+							audioSampleRate = oc_audioSampleRate_samplerate192kHz;
+							break;
+						default:
+							audioSampleRate = oc_audioSampleRate_other;
+							break;
+					}
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(audioSampleRate)
+											 , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIAUDIOCHANNELCOUNT:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int audioChannelCount = tmpDviHdmiDataPtr->container.audioChannelCount;
+					snmp_set_var_typed_value(var, ASN_UNSIGNED,
+											 (u_char *) &(audioChannelCount)
+											 , sizeof(unsigned int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIAUDIOMUTESTATUS:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int audioMuteStatus = tmpDviHdmiDataPtr->container.audioMuteStatus ? oc_true : oc_false;
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(audioMuteStatus)
+											 , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIAUDIOSAMPLESIZE:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int audioSampleSize;
+					switch (tmpDviHdmiDataPtr->container.audioSampleSize)
+					{
+						case 16:
+							audioSampleSize = oc_audioSampleSize_sample16Bit;
+							break;
+						case 20:
+							audioSampleSize = oc_audioSampleSize_sample20Bit;
+							break;
+						case 24:
+							audioSampleSize = oc_audioSampleSize_sample24Bit;
+							break;
+						default:
+							audioSampleSize = oc_audioSampleSize_notValid;
+							break;
+					}
+                	snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(audioSampleSize)
+											 , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMICOLORSPACE:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int colorSpace;
+					switch (tmpDviHdmiDataPtr->container.colorSpace)
+					{
+						case NEXUS_ColorSpace_eRgb:
+							colorSpace = oc_colorSpace_rgb;
+							break;
+						case NEXUS_ColorSpace_eYCbCr422:
+							colorSpace = oc_colorSpace_ycc422;
+							break;
+						case NEXUS_ColorSpace_eYCbCr444:
+							colorSpace = oc_colorSpace_ycc444;
+							break;
+					}
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(colorSpace)
+											 , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIFRAMERATE:
+			{
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					int frameRateCode;
+					switch (tmpDviHdmiDataPtr->container.frameRate)
+					{
+						case NEXUS_VideoFrameRate_e23_976:
+							frameRateCode = oc_frameRateCode1;
+							break;
+						case NEXUS_VideoFrameRate_e24:
+							frameRateCode = oc_frameRateCode2;
+							break;
+						case NEXUS_VideoFrameRate_e29_97:
+							frameRateCode = oc_frameRateCode3;
+							break;
+						case NEXUS_VideoFrameRate_e30:
+							frameRateCode = oc_frameRateCode4;
+							break;
+						case NEXUS_VideoFrameRate_e59_94:
+							frameRateCode = oc_frameRateCode5;
+							break;
+						case NEXUS_VideoFrameRate_e60:
+							frameRateCode = oc_frameRateCode6;
+							break;
+						default:
+							BDBG_ERR(("Unsupported Frame rate for HDMI output found"));
+							break;
+					}
+	                snmp_set_var_typed_value(var, ASN_INTEGER,
+	                                         (u_char *) &(frameRateCode)
+	                                         , sizeof(int) );
+				}
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTDVIHDMIATTACHEDDEVICETYPE:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(tmpDviHdmiDataPtr->container.attachedDeviceType)
+											 , sizeof(int) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIEDID:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_OCTET_STR,
+											 (u_char *) (tmpDviHdmiDataPtr->container.edid)
+											 , sizeof(tmpDviHdmiDataPtr->container.edid) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMILIPSYNCDELAY:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(tmpDviHdmiDataPtr->container.lipSyncDelay)
+											 , sizeof(int) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMICECFEATURES:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_OCTET_STR,
+											 (u_char *) &(tmpDviHdmiDataPtr->container.cecFeatures)
+											 , sizeof(short) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIFEATURES:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_OCTET_STR,
+											 (u_char *) &(tmpDviHdmiDataPtr->container.features)
+											 , sizeof(char) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIMAXDEVICECOUNT:
+				if (tmpDviHdmiDataPtr->container.hdmiDevice)
+				{
+					snmp_set_var_typed_value(var, ASN_INTEGER,
+											 (u_char *) &(tmpDviHdmiDataPtr->container.maxDeviceCount)
+											 , sizeof(unsigned) );
+				}
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIPREFERREDVIDEOFORMAT:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpDviHdmiDataPtr->container.preferredVideoFormat)
+                                         , sizeof(unsigned) );
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMIEDIDVERSION:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) &(tmpDviHdmiDataPtr->container.edidVersion)
+                                         , sizeof(tmpDviHdmiDataPtr->container.edidVersion) );
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMI3DCOMPATIBILITYCONTROL:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpDviHdmiDataPtr->container.threeDCompatibilityControl)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTDVIHDMI3DCOMPATIBILITYMSGDISPLAY:
+			{
+				int msgDisplay = tmpDviHdmiDataPtr->container.threeDCompatibilityMsgDisplay ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(msgDisplay)
+                                         , sizeof(int) );
+                break;
+            }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostDVIHDMITable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostDVIHDMITable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostDVIHDMITable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,47 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTDVIHDMITABLE_H
+#define OCSTBHOSTDVIHDMITABLE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostDVIHDMITable(void);
+void            initialize_table_ocStbHostDVIHDMITable(void);
+Netsnmp_Node_Handler ocStbHostDVIHDMITable_handler;
+
+Netsnmp_First_Data_Point ocStbHostDVIHDMITable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostDVIHDMITable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostDVIHDMITable
+ */
+#define COLUMN_OCSTBHOSTDVIHDMIOUTPUTTYPE		2
+#define COLUMN_OCSTBHOSTDVIHDMICONNECTIONSTATUS		3
+#define COLUMN_OCSTBHOSTDVIHDMIREPEATERSTATUS		4
+#define COLUMN_OCSTBHOSTDVIHDMIVIDEOXMISSIONSTATUS		5
+#define COLUMN_OCSTBHOSTDVIHDMIHDCPSTATUS		6
+#define COLUMN_OCSTBHOSTDVIHDMIVIDEOMUTESTATUS		7
+#define COLUMN_OCSTBHOSTDVIHDMIOUTPUTFORMAT		8
+#define COLUMN_OCSTBHOSTDVIHDMIASPECTRATIO		9
+#define COLUMN_OCSTBHOSTDVIHDMIHOSTDEVICEHDCPSTATUS		10
+#define COLUMN_OCSTBHOSTDVIHDMIAUDIOFORMAT		11
+#define COLUMN_OCSTBHOSTDVIHDMIAUDIOSAMPLERATE		12
+#define COLUMN_OCSTBHOSTDVIHDMIAUDIOCHANNELCOUNT		13
+#define COLUMN_OCSTBHOSTDVIHDMIAUDIOMUTESTATUS		14
+#define COLUMN_OCSTBHOSTDVIHDMIAUDIOSAMPLESIZE		15
+#define COLUMN_OCSTBHOSTDVIHDMICOLORSPACE		16
+#define COLUMN_OCSTBHOSTDVIHDMIFRAMERATE		17
+#define COLUMN_OCSTBHOSTDVIHDMIATTACHEDDEVICETYPE		18
+#define COLUMN_OCSTBHOSTDVIHDMIEDID		19
+#define COLUMN_OCSTBHOSTDVIHDMILIPSYNCDELAY		20
+#define COLUMN_OCSTBHOSTDVIHDMICECFEATURES		21
+#define COLUMN_OCSTBHOSTDVIHDMIFEATURES		22
+#define COLUMN_OCSTBHOSTDVIHDMIMAXDEVICECOUNT		23
+#define COLUMN_OCSTBHOSTDVIHDMIPREFERREDVIDEOFORMAT		24
+#define COLUMN_OCSTBHOSTDVIHDMIEDIDVERSION		25
+#define COLUMN_OCSTBHOSTDVIHDMI3DCOMPATIBILITYCONTROL		26
+#define COLUMN_OCSTBHOSTDVIHDMI3DCOMPATIBILITYMSGDISPLAY		27
+#endif                          /* OCSTBHOSTDVIHDMITABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,192 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostEasCodes.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostEasCodes module */
+void
+init_ocStbHostEasCodes(void)
+{
+    static oid      ocStbEasMessageStateCode_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 3, 1, 1, 0 };
+    static oid      ocStbEasMessageCountyCode_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 3, 1, 2, 0 };
+    static oid      ocStbEasMessageCountySubdivisionCode_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 3, 1, 3, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostEasCodes];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostEasCodes", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbEasMessageStateCode",
+											 get_ocStbEasMessageStateCode,
+											 ocStbEasMessageStateCode_oid,
+											 OID_LENGTH
+											 (ocStbEasMessageStateCode_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbEasMessageCountyCode",
+											 get_ocStbEasMessageCountyCode,
+											 ocStbEasMessageCountyCode_oid,
+											 OID_LENGTH
+											 (ocStbEasMessageCountyCode_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbEasMessageCountySubdivisionCode",
+											 get_ocStbEasMessageCountySubdivisionCode,
+											 ocStbEasMessageCountySubdivisionCode_oid,
+											 OID_LENGTH
+											 (ocStbEasMessageCountySubdivisionCode_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbEasMessageStateCode(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+	mibObjectEasCodes *pObj = (mibObjectEasCodes *)gMibObjs[ocStbHostEasCodes].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.stateCode)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbEasMessageCountyCode(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+	mibObjectEasCodes *pObj = (mibObjectEasCodes *)gMibObjs[ocStbHostEasCodes].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.countyCode)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbEasMessageCountySubdivisionCode(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+	mibObjectEasCodes *pObj = (mibObjectEasCodes *)gMibObjs[ocStbHostEasCodes].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.subDivisionCode)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostEasCodes.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTEASCODES_H
+#define OCSTBHOSTEASCODES_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostEasCodes(void);
+Netsnmp_Node_Handler get_ocStbEasMessageStateCode;
+Netsnmp_Node_Handler get_ocStbEasMessageCountyCode;
+Netsnmp_Node_Handler get_ocStbEasMessageCountySubdivisionCode;
+
+#endif                          /* OCSTBHOSTEASCODES_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,360 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostFirmwareDownloadStatus.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostFirmwareDownloadStatus module */
+void
+init_ocStbHostFirmwareDownloadStatus(void)
+{
+    static oid      ocStbHostFirmwareDownloadFailedStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 4, 0 };
+    static oid      ocStbHostFirmwareCodeObjectName_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 3, 0 };
+	static oid		ocStbHostFirmwareDownloadFailedCount_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 5, 0 };
+    static oid      ocStbHostFirmwareDownloadGroupId_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 6, 0 };
+    static oid      ocStbHostFirmwareImageStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 1, 0 };
+    static oid      ocStbHostFirmwareCodeDownloadStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 2, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostFirmwareDownloadStatus];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostFirmwareDownloadStatus", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostFirmwareDownloadFailedStatus",
+											 get_ocStbHostFirmwareDownloadFailedStatus,
+											 ocStbHostFirmwareDownloadFailedStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostFirmwareDownloadFailedStatus_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostFirmwareCodeObjectName",
+											 get_ocStbHostFirmwareCodeObjectName,
+											 ocStbHostFirmwareCodeObjectName_oid,
+											 OID_LENGTH
+											 (ocStbHostFirmwareCodeObjectName_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostFirmwareDownloadFailedCount",
+											 get_ocStbHostFirmwareDownloadFailedCount,
+											 ocStbHostFirmwareDownloadFailedCount_oid,
+											 OID_LENGTH
+											 (ocStbHostFirmwareDownloadFailedCount_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbHostFirmwareDownloadGroupId",
+                                         get_ocStbHostFirmwareDownloadGroupId,
+                                         ocStbHostFirmwareDownloadGroupId_oid,
+                                         OID_LENGTH
+                                         (ocStbHostFirmwareDownloadGroupId_oid),
+                                         HANDLER_CAN_RONLY));
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostFirmwareImageStatus",
+											 get_ocStbHostFirmwareImageStatus,
+											 ocStbHostFirmwareImageStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostFirmwareImageStatus_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostFirmwareCodeDownloadStatus",
+											 get_ocStbHostFirmwareCodeDownloadStatus,
+											 ocStbHostFirmwareCodeDownloadStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostFirmwareCodeDownloadStatus_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostFirmwareDownloadFailedStatus(netsnmp_mib_handler *handler,
+                                          netsnmp_handler_registration
+                                          *reginfo,
+                                          netsnmp_agent_request_info
+                                          *reqinfo,
+                                          netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.downloadFailedStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostFirmwareCodeObjectName(netsnmp_mib_handler *handler,
+                                    netsnmp_handler_registration *reginfo,
+                                    netsnmp_agent_request_info *reqinfo,
+                                    netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.name)
+                                 ,
+                                 strlen(pObj->container.name)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostFirmwareDownloadFailedCount(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 &(pObj->container.downloadFailedCount)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostFirmwareDownloadGroupId(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.downloadGroupId)
+                                 ,
+								 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostFirmwareImageStatus(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.imageStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostFirmwareCodeDownloadStatus(netsnmp_mib_handler *handler,
+                                        netsnmp_handler_registration
+                                        *reginfo,
+                                        netsnmp_agent_request_info
+                                        *reqinfo,
+                                        netsnmp_request_info *requests)
+{
+	mibObjectFwDownloadStatus *pObj = (mibObjectFwDownloadStatus *)gMibObjs[ocStbHostFirmwareDownloadStatus].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.codeDownloadStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostFirmwareDownloadStatus.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,19 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTFIRMWAREDOWNLOADSTATUS_H
+#define OCSTBHOSTFIRMWAREDOWNLOADSTATUS_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostFirmwareDownloadStatus(void);
+Netsnmp_Node_Handler get_ocStbHostFirmwareDownloadFailedStatus;
+Netsnmp_Node_Handler get_ocStbHostFirmwareCodeObjectName;
+Netsnmp_Node_Handler get_ocStbHostFirmwareDownloadFailedCount;
+Netsnmp_Node_Handler get_ocStbHostFirmwareDownloadGroupId;
+Netsnmp_Node_Handler get_ocStbHostFirmwareImageStatus;
+Netsnmp_Node_Handler get_ocStbHostFirmwareCodeDownloadStatus;
+
+#endif                          /* OCSTBHOSTFIRMWAREDOWNLOADSTATUS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,250 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ocStbHostHWIdentifiers.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostHWIdentifiers module */
+void
+init_ocStbHostHWIdentifiers(void)
+{
+    static oid      ocStbHostSerialNumber_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 1, 1, 0 };
+    static oid      ocStbHostCapabilities_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 1, 3, 0 };
+    static oid      ocStbHostHostID_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 1, 2, 0 };
+    static oid      ocStbHostAvcSupport_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 1, 4, 0 };
+	
+	mibObjects *pObj = &gMibObjs[ocStbHostHWIdentifiers];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostHWIdentifiers", "Initializing\n"));
+		
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostSerialNumber",
+											 get_ocStbHostSerialNumber,
+											 ocStbHostSerialNumber_oid,
+											 OID_LENGTH
+											 (ocStbHostSerialNumber_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCapabilities",
+											 get_ocStbHostCapabilities,
+											 ocStbHostCapabilities_oid,
+											 OID_LENGTH
+											 (ocStbHostCapabilities_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostHostID",
+											 get_ocStbHostHostID,
+											 ocStbHostHostID_oid,
+											 OID_LENGTH(ocStbHostHostID_oid),
+											 HANDLER_CAN_RONLY));
+	    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+	                                        ("ocStbHostAvcSupport",
+	                                         get_ocStbHostAvcSupport,
+	                                         ocStbHostAvcSupport_oid,
+	                                         OID_LENGTH
+	                                         (ocStbHostAvcSupport_oid),
+	                                         HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostSerialNumber(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	containerHwIdentifiers *pContainer = NULL;
+	mibObjectHwIdentifiers *pObj = (mibObjectHwIdentifiers *)gMibObjs[ocStbHostHWIdentifiers].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+		
+	/*
+	 * We are never called for a GETNEXT if it's registered as a
+	 * "instance", as it's "magically" handled for us.	
+	 */
+	
+	/*
+	 * a instance handler also only hands us one request at a time, so
+	 * we don't need to loop over a list of requests; we'll only get one. 
+	 */
+	
+	switch (reqinfo->mode) {
+	
+	case MODE_GET:
+		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+								 (u_char *)
+								 (pObj->container.serialNumber)
+								 ,
+								 strlen(pObj->container.serialNumber)
+								 );
+		break;
+	
+	
+	default:
+		/*
+		 * we should never get here, so this is a really bad error 
+		 */
+		return SNMP_ERR_GENERR;
+	}
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCapabilities(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	containerHwIdentifiers *pContainer = NULL;
+	mibObjectHwIdentifiers *pObj = (mibObjectHwIdentifiers *)gMibObjs[ocStbHostHWIdentifiers].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	/*
+	 * We are never called for a GETNEXT if it's registered as a
+	 * "instance", as it's "magically" handled for us.	
+	 */
+	
+	/*
+	 * a instance handler also only hands us one request at a time, so
+	 * we don't need to loop over a list of requests; we'll only get one. 
+	 */
+	
+	switch (reqinfo->mode) {
+	
+	case MODE_GET:
+		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+								 (u_char *)
+								 &(pObj->container.capabilities)
+								 ,
+								 sizeof(int)
+								 );
+		break;
+	
+	
+	default:
+		/*
+		 * we should never get here, so this is a really bad error 
+		 */
+		return SNMP_ERR_GENERR;
+	}			
+	
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostHostID(netsnmp_mib_handler *handler,
+                    netsnmp_handler_registration *reginfo,
+                    netsnmp_agent_request_info *reqinfo,
+                    netsnmp_request_info *requests)
+{
+	containerHwIdentifiers *pContainer = NULL;
+	mibObjectHwIdentifiers *pObj = (mibObjectHwIdentifiers *)gMibObjs[ocStbHostHWIdentifiers].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+		
+	/*
+	 * We are never called for a GETNEXT if it's registered as a
+	 * "instance", as it's "magically" handled for us.	
+	 */
+	
+	/*
+	 * a instance handler also only hands us one request at a time, so
+	 * we don't need to loop over a list of requests; we'll only get one. 
+	 */
+	
+	switch (reqinfo->mode) {
+	
+	case MODE_GET:
+		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+								 (u_char *)
+								 (pObj->container.hostId)
+								 ,
+								 strlen(pObj->container.hostId)
+								 );
+		break;
+	
+	
+	default:
+		/*
+		 * we should never get here, so this is a really bad error 
+		 */
+		return SNMP_ERR_GENERR;
+	}
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostAvcSupport(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	containerHwIdentifiers *pContainer = NULL;
+	mibObjectHwIdentifiers *pObj = (mibObjectHwIdentifiers *)gMibObjs[ocStbHostHWIdentifiers].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.avcSupport)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostHWIdentifiers.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,17 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTHWIDENTIFIERS_H
+#define OCSTBHOSTHWIDENTIFIERS_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostHWIdentifiers(void);
+Netsnmp_Node_Handler get_ocStbHostSerialNumber;
+Netsnmp_Node_Handler get_ocStbHostCapabilities;
+Netsnmp_Node_Handler get_ocStbHostHostID;
+Netsnmp_Node_Handler get_ocStbHostAvcSupport;
+
+#endif                          /* OCSTBHOSTHWIDENTIFIERS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,346 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostIEEE1394ConnectedDevicesTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ieee1394ConnectedDevicesTable.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+static int avIfIndex[NUM_IEEE1394_OUTPUTS];
+
+/** Initialize the ocStbHostIEEE1394ConnectedDevicesTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostIEEE1394ConnectedDevicesTable(void)
+{
+    static oid      ocStbHostIEEE1394ConnectedDevicesTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 3, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostIEEE1394ConnectedDevicesTable",
+         ocStbHostIEEE1394ConnectedDevicesTable_handler,
+         ocStbHostIEEE1394ConnectedDevicesTable_oid,
+         OID_LENGTH(ocStbHostIEEE1394ConnectedDevicesTable_oid),
+		 HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostIEEE1394ConnectedDevicesIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 5;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostIEEE1394ConnectedDevicesTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostIEEE1394ConnectedDevicesTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostIEEE1394ConnectedDevicesTable",
+                "Registering table ocStbHostIEEE1394ConnectedDevicesTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostIEEE1394ConnectedDevicesTable module */
+void
+init_ocStbHostIEEE1394ConnectedDevicesTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostIEEE1394ConnectedDevicesTable];
+	mibObjectIeee1394ConnectedDevicesTable *pTblObj = (mibObjectIeee1394ConnectedDevicesTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostIEEE1394ConnectedDevicesTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (checkAVInterfaceExistence(ocStbHost1394Out, avIfIndex))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateIeee1394ConnectedDevices(); 	  /* MOE initialize IEEE1394ConnectedDevices instrumentation */
+			initialize_table_ocStbHostIEEE1394ConnectedDevicesTable();
+
+			for (i=0; i<NUM_IEEE1394_OUTPUTS; i++)
+			{
+				struct ieee1394ConnectedDevicesEntry *pEntry = getIeee1394ConnectedDevicesEntry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostIEEE1394ConnectedDevicesTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostIEEE1394ConnectedDevicesTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostIEEE1394ConnectedDevicesTable_get_first_data_point(void
+                                                            **my_loop_context,
+                                                            void
+                                                            **my_data_context,
+                                                            netsnmp_variable_list
+                                                            *
+                                                            put_index_data,
+                                                            netsnmp_iterator_info
+                                                            *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ieee1394ConnectedDevicesEntry *tmpPtr;	    /* MOE a pointer to the first entry */
+
+    tmpPtr = getIeee1394ConnectedDevicesEntry(0);		/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+					   (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostIEEE1394ConnectedDevicesTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostIEEE1394ConnectedDevicesTable_get_next_data_point(void
+                                                           **my_loop_context,
+                                                           void
+                                                           **my_data_context,
+                                                           netsnmp_variable_list
+                                                           *
+                                                           put_index_data,
+                                                           netsnmp_iterator_info
+                                                           *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ieee1394ConnectedDevicesEntry *tmpPtr;					/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostIEEE1394ConnectedDevicesTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct ieee1394ConnectedDevicesEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getIeee1394ConnectedDevicesEntry(tmpPtr->index);  	/* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostIEEE1394ConnectedDevicesTable table, if anything else needs to be done */
+int
+ocStbHostIEEE1394ConnectedDevicesTable_handler(netsnmp_mib_handler
+                                               *handler,
+                                               netsnmp_handler_registration
+                                               *reginfo,
+                                               netsnmp_agent_request_info
+                                               *reqinfo,
+                                               netsnmp_request_info
+                                               *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct ieee1394ConnectedDevicesData *tmpIeee1394ConnectedDevicesDataPtr;          /* MOE a pointer to some IEEE1394 data */
+	mibObjectIeee1394ConnectedDevicesTable *pObj = (mibObjectIeee1394ConnectedDevicesTable *)gMibObjs[ocStbHostIEEE1394ConnectedDevicesTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostIEEE1394ConnectedDevicesTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostIEEE1394ConnectedDevicesTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpIeee1394ConnectedDevicesDataPtr = ( struct ieee1394ConnectedDevicesData *) netsnmp_extract_iterator_context(request);
+		if ( tmpIeee1394ConnectedDevicesDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpIeee1394ConnectedDevicesDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESAVINTERFACEINDEX:
+			{
+				int index = avIfIndex[tmpIeee1394ConnectedDevicesDataPtr->index];
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(index)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESSUBUNITTYPE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpIeee1394ConnectedDevicesDataPtr->container.subUnitType)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESEUI64:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpIeee1394ConnectedDevicesDataPtr->container.eui64)
+                                         , sizeof(tmpIeee1394ConnectedDevicesDataPtr->container.eui64) );
+                break;
+
+            case COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESADSOURCESELECTSUPPORT:
+			{
+				int analogDigitalSourceSelection = tmpIeee1394ConnectedDevicesDataPtr->container.analogDigitalSourceSelection ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(analogDigitalSourceSelection)
+                                         , sizeof(int) );
+                break;
+            }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostIEEE1394ConnectedDevicesTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostIEEE1394ConnectedDevicesTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,29 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTIEEE1394CONNECTEDDEVICESTABLE_H
+#define OCSTBHOSTIEEE1394CONNECTEDDEVICESTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostIEEE1394ConnectedDevicesTable(void);
+void           
+initialize_table_ocStbHostIEEE1394ConnectedDevicesTable(void);
+Netsnmp_Node_Handler ocStbHostIEEE1394ConnectedDevicesTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostIEEE1394ConnectedDevicesTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostIEEE1394ConnectedDevicesTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostIEEE1394ConnectedDevicesTable 
+ */
+#define COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESINDEX		1
+#define COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESAVINTERFACEINDEX		2
+#define COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESSUBUNITTYPE		3
+#define COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESEUI64		4
+#define COLUMN_OCSTBHOSTIEEE1394CONNECTEDDEVICESADSOURCESELECTSUPPORT		5
+#endif                          /* OCSTBHOSTIEEE1394CONNECTEDDEVICESTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,381 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostIEEE1394Table.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ieee1394Table.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostIEEE1394Table table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostIEEE1394Table(void)
+{
+    static oid      ocStbHostIEEE1394Table_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 3, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostIEEE1394Table",
+                                            ocStbHostIEEE1394Table_handler,
+                                            ocStbHostIEEE1394Table_oid,
+                                            OID_LENGTH
+                                            (ocStbHostIEEE1394Table_oid),
+											HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostIEEE1394Index */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 9;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostIEEE1394Table_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostIEEE1394Table_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostIEEE1394Table",
+                "Registering table ocStbHostIEEE1394Table as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostIEEE1394Table module */
+void
+init_ocStbHostIEEE1394Table(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostIEEE1394Table];
+	mibObjectIeee1394Table *pTblObj = (mibObjectIeee1394Table *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostIEEE1394Table() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (checkAVInterfaceExistence(ocStbHost1394Out, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateIeee1394(); 	  /* MOE initialize IEEE1394 instrumentation */
+			initialize_table_ocStbHostIEEE1394Table();
+
+			for (i=0; i<NUM_IEEE1394_OUTPUTS; i++)
+			{
+				struct ieee1394Entry *pEntry = getIeee1394Entry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostIEEE1394Table table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostIEEE1394Table_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostIEEE1394Table_get_first_data_point(void **my_loop_context,
+                                            void **my_data_context,
+                                            netsnmp_variable_list *
+                                            put_index_data,
+                                            netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ieee1394Entry *tmpPtr;			/* MOE a pointer to the first entry */
+
+    tmpPtr = getIeee1394Entry(0);			/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {					/* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;              /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;        /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+					   (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+					   sizeof(tmpPtr->index)		/* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostIEEE1394Table_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostIEEE1394Table_get_next_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ieee1394Entry *tmpPtr;				/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostIEEE1394Table_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct ieee1394Entry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getIeee1394Entry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+					   (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+					   sizeof(tmpPtr->index)		  /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostIEEE1394Table table, if anything else needs to be done */
+int
+ocStbHostIEEE1394Table_handler(netsnmp_mib_handler *handler,
+                               netsnmp_handler_registration *reginfo,
+                               netsnmp_agent_request_info *reqinfo,
+                               netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct ieee1394Data *tmpIeee1394DataPtr;          /* MOE a pointer to some IEEE1394 data */
+	mibObjectIeee1394Table *pObj = (mibObjectIeee1394Table *)gMibObjs[ocStbHostIEEE1394Table].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    // snmp_log(LOG_INFO, "ocStbHostIEEE1394Table_handler() enter\n");
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostIEEE1394Table table in question
+         */
+        /*
+	     /* MOE extract the data pointer */
+		 tmpIeee1394DataPtr = ( struct ieee1394Data *) netsnmp_extract_iterator_context(request);
+		 if ( tmpIeee1394DataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpIeee1394DataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTIEEE1394ACTIVENODES:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpIeee1394DataPtr->container.activeNodes)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTIEEE1394DATAXMISSION:
+			{
+				int dataXMission = tmpIeee1394DataPtr->container.dataXMission ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+										 (u_char *) &(dataXMission)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394DTCPSTATUS:
+			{
+				int dtcpStatus = tmpIeee1394DataPtr->container.dtcpStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(dtcpStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394LOOPSTATUS:
+			{
+				int loopStatus = tmpIeee1394DataPtr->container.loopStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(loopStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394ROOTSTATUS:
+			{
+				int rootStatus = tmpIeee1394DataPtr->container.rootStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(rootStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394CYCLEISMASTER:
+			{
+				int cycleIsMaster = tmpIeee1394DataPtr->container.cycleIsMaster ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(cycleIsMaster)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394IRMSTATUS:
+			{
+				int irmStatus = tmpIeee1394DataPtr->container.irmStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(irmStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394AUDIOMUTESTATUS:
+			{
+				int audioMuteStatus = tmpIeee1394DataPtr->container.audioMuteStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(audioMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTIEEE1394VIDEOMUTESTATUS:
+			{
+				int videoMuteStatus = tmpIeee1394DataPtr->container.videoMuteStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(videoMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostIEEE1394Table_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostIEEE1394Table_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostIEEE1394Table.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,30 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTIEEE1394TABLE_H
+#define OCSTBHOSTIEEE1394TABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostIEEE1394Table(void);
+void            initialize_table_ocStbHostIEEE1394Table(void);
+Netsnmp_Node_Handler ocStbHostIEEE1394Table_handler;
+
+Netsnmp_First_Data_Point ocStbHostIEEE1394Table_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostIEEE1394Table_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostIEEE1394Table 
+ */
+#define COLUMN_OCSTBHOSTIEEE1394ACTIVENODES		1
+#define COLUMN_OCSTBHOSTIEEE1394DATAXMISSION		2
+#define COLUMN_OCSTBHOSTIEEE1394DTCPSTATUS		3
+#define COLUMN_OCSTBHOSTIEEE1394LOOPSTATUS		4
+#define COLUMN_OCSTBHOSTIEEE1394ROOTSTATUS		5
+#define COLUMN_OCSTBHOSTIEEE1394CYCLEISMASTER		6
+#define COLUMN_OCSTBHOSTIEEE1394IRMSTATUS		7
+#define COLUMN_OCSTBHOSTIEEE1394AUDIOMUTESTATUS		8
+#define COLUMN_OCSTBHOSTIEEE1394VIDEOMUTESTATUS		9
+#endif                          /* OCSTBHOSTIEEE1394TABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,602 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostInBandTunerTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "ibTunerTable.h"   /* MOE this is where we get our tuner info */
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/* QAM Interleaved Depth Table :J83*/
+static unsigned int qam_interleaved_depth[16] = {
+                128<<16|1, 128<<16|1, 128<<16|2, 64<<16|2,
+                128<<16|3, 32<<16|4,  128<<16|4, 16<<16|8,
+                128<<16|5, 8<<16|16,  128<<16|6, 0,
+                128<<16|7, 0,         128<<16|8, 0 };
+
+/** Initialize the ocStbHostInBandTunerTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostInBandTunerTable(void)
+{
+    static oid      ocStbHostInBandTunerTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostInBandTunerTable",
+                                            ocStbHostInBandTunerTable_handler,
+                                            ocStbHostInBandTunerTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostInBandTunerTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostInBandTunerIndex */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 21;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostInBandTunerTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostInBandTunerTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostInBandTunerTable",
+                "Registering table ocStbHostInBandTunerTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostInBandTunerTable module */
+void
+init_ocStbHostInBandTunerTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostInBandTunerTable];
+	mibObjectInBandTunerTable *pTblObj = (mibObjectInBandTunerTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+    /* snmp_log(LOG_INFO, "init_ocStbHostInBandTunerTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (checkAVInterfaceExistence(ocStbHostScte40FatRx, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateIBTuners(); 	  /* MOE initialize tuner instrumentation */
+			initialize_table_ocStbHostInBandTunerTable();
+
+			for (i=0; i<getIBTunerTotalEntry(); i++)
+			{
+				struct ibTunerEntry *pEntry = getIBTunerEntry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostInBandTunerTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostInBandTunerTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostInBandTunerTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ibTunerEntry *tmpPtr;           	  /* MOE a pointer to the first entry */
+
+    tmpPtr = getIBTunerEntry(0);       		  /* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)        /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostInBandTunerTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostInBandTunerTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct ibTunerEntry *tmpPtr;             	/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostInBandTunerTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct ibTunerEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getIBTunerEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)          /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostInBandTunerTable table, if anything else needs to be done */
+int
+ocStbHostInBandTunerTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct ibTunerData *tmpTunerDataPtr;          /* MOE a pointer to some tuner data */
+	mibObjectInBandTunerTable *pObj = (mibObjectInBandTunerTable *)gMibObjs[ocStbHostInBandTunerTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostInBandTunerTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostInBandTunerTable table in question
+         */
+         /* MOE extract the data pointer */
+         tmpTunerDataPtr  = ( struct ibTunerData *) netsnmp_extract_iterator_context(request);
+        if ( tmpTunerDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+
+		pObj->callback((void *)pObj, tmpTunerDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTINBANDTUNERMODULATIONMODE:
+			{
+                int modulationMode = oc_tunerModulationMode_other;
+				if (pObj->qam)
+				{
+					switch(tmpTunerDataPtr->container.modulationMode)
+					{
+						case NEXUS_FrontendQamMode_e64:
+							modulationMode = oc_tunerModulationMode_qam64;
+							break;
+						case NEXUS_FrontendQamMode_e256:
+							modulationMode = oc_tunerModulationMode_qam256;
+							break;
+						case NEXUS_FrontendQamMode_e16:
+						case NEXUS_FrontendQamMode_e32:
+						case NEXUS_FrontendQamMode_e128:
+						case NEXUS_FrontendQamMode_e512:
+						case NEXUS_FrontendQamMode_e1024:
+						case NEXUS_FrontendQamMode_e2048:
+						case NEXUS_FrontendQamMode_e4096:
+						default:
+							modulationMode = oc_tunerModulationMode_other;
+							break;
+					}
+				}
+				else if (pObj->analog)
+				{
+					modulationMode = oc_tunerModulationMode_analog;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(modulationMode)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERFREQUENCY:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpTunerDataPtr->container.frequency)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERINTERLEAVER:
+			{
+				int interleaver = oc_tunerInterleaver_unknown;
+				if (pObj->annex == NEXUS_FrontendQamAnnex_eA || pObj->annex == NEXUS_FrontendQamAnnex_eC)
+				{
+					interleaver = oc_tunerInterleaver_other;
+				}
+				else if (pObj->annex == NEXUS_FrontendQamAnnex_eB)
+				{
+					switch(tmpTunerDataPtr->container.interleaver)
+					{
+						case 0x0:
+						case 0x1:
+							interleaver = oc_tunerInterleaver_taps128Increment1;
+							break;
+						case 0x2:
+							interleaver = oc_tunerInterleaver_taps128Increment2;
+							break;
+						case 0x3:
+							interleaver = oc_tunerInterleaver_taps64Increment2;
+							break;
+						case 0x4:
+							interleaver = oc_tunerInterleaver_taps128Increment3;
+							break;
+						case 0x5:
+							interleaver = oc_tunerInterleaver_taps32Increment4;
+							break;
+						case 0x6:
+							interleaver = oc_tunerInterleaver_taps128Increment4;
+							break;
+						case 0x7:
+							interleaver = oc_tunerInterleaver_taps16Increment8;
+							break;
+						case 0x9:
+							interleaver = oc_tunerInterleaver_taps8Increment16;
+							break;
+						case 0x8: /* taps128Increment5 */
+						case 0xa: /* taps128Increment6 */
+						case 0xb: /* reserved, taps4Increment32 */
+						case 0xc: /* taps128Increment7 */
+						case 0xd: /* reserved, taps2Increment64 */
+						case 0xe: /* taps128Increment8 */
+						case 0xf: /* reserved, taps1Increment128 */
+							interleaver = oc_tunerInterleaver_other;
+							break;
+						default:
+							interleaver = oc_tunerInterleaver_unknown;
+					}
+				}
+				else
+				{
+					interleaver = oc_tunerInterleaver_unknown;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(interleaver)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERPOWER:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpTunerDataPtr->container.tunerPower)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERAGCVALUE:
+			{
+                int agcValue = tmpTunerDataPtr->container.agcValue/10;
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(agcValue)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERSNRVALUE:
+			{
+                int snrValue = tmpTunerDataPtr->container.snrValue/10;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(snrValue)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERUNERROREDS:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.unerroreds)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERCORRECTEDS:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.correcteds)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERUNCORRECTABLES:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.uncorrectables)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERCARRIERLOCKLOST:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.carrierLockLost)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERPCRERRORS:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.pcrErrors)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERPTSERRORS:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.ptsErrors)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERSTATE:
+			{
+				int tunerState = oc_tunerState_unknown;
+				if (pObj->qam)
+				{
+					switch(tmpTunerDataPtr->container.state)
+					{
+						case tuner_idle:
+						case tuner_failed:
+							tunerState = oc_tunerState_ready;
+							break;
+						case tuner_tuning:
+							tunerState = oc_tunerState_waitingQam;
+							break;
+						case tuner_locked:
+							tunerState = oc_tunerState_foundQam;
+							break;
+                        default:
+							tunerState = oc_tunerState_unknown;
+							break;
+					}
+				}
+				else if (pObj->analog)
+				{
+					//TODO: need support for analog?
+					tunerState = oc_tunerState_unknown;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tunerState)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERBER:
+			{
+				int ber = oc_berNotApplicable;
+				if (pObj->qam)
+				{
+					if (tmpTunerDataPtr->container.ber > 0)
+					{
+						ber = oc_berNotApplicable;
+					}
+					else if (tmpTunerDataPtr->container.ber > -2 && tmpTunerDataPtr->container.ber <= 0)
+					{
+						ber = oc_berGreaterThan10e2;
+					}
+					else if (tmpTunerDataPtr->container.ber > -4 && tmpTunerDataPtr->container.ber <= -2)
+					{
+						ber = oc_berRange10e2ToGreaterThan10e4;
+					}
+					else if (tmpTunerDataPtr->container.ber > -6 && tmpTunerDataPtr->container.ber <= -4)
+					{
+						ber = oc_berRange10e4ToGreaterThan10e6;
+					}
+					else if (tmpTunerDataPtr->container.ber > -8 && tmpTunerDataPtr->container.ber <= -6)
+					{
+						ber = oc_berRange10e6ToGreaterThan10e8;
+					}
+					else if (tmpTunerDataPtr->container.ber > -12 && tmpTunerDataPtr->container.ber <= -8)
+					{
+						ber = oc_berRange10e8ToGreaterThan10e10;
+					}
+					else if (tmpTunerDataPtr->container.ber <= -12)
+					{
+						ber = oc_berEqualToOrLessThan10e12;
+					}
+				}
+				else if (pObj->analog)
+				{
+					ber = oc_berNotApplicable;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(ber)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERSECSSINCELOCK:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpTunerDataPtr->container.secSinceLock)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNEREQGAIN:
+			{
+				int eqGain;
+				if (pObj->qam)
+				{
+					eqGain = tmpTunerDataPtr->container.eqGain;
+				}
+				else
+				{
+					eqGain = 0;
+				}
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(eqGain)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTINBANDTUNERMAINTAPCOEFF:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpTunerDataPtr->container.mainTap)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERTOTALTUNECOUNT:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.totalTuneCount)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERTUNEFAILURECOUNT:
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpTunerDataPtr->container.tuneFailureCount)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERTUNEFAILFREQ:
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpTunerDataPtr->container.tuneFailFreq)
+                                         , sizeof(int));
+                break;
+
+            case COLUMN_OCSTBHOSTINBANDTUNERBANDWIDTH:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpTunerDataPtr->container.bandwidth)
+                                         , sizeof(int));
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostInBandTunerTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostInBandTunerTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInBandTunerTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,42 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTINBANDTUNERTABLE_H
+#define OCSTBHOSTINBANDTUNERTABLE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostInBandTunerTable(void);
+void            initialize_table_ocStbHostInBandTunerTable(void);
+Netsnmp_Node_Handler ocStbHostInBandTunerTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostInBandTunerTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostInBandTunerTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostInBandTunerTable
+ */
+#define COLUMN_OCSTBHOSTINBANDTUNERMODULATIONMODE		1
+#define COLUMN_OCSTBHOSTINBANDTUNERFREQUENCY		2
+#define COLUMN_OCSTBHOSTINBANDTUNERINTERLEAVER		3
+#define COLUMN_OCSTBHOSTINBANDTUNERPOWER		4
+#define COLUMN_OCSTBHOSTINBANDTUNERAGCVALUE		5
+#define COLUMN_OCSTBHOSTINBANDTUNERSNRVALUE		6
+#define COLUMN_OCSTBHOSTINBANDTUNERUNERROREDS		7
+#define COLUMN_OCSTBHOSTINBANDTUNERCORRECTEDS		8
+#define COLUMN_OCSTBHOSTINBANDTUNERUNCORRECTABLES		9
+#define COLUMN_OCSTBHOSTINBANDTUNERCARRIERLOCKLOST		10
+#define COLUMN_OCSTBHOSTINBANDTUNERPCRERRORS		11
+#define COLUMN_OCSTBHOSTINBANDTUNERPTSERRORS		12
+#define COLUMN_OCSTBHOSTINBANDTUNERSTATE		13
+#define COLUMN_OCSTBHOSTINBANDTUNERBER		14
+#define COLUMN_OCSTBHOSTINBANDTUNERSECSSINCELOCK		15
+#define COLUMN_OCSTBHOSTINBANDTUNEREQGAIN		16
+#define COLUMN_OCSTBHOSTINBANDTUNERMAINTAPCOEFF		17
+#define COLUMN_OCSTBHOSTINBANDTUNERTOTALTUNECOUNT		18
+#define COLUMN_OCSTBHOSTINBANDTUNERTUNEFAILURECOUNT		19
+#define COLUMN_OCSTBHOSTINBANDTUNERTUNEFAILFREQ		20
+#define COLUMN_OCSTBHOSTINBANDTUNERBANDWIDTH		21
+#endif                          /* OCSTBHOSTINBANDTUNERTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,933 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostInfo module */
+void
+init_ocStbHostInfo(void)
+{
+    static oid      ocStbHostIpSubNetMask_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 2, 0 };
+#if 0
+	static oid		ocStbHostPmtTimeoutCount_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 2, 0 };
+	static oid		ocStbHostInbandCarouselTimeoutCount_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 4, 0 };
+#endif
+    static oid      ocStbHostIpAddressType_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 1, 0 };
+#if 0
+    static oid      ocStbHostDumpNow_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 2, 0 };
+    static oid      ocStbHostCfrSpecificationIssue_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 5, 1, 0 };
+	static oid		ocStbHostOobCarouselTimeoutCount_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 3, 0 };
+    static oid      ocStbHostDumpEventTimeout_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 3, 0 };
+	static oid		ocStbHostMibSpecificationIssue_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 5, 2, 0 };
+    static oid      ocStbHostDumpEventCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 1, 0 };
+#endif
+    static oid      ocStbHostBootStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 6, 0 };
+    static oid      ocStbHostOobMessageMode_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 3, 0 };
+#if 0
+    static oid      ocStbHostPatTimeoutCount_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 7, 1, 0 };
+    static oid      ocStbHostDumpFilePath_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 4, 4, 0 };
+#endif
+
+	mibObjects *pObj = &gMibObjs[ocStbHostInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+			DEBUGMSGTL(("ocStbHostInfo", "Initializing\n"));
+
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostIpSubNetMask",
+												 get_ocStbHostIpSubNetMask,
+												 ocStbHostIpSubNetMask_oid,
+												 OID_LENGTH
+												 (ocStbHostIpSubNetMask_oid),
+												 HANDLER_CAN_RONLY));
+#if 0
+		    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+		                                        ("ocStbHostPmtTimeoutCount",
+		                                         get_ocStbHostPmtTimeoutCount,
+		                                         ocStbHostPmtTimeoutCount_oid,
+		                                         OID_LENGTH
+		                                         (ocStbHostPmtTimeoutCount_oid),
+		                                         HANDLER_CAN_RONLY));
+		    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+		                                        ("ocStbHostInbandCarouselTimeoutCount",
+		                                         get_ocStbHostInbandCarouselTimeoutCount,
+		                                         ocStbHostInbandCarouselTimeoutCount_oid,
+		                                         OID_LENGTH
+		                                         (ocStbHostInbandCarouselTimeoutCount_oid),
+		                                         HANDLER_CAN_RONLY));
+#endif
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostIpAddressType",
+												 get_ocStbHostIpAddressType,
+												 ocStbHostIpAddressType_oid,
+												 OID_LENGTH
+												 (ocStbHostIpAddressType_oid),
+												 HANDLER_CAN_RONLY));
+#if 0
+			netsnmp_register_instance(netsnmp_create_handler_registration
+									  ("ocStbHostDumpNow", do_ocStbHostDumpNow,
+									   ocStbHostDumpNow_oid,
+									   OID_LENGTH(ocStbHostDumpNow_oid),
+									   HANDLER_CAN_RWRITE));
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostCfrSpecificationIssue",
+												 get_ocStbHostCfrSpecificationIssue,
+												 ocStbHostCfrSpecificationIssue_oid,
+												 OID_LENGTH
+												 (ocStbHostCfrSpecificationIssue_oid),
+												 HANDLER_CAN_RONLY));
+		    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+		                                        ("ocStbHostOobCarouselTimeoutCount",
+		                                         get_ocStbHostOobCarouselTimeoutCount,
+		                                         ocStbHostOobCarouselTimeoutCount_oid,
+		                                         OID_LENGTH
+		                                         (ocStbHostOobCarouselTimeoutCount_oid),
+		                                         HANDLER_CAN_RONLY));
+			netsnmp_register_instance(netsnmp_create_handler_registration
+									  ("ocStbHostDumpEventTimeout",
+									   do_ocStbHostDumpEventTimeout,
+									   ocStbHostDumpEventTimeout_oid,
+									   OID_LENGTH(ocStbHostDumpEventTimeout_oid),
+									   HANDLER_CAN_RWRITE));
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostMibSpecificationIssue",
+												 get_ocStbHostMibSpecificationIssue,
+												 ocStbHostMibSpecificationIssue_oid,
+												 OID_LENGTH
+												 (ocStbHostMibSpecificationIssue_oid),
+												 HANDLER_CAN_RONLY));
+			netsnmp_register_instance(netsnmp_create_handler_registration
+									  ("ocStbHostDumpEventCount",
+									   do_ocStbHostDumpEventCount,
+									   ocStbHostDumpEventCount_oid,
+									   OID_LENGTH(ocStbHostDumpEventCount_oid),
+									   HANDLER_CAN_RWRITE));
+#endif
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostBootStatus",
+												 get_ocStbHostBootStatus,
+												 ocStbHostBootStatus_oid,
+												 OID_LENGTH
+												 (ocStbHostBootStatus_oid),
+												 HANDLER_CAN_RONLY));
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostOobMessageMode",
+												 get_ocStbHostOobMessageMode,
+												 ocStbHostOobMessageMode_oid,
+												 OID_LENGTH
+												 (ocStbHostOobMessageMode_oid),
+												 HANDLER_CAN_RONLY));
+#if 0
+		    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+		                                        ("ocStbHostPatTimeoutCount",
+		                                         get_ocStbHostPatTimeoutCount,
+		                                         ocStbHostPatTimeoutCount_oid,
+		                                         OID_LENGTH
+		                                         (ocStbHostPatTimeoutCount_oid),
+		                                         HANDLER_CAN_RONLY));
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostDumpFilePath",
+												 get_ocStbHostDumpFilePath,
+												 ocStbHostDumpFilePath_oid,
+												 OID_LENGTH
+												 (ocStbHostDumpFilePath_oid),
+												 HANDLER_CAN_RONLY));
+#endif
+	}
+}
+
+int
+get_ocStbHostIpSubNetMask(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectHostInfo *pObj = (mibObjectHostInfo *)gMibObjs[ocStbHostInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.subNetMask)
+                                 ,
+                                 (pObj->container.ipType == oc_inetAddrType_ipv6)
+                                 ? 16 : 4
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostPmtTimeoutCount(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostInbandCarouselTimeoutCount(netsnmp_mib_handler *handler,
+                                        netsnmp_handler_registration
+                                        *reginfo,
+                                        netsnmp_agent_request_info
+                                        *reqinfo,
+                                        netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostIpAddressType(netsnmp_mib_handler *handler,
+                           netsnmp_handler_registration *reginfo,
+                           netsnmp_agent_request_info *reqinfo,
+                           netsnmp_request_info *requests)
+{
+	mibObjectHostInfo *pObj = (mibObjectHostInfo *)gMibObjs[ocStbHostInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.ipType)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+do_ocStbHostDumpNow(netsnmp_mib_handler *handler,
+                    netsnmp_handler_registration *reginfo,
+                    netsnmp_agent_request_info *reqinfo,
+                    netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
+                                      );
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        /*
+         * XXX malloc "undo" storage buffer
+         */
+        if ( /* XXX if malloc, or whatever, failed: */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_RESOURCESUNAVAILABLE);
+        }
+        break;
+
+    case MODE_SET_FREE:
+        /*
+         * XXX: free resources allocated in RESERVE1 and/or
+         * RESERVE2.  Something failed somewhere, and the states
+         * below won't be called.
+         */
+        break;
+
+    case MODE_SET_ACTION:
+        /*
+         * XXX: perform the value change here
+         */
+        if ( /* XXX: error? */ ) {
+            netsnmp_set_request_error(reqinfo, requests, /* some error */
+                                      );
+        }
+        break;
+
+    case MODE_SET_COMMIT:
+        /*
+         * XXX: delete temporary storage
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_COMMITFAILED);
+        }
+        break;
+
+    case MODE_SET_UNDO:
+        /*
+         * XXX: UNDO and return to previous value for the object
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_UNDOFAILED);
+        }
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCfrSpecificationIssue(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostOobCarouselTimeoutCount(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostDumpEventTimeout(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
+                                      );
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        /*
+         * XXX malloc "undo" storage buffer
+         */
+        if ( /* XXX if malloc, or whatever, failed: */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_RESOURCESUNAVAILABLE);
+        }
+        break;
+
+    case MODE_SET_FREE:
+        /*
+         * XXX: free resources allocated in RESERVE1 and/or
+         * RESERVE2.  Something failed somewhere, and the states
+         * below won't be called.
+         */
+        break;
+
+    case MODE_SET_ACTION:
+        /*
+         * XXX: perform the value change here
+         */
+        if ( /* XXX: error? */ ) {
+            netsnmp_set_request_error(reqinfo, requests, /* some error */
+                                      );
+        }
+        break;
+
+    case MODE_SET_COMMIT:
+        /*
+         * XXX: delete temporary storage
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_COMMITFAILED);
+        }
+        break;
+
+    case MODE_SET_UNDO:
+        /*
+         * XXX: UNDO and return to previous value for the object
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_UNDOFAILED);
+        }
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostMibSpecificationIssue(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostDumpEventCount(netsnmp_mib_handler *handler,
+                           netsnmp_handler_registration *reginfo,
+                           netsnmp_agent_request_info *reqinfo,
+                           netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
+                                      );
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        /*
+         * XXX malloc "undo" storage buffer
+         */
+        if ( /* XXX if malloc, or whatever, failed: */ ) {
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_RESOURCESUNAVAILABLE);
+        }
+        break;
+
+    case MODE_SET_FREE:
+        /*
+         * XXX: free resources allocated in RESERVE1 and/or
+         * RESERVE2.  Something failed somewhere, and the states
+         * below won't be called.
+         */
+        break;
+
+    case MODE_SET_ACTION:
+        /*
+         * XXX: perform the value change here
+         */
+        if ( /* XXX: error? */ ) {
+            netsnmp_set_request_error(reqinfo, requests, /* some error */
+                                      );
+        }
+        break;
+
+    case MODE_SET_COMMIT:
+        /*
+         * XXX: delete temporary storage
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_COMMITFAILED);
+        }
+        break;
+
+    case MODE_SET_UNDO:
+        /*
+         * XXX: UNDO and return to previous value for the object
+         */
+        if ( /* XXX: error? */ ) {
+            /*
+             * try _really_really_ hard to never get to this point
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_UNDOFAILED);
+        }
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostBootStatus(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	mibObjectHostInfo *pObj = (mibObjectHostInfo *)gMibObjs[ocStbHostInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.bootStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostOobMessageMode(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+	mibObjectHostInfo *pObj = (mibObjectHostInfo *)gMibObjs[ocStbHostInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.oobMessageMode)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0
+int
+get_ocStbHostPatTimeoutCount(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostDumpFilePath(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,33 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTINFO_H
+#define OCSTBHOSTINFO_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostInfo(void);
+Netsnmp_Node_Handler get_ocStbHostIpSubNetMask;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostPmtTimeoutCount;
+Netsnmp_Node_Handler get_ocStbHostInbandCarouselTimeoutCount;
+#endif
+Netsnmp_Node_Handler get_ocStbHostIpAddressType;
+#if 0
+Netsnmp_Node_Handler do_ocStbHostDumpNow;
+Netsnmp_Node_Handler get_ocStbHostCfrSpecificationIssue;
+Netsnmp_Node_Handler get_ocStbHostOobCarouselTimeoutCount;
+Netsnmp_Node_Handler do_ocStbHostDumpEventTimeout;
+Netsnmp_Node_Handler get_ocStbHostMibSpecificationIssue;
+Netsnmp_Node_Handler do_ocStbHostDumpEventCount;
+#endif
+Netsnmp_Node_Handler get_ocStbHostBootStatus;
+Netsnmp_Node_Handler get_ocStbHostOobMessageMode;
+#if 0
+Netsnmp_Node_Handler get_ocStbHostPatTimeoutCount;
+Netsnmp_Node_Handler get_ocStbHostDumpFilePath;
+#endif
+
+#endif                          /* OCSTBHOSTINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,246 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostJVMInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostJVMInfo module */
+void
+init_ocStbHostJVMInfo(void)
+{
+    static oid      ocStbHostJVMLiveObjects_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 8, 3, 0 };
+    static oid      ocStbHostJVMHeapSize_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 8, 1, 0 };
+    static oid      ocStbHostJVMDeadObjects_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 8, 4, 0 };
+    static oid      ocStbHostJVMAvailHeap_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 8, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostJVMInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostJVMInfo", "Initializing\n"));
+		
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostJVMLiveObjects",
+											 get_ocStbHostJVMLiveObjects,
+											 ocStbHostJVMLiveObjects_oid,
+											 OID_LENGTH
+											 (ocStbHostJVMLiveObjects_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostJVMHeapSize",
+											 get_ocStbHostJVMHeapSize,
+											 ocStbHostJVMHeapSize_oid,
+											 OID_LENGTH
+											 (ocStbHostJVMHeapSize_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostJVMDeadObjects",
+											 get_ocStbHostJVMDeadObjects,
+											 ocStbHostJVMDeadObjects_oid,
+											 OID_LENGTH
+											 (ocStbHostJVMDeadObjects_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostJVMAvailHeap",
+											 get_ocStbHostJVMAvailHeap,
+											 ocStbHostJVMAvailHeap_oid,
+											 OID_LENGTH
+											 (ocStbHostJVMAvailHeap_oid),
+											 HANDLER_CAN_RONLY));
+	}	
+}
+
+int
+get_ocStbHostJVMLiveObjects(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+	mibObjectJvmInfo *pObj = (mibObjectJvmInfo *)gMibObjs[ocStbHostJVMInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.liveObjects)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostJVMHeapSize(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectJvmInfo *pObj = (mibObjectJvmInfo *)gMibObjs[ocStbHostJVMInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.heapSize)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostJVMDeadObjects(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+	mibObjectJvmInfo *pObj = (mibObjectJvmInfo *)gMibObjs[ocStbHostJVMInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.deadObjects)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostJVMAvailHeap(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectJvmInfo *pObj = (mibObjectJvmInfo *)gMibObjs[ocStbHostJVMInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.availHeap)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostJVMInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,17 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTJVMINFO_H
+#define OCSTBHOSTJVMINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostJVMInfo(void);
+Netsnmp_Node_Handler get_ocStbHostJVMLiveObjects;
+Netsnmp_Node_Handler get_ocStbHostJVMHeapSize;
+Netsnmp_Node_Handler get_ocStbHostJVMDeadObjects;
+Netsnmp_Node_Handler get_ocStbHostJVMAvailHeap;
+
+#endif                          /* OCSTBHOSTJVMINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,222 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostMemoryInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostMemoryInfo module */
+void
+init_ocStbHostMemoryInfo(void)
+{
+    static oid      ocStbHostTotalVideoMemory_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 7, 2, 0 };
+    static oid      ocStbHostAvailableVideoMemory_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 7, 3, 0 };
+    static oid      ocStbHostLargestAvailableBlock_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 7, 1, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostMemoryInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostMemoryInfo", "Initializing\n"));
+		
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostTotalVideoMemory",
+											 get_ocStbHostTotalVideoMemory,
+											 ocStbHostTotalVideoMemory_oid,
+											 OID_LENGTH
+											 (ocStbHostTotalVideoMemory_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostAvailableVideoMemory",
+											 get_ocStbHostAvailableVideoMemory,
+											 ocStbHostAvailableVideoMemory_oid,
+											 OID_LENGTH
+											 (ocStbHostAvailableVideoMemory_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostLargestAvailableBlock",
+											 get_ocStbHostLargestAvailableBlock,
+											 ocStbHostLargestAvailableBlock_oid,
+											 OID_LENGTH
+											 (ocStbHostLargestAvailableBlock_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostTotalVideoMemory(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+	NEXUS_MemoryStatus status;
+	NEXUS_PlatformConfiguration configuration;
+	int total_video_memory = 0;
+	
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+	/* by default, heap[0] is used for video decoder and display */
+	if (configuration.heap[0])
+	{
+		NEXUS_Heap_GetStatus(configuration.heap[0], &status);
+		total_video_memory = status.size;
+	}
+
+	total_video_memory /= 1024;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(total_video_memory)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostAvailableVideoMemory(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+	NEXUS_MemoryStatus status;
+	NEXUS_PlatformConfiguration configuration;
+	int available_video_memory = 0;
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+	/* by default, heap[0] is used for video decoder and display */
+	if (configuration.heap[0])
+	{
+		NEXUS_Heap_GetStatus(configuration.heap[0], &status);
+		available_video_memory = status.largestFreeBlock;
+	}
+
+	available_video_memory /= 1024;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(available_video_memory)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostLargestAvailableBlock(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+	NEXUS_PlatformConfiguration configuration;
+	NEXUS_MemoryStatus status[NEXUS_MAX_HEAPS];
+	int largest_available_block = 0;
+	int i;
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+
+	for (i=0; i<NEXUS_MAX_HEAPS; i++)
+	{
+		if (configuration.heap[i])
+		{
+			NEXUS_Heap_GetStatus(configuration.heap[i], &status[i]);
+			if (status[i].largestFreeBlock > largest_available_block)
+			{
+				largest_available_block = status[i].largestFreeBlock;
+			}
+		}
+	}
+
+	largest_available_block /= 1024;
+	
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(largest_available_block)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMemoryInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,16 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTMEMORYINFO_H
+#define OCSTBHOSTMEMORYINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostMemoryInfo(void);
+Netsnmp_Node_Handler get_ocStbHostTotalVideoMemory;
+Netsnmp_Node_Handler get_ocStbHostAvailableVideoMemory;
+Netsnmp_Node_Handler get_ocStbHostLargestAvailableBlock;
+
+#endif                          /* OCSTBHOSTMEMORYINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,452 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostMpeg2ContentTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "mpeg2ContentTable.h"
+
+/** Initialize the ocStbHostMpeg2ContentTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostMpeg2ContentTable(void)
+{
+    static oid      ocStbHostMpeg2ContentTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 3 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostMpeg2ContentTable",
+                                            ocStbHostMpeg2ContentTable_handler,
+                                            ocStbHostMpeg2ContentTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostMpeg2ContentTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostMpeg2ContentIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 19;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostMpeg2ContentTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostMpeg2ContentTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostMpeg2ContentTable",
+                "Registering table ocStbHostMpeg2ContentTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostMpeg2ContentTable module */
+void
+init_ocStbHostMpeg2ContentTable(void)
+{
+    mibObjects *pObj = &gMibObjs[ocStbHostMpeg2ContentTable];
+    mibObjectMpeg2ContentTable *pTblObj = (mibObjectMpeg2ContentTable *)pObj->obj;
+    struct mpeg2ContentEntry *pEntry;
+    int i;
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+    /*
+     * here we initialize all the tables we're planning on supporting
+     */
+	// snmp_log(LOG_INFO, "init_ocStbHostIEEE1394Table() enter\n");
+    if(pObj->registered)
+	{
+        activateMpeg2Content(); 	  /* MOE initialize mpeg2Content instrumentation */
+        initialize_table_ocStbHostMpeg2ContentTable();
+        for (i=0;i<getMpeg2ContentTotalEntry();i++)
+        {
+            pEntry = getMpeg2ContentEntry(i);
+		    pTblObj->pContainer[i] = &pEntry->data->container;
+        }
+    }
+}
+
+/** returns the first data point within the ocStbHostMpeg2ContentTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostMpeg2ContentTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostMpeg2ContentTable_get_first_data_point(void **my_loop_context,
+                                                void **my_data_context,
+                                                netsnmp_variable_list *
+                                                put_index_data,
+                                                netsnmp_iterator_info
+                                                *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct mpeg2ContentEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    tmpPtr = getMpeg2ContentEntry(0);         /* go ahead and get the first entry */
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+	                   ,
+		               sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostMpeg2ContentTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostMpeg2ContentTable_get_next_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct mpeg2ContentEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    // snmp_log(LOG_INFO, "ocStbHostMpeg2ContentTable_get_next_data_point() enter\n");
+
+    tmpPtr = (struct mpeg2ContentEntry *) *my_loop_context;
+    if (tmpPtr) {
+      tmpPtr = getMpeg2ContentEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+		               ,
+		               sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostMpeg2ContentTable table, if anything else needs to be done */
+int
+ocStbHostMpeg2ContentTable_handler(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct mpeg2ContentData *tmpMpeg2ContentDataPtr;          /* MOE a pointer to some IEEE1394 data */
+    mibObjectMpeg2ContentTable *pObj = (mibObjectMpeg2ContentTable *)gMibObjs[ocStbHostMpeg2ContentTable].obj;
+
+
+    BDBG_ASSERT(pObj != NULL);
+
+    // snmp_log(LOG_INFO, "ocStbHostMpeg2ContentTable_handler() enter\n");
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostMpeg2ContentTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpMpeg2ContentDataPtr = ( struct mpeg2ContentData *) netsnmp_extract_iterator_context(request);
+		if ( tmpMpeg2ContentDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        pObj->callback((void *)pObj, tmpMpeg2ContentDataPtr->index);
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTMPEG2CONTENTPROGRAMNUMBER:
+
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.programNumber)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTTRANSPORTSTREAMID:
+
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.transportStreamId)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTTOTALSTREAMS:
+
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.totalStreams)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTSELECTEDVIDEOPID:
+
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.selectedVideoPid)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTSELECTEDAUDIOPID:
+
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.selectedAudioPid)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTOTHERAUDIOPIDS:
+            {
+                int otherAudioPids = tmpMpeg2ContentDataPtr->container.otherAudioPids ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(otherAudioPids)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTCCIVALUE:
+            {
+                int cciValue;
+                if (tmpMpeg2ContentDataPtr->container.cciValue < 0)
+                {
+                    cciValue = oc_Mpeg2ContentTable_cciNotDefined;
+                }
+                else
+                {
+                    cciValue =  tmpMpeg2ContentDataPtr->container.cciValue;
+                }
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(cciValue)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTAPSVALUE:
+            {
+                int apsValue;
+                if (tmpMpeg2ContentDataPtr->container.apsValue < 0)
+                {
+                    apsValue = oc_Mpeg2ContentTable_apsNotDefined;
+                }
+                else if (tmpMpeg2ContentDataPtr->container.apsValue == 0)
+                {
+                    apsValue = oc_Mpeg2ContentTable_apsNone;
+                }
+                else
+                {
+                    apsValue = tmpMpeg2ContentDataPtr->container.apsValue;
+                }
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(apsValue)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTCITSTATUS:
+            {
+                int citStatus = tmpMpeg2ContentDataPtr->container.citStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(citStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTBROADCASTFLAGSTATUS:
+            {
+                int broadcastFlagStatus = tmpMpeg2ContentDataPtr->container.broadcastFlagStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(broadcastFlagStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTEPNSTATUS:
+            {
+                int epnStatus = tmpMpeg2ContentDataPtr->container.epnStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(epnStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTPCRPID:
+
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.pcrPid)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTPCRLOCKSTATUS:
+            {
+                int pcrLockStatus = tmpMpeg2ContentDataPtr->container.pcrLockStatus ? oc_Mpeg2ContentTable_Locked : oc_Mpeg2ContentTable_UnLocked;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(pcrLockStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTDECODERPTS:
+
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.decoderPts)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTDISCONTINUITIES:
+
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.discontinuities)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTPKTERRORS:
+
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.pktErrors)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTPIPELINEERRORS:
+
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.pipelineErrors)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTMPEG2CONTENTDECODERRESTARTS:
+
+                snmp_set_var_typed_value(var, ASN_COUNTER,
+                                         (u_char *) &(tmpMpeg2ContentDataPtr->container.decoderRestarts)
+                                         , sizeof(int) );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostMpeg2ContentTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostMpeg2ContentTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostMpeg2ContentTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,40 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTMPEG2CONTENTTABLE_H
+#define OCSTBHOSTMPEG2CONTENTTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostMpeg2ContentTable(void);
+void            initialize_table_ocStbHostMpeg2ContentTable(void);
+Netsnmp_Node_Handler ocStbHostMpeg2ContentTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostMpeg2ContentTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostMpeg2ContentTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostMpeg2ContentTable 
+ */
+#define COLUMN_OCSTBHOSTMPEG2CONTENTINDEX		1
+#define COLUMN_OCSTBHOSTMPEG2CONTENTPROGRAMNUMBER		2
+#define COLUMN_OCSTBHOSTMPEG2CONTENTTRANSPORTSTREAMID		3
+#define COLUMN_OCSTBHOSTMPEG2CONTENTTOTALSTREAMS		4
+#define COLUMN_OCSTBHOSTMPEG2CONTENTSELECTEDVIDEOPID		5
+#define COLUMN_OCSTBHOSTMPEG2CONTENTSELECTEDAUDIOPID		6
+#define COLUMN_OCSTBHOSTMPEG2CONTENTOTHERAUDIOPIDS		7
+#define COLUMN_OCSTBHOSTMPEG2CONTENTCCIVALUE		8
+#define COLUMN_OCSTBHOSTMPEG2CONTENTAPSVALUE		9
+#define COLUMN_OCSTBHOSTMPEG2CONTENTCITSTATUS		10
+#define COLUMN_OCSTBHOSTMPEG2CONTENTBROADCASTFLAGSTATUS		11
+#define COLUMN_OCSTBHOSTMPEG2CONTENTEPNSTATUS		12
+#define COLUMN_OCSTBHOSTMPEG2CONTENTPCRPID		13
+#define COLUMN_OCSTBHOSTMPEG2CONTENTPCRLOCKSTATUS		14
+#define COLUMN_OCSTBHOSTMPEG2CONTENTDECODERPTS		15
+#define COLUMN_OCSTBHOSTMPEG2CONTENTDISCONTINUITIES		16
+#define COLUMN_OCSTBHOSTMPEG2CONTENTPKTERRORS		17
+#define COLUMN_OCSTBHOSTMPEG2CONTENTPIPELINEERRORS		18
+#define COLUMN_OCSTBHOSTMPEG2CONTENTDECODERRESTARTS		19
+#endif                          /* OCSTBHOSTMPEG2CONTENTTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,67 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostNotifications.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostNotifications module */
+void
+init_ocStbHostNotifications(void)
+{
+    static oid      ocStbPanicDumpTrap_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 0, 1, 0 };
+
+    DEBUGMSGTL(("ocStbHostNotifications", "Initializing\n"));
+
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbPanicDumpTrap",
+                                         get_ocStbPanicDumpTrap,
+                                         ocStbPanicDumpTrap_oid,
+                                         OID_LENGTH
+                                         (ocStbPanicDumpTrap_oid),
+                                         HANDLER_CAN_RONLY));
+}
+
+int
+get_ocStbPanicDumpTrap(netsnmp_mib_handler *handler,
+                       netsnmp_handler_registration *reginfo,
+                       netsnmp_agent_request_info *reqinfo,
+                       netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb,,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostNotifications.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,14 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTNOTIFICATIONS_H
+#define OCSTBHOSTNOTIFICATIONS_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostNotifications(void);
+Netsnmp_Node_Handler get_ocStbPanicDumpTrap;
+
+#endif                          /* OCSTBHOSTNOTIFICATIONS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostPower.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostPower.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostPower.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostPower.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,135 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostPower.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostPower module */
+void
+init_ocStbHostPower(void)
+{
+    static oid      ocStbHostPowerStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 1, 1, 0 };
+    static oid      ocStbHostAcOutletStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 1, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostPower];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostPower", "Initializing\n"));
+		
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostPowerStatus",
+											 get_ocStbHostPowerStatus,
+											 ocStbHostPowerStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostPowerStatus_oid),
+											 HANDLER_CAN_RONLY));
+#if 0 /* Optional, do not support */
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostAcOutletStatus",
+											 get_ocStbHostAcOutletStatus,
+											 ocStbHostAcOutletStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostAcOutletStatus_oid),
+											 HANDLER_CAN_RONLY));
+#endif
+	}
+}
+
+int
+get_ocStbHostPowerStatus(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectPower *pObj = (mibObjectPower *)gMibObjs[ocStbHostPower].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.powerStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+#if 0 /* Optional, do not support */
+int
+get_ocStbHostAcOutletStatus(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostPower.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostPower.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostPower.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostPower.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,17 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTPOWER_H
+#define OCSTBHOSTPOWER_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostPower(void);
+Netsnmp_Node_Handler get_ocStbHostPowerStatus;
+#if 0 /* Optional, do not support */
+Netsnmp_Node_Handler get_ocStbHostAcOutletStatus;
+#endif
+
+#endif                          /* OCSTBHOSTPOWER_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,504 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostProgramStatusTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "programStatusTable.h"
+
+static oid av_source_oid[] = { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 2, 1, 2, 0 }; /* ocStbHostAVInterfaceType */
+static oid av_destination_oid[] = { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 2, 1, 2, 0 }; /* ocStbHostAVInterfaceType */
+static oid content_source_oid[] = { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 3, 1, 2, 0 }; /* ocStbHostMpeg2ContentProgramNumber */
+static oid content_destination_oid[] = { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 3, 1, 2, 0 }; /* ocStbHostMpeg2ContentProgramNumber */
+
+/** Initialize the ocStbHostProgramStatusTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostProgramStatusTable(void)
+{
+    static oid      ocStbHostProgramStatusTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 7, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostProgramStatusTable",
+                                            ocStbHostProgramStatusTable_handler,
+                                            ocStbHostProgramStatusTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostProgramStatusTable_oid),
+                                            HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostProgramIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 5;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostProgramStatusTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostProgramStatusTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostProgramStatusTable",
+                "Registering table ocStbHostProgramStatusTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostProgramStatusTable module */
+void
+init_ocStbHostProgramStatusTable(void)
+{
+    mibObjects *pObj = &gMibObjs[ocStbHostProgramStatusTable];
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+    /*
+     * here we initialize all the tables we're planning on supporting 
+     */
+	/* snmp_log(LOG_INFO, "init_ocStbHostProgramStatusTable() enter\n"); */
+    if(pObj->registered)
+    {
+     activateProgramStatus(); 	  /* MOE initialize programStatus instrumentation */
+     initialize_table_ocStbHostProgramStatusTable();
+    }
+}
+
+/** returns the first data point within the ocStbHostProgramStatusTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostProgramStatusTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostProgramStatusTable_get_first_data_point(void **my_loop_context,
+                                                 void **my_data_context,
+                                                 netsnmp_variable_list *
+                                                 put_index_data,
+                                                 netsnmp_iterator_info
+                                                 *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct programStatusEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    tmpPtr = getProgramStatusEntry(0);         /* go ahead and get the first entry */
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+	                   );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostProgramStatusTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostProgramStatusTable_get_next_data_point(void **my_loop_context,
+                                                void **my_data_context,
+                                                netsnmp_variable_list *
+                                                put_index_data,
+                                                netsnmp_iterator_info
+                                                *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct programStatusEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostProgramStatusTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct programStatusEntry *) *my_loop_context;
+    if (tmpPtr) {
+      tmpPtr = getProgramStatusEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+	                   );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostProgramStatusTable table, if anything else needs to be done */
+int
+ocStbHostProgramStatusTable_handler(netsnmp_mib_handler *handler,
+                                    netsnmp_handler_registration *reginfo,
+                                    netsnmp_agent_request_info *reqinfo,
+                                    netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct programStatusData *tmpProgramStatusDataPtr;          /* MOE a pointer to some IEEE1394 data */
+    mibObjectProgramStatusTable *pObj = (mibObjectProgramStatusTable *)gMibObjs[ocStbHostProgramStatusTable].obj;
+	NEXUS_PlatformConfiguration configuration;
+	NEXUS_HdmiOutputStatus status;
+	int avIfIdxIbTuner[NUM_INBAND_TUNERS];
+	int avIfIdxHdmi[NEXUS_NUM_HDMI_OUTPUTS];
+	int avIfIdxComponent[NEXUS_NUM_COMPONENT_OUTPUTS];
+	int avIfIdxBbVideo[NEXUS_NUM_COMPOSITE_OUTPUTS];
+	int avIfIdxBbAudio[NEXUS_NUM_AUDIO_DACS];
+	int avIfIdxSvideo[NEXUS_NUM_SVIDEO_OUTPUTS];
+	int avIfIdxSpdif[NEXUS_NUM_SPDIF_OUTPUTS];
+	int avIfIdxRfm[NEXUS_NUM_RFM_OUTPUTS];
+	int i;
+
+    /* snmp_log(LOG_INFO, "ocStbHostProgramStatusTable_handler() enter\n"); */
+
+	NEXUS_Platform_GetConfiguration(&configuration);
+	NEXUS_HdmiOutput_GetStatus(configuration.outputs.hdmi[0], &status);
+
+	checkAVInterfacesStatus();
+	checkAVInterfaceExistence(ocStbHostScte40FatRx, avIfIdxIbTuner);
+	checkAVInterfaceExistence((status.hdmiDevice ? ocStbHostHdmiOut : ocStbHostDviOut), avIfIdxHdmi);
+	checkAVInterfaceExistence(ocStbHostComponentOut, avIfIdxComponent);
+	checkAVInterfaceExistence(ocStbHostBbVideoOut, avIfIdxBbVideo);
+	checkAVInterfaceExistence(ocStbHostBbAudioOut, avIfIdxBbAudio);
+	checkAVInterfaceExistence(ocStbHostSVideoOut, avIfIdxSvideo);
+	checkAVInterfaceExistence(ocStbHostRcaSpdifOut, avIfIdxSpdif);
+	checkAVInterfaceExistence(ocStbHostRfOutCh, avIfIdxRfm);
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostProgramStatusTable table in question 
+         */
+		/* MOE extract the data pointer */
+		tmpProgramStatusDataPtr = ( struct programStatusData *) netsnmp_extract_iterator_context(request);
+		if ( tmpProgramStatusDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, (tmpProgramStatusDataPtr->index < 7) ? 0 : 1);
+
+#if BCHP_CHIP == 7405
+		/* 1. Tuner0/1 -> Decode0 -> HDMI/DVI
+		   2. Tuner0/1 -> Decode0 -> Component
+		   3. Tuner0/1 -> Decode0 -> Baseband video output
+		   4. Tuner0/1 -> Decode0 -> Baseband audio output
+		   5. Tuner0/1 -> Decode0 -> SVIDEO
+		   6. Tuner0/1 -> Decode0 -> SPDIF
+		   7. Tuner0/1 -> Decode0 -> RF Out
+		*/
+		switch (tmpProgramStatusDataPtr->index)
+		{
+			case 0:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxHdmi[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 1:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxComponent[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 2:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbVideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 3:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbAudio[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 4:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSvideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 5:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSpdif[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 6:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxRfm[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			default:
+				break;
+
+		}
+#elif (BCHP_CHIP == 7420 || BCHP_CHIP == 7400)
+		/* 1. Tuner0 -> Decode0 -> HDMI/DVI
+		   2. Tuner0 -> Decode0 -> Component
+		   3. Tuner0 -> Decode0 -> Baseband video output
+		   4. Tuner0 -> Decode0 -> Baseband audio output
+		   5. Tuner0 -> Decode0 -> SVIDEO
+		   6. Tuner0 -> Decode0 -> SPDIF
+		   7. Tuner0 -> Decode0 -> RF Out
+		   8. Tuner1 -> Decode1 -> HDMI/DVI
+		   9. Tuner1 -> Decode1 -> Component
+		  10. Tuner1 -> Decode1 -> Baseband video output
+		  11. Tuner1 -> Decode1 -> Baseband audio output
+		  12. Tuner1 -> Decode1 -> SVIDEO
+		  13. Tuner1 -> Decode1 -> SPDIF
+		  14. Tuner1 -> Decode1 -> RF Out
+		*/
+		switch (tmpProgramStatusDataPtr->index)
+		{
+			case 0:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxHdmi[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 1:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxComponent[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 2:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbVideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 3:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbAudio[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 4:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSvideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 5:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSpdif[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 6:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[0];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxRfm[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 7:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxHdmi[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+
+			case 8:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxComponent[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 9:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbVideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 10:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxBbAudio[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 11:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSvideo[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 12:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxSpdif[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			case 13:
+				tmpProgramStatusDataPtr->container.avSource = avIfIdxIbTuner[1];
+				tmpProgramStatusDataPtr->container.avDestination = avIfIdxRfm[0];
+				tmpProgramStatusDataPtr->container.contentDestination = pObj->decode_index;
+				tmpProgramStatusDataPtr->container.contentSource = pObj->decode_index;
+				break;
+			default:
+				break;
+		}
+#endif
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTPROGRAMAVSOURCE:
+				av_source_oid[OID_LENGTH(av_source_oid)-1] = tmpProgramStatusDataPtr->container.avSource;
+                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
+                                         (u_char *) (av_source_oid)
+                                         , sizeof(av_source_oid) );
+                break;
+
+            case COLUMN_OCSTBHOSTPROGRAMAVDESTINATION:
+				av_destination_oid[OID_LENGTH(av_destination_oid)-1] = tmpProgramStatusDataPtr->container.avDestination;
+                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
+                                         (u_char *) (av_destination_oid)
+                                         , sizeof(av_destination_oid) );
+                break;
+
+            case COLUMN_OCSTBHOSTPROGRAMCONTENTSOURCE:
+				content_source_oid[OID_LENGTH(content_source_oid)-1] = tmpProgramStatusDataPtr->container.contentSource;
+                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
+                                         (u_char *) (content_source_oid)
+                                         , sizeof(content_source_oid) );
+                break;
+
+            case COLUMN_OCSTBHOSTPROGRAMCONTENTDESTINATION:
+				content_destination_oid[OID_LENGTH(content_destination_oid)-1] = tmpProgramStatusDataPtr->container.contentDestination;
+                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
+                                         (u_char *) (content_destination_oid)
+                                         , sizeof(content_destination_oid) );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostProgramStatusTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostProgramStatusTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostProgramStatusTable.h	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,26 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTPROGRAMSTATUSTABLE_H
+#define OCSTBHOSTPROGRAMSTATUSTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostProgramStatusTable(void);
+void            initialize_table_ocStbHostProgramStatusTable(void);
+Netsnmp_Node_Handler ocStbHostProgramStatusTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostProgramStatusTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostProgramStatusTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostProgramStatusTable 
+ */
+#define COLUMN_OCSTBHOSTPROGRAMINDEX		1
+#define COLUMN_OCSTBHOSTPROGRAMAVSOURCE		2
+#define COLUMN_OCSTBHOSTPROGRAMAVDESTINATION		3
+#define COLUMN_OCSTBHOSTPROGRAMCONTENTSOURCE		4
+#define COLUMN_OCSTBHOSTPROGRAMCONTENTDESTINATION		5
+#endif                          /* OCSTBHOSTPROGRAMSTATUSTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,697 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostQpskObjects.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostQpskObjects module */
+void
+init_ocStbHostQpskObjects(void)
+{
+    static oid      ocStbHostQpskFDCFreq_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 1, 0 };
+    static oid      ocStbHostQpskRDCDataRate_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 11, 0 };
+    static oid      ocStbHostQpskFDCSNR_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 8, 0 };
+    static oid      ocStbHostQpskFDCPower_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 6, 0 };
+    static oid      ocStbHostQpskFDCBer_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 3, 0 };
+    static oid      ocStbHostQpskRDCPower_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 10, 0 };
+    static oid      ocStbHostQpskFDCStatus_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 4, 0 };
+    static oid      ocStbHostQpskFDCLockedTime_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 7, 0 };
+    static oid      ocStbHostQpskAGC_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 9, 0 };
+    static oid      ocStbHostQpskRDCFreq_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 2, 0 };
+    static oid      ocStbHostQpskFDCBytesRead_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 8, 5, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostQpskObjects];
+	int i;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostQpskObjects", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCFreq",
+											 get_ocStbHostQpskFDCFreq,
+											 ocStbHostQpskFDCFreq_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCFreq_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskRDCDataRate",
+											 get_ocStbHostQpskRDCDataRate,
+											 ocStbHostQpskRDCDataRate_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskRDCDataRate_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCSNR",
+											 get_ocStbHostQpskFDCSNR,
+											 ocStbHostQpskFDCSNR_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCSNR_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCPower",
+											 get_ocStbHostQpskFDCPower,
+											 ocStbHostQpskFDCPower_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCPower_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCBer",
+											 get_ocStbHostQpskFDCBer,
+											 ocStbHostQpskFDCBer_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCBer_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskRDCPower",
+											 get_ocStbHostQpskRDCPower,
+											 ocStbHostQpskRDCPower_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskRDCPower_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCStatus",
+											 get_ocStbHostQpskFDCStatus,
+											 ocStbHostQpskFDCStatus_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCStatus_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCLockedTime",
+											 get_ocStbHostQpskFDCLockedTime,
+											 ocStbHostQpskFDCLockedTime_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCLockedTime_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskAGC",
+											 get_ocStbHostQpskAGC,
+											 ocStbHostQpskAGC_oid,
+											 OID_LENGTH(ocStbHostQpskAGC_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskRDCFreq",
+											 get_ocStbHostQpskRDCFreq,
+											 ocStbHostQpskRDCFreq_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskRDCFreq_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostQpskFDCBytesRead",
+											 get_ocStbHostQpskFDCBytesRead,
+											 ocStbHostQpskFDCBytesRead_oid,
+											 OID_LENGTH
+											 (ocStbHostQpskFDCBytesRead_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostQpskFDCFreq(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.fdcFreq)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskRDCDataRate(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *reqinfo,
+                             netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int rdcDataRate = oc_qpskRDCDataRate_kbps256;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	switch (2*pObj->container.rdcDataRate/1000)
+	{
+		case 256:
+			rdcDataRate = oc_qpskRDCDataRate_kbps256;
+			break;
+		case 1544:
+			rdcDataRate = oc_qpskRDCDataRate_kbps1544;
+			break;
+		case 2048:
+			/* Not defined in ocStbHostQpskRDCDataRate */
+			/* What to do if data rate is 2048kbps ? */
+			break;
+		case 3088:
+			rdcDataRate = oc_qpskRDCDataRate_kbps3088;
+			break;
+	}
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(rdcDataRate)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCSNR(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int fdcSnr; /* in a unit of tenth dB */
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	fdcSnr = pObj->container.fdcSNR/10;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(fdcSnr)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCPower(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int fdcPower; /* in a unit of tenth dBmV */
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	fdcPower = pObj->container.fdcPower;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(fdcPower)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCBer(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int fdcBer = oc_berNotApplicable;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	if (pObj->container.fdcBer > 0 || pObj->container.fdcBer == UNSUPPORTED_MIB)
+	{
+		fdcBer = oc_berNotApplicable;
+	}
+	else if (pObj->container.fdcBer > -2  && pObj->container.fdcBer <= 0)
+	{
+		fdcBer = oc_berGreaterThan10e2;
+	}
+	else if (pObj->container.fdcBer > -4 && pObj->container.fdcBer <= -2)
+	{
+		fdcBer = oc_berRange10e2ToGreaterThan10e4;
+	}
+	else if (pObj->container.fdcBer > -6 && pObj->container.fdcBer <= -4)
+	{
+		fdcBer = oc_berRange10e4ToGreaterThan10e6;
+	}
+	else if (pObj->container.fdcBer > -8 && pObj->container.fdcBer <= -6)
+	{
+		fdcBer = oc_berRange10e6ToGreaterThan10e8;
+	}
+	else if (pObj->container.fdcBer > -12 && pObj->container.fdcBer <= -8)
+	{
+		fdcBer = oc_berRange10e8ToGreaterThan10e10;
+	}
+	else if (pObj->container.fdcBer <= -12)
+	{
+		fdcBer = oc_berEqualToOrLessThan10e12;
+	}
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(fdcBer)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskRDCPower(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int rdcPower; /* in a unit of tenth dBmV */
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	rdcPower = pObj->container.rdcPower;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(rdcPower)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCStatus(netsnmp_mib_handler *handler,
+                           netsnmp_handler_registration *reginfo,
+                           netsnmp_agent_request_info *reqinfo,
+                           netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int status;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	switch (pObj->container.state)
+	{
+		case tuner_locked:
+			status = oc_qpskFDCLockStatus_locked;
+			break;
+		case tuner_idle:
+		case tuner_tuning:
+		case tuner_failed:
+        default:
+			status = oc_qpskFDCLockStatus_notLocked;
+			break;
+	}
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(status)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCLockedTime(netsnmp_mib_handler *handler,
+                               netsnmp_handler_registration *reginfo,
+                               netsnmp_agent_request_info *reqinfo,
+                               netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.lockedTime)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskAGC(netsnmp_mib_handler *handler,
+                     netsnmp_handler_registration *reginfo,
+                     netsnmp_agent_request_info *reqinfo,
+                     netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+	int agc;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+	agc = pObj->container.agc/10;
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(agc)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskRDCFreq(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.rdcFreq)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostQpskFDCBytesRead(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+	mibObjectQpskObjects *pObj = (mibObjectQpskObjects *)gMibObjs[ocStbHostQpskObjects].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)
+                                 &(pObj->container.fdcBytesRead)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostQpskObjects.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,24 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTQPSKOBJECTS_H
+#define OCSTBHOSTQPSKOBJECTS_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostQpskObjects(void);
+Netsnmp_Node_Handler get_ocStbHostQpskFDCFreq;
+Netsnmp_Node_Handler get_ocStbHostQpskRDCDataRate;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCSNR;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCPower;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCBer;
+Netsnmp_Node_Handler get_ocStbHostQpskRDCPower;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCStatus;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCLockedTime;
+Netsnmp_Node_Handler get_ocStbHostQpskAGC;
+Netsnmp_Node_Handler get_ocStbHostQpskRDCFreq;
+Netsnmp_Node_Handler get_ocStbHostQpskFDCBytesRead;
+
+#endif                          /* OCSTBHOSTQPSKOBJECTS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,188 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostRebootInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "rebootInfo.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostRebootInfo module */
+void
+init_ocStbHostRebootInfo(void)
+{
+    static oid      ocStbHostRebootType_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 6, 1, 0 };
+    static oid      ocStbHostRebootReset_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 6, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostRebootInfo];
+	FILE *fp;
+	int rebootTypeUnknown = oc_rebootType_unknown;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostRebootInfo", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostRebootType",
+											 get_ocStbHostRebootType,
+											 ocStbHostRebootType_oid,
+											 OID_LENGTH
+											 (ocStbHostRebootType_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostRebootReset",
+								   do_ocStbHostRebootReset,
+								   ocStbHostRebootReset_oid,
+								   OID_LENGTH(ocStbHostRebootReset_oid),
+								   HANDLER_CAN_RWRITE));
+	}
+}
+
+int
+get_ocStbHostRebootType(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	mibObjectRebootInfo *pObj = (mibObjectRebootInfo *)gMibObjs[ocStbHostRebootInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.rebootType)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostRebootReset(netsnmp_mib_handler *handler,
+                        netsnmp_handler_registration *reginfo,
+                        netsnmp_agent_request_info *reqinfo,
+                        netsnmp_request_info *requests)
+{
+	int reset = oc_false; /* always return false when query */
+	mibObjectRebootInfo *pObj = (mibObjectRebootInfo *)gMibObjs[ocStbHostRebootInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->set_callback);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(reset)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        /*
+         * check type
+         */
+        if (requests->requestvb->type != ASN_INTEGER) {
+            /*
+             * not an integer.  Bad dog, no bone.
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGTYPE);
+			return;
+        }
+		/*
+		 * check value
+		 */
+        if ( *requests->requestvb->val.integer != 1 ) {
+			/*
+			 * the value must be 1.
+			 */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGVALUE
+                                      );
+			return;
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        break;
+
+    case MODE_SET_FREE:
+        break;
+
+    case MODE_SET_ACTION:
+		pObj->set_callback(NULL, 0);
+        break;
+
+    case MODE_SET_COMMIT:
+        break;
+
+    case MODE_SET_UNDO:
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRebootInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,15 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTREBOOTINFO_H
+#define OCSTBHOSTREBOOTINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostRebootInfo(void);
+Netsnmp_Node_Handler get_ocStbHostRebootType;
+Netsnmp_Node_Handler do_ocStbHostRebootReset;
+
+#endif                          /* OCSTBHOSTREBOOTINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,332 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostRFChannelOutTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "rfChannelOutTable.h"
+#include "avInterfaceTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostRFChannelOutTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostRFChannelOutTable(void)
+{
+    static oid      ocStbHostRFChannelOutTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 5, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostRFChannelOutTable",
+                                            ocStbHostRFChannelOutTable_handler,
+                                            ocStbHostRFChannelOutTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostRFChannelOutTable_oid),
+											HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostRFChannelOutIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 4;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostRFChannelOutTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostRFChannelOutTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostRFChannelOutTable",
+                "Registering table ocStbHostRFChannelOutTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostRFChannelOutTable module */
+void
+init_ocStbHostRFChannelOutTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostRFChannelOutTable];
+	mibObjectRfChannelOutTable *pTblObj = (mibObjectRfChannelOutTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostRFChannelOutTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		if (checkAVInterfaceExistence(ocStbHostRfOutCh, NULL))
+		{
+			/*
+			 * here we initialize all the tables we're planning on supporting
+			 */
+			activateRfChannelOut(); 	  /* MOE initialize RfChannelOut instrumentation */
+			initialize_table_ocStbHostRFChannelOutTable();
+
+#if NEXUS_NUM_RFM_OUTPUTS
+			for (i=0; i<NEXUS_NUM_RFM_OUTPUTS; i++)
+			{
+				struct rfChannelOutEntry *pEntry = getRfChannelOutEntry(i);
+				pTblObj->pContainer[i] = &pEntry->data->container;
+			}
+#endif
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostRFChannelOutTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostRFChannelOutTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostRFChannelOutTable_get_first_data_point(void **my_loop_context,
+                                                void **my_data_context,
+                                                netsnmp_variable_list *
+                                                put_index_data,
+                                                netsnmp_iterator_info
+                                                *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct rfChannelOutEntry *tmpPtr;  			/* MOE a pointer to the first entry */
+
+    tmpPtr = getRfChannelOutEntry(0);			/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     	/* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+		               sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostRFChannelOutTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostRFChannelOutTable_get_next_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct rfChannelOutEntry *tmpPtr;  				/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostRFChannelOutTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct rfChannelOutEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getRfChannelOutEntry(tmpPtr->index);	/* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+		               (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostRFChannelOutTable table, if anything else needs to be done */
+int
+ocStbHostRFChannelOutTable_handler(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct rfChannelOutData *tmpRfChannelOutDataPtr;          /* MOE a pointer to some RFChannelOut data */
+	mibObjectRfChannelOutTable *pObj = (mibObjectRfChannelOutTable *)gMibObjs[ocStbHostRFChannelOutTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostRFChannelOutTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostRFChannelOutTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpRfChannelOutDataPtr = ( struct rfChannelOutData *) netsnmp_extract_iterator_context(request);
+		if ( tmpRfChannelOutDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpRfChannelOutDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTRFCHANNELOUT:
+			{
+				int channelOut = tmpRfChannelOutDataPtr->container.channelOut;
+                snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                         (u_char *) &(channelOut)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTRFCHANNELOUTAUDIOMUTESTATUS:
+			{
+				int audioMuteStatus = tmpRfChannelOutDataPtr->container.audioMuteStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(audioMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTRFCHANNELOUTVIDEOMUTESTATUS:
+			{
+				int videoMuteStatus = tmpRfChannelOutDataPtr->container.videoMuteStatus ? oc_true : oc_false;
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(videoMuteStatus)
+                                         , sizeof(int) );
+                break;
+            }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostRFChannelOutTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostRFChannelOutTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostRFChannelOutTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,24 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTRFCHANNELOUTTABLE_H
+#define OCSTBHOSTRFCHANNELOUTTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostRFChannelOutTable(void);
+void            initialize_table_ocStbHostRFChannelOutTable(void);
+Netsnmp_Node_Handler ocStbHostRFChannelOutTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostRFChannelOutTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostRFChannelOutTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostRFChannelOutTable 
+ */
+#define COLUMN_OCSTBHOSTRFCHANNELOUT		2
+#define COLUMN_OCSTBHOSTRFCHANNELOUTAUDIOMUTESTATUS		3
+#define COLUMN_OCSTBHOSTRFCHANNELOUTVIDEOMUTESTATUS		4
+#endif                          /* OCSTBHOSTRFCHANNELOUTTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,186 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSecuritySubSystem.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostSecuritySubSystem module */
+void
+init_ocStbHostSecuritySubSystem(void)
+{
+    static oid      ocStbHostSecurityIdentifier_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 2, 2, 0 };
+    static oid      ocStbHostCASystemIdentifier_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 2, 3, 0 };
+    static oid      ocStbHostCAType_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 2, 4, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostSecuritySubSystem];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+			DEBUGMSGTL(("ocStbHostSecuritySubSystem", "Initializing\n"));
+		
+#if 0 /* ocStbHostSecurityIdentifier is deprecated */
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostSecurityIdentifier",
+												 get_ocStbHostSecurityIdentifier,
+												 ocStbHostSecurityIdentifier_oid,
+												 OID_LENGTH
+												 (ocStbHostSecurityIdentifier_oid),
+												 HANDLER_CAN_RONLY));
+#endif
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostCASystemIdentifier",
+												 get_ocStbHostCASystemIdentifier,
+												 ocStbHostCASystemIdentifier_oid,
+												 OID_LENGTH
+												 (ocStbHostCASystemIdentifier_oid),
+												 HANDLER_CAN_RONLY));
+			netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+												("ocStbHostCAType",
+												 get_ocStbHostCAType,
+												 ocStbHostCAType_oid,
+												 OID_LENGTH(ocStbHostCAType_oid),
+												 HANDLER_CAN_RONLY));
+	}
+}
+
+#if 0 /* ocStbHostSecurityIdentifier is deprecated */
+int
+get_ocStbHostCASystemIdentifier(netsnmp_mib_handler *handler,
+                                netsnmp_handler_registration *reginfo,
+                                netsnmp_agent_request_info *reqinfo,
+                                netsnmp_request_info *requests)
+{
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 /* XXX: a pointer to the scalar's data */
+                                 ,
+                                 /* XXX: the length of the data in bytes */
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+#endif
+
+int
+get_ocStbHostCASystemIdentifier(netsnmp_mib_handler *handler,
+                                netsnmp_handler_registration *reginfo,
+                                netsnmp_agent_request_info *reqinfo,
+                                netsnmp_request_info *requests)
+{
+	mibObjectSecuritySubSystem *pObj = (mibObjectSecuritySubSystem *)gMibObjs[ocStbHostSecuritySubSystem].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.caId)
+                                 ,
+                                 strlen(pObj->container.caId)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCAType(netsnmp_mib_handler *handler,
+                    netsnmp_handler_registration *reginfo,
+                    netsnmp_agent_request_info *reqinfo,
+                    netsnmp_request_info *requests)
+{
+	mibObjectSecuritySubSystem *pObj = (mibObjectSecuritySubSystem *)gMibObjs[ocStbHostSecuritySubSystem].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.caType)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSecuritySubSystem.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,18 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTSECURITYSUBSYSTEM_H
+#define OCSTBHOSTSECURITYSUBSYSTEM_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSecuritySubSystem(void);
+#if 0
+Netsnmp_Node_Handler get_ocStbHostSecurityIdentifier;
+#endif
+Netsnmp_Node_Handler get_ocStbHostCASystemIdentifier;
+Netsnmp_Node_Handler get_ocStbHostCAType;
+
+#endif                          /* OCSTBHOSTSECURITYSUBSYSTEM_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,371 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSnmpProxyInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostSnmpProxyInfo module */
+void
+init_ocStbHostSnmpProxyInfo(void)
+{
+    static oid      ocStbHostCardSerialNumber_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 4, 0 };
+    static oid      ocStbHostCardMfgId_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 1, 0 };
+	static oid		ocStbHostCardSnmpAccessControl_oid[] =
+		{ 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 5, 0 };
+    static oid      ocStbHostCardRootOid_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 3, 0 };
+    static oid      ocStbHostCardVersion_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 4, 6, 2, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostSnmpProxyInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostSnmpProxyInfo", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardSerialNumber",
+											 get_ocStbHostCardSerialNumber,
+											 ocStbHostCardSerialNumber_oid,
+											 OID_LENGTH
+											 (ocStbHostCardSerialNumber_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardMfgId",
+											 get_ocStbHostCardMfgId,
+											 ocStbHostCardMfgId_oid,
+											 OID_LENGTH
+											 (ocStbHostCardMfgId_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_instance(netsnmp_create_handler_registration
+								  ("ocStbHostCardSnmpAccessControl",
+								   do_ocStbHostCardSnmpAccessControl,
+								   ocStbHostCardSnmpAccessControl_oid,
+								   OID_LENGTH
+								   (ocStbHostCardSnmpAccessControl_oid),
+								   HANDLER_CAN_RWRITE));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardRootOid",
+											 get_ocStbHostCardRootOid,
+											 ocStbHostCardRootOid_oid,
+											 OID_LENGTH
+											 (ocStbHostCardRootOid_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCardVersion",
+											 get_ocStbHostCardVersion,
+											 ocStbHostCardVersion_oid,
+											 OID_LENGTH
+											 (ocStbHostCardVersion_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostCardSerialNumber(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+	mibObjectSnmpProxyInfo *pObj = (mibObjectSnmpProxyInfo *)gMibObjs[ocStbHostSnmpProxyInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 pObj->container.cardSerialNum
+                                 ,
+                                 strlen(pObj->container.cardSerialNum)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardMfgId(netsnmp_mib_handler *handler,
+                       netsnmp_handler_registration *reginfo,
+                       netsnmp_agent_request_info *reqinfo,
+                       netsnmp_request_info *requests)
+{
+	mibObjectSnmpProxyInfo *pObj = (mibObjectSnmpProxyInfo *)gMibObjs[ocStbHostSnmpProxyInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.cardMfgId)
+                                 ,
+                                 sizeof(pObj->container.cardMfgId)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+do_ocStbHostCardSnmpAccessControl(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+	mibObjectSnmpProxyInfo *pObj = (mibObjectSnmpProxyInfo *)gMibObjs[ocStbHostSnmpProxyInfo].obj;
+	int newAccessControl = oc_true;
+	static int oldAccessControl = oc_true;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+    BDBG_ASSERT(pObj->set_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+		{
+			int accessControl = pObj->container.discardCardSnmpAccessControl ?   oc_false : oc_true;
+	        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+	                                 (u_char *)
+	                                 &(accessControl)
+	                                 ,
+	                                 sizeof(int)
+	                                 );
+		}
+	    break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+    case MODE_SET_RESERVE1:
+        /*
+         * check type
+         */
+        if (requests->requestvb->type != ASN_INTEGER) {
+            /*
+             * not an integer.  Bad dog, no bone.
+             */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGTYPE);
+			return;
+        }
+		/*
+		 * check value
+		 */
+		if ( *requests->requestvb->val.integer != 1 && *requests->requestvb->val.integer != 2) {
+			/*
+			 * the value must be either 1 or 2 (TruthValue).
+			 */
+            netsnmp_set_request_error(reqinfo, requests,
+                                      SNMP_ERR_WRONGVALUE
+                                      );
+			return;
+        }
+        break;
+
+    case MODE_SET_RESERVE2:
+        break;
+
+    case MODE_SET_FREE:
+        break;
+
+    case MODE_SET_ACTION:
+		oldAccessControl = pObj->container.discardCardSnmpAccessControl ? oc_false : oc_true;
+		newAccessControl = *requests->requestvb->val.integer;
+		if (newAccessControl == oc_true)
+		{
+			pObj->set_callback((void *)pObj, false);
+		}
+		else if (newAccessControl == oc_false)
+		{
+			pObj->set_callback((void *)pObj, true);
+		}
+        break;
+
+    case MODE_SET_COMMIT:
+        break;
+
+    case MODE_SET_UNDO:
+		newAccessControl = oldAccessControl;
+		oldAccessControl = oc_true;
+		if (newAccessControl == oc_true)
+		{
+			pObj->set_callback((void *)pObj, false);
+		}
+		else if (newAccessControl == oc_false)
+		{
+			pObj->set_callback((void *)pObj, true);
+		}
+        break;
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardRootOid(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectSnmpProxyInfo *pObj = (mibObjectSnmpProxyInfo *)gMibObjs[ocStbHostSnmpProxyInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
+                                 (u_char *)
+                                 pObj->container.cardRootOid
+                                 ,
+								 pObj->container.rootOidLen*sizeof(oid)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCardVersion(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+	mibObjectSnmpProxyInfo *pObj = (mibObjectSnmpProxyInfo *)gMibObjs[ocStbHostSnmpProxyInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->get_callback);
+
+	pObj->get_callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.cardVersion)
+                                 ,
+                                 sizeof(pObj->container.cardVersion)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSnmpProxyInfo.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,18 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTSNMPPROXYINFO_H
+#define OCSTBHOSTSNMPPROXYINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSnmpProxyInfo(void);
+Netsnmp_Node_Handler get_ocStbHostCardSerialNumber;
+Netsnmp_Node_Handler get_ocStbHostCardMfgId;
+Netsnmp_Node_Handler do_ocStbHostCardSnmpAccessControl;
+Netsnmp_Node_Handler get_ocStbHostCardRootOid;
+Netsnmp_Node_Handler get_ocStbHostCardVersion;
+
+#endif                          /* OCSTBHOSTSNMPPROXYINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,251 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSoftwareApplicationInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostSoftwareApplicationInfo module */
+void
+init_ocStbHostSoftwareApplicationInfo(void)
+{
+    static oid
+        ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 3, 4, 0 };
+    static oid
+        ocStbHostSoftwareApplicationInfoSigLastReceivedTime_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 3, 2, 0 };
+    static oid      ocStbHostSoftwareApplicationInfoSigLastReadStatus_oid[]
+        = { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 3, 3, 0 };
+    static oid      ocStbHostSoftwareApplicationInfoSigVersionInUse_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 3, 5, 0 };
+
+    DEBUGMSGTL(("ocStbHostSoftwareApplicationInfo", "Initializing\n"));
+
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead",
+                                         get_ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead,
+                                         ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead_oid,
+                                         OID_LENGTH
+                                         (ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead_oid),
+                                         HANDLER_CAN_RONLY));
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbHostSoftwareApplicationInfoSigLastReceivedTime",
+                                         get_ocStbHostSoftwareApplicationInfoSigLastReceivedTime,
+                                         ocStbHostSoftwareApplicationInfoSigLastReceivedTime_oid,
+                                         OID_LENGTH
+                                         (ocStbHostSoftwareApplicationInfoSigLastReceivedTime_oid),
+                                         HANDLER_CAN_RONLY));
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbHostSoftwareApplicationInfoSigLastReadStatus",
+                                         get_ocStbHostSoftwareApplicationInfoSigLastReadStatus,
+                                         ocStbHostSoftwareApplicationInfoSigLastReadStatus_oid,
+                                         OID_LENGTH
+                                         (ocStbHostSoftwareApplicationInfoSigLastReadStatus_oid),
+                                         HANDLER_CAN_RONLY));
+    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+                                        ("ocStbHostSoftwareApplicationInfoSigVersionInUse",
+                                         get_ocStbHostSoftwareApplicationInfoSigVersionInUse,
+                                         ocStbHostSoftwareApplicationInfoSigVersionInUse_oid,
+                                         OID_LENGTH
+                                         (ocStbHostSoftwareApplicationInfoSigVersionInUse_oid),
+                                         HANDLER_CAN_RONLY));
+}
+
+int
+get_ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead
+    (netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo,
+     netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)
+{
+	mibObjectSwAppInfo *pObj = (mibObjectSwAppInfo *)gMibObjs[ocStbHostSoftwareApplicationInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.sigLastNetworkVersionRead)
+                                 ,
+								 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostSoftwareApplicationInfoSigLastReceivedTime(netsnmp_mib_handler
+                                                        *handler,
+                                                        netsnmp_handler_registration
+                                                        *reginfo,
+                                                        netsnmp_agent_request_info
+                                                        *reqinfo,
+                                                        netsnmp_request_info
+                                                        *requests)
+{
+	mibObjectSwAppInfo *pObj = (mibObjectSwAppInfo *)gMibObjs[ocStbHostSoftwareApplicationInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.sigLastReceivedTime)
+                                 ,
+                                 8
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostSoftwareApplicationInfoSigLastReadStatus(netsnmp_mib_handler
+                                                      *handler,
+                                                      netsnmp_handler_registration
+                                                      *reginfo,
+                                                      netsnmp_agent_request_info
+                                                      *reqinfo,
+                                                      netsnmp_request_info
+                                                      *requests)
+{
+	mibObjectSwAppInfo *pObj = (mibObjectSwAppInfo *)gMibObjs[ocStbHostSoftwareApplicationInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+                                 &(pObj->container.sigLastReadStatus)
+                                 ,
+                                 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostSoftwareApplicationInfoSigVersionInUse(netsnmp_mib_handler
+                                                    *handler,
+                                                    netsnmp_handler_registration
+                                                    *reginfo,
+                                                    netsnmp_agent_request_info
+                                                    *reqinfo,
+                                                    netsnmp_request_info
+                                                    *requests)
+{
+	mibObjectSwAppInfo *pObj = (mibObjectSwAppInfo *)gMibObjs[ocStbHostSoftwareApplicationInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                                 (u_char *)
+								 &(pObj->container.sigVersionInUse)
+                                 ,
+								 sizeof(int)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfo.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,19 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTSOFTWAREAPPLICATIONINFO_H
+#define OCSTBHOSTSOFTWAREAPPLICATIONINFO_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostSoftwareApplicationInfo(void);
+Netsnmp_Node_Handler
+    get_ocStbHostSoftwareApplicationInfoSigLastNetworkVersionRead;
+Netsnmp_Node_Handler
+    get_ocStbHostSoftwareApplicationInfoSigLastReceivedTime;
+Netsnmp_Node_Handler get_ocStbHostSoftwareApplicationInfoSigLastReadStatus;
+Netsnmp_Node_Handler get_ocStbHostSoftwareApplicationInfoSigVersionInUse;
+
+#endif                          /* OCSTBHOSTSOFTWAREAPPLICATIONINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,355 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSoftwareApplicationInfoTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "softwareApplicationInfoTable.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initialize the ocStbHostSoftwareApplicationInfoTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSoftwareApplicationInfoTable(void)
+{
+    static oid      ocStbHostSoftwareApplicationInfoTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 3, 3, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostSoftwareApplicationInfoTable",
+         ocStbHostSoftwareApplicationInfoTable_handler,
+         ocStbHostSoftwareApplicationInfoTable_oid,
+         OID_LENGTH(ocStbHostSoftwareApplicationInfoTable_oid),
+         HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostSoftwareApplicationInfoIndex */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 7;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSoftwareApplicationInfoTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSoftwareApplicationInfoTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSoftwareApplicationInfoTable",
+                "Registering table ocStbHostSoftwareApplicationInfoTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSoftwareApplicationInfo module */
+void
+init_ocStbHostSoftwareApplicationInfoTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostSoftwareApplicationInfoTable];
+	mibObjectSwAppInfoTable *pTblObj = (mibObjectSwAppInfoTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostSoftwareApplicationInfoTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		/*
+		 * here we initialize all the tables we're planning on supporting
+		 */
+		activateSwApp();	  /* MOE initialize SoftwareApplicationInfoTable instrumentation */
+		initialize_table_ocStbHostSoftwareApplicationInfoTable();
+
+		for (i=0; i<NUM_SW_APPS; i++)
+		{
+			struct swAppEntry *pEntry = getSwAppEntry(i);
+			pTblObj->pContainer[i] = &pEntry->data->container;
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostSoftwareApplicationInfoTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSoftwareApplicationInfoTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSoftwareApplicationInfoTable_get_first_data_point(void
+                                                           **my_loop_context,
+                                                           void
+                                                           **my_data_context,
+                                                           netsnmp_variable_list
+                                                           *
+                                                           put_index_data,
+                                                           netsnmp_iterator_info
+                                                           *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct swAppEntry *tmpPtr;					/* MOE a pointer to the first entry */
+
+    tmpPtr = getSwAppEntry(0);					/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {						/* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;					/* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;			/* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)	/* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		/* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSoftwareApplicationInfoTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSoftwareApplicationInfoTable_get_next_data_point(void
+                                                          **my_loop_context,
+                                                          void
+                                                          **my_data_context,
+                                                          netsnmp_variable_list
+                                                          * put_index_data,
+                                                          netsnmp_iterator_info
+                                                          *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct swAppEntry *tmpPtr;						/* MOE a pointer to the entry */
+
+    /* snmp_log(LOG_INFO, "ocStbHostSoftwareApplicationInfoTable_get_next_data_point() enter\n"); */
+
+    tmpPtr = (struct swAppEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getSwAppEntry(tmpPtr->index);		/* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		  /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSoftwareApplicationInfoTable table, if anything else needs to be done */
+int
+ocStbHostSoftwareApplicationInfoTable_handler(netsnmp_mib_handler *handler,
+                                              netsnmp_handler_registration
+                                              *reginfo,
+                                              netsnmp_agent_request_info
+                                              *reqinfo,
+                                              netsnmp_request_info
+                                              *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct swAppData *tmpSwAppDataPtr;          /* MOE a pointer to some SoftwareApplicationInfoTable data */
+	mibObjectSwAppInfoTable *pObj = (mibObjectSwAppInfoTable *)gMibObjs[ocStbHostSoftwareApplicationInfoTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    /* snmp_log(LOG_INFO, "ocStbHostSoftwareApplicationInfoTable_handler() enter\n"); */
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSoftwareApplicationInfoTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpSwAppDataPtr = ( struct swAppData *) netsnmp_extract_iterator_context(request);
+		if ( tmpSwAppDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpSwAppDataPtr->index);
+
+        if (tmpSwAppDataPtr->container.name[0] == 0)
+        {
+           netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
+           continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSOFTWAREAPPNAMESTRING:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpSwAppDataPtr->container.name)
+                                         , strlen(tmpSwAppDataPtr->container.name));
+                break;
+
+            case COLUMN_OCSTBHOSTSOFTWAREAPPVERSIONNUMBER:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpSwAppDataPtr->container.version)
+                                         , strlen(tmpSwAppDataPtr->container.version));
+                break;
+
+            case COLUMN_OCSTBHOSTSOFTWARESTATUS:
+			{
+				int status = getSwAppStatus(tmpSwAppDataPtr->container.name);
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(status)
+                                         , sizeof(int));
+                break;
+            }
+
+            case COLUMN_OCSTBHOSTSOFTWAREORGANIZATIONID:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpSwAppDataPtr->container.orgId)
+                                         , sizeof(tmpSwAppDataPtr->container.orgId));
+                break;
+
+            case COLUMN_OCSTBHOSTSOFTWAREAPPLICATIONID:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) (tmpSwAppDataPtr->container.appId)
+                                         , sizeof(tmpSwAppDataPtr->container.appId));
+                break;
+
+#if 0 /* Deprecated, do not support */
+            case COLUMN_OCSTBHOSTSOFTWAREAPPLICATIONSIGSTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+#endif
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSoftwareApplicationInfoTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSoftwareApplicationInfoTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,31 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSOFTWAREAPPLICATIONINFOTABLE_H
+#define OCSTBHOSTSOFTWAREAPPLICATIONINFOTABLE_H
+
+/*
+ * function declarations
+ */
+void            init_ocStbHostSoftwareApplicationInfoTable(void);
+void
+initialize_table_ocStbHostSoftwareApplicationInfoTable(void);
+Netsnmp_Node_Handler ocStbHostSoftwareApplicationInfoTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostSoftwareApplicationInfoTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostSoftwareApplicationInfoTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSoftwareApplicationInfoTable
+ */
+#define COLUMN_OCSTBHOSTSOFTWAREAPPNAMESTRING		1
+#define COLUMN_OCSTBHOSTSOFTWAREAPPVERSIONNUMBER		2
+#define COLUMN_OCSTBHOSTSOFTWARESTATUS		3
+#define COLUMN_OCSTBHOSTSOFTWAREAPPLICATIONINFOINDEX		4
+#define COLUMN_OCSTBHOSTSOFTWAREORGANIZATIONID		5
+#define COLUMN_OCSTBHOSTSOFTWAREAPPLICATIONID		6
+#define COLUMN_OCSTBHOSTSOFTWAREAPPLICATIONSIGSTATUS		7
+#endif                          /* OCSTBHOSTSOFTWAREAPPLICATIONINFOTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,336 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSPDIfTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "spDifTable.h"
+
+/** Initialize the ocStbHostSPDIfTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSPDIfTable(void)
+{
+    static oid      ocStbHostSPDIfTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 1, 2, 6 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY
+     */
+    my_handler = netsnmp_create_handler_registration("ocStbHostSPDIfTable",
+                                                     ocStbHostSPDIfTable_handler,
+                                                     ocStbHostSPDIfTable_oid,
+                                                     OID_LENGTH
+                                                     (ocStbHostSPDIfTable_oid),
+                                                     HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostAVInterfaceIndex */
+                                     0);
+
+    table_info->min_column = 1;
+    table_info->max_column = 2;
+
+    /*
+     * iterator access routines
+     */
+    iinfo->get_first_data_point = ocStbHostSPDIfTable_get_first_data_point;
+    iinfo->get_next_data_point = ocStbHostSPDIfTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSPDIfTable",
+                "Registering table ocStbHostSPDIfTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSPDIfTable module */
+void
+init_ocStbHostSPDIfTable(void)
+{
+    mibObjects *pObj = &gMibObjs[ocStbHostSPDIfTable];
+	mibObjectSPDIfTable *pTblObj = (mibObjectSPDIfTable *)pObj->obj;
+    struct spDifEntry *pEntry;
+	int i;
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+    /*
+     * here we initialize all the tables we're planning on supporting
+     */
+	// snmp_log(LOG_INFO, "init_ocStbHostSPDIfTable() enter\n");
+    if(pObj->registered)
+    {
+     activateSpDif(); 	  /* MOE initialize spDif instrumentation */
+     initialize_table_ocStbHostSPDIfTable();
+#if NEXUS_NUM_SPDIF_OUTPUTS
+     for (i=0;i<NEXUS_NUM_SPDIF_OUTPUTS;i++)
+     {
+       pEntry = getSpDifEntry(i);
+ 	   pTblObj->pContainer[i] = &pEntry->data->container;
+     }
+#endif
+    }
+}
+
+/** returns the first data point within the ocStbHostSPDIfTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSPDIfTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSPDIfTable_get_first_data_point(void **my_loop_context,
+                                         void **my_data_context,
+                                         netsnmp_variable_list *
+                                         put_index_data,
+                                         netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct spDifEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    tmpPtr = getSpDifEntry(0);         /* go ahead and get the first entry */
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSPDIfTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSPDIfTable_get_next_data_point(void **my_loop_context,
+                                        void **my_data_context,
+                                        netsnmp_variable_list *
+                                        put_index_data,
+                                        netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct spDifEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    // snmp_log(LOG_INFO, "ocStbHostSPDIfTable_get_next_data_point() enter\n");
+
+    tmpPtr = (struct spDifEntry *) *my_loop_context;
+    if (tmpPtr) {
+      tmpPtr = getSpDifEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSPDIfTable table, if anything else needs to be done */
+int
+ocStbHostSPDIfTable_handler(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *reqinfo,
+                            netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct spDifData *tmpSpDifDataPtr;          /* MOE a pointer to some IEEE1394 data */
+    mibObjectSPDIfTable *pObj = (mibObjectSPDIfTable *)gMibObjs[ocStbHostSPDIfTable].obj;
+
+    // snmp_log(LOG_INFO, "ocStbHostSPDIfTable_handler() enter\n");
+    BDBG_ASSERT(pObj != NULL);
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed.
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSPDIfTable table in question
+         */
+		/* MOE extract the data pointer */
+		tmpSpDifDataPtr = ( struct spDifData *) netsnmp_extract_iterator_context(request);
+		if ( tmpSpDifDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        pObj->callback((void *)pObj, tmpSpDifDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSPDIFAUDIOFORMAT:
+                {
+                    int audioFormat;
+                    switch (tmpSpDifDataPtr->container.audioFormat)
+                    {
+                        case NEXUS_AudioCodec_ePcm:
+                            audioFormat = oc_audioOutputFormat_lpcm;
+                            break;
+                        case NEXUS_AudioCodec_eAc3:
+                            audioFormat = oc_audioOutputFormat_ac3;
+                            break;
+                        case NEXUS_AudioCodec_eAc3Plus:
+                            audioFormat = oc_audioOutputFormat_eac3;
+                            break;
+                        case NEXUS_AudioCodec_eMpeg:
+                            audioFormat = oc_audioOutputFormat_mpeg1L1L2;
+                            break;
+                        case NEXUS_AudioCodec_eMp3:
+                            audioFormat = oc_audioOutputFormat_mpeg1L3;
+                            break;
+                        case NEXUS_AudioCodec_eAac:
+                            audioFormat = oc_audioOutputFormat_mpeg2;
+                            break;
+                        case NEXUS_AudioCodec_eAacPlus:
+                            audioFormat = oc_audioOutputFormat_mpeg4;
+                            break;
+                        case NEXUS_AudioCodec_eDts:
+                            audioFormat = oc_audioOutputFormat_dts;
+                            break;
+                        default:
+                            audioFormat = oc_audioOutputFormat_other;
+                            break;
+                    }
+
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (u_char *) &(audioFormat)
+                                             , sizeof(int) );
+                    break;
+                }
+
+            case COLUMN_OCSTBHOSTSPDIFAUDIOMUTESTATUS:
+                {
+                    int muteStatus = tmpSpDifDataPtr->container.muteStatus ? oc_true : oc_false;
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (u_char *) &(muteStatus)
+                                             , sizeof(int) );
+                    break;
+                }
+
+            default:
+                /*
+                 * We shouldn't get here
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSPDIfTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling...
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSPDIfTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSPDIfTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,23 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSPDIFTABLE_H
+#define OCSTBHOSTSPDIFTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSPDIfTable(void);
+void            initialize_table_ocStbHostSPDIfTable(void);
+Netsnmp_Node_Handler ocStbHostSPDIfTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostSPDIfTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostSPDIfTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSPDIfTable 
+ */
+#define COLUMN_OCSTBHOSTSPDIFAUDIOFORMAT		1
+#define COLUMN_OCSTBHOSTSPDIFAUDIOMUTESTATUS		2
+#endif                          /* OCSTBHOSTSPDIFTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,136 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSpecificationsInfo.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+/** Initializes the ocStbHostSpecificationsInfo module */
+void
+init_ocStbHostSpecificationsInfo(void)
+{
+    static oid      ocStbHostMibSpecificationIssue_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 5, 2, 0 };
+    static oid      ocStbHostCfrSpecificationIssue_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 5, 5, 1, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostSpecificationsInfo];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostSpecificationsInfo", "Initializing\n"));
+
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostMibSpecificationIssue",
+											 get_ocStbHostMibSpecificationIssue,
+											 ocStbHostMibSpecificationIssue_oid,
+											 OID_LENGTH
+											 (ocStbHostMibSpecificationIssue_oid),
+											 HANDLER_CAN_RONLY));
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostCfrSpecificationIssue",
+											 get_ocStbHostCfrSpecificationIssue,
+											 ocStbHostCfrSpecificationIssue_oid,
+											 OID_LENGTH
+											 (ocStbHostCfrSpecificationIssue_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostMibSpecificationIssue(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+	mibObjectSpecInfo *pObj = (mibObjectSpecInfo *)gMibObjs[ocStbHostSpecificationsInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.mibSpecIssue)
+                                 ,
+                                 strlen(pObj->container.mibSpecIssue)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+get_ocStbHostCfrSpecificationIssue(netsnmp_mib_handler *handler,
+                                   netsnmp_handler_registration *reginfo,
+                                   netsnmp_agent_request_info *reqinfo,
+                                   netsnmp_request_info *requests)
+{
+	mibObjectSpecInfo *pObj = (mibObjectSpecInfo *)gMibObjs[ocStbHostSpecificationsInfo].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one.
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.cfrSpecIssue)
+                                 ,
+                                 strlen(pObj->container.cfrSpecIssue)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSpecificationsInfo.h	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,15 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTSPECIFICATIONSINFO_H
+#define OCSTBHOSTSPECIFICATIONSINFO_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSpecificationsInfo(void);
+Netsnmp_Node_Handler get_ocStbHostMibSpecificationIssue;
+Netsnmp_Node_Handler get_ocStbHostCfrSpecificationIssue;
+
+#endif                          /* OCSTBHOSTSPECIFICATIONSINFO_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,286 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSystemHomeNetworkTable.h"
+
+/** Initialize the ocStbHostSystemHomeNetworkTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemHomeNetworkTable(void)
+{
+    static oid      ocStbHostSystemHomeNetworkTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostSystemHomeNetworkTable",
+         ocStbHostSystemHomeNetworkTable_handler,
+         ocStbHostSystemHomeNetworkTable_oid,
+         OID_LENGTH(ocStbHostSystemHomeNetworkTable_oid),
+         HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostSystemHomeNetworkIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 7;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemHomeNetworkTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemHomeNetworkTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemHomeNetworkTable",
+                "Registering table ocStbHostSystemHomeNetworkTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSystemHomeNetworkTable module */
+void
+init_ocStbHostSystemHomeNetworkTable(void)
+{
+
+    /*
+     * here we initialize all the tables we're planning on supporting 
+     */
+    initialize_table_ocStbHostSystemHomeNetworkTable();
+}
+
+/** returns the first data point within the ocStbHostSystemHomeNetworkTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemHomeNetworkTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemHomeNetworkTable_get_first_data_point(void
+                                                     **my_loop_context,
+                                                     void
+                                                     **my_data_context,
+                                                     netsnmp_variable_list
+                                                     * put_index_data,
+                                                     netsnmp_iterator_info
+                                                     *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemHomeNetworkIndex data */ ,
+                       /* XXX: length of ocStbHostSystemHomeNetworkIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemHomeNetworkTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemHomeNetworkTable_get_next_data_point(void **my_loop_context,
+                                                    void **my_data_context,
+                                                    netsnmp_variable_list *
+                                                    put_index_data,
+                                                    netsnmp_iterator_info
+                                                    *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemHomeNetworkIndex data */ ,
+                       /* XXX: length of ocStbHostSystemHomeNetworkIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemHomeNetworkTable table, if anything else needs to be done */
+int
+ocStbHostSystemHomeNetworkTable_handler(netsnmp_mib_handler *handler,
+                                        netsnmp_handler_registration
+                                        *reginfo,
+                                        netsnmp_agent_request_info
+                                        *reqinfo,
+                                        netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemHomeNetworkTable table in question 
+         */
+        /*
+         * XXX 
+         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
+        if ( /* XXX */  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKMAXCLIENTS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKHOSTDRMSTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCONNECTEDCLIENTS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTMACADDRESS:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTIPADDRESS:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTDRMSTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemHomeNetworkTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemHomeNetworkTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemHomeNetworkTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,30 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSYSTEMHOMENETWORKTABLE_H
+#define OCSTBHOSTSYSTEMHOMENETWORKTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSystemHomeNetworkTable(void);
+void            initialize_table_ocStbHostSystemHomeNetworkTable(void);
+Netsnmp_Node_Handler ocStbHostSystemHomeNetworkTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostSystemHomeNetworkTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostSystemHomeNetworkTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSystemHomeNetworkTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKMAXCLIENTS		2
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKHOSTDRMSTATUS		3
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCONNECTEDCLIENTS		4
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTMACADDRESS		5
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTIPADDRESS		6
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTDRMSTATUS		7
+#endif                          /* OCSTBHOSTSYSTEMHOMENETWORKTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,316 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSystemMemoryReportTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "systemMemoryReportTable.h"
+
+/** Initialize the ocStbHostSystemMemoryReportTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemMemoryReportTable(void)
+{
+    static oid      ocStbHostSystemMemoryReportTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 3 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostSystemMemoryReportTable",
+         ocStbHostSystemMemoryReportTable_handler,
+         ocStbHostSystemMemoryReportTable_oid,
+         OID_LENGTH(ocStbHostSystemMemoryReportTable_oid),
+         HANDLER_CAN_RONLY); /* MOE this table is readOnly */
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostSystemMemoryReportIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 3;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemMemoryReportTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemMemoryReportTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemMemoryReportTable",
+                "Registering table ocStbHostSystemMemoryReportTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSystemMemoryReportTable module */
+void
+init_ocStbHostSystemMemoryReportTable(void)
+{
+	mibObjects *pObj = &gMibObjs[ocStbHostSystemMemoryReportTable];
+	mibObjectSystemMemoryReportTable *pTblObj = (mibObjectSystemMemoryReportTable *)pObj->obj;
+	int i;
+
+    BDBG_ASSERT(pObj != NULL);
+    BDBG_ASSERT(pObj->opened);
+
+	/* snmp_log(LOG_INFO, "init_ocStbHostSystemMemoryReportTable() enter\n"); */
+
+	if (pObj->registered)
+	{
+		/*
+		 * here we initialize all the tables we're planning on supporting
+		 */
+		activateSystemMemoryReport();	  /* MOE initialize systemMemoryReport instrumentation */
+		initialize_table_ocStbHostSystemMemoryReportTable();
+
+		for (i=0; i<NUM_MEMORY_TYPE; i++)
+		{
+			struct systemMemoryReportEntry *pEntry = getSystemMemoryReportEntry(i);
+			pTblObj->pContainer[i] = &pEntry->data->container;
+		}
+	}
+}
+
+/** returns the first data point within the ocStbHostSystemMemoryReportTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemMemoryReportTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemMemoryReportTable_get_first_data_point(void
+                                                      **my_loop_context,
+                                                      void
+                                                      **my_data_context,
+                                                      netsnmp_variable_list
+                                                      * put_index_data,
+                                                      netsnmp_iterator_info
+                                                      *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct systemMemoryReportEntry *tmpPtr;             /* MOE a pointer to the first entry */
+
+    tmpPtr = getSystemMemoryReportEntry(0);    			/* go ahead and get the first entry */
+
+    if (tmpPtr == NULL) {                     /* empty table, punt now!! */
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;                /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;          /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)  /* MOE the index of this entry */
+                       ,
+                       sizeof(tmpPtr->index)		 /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemMemoryReportTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemMemoryReportTable_get_next_data_point(void
+                                                     **my_loop_context,
+                                                     void
+                                                     **my_data_context,
+                                                     netsnmp_variable_list
+                                                     * put_index_data,
+                                                     netsnmp_iterator_info
+                                                     *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+    struct systemMemoryReportEntry *tmpPtr;             /* MOE a pointer to the entry */
+
+    // snmp_log(LOG_INFO, "ocStbHostSystemMemoryReportTable_get_next_data_point() enter\n");
+
+    tmpPtr = (struct systemMemoryReportEntry *) *my_loop_context;
+
+    if (tmpPtr) {
+      tmpPtr = getSystemMemoryReportEntry(tmpPtr->index);  /* get the next entry after this one */
+    }
+
+    if (tmpPtr == NULL) {
+      *my_loop_context = NULL;
+      *my_data_context = NULL;
+      return NULL;
+    }
+
+    *my_loop_context = tmpPtr;            /* MOE the entry struct so we can do a "next" */
+    *my_data_context = tmpPtr->data;      /* MOE the data struct so we can get values */
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *) &(tmpPtr->index)    /* MOE the index of this entry */
+                        ,
+                       sizeof(tmpPtr->index)		   /* the size in bytes of the index */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemMemoryReportTable table, if anything else needs to be done */
+int
+ocStbHostSystemMemoryReportTable_handler(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct systemMemoryReportData *tmpSystemMemoryReportDataPtr;          /* MOE a pointer to some systemMemoryReport data */
+	mibObjectSystemMemoryReportTable *pObj = (mibObjectSystemMemoryReportTable *)gMibObjs[ocStbHostSystemMemoryReportTable].obj;
+
+    BDBG_ASSERT(pObj != NULL);
+
+    // snmp_log(LOG_INFO, "ocStbHostSystemMemoryReportTable_handler() enter\n");
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemMemoryReportTable table in question 
+         */
+		/* MOE extract the data pointer */
+		tmpSystemMemoryReportDataPtr = ( struct systemMemoryReportData *) netsnmp_extract_iterator_context(request);
+		if ( tmpSystemMemoryReportDataPtr  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+		pObj->callback((void *)pObj, tmpSystemMemoryReportDataPtr->index);
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYTYPE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpSystemMemoryReportDataPtr->container.memoryType)
+                                         , sizeof(int) );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYSIZE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) &(tmpSystemMemoryReportDataPtr->container.memorySize)
+                                         , sizeof(int) );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemMemoryReportTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemMemoryReportTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemMemoryReportTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,26 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSYSTEMMEMORYREPORTTABLE_H
+#define OCSTBHOSTSYSTEMMEMORYREPORTTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSystemMemoryReportTable(void);
+void            initialize_table_ocStbHostSystemMemoryReportTable(void);
+Netsnmp_Node_Handler ocStbHostSystemMemoryReportTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostSystemMemoryReportTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostSystemMemoryReportTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSystemMemoryReportTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYTYPE		2
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYSIZE		3
+#endif                          /* OCSTBHOSTSYSTEMMEMORYREPORTTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,786 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSystemObjects.h"
+
+/** Initialize the ocStbHostSystemHomeNetworkTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemHomeNetworkTable(void)
+{
+    static oid      ocStbHostSystemHomeNetworkTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostSystemHomeNetworkTable",
+         ocStbHostSystemHomeNetworkTable_handler,
+         ocStbHostSystemHomeNetworkTable_oid,
+         OID_LENGTH(ocStbHostSystemHomeNetworkTable_oid),
+         HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostSystemHomeNetworkIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 7;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemHomeNetworkTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemHomeNetworkTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemHomeNetworkTable",
+                "Registering table ocStbHostSystemHomeNetworkTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initialize the ocStbHostSystemMemoryReportTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemMemoryReportTable(void)
+{
+    static oid      ocStbHostSystemMemoryReportTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 3 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("ocStbHostSystemMemoryReportTable",
+         ocStbHostSystemMemoryReportTable_handler,
+         ocStbHostSystemMemoryReportTable_oid,
+         OID_LENGTH(ocStbHostSystemMemoryReportTable_oid),
+         HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,  /* index: ocStbHostSystemMemoryReportIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 3;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemMemoryReportTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemMemoryReportTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemMemoryReportTable",
+                "Registering table ocStbHostSystemMemoryReportTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initialize the ocStbHostSystemTempTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemTempTable(void)
+{
+    static oid      ocStbHostSystemTempTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostSystemTempTable",
+                                            ocStbHostSystemTempTable_handler,
+                                            ocStbHostSystemTempTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostSystemTempTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
+                                     ASN_UNSIGNED,      /* index: ocStbHostSystemTempIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 5;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemTempTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemTempTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemTempTable",
+                "Registering table ocStbHostSystemTempTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSystemObjects module */
+void
+init_ocStbHostSystemObjects(void)
+{
+
+    /*
+     * here we initialize all the tables we're planning on supporting 
+     */
+    initialize_table_ocStbHostSystemHomeNetworkTable();
+    initialize_table_ocStbHostSystemMemoryReportTable();
+    initialize_table_ocStbHostSystemTempTable();
+}
+
+/** returns the first data point within the ocStbHostSystemHomeNetworkTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemHomeNetworkTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemHomeNetworkTable_get_first_data_point(void
+                                                     **my_loop_context,
+                                                     void
+                                                     **my_data_context,
+                                                     netsnmp_variable_list
+                                                     * put_index_data,
+                                                     netsnmp_iterator_info
+                                                     *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemHomeNetworkIndex data */ ,
+                       /* XXX: length of ocStbHostSystemHomeNetworkIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemHomeNetworkTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemHomeNetworkTable_get_next_data_point(void **my_loop_context,
+                                                    void **my_data_context,
+                                                    netsnmp_variable_list *
+                                                    put_index_data,
+                                                    netsnmp_iterator_info
+                                                    *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemHomeNetworkIndex data */ ,
+                       /* XXX: length of ocStbHostSystemHomeNetworkIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemHomeNetworkTable table, if anything else needs to be done */
+int
+ocStbHostSystemHomeNetworkTable_handler(netsnmp_mib_handler *handler,
+                                        netsnmp_handler_registration
+                                        *reginfo,
+                                        netsnmp_agent_request_info
+                                        *reqinfo,
+                                        netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemHomeNetworkTable table in question 
+         */
+        /*
+         * XXX 
+         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
+        if ( /* XXX */  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKMAXCLIENTS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKHOSTDRMSTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCONNECTEDCLIENTS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTMACADDRESS:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTIPADDRESS:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTDRMSTATUS:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemHomeNetworkTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemHomeNetworkTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+/** returns the first data point within the ocStbHostSystemMemoryReportTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemMemoryReportTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemMemoryReportTable_get_first_data_point(void
+                                                      **my_loop_context,
+                                                      void
+                                                      **my_data_context,
+                                                      netsnmp_variable_list
+                                                      * put_index_data,
+                                                      netsnmp_iterator_info
+                                                      *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemMemoryReportIndex data */ ,
+                       /* XXX: length of ocStbHostSystemMemoryReportIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemMemoryReportTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemMemoryReportTable_get_next_data_point(void
+                                                     **my_loop_context,
+                                                     void
+                                                     **my_data_context,
+                                                     netsnmp_variable_list
+                                                     * put_index_data,
+                                                     netsnmp_iterator_info
+                                                     *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr,
+                       (u_char *)
+                       /* XXX: ocStbHostSystemMemoryReportIndex data */ ,
+                       /* XXX: length of ocStbHostSystemMemoryReportIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemMemoryReportTable table, if anything else needs to be done */
+int
+ocStbHostSystemMemoryReportTable_handler(netsnmp_mib_handler *handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemMemoryReportTable table in question 
+         */
+        /*
+         * XXX 
+         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
+        if ( /* XXX */  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYTYPE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYSIZE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemMemoryReportTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemMemoryReportTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+/** returns the first data point within the ocStbHostSystemTempTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemTempTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemTempTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr, (u_char *) /* XXX: hrDeviceIndex data */ ,
+                       /* XXX: length of hrDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr,
+                       (u_char *) /* XXX: ocStbHostSystemTempIndex data */
+                       , /* XXX: length of ocStbHostSystemTempIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemTempTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemTempTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr, (u_char *) /* XXX: hrDeviceIndex data */ ,
+                       /* XXX: length of hrDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr,
+                       (u_char *) /* XXX: ocStbHostSystemTempIndex data */
+                       , /* XXX: length of ocStbHostSystemTempIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemTempTable table, if anything else needs to be done */
+int
+ocStbHostSystemTempTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemTempTable table in question 
+         */
+        /*
+         * XXX 
+         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
+        if ( /* XXX */  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMTEMPDESCR:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPVALUE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPLASTUPDATE:
+                snmp_set_var_typed_value(var, ASN_TIMETICKS,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPMAXVALUE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemTempTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemTempTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemObjects.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,58 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSYSTEMOBJECTS_H
+#define OCSTBHOSTSYSTEMOBJECTS_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSystemObjects(void);
+void            initialize_table_ocStbHostSystemHomeNetworkTable(void);
+Netsnmp_Node_Handler ocStbHostSystemHomeNetworkTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostSystemHomeNetworkTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostSystemHomeNetworkTable_get_next_data_point;
+void            initialize_table_ocStbHostSystemMemoryReportTable(void);
+Netsnmp_Node_Handler ocStbHostSystemMemoryReportTable_handler;
+
+Netsnmp_First_Data_Point
+    ocStbHostSystemMemoryReportTable_get_first_data_point;
+Netsnmp_Next_Data_Point
+    ocStbHostSystemMemoryReportTable_get_next_data_point;
+void            initialize_table_ocStbHostSystemTempTable(void);
+Netsnmp_Node_Handler ocStbHostSystemTempTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostSystemTempTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostSystemTempTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSystemHomeNetworkTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKMAXCLIENTS		2
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKHOSTDRMSTATUS		3
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCONNECTEDCLIENTS		4
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTMACADDRESS		5
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTIPADDRESS		6
+#define COLUMN_OCSTBHOSTSYSTEMHOMENETWORKCLIENTDRMSTATUS		7
+
+/*
+ * column number definitions for table ocStbHostSystemMemoryReportTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYTYPE		2
+#define COLUMN_OCSTBHOSTSYSTEMMEMORYREPORTMEMORYSIZE		3
+
+/*
+ * column number definitions for table ocStbHostSystemTempTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMTEMPINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMTEMPDESCR		2
+#define COLUMN_OCSTBHOSTSYSTEMTEMPVALUE		3
+#define COLUMN_OCSTBHOSTSYSTEMTEMPLASTUPDATE		4
+#define COLUMN_OCSTBHOSTSYSTEMTEMPMAXVALUE		5
+#endif                          /* OCSTBHOSTSYSTEMOBJECTS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,274 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostSystemTempTable.h"
+
+/** Initialize the ocStbHostSystemTempTable table by defining its contents and how it's structured */
+void
+initialize_table_ocStbHostSystemTempTable(void)
+{
+    static oid      ocStbHostSystemTempTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 3, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /*
+     * create the table structure itself 
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /*
+     * if your table is read only, it's easiest to change the
+     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
+     */
+    my_handler =
+        netsnmp_create_handler_registration("ocStbHostSystemTempTable",
+                                            ocStbHostSystemTempTable_handler,
+                                            ocStbHostSystemTempTable_oid,
+                                            OID_LENGTH
+                                            (ocStbHostSystemTempTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo)
+        return;                 /* mallocs failed */
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: hrDeviceIndex */
+                                     ASN_UNSIGNED,      /* index: ocStbHostSystemTempIndex */
+                                     0);
+
+    table_info->min_column = 2;
+    table_info->max_column = 5;
+
+    /*
+     * iterator access routines 
+     */
+    iinfo->get_first_data_point =
+        ocStbHostSystemTempTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        ocStbHostSystemTempTable_get_next_data_point;
+
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_ocStbHostSystemTempTable",
+                "Registering table ocStbHostSystemTempTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the ocStbHostSystemTempTable module */
+void
+init_ocStbHostSystemTempTable(void)
+{
+
+    /*
+     * here we initialize all the tables we're planning on supporting 
+     */
+    initialize_table_ocStbHostSystemTempTable();
+}
+
+/** returns the first data point within the ocStbHostSystemTempTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later (in your main ocStbHostSystemTempTable_handler routine) that will provide
+    you with the data to return in a given row.  This could be the
+    same pointer as what my_loop_context is set to, or something
+    different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+ocStbHostSystemTempTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr, (u_char *) /* XXX: hrDeviceIndex data */ ,
+                       /* XXX: length of hrDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr,
+                       (u_char *) /* XXX: ocStbHostSystemTempIndex data */
+                       , /* XXX: length of ocStbHostSystemTempIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as ocStbHostSystemTempTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it and the return
+   my_loop_context->next.  The my_data_context pointer should be set
+   to something you need later and the indexes in put_index_data
+   updated again. */
+
+netsnmp_variable_list *
+ocStbHostSystemTempTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    netsnmp_variable_list *vptr;
+
+    *my_loop_context = /* XXX */ ;
+    *my_data_context = /* XXX */ ;
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr, (u_char *) /* XXX: hrDeviceIndex data */ ,
+                       /* XXX: length of hrDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr,
+                       (u_char *) /* XXX: ocStbHostSystemTempIndex data */
+                       , /* XXX: length of ocStbHostSystemTempIndex data */
+                       );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** handles requests for the ocStbHostSystemTempTable table, if anything else needs to be done */
+int
+ocStbHostSystemTempTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        /*
+         * perform anything here that you need to do before each
+         * request is processed. 
+         */
+
+        /*
+         * the following extracts the my_data_context pointer set in
+         * the loop functions above.  You can then use the results to
+         * help return data for the columns of the ocStbHostSystemTempTable table in question 
+         */
+        /*
+         * XXX 
+         */  = ( /* XXX */ *)netsnmp_extract_iterator_context(request);
+        if ( /* XXX */  == NULL) {
+            if (reqinfo->mode == MODE_GET) {
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+            /*
+             * XXX: no row existed, if you support creation and this is a
+             * set, start dealing with it here, else continue 
+             */
+        }
+
+        /*
+         * extracts the information about the table from the request 
+         */
+        table_info = netsnmp_extract_table_info(request);
+        /*
+         * table_info->colnum contains the column number requested 
+         */
+        /*
+         * table_info->indexes contains a linked list of snmp variable
+         * bindings for the indexes of the table.  Values in the list
+         * have been set corresponding to the indexes of the
+         * request 
+         */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+            /*
+             * the table_iterator helper should change all GETNEXTs
+             * into GETs for you automatically, so you don't have to
+             * worry about the GETNEXT case.  Only GETs and SETs need
+             * to be dealt with here 
+             */
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_OCSTBHOSTSYSTEMTEMPDESCR:
+                snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPVALUE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPLASTUPDATE:
+                snmp_set_var_typed_value(var, ASN_TIMETICKS,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            case COLUMN_OCSTBHOSTSYSTEMTEMPMAXVALUE:
+                snmp_set_var_typed_value(var, ASN_INTEGER,
+                                         (u_char *) /* XXX: column data */
+                                         , /* XXX: column data length */ );
+                break;
+
+            default:
+                /*
+                 * We shouldn't get here 
+                 */
+                snmp_log(LOG_ERR,
+                         "problem encountered in ocStbHostSystemTempTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            /*
+             * set handling... 
+             */
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in ocStbHostSystemTempTable_handler: unsupported mode\n");
+        }
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostSystemTempTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,26 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.5.2.1 2003/07/02 17:36:07 hardaker Exp $
+ */
+#ifndef OCSTBHOSTSYSTEMTEMPTABLE_H
+#define OCSTBHOSTSYSTEMTEMPTABLE_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostSystemTempTable(void);
+void            initialize_table_ocStbHostSystemTempTable(void);
+Netsnmp_Node_Handler ocStbHostSystemTempTable_handler;
+
+Netsnmp_First_Data_Point ocStbHostSystemTempTable_get_first_data_point;
+Netsnmp_Next_Data_Point ocStbHostSystemTempTable_get_next_data_point;
+
+/*
+ * column number definitions for table ocStbHostSystemTempTable 
+ */
+#define COLUMN_OCSTBHOSTSYSTEMTEMPINDEX		1
+#define COLUMN_OCSTBHOSTSYSTEMTEMPDESCR		2
+#define COLUMN_OCSTBHOSTSYSTEMTEMPVALUE		3
+#define COLUMN_OCSTBHOSTSYSTEMTEMPLASTUPDATE		4
+#define COLUMN_OCSTBHOSTSYSTEMTEMPMAXVALUE		5
+#endif                          /* OCSTBHOSTSYSTEMTEMPTABLE_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/oc-stb-host.txt net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/oc-stb-host.txt
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/oc-stb-host.txt	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/oc-stb-host.txt	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,4229 @@
+OC-STB-HOST-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    TenthdB,
+    TenthdBmV
+       FROM DOCS-IF-MIB                     -- RFC 2670
+    OBJECT-GROUP,
+    MODULE-COMPLIANCE
+       FROM SNMPv2-CONF                     -- RFC 2580
+    Integer32,
+    Unsigned32,
+    Counter32,
+    TimeTicks,
+    OBJECT-TYPE,
+    MODULE-IDENTITY,
+    OBJECT-IDENTITY
+       FROM SNMPv2-SMI                      -- RFC 2578
+    AutonomousType,
+    DisplayString,
+    TruthValue,
+    RowPointer,
+    TimeStamp,
+    PhysAddress,
+    MacAddress,
+    DateAndTime,
+    TEXTUAL-CONVENTION
+       FROM SNMPv2-TC                       -- RFC 2579
+    SnmpAdminString
+       FROM SNMP-FRAMEWORK-MIB              -- RFC 3411
+    InetAddressType,
+    InetAddress
+       FROM INET-ADDRESS-MIB                -- RFC 4001
+    hrDeviceIndex
+       FROM HOST-RESOURCES-MIB              -- RFC 2790
+    clabProjOpenCable
+       FROM CLAB-DEF-MIB
+       ;
+
+ocStbHostMibModule MODULE-IDENTITY
+    LAST-UPDATED "201005070000Z"              -- May 7, 2010
+    ORGANIZATION "Cable Television Laboratories, Inc."
+    CONTACT-INFO
+         "Postal: Cable Television Laboratories, Inc.
+         858 Coal Creek Circle
+         Louisville, Colorado 80027-9750
+         U.S.A.
+         Phone: +1 303-661-9100
+         Fax:     +1 303-661-9199
+         E-mail: mibs@cablelabs.com"
+    DESCRIPTION
+           "This MIB module contains the management objects for the
+           management of OpenCable Set-top Host Device."
+    REVISION "201005070000Z"             -- May 7, 2010
+    DESCRIPTION
+           "Deprecated ocStbHostSoftwareApplicationSigStatus
+           and added replacement leaf objects,
+           ocStbHostSoftwareApplicationInfoSigLastReceivedTime
+           and ocStbHostSoftwareApplicationInfoSigLastReadStatus.
+           Added ocStbHostFirmwareDownloadFailedCount.
+           Added ochdtc(7) to ocStbHostCapabilities, other(4) to
+           ocStbHostFirmwareCodeDownloadStatus, and
+           ocStbHostDVIHDMIEdidVersion."
+    REVISION "200912110000Z"             -- December 11, 2009
+    DESCRIPTION
+           "Added ocStbHostDVIHDMIPreferredVideoFormat,
+           ocStbHostDVIHDMIAvailableVideoFormatTable,
+           ocStbHostAvcSupport, and
+           ocStbHostCardSnmpAccessControl. Also removed
+           extraneous ',' in HDMI Features object."
+    REVISION "200909040000Z"             -- September 4, 2009
+    DESCRIPTION
+           "Added 'other(6)' enumerated value to
+           ocStbHostDVIHDMIAttachedDeviceType, changed
+           ocStbHostSoftwareApplicationSigStatus SYNTAX to
+           enumerated values(INTEGER)."
+    REVISION "200905080000Z"             -- May 8, 2009
+    DESCRIPTION
+           "Added HDMI objects ocStbHostDVIHDMIEdid,
+           ocStbHostDVIHDMILipSyncDelay,
+           ocStbHostDVIHDMICecFeatures,
+           ocStbHostDVIHDMIFeatures,
+           ocStbHostDVIHDMIMaxDeviceCount.
+           Added the following objects to support the enhanced
+           diagnostics display: ocStbHostDVIHDMIAttachedDeviceType,
+           ocStbHostSoftwareFirmwareReleaseDate,
+           ocStbHostSoftwareOrganizationId,
+           ocStbHostSoftwareApplicationId,
+           ocStbHostSoftwareApplicationSigStatus,
+           ocStbHostPatTimeoutCount,
+           ocStbHostPmtTimeoutCount,
+           ocStbHostOobCarouselTimeoutCount,
+           ocStbHostInbandCarouselTimeoutCount,
+           ocStbHostCardOpenedGenericResource,
+           ocStbHostCardTimeZoneOffset,
+           ocStbHostCardDaylightSavingsTimeDelta,
+           ocStbHostCardDaylightSavingsTimeEntry,
+           ocStbHostCardDaylightSavingsTimeExit,
+           ocStbHostCardEaLocationCode,ocStbHostCardVctId,
+           ocStbHostCardCpAuthKeyStatus,
+           ocStbHostCardCpCertificateCheck,
+           ocStbHostCardCpCciChallengeCount,
+           ocStbHostCardCpKeyGenerationReqCount,
+           ocStbHostCardCpIdList,ocStbHostBootStatus,
+           ocStbHostInBandTunerBandwidth.
+           Added frameRate enumeration of 60Hz to
+           ocStbHostDVIHDMIFrameRate.
+           Added DateAndTime textual convention import."
+    REVISION "200902060000Z"             -- February 6, 2009
+    DESCRIPTION
+           "Added 1) Notification support to MIB Notifications
+           section, 2) a trap for signaling the headend a dump is
+           ready to be transferred, 3) ocStbHostDumpEventCount,
+           ocStbHostDumpNow, ocStbHostDumpEventTimeout, and
+           ocStbHostDumpFilePath objects for Panic Dump transfer
+           support, 4) new group and trap to the Notifications
+           conformance section, 5) ocStbHostCfrSpecificationIssue and
+           ocStbHostMibSpecificationIssue to report the versions of
+           the specifications implemented,
+           6) ocStbHostSystemTempMaxValue,
+           7)ocStbHostSystemMemoryReportMemoryType and
+           ocStbHostSoftwareStatus Objects to the compliance
+           section to track obsoleted values.
+           Modified 1) ocStbHostSoftwareStatus with new enumerated
+           values, 2) ocStbHostInBandTunerPower to read-only
+           MAX-ACCESS and 3) ocStbHostCardMfgId by changing SA
+           to Cisco and adding Conax."
+   REVISION "200811140000Z"        -- November 14, 2008
+   DESCRIPTION
+           "Added/updated tables to align the MIB with the CCIF
+           Diagnostic APDU. Added color space, sample size, and
+           frame rate to the ocStbHostDVIHdmiTable, additional memory
+           types to the ocStbHostSystemMemoryReportTable, SNMP
+           proxy objects, and added Out of Band messaging mode object.
+           Corrected ocStbHostCCApplicationType to include 0 as a
+           valid index. Modified descriptions to clarify usage of
+           ocStbHostMpeg2ContentDecoderPTS, ocStbHostCASystemId,
+           ocStbHostCardIpAddressType, and ocStbHostCardIpAddressIp.
+           Added TotalTuneCount, TuneFailureCount, and
+           TuneFailureFreq columns in
+           ocStbHostInBandTunerTable to support field
+           diagnostics. Added OIDs for CableCARD ID, CableCARD/Host
+           binding status. Deprecated homenetworking and
+           ocStbHostSecurityIdentifier objects. Corrected UNITS for
+           objects with tenthdB syntax."
+   REVISION "200803280000Z"        -- March 28, 2008
+   DESCRIPTION
+           "Corrected index for ocStbHostSoftwareApplicationInfoTable
+           that required adding an index object. Added
+           ocStbHostRebootInfo, ocStbHostMemoryInfo, ocStbHostJVMInfo.
+           Also repaired a problem in two areas where OID values were
+           changed from previous HOSTMIB I02 version. These include
+           realignment of objects within the ocStbHostDVIHDMITable and
+           ocStbHostFirmwareDownloadStatus. Added 1080p(5) to the
+           VideoOutputFormat textual convention; updated the
+           ocStbHostAvInterfaceTypes Description field to
+           reference the DVIHDMI and 1394 tables; corrected INTEGER
+           syntax statements to specify ranges. This version is
+           published as part of the OpenCable Host MIB specification,
+           MIB-HOST2.X, version I04. Copyright 1999-2008 Cable
+           Television Laboratories, Inc. All rights reserved."
+   REVISION "200711130000Z"        -- November 13, 2007
+   DESCRIPTION
+           "Added diagnostics MIB objects to include Home Network
+           Table, MemoryReportTable, Software App Table and addition
+           of software info MIB objects. Added diagnostics MIB objects
+           to include Firmware download
+           fail status, device HDCP status, fixed inband tuner
+           interleaver object, added host DRI interface, Host
+           capabilities, RDC data rate object, added MacAddress syntax
+           to imports from rfc2579, changes syntax on RDC and FDC
+           power level MIB objects to TenthdBmV, changed the index in
+           ocStbHostCCAppInfoTable. This version is published as part
+           of the OpenCable Host MIB specification, MIB-HOST2.X,
+           version I03. Copyright 1999-2007 Cable Television
+           Laboratories, Inc. All rights reserved."
+   REVISION "200709210000Z"        -- September 21, 2007
+   DESCRIPTION
+           "Updated version to cover the addition of
+           physical address, address type, ip address and subnetmask
+           mib objects to both ocStbCardInfo and ocStbHostInfo,
+           Tuner status MIB objects to ocStbHostInBandTunerState,
+           MIB Decoder objects to ocStbHostMpeg2ContentTable,
+           QAM statistics MIB objects to ocStbHostQPSK,
+           CableCard Diagnostics ocStbHostCCMMITable and
+           ocStbHostCCAppInfo. This version is published as part of
+           the OpenCable Host MIB specification MIB-HOST2.X,
+           version I02. Copyright 1999-2007 Cable Television
+           Laboratories, Inc. All rights reserved."
+   ::= { clabProjOpenCable 1 }
+
+--
+-- Textual conventions
+--
+
+VideoOutputFormat ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+            "Defines the output format of the video signal
+            horizontal and vertical resolution."
+    SYNTAX      INTEGER {
+                format480i(1),
+                format480p(2),
+                format720p(3),
+                format1080i(4),
+                format1080p(5)
+                }
+
+AudioOutputFormat ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+            "Defines the output format of the audio signal."
+    SYNTAX      INTEGER
+                {
+                other(1),
+                lpcm(2), -- CD-A, DVD-A
+                ac3(3), -- Dolby Digital
+                eac3(4), -- Dolby Digital Plus
+                mpeg1L1L2(5), -- MPEG-1 Layers 1 & 2
+                mpeg1L3(6), -- MPEG-1 Layer 3
+                mpeg2(7), -- Advanced Audio Coding (AAC-LC)
+                mpeg4(8), -- MPEG-4 Advanced Audio Coding
+                            -- High Efficiency (AAC PLUS)
+                dts(9), -- Digital Theater Sound
+                atrac(10) -- Adaptive Transform Acoustic Coding
+                }
+
+VideoAspectRatio ::= TEXTUAL-CONVENTION
+    STATUS      current
+    DESCRIPTION
+            "Defines the horizontal and vertical aspect ratio of the
+            video signal.
+            'fourByThree' means a 4 by 3 aspect ratio.
+            'sixteenByNine' means a 16 by 9 aspect ratio.
+            'other' indicates a non-specified aspect ratio."
+    SYNTAX      INTEGER {
+                other(1),
+                fourByThree(2),
+                sixteenByNine(3)
+                }
+
+--
+-- Node definitions
+--
+
+ocStbHostNotifications OBJECT IDENTIFIER ::= { ocStbHostMibModule 0 }
+ocStbPanicDumpTrap NOTIFICATION-TYPE
+    OBJECTS {
+            ocStbHostDumpFilePath
+            }
+    STATUS      current
+    DESCRIPTION
+            "Notifies host that a panic dump condition has occurred.
+            The headend then may issue a TFTP Get to retrieve the
+            dump or ignore the trap and allow the host
+            ocStbHostDumpEventTimeout timer to expire. This trap is
+            sent only when the ocStbHostDumpEventCount object has a
+            non-zero value."
+    ::= { ocStbHostNotifications 1 }
+
+ocStbHostMibObjects OBJECT IDENTIFIER ::= { ocStbHostMibModule 1 }
+
+ocStbHostSystem OBJECT IDENTIFIER ::= { ocStbHostMibObjects 1 }
+ocStbHostHWIdentifiers OBJECT IDENTIFIER ::= { ocStbHostSystem 1 }
+ocStbHostInterfaces OBJECT IDENTIFIER ::= { ocStbHostSystem 2 }
+
+ocStbHostSerialNumber OBJECT-TYPE
+   SYNTAX       SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "The manufacturer's serial number for this device."
+   ::= { ocStbHostHWIdentifiers 1 }
+
+ocStbHostHostID OBJECT-TYPE
+   SYNTAX       DisplayString (SIZE(17))
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "Allows the manager to retrieve the 40-bit Host ID
+           of the ocStbHost (SNMP apdu TLV #1) in the string
+           format indicated below:
+
+           M-MMU-UUU-UUU-UUL
+
+           Where:
+
+           M-MM is the decimal representation of the
+           10-bit CHICA assigned manufacturer number.
+
+           U-UUU-UUU-UU is the decimal representation
+           of the 30-bit manufacturer assigned unit number.
+
+           L is a Luhn check digit calculated over the
+           preceding 12 decimal digits.
+
+           If the Host ID is unknown, then the string shall
+           be all zeros e.g., '0-000-000-000-000'."
+   ::= { ocStbHostHWIdentifiers 2 }
+
+ocStbHostCapabilities OBJECT-TYPE
+   SYNTAX       INTEGER {
+                other(1),
+                ochd2(2),
+                embedded(3),
+                dcas(4),
+                ochd21(5),
+                bocr(6),
+                ochdtc(7)
+                }
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "The capabilities indication of the STB device.
+
+           'other' means a device which is not described
+                by one of the other enumerations in this list.
+           'ochd2' means the STB device is an OpenCable Host Device
+                Version 2 Compliant device.
+           'embedded' means the STB device is of the non-removable
+                security type.
+           'dcas' means the STB device is of the downloadable
+                security type.
+           'ochd21' means the STB device is an OpenCable Host Device
+                Version 2.1 Compliant device.
+           'bocr' means the STB is bi-directional OCUR compliant.
+           'ochdtc' means the STB is an OpenCable Host Thin Chassis
+                device."
+    ::= { ocStbHostHWIdentifiers 3 }
+
+ocStbHostAvcSupport OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The AVC capabilities indication of the STB device.
+           The object has a value of true (1) if AVC decode is
+           supported. Otherwise, the object has a value of false (2).
+           The object is required when the ocStbHostCapabilities value
+           is ochd(2); otherwise the object is optional."
+    ::= { ocStbHostHWIdentifiers 4 }
+
+-- Types appropriate for use when designating devices and interfaces
+-- related to OpenCable Hosts. These types, for example, can be used
+-- in ocStbHostAVInterfaceType to designate the kind of interface.
+-- These types are also appropriate for use in hrDeviceType.
+--
+--
+ocStbHostDevInterfaceTypes OBJECT IDENTIFIER ::= { ocStbHostInterfaces 1 }
+
+ocStbHostOther OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for an interface not defined
+           in this MIB."
+    ::= { ocStbHostDevInterfaceTypes 1 }
+
+ocStbHostScte55FdcRx OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for SCTE-55 FDC Receiver
+           (i.e., out-of-band downstream tuner)."
+    ::= { ocStbHostDevInterfaceTypes 2 }
+
+ocStbHostScte55RdcTx OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for SCTE-55 RDC Transmitter
+           (i.e., out-of-band upstream transmitter)."
+    ::= { ocStbHostDevInterfaceTypes 3 }
+
+ocStbHostScte40FatRx OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for SCTE-40 FAT Receiver
+           (i.e., in-band video tuner)."
+    ::= { ocStbHostDevInterfaceTypes 4 }
+
+ocStbHostBbVideoIn OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for baseband video input."
+    ::= { ocStbHostDevInterfaceTypes 5 }
+
+ocStbHostBbAudioIn OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for baseband audio input."
+    ::= { ocStbHostDevInterfaceTypes 6 }
+
+ocStbHostBbVideoOut OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+           "The type identifier used for baseband video output."
+   ::= { ocStbHostDevInterfaceTypes 7 }
+
+ocStbHostBbAudioOut OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for baseband audio output."
+   ::= { ocStbHostDevInterfaceTypes 8 }
+
+ocStbHostRfOutCh OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for analog RF output."
+   ::= { ocStbHostDevInterfaceTypes 9 }
+
+ocStbHostSVideoIn OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for SVideo input."
+   ::= { ocStbHostDevInterfaceTypes 10 }
+
+ocStbHostSVideoOut OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for SVideo output."
+   ::= { ocStbHostDevInterfaceTypes 11 }
+
+ocStbHostComponentIn OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for Component input."
+   ::= { ocStbHostDevInterfaceTypes 12 }
+
+ocStbHostComponentOut OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for Component output."
+   ::= { ocStbHostDevInterfaceTypes 13 }
+
+ocStbHostDviIn OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for DVI input."
+   ::= { ocStbHostDevInterfaceTypes 14 }
+
+ocStbHostDviOut OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for DVI output."
+   ::= { ocStbHostDevInterfaceTypes 15 }
+
+ocStbHostHdmiIn OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for HDMI input."
+   ::= { ocStbHostDevInterfaceTypes 16 }
+
+ocStbHostHdmiOut OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for HDMI output."
+   ::= { ocStbHostDevInterfaceTypes 17 }
+
+ocStbHostRcaSpdifIn OBJECT-IDENTITY
+   STATUS       current
+   DESCRIPTION
+           "The type identifier used for RCA SPDIF input."
+   ::= { ocStbHostDevInterfaceTypes 18 }
+
+ocStbHostRcaSpdifOut OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for RCA SPDIF output."
+    ::= { ocStbHostDevInterfaceTypes 19 }
+
+ocStbHostToslinkSpdifIn OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for Toslink SPDIF input."
+    ::= { ocStbHostDevInterfaceTypes 20 }
+
+ocStbHostToslinkSpdifOut OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for Toslink SPDIF output."
+    ::= { ocStbHostDevInterfaceTypes 21 }
+
+ocStbHostDisplayOut OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for the television
+            screen output."
+    ::= { ocStbHostDevInterfaceTypes 22 }
+
+ocStbHost1394In OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for IEEE-1394 input."
+    ::= { ocStbHostDevInterfaceTypes 23 }
+
+ocStbHost1394Out OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for IEEE-1394 output."
+    ::= { ocStbHostDevInterfaceTypes 24 }
+
+ocStbHostDRIInterface OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION
+            "The type identifier used for the DRI interface."
+    ::= { ocStbHostDevInterfaceTypes 25 }
+
+-- A/V Interface Table
+
+ocStbHostAVInterfaceTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostAVInterfaceEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table contains a list of A/V (Audio/Video)
+            interfaces (video inputs/outputs, tuners, audio
+            inputs/outputs) in the ocStbHost."
+    ::= { ocStbHostInterfaces 2 }
+
+ocStbHostAVInterfaceEntry OBJECT-TYPE
+    SYNTAX      OcStbHostAVInterfaceEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "Each entry describes the type and status of the A/V
+            interface on the ocStbHost. The details of A/V interface
+            entries may be defined in table extensions as indicated
+            in the MIB object ocStbHostAVInterfaceType."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostAVInterfaceTable 1 }
+
+OcStbHostAVInterfaceEntry ::=
+   SEQUENCE {
+       ocStbHostAVInterfaceIndex
+           Unsigned32,
+       ocStbHostAVInterfaceType
+           AutonomousType,
+       ocStbHostAVInterfaceDesc
+           SnmpAdminString,
+       ocStbHostAVInterfaceStatus
+           INTEGER
+    }
+
+ocStbHostAVInterfaceIndex OBJECT-TYPE
+   SYNTAX      Unsigned32 (1..4294967295)
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "Index of the table."
+   ::= { ocStbHostAVInterfaceEntry 1 }
+
+ocStbHostAVInterfaceType OBJECT-TYPE
+   SYNTAX      AutonomousType
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "An indication of the type of interface.
+
+           If this value is
+              ocStbHostComponentOut
+           then a corresponding entry exists in the
+           ocStbHostComponentVideoTable.
+
+           If this value is
+              ocStbHostRFOutCh
+           then a corresponding entry exists in the
+           ocStbHostRFChannelOutTable.
+
+           If this value is
+              ocStbHostScte40FatRx
+           then a corresponding entry exists in the
+           ocStbHostInBandTunerTable.
+
+           If this value is
+              ocStbHostDviOut or ocStbHostHdmiOut
+           then a corresponding entry exists in the
+           ocStbHostDVIHDMITable
+
+           If this value is
+              ocStbHost1394Out
+           then a corresponding entry exists in the
+           ocStbHostIEEE1394Table
+
+           If this value is
+              hrDeviceOther
+           then no further information is available for the device."
+   ::= { ocStbHostAVInterfaceEntry 2 }
+
+ocStbHostAVInterfaceDesc OBJECT-TYPE
+   SYNTAX      SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Textual description of the A/V Interface "
+   ::= { ocStbHostAVInterfaceEntry 3 }
+
+ocStbHostAVInterfaceStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                enabled(1),
+                disabled(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "Status of the interface.
+            'enabled' indicates the A/V interface is active and can be
+            used for the user.
+            'disabled' indicates the A/V interface is currently not
+            available for the user due to hardware, software or
+            configuration conditions.
+            Additional information about the interface status may be
+            available in the A/V Type interface Table extensions."
+    ::= { ocStbHostAVInterfaceEntry 4 }
+
+--
+-- IEEE 1394 Objects
+--
+
+ocStbHostIEEE1394Objects OBJECT IDENTIFIER ::= { ocStbHostInterfaces 3 }
+
+ocStbHostIEEE1394Table OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostIEEE1394Entry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table contains attributes associated with the
+            ocStbHost Interfaces of type IEEE 1394."
+    ::= { ocStbHostIEEE1394Objects 1 }
+
+ocStbHostIEEE1394Entry OBJECT-TYPE
+    SYNTAX      OcStbHostIEEE1394Entry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "An entry exists in this table for each
+            interface of the type IEEE 1394."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostIEEE1394Table 1 }
+
+OcStbHostIEEE1394Entry ::=
+    SEQUENCE {
+        ocStbHostIEEE1394ActiveNodes          Integer32,
+        ocStbHostIEEE1394DataXMission         TruthValue,
+        ocStbHostIEEE1394DTCPStatus           TruthValue,
+        ocStbHostIEEE1394LoopStatus           TruthValue,
+        ocStbHostIEEE1394RootStatus           TruthValue,
+        ocStbHostIEEE1394CycleIsMaster        TruthValue,
+        ocStbHostIEEE1394IRMStatus            TruthValue,
+        ocStbHostIEEE1394AudioMuteStatus      TruthValue,
+        ocStbHostIEEE1394VideoMuteStatus      TruthValue
+        }
+
+ocStbHostIEEE1394ActiveNodes OBJECT-TYPE
+    SYNTAX      Integer32 (-1 | 0..64)
+    UNITS       "nodes"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object allows the manager to retrieve the
+            number of nodes connected to the 1394 bus of
+            the ocStbHost.
+            The value '-1' means unknown number of nodes."
+    ::= { ocStbHostIEEE1394Entry 1 }
+
+ocStbHostIEEE1394DataXMission OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of data being transmitted over the 1394
+           bus. True indicates that data is being transmitted
+           over the 1394 bus."
+   ::= { ocStbHostIEEE1394Entry 2 }
+
+ocStbHostIEEE1394DTCPStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of DTCP on the device. True indicates
+           that DTCP is enabled and content is being encrypted
+           of the 1394 link on the ocStbHost."
+   ::= { ocStbHostIEEE1394Entry 3 }
+
+ocStbHostIEEE1394LoopStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of a Loop present on the 1394 bus. True
+           indicates that a Loop is present on the 1394 bus."
+   ::= { ocStbHostIEEE1394Entry 4 }
+
+ocStbHostIEEE1394RootStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of Root Status on the device. True indicates
+           that the set-top is the Root node on the 1394 bus."
+   ::= { ocStbHostIEEE1394Entry 5 }
+
+ocStbHostIEEE1394CycleIsMaster OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of Cycle Master on the device. True indicates
+           that the set-top is Cycle Master on the 1394 bus."
+   ::= { ocStbHostIEEE1394Entry 6 }
+
+ocStbHostIEEE1394IRMStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of Isochronous Resource Master on the
+           device. True indicates that the set-top is IRM
+           on the 1394 bus."
+   ::= { ocStbHostIEEE1394Entry 7 }
+
+ocStbHostIEEE1394AudioMuteStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The value 'true' indicates that the audio signal
+            is muted for this Interface. 'false' means the audio
+            is not muted."
+    ::= { ocStbHostIEEE1394Entry 8 }
+
+ocStbHostIEEE1394VideoMuteStatus OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The value 'true' indicates that the video signal
+            is muted for this Interface. 'false' means the video
+            signal is not muted."
+    ::= { ocStbHostIEEE1394Entry 9 }
+
+ocStbHostIEEE1394ConnectedDevicesTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostIEEE1394ConnectedDevicesEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table contains A/D Source Selection attributes
+            associated to devices connected to the ocStbHost
+            Interfaces of type IEEE 1394."
+    ::= { ocStbHostIEEE1394Objects 2 }
+
+ocStbHostIEEE1394ConnectedDevicesEntry OBJECT-TYPE
+    SYNTAX      OcStbHostIEEE1394ConnectedDevicesEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "An entry exist in this table for each
+            device connected to all Interfaces of
+            the type IEEE 1394."
+    INDEX { ocStbHostIEEE1394ConnectedDevicesIndex }
+    ::= { ocStbHostIEEE1394ConnectedDevicesTable 1 }
+
+OcStbHostIEEE1394ConnectedDevicesEntry ::=
+    SEQUENCE {
+            ocStbHostIEEE1394ConnectedDevicesIndex
+             Unsigned32,
+            ocStbHostIEEE1394ConnectedDevicesAVInterfaceIndex
+             Unsigned32,
+            ocStbHostIEEE1394ConnectedDevicesSubUnitType
+             INTEGER,
+            ocStbHostIEEE1394ConnectedDevicesEui64
+             OCTET STRING,
+            ocStbHostIEEE1394ConnectedDevicesADSourceSelectSupport
+             TruthValue
+             }
+
+ocStbHostIEEE1394ConnectedDevicesIndex OBJECT-TYPE
+    SYNTAX      Unsigned32(1..4294967295)
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "The unique identifier of the connected device entry."
+    ::= { ocStbHostIEEE1394ConnectedDevicesEntry 1 }
+
+ocStbHostIEEE1394ConnectedDevicesAVInterfaceIndex OBJECT-TYPE
+    SYNTAX      Unsigned32(1..4294967295)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object allows the manager to retrieve the
+            index value associated with the IEEE1394
+           instance of ocStbHostAVInterfaceIndex
+           to which the device is physically connected."
+   ::= { ocStbHostIEEE1394ConnectedDevicesEntry 2 }
+
+ocStbHostIEEE1394ConnectedDevicesSubUnitType OBJECT-TYPE
+   SYNTAX      INTEGER {
+               monitor(0),
+               audio(1),
+               printer(2),
+               disc(3),
+               tape(4),
+               tuner(5),
+               ca(6),
+               camera(7),
+               reserved(8),
+               panel(9),
+               other(10)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           Subunit Type associated with the device connected
+           to the ocStbHost's IEEE1394 interface."
+   ::= { ocStbHostIEEE1394ConnectedDevicesEntry 3 }
+
+ocStbHostIEEE1394ConnectedDevicesEui64 OBJECT-TYPE
+   SYNTAX      OCTET STRING (SIZE (8))
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           64-bit Extended Unique Identifier (EUI-64)
+           associated with the device connected
+           to the ocStbHost's IEEE1394 interface."
+   ::= { ocStbHostIEEE1394ConnectedDevicesEntry 4 }
+
+ocStbHostIEEE1394ConnectedDevicesADSourceSelectSupport OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           status of Analog/Digital Source Selection support
+           associated with the device connected to the
+           ocStbHost's IEEE1394 interface.
+           'true' indicates that the device supports A/D
+           source selection."
+   ::= { ocStbHostIEEE1394ConnectedDevicesEntry 5 }
+
+ocStbHostDigitalVideoOutput OBJECT IDENTIFIER ::= { ocStbHostInterfaces 4 }
+
+ocStbHostDVIHDMITable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostDVIHDMIEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table allows the manager to retrieve information
+           about the DVI/HDMI port of the ocStbHost."
+   ::= { ocStbHostDigitalVideoOutput 1 }
+
+ocStbHostDVIHDMIEntry OBJECT-TYPE
+   SYNTAX      OcStbHostDVIHDMIEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "An entry exists for each A/V interface of type HDMI or DVI
+            of the ocStbHost."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostDVIHDMITable 1 }
+
+OcStbHostDVIHDMIEntry ::=
+    SEQUENCE {
+        ocStbHostDVIHDMIOutputType
+            INTEGER,
+        ocStbHostDVIHDMIConnectionStatus
+            TruthValue,
+        ocStbHostDVIHDMIRepeaterStatus
+            TruthValue,
+        ocStbHostDVIHDMIVideoXmissionStatus
+            TruthValue,
+        ocStbHostDVIHDMIHDCPStatus
+            TruthValue,
+        ocStbHostDVIHDMIVideoMuteStatus
+            TruthValue,
+        ocStbHostDVIHDMIOutputFormat
+            VideoOutputFormat,
+        ocStbHostDVIHDMIAspectRatio
+            VideoAspectRatio,
+        ocStbHostDVIHDMIHostDeviceHDCPStatus
+            INTEGER,
+        ocStbHostDVIHDMIAudioFormat
+            AudioOutputFormat,
+        ocStbHostDVIHDMIAudioSampleRate
+            INTEGER,
+        ocStbHostDVIHDMIAudioChannelCount
+            Unsigned32,
+        ocStbHostDVIHDMIAudioMuteStatus
+            TruthValue,
+        ocStbHostDVIHDMIAudioSampleSize
+            INTEGER,
+        ocStbHostDVIHDMIColorSpace
+            INTEGER,
+        ocStbHostDVIHDMIFrameRate
+            INTEGER,
+        ocStbHostDVIHDMIAttachedDeviceType
+            INTEGER,
+        ocStbHostDVIHDMIEdid
+            OCTET STRING,
+        ocStbHostDVIHDMILipSyncDelay
+            Integer32,
+        ocStbHostDVIHDMICecFeatures
+            BITS,
+        ocStbHostDVIHDMIFeatures
+            BITS,
+        ocStbHostDVIHDMIMaxDeviceCount
+            Integer32,
+        ocStbHostDVIHDMIPreferredVideoFormat
+            INTEGER,
+        ocStbHostDVIHDMIEdidVersion
+            SnmpAdminString
+     }
+
+ocStbHostDVIHDMIOutputType OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                dvi(1),
+                hdmi(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object defines the operational mode of the
+            interface, where valid modes are dependant on
+           the physical interface defined.
+
+           If ocStbHostAVInterfaceIndex is DVI, then
+           this value is always set to 1 (DVI).
+
+           If ocStbHostAVInterfaceIndex is HDMI, then
+           this value is either 1 (DVI) or 2 (HDMI)."
+   ::= { ocStbHostDVIHDMIEntry 2 }
+
+ocStbHostDVIHDMIConnectionStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of the DVI/HDMI port on the device.
+           'true' indicates that a device is connected to
+           the ocStbHost."
+   ::= { ocStbHostDVIHDMIEntry 3 }
+
+ocStbHostDVIHDMIRepeaterStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           presence of a repeater connected to the ocStbHost.
+           'true' indicates that a repeater is connected
+           to the ocStbHost."
+   ::= { ocStbHostDVIHDMIEntry 4 }
+
+ocStbHostDVIHDMIVideoXmissionStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of video transmission over the DVI/HDMI port
+           of the ocStbHost. 'true' indicates that video is being
+           transmitted over the DVI/HDMI link to a connected
+           device."
+   ::= { ocStbHostDVIHDMIEntry 5 }
+
+ocStbHostDVIHDMIHDCPStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of the digital copy protection protocol in the
+           interface.
+           'true' indicates that HDCP encryption is enabled."
+   ::= { ocStbHostDVIHDMIEntry 6 }
+
+ocStbHostDVIHDMIVideoMuteStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The value 'true' indicates that the video signal
+           is being muted over the DVI/HDMI link. 'false' means
+           the video signal is not muted."
+   ::= { ocStbHostDVIHDMIEntry 7 }
+
+ocStbHostDVIHDMIOutputFormat OBJECT-TYPE
+   SYNTAX      VideoOutputFormat
+   MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           video timing format currently being transmitted
+           over the DVI/HDMI link."
+    ::= { ocStbHostDVIHDMIEntry 8 }
+
+ocStbHostDVIHDMIAspectRatio OBJECT-TYPE
+    SYNTAX      VideoAspectRatio
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           aspect ratio applicable to the video timing
+           format currently being transmitted over the
+           DVI/HDMI link. e.g., 4/3 or 16/9."
+    ::= { ocStbHostDVIHDMIEntry 9 }
+
+ocStbHostDVIHDMIHostDeviceHDCPStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                nonHDCPdevice(1),
+                compliantHDCPdevice(2),
+                revokedHDCPdevice(3)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Connected device HDCP status."
+    ::= { ocStbHostDVIHDMIEntry 10 }
+
+ocStbHostDVIHDMIAudioFormat OBJECT-TYPE
+    SYNTAX      AudioOutputFormat
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           audio format being transmitted over the
+           HDMI link. If this entry corresponds to a DVI interface,
+           this object is not instantiated."
+    ::= { ocStbHostDVIHDMIEntry 11 }
+
+ocStbHostDVIHDMIAudioSampleRate OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                other(1),
+                samplerate32kHz(2),
+                samplerate44kHz(3),
+                samplerate48kHz(4),
+                samplerate88kHz(5),
+                samplerate96kHz(6),
+                samplerate176kHz(7),
+                samplerate192kHz(8)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           audio sample rate being transmitted over the
+           HDMI link. If this entry corresponds to a DVI interface,
+           this object is not instantiated."
+    ::= { ocStbHostDVIHDMIEntry 12 }
+
+ocStbHostDVIHDMIAudioChannelCount OBJECT-TYPE
+    SYNTAX      Unsigned32 (0..10)
+    UNITS       "channels"
+    MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           audio channel count being transmitted over the
+           HDMI link. If this entry corresponds to a DVI interface,
+           this object is not instantiated."
+   ::= { ocStbHostDVIHDMIEntry 13 }
+
+ocStbHostDVIHDMIAudioMuteStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The value 'true' indicates that the audio signal is muted
+           over the DVI/HDMI link. 'false' means the audio is not
+           muted. This object is not instantiated for entries of
+           ocStbHostDVIHDMIOutputType 'dvi'."
+   ::= { ocStbHostDVIHDMIEntry 14 }
+
+ocStbHostDVIHDMIAudioSampleSize OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               notValid(0),
+               sample16Bit(1),
+               sample20Bit(2),
+               sample24Bit(3)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Non-zero values pertain only to PCM audio formats and
+           indicate the PCM sample size. This object applies only
+           to HDMI outputs."
+   ::= { ocStbHostDVIHDMIEntry 15 }
+
+ocStbHostDVIHDMIColorSpace OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               rgb(0),
+               ycc422(1),
+               ycc444(2)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Color space for HDMI outputs only."
+   ::= { ocStbHostDVIHDMIEntry 16 }
+
+ocStbHostDVIHDMIFrameRate OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               frameRateCode1(1),
+               frameRateCode2(2),
+               frameRateCode3(3),
+               frameRateCode4(4),
+               frameRateCode5(5),
+               frameRateCode6(6)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Frame rates for HDMI outputs as defined in CCIF spec:
+               frameRateCode1 = 23.976 Hz
+               frameRateCode2 = 24.0 Hz
+               frameRateCode3 = 29.97 Hz
+               frameRateCode4 = 30.0 Hz
+               frameRateCode5 = 59.94 Hz
+                frameRateCode6 = 60.0 Hz."
+    ::= { ocStbHostDVIHDMIEntry 17 }
+
+ocStbHostDVIHDMIAttachedDeviceType OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                tv(0),
+                recordingDevice(1),
+                tuner(3),
+                playbackDevice(4),
+                audioSystem(5),
+                other(6)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The HDMI defined types of devices derived defined
+           in the DHMI specification version 1.3a."
+    ::= { ocStbHostDVIHDMIEntry 18 }
+
+ocStbHostDVIHDMIEdid OBJECT-TYPE
+    SYNTAX      OCTET STRING
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "EDID blob for debugging. A 0x00
+           should be returned if an EDID is
+           not available."
+    ::= { ocStbHostDVIHDMIEntry 19 }
+
+ocStbHostDVIHDMILipSyncDelay OBJECT-TYPE
+    SYNTAX Integer32
+    MAX-ACCESS read-only
+    STATUS current
+    DESCRIPTION
+           "Defines the amount of delay in milliseconds that is
+           being applied to the audio delivered over the HDMI
+           link. A value of zero indicates that either no delay
+           is being applied or Lip Sync is not supported by the
+           device."
+    ::= { ocStbHostDVIHDMIEntry 20 }
+
+ocStbHostDVIHDMICecFeatures OBJECT-TYPE
+    SYNTAX      BITS
+                {
+                oneTouchPlay(0),
+                systemStandby(1),
+                oneTouchRecord(2),
+                timerProgramming(3),
+                deckControl(4),
+                tunerControl(5),
+                deviceMenuControl(6),
+                remoteControlPassThrough(7),
+                systemAudioControl(8),
+                deviceOsdNameTransfer(9),
+                devicePowerStatus(10),
+                osdDisplay(11),
+                routingControl(12),
+                systemInformation(13),
+                vendorSpecificCommands(14),
+                audioRateControl(15)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object lists all of the CEC Features supported by the
+           device. When the bit is set, the feature is supported."
+   ::= { ocStbHostDVIHDMIEntry 21 }
+
+ocStbHostDVIHDMIFeatures OBJECT-TYPE
+   SYNTAX      BITS
+               {
+               deepColor(0),
+               extendedColorGamut(1),
+               oneBitAudio(2),
+               lipSync(3),
+               cec(4)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object lists all of the HDMI Features supported by
+           the device. When the bit is set, the feature is supported."
+   ::= { ocStbHostDVIHDMIEntry 22 }
+
+ocStbHostDVIHDMIMaxDeviceCount OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Defines the maximum number of downstream devices
+           that this device can support."
+   ::= { ocStbHostDVIHDMIEntry 23 }
+
+ocStbHostDVIHDMIPreferredVideoFormat OBJECT-TYPE
+   SYNTAX      INTEGER (0..127)
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           preferred video format of the sink device. The
+           value is an integer representing the video timing
+           format expressed as a CEA-861 Video Identification
+           Code (VIC).
+
+           If the Host is not able to determine the preferred
+           video format, or there is no corresponding VIC,
+           then the Host sets this value to zero. The Host also
+           sets this value to zero if there is no EDID or
+           active HDMI/DVI connection in place."
+   ::= { ocStbHostDVIHDMIEntry 24 }
+
+ocStbHostDVIHDMIEdidVersion OBJECT-TYPE
+   SYNTAX      SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "EDID version reported in bytes 18 and 19 of the EDID
+           itself. It is in version.release format. A value of 0.0
+           should be returned if an EDID is not available."
+   ::= { ocStbHostDVIHDMIEntry 25 }
+
+ocStbHostDVIHDMIAvailableVideoFormatTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostDVIHDMIAvailableVideoFormatEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table allows the manager to retrieve a list
+           of all of the video timing formats reported by the
+           sink device as per the device's EDID."
+   ::= { ocStbHostDigitalVideoOutput 2 }
+
+ocStbHostDVIHDMIAvailableVideoFormatEntry OBJECT-TYPE
+   SYNTAX      OcStbHostDVIHDMIAvailableVideoFormatEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "Entry in the ocStbHostDVIHDMIAvailableVideoFormatTable."
+    INDEX { ocStbHostDVIHDMIAvailableVideoFormatIndex }
+    ::= { ocStbHostDVIHDMIAvailableVideoFormatTable 1 }
+
+OcStbHostDVIHDMIAvailableVideoFormatEntry ::=
+    SEQUENCE {
+             ocStbHostDVIHDMIAvailableVideoFormatIndex
+                     INTEGER,
+             ocStbHostDVIHDMIAvailableVideoFormat
+                     INTEGER
+             }
+
+ocStbHostDVIHDMIAvailableVideoFormatIndex OBJECT-TYPE
+    SYNTAX      INTEGER (0..127)
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "Index in the ocStbHostDVIHDMIAvailableVideoFormatTable."
+    ::= { ocStbHostDVIHDMIAvailableVideoFormatEntry 1 }
+
+ocStbHostDVIHDMIAvailableVideoFormat OBJECT-TYPE
+    SYNTAX      INTEGER (0..127)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object allows the manager to retrieve the
+            available video formats of the sink device. The
+            value is an integer representing the video timing
+            format expressed as a CEA-861 Video Identification
+            Code (VIC).
+
+            If the Host is not able to determine the available
+            video formats, or there is no corresponding VIC,
+            then the Host makes an entry with a value of zero.
+            The Host also makes an entry with a value of zero
+            if there is no active HDMI/DVI connection in place."
+    ::= { ocStbHostDVIHDMIAvailableVideoFormatEntry 2 }
+
+--
+-- Analog Video Table Information
+--
+
+ocStbHostAnalogOutput OBJECT IDENTIFIER ::= { ocStbHostInterfaces 5 }
+
+ocStbHostComponentVideoTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostComponentVideoEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table allows the manager to retrieve information
+            about a Component Video interface of the ocStbHost."
+    ::= { ocStbHostAnalogOutput 1 }
+
+ocStbHostComponentVideoEntry OBJECT-TYPE
+    SYNTAX      OcStbHostComponentVideoEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "An entry for each interface of type
+            'ocStbHostComponentOut'."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostComponentVideoTable 1 }
+
+OcStbHostComponentVideoEntry ::=
+   SEQUENCE {
+        ocStbHostComponentVideoConstrainedStatus TruthValue,
+        ocStbHostComponentOutputFormat           VideoOutputFormat,
+        ocStbHostComponentAspectRatio            VideoAspectRatio,
+        ocStbHostComponentVideoMuteStatus        TruthValue
+        }
+
+ocStbHostComponentVideoConstrainedStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           state of Constrained Video Image on the port.
+           True indicates that video is being constrained
+           over the component video output port."
+   ::= { ocStbHostComponentVideoEntry 1 }
+
+ocStbHostComponentOutputFormat OBJECT-TYPE
+   SYNTAX      VideoOutputFormat
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           video format currently being transmitted over
+           the Component Video output port."
+   ::= { ocStbHostComponentVideoEntry 2 }
+
+ocStbHostComponentAspectRatio OBJECT-TYPE
+   SYNTAX      VideoAspectRatio
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           video aspect ratio currently being transmitted over
+           the Component Video output port."
+   ::= { ocStbHostComponentVideoEntry 3 }
+
+ocStbHostComponentVideoMuteStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The value 'true' indicates that the video signal is
+           muted for this Interface. 'false' means the video
+           signal is not muted."
+   ::= { ocStbHostComponentVideoEntry 4 }
+
+--
+-- NTSC RF Output
+--
+
+ocStbHostRFChannelOutTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostRFChannelOutEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table allows the manager to retrieve information
+           about an RF channel output interface of the ocStbHost."
+   ::= { ocStbHostAnalogOutput 2 }
+
+ocStbHostRFChannelOutEntry OBJECT-TYPE
+   SYNTAX      OcStbHostRFChannelOutEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "An entry for each interface of type 'ocStbHostRFOutCh'."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostRFChannelOutTable 1 }
+
+OcStbHostRFChannelOutEntry ::=
+    SEQUENCE {
+        ocStbHostRFChannelOut                     Unsigned32,
+        ocStbHostRFChannelOutAudioMuteStatus      TruthValue,
+        ocStbHostRFChannelOutVideoMuteStatus      TruthValue
+        }
+
+ocStbHostRFChannelOut OBJECT-TYPE
+    SYNTAX      Unsigned32 (3..99)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "Indicates the RF channel out value. Typical values are
+            3 or 4 for Channels 3 and 4, respectively."
+    ::= { ocStbHostRFChannelOutEntry 2 }
+
+ocStbHostRFChannelOutAudioMuteStatus OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The value 'true' indicates that the audio signal is
+            muted for this Interface. 'false' means the audio
+            is not muted."
+    ::= { ocStbHostRFChannelOutEntry 3 }
+
+ocStbHostRFChannelOutVideoMuteStatus OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The value 'true' indicates that the video signal is
+            muted for this Interface. 'false' means the video
+            signal is not muted."
+    ::= { ocStbHostRFChannelOutEntry 4 }
+
+--
+-- Sony Philips Digital Audio Interface
+--
+
+ocStbHostSPDIfTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostSPDIfEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table allows the manager to retrieve information
+            about the SONY, Philips Digital (SPD) Interface of the
+            ocStbHost."
+    ::= { ocStbHostInterfaces 6 }
+
+ocStbHostSPDIfEntry OBJECT-TYPE
+    SYNTAX      OcStbHostSPDIfEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "An entry exists for each Audio interface of type SPD."
+    INDEX { ocStbHostAVInterfaceIndex }
+    ::= { ocStbHostSPDIfTable 1 }
+
+OcStbHostSPDIfEntry ::= SEQUENCE {
+        ocStbHostSPDIfAudioFormat          AudioOutputFormat,
+        ocStbHostSPDIfAudioMuteStatus      TruthValue
+        }
+
+ocStbHostSPDIfAudioFormat OBJECT-TYPE
+   SYNTAX      AudioOutputFormat
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The format of the Audio stream transmitted over this
+           interface."
+   ::= { ocStbHostSPDIfEntry 1 }
+
+ocStbHostSPDIfAudioMuteStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The value 'true' indicates that the audio signal is muted
+           over the SPDIF link. 'false' means the audio is not muted."
+   ::= { ocStbHostSPDIfEntry 2 }
+
+ocStbHostServiceProgramInfo OBJECT IDENTIFIER ::= { ocStbHostInterfaces 7 }
+
+ocStbHostInBandTunerTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostInBandTunerEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This Object Table allows the manager to retrieve
+           information regarding the In-Band tuner(s) in
+           the ocStbHost."
+   ::= { ocStbHostServiceProgramInfo 1 }
+
+ocStbHostInBandTunerEntry OBJECT-TYPE
+   SYNTAX      OcStbHostInBandTunerEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This entry contains information regarding
+           a tuner of type ocStbHostScte40FatRx in the ocStbHost."
+   INDEX { ocStbHostAVInterfaceIndex }
+   ::= { ocStbHostInBandTunerTable 1 }
+
+OcStbHostInBandTunerEntry ::=
+   SEQUENCE {
+       ocStbHostInBandTunerModulationMode
+           INTEGER,
+       ocStbHostInBandTunerFrequency
+           Unsigned32,
+       ocStbHostInBandTunerInterleaver
+           INTEGER,
+       ocStbHostInBandTunerPower
+           TenthdBmV,
+       ocStbHostInBandTunerAGCValue
+           Unsigned32,
+       ocStbHostInBandTunerSNRValue
+           TenthdB,
+       ocStbHostInBandTunerUnerroreds
+           Counter32,
+       ocStbHostInBandTunerCorrecteds
+           Counter32,
+       ocStbHostInBandTunerUncorrectables
+           Counter32,
+       ocStbHostInBandTunerCarrierLockLost
+           Counter32,
+       ocStbHostInBandTunerPCRErrors
+           Counter32,
+       ocStbHostInBandTunerPTSErrors
+           Counter32,
+       ocStbHostInBandTunerState
+           INTEGER,
+        ocStbHostInBandTunerBER
+           INTEGER,
+        ocStbHostInBandTunerSecsSinceLock
+           Unsigned32,
+        ocStbHostInBandTunerEqGain
+           Integer32,
+        ocStbHostInBandTunerMainTapCoeff
+           INTEGER,
+        ocStbHostInBandTunerTotalTuneCount
+           Counter32,
+        ocStbHostInBandTunerTuneFailureCount
+           Counter32,
+        ocStbHostInBandTunerTuneFailFreq
+           Unsigned32,
+        ocStbHostInBandTunerBandwidth
+           INTEGER
+        }
+
+ocStbHostInBandTunerModulationMode OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                other(1),
+                analog(2),
+                qam64(3),
+                qam256(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The In-band tuner modulation mode.
+
+           Modulation modes are as follows:
+           other      - IB is configured in a manner not described
+                        by any other listed mode.
+           Analog     - IB is configured for analog service.
+           QAM-64     - IB is configured for a digital service that
+                        is 64-QAM.
+           QAM-256 - IB is configured for a digital service that
+                        is 256-QAM."
+    ::= { ocStbHostInBandTunerEntry 1 }
+
+ocStbHostInBandTunerFrequency OBJECT-TYPE
+    SYNTAX      Unsigned32
+    UNITS       "hertz"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the center
+           frequency of the currently tuned channel in Hz."
+    ::= { ocStbHostInBandTunerEntry 2 }
+
+ocStbHostInBandTunerInterleaver OBJECT-TYPE
+    SYNTAX      INTEGER {
+                unknown(1),
+                other(2),
+                taps64Increment2(3),
+                taps128Increment1(4),
+                taps128increment2(5),
+                taps128increment3(6),
+                taps128increment4(7),
+                taps32increment4(8),
+                taps16increment8(9),
+                taps8increment16(10)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+   DESCRIPTION
+           "The in-band interface interleaver value.
+              set to '3' current operational mode 'taps64Increment2'
+              set to '4' current operational mode 'taps128Increment1'
+              set to '5' current operational mode 'taps128increment2'
+              set to '6' current operational mode 'taps128increment3'
+              set to '7' current operational mode 'taps128increment4'
+              set to '8' current operational mode 'taps32increment4'
+              set to '9' current operational mode 'taps16increment8'
+              set to '10' current operational mode 'taps8increment16'"
+   ::= { ocStbHostInBandTunerEntry 3 }
+ocStbHostInBandTunerPower OBJECT-TYPE
+   SYNTAX      TenthdBmV
+   UNITS       "dBmV"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The received power level of this in-band interface."
+   ::= { ocStbHostInBandTunerEntry 4 }
+
+ocStbHostInBandTunerAGCValue OBJECT-TYPE
+   SYNTAX      Unsigned32(0..100)
+   UNITS       "percentage"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           In-band channel AGC value (%). When an In-band
+           Carrier Lock is indicated, a value of 0 (zero)
+           indicates that the ocStbHost does not compute the
+           value."
+   ::= { ocStbHostInBandTunerEntry 5 }
+
+ocStbHostInBandTunerSNRValue OBJECT-TYPE
+   SYNTAX      TenthdB
+   UNITS       "dB"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           In-band channel SNR value (1/10 dB). When an
+           In-band Carrier Lock is indicated, a value of 0
+           (zero) indicates that the ocStbHost does not compute
+           the value."
+   ::= { ocStbHostInBandTunerEntry 6 }
+
+ocStbHostInBandTunerUnerroreds OBJECT-TYPE
+   SYNTAX      Counter32
+   UNITS       "codewords"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Codewords received on this channel without error.
+           Discontinuities in the value of this counter can occur
+           at reinitialization of the managed system, and at other
+           times as indicated by the value of
+           ifCounterDiscontinuityTime for the associated ifIndex."
+   ::= { ocStbHostInBandTunerEntry 7 }
+
+ocStbHostInBandTunerCorrecteds OBJECT-TYPE
+   SYNTAX      Counter32
+   UNITS       "codewords"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Codewords received on this in-band channel with
+           correctable errors. Discontinuities in the value of
+           this counter can occur at reinitialization of the
+           managed system."
+    ::= { ocStbHostInBandTunerEntry 8 }
+
+ocStbHostInBandTunerUncorrectables OBJECT-TYPE
+    SYNTAX      Counter32
+    UNITS       "codewords"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Codewords received on this in-band channel with
+           uncorrectable errors.
+           Discontinuities in the value of this counter can occur
+           at reinitialization of the managed system."
+    ::= { ocStbHostInBandTunerEntry 9 }
+
+ocStbHostInBandTunerCarrierLockLost OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of times the ocStbHost has detected carrier
+           Lock is lost.
+           Discontinuities in the value of this counter can occur
+           at reinitialization of the managed system."
+    ::= { ocStbHostInBandTunerEntry 10 }
+
+ocStbHostInBandTunerPCRErrors OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of times the Program Clock Reference (PCR)
+           detected Synchronization errors; e.g., wrong PCR from
+           multiplexer, excessive CPR Jitter, etc.
+           Discontinuities in the value of this counter can occur
+           at reinitialization of the managed system."
+    ::= { ocStbHostInBandTunerEntry 11 }
+
+ocStbHostInBandTunerPTSErrors OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of Presentation TimeStamp (PTS) packets that
+           encounter sequencing errors.
+           Discontinuities in the value of this counter can occur
+           at reinitialization of the managed system."
+    ::= { ocStbHostInBandTunerEntry 12 }
+
+ocStbHostInBandTunerState OBJECT-TYPE
+    SYNTAX      INTEGER {
+                ready(1),
+                waitingSync(2),
+                waitingQam(3),
+                foundSync(4),
+                foundQam(5),
+                unknown(6),
+                standby(7)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The In-band tuner current state.
+
+           Modulation modes are as follows:
+           ready - indicates that the tuner is in idle mode (not
+               currently in use).
+           waitingSync - indicates that the tuner is trying to
+               find sync on an analog channel.
+           waitingQam - indicates that the tuner is trying to tune
+               to the desired QAM frequency and lock onto valid data.
+           foundSync - indicates that the tuner has successfully
+               tuned to an analog channel.
+           foundQam - indicates that the tuner has successfully
+               tuned to a digital channel."
+   ::= { ocStbHostInBandTunerEntry 13 }
+
+ocStbHostInBandTunerBER OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               berGreaterThan10e2(1),
+               berRange10e2ToGreaterThan10e4(2),
+               berRange10e4ToGreaterThan10e6(3),
+               berRange10e6ToGreaterThan10e8(4),
+               berRange10e8ToGreaterThan10e12(5),
+               berEqualToOrLessThan10e12(6),
+               berNotApplicable(7)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The average Bit Error Rate range since last tune to a digital
+           channel. This value is determined by dividing the number of
+           erroneous bits by the total number of bits transmitted
+           within the last 10 minutes of the object being polled.
+           Report value of 7 if tuned to an analog channel."
+   ::= { ocStbHostInBandTunerEntry 14 }
+
+ocStbHostInBandTunerSecsSinceLock OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The amount of time, in seconds, since the last tuner lock
+           on a valid data signal. Each time the tuner locks the
+           ocStbHostInBandTunerUnerroreds,
+           ocStbHostInBandTunerCorrecteds, and
+           ocStbHostInBandTunerUncorrectables, counters should be
+           set to 0."
+   ::= { ocStbHostInBandTunerEntry 15 }
+
+ocStbHostInBandTunerEqGain OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The value of the equalizer gain on the QAM data channel.
+            A value of 0 (zero) indicates that the ocStbHost does not
+            compute the value."
+   ::= { ocStbHostInBandTunerEntry 16 }
+
+ocStbHostInBandTunerMainTapCoeff OBJECT-TYPE
+   SYNTAX      INTEGER(1..32767)
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The normalized main tap coefficient used for calibrating
+           data path delay or frequency response. A value of 0 (zero)
+           indicates that the ocStbHost does not compute the value."
+   ::= { ocStbHostInBandTunerEntry 17 }
+
+ocStbHostInBandTunerTotalTuneCount OBJECT-TYPE
+   SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of times an attempt has been made to change
+           the tuned frequency. This includes both successful and
+           unsuccessful attempts."
+    ::= { ocStbHostInBandTunerEntry 18 }
+
+ocStbHostInBandTunerTuneFailureCount OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of times an attempt to change the tuned
+           frequency has resulted in a failure to acquire a signal
+           (either analog or digital)."
+    ::= { ocStbHostInBandTunerEntry 19 }
+
+ocStbHostInBandTunerTuneFailFreq OBJECT-TYPE
+    SYNTAX      Unsigned32
+    UNITS       "hertz"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The most recent frequency at which an attempt to tune
+           resulted in an increment of
+           ocStbHostInBandTunerTuneFailureCount. If no tune attempt
+           has failed since initialization, this value
+           SHALL be zero."
+    ::= { ocStbHostInBandTunerEntry 20 }
+
+ocStbHostInBandTunerBandwidth OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                other(1),
+                mHz864(2),
+                mHz1002(3)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The In-band tuner bandwidth.
+           Tuner bandwidth choices are as follows:
+           other        - Tuning range is not described
+                          by any other listed range.
+           mHz864       - Tuning range is 54 to 864 MHz
+           mHz1002      - Tuning range is 54 to 1002 MHz."
+    ::= { ocStbHostInBandTunerEntry 21 }
+
+ocStbHostProgramStatusTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostProgramStatusEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+           "A table of current program content being forwarded by the
+           ocStbHost."
+    ::= { ocStbHostServiceProgramInfo 2 }
+
+ocStbHostProgramStatusEntry OBJECT-TYPE
+    SYNTAX      OcStbHostProgramStatusEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+           "There is an entry in this table for each active program
+           content path.
+           This means that the same program content source and/or
+           destination can be associated to multiple A/V interface
+           combinations as different entries in this table."
+   INDEX { ocStbHostProgramIndex }
+   ::= { ocStbHostProgramStatusTable 1 }
+
+OcStbHostProgramStatusEntry ::=
+   SEQUENCE {
+       ocStbHostProgramIndex
+           Unsigned32,
+       ocStbHostProgramAVSource
+           RowPointer,
+       ocStbHostProgramAVDestination
+           RowPointer,
+       ocStbHostProgramContentSource
+           RowPointer,
+       ocStbHostProgramContentDestination
+           RowPointer
+       }
+
+ocStbHostProgramIndex OBJECT-TYPE
+   SYNTAX      Unsigned32 (1..20)
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "Index for Program Status Entry Table."
+   ::= { ocStbHostProgramStatusEntry 1 }
+
+ocStbHostProgramAVSource OBJECT-TYPE
+   SYNTAX      RowPointer
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Defines the source interface
+           associated with this entry. Example sources are
+           interfaces listed in the ifTable, interfaces listed in
+           ocStbAVInterfaceTable, or a Host Resources Device such as a
+           DVR.
+           If the source corresponds to an entry in the
+           ocStbAVInterfaceTable, this object reports the
+           ocStbAVInterfaceType instance of the source interface.
+           If the source corresponds to a resource listed in the
+           ifTable, this object reports the ifIndex instance of
+           the source interface.
+           If the source corresponds to a resource listed in
+           hrDeviceTable, this object reports the hrDeviceType
+           instance of the source interface.
+           Other table rows may be designated by this object
+           as appropriate to the particular source."
+   ::= { ocStbHostProgramStatusEntry 2 }
+
+ocStbHostProgramAVDestination OBJECT-TYPE
+   SYNTAX      RowPointer
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Defines the destination interface
+           associated with this entry. Example destinations are
+           interfaces listed in the ifTable, interfaces listed in
+           ocStbAVInterfaceTable,
+           or a Host Resource Device such as a DVR.
+           If the destination corresponds to an entry in the
+           ocStbAVInterfaceTable, this object reports the
+           ocStbAVInterfaceType instance of the destination
+           interface.
+           If the destination corresponds to an interface listed in
+           the ifTable, this object reports the ifIndex instance of
+           the destination interface.
+           If the destination corresponds to a resource listed in the
+            hrDeviceTable, this object reports the hrDeviceType
+            instance of the destination interface.
+            Other table rows may be designated by this object
+            as appropriate to the particular destination."
+    ::= { ocStbHostProgramStatusEntry 3 }
+
+ocStbHostProgramContentSource OBJECT-TYPE
+    SYNTAX      RowPointer
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "A pointer to the first visible object structure that
+            defines the type of content associated to the A/V source
+            interface. If the content is from an MPEG2 stream, this
+            object points to the first visible object in
+            ocStbHostMpeg2ContentEntry.
+            Vendor-specific Content models may be defined in the vendor
+            enterprise IANA assigned OID.
+            This object reports 'zeroDotZero' value if no content
+            information is available."
+    ::= { ocStbHostProgramStatusEntry 4 }
+
+ocStbHostProgramContentDestination OBJECT-TYPE
+    SYNTAX      RowPointer
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "A pointer to the first visible object structure that
+            defines the type of content associated to the A/V
+            destination interface. For example, if the content for the
+            destination interface is an MPEG2 stream
+            (e.g., IEEE 1394 SPTS), this object points to the
+            first visible object in ocStbHostMpeg2ContentEntry.
+            Vendor-specific Content models may be defined in the vendor
+            enterprise IANA assigned OID.
+            This object reports 'zeroDotZero' value if no content
+            information is available."
+    ::= { ocStbHostProgramStatusEntry 5 }
+
+--
+-- MPEG2 Streaming Content Information
+--
+
+ocStbHostMpeg2ContentTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostMpeg2ContentEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "Contains information associated to an MPEG-2
+            Program carried by an MPEG-2 transport stream.
+            Entries in this table can be
+            associated to interfaces receiving or forwarding
+            MPEG-2 content."
+    ::= { ocStbHostServiceProgramInfo 3 }
+
+ocStbHostMpeg2ContentEntry OBJECT-TYPE
+    SYNTAX      OcStbHostMpeg2ContentEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "The conceptual row for this table."
+    INDEX { ocStbHostMpeg2ContentIndex }
+    ::= { ocStbHostMpeg2ContentTable 1 }
+
+OcStbHostMpeg2ContentEntry::=
+    SEQUENCE {
+        ocStbHostMpeg2ContentIndex
+           Unsigned32,
+       ocStbHostMpeg2ContentProgramNumber
+           Unsigned32,
+       ocStbHostMpeg2ContentTransportStreamID
+           Unsigned32,
+       ocStbHostMpeg2ContentTotalStreams
+           Unsigned32,
+       ocStbHostMpeg2ContentSelectedVideoPID
+           Integer32,
+       ocStbHostMpeg2ContentSelectedAudioPID
+           Integer32,
+       ocStbHostMpeg2ContentOtherAudioPIDs
+           TruthValue,
+       ocStbHostMpeg2ContentCCIValue
+           INTEGER,
+       ocStbHostMpeg2ContentAPSValue
+           INTEGER,
+       ocStbHostMpeg2ContentCITStatus
+           TruthValue,
+       ocStbHostMpeg2ContentBroadcastFlagStatus
+           TruthValue,
+       ocStbHostMpeg2ContentEPNStatus
+           TruthValue,
+       ocStbHostMpeg2ContentPCRPID
+           Integer32,
+       ocStbHostMpeg2ContentPCRLockStatus
+           INTEGER,
+       ocStbHostMpeg2ContentDecoderPTS
+           Integer32,
+       ocStbHostMpeg2ContentDiscontinuities
+           Counter32,
+       ocStbHostMpeg2ContentPktErrors
+           Counter32,
+       ocStbHostMpeg2ContentPipelineErrors
+           Counter32,
+       ocStbHostMpeg2ContentDecoderRestarts
+           Counter32
+       }
+
+ocStbHostMpeg2ContentIndex OBJECT-TYPE
+   SYNTAX      Unsigned32 (1..20)
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "The unique identifier for the Mpeg2 Content entries in
+           this table."
+   ::= { ocStbHostMpeg2ContentEntry 1 }
+
+ocStbHostMpeg2ContentProgramNumber OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The program Number associated with active content within
+           the ocStbHost."
+   ::= { ocStbHostMpeg2ContentEntry 2 }
+
+ocStbHostMpeg2ContentTransportStreamID OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Defines the transport stream ID associated with the
+           program number."
+   ::= { ocStbHostMpeg2ContentEntry 3 }
+
+ocStbHostMpeg2ContentTotalStreams OBJECT-TYPE
+    SYNTAX      Unsigned32
+    UNITS       "streams"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Defines the total number of elementary streams associated
+           with the program number."
+    ::= { ocStbHostMpeg2ContentEntry 4 }
+
+ocStbHostMpeg2ContentSelectedVideoPID OBJECT-TYPE
+    SYNTAX      Integer32 (-1 | 1..8191)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           PID associated to the selected video
+           stream. The value '-1' indicates that no video stream
+           is being selected or identified.
+           The value is the 13-bit PID value expressed in decimal."
+    ::= { ocStbHostMpeg2ContentEntry 5 }
+
+ocStbHostMpeg2ContentSelectedAudioPID OBJECT-TYPE
+    SYNTAX      Integer32 (-1 | 1..8191)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The selected audio PID.
+           The value '-1' indicates no audio stream identified."
+    ::= { ocStbHostMpeg2ContentEntry 6 }
+
+ocStbHostMpeg2ContentOtherAudioPIDs OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Then value 'true' indicates the MPEG-2 program
+           has more than one audio PID.
+           'false' indicates the MPEG-2 program has only one
+           audio PID."
+    ::= { ocStbHostMpeg2ContentEntry 7 }
+
+ocStbHostMpeg2ContentCCIValue OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                copyFreely(0),
+                copyNoMore(1),
+                copyOneGeneration(2),
+                copyNever(3),
+                undefined(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This value allows the manager to retrieve the
+           encryption Mode Indication (EMI) Bits of the
+           Copy Control Information (CCI) byte associated
+           with the service."
+    ::= { ocStbHostMpeg2ContentEntry 8 }
+
+ocStbHostMpeg2ContentAPSValue OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                type1(1),
+                type2(2),
+                type3(3),
+                noMacrovision(4),
+                notDefined(5)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This value allows the manager to retrieve the
+           Analog Protection System (APS) bits of the
+           Copy Control Information (CCI) byte
+           associated with the service.
+           'type1' indicates AGC ON, split burst OFF
+           'type2' indicates AGC ON, 2-line split burst
+           'type3' indicates AGC ON, 4-line split burst."
+   ::= { ocStbHostMpeg2ContentEntry 9 }
+
+ocStbHostMpeg2ContentCITStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This value allows the manager to retrieve the state
+           of the Constrained Image Trigger(CIT).
+
+           'true' indicates image constraint required.
+           'false' indicates image constraint not asserted."
+   ::= { ocStbHostMpeg2ContentEntry 10 }
+
+ocStbHostMpeg2ContentBroadcastFlagStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This value allows the manager to retrieve the state
+           of Broadcast Flag in the source interface.
+           'true' indicates Broadcast Flag present.
+           'false' indicates Broadcast Flag not present."
+   ::= { ocStbHostMpeg2ContentEntry 11 }
+
+ocStbHostMpeg2ContentEPNStatus OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           EPN status of the MPEG stream. 'true' indicates
+           that EPN is asserted."
+   ::= { ocStbHostMpeg2ContentEntry 12 }
+
+ocStbHostMpeg2ContentPCRPID OBJECT-TYPE
+   SYNTAX      Integer32 (-1 | 1..8191)
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           PCR PID associated to the selected video
+           stream. The value '-1' indicates that no video stream
+           is being selected or identified. The value is the 13-bit
+           PCR PID value expressed in decimal."
+   ::= { ocStbHostMpeg2ContentEntry 13 }
+
+ocStbHostMpeg2ContentPCRLockStatus OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               notLocked(1),
+               locked(2)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The status of the Program Clock Reference lock."
+    ::= { ocStbHostMpeg2ContentEntry 14 }
+
+ocStbHostMpeg2ContentDecoderPTS OBJECT-TYPE
+    SYNTAX      Integer32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The value of the MPEG decoder Presentation TimeStamp
+           (PTS). The LSB should be dropped to reduce the PTS length
+           to 32 bits."
+    ::= { ocStbHostMpeg2ContentEntry 15 }
+
+ocStbHostMpeg2ContentDiscontinuities OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The sum of the audio and video PID discontinuities
+           detected on the MPEG stream. The values are based on
+           the time since PCR lock on the current PIDs or stream being
+           reported"
+    ::= { ocStbHostMpeg2ContentEntry 16 }
+
+ocStbHostMpeg2ContentPktErrors OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of errors detected in the MPEG stream. The
+            Values are based on the time since PCR lock on the
+            Current PIDs or stream being reported"
+    ::= { ocStbHostMpeg2ContentEntry 17 }
+
+ocStbHostMpeg2ContentPipelineErrors OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of errors reported exclusively by the MPEG decoder."
+    ::= { ocStbHostMpeg2ContentEntry 18 }
+
+ocStbHostMpeg2ContentDecoderRestarts OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of times the software driver restarted
+           the MPEG decoding process."
+    ::= { ocStbHostMpeg2ContentEntry 19 }
+
+--
+-- Analog Video Table
+--
+
+ocStbHostAnalogVideoTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostAnalogVideoEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+           "Contains information about the Analog Video signal.
+           Entries in this table can be associated to interfaces
+           receiving or forwarding analog content."
+    ::= { ocStbHostServiceProgramInfo 4 }
+
+ocStbHostAnalogVideoEntry OBJECT-TYPE
+    SYNTAX      OcStbHostAnalogVideoEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "The conceptual row for this table."
+   INDEX { ocStbHostAVInterfaceIndex }
+   ::= { ocStbHostAnalogVideoTable 1 }
+
+OcStbHostAnalogVideoEntry ::=
+   SEQUENCE {
+        ocStbHostAnalogVideoProtectionStatus INTEGER
+        }
+
+ocStbHostAnalogVideoProtectionStatus OBJECT-TYPE
+   SYNTAX      INTEGER {
+               copyProtectionOff(0),
+               splitBurstOff(1),
+               twoLineSplitBurst(2),
+               fourLineSplitBurst(3)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The analog protection system (APS) of this Video content
+           entry. The possible values are:
+           'copyProtectionOff' means the Macrovision Analog protection
+            is off
+           'splitBurstOff' means the AGC (Automatic Gain Control)
+            is on and the split burst is off.
+           'twoLineSplitBurst' means AGC is on with two-line
+            split burst.
+           'fourLineSplitBurst' means AGC is on with four-line
+            split burst.
+           This object is instantiated only for A/V output interfaces
+           that support APS like but not limited to:
+           'ocStbHostRfOutCh', 'ocStbHostSVideoOut' and
+           'ocStbHostBbVideoOut'.
+           The A/V interfaces 'ocStbHostComponentOut'
+           only support 'splitBurstOff' APS mode for the video formats
+           'format480i' and 'format480p'."
+   ::= { ocStbHostAnalogVideoEntry 1 }
+
+--
+-- QPSK Objects
+--
+
+ocStbHostQpskObjects OBJECT IDENTIFIER ::= {ocStbHostInterfaces 8}
+
+ocStbHostQpskFDCFreq OBJECT-TYPE
+   SYNTAX      Unsigned32
+   UNITS       "hertz"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The frequency to which the QPSK receiver is currently tuned."
+   ::= { ocStbHostQpskObjects 1 }
+
+ocStbHostQpskRDCFreq OBJECT-TYPE
+   SYNTAX      Unsigned32
+   UNITS       "hertz"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The frequency to which the QPSK transmitter is currently tuned."
+   ::= { ocStbHostQpskObjects 2 }
+
+ocStbHostQpskFDCBer OBJECT-TYPE
+   SYNTAX      INTEGER
+                {
+                berGreaterThan10e2(1),
+                berRange10e2ToGreaterThan10e4(2),
+                berRange10e4ToGreaterThan10e6(3),
+                berRange10e6ToGreaterThan10e8(4),
+                berRange10e8ToGreaterThan10e12(5),
+                berEqualToOrLessThan10e12(6),
+                berNotApplicable(7)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The rate at which bit errors are occurring based on the
+           number of data errors since the frequency has been locked."
+    ::= { ocStbHostQpskObjects 3 }
+
+ocStbHostQpskFDCStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                notLocked(1),
+                locked(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Forward data channel lock status."
+    ::= { ocStbHostQpskObjects 4 }
+
+ocStbHostQpskFDCBytesRead OBJECT-TYPE
+    SYNTAX      Unsigned32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of bytes successfully read since the frequency
+           was locked."
+    ::= { ocStbHostQpskObjects 5 }
+
+ocStbHostQpskFDCPower OBJECT-TYPE
+    SYNTAX      TenthdBmV
+    UNITS       "dBmV"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The power level, in dBmV, of the forward data channel."
+    ::= { ocStbHostQpskObjects 6 }
+
+ocStbHostQpskFDCLockedTime OBJECT-TYPE
+    SYNTAX      Unsigned32
+    UNITS       "seconds"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The number of seconds that the current FDC frequency
+           has been locked."
+    ::= { ocStbHostQpskObjects 7 }
+
+ocStbHostQpskFDCSNR OBJECT-TYPE
+    SYNTAX      TenthdB
+    UNITS       "dB"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object allows the manager to retrieve the
+           FDC SNR value (1/10 dB)."
+    ::= { ocStbHostQpskObjects 8 }
+
+ocStbHostQpskAGC OBJECT-TYPE
+   SYNTAX      Unsigned32
+   UNITS       "percent"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the OOB channel
+           Automatic Gain Control value (%)."
+   ::= { ocStbHostQpskObjects 9 }
+
+ocStbHostQpskRDCPower OBJECT-TYPE
+   SYNTAX      TenthdBmV
+   UNITS       "dBmV"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The power output level, in dBmV, of the QPSK transmitter."
+   ::= { ocStbHostQpskObjects 10 }
+
+ocStbHostQpskRDCDataRate OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               kbps256(1),
+               kbps1544(2),
+               kbps3088(3)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The data rate (in kbps) of the RDC."
+   ::= { ocStbHostQpskObjects 11 }
+
+--
+-- EAS Objects
+--
+
+ocStbHostEasObjects OBJECT IDENTIFIER ::= { ocStbHostSystem 3 }
+ocStbHostEasCodes   OBJECT IDENTIFIER ::= { ocStbHostEasObjects 1 }
+
+ocStbEasMessageStateCode OBJECT-TYPE
+   SYNTAX      Unsigned32 (0..99)
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           EAS State Code utilized by the STB. A
+           value of 0 indicates that the code is not
+           defined, thus the eSTB does not discriminate
+           any State Code defined in an EAS message."
+   REFERENCE
+           "SCTE-18"
+   ::= { ocStbHostEasCodes 1 }
+
+ocStbEasMessageCountyCode OBJECT-TYPE
+   SYNTAX      Unsigned32 (0..999)
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object allows the manager to retrieve the
+           EAS County Code utilized by the STB. A
+           value of 0 indicates that the code is not
+           defined, thus the eSTB ignores any County
+           Code defined in an EAS message."
+   REFERENCE
+           "SCTE-18"
+   ::= { ocStbHostEasCodes 2 }
+
+ocStbEasMessageCountySubdivisionCode OBJECT-TYPE
+    SYNTAX      Unsigned32 (0..9)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object allows the manager to retrieve the
+            EAS County Sub Code utilized by the STB. A
+            value of 0 indicates that the code is not
+            defined, thus the eSTB ignores it and any County
+            Subdivision Code defined in an EAS message is accepted."
+    REFERENCE
+            "SCTE-18"
+    ::= { ocStbHostEasCodes 3}
+
+--
+-- STB security subsystem
+--
+
+ocStbHostSecuritySubSystem OBJECT IDENTIFIER ::= { ocStbHostMibObjects 2 }
+
+ocStbHostSecurityIdentifier OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      deprecated
+    DESCRIPTION
+            "The security identifier of the ocStbHost.
+            This object represents the 40-bit Host_ID
+            obtained from the Host x509 certificate."
+    ::= { ocStbHostSecuritySubSystem 2 }
+
+ocStbHostCASystemIdentifier OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "Conditional access system identifier defined by DVB
+            and MPEG. This object represents the 16-bit CA_system_id
+            obtained from the ca_info_reply apdu. Only the first CAS ID
+            value (16-bits) from ca_info()will be reported."
+    ::= { ocStbHostSecuritySubSystem 3 }
+
+ocStbHostCAType OBJECT-TYPE
+    SYNTAX      INTEGER {
+                other(1),
+                embedded(2),
+                cablecard(3),
+                dcas(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The Conditional Access (CA) supported by
+            the host device.
+            'other' means a CA which is not described by one of
+            the other enumerations in this list.
+            'embedded' means a vendor-specific embedded CA
+            'cablecard' means OpenCable CableCARD is supported.
+            'dcas' means software downloadable CA is
+            supported."
+    ::= { ocStbHostSecuritySubSystem 4 }
+
+--
+-- STB Host Software objects
+--
+
+ocStbHostSoftware OBJECT IDENTIFIER ::= { ocStbHostMibObjects 3 }
+
+--
+-- ocStbHost device Software Requirements
+--
+
+ocStbHostDeviceSoftwareBase OBJECT IDENTIFIER ::=
+                                              { ocStbHostSoftware 1 }
+ocStbHostFirmwareDownloadStatus OBJECT IDENTIFIER ::=
+                                              { ocStbHostSoftware 2 }
+ocStbHostSoftwareApplicationInfo OBJECT IDENTIFIER ::=
+                                              { ocStbHostSoftware 3 }
+
+--
+-- Software versions
+--
+
+ocStbHostSoftwareFirmwareVersion OBJECT-TYPE
+   SYNTAX       SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+            "The platform code software version currently operating in
+            this device. This object should be in the syntax used by
+            the individual vendor to identify software versions. The
+            device must return a string descriptive of the current
+            software load. This object is shared with
+            docsDevSwCurrentVers."
+   ::= { ocStbHostDeviceSoftwareBase 1 }
+
+ocStbHostSoftwareOCAPVersion OBJECT-TYPE
+   SYNTAX       SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+            "This object returns a string indicating the latest version
+            of the OCAP profile supported by this device, e.g., '1.0'."
+   ::= { ocStbHostDeviceSoftwareBase 2 }
+
+ocStbHostSoftwareFirmwareReleaseDate OBJECT-TYPE
+   SYNTAX       DateAndTime
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+            "This object returns release date of this entire firmware
+            image (the stack OS). The local time fields should be
+            set to zero and the timezone information omitted."
+   ::= { ocStbHostDeviceSoftwareBase 3 }
+
+--
+-- Firmware Download Status
+--
+
+ocStbHostFirmwareImageStatus OBJECT-TYPE
+   SYNTAX       INTEGER
+                {
+                imageAuthorized(1),
+                imageCorrupted(2),
+                imageCertFailure(3),
+                imageMaxDownloadRetry(4),
+                imageMaxRebootRetry(5)
+                }
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+            "This object details the image status recently downloaded
+            'imageAuthorized' means the image is valid.
+            'imageCorrupted' means the image is invalid.
+            'imageCertFailure' means CVC authentication has failed.
+            'imageMaxDownloadRetry' means the maximum number of code
+           file download retries has been reached. When the value of
+           this object is imageMaxDownloadRetry(4), the value of
+           ocStbHostSoftwareCodeDownloadStatus must be
+           downloadingFailed(3).
+           'imageMaxRebootRetry' means the maximum number of reboots
+           has occurred after code file download."
+    ::= { ocStbHostFirmwareDownloadStatus 1 }
+
+ocStbHostFirmwareCodeDownloadStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                downloadingStarted(1),
+                downloadingComplete(2),
+                downloadingFailed(3),
+                other(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This object details the download status
+           of the target image.
+           'downloadingComplete' means the image download was
+           successful.
+           'downloadingFailed' means the image download failed.
+           'other' means a status not described by the other
+           enumerations."
+    ::= { ocStbHostFirmwareDownloadStatus 2 }
+
+ocStbHostFirmwareCodeObjectName OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The file name of the software image to be loaded into this
+           device. This object value may optionally contain server
+           and path information about the file name when applicable.
+           If unknown, the string '(unknown)' is returned. This
+           object is shared with docsDevSwFilename."
+    ::= { ocStbHostFirmwareDownloadStatus 3 }
+
+ocStbHostFirmwareDownloadFailedStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                cdlError1(1),
+                cdlError2(2),
+                cdlError3(3),
+                cdlError4(4),
+                cdlError5(5),
+                cdlError6(6),
+                cdlError7(7),
+                cdlError8(8),
+                cdlError9(9),
+                cdlError10(10),
+                cdlError11(11),
+                cdlError12(12),
+                cdlError13(13),
+                cdlError14(14),
+                cdlError15(15),
+                cdlError16(16),
+                cdlError17(17),
+                cdlError18(18),
+                cdlError19(19),
+                cdlError20(20),
+                cdlError21(21),
+                cdlError22(22),
+                cdlError23(23),
+                cdlError24(24),
+              cdlError25(25)
+              }
+   MAX-ACCESS read-only
+   STATUS     current
+   DESCRIPTION
+           "This object details the firmware download
+           failed status codes.
+
+           cdlError1, No Failure
+           cdlError2, Improper code file controls - CVC subject
+              organizationName for manufacturer does not match the
+              Host device manufacturer name
+           cdlError3, Improper code file controls - CVC subject
+              organizationName for code cosigning agent does not
+              match the Host device current code cosigning agent.
+           cdlError4, Improper code file controls - The
+              manufacturer's PKCS #7 signingTime value is equal-to
+              or less-than the codeAccessStart value currently held
+              in the Host device.
+           cdlError5, Improper code file controls - The
+              manufacturer's PKCS #7 validity start time value is
+              less-than the cvcAccessStart value currently held in
+              the Host device.
+           cdlError6, Improper code file controls - The manufacturer's
+              CVC validity start time is less-than the cvcAccessStart
+              value currently held in the Host device.
+           cdlError7, Improper code file controls - The manufacturer's
+              PKCS #7 signingTime value is less-than the CVC validity
+              start time.
+           cdlError8, Improper code file controls - Missing or
+              improper extendedKeyUsage extension in the
+              manufacturer CVC.
+           cdlError9, Improper code file controls - The cosigner's
+              PKCS #7 signingTime value is equal-to or less-than the
+              codeAccessStart value currently held in the
+              Host device.
+           cdlError10, Improper code file controls - The cosigner's
+              PKCS #7 validity start time value is less-than the
+              cvcAccessStart value currently held in the Host device.
+           cdlError11, Improper code file controls - The cosigner's
+              CVC validity start time is less-than the cvcAccessStart
+              value currently held in the Host device.
+           cdlError12, Improper code file controls - The cosigner's
+              PKCS #7 signingTime value is less-than the CVC validity
+              start time.
+           cdlError13, Improper code file controls - Missing or
+              improper extended key-usage extension in the cosigner's
+              CVC.
+           cdlError14, Code file manufacturer CVC validation failure.
+           cdlError15, Code file manufacturer CVS validation failure.
+           cdlError16, Code file cosigner CVC validation failure.
+           cdlError17, Code file cosigner CVS validation failure.
+           cdlError18, Improper eCM configuration file CVC format
+              (e.g., missing or improper key usage attribute).
+           cdlError19, eCM configuration file CVC validation failure.
+           cdlError20, Improper SNMP CVC format.
+           cdlError21, CVC subject organizationName for manufacturer
+              does not match the Host devices manufacturer name.
+           cdlError22, CVC subject organizationName for code cosigning
+              agent does not match the Host devices current code
+              cosigning agent.
+           cdlError23, The CVC validity start time is less-than or
+              equal-to the corresponding subject's cvcAccessStart
+              value currently held in the Host device.
+           cdlError24, Missing or improper key usage attribute.
+           cdlError25, SNMP CVC validation failure."
+   ::= { ocStbHostFirmwareDownloadStatus 4 }
+
+ocStbHostFirmwareDownloadFailedCount OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "This object details the number of times the product
+            attempted to download the firmware object defined by
+            ocStbHostFirmwareCodeObjectName. The value is reset when
+            the product attempts to download a new firmware object."
+    ::= { ocStbHostFirmwareDownloadStatus 5 }
+
+ocStbHostSoftwareApplicationInfoTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostSoftwareApplicationInfoEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "This table allows the manager to display and retrieve
+            self-diagnostic software information of all available
+            applications."
+    ::= { ocStbHostSoftwareApplicationInfo 1 }
+
+ocStbHostSoftwareApplicationInfoEntry OBJECT-TYPE
+    SYNTAX      OcStbHostSoftwareApplicationInfoEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "An entry exists for each available application."
+    INDEX { ocStbHostSoftwareApplicationInfoIndex }
+    ::= { ocStbHostSoftwareApplicationInfoTable 1 }
+
+OcStbHostSoftwareApplicationInfoEntry ::= SEQUENCE {
+        ocStbHostSoftwareAppNameString          SnmpAdminString,
+        ocStbHostSoftwareAppVersionNumber       SnmpAdminString,
+        ocStbHostSoftwareStatus                 INTEGER,
+        ocStbHostSoftwareApplicationInfoIndex Unsigned32,
+        ocStbHostSoftwareOrganizationId         OCTET STRING,
+        ocStbHostSoftwareApplicationId          OCTET STRING,
+        ocStbHostSoftwareApplicationSigStatus INTEGER
+        }
+
+ocStbHostSoftwareAppNameString OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The application's name string."
+    ::= { ocStbHostSoftwareApplicationInfoEntry 1 }
+
+ocStbHostSoftwareAppVersionNumber OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The application's version number."
+    ::= { ocStbHostSoftwareApplicationInfoEntry 2 }
+
+ocStbHostSoftwareStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                loaded(4),
+                notLoaded(5),
+                paused(6),
+                running(7),
+                destroyed(8)
+                }
+    MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The software status of the application."
+   ::= { ocStbHostSoftwareApplicationInfoEntry 3 }
+
+ocStbHostSoftwareApplicationInfoIndex OBJECT-TYPE
+   SYNTAX      Unsigned32 (1..4294967295)
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "Table Index added in this position (4) because it
+           replaced an external index."
+   ::= { ocStbHostSoftwareApplicationInfoEntry 4 }
+
+ocStbHostSoftwareOrganizationId OBJECT-TYPE
+   SYNTAX      OCTET STRING (SIZE(4))
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Organization ID captured in the XAIT or AIT."
+   ::= { ocStbHostSoftwareApplicationInfoEntry 5 }
+
+ocStbHostSoftwareApplicationId OBJECT-TYPE
+   SYNTAX      OCTET STRING (SIZE(2))
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This 16 bit field uniquely identifies the
+           application function as assigned by the
+           responsible/owning organization identified in
+           ocStbHostSoftwareOrganizationId."
+   ::= { ocStbHostSoftwareApplicationInfoEntry 6 }
+
+ocStbHostSoftwareApplicationSigStatus OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               other(0),
+               okay(1),
+               error(2)
+               }
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "This field has been replaced by the leaf objects
+           ocStbHostSoftwareApplicationInfoSigLastReceivedTime and
+           ocStbHostSoftwareApplicationInfoSigLastReadStatus."
+   ::= { ocStbHostSoftwareApplicationInfoEntry 7 }
+
+ocStbHostSoftwareApplicationInfoSigLastReceivedTime OBJECT-TYPE
+   SYNTAX      DateAndTime
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Indicates the last time an XAIT was received. If the host
+           device has not received an XAIT, then this returns a date
+           and time of all zeros."
+   ::= { ocStbHostSoftwareApplicationInfo 2 }
+
+ocStbHostSoftwareApplicationInfoSigLastReadStatus OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               unknown(0),
+               okay(1),
+               error(2)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+    DESCRIPTION
+           "Indicates the status of the last attempted read of the
+           XAIT. Reports unknown(0) if no XAIT has been received."
+    ::= { ocStbHostSoftwareApplicationInfo 3 }
+
+--
+-- ocStbHost Status Information
+--
+
+ocStbHostStatus OBJECT IDENTIFIER ::= { ocStbHostMibObjects 4 }
+
+--
+-- Host Power resources
+--
+
+ocStbHostPower OBJECT IDENTIFIER ::= { ocStbHostStatus 1 }
+
+ocStbHostPowerStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                powerOn(1),
+                standby(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Indicates the current power status of the ocStbHost."
+    ::= { ocStbHostPower 1 }
+
+ocStbHostAcOutletStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                unSwitched(1),
+                switchedOn(2),
+                switchedOff(3),
+                notInstalled(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Indicates the AC accessory power outlet status of the
+           ocStbHost.
+           'unSwitched'
+           Indicates AC accessory power outlet is present and provides
+           power as long as the ocStbHost is connected to a powered AC
+           outlet.
+           'switchedOn'
+           Indicates the AC accessory power outlet is currently
+           switched to ON and provides power as long as the value of
+           ocStbHostPowerStatus is 'powerOn'.
+           'switchedOff'
+           Indicates the AC accessory power outlet is currently
+           switched to OFF and does not provide power.
+           'notInstalled'
+           Indicates no AC accessory power outlet is present in the
+           ocStbHost."
+    ::= { ocStbHostPower 2 }
+
+--
+-- Host User settings
+--
+
+ocStbHostUserSettings OBJECT IDENTIFIER ::= { ocStbHostStatus 2 }
+
+ocStbHostUserSettingsPreferedLanguage OBJECT-TYPE
+    SYNTAX      DisplayString (SIZE(3))
+    MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The preferred language of the audio streams indicated
+           as the 3-octet code specified in ISO 639-2."
+   REFERENCE
+           "ISO 639.2 Codes for the Representation of Names of
+           Languages available at
+           http://www.loc.gov/standards/iso639-2/langhome.html."
+   ::= { ocStbHostUserSettings 1 }
+
+--
+-- Host system resources
+--
+
+ocStbHostSystemObjects OBJECT IDENTIFIER ::= { ocStbHostStatus 3 }
+
+
+ocStbHostSystemTempTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostSystemTempEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table contains the temperature sensors of the
+           ocStbHost."
+   ::= { ocStbHostSystemObjects 1 }
+
+ocStbHostSystemTempEntry OBJECT-TYPE
+   SYNTAX      OcStbHostSystemTempEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "Conceptual row of a temperature sensor device associated
+           with a Host Resource device (e.g. DVR) of the ocStbHost."
+   INDEX { hrDeviceIndex, ocStbHostSystemTempIndex }
+   ::= { ocStbHostSystemTempTable 1 }
+
+OcStbHostSystemTempEntry::= SEQUENCE {
+        ocStbHostSystemTempIndex       Unsigned32,
+        ocStbHostSystemTempDescr       SnmpAdminString,
+        ocStbHostSystemTempValue       Integer32,
+        ocStbHostSystemTempLastUpdate  TimeStamp,
+        ocStbHostSystemTempMaxValue    Integer32
+   }
+
+ocStbHostSystemTempIndex OBJECT-TYPE
+   SYNTAX      Unsigned32(1..4294967295)
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "The identifier of the temperature sensor for the
+           corresponding hrDeviceIdx."
+   ::= { ocStbHostSystemTempEntry 1 }
+
+ocStbHostSystemTempDescr OBJECT-TYPE
+   SYNTAX      SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The text containing information about the temperature
+           sensor."
+   ::= { ocStbHostSystemTempEntry 2 }
+
+ocStbHostSystemTempValue OBJECT-TYPE
+   SYNTAX      Integer32
+   UNITS       "celsius"
+   MAX-ACCESS read-only
+   STATUS      current
+    DESCRIPTION
+            "The temperature measured by the sensor.
+            If the temperature sensor does not report a
+            value, this object indicates a value of 0."
+    ::= { ocStbHostSystemTempEntry 3 }
+
+ocStbHostSystemTempLastUpdate OBJECT-TYPE
+    SYNTAX      TimeStamp
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The value of sysUpTime of the last time this value
+            was measured by the ocStbHost.
+            A value 0 means the temperature value is invalid."
+    ::= { ocStbHostSystemTempEntry 4 }
+
+ocStbHostSystemTempMaxValue OBJECT-TYPE
+    SYNTAX      Integer32
+    UNITS       "celsius"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The maximum temperature measured by the sensor.
+            If the temperature sensor does not report a
+            value, this object indicates a value of 0."
+    ::= { ocStbHostSystemTempEntry 5 }
+
+ocStbHostSystemHomeNetworkTable OBJECT-TYPE
+    SYNTAX      SEQUENCE OF OcStbHostSystemHomeNetworkEntry
+    MAX-ACCESS not-accessible
+    STATUS      deprecated
+    DESCRIPTION
+            "This table contains info about Home Network Clients
+            connected to the ocStbHost."
+    ::= { ocStbHostSystemObjects 2 }
+
+ocStbHostSystemHomeNetworkEntry OBJECT-TYPE
+    SYNTAX      OcStbHostSystemHomeNetworkEntry
+    MAX-ACCESS not-accessible
+    STATUS      deprecated
+    DESCRIPTION
+            "Conceptual row of a Home Network device ocStbHost
+            support/status."
+    INDEX { ocStbHostSystemHomeNetworkIndex }
+    ::= { ocStbHostSystemHomeNetworkTable 1 }
+
+OcStbHostSystemHomeNetworkEntry::= SEQUENCE {
+        ocStbHostSystemHomeNetworkIndex                Unsigned32,
+        ocStbHostSystemHomeNetworkMaxClients           Integer32,
+        ocStbHostSystemHomeNetworkHostDRMStatus        INTEGER,
+        ocStbHostSystemHomeNetworkConnectedClients     Integer32,
+        ocStbHostSystemHomeNetworkClientMacAddress     MacAddress,
+        ocStbHostSystemHomeNetworkClientIpAddress      InetAddress,
+        ocStbHostSystemHomeNetworkClientDRMStatus      Integer32
+        }
+
+ocStbHostSystemHomeNetworkIndex OBJECT-TYPE
+    SYNTAX      Unsigned32(1..4294967295)
+    MAX-ACCESS not-accessible
+    STATUS      deprecated
+    DESCRIPTION
+            "The identifier of the Home network Client connected
+            to the ocStbHost."
+    ::= { ocStbHostSystemHomeNetworkEntry 1 }
+
+ocStbHostSystemHomeNetworkMaxClients OBJECT-TYPE
+    SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "Maximum number of clients the Host can support.
+           NOTE: If the Host does not support home network clients,
+           then it SHALL report 0x00."
+   ::= { ocStbHostSystemHomeNetworkEntry 2 }
+
+ocStbHostSystemHomeNetworkHostDRMStatus OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               hostHasNoDrmCapability(1),
+               hostSupportsDrmButNotForHomeNetworkedClients(2),
+               hostSupportsDrmForItselfAndHomeNetworkedClients(3),
+               reserved(4)
+               }
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "The ocStbHost support for Digital Right Management (DRM)."
+   ::= { ocStbHostSystemHomeNetworkEntry 3 }
+
+ocStbHostSystemHomeNetworkConnectedClients OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "The number of Home Network Clients currently connected
+           to the ocStbHost."
+   ::= { ocStbHostSystemHomeNetworkEntry 4 }
+
+ocStbHostSystemHomeNetworkClientMacAddress OBJECT-TYPE
+   SYNTAX      MacAddress
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "The MAC address of Home Network Client."
+   ::= { ocStbHostSystemHomeNetworkEntry 5 }
+
+ocStbHostSystemHomeNetworkClientIpAddress OBJECT-TYPE
+   SYNTAX      InetAddress
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "The Ip address of Home Network Client."
+   ::= { ocStbHostSystemHomeNetworkEntry 6 }
+
+ocStbHostSystemHomeNetworkClientDRMStatus OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      deprecated
+   DESCRIPTION
+           "The Home Network Clients support for Digital
+           Rights Management (DRM)."
+   ::= { ocStbHostSystemHomeNetworkEntry 7 }
+
+ocStbHostSystemMemoryReportTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostSystemMemoryReportEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table contains the Id of each memory type
+           reported by the ocStbHost."
+   ::= { ocStbHostSystemObjects 3 }
+
+ocStbHostSystemMemoryReportEntry OBJECT-TYPE
+   SYNTAX      OcStbHostSystemMemoryReportEntry
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "Conceptual row of a memory type reported
+            by the ocStbHost."
+    INDEX { ocStbHostSystemMemoryReportIndex }
+    ::= { ocStbHostSystemMemoryReportTable 1 }
+
+OcStbHostSystemMemoryReportEntry::= SEQUENCE {
+        ocStbHostSystemMemoryReportIndex           Unsigned32,
+        ocStbHostSystemMemoryReportMemoryType      INTEGER,
+        ocStbHostSystemMemoryReportMemorySize      Integer32
+        }
+
+ocStbHostSystemMemoryReportIndex OBJECT-TYPE
+    SYNTAX      Unsigned32(1..4294967295)
+    MAX-ACCESS not-accessible
+    STATUS      current
+    DESCRIPTION
+            "The identifier of the memory type."
+    ::= { ocStbHostSystemMemoryReportEntry 1 }
+
+ocStbHostSystemMemoryReportMemoryType OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                rom(1),
+                dram(2),
+                sram(3),
+                flash(4),
+                nvm(5),
+                videomemory(7),
+                othermemory(8),
+                reserved(9),
+                internalHardDrive(10),
+                externalHardDrive(11),
+                opticalMedia(12)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "Designates the type of memory that is being reported."
+    ::= { ocStbHostSystemMemoryReportEntry 2 }
+
+ocStbHostSystemMemoryReportMemorySize OBJECT-TYPE
+    SYNTAX      Integer32
+    UNITS       "kilobytes"
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "Designates the physical size of the reported memory type.
+            The units are kilobytes, defined to be 1,024 bytes."
+    ::= { ocStbHostSystemMemoryReportEntry 3 }
+
+--
+-- Host and Card Information
+--
+
+ocStbCardInfo OBJECT IDENTIFIER ::= { ocStbHostStatus 4 }
+
+ocStbHostCardMacAddress OBJECT-TYPE
+    SYNTAX      MacAddress
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+            "The Mac Address associated with the Card."
+    ::= { ocStbCardInfo 1 }
+
+ocStbHostCardIpAddressType OBJECT-TYPE
+   SYNTAX      InetAddressType
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The network address Type of ocStbHostCardIpAddress.
+           If the Host does not have the Card's IP address (e.g.,
+           the Card has not opened an IP Unicast Flow, which would
+           require the Host to obtain the Card's IP address, thus
+           providing the Host with knowledge of the Card's IP address
+           type), then the Host replies with a value of unknown (0)."
+   ::= { ocStbCardInfo 2 }
+
+ocStbHostCardIpAddress OBJECT-TYPE
+   SYNTAX      InetAddress
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The network address of the Card. If the Host does not
+           have the Card's IP address (e.g., the Card has not opened
+           an IP Unicast Flow, which would require the Host to obtain
+           the Card's IP address, thus providing the Host with
+           knowledge of the Card's IP address), then the Host replies
+           with a value of zero (00)."
+   ::= { ocStbCardInfo 3 }
+
+ocStbHostCCMMI OBJECT IDENTIFIER ::= { ocStbCardInfo 5 }
+
+ocStbHostCCApplications OBJECT IDENTIFIER ::= { ocStbHostCCMMI 1 }
+
+ocStbHostCCAppInfoTable OBJECT-TYPE
+   SYNTAX      SEQUENCE OF OcStbHostCCAppInfoEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "This table allows the manager to retrieve
+           the HTML pages for Card applications retrieved by the
+           Host using the Application Info resource."
+   ::= { ocStbHostCCApplications 1 }
+
+ocStbHostCCAppInfoEntry OBJECT-TYPE
+   SYNTAX      OcStbHostCCAppInfoEntry
+   MAX-ACCESS not-accessible
+   STATUS      current
+   DESCRIPTION
+           "The conceptual row for this table."
+   INDEX { ocStbHostCCApplicationType }
+   ::= { ocStbHostCCAppInfoTable 1 }
+
+OcStbHostCCAppInfoEntry ::=
+   SEQUENCE {
+            ocStbHostCCAppInfoIndex
+                Unsigned32,
+            ocStbHostCCApplicationType
+                Unsigned32,
+            ocStbHostCCApplicationName
+                SnmpAdminString,
+            ocStbHostCCApplicationVersion
+                Unsigned32,
+            ocStbHostCCAppInfoPage
+                OCTET STRING
+            }
+
+ocStbHostCCAppInfoIndex OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+    DESCRIPTION
+           "This object was the index for this table
+           in a previous version of the MIB.
+           Currently used only as a placeholder to
+           avoid changing OID values."
+    ::= { ocStbHostCCAppInfoEntry 1 }
+
+ocStbHostCCApplicationType OBJECT-TYPE
+    SYNTAX      Unsigned32(0..4294967295)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Index for this table.
+           Contains the application_type field
+           in the application_info_cnf() APDU."
+    ::= { ocStbHostCCAppInfoEntry 2 }
+
+ocStbHostCCApplicationName OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Contains the application name."
+    ::= { ocStbHostCCAppInfoEntry 3 }
+
+ocStbHostCCApplicationVersion OBJECT-TYPE
+    SYNTAX      Unsigned32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Contains the application version."
+    ::= { ocStbHostCCAppInfoEntry 4 }
+
+ocStbHostCCAppInfoPage OBJECT-TYPE
+    SYNTAX      OCTET STRING
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "All HTML data for this application.
+           If a 'page' as reported from the Card contains
+           links, the links shall be traversed, and all
+           HTML from each page traversed shall be included
+           in a single, valid HTML string (with per-page
+           start/end HTML and BODY tags removed). The resulting
+           HTML SHOULD be structured as an HTML table
+           consisting of one column, with one row for each
+           'page' from the Card. If the full HTML from the
+           application (all pages concatenated) will not fit
+           within the SNMP buffer, text indicating this
+           SHALL follow the table; otherwise nothing except
+           the close BODY and HTML tags SHOULD follow the table."
+    ::= { ocStbHostCCAppInfoEntry 5 }
+
+ocStbHostSnmpProxyInfo OBJECT IDENTIFIER ::= { ocStbCardInfo 6 }
+
+ocStbHostCardMfgId OBJECT-TYPE
+    SYNTAX      OCTET STRING (SIZE(2))
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The two-byte manufacturer identifier
+           acquired from the CableCard. The high order byte
+           defines the manufacturer as follows.
+                00xx = Motorola
+                01xx = Cisco (Scientific-Atlanta)
+                02xx = NDS
+                03xx = Conax
+           This can be used with version and root OID to enable
+           SNMP access to proprietary CC diagnostic information.
+           The lower order octet can be used to privately identify
+           product generation and derivatives."
+   ::= { ocStbHostSnmpProxyInfo 1 }
+
+ocStbHostCardVersion OBJECT-TYPE
+   SYNTAX       OCTET STRING (SIZE (2))
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "The version of the CableCard. This can be used with
+           manufacturer and root OID to enable SNMP access to
+           proprietary diagnostic information."
+   ::= { ocStbHostSnmpProxyInfo 2 }
+
+ocStbHostCardRootOid OBJECT-TYPE
+   SYNTAX       OBJECT IDENTIFIER
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "An ASN.1 encoding of the root OID of the
+           CableCARD MIB defined in the CC Manufacturers private
+           MIB name space. This OID will be compared against each
+           object identifier in the VARBIND contained within the
+           GetRequests, GetNextRequests, GetBulkRequests, and
+           SetRequests received by the Host2.x if the objects are not
+           in the Host2.x MIB. A match of OIDs root requires the Host
+           to send a corresponding request to the Card. A 0.0 value
+           explicitly states the Card does not support SNMP message
+           processing."
+   ::= { ocStbHostSnmpProxyInfo 3 }
+
+ocStbHostCardSerialNumber OBJECT-TYPE
+   SYNTAX       SnmpAdminString
+   MAX-ACCESS read-only
+   STATUS       current
+   DESCRIPTION
+           "Serial Number of CableCARD."
+   ::= { ocStbHostSnmpProxyInfo 4 }
+
+ocStbHostCardSnmpAccessControl OBJECT-TYPE
+   SYNTAX       TruthValue
+   MAX-ACCESS read-write
+   STATUS       current
+   DESCRIPTION
+           "This object allows the manager to control access to the
+           Card's MIB via networked devices (e.g., get/set by network
+           attached managers). It has no impact on local
+           access (e.g., application get/set of Card MIB objects).
+
+           When set to TRUE, the Host is permitted to forward
+           SNMP messages received on the WAN/LAN interface addressed
+           to the OID of the Card subtree.
+
+           When set to FALSE, the Host must discard and not forward
+           to the Card any SNMP messages received on the WAN/LAN
+           interface addressed to the OID of the Card subtree.
+
+           Default of this object is TRUE."
+   DEFVAL { 1 }
+   ::= { ocStbHostSnmpProxyInfo 5 }
+
+ocStbHostCardId OBJECT-TYPE
+   SYNTAX       DisplayString (SIZE(17))
+   MAX-ACCESS read-only
+   STATUS       current
+    DESCRIPTION
+           "Allows the manager to retrieve the 40 least-significant
+           Bits of the CableCARD ID in the string
+           format indicated below:
+
+           M-MMU-UUU-UUU-UUL
+
+           Where:
+
+           M-MM is the decimal representation of the
+           10-bit CHICA assigned manufacturer number.
+
+           U-UUU-UUU-UU is the decimal representation
+           of the 30-bit manufacturer assigned unit number.
+
+           L is a Luhn check digit calculated over the
+           preceding 12 decimal digits.
+
+           If the Card ID is unknown, then the string shall
+           be all zeros e.g., '0-000-000-000-000'."
+    ::= { ocStbCardInfo 7 }
+
+ocStbHostCardBindingStatus OBJECT-TYPE
+    SYNTAX      INTEGER {
+                unknown(1),
+                invalidCertificate(2),
+                otherAuthFailure(3),
+                bound(4)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The status of CableCARD/Host mutual authentication
+           and binding.
+
+           `unknown' means the binding state has not been determined.
+                 For example, mutual authentication may not have
+                 commenced or may be in process.
+           `invalidCertificate' means the Host failed to establish
+                 device certificate authenticity.
+           `otherAuthFailure' corresponds to other failures in
+                 establishing mutual authentication.
+           `bound' indicates that mutual authentication has succeeded
+                 and CableCARD and Host are bound successfully."
+    ::= { ocStbCardInfo 8 }
+
+ocStbHostCardOpenedGenericResource OBJECT-TYPE
+    SYNTAX      OCTET STRING (SIZE (4))
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The hexadecimal representation of the generic feature
+           control resource number opened using a profile
+           reply() APDU resource_identifier field. The
+           possible values are defined in the [CCIF]
+           specification."
+    ::= { ocStbCardInfo 9 }
+
+ocStbHostCardTimeZoneOffset OBJECT-TYPE
+    SYNTAX      INTEGER(-12..12)
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Decimal value of the UTC offset taken from the
+           feature_parameters() APDU for feature_id =5 where
+           possible values are defined in the [CCIF]
+           specification."
+   ::= { ocStbCardInfo 10 }
+
+ocStbHostCardDaylightSavingsTimeDelta OBJECT-TYPE
+   SYNTAX      OCTET STRING (SIZE (1))
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Decimal value of the daylight savings delta.
+           A 0x00 should be returned if the Card does not
+           support this feature or if there is no delta.
+           The ambiguity may be resolved by querying
+           ocStbHostCardDaylightSavingsTimeEntry object."
+   ::= { ocStbCardInfo 11 }
+
+ocStbHostCardDaylightSavingsTimeEntry OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Daylight savings entry time given as time lapsed
+           since 12 AM Jan 6, 1980, in units of GPS seconds.
+           All zeros should be returned if the Card does not
+           support this feature."
+   ::= { ocStbCardInfo 12 }
+
+ocStbHostCardDaylightSavingsTimeExit OBJECT-TYPE
+   SYNTAX      Unsigned32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Daylight savings exit time given as time lapsed
+           since 12 AM Jan 6, 1980, in units of GPS seconds.
+           All zeros should be returned if the Card does not
+           support this feature."
+   ::= { ocStbCardInfo 13 }
+
+ocStbHostCardEaLocationCode OBJECT-TYPE
+   SYNTAX      OCTET STRING (SIZE(3))
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Contains the EA location codes as defined
+           in American National Standard, J-STD-042.
+           The bits corresponding to ANSI EA location codes
+           are indicated below:
+
+           SSSSSSSS-DDDD-xx-CCCCCCCCCC
+
+           Where:
+
+           SSSSSSSS is An 8-bit unsigned number in the
+           range 0 to 99 that represents the State or
+           Territory affected by the emergency alert.
+
+           DDDD is A 4-bit number in the range 0 to 9
+           that defines county subdivisions.
+
+           xx is reserved
+
+           CCCCCCCCCC is 10-bit number between 0 to 999
+           that identifies a county within a state.
+
+           If the EA_Location code is unknown, then the string shall
+           be all zeros e.g., '000000'."
+   ::= { ocStbCardInfo 14 }
+
+ocStbHostCardVctId OBJECT-TYPE
+    SYNTAX      OCTET STRING (SIZE(2))
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Display the VTC-ID if supported. If not supported
+           then return 0x0000."
+    ::= { ocStbCardInfo 15 }
+
+ocStbHostCardCpInfo OBJECT IDENTIFIER ::= { ocStbCardInfo 16 }
+
+ocStbHostCardCpAuthKeyStatus OBJECT-TYPE
+    SYNTAX      INTEGER {
+                ready(1),
+                notReady(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "This parameter SHALL be set to 'Ready' if the
+           Card has requested the host's authentication
+           key via the APDU CP_data_req() with a
+           Datatype_id = 22. This parameter SHALL be set
+           to 'Not Ready' if the Cablecard has NOT
+           requested the authentication key."
+    ::= { ocStbHostCardCpInfo 1 }
+
+ocStbHostCardCpCertificateCheck OBJECT-TYPE
+    SYNTAX      INTEGER {
+                ok(1),
+                failed(2)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Display the results of the Card_DevCert verification
+           as defined in the OpenCable CableCard Copy Protection
+           Specification."
+    ::= { ocStbHostCardCpInfo 2 }
+
+ocStbHostCardCpCciChallengeCount OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Display the Card CCI Challenge message
+           count [CCCP] since the
+           last boot or reset."
+    ::= { ocStbHostCardCpInfo 3 }
+
+ocStbHostCardCpKeyGenerationReqCount OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Display the Copy Protection Key Generation
+           Request count [CCCP] since
+           the last boot or reset."
+    ::= { ocStbHostCardCpInfo 4 }
+
+ocStbHostCardCpIdList OBJECT-TYPE
+    SYNTAX      OCTET STRING (SIZE(4))
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Display the CP_system_id_bitmask field of the
+           APDU CP_open_cnf() as defined in the CableCARD Copy
+           Protection Specification Section 11.3.1.2."
+   ::= { ocStbHostCardCpInfo 5 }
+
+ocStbHostInfo OBJECT IDENTIFIER ::= { ocStbHostStatus 5 }
+
+ocStbHostIpAddressType OBJECT-TYPE
+   SYNTAX      InetAddressType
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "This object was the address type for ocStbHostIpAddress,
+           which was never implemented in a previous version of the
+           MIB. Currently used only as a placeholder to avoid
+           changing OID values."
+   ::= { ocStbHostInfo 1 }
+
+ocStbHostIpSubNetMask OBJECT-TYPE
+   SYNTAX      InetAddress
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The IP subnet mask of the Host address."
+   ::= { ocStbHostInfo 2 }
+
+ocStbHostOobMessageMode OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               scte55(1),
+               dsg(2),
+               other(3)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Out of Band Messaging communications mode currently
+           employed by the Host2.x."
+   ::= { ocStbHostInfo 3 }
+
+ocStbHostDumpTrapInfo OBJECT IDENTIFIER ::= { ocStbHostInfo 4 }
+
+ocStbHostDumpEventCount OBJECT-TYPE
+   SYNTAX      INTEGER(0..32)
+   MAX-ACCESS read-write
+   STATUS      current
+   DESCRIPTION
+           "The number of times the host should notify the headend(s)
+           of a dump condition (e.g., stack dumps after boot).
+           When an exception occurs, if ocStbHostDumpEventCount is
+           non-zero, the host will send the notification to each
+           defined notification receiver and decrement
+           ocStbHostDumpEventCount. A non-zero count arms the trap.
+           No trap will be sent if the value is 0."
+   DEFVAL { 0 }
+   ::= { ocStbHostDumpTrapInfo 1 }
+
+ocStbHostDumpNow OBJECT-TYPE
+   SYNTAX      TruthValue
+   MAX-ACCESS read-write
+   STATUS      current
+   DESCRIPTION
+           "True(1) forces an immediate dump of a component of the
+           Host. The Host will prepare the dump file then send the
+           Notification-PDU to the headend. This simulates
+           the manufacturer-defined event that would cause a dump.
+           Reading this object returns false(2)."
+   ::= { ocStbHostDumpTrapInfo 2 }
+
+ocStbHostDumpEventTimeout OBJECT-TYPE
+    SYNTAX      Unsigned32(1..120)
+    MAX-ACCESS read-write
+    STATUS      current
+    DESCRIPTION
+           "The time, in seconds, after a SNMPv2-Trap-PDU as been sent
+           to the headend that the Host will wait before abandoning
+           the dump transfer. If the Host does not receive a TFTP Get
+           from the headend within this timeout period, it will
+           proceed with the manufacturer-defined recovery process
+           from the condition that caused the dump. The intent is to
+           prevent the Host from waiting indefinitely for a TFTP
+           session to enable the dump transfer. The timer should be
+           ignored if the Host receives a TFTP GET from the headend
+           within the timeout period. The default timeout value
+           is 5 seconds."
+    DEFVAL { 5 }
+    ::= { ocStbHostDumpTrapInfo 3 }
+
+ocStbHostDumpFilePath OBJECT-TYPE
+SYNTAX     SnmpAdminString
+MAX-ACCESS read-only
+STATUS     current
+DESCRIPTION
+        "Dump file path and name."
+    ::= { ocStbHostDumpTrapInfo 4 }
+
+ocStbHostSpecificationsInfo OBJECT IDENTIFIER ::= { ocStbHostInfo 5 }
+
+ocStbHostCfrSpecificationIssue OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The Host CFR version implemented in this
+           device (e.g., OC-SP-HOST2.1-CFR-I06-081114)."
+    ::= { ocStbHostSpecificationsInfo 1 }
+
+ocStbHostMibSpecificationIssue OBJECT-TYPE
+    SYNTAX      SnmpAdminString
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "The version implemented in this device
+           (e.g., OC-SP-MIB-HOST2.X-I05-081114)."
+    ::= { ocStbHostSpecificationsInfo 2 }
+
+ocStbHostBootStatus OBJECT-TYPE
+    SYNTAX      INTEGER
+                {
+                completedSuccessfully(1),
+                completeWithErrors(2),
+                inProgressWithCodeDownload(3),
+                inProgressNoCodeDownload(4),
+                inProgressAwaitingMonitorApp(5),
+                unknown(6)
+                }
+    MAX-ACCESS read-only
+    STATUS      current
+    DESCRIPTION
+           "Defines the current status of the host during or after
+           boot process."
+    ::= { ocStbHostInfo 6 }
+
+ocStbHostContentErrorSummaryInfo OBJECT IDENTIFIER ::= { ocStbHostInfo 7 }
+
+ocStbHostPatTimeoutCount OBJECT-TYPE
+    SYNTAX      Counter32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "These values increment every time a PAT timeout
+           condition has occurred since the last boot or reset."
+   ::= { ocStbHostContentErrorSummaryInfo 1 }
+
+ocStbHostPmtTimeoutCount OBJECT-TYPE
+   SYNTAX      Counter32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "These values increment every time a PMT timeout
+           condition has occurred since the last boot or reset."
+   ::= { ocStbHostContentErrorSummaryInfo 2 }
+
+ocStbHostOobCarouselTimeoutCount OBJECT-TYPE
+   SYNTAX      Counter32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "These values increment each time an implementation
+           specific OOB Carousel timeout has occurred since the last
+           boot or reset."
+   ::= { ocStbHostContentErrorSummaryInfo 3 }
+
+ocStbHostInbandCarouselTimeoutCount OBJECT-TYPE
+   SYNTAX      Counter32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "These values increment each time an implementation
+           specific Inband Carousel timeout has occurred since the
+           last boot or reset."
+   ::= { ocStbHostContentErrorSummaryInfo 4 }
+
+ocStbHostRebootInfo OBJECT IDENTIFIER ::= { ocStbHostStatus 6 }
+
+ocStbHostRebootType OBJECT-TYPE
+   SYNTAX      INTEGER
+               {
+               unknown(0),
+               davicDocsis(1),
+               user(2),
+               system(3),
+               trap(4),
+               silentWatchdog(5),
+               bootloader(6),
+               powerup(7),
+               hostUpgrade(8),
+               hardware(9),
+               cablecardError(10)
+               }
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "Describes the type of reboot that occurred the last time
+           the host device rebooted.
+
+           Unknown(0), unknown reboot. 0 is used as a sentinel value
+           to denote that the reboot reporting mechanism is
+           initialized and ready for use. If it appears in a reboot
+           report as a reboot reason, it means that something
+           (of unknown cause) prevented a reboot reason from being
+           saved. This is a spontaneous reboot.
+
+           Davic/DOCSIS(1), Davic/DOCSIS switch. The set-top rebooted
+           because the network switched from Davic to DOCSIS or
+           vice versa. This is a controlled reboot.
+
+           User(2), User reboot. The set-top rebooted at the specific
+           request of the user, typically the MSO, but can also be the
+           subscriber. Includes, but not limited to, headend-initiated
+           reboots, pass-thru and SNMP messages to reboot, new
+           application versions that require a reboot in order to
+           reload, the staging toolkit, hard disk re-format requests,
+           CableCARD inserted or firmware upgrade, and more.
+           This is a controlled reboot.
+
+           System(3), System reboot. The set-top rebooted because its
+           software determined it cannot continue operation. This can
+           be due to any number of reasons, including: detection of
+           logic errors, exhaustion of various system resources,
+           detection of memory corruption, and more. This is a
+           spontaneous reboot.
+
+           Trap(4), Trap reboot. A fatal error detected by the CPU.
+           This varies between CPU manufacturers; some possible causes
+           are illegal address references, misaligned instruction or
+           data access, memory protection violations, attempt to
+           decode an unrecognized instruction, etc. This is a
+           spontaneous reboot.
+
+           Silent or Watchdog(5). Depending on platform, this is
+           either a Silent Reboot (A reboot of unknown origin that
+           reports no information) or a Watchdog reboot. This is a
+           spontaneous reboot.
+
+           Bootloader(6), Bootloader reboot. For use by bootloader
+           software. This is a spontaneous reboot.
+
+           PowerUp(7), Power-up reboot. The set-top rebooted because
+           power was lost and then restored. This is a controlled
+           reboot.
+
+           Upgrade(8), Upgrade Reboot due to loading new resident
+           set-top software. This is a controlled reboot.
+
+           Hardware(9), Hardware Reset reboot. This depends on the
+           design of a particular set-top. It might be due to a
+           hardware reset line being triggered or by a button push of
+           some kind. Manufacturers sometimes provide a way to
+           hard reset a box besides removing power. This is a
+           spontaneous reboot.
+
+           CablecardError(10), CablecardError. The Host rebooted
+           because the communication with the CableCARD was lost and
+           could not be reestablished."
+     ::= { ocStbHostRebootInfo 1 }
+
+ocStbHostRebootReset OBJECT-TYPE
+    SYNTAX      TruthValue
+    MAX-ACCESS read-write
+    STATUS      current
+    DESCRIPTION
+           "Setting this object to true(1) causes the device to reset,
+           equivalent to a power reset. Reading this object always
+           returns false(2)."
+    ::= { ocStbHostRebootInfo 2 }
+
+ocStbHostMemoryInfo OBJECT IDENTIFIER ::= { ocStbHostStatus 7 }
+
+ocStbHostLargestAvailableBlock OBJECT-TYPE
+    SYNTAX      Integer32
+   UNITS       "kilobytes"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The largest available continuous block of DRAM available
+           on the host device, in kilobytes."
+   ::= { ocStbHostMemoryInfo 1 }
+
+ocStbHostTotalVideoMemory OBJECT-TYPE
+   SYNTAX      Integer32
+   UNITS       "kilobytes"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The total amount of DRAM dedicated to video decoding and
+           display on the host device, in kilobytes."
+   ::= { ocStbHostMemoryInfo 2 }
+
+ocStbHostAvailableVideoMemory OBJECT-TYPE
+   SYNTAX      Integer32
+   UNITS       "kilobytes"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The total amount of DRAM dedicated to video decoding and
+           display on the host device that is not allocated and
+           available for use, in kilobytes."
+   ::= { ocStbHostMemoryInfo 3 }
+
+ocStbHostJVMInfo OBJECT IDENTIFIER ::= { ocStbHostStatus 8 }
+
+ocStbHostJVMHeapSize OBJECT-TYPE
+   SYNTAX      Integer32
+   UNITS       "kilobytes"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The total amount of DRAM allocated to the Java Virtual
+           Machine heap. The units are kilobytes, defined to be
+           1,024 bytes."
+   ::= { ocStbHostJVMInfo 1 }
+
+ocStbHostJVMAvailHeap OBJECT-TYPE
+   SYNTAX      Integer32
+   UNITS       "kilobytes"
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The amount of DRAM in the Java Virtual Machine heap that
+           is not allocated and is available for use.
+           The units are kilobytes, defined to be 1,024 bytes."
+   ::= { ocStbHostJVMInfo 2 }
+
+ocStbHostJVMLiveObjects OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The number of active object instances in the Java Virtual
+           Machine that are reachable from running code."
+   ::= { ocStbHostJVMInfo 3 }
+
+ocStbHostJVMDeadObjects OBJECT-TYPE
+   SYNTAX      Integer32
+   MAX-ACCESS read-only
+   STATUS      current
+   DESCRIPTION
+           "The number of object instances in the Java Virtual Machine
+           that are NOT reachable from running Code."
+    ::= { ocStbHostJVMInfo 4 }
+
+-- Conformance information
+
+ocStbHostConformance OBJECT IDENTIFIER ::= { ocStbHostMibModule 2 }
+ocStbHostMIBCompliances OBJECT IDENTIFIER ::= { ocStbHostConformance 1 }
+ocStbHostMIBGroups OBJECT IDENTIFIER ::= { ocStbHostConformance 2 }
+
+-- Compliance statements
+
+ocStbHostMIBCompliance MODULE-COMPLIANCE
+    STATUS      current
+    DESCRIPTION
+           "The requirements for conformance to the OpenCable
+           Set-top HOST MIB."
+    MODULE -- this module
+    MANDATORY-GROUPS {
+                      ocStbHostSystemGroup,
+                      ocStbHostSoftwareGroup,
+                      ocStbHostStatusGroup,
+                      ocStbHostSecuritySubSystemGroup
+                      }
+    OBJECT ocStbHostSystemMemoryReportMemoryType
+    DESCRIPTION
+           "Retired values internalHardDriveNoDrmSupport(6)."
+
+    OBJECT ocStbHostSoftwareStatus
+    DESCRIPTION
+           "Retired values replaced by more
+           descriptive values:
+              active(1),
+              inactive(2),
+              downloading(3)."
+    ::= { ocStbHostMIBCompliances 1 }
+
+ocStbHostSystemGroup OBJECT-GROUP
+    OBJECTS     {
+                ocStbHostSerialNumber,
+                ocStbHostHostID,
+                ocStbHostCapabilities,
+                ocStbHostAvcSupport,
+                ocStbHostAVInterfaceType,
+                ocStbHostAVInterfaceDesc,
+                ocStbHostAVInterfaceStatus,
+                ocStbHostInBandTunerModulationMode,
+                ocStbHostInBandTunerFrequency,
+                ocStbHostInBandTunerInterleaver,
+                ocStbHostInBandTunerPower,
+                ocStbHostInBandTunerAGCValue,
+                ocStbHostInBandTunerSNRValue,
+                ocStbHostInBandTunerUnerroreds,
+                ocStbHostInBandTunerCorrecteds,
+                ocStbHostInBandTunerUncorrectables,
+                ocStbHostInBandTunerCarrierLockLost,
+                ocStbHostInBandTunerPCRErrors,
+                ocStbHostInBandTunerPTSErrors,
+                ocStbHostInBandTunerState,
+                ocStbHostInBandTunerBER,
+                ocStbHostInBandTunerSecsSinceLock,
+                ocStbHostInBandTunerEqGain,
+                ocStbHostInBandTunerMainTapCoeff,
+                ocStbHostInBandTunerTotalTuneCount,
+                ocStbHostInBandTunerTuneFailureCount,
+                ocStbHostInBandTunerTuneFailFreq,
+                ocStbHostInBandTunerBandwidth,
+              ocStbHostIEEE1394ActiveNodes,
+              ocStbHostIEEE1394DataXMission,
+              ocStbHostIEEE1394DTCPStatus,
+              ocStbHostIEEE1394LoopStatus,
+              ocStbHostIEEE1394RootStatus,
+              ocStbHostIEEE1394CycleIsMaster,
+              ocStbHostIEEE1394IRMStatus,
+              ocStbHostIEEE1394AudioMuteStatus,
+              ocStbHostIEEE1394VideoMuteStatus,
+              ocStbHostIEEE1394ConnectedDevicesAVInterfaceIndex,
+              ocStbHostIEEE1394ConnectedDevicesSubUnitType,
+              ocStbHostIEEE1394ConnectedDevicesEui64,
+              ocStbHostIEEE1394ConnectedDevicesADSourceSelectSupport,
+              ocStbHostDVIHDMIOutputType,
+              ocStbHostDVIHDMIConnectionStatus,
+              ocStbHostDVIHDMIRepeaterStatus,
+              ocStbHostDVIHDMIVideoXmissionStatus,
+              ocStbHostDVIHDMIHDCPStatus,
+              ocStbHostDVIHDMIHostDeviceHDCPStatus,
+              ocStbHostDVIHDMIVideoMuteStatus,
+              ocStbHostDVIHDMIOutputFormat,
+              ocStbHostDVIHDMIAspectRatio,
+              ocStbHostDVIHDMIAudioFormat,
+              ocStbHostDVIHDMIAudioSampleRate,
+              ocStbHostDVIHDMIAudioChannelCount,
+              ocStbHostDVIHDMIAudioMuteStatus,
+              ocStbHostDVIHDMIAudioSampleSize,
+              ocStbHostDVIHDMIColorSpace,
+              ocStbHostDVIHDMIFrameRate,
+              ocStbHostDVIHDMIAttachedDeviceType,
+              ocStbHostDVIHDMIEdid,
+              ocStbHostDVIHDMILipSyncDelay,
+              ocStbHostDVIHDMICecFeatures,
+              ocStbHostDVIHDMIFeatures,
+              ocStbHostDVIHDMIMaxDeviceCount,
+              ocStbHostDVIHDMIEdidVersion,
+              ocStbHostDVIHDMIPreferredVideoFormat,
+              ocStbHostDVIHDMIAvailableVideoFormat,
+              ocStbHostSPDIfAudioFormat,
+              ocStbHostSPDIfAudioMuteStatus,
+              ocStbHostComponentVideoConstrainedStatus,
+              ocStbHostComponentOutputFormat,
+              ocStbHostComponentAspectRatio,
+              ocStbHostComponentVideoMuteStatus,
+              ocStbHostRFChannelOut,
+              ocStbHostRFChannelOutAudioMuteStatus,
+              ocStbHostRFChannelOutVideoMuteStatus,
+              ocStbEasMessageStateCode,
+              ocStbEasMessageCountyCode,
+              ocStbEasMessageCountySubdivisionCode,
+              ocStbHostProgramAVSource,
+              ocStbHostProgramAVDestination,
+              ocStbHostProgramContentSource,
+              ocStbHostProgramContentDestination,
+              ocStbHostMpeg2ContentProgramNumber,
+              ocStbHostMpeg2ContentTransportStreamID,
+              ocStbHostMpeg2ContentTotalStreams,
+              ocStbHostMpeg2ContentSelectedVideoPID,
+              ocStbHostMpeg2ContentSelectedAudioPID,
+              ocStbHostMpeg2ContentOtherAudioPIDs,
+              ocStbHostMpeg2ContentCCIValue,
+              ocStbHostMpeg2ContentAPSValue,
+              ocStbHostMpeg2ContentCITStatus,
+              ocStbHostMpeg2ContentBroadcastFlagStatus,
+              ocStbHostMpeg2ContentEPNStatus,
+              ocStbHostMpeg2ContentPCRPID,
+              ocStbHostMpeg2ContentPCRLockStatus,
+                ocStbHostMpeg2ContentDecoderPTS,
+                ocStbHostMpeg2ContentDiscontinuities,
+                ocStbHostMpeg2ContentPktErrors,
+                ocStbHostMpeg2ContentPipelineErrors,
+                ocStbHostMpeg2ContentDecoderRestarts,
+                ocStbHostQpskFDCFreq,
+                ocStbHostQpskRDCFreq,
+                ocStbHostQpskFDCBer,
+                ocStbHostQpskFDCStatus,
+                ocStbHostQpskFDCBytesRead,
+                ocStbHostQpskFDCPower,
+                ocStbHostQpskFDCLockedTime,
+                ocStbHostQpskFDCSNR,
+                ocStbHostQpskAGC,
+                ocStbHostQpskRDCPower,
+                ocStbHostQpskRDCDataRate,
+                ocStbHostAnalogVideoProtectionStatus
+                }
+    STATUS      current
+    DESCRIPTION
+           "Defines the objects contained with the ocStbHost System
+           Group."
+    ::= { ocStbHostMIBGroups 1 }
+
+ocStbHostSoftwareGroup OBJECT-GROUP
+    OBJECTS      {
+                 ocStbHostFirmwareImageStatus,
+                 ocStbHostFirmwareCodeDownloadStatus,
+                 ocStbHostFirmwareCodeObjectName,
+                 ocStbHostFirmwareDownloadFailedStatus,
+                 ocStbHostFirmwareDownloadFailedCount,
+                 ocStbHostSoftwareOCAPVersion,
+                 ocStbHostSoftwareFirmwareReleaseDate,
+                 ocStbHostSoftwareAppNameString,
+                 ocStbHostSoftwareAppVersionNumber,
+                 ocStbHostCCAppInfoIndex,
+                 ocStbHostSoftwareFirmwareVersion,
+                 ocStbHostCCApplicationName,
+                 ocStbHostCCApplicationVersion,
+                 ocStbHostSoftwareStatus,
+                 ocStbHostSoftwareOrganizationId,
+                 ocStbHostSoftwareApplicationId,
+                 ocStbHostSoftwareApplicationInfoSigLastReceivedTime,
+                 ocStbHostSoftwareApplicationInfoSigLastReadStatus
+                 }
+    STATUS      current
+    DESCRIPTION
+           "The ocStbHost Software group."
+    ::= { ocStbHostMIBGroups 2 }
+
+ocStbHostStatusGroup OBJECT-GROUP
+    OBJECTS      {
+                 ocStbHostPowerStatus,
+                 ocStbHostAcOutletStatus,
+                 ocStbHostUserSettingsPreferedLanguage,
+                 ocStbHostSystemTempDescr,
+                 ocStbHostSystemTempValue,
+                 ocStbHostSystemTempLastUpdate,
+                 ocStbHostSystemTempMaxValue,
+                 ocStbHostSystemMemoryReportMemoryType,
+                 ocStbHostSystemMemoryReportMemorySize,
+                 ocStbHostCardMacAddress,
+                 ocStbHostCardIpAddressType,
+                 ocStbHostCardIpAddress,
+                 ocStbHostCCApplicationType,
+                 ocStbHostCCAppInfoPage,
+                 ocStbHostCardMfgId,
+                ocStbHostCardVersion,
+                ocStbHostCardRootOid,
+                ocStbHostCardSnmpAccessControl,
+                ocStbHostCfrSpecificationIssue,
+                ocStbHostMibSpecificationIssue,
+                ocStbHostPatTimeoutCount,
+                ocStbHostPmtTimeoutCount,
+                ocStbHostOobCarouselTimeoutCount,
+                ocStbHostInbandCarouselTimeoutCount,
+                ocStbHostCardSerialNumber,
+                ocStbHostCardId,
+                ocStbHostCardBindingStatus,
+                ocStbHostCardOpenedGenericResource,
+                ocStbHostCardTimeZoneOffset,
+                ocStbHostCardDaylightSavingsTimeDelta,
+                ocStbHostCardDaylightSavingsTimeEntry,
+                ocStbHostCardDaylightSavingsTimeExit,
+                ocStbHostCardEaLocationCode,
+                ocStbHostCardVctId,
+                ocStbHostCardCpAuthKeyStatus,
+                ocStbHostCardCpCertificateCheck,
+                ocStbHostCardCpCciChallengeCount,
+                ocStbHostCardCpKeyGenerationReqCount,
+                ocStbHostCardCpIdList,
+                ocStbHostIpAddressType,
+                ocStbHostIpSubNetMask,
+                ocStbHostOobMessageMode,
+                ocStbHostBootStatus,
+                ocStbHostDumpEventCount,
+                ocStbHostDumpNow,
+                ocStbHostDumpEventTimeout,
+                ocStbHostDumpFilePath,
+                ocStbHostRebootType,
+                ocStbHostRebootReset,
+                ocStbHostLargestAvailableBlock,
+                ocStbHostTotalVideoMemory,
+                ocStbHostAvailableVideoMemory,
+                ocStbHostJVMHeapSize,
+                ocStbHostJVMAvailHeap,
+                ocStbHostJVMLiveObjects,
+                ocStbHostJVMDeadObjects
+                }
+   STATUS      current
+   DESCRIPTION
+           "The object group related to multiple ocStbHost status."
+   ::= { ocStbHostMIBGroups 3 }
+
+ocStbHostSecuritySubSystemGroup OBJECT-GROUP
+   OBJECTS      {
+                ocStbHostCASystemIdentifier,
+                ocStbHostCAType
+                }
+   STATUS      current
+   DESCRIPTION
+           "The ocStbHost Security Subsystem group."
+   ::= { ocStbHostMIBGroups 4 }
+
+ocStbHostDeprecatedGroup OBJECT-GROUP
+   OBJECTS     {
+               ocStbHostSystemHomeNetworkMaxClients,
+               ocStbHostSystemHomeNetworkHostDRMStatus,
+               ocStbHostSystemHomeNetworkConnectedClients,
+               ocStbHostSystemHomeNetworkClientMacAddress,
+               ocStbHostSystemHomeNetworkClientIpAddress,
+               ocStbHostSystemHomeNetworkClientDRMStatus,
+               ocStbHostSecurityIdentifier,
+               ocStbHostSoftwareApplicationSigStatus
+                }
+    STATUS      deprecated
+    DESCRIPTION
+            "Group of objects deprecated."
+        ::= { ocStbHostMIBGroups 5 }
+
+ocStbHostNotificationGroup NOTIFICATION-GROUP
+    NOTIFICATIONS {
+                    ocStbPanicDumpTrap
+                   }
+    STATUS      current
+    DESCRIPTION
+            "Defines the objects contained with the ocStbHost System
+            Group."
+    ::= { ocStbHostMIBGroups 6 }
+
+END
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,86 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "ocStbHostUserSettings.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+BDBG_MODULE(snmpProxy);
+
+/** Initializes the ocStbHostUserSettings module */
+void
+init_ocStbHostUserSettings(void)
+{
+    static oid      ocStbHostUserSettingsPreferedLanguage_oid[] =
+        { 1, 3, 6, 1, 4, 1, 4491, 2, 3, 1, 1, 4, 2, 1, 0 };
+
+	mibObjects *pObj = &gMibObjs[ocStbHostUserSettings];
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->opened);
+
+	if (pObj->registered)
+	{
+		DEBUGMSGTL(("ocStbHostUserSettings", "Initializing\n"));
+		
+		netsnmp_register_read_only_instance(netsnmp_create_handler_registration
+											("ocStbHostUserSettingsPreferedLanguage",
+											 get_ocStbHostUserSettingsPreferedLanguage,
+											 ocStbHostUserSettingsPreferedLanguage_oid,
+											 OID_LENGTH
+											 (ocStbHostUserSettingsPreferedLanguage_oid),
+											 HANDLER_CAN_RONLY));
+	}
+}
+
+int
+get_ocStbHostUserSettingsPreferedLanguage(netsnmp_mib_handler *handler,
+                                          netsnmp_handler_registration
+                                          *reginfo,
+                                          netsnmp_agent_request_info
+                                          *reqinfo,
+                                          netsnmp_request_info *requests)
+{
+	mibObjectUserSettings *pObj = (mibObjectUserSettings *)gMibObjs[ocStbHostUserSettings].obj;
+
+    BDBG_ASSERT(pObj);
+    BDBG_ASSERT(pObj->callback);
+
+	pObj->callback((void *)pObj, 0);
+
+    /*
+     * We are never called for a GETNEXT if it's registered as a
+     * "instance", as it's "magically" handled for us.  
+     */
+
+    /*
+     * a instance handler also only hands us one request at a time, so
+     * we don't need to loop over a list of requests; we'll only get one. 
+     */
+
+    switch (reqinfo->mode) {
+
+    case MODE_GET:
+        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                 (u_char *)
+                                 (pObj->container.preferredLanguage)
+                                 ,
+                                 strlen(pObj->container.preferredLanguage)
+                                 );
+        break;
+
+
+    default:
+        /*
+         * we should never get here, so this is a really bad error 
+         */
+        return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/ocStbHostUserSettings.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,14 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
+ */
+#ifndef OCSTBHOSTUSERSETTINGS_H
+#define OCSTBHOSTUSERSETTINGS_H
+
+/*
+ * function declarations 
+ */
+void            init_ocStbHostUserSettings(void);
+Netsnmp_Node_Handler get_ocStbHostUserSettingsPreferedLanguage;
+
+#endif                          /* OCSTBHOSTUSERSETTINGS_H */
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/programStatusTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/programStatusTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/programStatusTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/programStatusTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,42 @@
+/* This is the data storage for programStatus info. It is expected that this info changes
+   all the time, but for this demo, it is static.
+ */
+#include "snmpProxyIf.h"
+#include "programStatusTable.h"
+#include "snmpProxyIf_priv.h"
+
+static struct programStatusData programStatusData1[PROGRAM_STATUS_TABLE_SIZE]; 
+static struct programStatusEntry ListOfProgramStatus[PROGRAM_STATUS_TABLE_SIZE];
+
+void
+activateProgramStatus(void)
+{
+	int i;
+
+	for (i=0; i<PROGRAM_STATUS_TABLE_SIZE; i++)
+	{
+		programStatusData1[i].index = i;
+		ListOfProgramStatus[i].index = i+1;
+		ListOfProgramStatus[i].data = &programStatusData1[i];
+	}
+
+	return;
+}
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct programStatusEntry *
+getProgramStatusEntry(int index)
+{
+	struct programStatusEntry *foundEntry =NULL;
+
+	if (index >= 0 && index < PROGRAM_STATUS_TABLE_SIZE )
+	{
+		foundEntry = &ListOfProgramStatus[index];
+	}
+
+	return foundEntry;
+}
+
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/programStatusTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/programStatusTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/programStatusTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/programStatusTable.h	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,41 @@
+#ifndef PROGRAMSTATUSTABLE_H
+#define PROGRAMSTATUSTABLE_H
+#include "avInterfaceTable.h"
+
+/* These are the data structures for programStatus info.  */
+
+#define NUM_AV_OUTPUTS (NEXUS_NUM_HDMI_OUTPUTS \
+                        +NEXUS_NUM_SVIDEO_OUTPUTS \
+                        +NEXUS_NUM_RFM_OUTPUTS \
+                        +NEXUS_NUM_COMPONENT_OUTPUTS \
+                        +NEXUS_NUM_COMPOSITE_OUTPUTS \
+                        +NEXUS_NUM_SPDIF_OUTPUTS)
+
+#if (BCHP_CHIP == 7420 || BCHP_CHIP == 7400)
+#define PROGRAM_STATUS_TABLE_SIZE NEXUS_NUM_VIDEO_DECODERS * NUM_AV_OUTPUTS
+#else
+#define PROGRAM_STATUS_TABLE_SIZE NUM_AV_OUTPUTS
+#endif
+
+struct programStatusData
+{
+	int index;
+	containerProgramStatusTable container;
+};
+
+struct programStatusEntry
+{
+	int index;
+	struct programStatusData *data;
+};
+
+void
+activateProgramStatus (void);
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct programStatusEntry *
+getProgramStatusEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rebootInfo.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rebootInfo.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rebootInfo.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rebootInfo.c	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,25 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "rebootInfo.h"
+
+void set_ocStbHostRebootType(int reboot_type)
+{
+	FILE *fp;
+
+	fp = fopen(REBOOT_TYPE_STORAGE, "w");
+	if (fp == NULL)
+	{
+		BDBG_ERR(("Unable to open %s", REBOOT_TYPE_STORAGE));
+		return; 
+	}	
+
+	if (reboot_type < oc_rebootType_unknown || reboot_type > oc_rebootType_cablecardError)
+	{
+		BDBG_ERR(("Unknown ocStbHostRebootType"));
+		return; 
+	}
+	
+	fwrite(&reboot_type, sizeof(int), 1, fp);
+	fclose(fp);
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rebootInfo.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rebootInfo.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rebootInfo.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rebootInfo.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,10 @@
+#ifndef REBOOTINFO_H
+#define REBOOTINFO_H
+
+/* These are the data structures for rebootInfo info.  */
+
+#define REBOOT_TYPE_STORAGE "reboot_type.info"
+
+void set_ocStbHostRebootType(int reboot_type);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,37 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "rfChannelOutTable.h"
+
+static struct rfChannelOutData rfChOutTblData[NEXUS_NUM_RFM_OUTPUTS];
+static struct rfChannelOutEntry rfChOutList[NEXUS_NUM_RFM_OUTPUTS];
+
+void
+activateRfChannelOut(void)
+{
+	struct rfChannelOutEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NEXUS_NUM_RFM_OUTPUTS; i++)
+	{
+		rfChOutTblData[i].index = i;
+
+		tmpEntry = &rfChOutList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &rfChOutTblData[i];
+	}
+
+	return;
+}
+
+struct rfChannelOutEntry *
+getRfChannelOutEntry(int index)
+{
+	struct rfChannelOutEntry *foundEntry =NULL;
+
+	if (index >=0 && index < NEXUS_NUM_RFM_OUTPUTS)
+	{
+		foundEntry = &rfChOutList[index];
+	}
+
+	return foundEntry;
+}
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/rfChannelOutTable.h	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,24 @@
+#ifndef RFCHANNELOUTTABLE_H
+#define RFCHANNELOUTTABLE_H
+
+/* These are the data structures for rfChannelOut info.  */
+
+struct rfChannelOutData 
+{
+	int index;
+	containerRfChannelOutTable container;
+};
+
+struct rfChannelOutEntry 
+{
+	int index;
+	struct rfChannelOutData *data;
+};
+
+void
+activateRfChannelOut (void);
+
+struct rfChannelOutEntry *
+getRfChannelOutEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.c	2015-03-20 11:44:06.891088225 -0700
@@ -0,0 +1,99 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "softwareApplicationInfoTable.h"
+
+static struct swAppData swAppTblData[NUM_SW_APPS];
+static struct swAppEntry swAppList[NUM_SW_APPS];
+
+void
+activateSwApp(void)
+{
+	struct swAppEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_SW_APPS; i++)
+	{
+		swAppTblData[i].index = i;
+
+		tmpEntry = &swAppList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &swAppTblData[i];
+	}
+
+	return;
+}
+
+struct swAppEntry *
+getSwAppEntry(int index)
+{
+	struct swAppEntry *foundEntry =NULL;
+
+	if (index >=0 && index < NUM_SW_APPS)
+	{
+		foundEntry = &swAppList[index];
+	}
+
+	return foundEntry;
+}
+
+int getSwAppStatus(char *app)
+{
+    DIR *procDir;
+    struct dirent *procEntry;
+    FILE *fp;
+    int pid, i;
+	char *ptr;
+	char buf[256];
+    char string[256];
+	int status = oc_swStatus_notLoaded;
+
+    if (procDir = opendir("/proc"))
+    {
+		while ((procEntry = readdir(procDir)) != NULL)
+		{
+			if ((pid = atoi(procEntry->d_name)) > 0)
+			{
+				sprintf(string, "/proc/%d/stat", pid);
+				if ((fp = fopen(string, "r")) != NULL)
+				{
+					if (fgets(buf, sizeof(buf), fp))
+					{
+						if (strlen(buf))
+						{
+							i = 0;
+							ptr = buf;
+							while (*ptr++ != '(');
+							while (*ptr != ')')
+							{
+								string[i++] = *ptr++;
+							}
+							if (strncmp(string, app, strlen(app)) == 0)
+							{
+								status = oc_swStatus_loaded;
+								ptr += 2;
+								switch (*ptr)
+								{
+									case 'R': /* running */
+										status = oc_swStatus_running;
+										break;
+									case 'S': /* sleeping */
+									case 'D': /* sleeping in an uninterruptible wait */
+										status = oc_swStatus_paused; /* is `pasued` equal to `sleeping`? */
+										break;
+									case 'T': /* traced or stopped */
+									case 'Z': /* zombie */
+										status = oc_swStatus_destroyed;
+										break;
+								}
+							}
+						}
+					}
+					fclose(fp);
+				}
+			}
+		}
+		closedir(procDir);
+    }
+	return status;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/softwareApplicationInfoTable.h	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,27 @@
+#ifndef SOFTWAREAPPLICATIONINFOTABLE_H
+#define SOFTWAREAPPLICATIONINFOTABLE_H
+
+/* These are the data structures for softwareApplication info table.  */
+
+struct swAppData
+{
+	int index;
+	containerSwAppInfoTable container;
+};
+
+struct swAppEntry
+{
+	int index;
+	struct swAppData *data;
+};
+
+void
+activateSwApp(void);
+
+struct swAppEntry *
+getSwAppEntry(int index);
+
+int
+getSwAppStatus(char *app);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/spDifTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/spDifTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/spDifTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/spDifTable.c	2015-04-13 16:47:11.653657286 -0700
@@ -0,0 +1,44 @@
+/* This is the data storage for spDif info. It is expected that this info changes
+   all the time, but for this demo, it is static.
+ */
+
+#include "spDifTable.h"
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+
+static struct spDifData spDifData1[NEXUS_NUM_SPDIF_OUTPUTS];
+static struct spDifEntry ListOfSpDif[NEXUS_NUM_SPDIF_OUTPUTS];
+
+
+void
+activateSpDif (void) {
+  int i;
+
+  
+  for (i=0;i<NEXUS_NUM_SPDIF_OUTPUTS;i++) {
+
+      spDifData1[i].index = i;
+      ListOfSpDif[i].index = i+1;
+      ListOfSpDif[i].data = &spDifData1[i];
+  }
+  
+  return;
+
+}
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct spDifEntry *
+getSpDifEntry(int index) {
+
+  
+  struct spDifEntry *foundEntry =NULL;
+  if (index >= 0 && index < NEXUS_NUM_SPDIF_OUTPUTS )
+  {
+       foundEntry = &ListOfSpDif[index];
+  }
+  
+  return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/spDifTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/spDifTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/spDifTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/spDifTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,35 @@
+#ifndef SPDIFABLE_H
+#define SPDIFABLE_H
+#include "snmpProxyIf.h"
+/* These are the data structures for spDif info.  */
+
+struct spDifData {
+        int index;
+        containerSPDIfTable container;
+};
+
+struct spDifEntry {
+         int index;
+         struct spDifData *data;
+         
+};
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+void
+activateSpDif (void);
+
+/* This function returns the entry with the next highest index, NOT the next in
+ * the list. This is very, very important for SNMP.
+ */
+struct spDifEntry *
+getSpDifEntry(int index);
+
+/* This function returns the first entry. The one wiht the lowest index, NOT the first in
+ * the linked list. This is very, very important for SNMP. Since indexes start at 1, we 
+ * just get the next one after 0.
+ */
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.c net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.c
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.c	2015-03-20 11:44:06.887088121 -0700
@@ -0,0 +1,38 @@
+#include "snmpProxyIf.h"
+#include "snmpProxyIf_priv.h"
+#include "systemMemoryReportTable.h"
+
+static struct systemMemoryReportData systemMemoryReportTblData[NUM_MEMORY_TYPE];
+static struct systemMemoryReportEntry systemMemoryReportList[NUM_MEMORY_TYPE];
+
+void
+activateSystemMemoryReport (void)
+{
+	struct systemMemoryReportEntry *tmpEntry;
+	int i;
+
+	for (i=0; i<NUM_MEMORY_TYPE; i++)
+	{
+		systemMemoryReportTblData[i].index = i;
+
+		tmpEntry = &systemMemoryReportList[i];
+		tmpEntry->index = i+1;
+		tmpEntry->data = &systemMemoryReportTblData[i];
+	}
+
+	return;
+}
+
+struct systemMemoryReportEntry *
+getSystemMemoryReportEntry(int index) {
+
+	struct systemMemoryReportEntry *foundEntry = NULL;
+
+	if (index >=0 && index < NUM_MEMORY_TYPE)
+	{
+		foundEntry = &systemMemoryReportList[index];
+	}
+
+	return foundEntry;
+}
+
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib/stb_host/systemMemoryReportTable.h	2015-03-20 11:44:06.895088329 -0700
@@ -0,0 +1,24 @@
+#ifndef SYSTEMMEMORYREPORTTABLE_H
+#define SYSTEMMEMORYREPORTTABLE_H
+
+/* These are the data structures for systemMemoryReport info.  */
+
+struct systemMemoryReportData
+{
+	int index;
+	containerSystemMemoryReportTable container;
+};
+
+struct systemMemoryReportEntry
+{
+	int index;
+	struct systemMemoryReportData *data;
+};
+
+void
+activateSystemMemoryReport (void);
+
+struct systemMemoryReportEntry *
+getSystemMemoryReportEntry(int index);
+
+#endif
diff -rupN net-snmp-5.0.9-original/agent/mibgroup/ocmib.h net-snmp-5.0.9-patched/agent/mibgroup/ocmib.h
--- net-snmp-5.0.9-original/agent/mibgroup/ocmib.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/agent/mibgroup/ocmib.h	2015-03-20 11:43:58.494869989 -0700
@@ -0,0 +1,52 @@
+config_require(util_funcs)
+config_require(ocmib/snmpProxyIf)
+config_require(ocmib/stb_host/ocStbHostHWIdentifiers)
+config_require(ocmib/stb_host/ocStbHostAVInterfaceTable)
+config_require(ocmib/stb_host/avInterfaceTable)
+config_require(ocmib/stb_host/ocStbHostIEEE1394Table)
+config_require(ocmib/stb_host/ieee1394Table)
+config_require(ocmib/stb_host/ocStbHostIEEE1394ConnectedDevicesTable)
+config_require(ocmib/stb_host/ieee1394ConnectedDevicesTable)
+config_require(ocmib/stb_host/ocStbHostDVIHDMITable)
+config_require(ocmib/stb_host/dviHdmiTable)
+config_require(ocmib/stb_host/ocStbHostDVIHDMIAvailableVideoFormatTable)
+config_require(ocmib/stb_host/dviHdmiAvailableVideoFormatTable)
+config_require(ocmib/stb_host/ocStbHostComponentVideoTable)
+config_require(ocmib/stb_host/componentVideoTable)
+config_require(ocmib/stb_host/ocStbHostRFChannelOutTable)
+config_require(ocmib/stb_host/rfChannelOutTable)
+config_require(ocmib/stb_host/ocStbHostInBandTunerTable)
+config_require(ocmib/stb_host/ibTunerTable)
+config_require(ocmib/stb_host/ocStbHostProgramStatusTable)
+config_require(ocmib/stb_host/programStatusTable)
+config_require(ocmib/stb_host/ocStbHostMpeg2ContentTable)
+config_require(ocmib/stb_host/mpeg2ContentTable)
+config_require(ocmib/stb_host/ocStbHostAnalogVideoTable)
+config_require(ocmib/stb_host/analogVideoTable)
+config_require(ocmib/stb_host/ocStbHostQpskObjects)
+config_require(ocmib/stb_host/ocStbHostSPDIfTable)
+config_require(ocmib/stb_host/spDifTable)
+config_require(ocmib/stb_host/ocStbHostEasCodes)
+config_require(ocmib/stb_host/ocStbHostDeviceSoftwareBase)
+config_require(ocmib/stb_host/ocStbHostFirmwareDownloadStatus)
+config_require(ocmib/stb_host/ocStbHostSoftwareApplicationInfo)
+config_require(ocmib/stb_host/ocStbHostSoftwareApplicationInfoTable)
+config_require(ocmib/stb_host/softwareApplicationInfoTable)
+config_require(ocmib/stb_host/ocStbHostSecuritySubSystem)
+config_require(ocmib/stb_host/ocStbHostPower)
+config_require(ocmib/stb_host/ocStbHostUserSettings)
+config_require(ocmib/stb_host/ocStbHostSystemMemoryReportTable)
+config_require(ocmib/stb_host/systemMemoryReportTable)
+config_require(ocmib/stb_host/ocStbCardInfo)
+config_require(ocmib/stb_host/ocStbHostCardCpInfo)
+config_require(ocmib/stb_host/ocStbHostCCAppInfoTable)
+config_require(ocmib/stb_host/ccAppInfoTable)
+config_require(ocmib/stb_host/ocStbHostSnmpProxyInfo)
+config_require(ocmib/stb_host/ocStbHostInfo)
+config_require(ocmib/stb_host/ocStbHostDumpTrapInfo)
+config_require(ocmib/stb_host/ocStbHostSpecificationsInfo)
+config_require(ocmib/stb_host/ocStbHostContentErrorSummaryInfo)
+config_require(ocmib/stb_host/ocStbHostRebootInfo)
+config_require(ocmib/stb_host/rebootInfo)
+config_require(ocmib/stb_host/ocStbHostMemoryInfo)
+config_require(ocmib/stb_host/ocStbHostJVMInfo)
diff -rupN net-snmp-5.0.9-original/agent/snmpd.c net-snmp-5.0.9-patched/agent/snmpd.c
--- net-snmp-5.0.9-original/agent/snmpd.c	2003-09-05 21:58:40.000000000 -0700
+++ net-snmp-5.0.9-patched/agent/snmpd.c	2015-03-20 11:55:54.917451301 -0700
@@ -10,17 +10,17 @@
  */
 /*
  * Copyright 1988, 1989 by Carnegie Mellon University
- * 
+ *
  * All Rights Reserved
- * 
- * Permission to use, copy, modify, and distribute this software and its 
- * documentation for any purpose and without fee is hereby granted, 
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
- * both that copyright notice and this permission notice appear in 
+ * both that copyright notice and this permission notice appear in
  * supporting documentation, and that the name of CMU not be
  * used in advertising or publicity pertaining to distribution of the
- * software without specific, written prior permission.  
- * 
+ * software without specific, written prior permission.
+ *
  * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
@@ -35,6 +35,7 @@
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
@@ -178,7 +179,7 @@ int             Facility = LOG_DAEMON;
 
 #ifdef WIN32
 /*
- * SNMP Agent Status 
+ * SNMP Agent Status
  */
 #define AGENT_RUNNING 1
 #define AGENT_STOPPED 0
@@ -205,6 +206,7 @@ int             snmp_input(int, netsnmp_
 static void     usage(char *);
 static void     SnmpTrapNodeDown(void);
 static int      receive(void);
+#if 0
 #ifdef WIN32
 void            StopSnmpAgent(void);
 int             SnmpDaemonMain(int argc, TCHAR * argv[]);
@@ -212,6 +214,9 @@ int __cdecl     _tmain(int argc, TCHAR *
 #else
 int             main(int, char **);
 #endif
+#else
+int             B_SNMP_Main(void);
+#endif
 
 /*
  * These definitions handle 4.2 systems without additional syslog facilities.
@@ -337,8 +342,8 @@ SnmpdShutDown(int a)
     running = 0;
 #ifdef WIN32
     /*
-     * In case of windows, select() in receive() function will not return 
-     * on signal. Thats why following function is called, which closes the 
+     * In case of windows, select() in receive() function will not return
+     * on signal. Thats why following function is called, which closes the
      * socket descriptors and causes the select() to return
      */
     snmp_close(main_session);
@@ -370,12 +375,12 @@ SnmpTrapNodeDown(void)
 {
     send_easy_trap(SNMP_TRAP_ENTERPRISESPECIFIC, 2);
     /*
-     * XXX  2 - Node Down #define it as NODE_DOWN_TRAP 
+     * XXX  2 - Node Down #define it as NODE_DOWN_TRAP
      */
 }
 
 static void
-setup_log(int restart, int dont_zero, int stderr_log, int syslog_log, 
+setup_log(int restart, int dont_zero, int stderr_log, int syslog_log,
 	  char *logfile)
 {
     static char logfile_s[PATH_MAX + 1] = { 0 };
@@ -414,7 +419,7 @@ setup_log(int restart, int dont_zero, in
  * Parameters:
  *	 argc
  *	*argv[]
- *      
+ *
  * Returns:
  *	0	Always succeeds.  (?)
  *
@@ -424,12 +429,23 @@ setup_log(int restart, int dont_zero, in
  * Also successfully EXITs with zero for some options.
  */
 int
+#if 0
 #ifdef WIN32
 SnmpDaemonMain(int argc, TCHAR * argv[])
 #else
 main(int argc, char *argv[])
 #endif
+#else
+B_SNMP_Main(void)
+#endif
 {
+#if 1
+    int argc = 2;
+    char *argv[2]= {"snmpd", "udp:16976"};
+#else
+    int argc = 1;
+    char *argv[1]= {"snmpd"};
+#endif
     char            options[128] = "aAc:CdD::fhHI:l:LP:qrsS:UvV-:";
     int             arg, i, ret;
     int             dont_fork = 0;
@@ -445,21 +461,23 @@ main(int argc, char *argv[])
     FILE           *PID;
 #endif
 
+    printf("*** snmpd (snmp proxy) is running...\n");
+
 #ifdef LOGFILE
     strncpy(logfile, LOGFILE, PATH_MAX);
 #endif
 
 #ifdef NO_ROOT_ACCESS
     /*
-     * Default to no.  
+     * Default to no.
      */
-    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 			   NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
 #endif
     /*
-     * Default to NOT running an AgentX master.  
+     * Default to NOT running an AgentX master.
      */
-    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+    netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 			   NETSNMP_DS_AGENT_AGENTX_MASTER, 0);
     netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
                        NETSNMP_DS_AGENT_AGENTX_TIMEOUT, -1);
@@ -467,7 +485,7 @@ main(int argc, char *argv[])
                        NETSNMP_DS_AGENT_AGENTX_RETRIES, -1);
 
     /*
-     * Add some options if they are available.  
+     * Add some options if they are available.
      */
 #if HAVE_UNISTD_H
     strcat(options, "g:u:");
@@ -480,7 +498,7 @@ main(int argc, char *argv[])
 #endif
 
     /*
-     * Now process options normally.  
+     * Now process options normally.
      */
 
     while ((arg = getopt(argc, argv, options)) != EOF) {
@@ -506,7 +524,7 @@ main(int argc, char *argv[])
 
         case 'c':
             if (optarg != NULL) {
-                netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
+                netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
 				      NETSNMP_DS_LIB_OPTIONALCONFIG, optarg);
             } else {
                 usage(argv[0]);
@@ -514,13 +532,13 @@ main(int argc, char *argv[])
             break;
 
         case 'C':
-            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
 				   NETSNMP_DS_LIB_DONT_READ_CONFIGS, 1);
             break;
 
         case 'd':
             snmp_set_dump_packet(++snmp_dump_packet);
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_VERBOSE, 1);
             break;
 
@@ -536,7 +554,7 @@ main(int argc, char *argv[])
 #if HAVE_UNISTD_H
         case 'g':
             if (optarg != NULL) {
-                netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID, 
+                netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_GROUPID, atoi(optarg));
             } else {
                 usage(argv[0]);
@@ -549,7 +567,7 @@ main(int argc, char *argv[])
             break;
 
         case 'H':
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
             init_agent("snmpd");        /* register our .conf handlers */
             init_mib_modules();
@@ -597,7 +615,7 @@ main(int argc, char *argv[])
             break;
 
         case 'r':
-            netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID,
 				      NETSNMP_DS_AGENT_NO_ROOT_ACCESS);
             break;
 
@@ -651,7 +669,7 @@ main(int argc, char *argv[])
             break;
 
         case 'U':
-            netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID,
 				      NETSNMP_DS_AGENT_LEAVE_PIDFILE);
             break;
 
@@ -676,7 +694,7 @@ main(int argc, char *argv[])
                     }
 #endif
                 }
-                netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID, 
+                netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_USERID, uid);
             } else {
                 usage(argv[0]);
@@ -688,19 +706,19 @@ main(int argc, char *argv[])
             version();
 
         case 'V':
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_VERBOSE, 1);
             break;
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE)|| defined(USING_AGENTX_MASTER_MODULE)
         case 'x':
             if (optarg != NULL) {
-                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
+                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
 				      NETSNMP_DS_AGENT_X_SOCKET, optarg);
             } else {
                 usage(argv[0]);
             }
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_AGENTX_MASTER, 1);
             break;
 #endif
@@ -724,12 +742,12 @@ main(int argc, char *argv[])
 
     if (optind < argc) {
         /*
-         * There are optional transport addresses on the command line.  
+         * There are optional transport addresses on the command line.
          */
         DEBUGMSGTL(("snmpd/main", "optind %d, argc %d\n", optind, argc));
         for (i = optind; i < argc; i++) {
             char *c, *astring;
-            if ((c = netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
+            if ((c = netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,
 					   NETSNMP_DS_AGENT_PORTS))) {
                 astring = malloc(strlen(c) + 2 + strlen(argv[i]));
                 if (astring == NULL) {
@@ -737,23 +755,23 @@ main(int argc, char *argv[])
                     exit(1);
                 }
                 sprintf(astring, "%s,%s", c, argv[i]);
-                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
+                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
 				      NETSNMP_DS_AGENT_PORTS, astring);
                 free(astring);
             } else {
-                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
+                netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
 				      NETSNMP_DS_AGENT_PORTS, argv[i]);
             }
         }
         DEBUGMSGTL(("snmpd/main", "port spec: %s\n",
-                    netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
+                    netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID,
 					  NETSNMP_DS_AGENT_PORTS)));
     }
 
     setup_log(0, dont_zero_log, stderr_log, syslog_log, logfile);
 
     /*
-     * Initialize a argv set to the current for restarting the agent.   
+     * Initialize a argv set to the current for restarting the agent.
      */
     argvrestartp = (char **)malloc((argc + 2) * sizeof(char *));
     argvptr = argvrestartp;
@@ -769,14 +787,14 @@ main(int argc, char *argv[])
     strcpy(argvrestartname, argv[0]);
     if (agent_mode == -1) {
         if (strstr(argvrestartname, "agentxd") != NULL) {
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_ROLE, SUB_AGENT);
         } else {
-            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+            netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_ROLE, MASTER_AGENT);
         }
     } else {
-        netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
+        netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 			       NETSNMP_DS_AGENT_ROLE, agent_mode);
     }
 
@@ -792,10 +810,11 @@ main(int argc, char *argv[])
     setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
 #endif
     /*
-     * Initialize the world.  Detach from the shell.  Create initial user.  
+     * Initialize the world.  Detach from the shell.  Create initial user.
      */
+#if 0
 #if HAVE_FORK
-    if (!dont_fork) {
+     if (!dont_fork) {
         /*
          * Fork to return control to the invoking process and to
          * guarantee that we aren't a process group leader.
@@ -848,22 +867,25 @@ main(int argc, char *argv[])
         }
     }
 #endif /* HAVE_FORK */
+#endif
 
     SOCK_STARTUP;
     init_agent("snmpd");        /* do what we need to do first. */
     init_mib_modules();
 
     /*
-     * start library 
+     * start library
      */
     init_snmp("snmpd");
 
     if ((ret = init_master_agent()) != 0) {
         /*
-         * Some error opening one of the specified agent transports.  
+         * Some error opening one of the specified agent transports.
          */
         Exit(1);                /*  Exit logs exit val for us  */
     }
+
+#if 0
 #ifdef SIGTERM
     DEBUGMSGTL(("signal", "registering SIGTERM signal handler\n"));
     signal(SIGTERM, SnmpdShutDown);
@@ -884,14 +906,15 @@ main(int argc, char *argv[])
     DEBUGMSGTL(("signal", "registering SIGPIPE signal handler\n"));
     signal(SIGPIPE, SIG_IGN);   /* 'Inline' failure of wayward readers */
 #endif
+#endif
 
     /*
-     * Store persistent data immediately in case we crash later.  
+     * Store persistent data immediately in case we crash later.
      */
     snmp_store("snmpd");
 
     /*
-     * Send coldstart trap if possible.  
+     * Send coldstart trap if possible.
      */
     send_easy_trap(0, 0);
 
@@ -906,7 +929,7 @@ main(int argc, char *argv[])
 	    fd = open(pid_file, O_CREAT | O_EXCL | O_WRONLY, 0600);
 	    if (fd == -1) {
 		    snmp_log_perror(pid_file);
-		    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
+		    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
 			NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
 			    exit(1);
 		    }
@@ -925,7 +948,7 @@ main(int argc, char *argv[])
 
 #if HAVE_UNISTD_H
 #ifdef HAVE_SETGID
-    if ((gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
+    if ((gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID,
 				  NETSNMP_DS_AGENT_GROUPID)) != 0) {
         DEBUGMSGTL(("snmpd/main", "Changing gid to %d.\n", gid));
         if (setgid(gid) == -1
@@ -934,7 +957,7 @@ main(int argc, char *argv[])
 #endif
             ) {
             snmp_log_perror("setgid failed");
-            if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
+            if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 exit(1);
             }
@@ -942,12 +965,12 @@ main(int argc, char *argv[])
     }
 #endif
 #ifdef HAVE_SETUID
-    if ((uid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
+    if ((uid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID,
 				  NETSNMP_DS_AGENT_USERID)) != 0) {
         DEBUGMSGTL(("snmpd/main", "Changing uid to %d.\n", uid));
         if (setuid(uid) == -1) {
             snmp_log_perror("setuid failed");
-            if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
+            if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 exit(1);
             }
@@ -957,7 +980,7 @@ main(int argc, char *argv[])
 #endif
 
     /*
-     * We're up, log our version number.  
+     * We're up, log our version number.
      */
     snmp_log(LOG_INFO, "NET-SNMP version %s\n", netsnmp_get_version());
 #ifdef WIN32
@@ -966,10 +989,10 @@ main(int argc, char *argv[])
     netsnmp_addrcache_initialise();
 
     /*
-     * Forever monitor the dest_port for incoming PDUs.  
+     * Forever monitor the dest_port for incoming PDUs.
      */
     DEBUGMSGTL(("snmpd/main", "We're up.  Starting to process data.\n"));
-    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
+    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
 				NETSNMP_DS_AGENT_QUIT_IMMEDIATELY))
         receive();
 #include "mib_module_shutdown.h"
@@ -977,11 +1000,12 @@ main(int argc, char *argv[])
     SnmpTrapNodeDown();
     DEBUGMSGTL(("snmpd/main", "Bye...\n"));
     snmp_shutdown("snmpd");
-    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
+    if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
 				NETSNMP_DS_AGENT_LEAVE_PIDFILE) &&
 	(pid_file != NULL)) {
         unlink(pid_file);
     }
+
 #ifdef WIN32
     agent_status = AGENT_STOPPED;
 #endif
@@ -992,7 +1016,7 @@ main(int argc, char *argv[])
  * receive
  *
  * Parameters:
- *      
+ *
  * Returns:
  *	0	On success.
  *	-1	System error.
@@ -1103,7 +1127,7 @@ receive(void)
 
 #ifdef USING_SMUX_MODULE
             /*
-             * handle the SMUX sd's 
+             * handle the SMUX sd's
              */
             if (smux_listen_sd >= 0) {
                 for (i = 0; i < sdlen; i++) {
@@ -1117,7 +1141,7 @@ receive(void)
                     }
                 }
                 /*
-                 * new connection 
+                 * new connection
                  */
                 if (FD_ISSET(smux_listen_sd, &readfds)) {
                     if ((sd = smux_accept(smux_listen_sd)) >= 0) {
@@ -1212,10 +1236,10 @@ receive(void)
         }
 
         /*
-         * endif -- now>sched 
+         * endif -- now>sched
          */
         /*
-         * run requested alarms 
+         * run requested alarms
          */
         run_alarms();
 
@@ -1239,10 +1263,10 @@ receive(void)
  *	 requid
  *	*pdu
  *	*magic
- *      
+ *
  * Returns:
  *	1		On success	-OR-
- *	Passes through	Return from alarmGetResponse() when 
+ *	Passes through	Return from alarmGetResponse() when
  *	  		  USING_V2PARTY_ALARM_MODULE is defined.
  *
  * Call-back function to manage responses to traps (informs) and alarms.
@@ -1259,7 +1283,7 @@ snmp_input(int op,
         if (pdu->command == SNMP_MSG_GET) {
             if (state->type == EVENT_GET_REQ) {
                 /*
-                 * this is just the ack to our inform pdu 
+                 * this is just the ack to our inform pdu
                  */
                 return 1;
             }
@@ -1267,7 +1291,7 @@ snmp_input(int op,
     } else if (op == NETSNMP_CALLBACK_OP_TIMED_OUT) {
         if (state->type == ALARM_GET_REQ) {
             /*
-             * Need a mechanism to replace obsolete SNMPv2p alarm 
+             * Need a mechanism to replace obsolete SNMPv2p alarm
              */
         }
     }
@@ -1278,14 +1302,14 @@ snmp_input(int op,
 
 
 /*
- * Windows Service Related functions 
+ * Windows Service Related functions
  */
 #ifdef WIN32
 /************************************************************
 * main function for Windows
 * Parse command line arguments for startup options,
 * to start as service or console mode application in windows.
-* Invokes appropriate startup funcitons depending on the 
+* Invokes appropriate startup funcitons depending on the
 * parameters passesd
 *************************************************************/
 int
@@ -1294,7 +1318,7 @@ _tmain(int argc, TCHAR * argv[])
 {
 
     /*
-     * Define Service Name and Description, which appears in windows SCM 
+     * Define Service Name and Description, which appears in windows SCM
      */
     LPCTSTR         lpszServiceName = g_szAppName;      /* Service Registry Name */
     LPCTSTR         lpszServiceDisplayName = _T("Net SNMP Agent Daemon");       /* Display Name */
@@ -1309,7 +1333,7 @@ _tmain(int argc, TCHAR * argv[])
     switch (nRunType) {
     case REGISTER_SERVICE:
         /*
-         * Register As service 
+         * Register As service
          */
         InputOptions.Argc = argc;
         InputOptions.Argv = argv;
@@ -1320,27 +1344,27 @@ _tmain(int argc, TCHAR * argv[])
         break;
     case UN_REGISTER_SERVICE:
         /*
-         * Unregister service 
+         * Unregister service
          */
         UnregisterService(lpszServiceName);
         exit(0);
         break;
     case RUN_AS_SERVICE:
         /*
-         * Run as service 
+         * Run as service
          */
         /*
-         * Register Stop Function 
+         * Register Stop Function
          */
         RegisterStopFunction(StopSnmpAgent);
         return RunAsService(SnmpDaemonMain);
         break;
     default:
         /*
-         * Run Net-Snmpd in console mode 
+         * Run Net-Snmpd in console mode
          */
         /*
-         * Invoke SnmpDeamonMain with input arguments 
+         * Invoke SnmpDeamonMain with input arguments
          */
         return SnmpDaemonMain(argc, argv);
         break;
@@ -1348,19 +1372,19 @@ _tmain(int argc, TCHAR * argv[])
 }
 
 /*
- * To stop Snmp Agent deamon 
+ * To stop Snmp Agent deamon
  * This portion is still not working
  */
 void
 StopSnmpAgent(void)
 {
     /*
-     * Shut Down Agent 
+     * Shut Down Agent
      */
     SnmpdShutDown(1);
 
     /*
-     * Wait till agent is completely stopped 
+     * Wait till agent is completely stopped
      */
 
     while (agent_status != AGENT_STOPPED) {
diff -rupN net-snmp-5.0.9-original/configure net-snmp-5.0.9-patched/configure
--- net-snmp-5.0.9-original/configure	2003-09-06 00:22:58.000000000 -0700
+++ net-snmp-5.0.9-patched/configure	2015-03-20 12:00:06.595900947 -0700
@@ -869,7 +869,7 @@ echo > confdefs.h
 
 # A filename unique to this package, relative to the directory that
 # configure is in, which we can look for to find out if srcdir is correct.
-ac_unique_file=agent/mibgroup/ucd-snmp/extensible.c
+ac_unique_file=agent/mibgroup/util_funcs.h
 
 # Find the source files, if location was not specified.
 if test -z "$srcdir"; then
@@ -18073,15 +18073,9 @@ ac_given_INSTALL="$INSTALL"
 trap 'rm -fr `echo "
  Makefile:Makefile.top:Makefile.in:Makefile.rules
  snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend
- apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend
- apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend
  agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend
  agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend
  agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend
- local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules
- testing/Makefile:Makefile.top:testing/Makefile.in
- man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules
- mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules
  net-snmp-config:net-snmp-config.in
  include/net-snmp/net-snmp-config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
@@ -18240,15 +18234,9 @@ cat >> $CONFIG_STATUS <<EOF
 
 CONFIG_FILES=\${CONFIG_FILES-"Makefile:Makefile.top:Makefile.in:Makefile.rules
  snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend
- apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend
- apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend
  agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend
  agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend
  agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend
- local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules
- testing/Makefile:Makefile.top:testing/Makefile.in
- man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules
- mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules
  net-snmp-config:net-snmp-config.in
 "}
 EOF
diff -rupN net-snmp-5.0.9-original/configure.in net-snmp-5.0.9-patched/configure.in
--- net-snmp-5.0.9-original/configure.in	2003-09-05 23:41:25.000000000 -0700
+++ net-snmp-5.0.9-patched/configure.in	2015-03-20 12:00:15.108117594 -0700
@@ -2676,15 +2676,9 @@ AC_SUBST(DLLIBS)
 AC_OUTPUT([
  Makefile:Makefile.top:Makefile.in:Makefile.rules
  snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend
- apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend
- apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend
  agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend
  agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend
  agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend
- local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules
- testing/Makefile:Makefile.top:testing/Makefile.in
- man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules
- mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules
  net-snmp-config:net-snmp-config.in
 ], [
  echo timestamp > stamp-h
diff -rupN net-snmp-5.0.9-original/doconfigure.arm net-snmp-5.0.9-patched/doconfigure.arm
--- net-snmp-5.0.9-original/doconfigure.arm	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/doconfigure.arm	2015-04-13 16:47:25.691850996 -0700
@@ -0,0 +1,17 @@
+#!/bin/bash
+bash configure --prefix=/usr/tmp \
+            --build=i686-pc-linux-gnu \
+            --host=arm-*-linux-gnu \
+            --without-openssl \
+            --with-cc=arm-linux-gcc \
+            --with-ar=arm-linux-ar \
+            --with-out-transports="Unix TCP" \
+            --with-endianness=little \
+            --with-cflags="-DBCM" \
+            --with-mib-modules="ocmib" \
+            --with-out-mib-modules="mibII snmpv3mibs ucd_snmp agent_mibs notification target utilities agentx" \
+            --with-default-snmp-version="3" \
+            --with-sys-contact="who@where" \
+            --with-sys-location="Unknown" \
+            --with-logfile="/var/log/snmpd.log" \
+            --with-persistent-directory="/var/net-snmp"
diff -rupN net-snmp-5.0.9-original/doconfigure.mips net-snmp-5.0.9-patched/doconfigure.mips
--- net-snmp-5.0.9-original/doconfigure.mips	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/doconfigure.mips	2015-03-31 14:21:36.554657950 -0700
@@ -0,0 +1,17 @@
+#!/bin/bash
+bash configure --prefix=/usr/tmp \
+            --build=i686-pc-linux-gnu \
+            --host=mips-*-linux-gnu \
+            --without-openssl \
+            --with-cc=mipsel-linux-uclibc-gcc \
+            --with-ar=mipsel-linux-uclibc-ar \
+            --with-out-transports="Unix TCP" \
+            --with-endianness=little \
+            --with-cflags="-DBCM" \
+            --with-mib-modules="ocmib" \
+            --with-out-mib-modules="mibII snmpv3mibs ucd_snmp agent_mibs notification target utilities agentx" \
+            --with-default-snmp-version="3" \
+            --with-sys-contact="who@where" \
+            --with-sys-location="Unknown" \
+            --with-logfile="/var/log/snmpd.log" \
+            --with-persistent-directory="/var/net-snmp"
diff -rupN net-snmp-5.0.9-original/include/b_snmp_lib.h net-snmp-5.0.9-patched/include/b_snmp_lib.h
--- net-snmp-5.0.9-original/include/b_snmp_lib.h	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/include/b_snmp_lib.h	2015-03-20 11:44:46.980129960 -0700
@@ -0,0 +1,212 @@
+/***************************************************************************
+ *     (c)2007-2010 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its licensors,
+ *  and may only be used, duplicated, modified or distributed pursuant to the terms and
+ *  conditions of a separate, written license agreement executed between you and Broadcom
+ *  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
+ *  no license (express or implied), right to use, or waiver of any kind with respect to the
+ *  Software, and Broadcom expressly reserves all rights in and to the Software and all
+ *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
+ *  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
+ *  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
+ *  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
+ *  and to use this information only in connection with your use of Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ *  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
+ *  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ *  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
+ *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
+ *  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
+ *  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
+ *  USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
+ *  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
+ *  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
+ *  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
+ *  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
+ *  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
+ *  ANY LIMITED REMEDY.
+ *
+ * $brcm_Workfile: b_snmp_lib.h $
+ * $brcm_Revision: Hydra_Software_Devel/4 $
+ * $brcm_Date: 4/9/10 11:10a $
+ *
+ * Module Description:  SNMP interface
+ *
+ * Revision History:
+ *
+ * $brcm_Log: /rockford/lib/ocap/snmp/include/b_snmp_lib.h $
+ * 
+ * Hydra_Software_Devel/4   4/9/10 11:10a haisongw
+ * SW7400-2687: set default format mode to 'g" for string type MIB
+ *
+ * Hydra_Software_Devel/3   3/31/10 3:05p haisongw
+ * SW7400-2687: add SNMP getnext support
+ *
+ * Hydra_Software_Devel/2   3/17/10 6:10p haisongw
+ * SW7400-2687: Add SNMP trap support
+ *
+ *
+ ***************************************************************************/
+/***********************************************************************
+	Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#ifndef B_SNMP_LIB_H
+#define B_SNMP_LIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+
+#include "nexus_base_types.h"
+
+#define B_SNMP_MAX_COMMUNITY_LEN	32
+
+typedef enum B_SNMP_VERSION {
+	B_SNMP_VERSION_1,
+	B_SNMP_VERSION_2c,
+	B_SNMP_VERSION_3,
+	B_SNMP_VERSION_LAST
+} B_SNMP_VERSION;
+
+/* copy from OCAP RI: MIBDefinition.java
+   org.ocap.diagnostics
+   public interface MIBDefinition */
+typedef enum B_SNMP_Type {
+    /**
+     * Unrecognized type encountered.  Not defined by RFC 2578.
+     */
+    B_SNMP_TYPE_INVALID = 0,
+
+    /**
+     * Base type, built-in ASN.1 integer type.
+     */
+    B_SNMP_TYPE_INTEGER = 0x02,
+
+    /**
+     * The BITS construct.
+     */
+    B_SNMP_TYPE_BITS = 0x03,
+
+    /**
+     * Base type, built-in ASN.1 string type.
+     */
+    B_SNMP_TYPE_OCTETSTRING = 0x04,
+
+    /**
+     * Base type, built-in ASN.1 OBJECT IDENTIFIER type.
+     */
+    B_SNMP_TYPE_OBJECTID = 0x06,
+
+    /**
+     * Base type, application defined IP address.
+     */
+    B_SNMP_TYPE_IPADDRESS = 0x40,
+
+    /**
+     * Base type, application defined 32 bit counter.
+     */
+    B_SNMP_TYPE_COUNTER32 = 0x41,
+
+    /**
+     * Base type, application defined 32 bit gauge.
+     */
+    B_SNMP_TYPE_GAUGE32 = 0x42,
+
+    /**
+     * Base type, application defined time ticks.
+     */
+    B_SNMP_TYPE_TIMETICKS = 0x43,
+
+    /**
+     * Base type, application defined opaque variable.
+     */
+    B_SNMP_TYPE_OPAQUE = 0x44,
+
+    /**
+     * Base type, application defined 64 bit counter.
+     */
+    B_SNMP_TYPE_COUNTER64 = 0x46
+
+} B_SNMP_Type;
+
+
+typedef struct b_snmp_setting
+{
+	B_SNMP_VERSION version;
+	char community[B_SNMP_MAX_COMMUNITY_LEN];
+	char format[8]; /* output format according to NET-SNMP */
+                    /*    a:  print all strings in ascii format
+                          b:  do not break OID indexes down
+                          e:  print enums numerically
+                          E:  escape quotes in string indices
+                          f:  print full OIDs on output
+                          g:  print all strings in auto format according to its content
+                          n:  print OIDs numerically
+                          q:  quick print for easier parsing
+                          Q:  quick print with equal-signs
+                          s:  print only last symbolic element of OID
+                          S:  print MIB module-id plus last element
+                          t:  print timeticks unparsed as numeric integers
+                          T:  print human-readable text along with hex strings
+                          u:  print OIDs using UCD-style prefix suppression
+                          U:  don't print units
+                          v:  print values only (not OID = value)
+                          x:  print all strings in hex format
+                          X:  extended index format
+                     */
+	unsigned timeout; /* in micro seconds*/
+	unsigned retries; /* number of retry*/
+} b_snmp_setting;
+
+NEXUS_Error B_SNMP_Get(const char *ipaddr, const char *oid,  char *buf, int buf_len);
+NEXUS_Error B_SNMP_GetNext(const char *ipaddr, const char *oid,  char *buf, int buf_len);
+NEXUS_Error B_SNMP_Set(const char *ipaddr, const char *oid, B_SNMP_Type type, const char *value);
+NEXUS_Error B_SNMP_Gets(const char *ipaddr, const int num_oid, const char **oid, char **buf, int *buf_len);
+NEXUS_Error B_SNMP_GetsNext(const char *ipaddr, const int num_oid, const char **oid, char **buf, int *buf_len);
+NEXUS_Error B_SNMP_Sets(const char *ipaddr, const int num_oid, const char **oid, B_SNMP_Type *type, const char **value);
+NEXUS_Error B_SNMP_Set_Setting(b_snmp_setting *setting);
+NEXUS_Error B_SNMP_Get_Setting(b_snmp_setting *setting);
+NEXUS_Error B_SNMP_Trap(const char *ipaddr, const char *trap_oid, const char *oid, B_SNMP_Type type, const char *value);
+NEXUS_Error B_SNMP_Traps(const char *ipaddr, const char *trap_oid, const int num_oid, const char **oid, B_SNMP_Type *type, const char **value);
+NEXUS_Error B_SNMP_Inform(const char *ipaddr, const char *trap_oid, const char *oid, B_SNMP_Type type, const char *value);
+NEXUS_Error B_SNMP_Informs(const char *ipaddr, const char *trap_oid, const int num_oid, const char **oid, B_SNMP_Type *type, const char **value);
+NEXUS_Error B_SNMP_Init();
+void B_SNMP_Shutdown();
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -rupN net-snmp-5.0.9-original/include/net-snmp/machine/generic.h net-snmp-5.0.9-patched/include/net-snmp/machine/generic.h
--- net-snmp-5.0.9-original/include/net-snmp/machine/generic.h	2002-04-20 00:30:12.000000000 -0700
+++ net-snmp-5.0.9-patched/include/net-snmp/machine/generic.h	2015-03-20 11:57:19.655648659 -0700
@@ -1,3 +1,74 @@
+
+#define bsdlike 1
+
 /*
- * chip specific definitions go here 
+ * nlist symbols in ip.c 
  */
+#define IPSTAT_SYMBOL "ipstat"
+#define IP_FORWARDING_SYMBOL "ipforwarding"
+#define TCP_TTL_SYMBOL "tcpDefaultTTL"
+
+/*
+ * nlist symbols in interfaces.c 
+ */
+#define IFNET_SYMBOL "ifnet"
+#define IFADDR_SYMBOL "in_ifaddr"
+
+/*
+ * nlist symbols in at.c 
+ */
+#define ARPTAB_SYMBOL "arptab"
+#define ARPTAB_SIZE_SYMBOL "arptab_size"
+
+/*
+ * load average lookup symbol 
+ */
+#define LOADAVE_SYMBOL "avenrun"
+
+/*
+ * nlist symbols in hr_proc.c and memory.c 
+ */
+#define PHYSMEM_SYMBOL "physmem"
+#define TOTAL_MEMORY_SYMBOL "total"
+#define MBSTAT_SYMBOL "mbstat"
+#define SWDEVT_SYMBOL "swdevt"
+#define FSWDEVT_SYMBOL "fswdevt"
+#define NSWAPFS_SYMBOL "nswapfs"
+#define NSWAPDEV_SYMBOL "nswapdev"
+
+/*
+ * process nlist symbols. 
+ */
+#define NPROC_SYMBOL "nproc"
+#define PROC_SYMBOL "proc"
+
+/*
+ * icmp.c nlist symbols 
+ */
+#define ICMPSTAT_SYMBOL "icmpstat"
+
+/*
+ * tcp.c nlist symbols 
+ */
+#define TCPSTAT_SYMBOL "tcpstat"
+#define TCP_SYMBOL "tcb"
+
+/*
+ * upd.c nlist symbols 
+ */
+#define UDPSTAT_SYMBOL "udpstat"
+#define UDB_SYMBOL "udb"
+
+/*
+ * var_route.c nlist symbols 
+ */
+#define RTTABLES_SYMBOL "rt_table"
+#define RTHASHSIZE_SYMBOL "rthashsize"
+#define RTHOST_SYMBOL "rthost"
+#define RTNET_SYMBOL "rtnet"
+
+/*
+ * udp_inpcb list symbol 
+ */
+#define INP_NEXT_SYMBOL inp_next
+#define INP_PREV_SYMBOL inp_prev
diff -rupN net-snmp-5.0.9-original/include/net-snmp/types.h net-snmp-5.0.9-patched/include/net-snmp/types.h
--- net-snmp-5.0.9-original/include/net-snmp/types.h	2002-08-13 12:05:48.000000000 -0700
+++ net-snmp-5.0.9-patched/include/net-snmp/types.h	2015-03-20 11:58:00.096680246 -0700
@@ -90,7 +90,7 @@ typedef u_int in_addr_t;
     } netsnmp_void_array;
 
 #ifdef __cplusplus
-};
+}
 #endif
 
 #endif                          /* NET_SNMP_TYPES_H */
diff -rupN net-snmp-5.0.9-original/Makefile.depend net-snmp-5.0.9-patched/Makefile.depend
--- net-snmp-5.0.9-original/Makefile.depend	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/Makefile.depend	2015-03-20 11:46:48.379282007 -0700
@@ -0,0 +1,2964 @@
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+./agent_handler.lo: ../include/net-snmp/net-snmp-config.h
+./agent_handler.lo: ../include/net-snmp/system/linux.h
+./agent_handler.lo: ../include/net-snmp/system/sysv.h
+./agent_handler.lo: ../include/net-snmp/system/generic.h
+./agent_handler.lo: ../include/net-snmp/machine/generic.h
+./agent_handler.lo: ../include/net-snmp/net-snmp-includes.h
+./agent_handler.lo: ../include/net-snmp/definitions.h
+./agent_handler.lo: ../include/net-snmp/types.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_api.h
+./agent_handler.lo: ../include/net-snmp/library/asn1.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_impl.h
+./agent_handler.lo: ../include/net-snmp/library/snmp.h
+./agent_handler.lo: ../include/net-snmp/library/snmp-tc.h
+./agent_handler.lo: ../include/net-snmp/utilities.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_client.h
+./agent_handler.lo: ../include/net-snmp/library/getopt.h
+./agent_handler.lo: ../include/net-snmp/library/system.h
+./agent_handler.lo: ../include/net-snmp/library/tools.h
+./agent_handler.lo: ../include/net-snmp/library/int64.h
+./agent_handler.lo: ../include/net-snmp/library/mt_support.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_alarm.h
+./agent_handler.lo: ../include/net-snmp/library/data_list.h
+./agent_handler.lo: ../include/net-snmp/library/callback.h
+./agent_handler.lo: ../include/net-snmp/library/oid_stash.h
+./agent_handler.lo: ../include/net-snmp/library/check_varbind.h
+./agent_handler.lo: ../include/net-snmp/version.h
+./agent_handler.lo: ../include/net-snmp/session_api.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_transport.h
+./agent_handler.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./agent_handler.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./agent_handler.lo: ../include/net-snmp/library/ucd_compat.h
+./agent_handler.lo: ../include/net-snmp/pdu_api.h
+./agent_handler.lo: ../include/net-snmp/mib_api.h
+./agent_handler.lo: ../include/net-snmp/library/mib.h
+./agent_handler.lo: ../include/net-snmp/library/parse.h
+./agent_handler.lo: ../include/net-snmp/varbind_api.h
+./agent_handler.lo: ../include/net-snmp/config_api.h
+./agent_handler.lo: ../include/net-snmp/library/read_config.h
+./agent_handler.lo: ../include/net-snmp/library/default_store.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_parse_args.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_enum.h
+./agent_handler.lo: ../include/net-snmp/library/vacm.h
+./agent_handler.lo: ../include/net-snmp/output_api.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_debug.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_logging.h
+./agent_handler.lo: ../include/net-snmp/snmpv3_api.h
+./agent_handler.lo: ../include/net-snmp/library/snmpv3.h
+./agent_handler.lo: ../include/net-snmp/library/transform_oids.h
+./agent_handler.lo: ../include/net-snmp/library/keytools.h
+./agent_handler.lo: ../include/net-snmp/library/scapi.h
+./agent_handler.lo: ../include/net-snmp/library/lcd_time.h
+./agent_handler.lo: ../include/net-snmp/library/snmp_secmod.h
+./agent_handler.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./agent_handler.lo: ../include/net-snmp/library/snmpusm.h
+./agent_handler.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./agent_handler.lo: ../include/net-snmp/agent/snmp_agent.h
+./agent_handler.lo: ../include/net-snmp/agent/snmp_vars.h
+./agent_handler.lo: ../include/net-snmp/agent/agent_handler.h
+./agent_handler.lo: ../include/net-snmp/agent/var_struct.h
+./agent_handler.lo: ../include/net-snmp/agent/agent_registry.h
+./agent_handler.lo: ../include/net-snmp/agent/ds_agent.h
+./agent_handler.lo: ../include/net-snmp/agent/agent_read_config.h
+./agent_handler.lo: ../include/net-snmp/agent/agent_trap.h
+./agent_handler.lo: ../include/net-snmp/agent/all_helpers.h
+./agent_handler.lo: ../include/net-snmp/agent/instance.h
+./agent_handler.lo: ../include/net-snmp/agent/multiplexer.h
+./agent_handler.lo: ../include/net-snmp/agent/null.h
+./agent_handler.lo: ../include/net-snmp/agent/debug_handler.h
+./agent_handler.lo: ../include/net-snmp/agent/old_api.h
+./agent_handler.lo: ../include/net-snmp/agent/read_only.h
+./agent_handler.lo: ../include/net-snmp/agent/serialize.h
+./agent_handler.lo: ../include/net-snmp/agent/bulk_to_next.h
+./agent_handler.lo: ../include/net-snmp/agent/mode_end_call.h
+./agent_handler.lo: ../include/net-snmp/agent/table.h
+./agent_handler.lo: ../include/net-snmp/agent/table_data.h
+./agent_handler.lo: ../include/net-snmp/agent/table_dataset.h
+./agent_handler.lo: ../include/net-snmp/agent/table_iterator.h
+./agent_handler.lo: ../include/net-snmp/agent/mib_module_config.h
+./agent_index.lo: ../include/net-snmp/net-snmp-config.h
+./agent_index.lo: ../include/net-snmp/system/linux.h
+./agent_index.lo: ../include/net-snmp/system/sysv.h
+./agent_index.lo: ../include/net-snmp/system/generic.h
+./agent_index.lo: ../include/net-snmp/machine/generic.h 
+./agent_index.lo: ../include/net-snmp/net-snmp-includes.h
+./agent_index.lo: ../include/net-snmp/definitions.h
+./agent_index.lo: ../include/net-snmp/types.h
+./agent_index.lo: ../include/net-snmp/library/snmp_api.h
+./agent_index.lo: ../include/net-snmp/library/asn1.h
+./agent_index.lo: ../include/net-snmp/library/snmp_impl.h
+./agent_index.lo: ../include/net-snmp/library/snmp.h
+./agent_index.lo: ../include/net-snmp/library/snmp-tc.h
+./agent_index.lo: ../include/net-snmp/utilities.h
+./agent_index.lo: ../include/net-snmp/library/snmp_client.h
+./agent_index.lo: ../include/net-snmp/library/getopt.h
+./agent_index.lo: ../include/net-snmp/library/system.h
+./agent_index.lo: ../include/net-snmp/library/tools.h
+./agent_index.lo: ../include/net-snmp/library/int64.h
+./agent_index.lo: ../include/net-snmp/library/mt_support.h
+./agent_index.lo: ../include/net-snmp/library/snmp_alarm.h
+./agent_index.lo: ../include/net-snmp/library/data_list.h
+./agent_index.lo: ../include/net-snmp/library/callback.h
+./agent_index.lo: ../include/net-snmp/library/oid_stash.h
+./agent_index.lo: ../include/net-snmp/library/check_varbind.h
+./agent_index.lo: ../include/net-snmp/version.h
+./agent_index.lo: ../include/net-snmp/session_api.h
+./agent_index.lo: ../include/net-snmp/library/snmp_transport.h
+./agent_index.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./agent_index.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./agent_index.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./agent_index.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./agent_index.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./agent_index.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./agent_index.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./agent_index.lo: ../include/net-snmp/library/ucd_compat.h
+./agent_index.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./agent_index.lo: ../include/net-snmp/library/mib.h
+./agent_index.lo: ../include/net-snmp/library/parse.h
+./agent_index.lo: ../include/net-snmp/varbind_api.h
+./agent_index.lo: ../include/net-snmp/config_api.h
+./agent_index.lo: ../include/net-snmp/library/read_config.h
+./agent_index.lo: ../include/net-snmp/library/default_store.h
+./agent_index.lo: ../include/net-snmp/library/snmp_parse_args.h
+./agent_index.lo: ../include/net-snmp/library/snmp_enum.h
+./agent_index.lo: ../include/net-snmp/library/vacm.h
+./agent_index.lo: ../include/net-snmp/output_api.h
+./agent_index.lo: ../include/net-snmp/library/snmp_debug.h
+./agent_index.lo: ../include/net-snmp/library/snmp_logging.h
+./agent_index.lo: ../include/net-snmp/snmpv3_api.h
+./agent_index.lo: ../include/net-snmp/library/snmpv3.h
+./agent_index.lo: ../include/net-snmp/library/transform_oids.h
+./agent_index.lo: ../include/net-snmp/library/keytools.h
+./agent_index.lo: ../include/net-snmp/library/scapi.h
+./agent_index.lo: ../include/net-snmp/library/lcd_time.h
+./agent_index.lo: ../include/net-snmp/library/snmp_secmod.h
+./agent_index.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./agent_index.lo: ../include/net-snmp/library/snmpusm.h
+./agent_index.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./agent_index.lo: ../include/net-snmp/agent/snmp_agent.h
+./agent_index.lo: ../include/net-snmp/agent/snmp_vars.h
+./agent_index.lo: ../include/net-snmp/agent/agent_handler.h
+./agent_index.lo: ../include/net-snmp/agent/var_struct.h
+./agent_index.lo: ../include/net-snmp/agent/agent_registry.h
+./agent_index.lo: ../include/net-snmp/agent/ds_agent.h
+./agent_index.lo: ../include/net-snmp/agent/agent_read_config.h
+./agent_index.lo: ../include/net-snmp/agent/agent_trap.h
+./agent_index.lo: ../include/net-snmp/agent/all_helpers.h
+./agent_index.lo: ../include/net-snmp/agent/instance.h
+./agent_index.lo: ../include/net-snmp/agent/multiplexer.h
+./agent_index.lo: ../include/net-snmp/agent/null.h
+./agent_index.lo: ../include/net-snmp/agent/debug_handler.h
+./agent_index.lo: ../include/net-snmp/agent/old_api.h
+./agent_index.lo: ../include/net-snmp/agent/read_only.h
+./agent_index.lo: ../include/net-snmp/agent/serialize.h
+./agent_index.lo: ../include/net-snmp/agent/bulk_to_next.h
+./agent_index.lo: ../include/net-snmp/agent/mode_end_call.h
+./agent_index.lo: ../include/net-snmp/agent/table.h
+./agent_index.lo: ../include/net-snmp/agent/table_data.h
+./agent_index.lo: ../include/net-snmp/agent/table_dataset.h
+./agent_index.lo: ../include/net-snmp/agent/table_iterator.h
+./agent_index.lo: ../include/net-snmp/agent/mib_module_config.h
+./agent_index.lo: ../include/net-snmp/agent/agent_callbacks.h
+./agent_index.lo: ../include/net-snmp/agent/agent_index.h snmpd.h
+./agent_index.lo: mibgroup/struct.h ./mibgroup/mib_module_includes.h
+./agent_index.lo: mibgroup/mibII.h mibgroup/ucd_snmp.h mibgroup/snmpv3mibs.h
+./agent_index.lo: mibgroup/notification.h mibgroup/target.h
+./agent_index.lo: mibgroup/agent_mibs.h mibgroup/agentx.h
+./agent_index.lo: mibgroup/utilities.h mibgroup/host.h mibgroup/examples.h
+./agent_index.lo: mibgroup/examples/example.h mibgroup/testhandler.h
+./agent_index.lo: mibgroup/smux.h mibgroup/Rmon.h mibgroup/disman/event-mib.h
+./agent_index.lo: mibgroup/mibII/system_mib.h mibgroup/mibII/sysORTable.h
+./agent_index.lo: mibgroup/mibII/at.h mibgroup/mibII/interfaces.h
+./agent_index.lo: mibgroup/mibII/snmp_mib.h mibgroup/mibII/tcp.h
+./agent_index.lo: mibgroup/mibII/icmp.h mibgroup/mibII/ip.h
+./agent_index.lo: mibgroup/mibII/var_route.h mibgroup/mibII/route_write.h
+./agent_index.lo: mibgroup/mibII/at.h mibgroup/mibII/udp.h
+./agent_index.lo: mibgroup/mibII/vacm_vars.h mibgroup/mibII/setSerialNo.h
+./agent_index.lo: mibgroup/ucd-snmp/memory.h ./mibgroup/mibdefs.h
+./agent_index.lo: mibgroup/ucd-snmp/vmstat.h mibgroup/ucd-snmp/proc.h
+./agent_index.lo: mibgroup/ucd-snmp/versioninfo.h mibgroup/ucd-snmp/pass.h
+./agent_index.lo: mibgroup/ucd-snmp/pass_persist.h mibgroup/ucd-snmp/disk.h
+./agent_index.lo: mibgroup/ucd-snmp/loadave.h mibgroup/ucd-snmp/extensible.h
+./agent_index.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./agent_index.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./agent_index.lo: mibgroup/snmpv3/snmpEngine.h mibgroup/snmpv3/snmpMPDStats.h
+./agent_index.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./agent_index.lo: mibgroup/notification/snmpNotifyTable.h
+./agent_index.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./agent_index.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./agent_index.lo: mibgroup/target/snmpTargetAddrEntry.h
+./agent_index.lo: mibgroup/target/snmpTargetParamsEntry.h
+./agent_index.lo: mibgroup/target/target.h mibgroup/target/target_counters.h
+./agent_index.lo: mibgroup/agent/nsTransactionTable.h
+./agent_index.lo: mibgroup/agent/nsModuleTable.h mibgroup/agentx/master.h
+./agent_index.lo: mibgroup/agentx/subagent.h mibgroup/utilities/override.h
+./agent_index.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./agent_index.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./agent_index.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./agent_index.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./agent_index.lo: mibgroup/host/hr_partition.h mibgroup/host/hr_filesys.h
+./agent_index.lo: mibgroup/host/hr_swrun.h mibgroup/host/hr_swinst.h
+./agent_index.lo: mibgroup/examples/scalar_int.h mibgroup/examples/data_set.h
+./agent_index.lo: mibgroup/examples/delayed_instance.h mibgroup/util_funcs.h
+./agent_index.lo: mibgroup/struct.h mibgroup/smux/smux.h mibgroup/Rmon/rows.h
+./agent_index.lo: mibgroup/Rmon/agutil.h mibgroup/Rmon/statistics.h
+./agent_index.lo: mibgroup/Rmon/alarm.h mibgroup/Rmon/history.h
+./agent_index.lo: mibgroup/Rmon/event.h mibgroup/disman/mteTriggerTable.h
+./agent_index.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./agent_index.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./agent_index.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./agent_index.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./agent_index.lo: mibgroup/disman/mteObjectsTable.h
+./agent_index.lo: mibgroup/disman/mteEventTable.h
+./agent_index.lo: mibgroup/disman/mteEventNotificationTable.h
+./agent_index.lo: mibgroup/mibII/kernel_linux.h mibgroup/mibII/tcpTable.h
+./agent_index.lo: mibgroup/mibII/ipAddr.h mibgroup/mibII/var_route.h
+./agent_index.lo: mibgroup/mibII/route_write.h mibgroup/mibII/udpTable.h
+./agent_index.lo: mibgroup/mibII/vacm_context.h mibgroup/header_complex.h
+./agent_index.lo: mibgroup/agentx/protocol.h mibgroup/agentx/client.h
+./agent_index.lo: mibgroup/agentx/master_admin.h
+./agent_index.lo: mibgroup/agentx/agentx_config.h
+./agent_index.lo: ./mibgroup/agentx/subagent.h ./mibgroup/agentx/client.h
+./agent_read_config.lo: ../include/net-snmp/net-snmp-config.h
+./agent_read_config.lo: ../include/net-snmp/system/linux.h
+./agent_read_config.lo: ../include/net-snmp/system/sysv.h
+./agent_read_config.lo: ../include/net-snmp/system/generic.h
+./agent_read_config.lo: ../include/net-snmp/machine/generic.h
+./agent_read_config.lo: ../include/net-snmp/net-snmp-includes.h
+./agent_read_config.lo: ../include/net-snmp/definitions.h
+./agent_read_config.lo: ../include/net-snmp/types.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_api.h
+./agent_read_config.lo: ../include/net-snmp/library/asn1.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_impl.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp-tc.h
+./agent_read_config.lo: ../include/net-snmp/utilities.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_client.h
+./agent_read_config.lo: ../include/net-snmp/library/getopt.h
+./agent_read_config.lo: ../include/net-snmp/library/system.h
+./agent_read_config.lo: ../include/net-snmp/library/tools.h
+./agent_read_config.lo: ../include/net-snmp/library/int64.h
+./agent_read_config.lo: ../include/net-snmp/library/mt_support.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_alarm.h
+./agent_read_config.lo: ../include/net-snmp/library/data_list.h
+./agent_read_config.lo: ../include/net-snmp/library/callback.h
+./agent_read_config.lo: ../include/net-snmp/library/oid_stash.h
+./agent_read_config.lo: ../include/net-snmp/library/check_varbind.h
+./agent_read_config.lo: ../include/net-snmp/version.h
+./agent_read_config.lo: ../include/net-snmp/session_api.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_transport.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./agent_read_config.lo: ../include/net-snmp/library/ucd_compat.h
+./agent_read_config.lo: ../include/net-snmp/pdu_api.h
+./agent_read_config.lo: ../include/net-snmp/mib_api.h
+./agent_read_config.lo: ../include/net-snmp/library/mib.h
+./agent_read_config.lo: ../include/net-snmp/library/parse.h
+./agent_read_config.lo: ../include/net-snmp/varbind_api.h
+./agent_read_config.lo: ../include/net-snmp/config_api.h
+./agent_read_config.lo: ../include/net-snmp/library/read_config.h
+./agent_read_config.lo: ../include/net-snmp/library/default_store.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_parse_args.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_enum.h
+./agent_read_config.lo: ../include/net-snmp/library/vacm.h
+./agent_read_config.lo: ../include/net-snmp/output_api.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_debug.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_logging.h
+./agent_read_config.lo: ../include/net-snmp/snmpv3_api.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpv3.h
+./agent_read_config.lo: ../include/net-snmp/library/transform_oids.h
+./agent_read_config.lo: ../include/net-snmp/library/keytools.h
+./agent_read_config.lo: ../include/net-snmp/library/scapi.h
+./agent_read_config.lo: ../include/net-snmp/library/lcd_time.h
+./agent_read_config.lo: ../include/net-snmp/library/snmp_secmod.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./agent_read_config.lo: ../include/net-snmp/library/snmpusm.h
+./agent_read_config.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./agent_read_config.lo: ../include/net-snmp/agent/snmp_agent.h
+./agent_read_config.lo: ../include/net-snmp/agent/snmp_vars.h
+./agent_read_config.lo: ../include/net-snmp/agent/agent_handler.h
+./agent_read_config.lo: ../include/net-snmp/agent/var_struct.h
+./agent_read_config.lo: ../include/net-snmp/agent/agent_registry.h
+./agent_read_config.lo: ../include/net-snmp/agent/ds_agent.h
+./agent_read_config.lo: ../include/net-snmp/agent/agent_read_config.h
+./agent_read_config.lo: ../include/net-snmp/agent/agent_trap.h
+./agent_read_config.lo: ../include/net-snmp/agent/all_helpers.h
+./agent_read_config.lo: ../include/net-snmp/agent/instance.h
+./agent_read_config.lo: ../include/net-snmp/agent/multiplexer.h
+./agent_read_config.lo: ../include/net-snmp/agent/null.h
+./agent_read_config.lo: ../include/net-snmp/agent/debug_handler.h
+./agent_read_config.lo: ../include/net-snmp/agent/old_api.h
+./agent_read_config.lo: ../include/net-snmp/agent/read_only.h
+./agent_read_config.lo: ../include/net-snmp/agent/serialize.h
+./agent_read_config.lo: ../include/net-snmp/agent/bulk_to_next.h
+./agent_read_config.lo: ../include/net-snmp/agent/mode_end_call.h
+./agent_read_config.lo: ../include/net-snmp/agent/table.h
+./agent_read_config.lo: ../include/net-snmp/agent/table_data.h
+./agent_read_config.lo: ../include/net-snmp/agent/table_dataset.h
+./agent_read_config.lo: ../include/net-snmp/agent/table_iterator.h
+./agent_read_config.lo: ../include/net-snmp/agent/mib_module_config.h
+./agent_read_config.lo: mibgroup/struct.h snmpd.h
+./agent_read_config.lo: ../include/net-snmp/agent/agent_callbacks.h
+./agent_read_config.lo: ./mibgroup/mib_module_includes.h mibgroup/mibII.h
+./agent_read_config.lo: mibgroup/ucd_snmp.h mibgroup/snmpv3mibs.h
+./agent_read_config.lo: mibgroup/notification.h mibgroup/target.h
+./agent_read_config.lo: mibgroup/agent_mibs.h mibgroup/agentx.h
+./agent_read_config.lo: mibgroup/utilities.h mibgroup/host.h
+./agent_read_config.lo: mibgroup/examples.h mibgroup/examples/example.h
+./agent_read_config.lo: mibgroup/testhandler.h mibgroup/smux.h
+./agent_read_config.lo: mibgroup/Rmon.h mibgroup/disman/event-mib.h
+./agent_read_config.lo: mibgroup/mibII/system_mib.h
+./agent_read_config.lo: mibgroup/mibII/sysORTable.h mibgroup/mibII/at.h
+./agent_read_config.lo: mibgroup/mibII/interfaces.h mibgroup/mibII/snmp_mib.h
+./agent_read_config.lo: mibgroup/mibII/tcp.h mibgroup/mibII/icmp.h
+./agent_read_config.lo: mibgroup/mibII/ip.h mibgroup/mibII/var_route.h
+./agent_read_config.lo: mibgroup/mibII/route_write.h mibgroup/mibII/at.h
+./agent_read_config.lo: mibgroup/mibII/udp.h mibgroup/mibII/vacm_vars.h
+./agent_read_config.lo: mibgroup/mibII/setSerialNo.h
+./agent_read_config.lo: mibgroup/ucd-snmp/memory.h ./mibgroup/mibdefs.h
+./agent_read_config.lo: mibgroup/ucd-snmp/vmstat.h mibgroup/ucd-snmp/proc.h
+./agent_read_config.lo: mibgroup/ucd-snmp/versioninfo.h
+./agent_read_config.lo: mibgroup/ucd-snmp/pass.h
+./agent_read_config.lo: mibgroup/ucd-snmp/pass_persist.h
+./agent_read_config.lo: mibgroup/ucd-snmp/disk.h mibgroup/ucd-snmp/loadave.h
+./agent_read_config.lo: mibgroup/ucd-snmp/extensible.h
+./agent_read_config.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./agent_read_config.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./agent_read_config.lo: mibgroup/snmpv3/snmpEngine.h
+./agent_read_config.lo: mibgroup/snmpv3/snmpMPDStats.h
+./agent_read_config.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./agent_read_config.lo: mibgroup/notification/snmpNotifyTable.h
+./agent_read_config.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./agent_read_config.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./agent_read_config.lo: mibgroup/target/snmpTargetAddrEntry.h
+./agent_read_config.lo: mibgroup/target/snmpTargetParamsEntry.h
+./agent_read_config.lo: mibgroup/target/target.h
+./agent_read_config.lo: mibgroup/target/target_counters.h
+./agent_read_config.lo: mibgroup/agent/nsTransactionTable.h
+./agent_read_config.lo: mibgroup/agent/nsModuleTable.h
+./agent_read_config.lo: mibgroup/agentx/master.h mibgroup/agentx/subagent.h
+./agent_read_config.lo: mibgroup/utilities/override.h
+./agent_read_config.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./agent_read_config.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./agent_read_config.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./agent_read_config.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./agent_read_config.lo: mibgroup/host/hr_partition.h
+./agent_read_config.lo: mibgroup/host/hr_filesys.h mibgroup/host/hr_swrun.h
+./agent_read_config.lo: mibgroup/host/hr_swinst.h
+./agent_read_config.lo: mibgroup/examples/scalar_int.h
+./agent_read_config.lo: mibgroup/examples/data_set.h
+./agent_read_config.lo: mibgroup/examples/delayed_instance.h
+./agent_read_config.lo: mibgroup/util_funcs.h mibgroup/struct.h
+./agent_read_config.lo: mibgroup/smux/smux.h mibgroup/Rmon/rows.h
+./agent_read_config.lo: mibgroup/Rmon/agutil.h mibgroup/Rmon/statistics.h
+./agent_read_config.lo: mibgroup/Rmon/alarm.h mibgroup/Rmon/history.h
+./agent_read_config.lo: mibgroup/Rmon/event.h
+./agent_read_config.lo: mibgroup/disman/mteTriggerTable.h
+./agent_read_config.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./agent_read_config.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./agent_read_config.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./agent_read_config.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./agent_read_config.lo: mibgroup/disman/mteObjectsTable.h
+./agent_read_config.lo: mibgroup/disman/mteEventTable.h
+./agent_read_config.lo: mibgroup/disman/mteEventNotificationTable.h
+./agent_read_config.lo: mibgroup/mibII/kernel_linux.h
+./agent_read_config.lo: mibgroup/mibII/tcpTable.h mibgroup/mibII/ipAddr.h
+./agent_read_config.lo: mibgroup/mibII/var_route.h
+./agent_read_config.lo: mibgroup/mibII/route_write.h
+./agent_read_config.lo: mibgroup/mibII/udpTable.h
+./agent_read_config.lo: mibgroup/mibII/vacm_context.h
+./agent_read_config.lo: mibgroup/header_complex.h mibgroup/agentx/protocol.h
+./agent_read_config.lo: mibgroup/agentx/client.h
+./agent_read_config.lo: mibgroup/agentx/master_admin.h
+./agent_read_config.lo: mibgroup/agentx/agentx_config.h
+./agent_read_config.lo: ./mibgroup/mib_module_dot_conf.h
+./agent_registry.lo: ../include/net-snmp/net-snmp-config.h
+./agent_registry.lo: ../include/net-snmp/system/linux.h
+./agent_registry.lo: ../include/net-snmp/system/sysv.h
+./agent_registry.lo: ../include/net-snmp/system/generic.h
+./agent_registry.lo: ../include/net-snmp/machine/generic.h
+./agent_registry.lo: ../include/net-snmp/net-snmp-includes.h
+./agent_registry.lo: ../include/net-snmp/definitions.h
+./agent_registry.lo: ../include/net-snmp/types.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_api.h
+./agent_registry.lo: ../include/net-snmp/library/asn1.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_impl.h
+./agent_registry.lo: ../include/net-snmp/library/snmp.h
+./agent_registry.lo: ../include/net-snmp/library/snmp-tc.h
+./agent_registry.lo: ../include/net-snmp/utilities.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_client.h
+./agent_registry.lo: ../include/net-snmp/library/getopt.h
+./agent_registry.lo: ../include/net-snmp/library/system.h
+./agent_registry.lo: ../include/net-snmp/library/tools.h
+./agent_registry.lo: ../include/net-snmp/library/int64.h
+./agent_registry.lo: ../include/net-snmp/library/mt_support.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_alarm.h
+./agent_registry.lo: ../include/net-snmp/library/data_list.h
+./agent_registry.lo: ../include/net-snmp/library/callback.h
+./agent_registry.lo: ../include/net-snmp/library/oid_stash.h
+./agent_registry.lo: ../include/net-snmp/library/check_varbind.h
+./agent_registry.lo: ../include/net-snmp/version.h
+./agent_registry.lo: ../include/net-snmp/session_api.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_transport.h
+./agent_registry.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./agent_registry.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./agent_registry.lo: ../include/net-snmp/library/ucd_compat.h
+./agent_registry.lo: ../include/net-snmp/pdu_api.h
+./agent_registry.lo: ../include/net-snmp/mib_api.h
+./agent_registry.lo: ../include/net-snmp/library/mib.h
+./agent_registry.lo: ../include/net-snmp/library/parse.h
+./agent_registry.lo: ../include/net-snmp/varbind_api.h
+./agent_registry.lo: ../include/net-snmp/config_api.h
+./agent_registry.lo: ../include/net-snmp/library/read_config.h
+./agent_registry.lo: ../include/net-snmp/library/default_store.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_parse_args.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_enum.h
+./agent_registry.lo: ../include/net-snmp/library/vacm.h
+./agent_registry.lo: ../include/net-snmp/output_api.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_debug.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_logging.h
+./agent_registry.lo: ../include/net-snmp/snmpv3_api.h
+./agent_registry.lo: ../include/net-snmp/library/snmpv3.h
+./agent_registry.lo: ../include/net-snmp/library/transform_oids.h
+./agent_registry.lo: ../include/net-snmp/library/keytools.h
+./agent_registry.lo: ../include/net-snmp/library/scapi.h
+./agent_registry.lo: ../include/net-snmp/library/lcd_time.h
+./agent_registry.lo: ../include/net-snmp/library/snmp_secmod.h
+./agent_registry.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./agent_registry.lo: ../include/net-snmp/library/snmpusm.h
+./agent_registry.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./agent_registry.lo: ../include/net-snmp/agent/snmp_agent.h
+./agent_registry.lo: ../include/net-snmp/agent/snmp_vars.h
+./agent_registry.lo: ../include/net-snmp/agent/agent_handler.h
+./agent_registry.lo: ../include/net-snmp/agent/var_struct.h
+./agent_registry.lo: ../include/net-snmp/agent/agent_registry.h
+./agent_registry.lo: ../include/net-snmp/agent/ds_agent.h
+./agent_registry.lo: ../include/net-snmp/agent/agent_read_config.h
+./agent_registry.lo: ../include/net-snmp/agent/agent_trap.h
+./agent_registry.lo: ../include/net-snmp/agent/all_helpers.h
+./agent_registry.lo: ../include/net-snmp/agent/instance.h
+./agent_registry.lo: ../include/net-snmp/agent/multiplexer.h
+./agent_registry.lo: ../include/net-snmp/agent/null.h
+./agent_registry.lo: ../include/net-snmp/agent/debug_handler.h
+./agent_registry.lo: ../include/net-snmp/agent/old_api.h
+./agent_registry.lo: ../include/net-snmp/agent/read_only.h
+./agent_registry.lo: ../include/net-snmp/agent/serialize.h
+./agent_registry.lo: ../include/net-snmp/agent/bulk_to_next.h
+./agent_registry.lo: ../include/net-snmp/agent/mode_end_call.h
+./agent_registry.lo: ../include/net-snmp/agent/table.h
+./agent_registry.lo: ../include/net-snmp/agent/table_data.h
+./agent_registry.lo: ../include/net-snmp/agent/table_dataset.h
+./agent_registry.lo: ../include/net-snmp/agent/table_iterator.h
+./agent_registry.lo: ../include/net-snmp/agent/mib_module_config.h
+./agent_registry.lo: ../include/net-snmp/agent/agent_callbacks.h snmpd.h
+./agent_registry.lo: mibgroup/struct.h ./mibgroup/mib_module_includes.h
+./agent_registry.lo: mibgroup/mibII.h mibgroup/ucd_snmp.h
+./agent_registry.lo: mibgroup/snmpv3mibs.h mibgroup/notification.h
+./agent_registry.lo: mibgroup/target.h mibgroup/agent_mibs.h
+./agent_registry.lo: mibgroup/agentx.h mibgroup/utilities.h mibgroup/host.h
+./agent_registry.lo: mibgroup/examples.h mibgroup/examples/example.h
+./agent_registry.lo: mibgroup/testhandler.h mibgroup/smux.h mibgroup/Rmon.h
+./agent_registry.lo: mibgroup/disman/event-mib.h mibgroup/mibII/system_mib.h
+./agent_registry.lo: mibgroup/mibII/sysORTable.h mibgroup/mibII/at.h
+./agent_registry.lo: mibgroup/mibII/interfaces.h mibgroup/mibII/snmp_mib.h
+./agent_registry.lo: mibgroup/mibII/tcp.h mibgroup/mibII/icmp.h
+./agent_registry.lo: mibgroup/mibII/ip.h mibgroup/mibII/var_route.h
+./agent_registry.lo: mibgroup/mibII/route_write.h mibgroup/mibII/at.h
+./agent_registry.lo: mibgroup/mibII/udp.h mibgroup/mibII/vacm_vars.h
+./agent_registry.lo: mibgroup/mibII/setSerialNo.h mibgroup/ucd-snmp/memory.h
+./agent_registry.lo: ./mibgroup/mibdefs.h mibgroup/ucd-snmp/vmstat.h
+./agent_registry.lo: mibgroup/ucd-snmp/proc.h mibgroup/ucd-snmp/versioninfo.h
+./agent_registry.lo: mibgroup/ucd-snmp/pass.h
+./agent_registry.lo: mibgroup/ucd-snmp/pass_persist.h
+./agent_registry.lo: mibgroup/ucd-snmp/disk.h mibgroup/ucd-snmp/loadave.h
+./agent_registry.lo: mibgroup/ucd-snmp/extensible.h
+./agent_registry.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./agent_registry.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./agent_registry.lo: mibgroup/snmpv3/snmpEngine.h
+./agent_registry.lo: mibgroup/snmpv3/snmpMPDStats.h
+./agent_registry.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./agent_registry.lo: mibgroup/notification/snmpNotifyTable.h
+./agent_registry.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./agent_registry.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./agent_registry.lo: mibgroup/target/snmpTargetAddrEntry.h
+./agent_registry.lo: mibgroup/target/snmpTargetParamsEntry.h
+./agent_registry.lo: mibgroup/target/target.h
+./agent_registry.lo: mibgroup/target/target_counters.h
+./agent_registry.lo: mibgroup/agent/nsTransactionTable.h
+./agent_registry.lo: mibgroup/agent/nsModuleTable.h mibgroup/agentx/master.h
+./agent_registry.lo: mibgroup/agentx/subagent.h mibgroup/utilities/override.h
+./agent_registry.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./agent_registry.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./agent_registry.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./agent_registry.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./agent_registry.lo: mibgroup/host/hr_partition.h mibgroup/host/hr_filesys.h
+./agent_registry.lo: mibgroup/host/hr_swrun.h mibgroup/host/hr_swinst.h
+./agent_registry.lo: mibgroup/examples/scalar_int.h
+./agent_registry.lo: mibgroup/examples/data_set.h
+./agent_registry.lo: mibgroup/examples/delayed_instance.h
+./agent_registry.lo: mibgroup/util_funcs.h mibgroup/struct.h
+./agent_registry.lo: mibgroup/smux/smux.h mibgroup/Rmon/rows.h
+./agent_registry.lo: mibgroup/Rmon/agutil.h mibgroup/Rmon/statistics.h
+./agent_registry.lo: mibgroup/Rmon/alarm.h mibgroup/Rmon/history.h
+./agent_registry.lo: mibgroup/Rmon/event.h mibgroup/disman/mteTriggerTable.h
+./agent_registry.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./agent_registry.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./agent_registry.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./agent_registry.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./agent_registry.lo: mibgroup/disman/mteObjectsTable.h
+./agent_registry.lo: mibgroup/disman/mteEventTable.h
+./agent_registry.lo: mibgroup/disman/mteEventNotificationTable.h
+./agent_registry.lo: mibgroup/mibII/kernel_linux.h mibgroup/mibII/tcpTable.h
+./agent_registry.lo: mibgroup/mibII/ipAddr.h mibgroup/mibII/var_route.h
+./agent_registry.lo: mibgroup/mibII/route_write.h mibgroup/mibII/udpTable.h
+./agent_registry.lo: mibgroup/mibII/vacm_context.h mibgroup/header_complex.h
+./agent_registry.lo: mibgroup/agentx/protocol.h mibgroup/agentx/client.h
+./agent_registry.lo: mibgroup/agentx/master_admin.h
+./agent_registry.lo: mibgroup/agentx/agentx_config.h
+./agent_registry.lo: ./mibgroup/agentx/subagent.h ./mibgroup/agentx/client.h
+./agent_trap.lo: ../include/net-snmp/net-snmp-config.h
+./agent_trap.lo: ../include/net-snmp/system/linux.h
+./agent_trap.lo: ../include/net-snmp/system/sysv.h
+./agent_trap.lo: ../include/net-snmp/system/generic.h
+./agent_trap.lo: ../include/net-snmp/machine/generic.h 
+./agent_trap.lo: ../include/net-snmp/utilities.h ../include/net-snmp/types.h
+./agent_trap.lo: ../include/net-snmp/definitions.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_api.h
+./agent_trap.lo: ../include/net-snmp/library/asn1.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_impl.h
+./agent_trap.lo: ../include/net-snmp/library/snmp.h
+./agent_trap.lo: ../include/net-snmp/library/snmp-tc.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_client.h
+./agent_trap.lo: ../include/net-snmp/library/getopt.h
+./agent_trap.lo: ../include/net-snmp/library/system.h
+./agent_trap.lo: ../include/net-snmp/library/tools.h
+./agent_trap.lo: ../include/net-snmp/library/int64.h
+./agent_trap.lo: ../include/net-snmp/library/mt_support.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_alarm.h
+./agent_trap.lo: ../include/net-snmp/library/data_list.h
+./agent_trap.lo: ../include/net-snmp/library/callback.h
+./agent_trap.lo: ../include/net-snmp/library/oid_stash.h
+./agent_trap.lo: ../include/net-snmp/library/check_varbind.h
+./agent_trap.lo: ../include/net-snmp/version.h
+./agent_trap.lo: ../include/net-snmp/net-snmp-includes.h
+./agent_trap.lo: ../include/net-snmp/session_api.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_transport.h
+./agent_trap.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./agent_trap.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./agent_trap.lo: ../include/net-snmp/library/ucd_compat.h
+./agent_trap.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./agent_trap.lo: ../include/net-snmp/library/mib.h
+./agent_trap.lo: ../include/net-snmp/library/parse.h
+./agent_trap.lo: ../include/net-snmp/varbind_api.h
+./agent_trap.lo: ../include/net-snmp/config_api.h
+./agent_trap.lo: ../include/net-snmp/library/read_config.h
+./agent_trap.lo: ../include/net-snmp/library/default_store.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_parse_args.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_enum.h
+./agent_trap.lo: ../include/net-snmp/library/vacm.h
+./agent_trap.lo: ../include/net-snmp/output_api.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_debug.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_logging.h
+./agent_trap.lo: ../include/net-snmp/snmpv3_api.h
+./agent_trap.lo: ../include/net-snmp/library/snmpv3.h
+./agent_trap.lo: ../include/net-snmp/library/transform_oids.h
+./agent_trap.lo: ../include/net-snmp/library/keytools.h
+./agent_trap.lo: ../include/net-snmp/library/scapi.h
+./agent_trap.lo: ../include/net-snmp/library/lcd_time.h
+./agent_trap.lo: ../include/net-snmp/library/snmp_secmod.h
+./agent_trap.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./agent_trap.lo: ../include/net-snmp/library/snmpusm.h
+./agent_trap.lo: ../include/net-snmp/agent/agent_trap.h
+./agent_trap.lo: ../include/net-snmp/agent/snmp_agent.h
+./agent_trap.lo: ../include/net-snmp/agent/agent_callbacks.h
+./agent_trap.lo: ../include/net-snmp/agent/mib_module_config.h
+./auto_nlist.lo: ../include/net-snmp/net-snmp-config.h
+./auto_nlist.lo: ../include/net-snmp/system/linux.h
+./auto_nlist.lo: ../include/net-snmp/system/sysv.h
+./auto_nlist.lo: ../include/net-snmp/system/generic.h
+./auto_nlist.lo: ../include/net-snmp/machine/generic.h
+./kernel.lo: ../include/net-snmp/net-snmp-config.h
+./kernel.lo: ../include/net-snmp/system/linux.h
+./kernel.lo: ../include/net-snmp/system/sysv.h
+./kernel.lo: ../include/net-snmp/system/generic.h
+./kernel.lo: ../include/net-snmp/machine/generic.h
+./mib_modules.lo: ../include/net-snmp/agent/mib_module_config.h
+./mib_modules.lo: ../include/net-snmp/net-snmp-config.h
+./mib_modules.lo: ../include/net-snmp/system/linux.h
+./mib_modules.lo: ../include/net-snmp/system/sysv.h
+./mib_modules.lo: ../include/net-snmp/system/generic.h
+./mib_modules.lo: ../include/net-snmp/machine/generic.h 
+./mib_modules.lo: ../include/net-snmp/net-snmp-includes.h
+./mib_modules.lo: ../include/net-snmp/definitions.h
+./mib_modules.lo: ../include/net-snmp/types.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_api.h
+./mib_modules.lo: ../include/net-snmp/library/asn1.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_impl.h
+./mib_modules.lo: ../include/net-snmp/library/snmp.h
+./mib_modules.lo: ../include/net-snmp/library/snmp-tc.h
+./mib_modules.lo: ../include/net-snmp/utilities.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_client.h
+./mib_modules.lo: ../include/net-snmp/library/getopt.h
+./mib_modules.lo: ../include/net-snmp/library/system.h
+./mib_modules.lo: ../include/net-snmp/library/tools.h
+./mib_modules.lo: ../include/net-snmp/library/int64.h
+./mib_modules.lo: ../include/net-snmp/library/mt_support.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_alarm.h
+./mib_modules.lo: ../include/net-snmp/library/data_list.h
+./mib_modules.lo: ../include/net-snmp/library/callback.h
+./mib_modules.lo: ../include/net-snmp/library/oid_stash.h
+./mib_modules.lo: ../include/net-snmp/library/check_varbind.h
+./mib_modules.lo: ../include/net-snmp/version.h
+./mib_modules.lo: ../include/net-snmp/session_api.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_transport.h
+./mib_modules.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./mib_modules.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./mib_modules.lo: ../include/net-snmp/library/ucd_compat.h
+./mib_modules.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./mib_modules.lo: ../include/net-snmp/library/mib.h
+./mib_modules.lo: ../include/net-snmp/library/parse.h
+./mib_modules.lo: ../include/net-snmp/varbind_api.h
+./mib_modules.lo: ../include/net-snmp/config_api.h
+./mib_modules.lo: ../include/net-snmp/library/read_config.h
+./mib_modules.lo: ../include/net-snmp/library/default_store.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_parse_args.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_enum.h
+./mib_modules.lo: ../include/net-snmp/library/vacm.h
+./mib_modules.lo: ../include/net-snmp/output_api.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_debug.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_logging.h
+./mib_modules.lo: ../include/net-snmp/snmpv3_api.h
+./mib_modules.lo: ../include/net-snmp/library/snmpv3.h
+./mib_modules.lo: ../include/net-snmp/library/transform_oids.h
+./mib_modules.lo: ../include/net-snmp/library/keytools.h
+./mib_modules.lo: ../include/net-snmp/library/scapi.h
+./mib_modules.lo: ../include/net-snmp/library/lcd_time.h
+./mib_modules.lo: ../include/net-snmp/library/snmp_secmod.h
+./mib_modules.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./mib_modules.lo: ../include/net-snmp/library/snmpusm.h
+./mib_modules.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./mib_modules.lo: ../include/net-snmp/agent/snmp_agent.h
+./mib_modules.lo: ../include/net-snmp/agent/snmp_vars.h
+./mib_modules.lo: ../include/net-snmp/agent/agent_handler.h
+./mib_modules.lo: ../include/net-snmp/agent/var_struct.h
+./mib_modules.lo: ../include/net-snmp/agent/agent_registry.h
+./mib_modules.lo: ../include/net-snmp/agent/ds_agent.h
+./mib_modules.lo: ../include/net-snmp/agent/agent_read_config.h
+./mib_modules.lo: ../include/net-snmp/agent/agent_trap.h
+./mib_modules.lo: ../include/net-snmp/agent/all_helpers.h
+./mib_modules.lo: ../include/net-snmp/agent/instance.h
+./mib_modules.lo: ../include/net-snmp/agent/multiplexer.h
+./mib_modules.lo: ../include/net-snmp/agent/null.h
+./mib_modules.lo: ../include/net-snmp/agent/debug_handler.h
+./mib_modules.lo: ../include/net-snmp/agent/old_api.h
+./mib_modules.lo: ../include/net-snmp/agent/read_only.h
+./mib_modules.lo: ../include/net-snmp/agent/serialize.h
+./mib_modules.lo: ../include/net-snmp/agent/bulk_to_next.h
+./mib_modules.lo: ../include/net-snmp/agent/mode_end_call.h
+./mib_modules.lo: ../include/net-snmp/agent/table.h
+./mib_modules.lo: ../include/net-snmp/agent/table_data.h
+./mib_modules.lo: ../include/net-snmp/agent/table_dataset.h
+./mib_modules.lo: ../include/net-snmp/agent/table_iterator.h m2m.h
+./mib_modules.lo: mibgroup/struct.h ../include/net-snmp/agent/mib_modules.h
+./mib_modules.lo: ./mibgroup/mib_module_includes.h mibgroup/mibII.h
+./mib_modules.lo: mibgroup/ucd_snmp.h mibgroup/snmpv3mibs.h
+./mib_modules.lo: mibgroup/notification.h mibgroup/target.h
+./mib_modules.lo: mibgroup/agent_mibs.h mibgroup/agentx.h
+./mib_modules.lo: mibgroup/utilities.h mibgroup/host.h mibgroup/examples.h
+./mib_modules.lo: mibgroup/examples/example.h mibgroup/testhandler.h
+./mib_modules.lo: mibgroup/smux.h mibgroup/Rmon.h mibgroup/disman/event-mib.h
+./mib_modules.lo: mibgroup/mibII/system_mib.h mibgroup/mibII/sysORTable.h
+./mib_modules.lo: mibgroup/mibII/at.h mibgroup/mibII/interfaces.h
+./mib_modules.lo: mibgroup/mibII/snmp_mib.h mibgroup/mibII/tcp.h
+./mib_modules.lo: mibgroup/mibII/icmp.h mibgroup/mibII/ip.h
+./mib_modules.lo: mibgroup/mibII/var_route.h mibgroup/mibII/route_write.h
+./mib_modules.lo: mibgroup/mibII/at.h mibgroup/mibII/udp.h
+./mib_modules.lo: mibgroup/mibII/vacm_vars.h mibgroup/mibII/setSerialNo.h
+./mib_modules.lo: mibgroup/ucd-snmp/memory.h ./mibgroup/mibdefs.h
+./mib_modules.lo: mibgroup/ucd-snmp/vmstat.h mibgroup/ucd-snmp/proc.h
+./mib_modules.lo: mibgroup/ucd-snmp/versioninfo.h mibgroup/ucd-snmp/pass.h
+./mib_modules.lo: mibgroup/ucd-snmp/pass_persist.h mibgroup/ucd-snmp/disk.h
+./mib_modules.lo: mibgroup/ucd-snmp/loadave.h mibgroup/ucd-snmp/extensible.h
+./mib_modules.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./mib_modules.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./mib_modules.lo: mibgroup/snmpv3/snmpEngine.h mibgroup/snmpv3/snmpMPDStats.h
+./mib_modules.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./mib_modules.lo: mibgroup/notification/snmpNotifyTable.h
+./mib_modules.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./mib_modules.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./mib_modules.lo: mibgroup/target/snmpTargetAddrEntry.h
+./mib_modules.lo: mibgroup/target/snmpTargetParamsEntry.h
+./mib_modules.lo: mibgroup/target/target.h mibgroup/target/target_counters.h
+./mib_modules.lo: mibgroup/agent/nsTransactionTable.h
+./mib_modules.lo: mibgroup/agent/nsModuleTable.h mibgroup/agentx/master.h
+./mib_modules.lo: mibgroup/agentx/subagent.h mibgroup/utilities/override.h
+./mib_modules.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./mib_modules.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./mib_modules.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./mib_modules.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./mib_modules.lo: mibgroup/host/hr_partition.h mibgroup/host/hr_filesys.h
+./mib_modules.lo: mibgroup/host/hr_swrun.h mibgroup/host/hr_swinst.h
+./mib_modules.lo: mibgroup/examples/scalar_int.h mibgroup/examples/data_set.h
+./mib_modules.lo: mibgroup/examples/delayed_instance.h mibgroup/util_funcs.h
+./mib_modules.lo: mibgroup/struct.h mibgroup/smux/smux.h mibgroup/Rmon/rows.h
+./mib_modules.lo: mibgroup/Rmon/agutil.h mibgroup/Rmon/statistics.h
+./mib_modules.lo: mibgroup/Rmon/alarm.h mibgroup/Rmon/history.h
+./mib_modules.lo: mibgroup/Rmon/event.h mibgroup/disman/mteTriggerTable.h
+./mib_modules.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./mib_modules.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./mib_modules.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./mib_modules.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./mib_modules.lo: mibgroup/disman/mteObjectsTable.h
+./mib_modules.lo: mibgroup/disman/mteEventTable.h
+./mib_modules.lo: mibgroup/disman/mteEventNotificationTable.h
+./mib_modules.lo: mibgroup/mibII/kernel_linux.h mibgroup/mibII/tcpTable.h
+./mib_modules.lo: mibgroup/mibII/ipAddr.h mibgroup/mibII/var_route.h
+./mib_modules.lo: mibgroup/mibII/route_write.h mibgroup/mibII/udpTable.h
+./mib_modules.lo: mibgroup/mibII/vacm_context.h mibgroup/header_complex.h
+./mib_modules.lo: mibgroup/agentx/protocol.h mibgroup/agentx/client.h
+./mib_modules.lo: mibgroup/agentx/master_admin.h
+./mib_modules.lo: mibgroup/agentx/agentx_config.h
+./mib_modules.lo: ./mibgroup/mib_module_inits.h
+./object_monitor.lo: ../include/net-snmp/net-snmp-config.h
+./object_monitor.lo: ../include/net-snmp/system/linux.h
+./object_monitor.lo: ../include/net-snmp/system/sysv.h
+./object_monitor.lo: ../include/net-snmp/system/generic.h
+./object_monitor.lo: ../include/net-snmp/machine/generic.h
+./object_monitor.lo: ../include/net-snmp/net-snmp-includes.h
+./object_monitor.lo: ../include/net-snmp/definitions.h
+./object_monitor.lo: ../include/net-snmp/types.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_api.h
+./object_monitor.lo: ../include/net-snmp/library/asn1.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_impl.h
+./object_monitor.lo: ../include/net-snmp/library/snmp.h
+./object_monitor.lo: ../include/net-snmp/library/snmp-tc.h
+./object_monitor.lo: ../include/net-snmp/utilities.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_client.h
+./object_monitor.lo: ../include/net-snmp/library/getopt.h
+./object_monitor.lo: ../include/net-snmp/library/system.h
+./object_monitor.lo: ../include/net-snmp/library/tools.h
+./object_monitor.lo: ../include/net-snmp/library/int64.h
+./object_monitor.lo: ../include/net-snmp/library/mt_support.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_alarm.h
+./object_monitor.lo: ../include/net-snmp/library/data_list.h
+./object_monitor.lo: ../include/net-snmp/library/callback.h
+./object_monitor.lo: ../include/net-snmp/library/oid_stash.h
+./object_monitor.lo: ../include/net-snmp/library/check_varbind.h
+./object_monitor.lo: ../include/net-snmp/version.h
+./object_monitor.lo: ../include/net-snmp/session_api.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_transport.h
+./object_monitor.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./object_monitor.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./object_monitor.lo: ../include/net-snmp/library/ucd_compat.h
+./object_monitor.lo: ../include/net-snmp/pdu_api.h
+./object_monitor.lo: ../include/net-snmp/mib_api.h
+./object_monitor.lo: ../include/net-snmp/library/mib.h
+./object_monitor.lo: ../include/net-snmp/library/parse.h
+./object_monitor.lo: ../include/net-snmp/varbind_api.h
+./object_monitor.lo: ../include/net-snmp/config_api.h
+./object_monitor.lo: ../include/net-snmp/library/read_config.h
+./object_monitor.lo: ../include/net-snmp/library/default_store.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_parse_args.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_enum.h
+./object_monitor.lo: ../include/net-snmp/library/vacm.h
+./object_monitor.lo: ../include/net-snmp/output_api.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_debug.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_logging.h
+./object_monitor.lo: ../include/net-snmp/snmpv3_api.h
+./object_monitor.lo: ../include/net-snmp/library/snmpv3.h
+./object_monitor.lo: ../include/net-snmp/library/transform_oids.h
+./object_monitor.lo: ../include/net-snmp/library/keytools.h
+./object_monitor.lo: ../include/net-snmp/library/scapi.h
+./object_monitor.lo: ../include/net-snmp/library/lcd_time.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_secmod.h
+./object_monitor.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./object_monitor.lo: ../include/net-snmp/library/snmpusm.h
+./object_monitor.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./object_monitor.lo: ../include/net-snmp/agent/snmp_agent.h
+./object_monitor.lo: ../include/net-snmp/agent/snmp_vars.h
+./object_monitor.lo: ../include/net-snmp/agent/agent_handler.h
+./object_monitor.lo: ../include/net-snmp/agent/var_struct.h
+./object_monitor.lo: ../include/net-snmp/agent/agent_registry.h
+./object_monitor.lo: ../include/net-snmp/agent/ds_agent.h
+./object_monitor.lo: ../include/net-snmp/agent/agent_read_config.h
+./object_monitor.lo: ../include/net-snmp/agent/agent_trap.h
+./object_monitor.lo: ../include/net-snmp/agent/all_helpers.h
+./object_monitor.lo: ../include/net-snmp/agent/instance.h
+./object_monitor.lo: ../include/net-snmp/agent/multiplexer.h
+./object_monitor.lo: ../include/net-snmp/agent/null.h
+./object_monitor.lo: ../include/net-snmp/agent/debug_handler.h
+./object_monitor.lo: ../include/net-snmp/agent/old_api.h
+./object_monitor.lo: ../include/net-snmp/agent/read_only.h
+./object_monitor.lo: ../include/net-snmp/agent/serialize.h
+./object_monitor.lo: ../include/net-snmp/agent/bulk_to_next.h
+./object_monitor.lo: ../include/net-snmp/agent/mode_end_call.h
+./object_monitor.lo: ../include/net-snmp/agent/table.h
+./object_monitor.lo: ../include/net-snmp/agent/table_data.h
+./object_monitor.lo: ../include/net-snmp/agent/table_dataset.h
+./object_monitor.lo: ../include/net-snmp/agent/table_iterator.h
+./object_monitor.lo: ../include/net-snmp/agent/mib_module_config.h
+./object_monitor.lo: ../include/net-snmp/library/container.h
+./object_monitor.lo: ../include/net-snmp/library/factory.h
+./object_monitor.lo: ../include/net-snmp/library/snmp_assert.h
+./object_monitor.lo: ../include/net-snmp/agent/object_monitor.h
+./snmp_agent.lo: ../include/net-snmp/net-snmp-config.h
+./snmp_agent.lo: ../include/net-snmp/system/linux.h
+./snmp_agent.lo: ../include/net-snmp/system/sysv.h
+./snmp_agent.lo: ../include/net-snmp/system/generic.h
+./snmp_agent.lo: ../include/net-snmp/machine/generic.h
+./snmp_agent.lo: ../include/net-snmp/net-snmp-includes.h 
+./snmp_agent.lo: ../include/net-snmp/definitions.h
+./snmp_agent.lo: ../include/net-snmp/types.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_api.h
+./snmp_agent.lo: ../include/net-snmp/library/asn1.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_impl.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp-tc.h
+./snmp_agent.lo: ../include/net-snmp/utilities.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_client.h
+./snmp_agent.lo: ../include/net-snmp/library/getopt.h
+./snmp_agent.lo: ../include/net-snmp/library/system.h
+./snmp_agent.lo: ../include/net-snmp/library/tools.h
+./snmp_agent.lo: ../include/net-snmp/library/int64.h
+./snmp_agent.lo: ../include/net-snmp/library/mt_support.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_alarm.h
+./snmp_agent.lo: ../include/net-snmp/library/data_list.h
+./snmp_agent.lo: ../include/net-snmp/library/callback.h
+./snmp_agent.lo: ../include/net-snmp/library/oid_stash.h
+./snmp_agent.lo: ../include/net-snmp/library/check_varbind.h
+./snmp_agent.lo: ../include/net-snmp/version.h
+./snmp_agent.lo: ../include/net-snmp/session_api.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_transport.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./snmp_agent.lo: ../include/net-snmp/library/ucd_compat.h
+./snmp_agent.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./snmp_agent.lo: ../include/net-snmp/library/mib.h
+./snmp_agent.lo: ../include/net-snmp/library/parse.h
+./snmp_agent.lo: ../include/net-snmp/varbind_api.h
+./snmp_agent.lo: ../include/net-snmp/config_api.h
+./snmp_agent.lo: ../include/net-snmp/library/read_config.h
+./snmp_agent.lo: ../include/net-snmp/library/default_store.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_parse_args.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_enum.h
+./snmp_agent.lo: ../include/net-snmp/library/vacm.h
+./snmp_agent.lo: ../include/net-snmp/output_api.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_debug.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_logging.h
+./snmp_agent.lo: ../include/net-snmp/snmpv3_api.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpv3.h
+./snmp_agent.lo: ../include/net-snmp/library/transform_oids.h
+./snmp_agent.lo: ../include/net-snmp/library/keytools.h
+./snmp_agent.lo: ../include/net-snmp/library/scapi.h
+./snmp_agent.lo: ../include/net-snmp/library/lcd_time.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_secmod.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./snmp_agent.lo: ../include/net-snmp/library/snmpusm.h
+./snmp_agent.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./snmp_agent.lo: ../include/net-snmp/agent/snmp_agent.h
+./snmp_agent.lo: ../include/net-snmp/agent/snmp_vars.h
+./snmp_agent.lo: ../include/net-snmp/agent/agent_handler.h
+./snmp_agent.lo: ../include/net-snmp/agent/var_struct.h
+./snmp_agent.lo: ../include/net-snmp/agent/agent_registry.h
+./snmp_agent.lo: ../include/net-snmp/agent/ds_agent.h
+./snmp_agent.lo: ../include/net-snmp/agent/agent_read_config.h
+./snmp_agent.lo: ../include/net-snmp/agent/agent_trap.h
+./snmp_agent.lo: ../include/net-snmp/agent/all_helpers.h
+./snmp_agent.lo: ../include/net-snmp/agent/instance.h
+./snmp_agent.lo: ../include/net-snmp/agent/multiplexer.h
+./snmp_agent.lo: ../include/net-snmp/agent/null.h
+./snmp_agent.lo: ../include/net-snmp/agent/debug_handler.h
+./snmp_agent.lo: ../include/net-snmp/agent/old_api.h
+./snmp_agent.lo: ../include/net-snmp/agent/read_only.h
+./snmp_agent.lo: ../include/net-snmp/agent/serialize.h
+./snmp_agent.lo: ../include/net-snmp/agent/bulk_to_next.h
+./snmp_agent.lo: ../include/net-snmp/agent/mode_end_call.h
+./snmp_agent.lo: ../include/net-snmp/agent/table.h
+./snmp_agent.lo: ../include/net-snmp/agent/table_data.h
+./snmp_agent.lo: ../include/net-snmp/agent/table_dataset.h
+./snmp_agent.lo: ../include/net-snmp/agent/table_iterator.h
+./snmp_agent.lo: ../include/net-snmp/agent/mib_module_config.h
+./snmp_agent.lo: ../include/net-snmp/library/snmp_assert.h snmpd.h
+./snmp_agent.lo: mibgroup/struct.h mibgroup/util_funcs.h mibgroup/struct.h
+./snmp_agent.lo: ./mibgroup/agentx/protocol.h ./mibgroup/agentx/master.h
+./snmpd.lo: ../include/net-snmp/net-snmp-config.h
+./snmpd.lo: ../include/net-snmp/system/linux.h
+./snmpd.lo: ../include/net-snmp/system/sysv.h
+./snmpd.lo: ../include/net-snmp/system/generic.h
+./snmpd.lo: ../include/net-snmp/machine/generic.h 
+./snmpd.lo: ../include/net-snmp/net-snmp-includes.h
+./snmpd.lo: ../include/net-snmp/definitions.h ../include/net-snmp/types.h
+./snmpd.lo: ../include/net-snmp/library/snmp_api.h
+./snmpd.lo: ../include/net-snmp/library/asn1.h
+./snmpd.lo: ../include/net-snmp/library/snmp_impl.h
+./snmpd.lo: ../include/net-snmp/library/snmp.h
+./snmpd.lo: ../include/net-snmp/library/snmp-tc.h
+./snmpd.lo: ../include/net-snmp/utilities.h
+./snmpd.lo: ../include/net-snmp/library/snmp_client.h
+./snmpd.lo: ../include/net-snmp/library/getopt.h
+./snmpd.lo: ../include/net-snmp/library/system.h
+./snmpd.lo: ../include/net-snmp/library/tools.h
+./snmpd.lo: ../include/net-snmp/library/int64.h
+./snmpd.lo: ../include/net-snmp/library/mt_support.h
+./snmpd.lo: ../include/net-snmp/library/snmp_alarm.h
+./snmpd.lo: ../include/net-snmp/library/data_list.h
+./snmpd.lo: ../include/net-snmp/library/callback.h
+./snmpd.lo: ../include/net-snmp/library/oid_stash.h
+./snmpd.lo: ../include/net-snmp/library/check_varbind.h
+./snmpd.lo: ../include/net-snmp/version.h ../include/net-snmp/session_api.h
+./snmpd.lo: ../include/net-snmp/library/snmp_transport.h
+./snmpd.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./snmpd.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./snmpd.lo:  ../include/net-snmp/library/snmpUDPDomain.h
+./snmpd.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./snmpd.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./snmpd.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./snmpd.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./snmpd.lo: ../include/net-snmp/library/ucd_compat.h
+./snmpd.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./snmpd.lo: ../include/net-snmp/library/mib.h
+./snmpd.lo: ../include/net-snmp/library/parse.h
+./snmpd.lo: ../include/net-snmp/varbind_api.h
+./snmpd.lo: ../include/net-snmp/config_api.h
+./snmpd.lo: ../include/net-snmp/library/read_config.h
+./snmpd.lo: ../include/net-snmp/library/default_store.h
+./snmpd.lo: ../include/net-snmp/library/snmp_parse_args.h
+./snmpd.lo: ../include/net-snmp/library/snmp_enum.h
+./snmpd.lo: ../include/net-snmp/library/vacm.h
+./snmpd.lo: ../include/net-snmp/output_api.h
+./snmpd.lo: ../include/net-snmp/library/snmp_debug.h
+./snmpd.lo: ../include/net-snmp/library/snmp_logging.h 
+./snmpd.lo:  ../include/net-snmp/snmpv3_api.h
+./snmpd.lo: ../include/net-snmp/library/snmpv3.h
+./snmpd.lo: ../include/net-snmp/library/transform_oids.h
+./snmpd.lo: ../include/net-snmp/library/keytools.h
+./snmpd.lo: ../include/net-snmp/library/scapi.h
+./snmpd.lo: ../include/net-snmp/library/lcd_time.h
+./snmpd.lo: ../include/net-snmp/library/snmp_secmod.h
+./snmpd.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./snmpd.lo: ../include/net-snmp/library/snmpusm.h
+./snmpd.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./snmpd.lo: ../include/net-snmp/agent/snmp_agent.h
+./snmpd.lo: ../include/net-snmp/agent/snmp_vars.h
+./snmpd.lo: ../include/net-snmp/agent/agent_handler.h
+./snmpd.lo: ../include/net-snmp/agent/var_struct.h
+./snmpd.lo: ../include/net-snmp/agent/agent_registry.h
+./snmpd.lo: ../include/net-snmp/agent/ds_agent.h
+./snmpd.lo: ../include/net-snmp/agent/agent_read_config.h
+./snmpd.lo: ../include/net-snmp/agent/agent_trap.h
+./snmpd.lo: ../include/net-snmp/agent/all_helpers.h
+./snmpd.lo: ../include/net-snmp/agent/instance.h
+./snmpd.lo: ../include/net-snmp/agent/multiplexer.h
+./snmpd.lo: ../include/net-snmp/agent/null.h
+./snmpd.lo: ../include/net-snmp/agent/debug_handler.h
+./snmpd.lo: ../include/net-snmp/agent/old_api.h
+./snmpd.lo: ../include/net-snmp/agent/read_only.h
+./snmpd.lo: ../include/net-snmp/agent/serialize.h
+./snmpd.lo: ../include/net-snmp/agent/bulk_to_next.h
+./snmpd.lo: ../include/net-snmp/agent/mode_end_call.h
+./snmpd.lo: ../include/net-snmp/agent/table.h
+./snmpd.lo: ../include/net-snmp/agent/table_data.h
+./snmpd.lo: ../include/net-snmp/agent/table_dataset.h
+./snmpd.lo: ../include/net-snmp/agent/table_iterator.h
+./snmpd.lo: ../include/net-snmp/agent/mib_module_config.h m2m.h snmpd.h
+./snmpd.lo: mibgroup/struct.h ../include/net-snmp/agent/mib_modules.h
+./snmpd.lo: mibgroup/util_funcs.h mibgroup/struct.h
+./snmpd.lo: ./mibgroup/mib_module_includes.h mibgroup/mibII.h
+./snmpd.lo: mibgroup/ucd_snmp.h mibgroup/snmpv3mibs.h mibgroup/notification.h
+./snmpd.lo: mibgroup/target.h mibgroup/agent_mibs.h mibgroup/agentx.h
+./snmpd.lo: mibgroup/utilities.h mibgroup/host.h mibgroup/examples.h
+./snmpd.lo: mibgroup/examples/example.h mibgroup/testhandler.h
+./snmpd.lo: mibgroup/smux.h mibgroup/Rmon.h mibgroup/disman/event-mib.h
+./snmpd.lo: mibgroup/mibII/system_mib.h mibgroup/mibII/sysORTable.h
+./snmpd.lo: mibgroup/mibII/at.h mibgroup/mibII/interfaces.h
+./snmpd.lo: mibgroup/mibII/snmp_mib.h mibgroup/mibII/tcp.h
+./snmpd.lo: mibgroup/mibII/icmp.h mibgroup/mibII/ip.h
+./snmpd.lo: mibgroup/mibII/var_route.h mibgroup/mibII/route_write.h
+./snmpd.lo: mibgroup/mibII/at.h mibgroup/mibII/udp.h
+./snmpd.lo: mibgroup/mibII/vacm_vars.h mibgroup/mibII/setSerialNo.h
+./snmpd.lo: mibgroup/ucd-snmp/memory.h ./mibgroup/mibdefs.h
+./snmpd.lo: mibgroup/ucd-snmp/vmstat.h mibgroup/ucd-snmp/proc.h
+./snmpd.lo: mibgroup/ucd-snmp/versioninfo.h mibgroup/ucd-snmp/pass.h
+./snmpd.lo: mibgroup/ucd-snmp/pass_persist.h mibgroup/ucd-snmp/disk.h
+./snmpd.lo: mibgroup/ucd-snmp/loadave.h mibgroup/ucd-snmp/extensible.h
+./snmpd.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./snmpd.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./snmpd.lo: mibgroup/snmpv3/snmpEngine.h mibgroup/snmpv3/snmpMPDStats.h
+./snmpd.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./snmpd.lo: mibgroup/notification/snmpNotifyTable.h
+./snmpd.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./snmpd.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./snmpd.lo: mibgroup/target/snmpTargetAddrEntry.h
+./snmpd.lo: mibgroup/target/snmpTargetParamsEntry.h mibgroup/target/target.h
+./snmpd.lo: mibgroup/target/target_counters.h
+./snmpd.lo: mibgroup/agent/nsTransactionTable.h
+./snmpd.lo: mibgroup/agent/nsModuleTable.h mibgroup/agentx/master.h
+./snmpd.lo: mibgroup/agentx/subagent.h mibgroup/utilities/override.h
+./snmpd.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./snmpd.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./snmpd.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./snmpd.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./snmpd.lo: mibgroup/host/hr_partition.h mibgroup/host/hr_filesys.h
+./snmpd.lo: mibgroup/host/hr_swrun.h mibgroup/host/hr_swinst.h
+./snmpd.lo: mibgroup/examples/scalar_int.h mibgroup/examples/data_set.h
+./snmpd.lo: mibgroup/examples/delayed_instance.h mibgroup/smux/smux.h
+./snmpd.lo: mibgroup/Rmon/rows.h mibgroup/Rmon/agutil.h
+./snmpd.lo: mibgroup/Rmon/statistics.h mibgroup/Rmon/alarm.h
+./snmpd.lo: mibgroup/Rmon/history.h mibgroup/Rmon/event.h
+./snmpd.lo: mibgroup/disman/mteTriggerTable.h
+./snmpd.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./snmpd.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./snmpd.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./snmpd.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./snmpd.lo: mibgroup/disman/mteObjectsTable.h mibgroup/disman/mteEventTable.h
+./snmpd.lo: mibgroup/disman/mteEventNotificationTable.h
+./snmpd.lo: mibgroup/mibII/kernel_linux.h mibgroup/mibII/tcpTable.h
+./snmpd.lo: mibgroup/mibII/ipAddr.h mibgroup/mibII/var_route.h
+./snmpd.lo: mibgroup/mibII/route_write.h mibgroup/mibII/udpTable.h
+./snmpd.lo: mibgroup/mibII/vacm_context.h mibgroup/header_complex.h
+./snmpd.lo: mibgroup/agentx/protocol.h mibgroup/agentx/client.h
+./snmpd.lo: mibgroup/agentx/master_admin.h mibgroup/agentx/agentx_config.h
+./snmpd.lo: ./mibgroup/mib_module_shutdown.h
+./snmp_perl.lo: ../include/net-snmp/net-snmp-config.h
+./snmp_perl.lo: ../include/net-snmp/system/linux.h
+./snmp_perl.lo: ../include/net-snmp/system/sysv.h
+./snmp_perl.lo: ../include/net-snmp/system/generic.h
+./snmp_perl.lo: ../include/net-snmp/machine/generic.h
+./snmp_perl.lo: ../include/net-snmp/net-snmp-includes.h
+./snmp_perl.lo: ../include/net-snmp/definitions.h ../include/net-snmp/types.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_api.h
+./snmp_perl.lo: ../include/net-snmp/library/asn1.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_impl.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp-tc.h
+./snmp_perl.lo: ../include/net-snmp/utilities.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_client.h
+./snmp_perl.lo: ../include/net-snmp/library/getopt.h
+./snmp_perl.lo: ../include/net-snmp/library/system.h
+./snmp_perl.lo: ../include/net-snmp/library/tools.h
+./snmp_perl.lo: ../include/net-snmp/library/int64.h
+./snmp_perl.lo: ../include/net-snmp/library/mt_support.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_alarm.h
+./snmp_perl.lo: ../include/net-snmp/library/data_list.h
+./snmp_perl.lo: ../include/net-snmp/library/callback.h
+./snmp_perl.lo: ../include/net-snmp/library/oid_stash.h
+./snmp_perl.lo: ../include/net-snmp/library/check_varbind.h
+./snmp_perl.lo: ../include/net-snmp/version.h
+./snmp_perl.lo: ../include/net-snmp/session_api.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_transport.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./snmp_perl.lo: ../include/net-snmp/library/ucd_compat.h
+./snmp_perl.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./snmp_perl.lo: ../include/net-snmp/library/mib.h
+./snmp_perl.lo: ../include/net-snmp/library/parse.h
+./snmp_perl.lo: ../include/net-snmp/varbind_api.h
+./snmp_perl.lo: ../include/net-snmp/config_api.h
+./snmp_perl.lo: ../include/net-snmp/library/read_config.h
+./snmp_perl.lo: ../include/net-snmp/library/default_store.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_parse_args.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_enum.h
+./snmp_perl.lo: ../include/net-snmp/library/vacm.h
+./snmp_perl.lo: ../include/net-snmp/output_api.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_debug.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_logging.h
+./snmp_perl.lo: ../include/net-snmp/snmpv3_api.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpv3.h
+./snmp_perl.lo: ../include/net-snmp/library/transform_oids.h
+./snmp_perl.lo: ../include/net-snmp/library/keytools.h
+./snmp_perl.lo: ../include/net-snmp/library/scapi.h
+./snmp_perl.lo: ../include/net-snmp/library/lcd_time.h
+./snmp_perl.lo: ../include/net-snmp/library/snmp_secmod.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./snmp_perl.lo: ../include/net-snmp/library/snmpusm.h
+./snmp_perl.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./snmp_perl.lo: ../include/net-snmp/agent/snmp_agent.h
+./snmp_perl.lo: ../include/net-snmp/agent/snmp_vars.h
+./snmp_perl.lo: ../include/net-snmp/agent/agent_handler.h
+./snmp_perl.lo: ../include/net-snmp/agent/var_struct.h
+./snmp_perl.lo: ../include/net-snmp/agent/agent_registry.h
+./snmp_perl.lo: ../include/net-snmp/agent/ds_agent.h
+./snmp_perl.lo: ../include/net-snmp/agent/agent_read_config.h
+./snmp_perl.lo: ../include/net-snmp/agent/agent_trap.h
+./snmp_perl.lo: ../include/net-snmp/agent/all_helpers.h
+./snmp_perl.lo: ../include/net-snmp/agent/instance.h
+./snmp_perl.lo: ../include/net-snmp/agent/multiplexer.h
+./snmp_perl.lo: ../include/net-snmp/agent/null.h
+./snmp_perl.lo: ../include/net-snmp/agent/debug_handler.h
+./snmp_perl.lo: ../include/net-snmp/agent/old_api.h
+./snmp_perl.lo: ../include/net-snmp/agent/read_only.h
+./snmp_perl.lo: ../include/net-snmp/agent/serialize.h
+./snmp_perl.lo: ../include/net-snmp/agent/bulk_to_next.h
+./snmp_perl.lo: ../include/net-snmp/agent/mode_end_call.h
+./snmp_perl.lo: ../include/net-snmp/agent/table.h
+./snmp_perl.lo: ../include/net-snmp/agent/table_data.h
+./snmp_perl.lo: ../include/net-snmp/agent/table_dataset.h
+./snmp_perl.lo: ../include/net-snmp/agent/table_iterator.h
+./snmp_perl.lo: ../include/net-snmp/agent/mib_module_config.h
+./snmp_vars.lo: ../include/net-snmp/net-snmp-config.h
+./snmp_vars.lo: ../include/net-snmp/system/linux.h
+./snmp_vars.lo: ../include/net-snmp/system/sysv.h
+./snmp_vars.lo: ../include/net-snmp/system/generic.h
+./snmp_vars.lo: ../include/net-snmp/machine/generic.h 
+./snmp_vars.lo: ../include/net-snmp/net-snmp-includes.h
+./snmp_vars.lo: ../include/net-snmp/definitions.h ../include/net-snmp/types.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_api.h
+./snmp_vars.lo: ../include/net-snmp/library/asn1.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_impl.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp-tc.h
+./snmp_vars.lo: ../include/net-snmp/utilities.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_client.h
+./snmp_vars.lo: ../include/net-snmp/library/getopt.h
+./snmp_vars.lo: ../include/net-snmp/library/system.h
+./snmp_vars.lo: ../include/net-snmp/library/tools.h
+./snmp_vars.lo: ../include/net-snmp/library/int64.h
+./snmp_vars.lo: ../include/net-snmp/library/mt_support.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_alarm.h
+./snmp_vars.lo: ../include/net-snmp/library/data_list.h
+./snmp_vars.lo: ../include/net-snmp/library/callback.h
+./snmp_vars.lo: ../include/net-snmp/library/oid_stash.h
+./snmp_vars.lo: ../include/net-snmp/library/check_varbind.h
+./snmp_vars.lo: ../include/net-snmp/version.h
+./snmp_vars.lo: ../include/net-snmp/session_api.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_transport.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./snmp_vars.lo: ../include/net-snmp/library/ucd_compat.h
+./snmp_vars.lo: ../include/net-snmp/pdu_api.h ../include/net-snmp/mib_api.h
+./snmp_vars.lo: ../include/net-snmp/library/mib.h
+./snmp_vars.lo: ../include/net-snmp/library/parse.h
+./snmp_vars.lo: ../include/net-snmp/varbind_api.h
+./snmp_vars.lo: ../include/net-snmp/config_api.h
+./snmp_vars.lo: ../include/net-snmp/library/read_config.h
+./snmp_vars.lo: ../include/net-snmp/library/default_store.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_parse_args.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_enum.h
+./snmp_vars.lo: ../include/net-snmp/library/vacm.h
+./snmp_vars.lo: ../include/net-snmp/output_api.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_debug.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_logging.h
+./snmp_vars.lo: ../include/net-snmp/snmpv3_api.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpv3.h
+./snmp_vars.lo: ../include/net-snmp/library/transform_oids.h
+./snmp_vars.lo: ../include/net-snmp/library/keytools.h
+./snmp_vars.lo: ../include/net-snmp/library/scapi.h
+./snmp_vars.lo: ../include/net-snmp/library/lcd_time.h
+./snmp_vars.lo: ../include/net-snmp/library/snmp_secmod.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./snmp_vars.lo: ../include/net-snmp/library/snmpusm.h
+./snmp_vars.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./snmp_vars.lo: ../include/net-snmp/agent/snmp_agent.h
+./snmp_vars.lo: ../include/net-snmp/agent/snmp_vars.h
+./snmp_vars.lo: ../include/net-snmp/agent/agent_handler.h
+./snmp_vars.lo: ../include/net-snmp/agent/var_struct.h
+./snmp_vars.lo: ../include/net-snmp/agent/agent_registry.h
+./snmp_vars.lo: ../include/net-snmp/agent/ds_agent.h
+./snmp_vars.lo: ../include/net-snmp/agent/agent_read_config.h
+./snmp_vars.lo: ../include/net-snmp/agent/agent_trap.h
+./snmp_vars.lo: ../include/net-snmp/agent/all_helpers.h
+./snmp_vars.lo: ../include/net-snmp/agent/instance.h
+./snmp_vars.lo: ../include/net-snmp/agent/multiplexer.h
+./snmp_vars.lo: ../include/net-snmp/agent/null.h
+./snmp_vars.lo: ../include/net-snmp/agent/debug_handler.h
+./snmp_vars.lo: ../include/net-snmp/agent/old_api.h
+./snmp_vars.lo: ../include/net-snmp/agent/read_only.h
+./snmp_vars.lo: ../include/net-snmp/agent/serialize.h
+./snmp_vars.lo: ../include/net-snmp/agent/bulk_to_next.h
+./snmp_vars.lo: ../include/net-snmp/agent/mode_end_call.h
+./snmp_vars.lo: ../include/net-snmp/agent/table.h
+./snmp_vars.lo: ../include/net-snmp/agent/table_data.h
+./snmp_vars.lo: ../include/net-snmp/agent/table_dataset.h
+./snmp_vars.lo: ../include/net-snmp/agent/table_iterator.h
+./snmp_vars.lo: ../include/net-snmp/agent/mib_module_config.h kernel.h
+./snmp_vars.lo: mibgroup/struct.h snmpd.h ./mibgroup/mib_module_includes.h
+./snmp_vars.lo: mibgroup/mibII.h mibgroup/ucd_snmp.h mibgroup/snmpv3mibs.h
+./snmp_vars.lo: mibgroup/notification.h mibgroup/target.h
+./snmp_vars.lo: mibgroup/agent_mibs.h mibgroup/agentx.h mibgroup/utilities.h
+./snmp_vars.lo: mibgroup/host.h mibgroup/examples.h
+./snmp_vars.lo: mibgroup/examples/example.h mibgroup/testhandler.h
+./snmp_vars.lo: mibgroup/smux.h mibgroup/Rmon.h mibgroup/disman/event-mib.h
+./snmp_vars.lo: mibgroup/mibII/system_mib.h mibgroup/mibII/sysORTable.h
+./snmp_vars.lo: mibgroup/mibII/at.h mibgroup/mibII/interfaces.h
+./snmp_vars.lo: mibgroup/mibII/snmp_mib.h mibgroup/mibII/tcp.h
+./snmp_vars.lo: mibgroup/mibII/icmp.h mibgroup/mibII/ip.h
+./snmp_vars.lo: mibgroup/mibII/var_route.h mibgroup/mibII/route_write.h
+./snmp_vars.lo: mibgroup/mibII/at.h mibgroup/mibII/udp.h
+./snmp_vars.lo: mibgroup/mibII/vacm_vars.h mibgroup/mibII/setSerialNo.h
+./snmp_vars.lo: mibgroup/ucd-snmp/memory.h ./mibgroup/mibdefs.h
+./snmp_vars.lo: mibgroup/ucd-snmp/vmstat.h mibgroup/ucd-snmp/proc.h
+./snmp_vars.lo: mibgroup/ucd-snmp/versioninfo.h mibgroup/ucd-snmp/pass.h
+./snmp_vars.lo: mibgroup/ucd-snmp/pass_persist.h mibgroup/ucd-snmp/disk.h
+./snmp_vars.lo: mibgroup/ucd-snmp/loadave.h mibgroup/ucd-snmp/extensible.h
+./snmp_vars.lo: mibgroup/ucd-snmp/errormib.h mibgroup/ucd-snmp/file.h
+./snmp_vars.lo: mibgroup/ucd-snmp/dlmod.h mibgroup/ucd-snmp/proxy.h
+./snmp_vars.lo: mibgroup/snmpv3/snmpEngine.h mibgroup/snmpv3/snmpMPDStats.h
+./snmp_vars.lo: mibgroup/snmpv3/usmStats.h mibgroup/snmpv3/usmUser.h
+./snmp_vars.lo: mibgroup/notification/snmpNotifyTable.h
+./snmp_vars.lo: mibgroup/notification/snmpNotifyFilterTable.h
+./snmp_vars.lo: mibgroup/notification/snmpNotifyFilterProfileTable.h
+./snmp_vars.lo: mibgroup/target/snmpTargetAddrEntry.h
+./snmp_vars.lo: mibgroup/target/snmpTargetParamsEntry.h
+./snmp_vars.lo: mibgroup/target/target.h mibgroup/target/target_counters.h
+./snmp_vars.lo: mibgroup/agent/nsTransactionTable.h
+./snmp_vars.lo: mibgroup/agent/nsModuleTable.h mibgroup/agentx/master.h
+./snmp_vars.lo: mibgroup/agentx/subagent.h mibgroup/utilities/override.h
+./snmp_vars.lo: mibgroup/host/hr_system.h mibgroup/host/hr_storage.h
+./snmp_vars.lo: mibgroup/host/hr_device.h mibgroup/host/hr_other.h
+./snmp_vars.lo: mibgroup/host/hr_proc.h mibgroup/host/hr_network.h
+./snmp_vars.lo: mibgroup/host/hr_print.h mibgroup/host/hr_disk.h
+./snmp_vars.lo: mibgroup/host/hr_partition.h mibgroup/host/hr_filesys.h
+./snmp_vars.lo: mibgroup/host/hr_swrun.h mibgroup/host/hr_swinst.h
+./snmp_vars.lo: mibgroup/examples/scalar_int.h mibgroup/examples/data_set.h
+./snmp_vars.lo: mibgroup/examples/delayed_instance.h mibgroup/util_funcs.h
+./snmp_vars.lo: mibgroup/struct.h mibgroup/smux/smux.h mibgroup/Rmon/rows.h
+./snmp_vars.lo: mibgroup/Rmon/agutil.h mibgroup/Rmon/statistics.h
+./snmp_vars.lo: mibgroup/Rmon/alarm.h mibgroup/Rmon/history.h
+./snmp_vars.lo: mibgroup/Rmon/event.h mibgroup/disman/mteTriggerTable.h
+./snmp_vars.lo: mibgroup/disman/mteTriggerDeltaTable.h
+./snmp_vars.lo: mibgroup/disman/mteTriggerExistenceTable.h
+./snmp_vars.lo: mibgroup/disman/mteTriggerBooleanTable.h
+./snmp_vars.lo: mibgroup/disman/mteTriggerThresholdTable.h
+./snmp_vars.lo: mibgroup/disman/mteObjectsTable.h
+./snmp_vars.lo: mibgroup/disman/mteEventTable.h
+./snmp_vars.lo: mibgroup/disman/mteEventNotificationTable.h
+./snmp_vars.lo: mibgroup/mibII/kernel_linux.h mibgroup/mibII/tcpTable.h
+./snmp_vars.lo: mibgroup/mibII/ipAddr.h mibgroup/mibII/var_route.h
+./snmp_vars.lo: mibgroup/mibII/route_write.h mibgroup/mibII/udpTable.h
+./snmp_vars.lo: mibgroup/mibII/vacm_context.h mibgroup/header_complex.h
+./snmp_vars.lo: mibgroup/agentx/protocol.h mibgroup/agentx/client.h
+./snmp_vars.lo: mibgroup/agentx/master_admin.h
+./snmp_vars.lo: mibgroup/agentx/agentx_config.h
+./snmp_vars.lo: ../include/net-snmp/library/container.h
+./snmp_vars.lo: ../include/net-snmp/library/factory.h
+./helpers/all_helpers.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/all_helpers.lo: ../include/net-snmp/system/linux.h
+./helpers/all_helpers.lo: ../include/net-snmp/system/sysv.h
+./helpers/all_helpers.lo: ../include/net-snmp/system/generic.h
+./helpers/all_helpers.lo: ../include/net-snmp/machine/generic.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/system/linux.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/system/sysv.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/system/generic.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/machine/generic.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/definitions.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/types.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/asn1.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/utilities.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/getopt.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/system.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/tools.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/int64.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/mt_support.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/data_list.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/callback.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/version.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/session_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/pdu_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/mib_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/mib.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/parse.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/varbind_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/config_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/read_config.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/default_store.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/vacm.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/output_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/keytools.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/scapi.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/instance.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/null.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/old_api.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/read_only.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/serialize.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/table.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/table_data.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/bulk_to_next.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/debug_handler.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/debug_handler.lo: ../include/net-snmp/system/linux.h
+./helpers/debug_handler.lo: ../include/net-snmp/system/sysv.h
+./helpers/debug_handler.lo: ../include/net-snmp/system/generic.h
+./helpers/debug_handler.lo: ../include/net-snmp/machine/generic.h
+./helpers/debug_handler.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/debug_handler.lo: ../include/net-snmp/definitions.h
+./helpers/debug_handler.lo: ../include/net-snmp/types.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/asn1.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/debug_handler.lo: ../include/net-snmp/utilities.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/getopt.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/system.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/tools.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/int64.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/mt_support.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/data_list.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/callback.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/debug_handler.lo: ../include/net-snmp/version.h
+./helpers/debug_handler.lo: ../include/net-snmp/session_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/debug_handler.lo: ../include/net-snmp/pdu_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/mib_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/mib.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/parse.h
+./helpers/debug_handler.lo: ../include/net-snmp/varbind_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/config_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/read_config.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/default_store.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/vacm.h
+./helpers/debug_handler.lo: ../include/net-snmp/output_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/debug_handler.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/keytools.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/scapi.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/debug_handler.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/instance.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/null.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/old_api.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/read_only.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/serialize.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/table.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/table_data.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/debug_handler.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/instance.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/instance.lo: ../include/net-snmp/system/linux.h
+./helpers/instance.lo: ../include/net-snmp/system/sysv.h
+./helpers/instance.lo: ../include/net-snmp/system/generic.h
+./helpers/instance.lo: ../include/net-snmp/machine/generic.h
+./helpers/instance.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/instance.lo: ../include/net-snmp/definitions.h
+./helpers/instance.lo: ../include/net-snmp/types.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/instance.lo: ../include/net-snmp/library/asn1.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/instance.lo: ../include/net-snmp/utilities.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/instance.lo: ../include/net-snmp/library/getopt.h
+./helpers/instance.lo: ../include/net-snmp/library/system.h
+./helpers/instance.lo: ../include/net-snmp/library/tools.h
+./helpers/instance.lo: ../include/net-snmp/library/int64.h
+./helpers/instance.lo: ../include/net-snmp/library/mt_support.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/instance.lo: ../include/net-snmp/library/data_list.h
+./helpers/instance.lo: ../include/net-snmp/library/callback.h
+./helpers/instance.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/instance.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/instance.lo: ../include/net-snmp/version.h
+./helpers/instance.lo: ../include/net-snmp/session_api.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/instance.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/instance.lo: ../include/net-snmp/pdu_api.h
+./helpers/instance.lo: ../include/net-snmp/mib_api.h
+./helpers/instance.lo: ../include/net-snmp/library/mib.h
+./helpers/instance.lo: ../include/net-snmp/library/parse.h
+./helpers/instance.lo: ../include/net-snmp/varbind_api.h
+./helpers/instance.lo: ../include/net-snmp/config_api.h
+./helpers/instance.lo: ../include/net-snmp/library/read_config.h
+./helpers/instance.lo: ../include/net-snmp/library/default_store.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/instance.lo: ../include/net-snmp/library/vacm.h
+./helpers/instance.lo: ../include/net-snmp/output_api.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/instance.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/instance.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/instance.lo: ../include/net-snmp/library/keytools.h
+./helpers/instance.lo: ../include/net-snmp/library/scapi.h
+./helpers/instance.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/instance.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/instance.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/instance.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/instance.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/instance.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/instance.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/instance.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/instance.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/instance.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/instance.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/instance.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/instance.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/instance.lo: ../include/net-snmp/agent/instance.h
+./helpers/instance.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/instance.lo: ../include/net-snmp/agent/null.h
+./helpers/instance.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/instance.lo: ../include/net-snmp/agent/old_api.h
+./helpers/instance.lo: ../include/net-snmp/agent/read_only.h
+./helpers/instance.lo: ../include/net-snmp/agent/serialize.h
+./helpers/instance.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/instance.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/instance.lo: ../include/net-snmp/agent/table.h
+./helpers/instance.lo: ../include/net-snmp/agent/table_data.h
+./helpers/instance.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/instance.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/instance.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/mode_end_call.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/mode_end_call.lo: ../include/net-snmp/system/linux.h
+./helpers/mode_end_call.lo: ../include/net-snmp/system/sysv.h
+./helpers/mode_end_call.lo: ../include/net-snmp/system/generic.h
+./helpers/mode_end_call.lo: ../include/net-snmp/machine/generic.h
+./helpers/mode_end_call.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/mode_end_call.lo: ../include/net-snmp/definitions.h
+./helpers/mode_end_call.lo: ../include/net-snmp/types.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/asn1.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/mode_end_call.lo: ../include/net-snmp/utilities.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/getopt.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/system.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/tools.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/int64.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/mt_support.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/data_list.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/callback.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/mode_end_call.lo: ../include/net-snmp/version.h
+./helpers/mode_end_call.lo: ../include/net-snmp/session_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/mode_end_call.lo: ../include/net-snmp/pdu_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/mib_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/mib.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/parse.h
+./helpers/mode_end_call.lo: ../include/net-snmp/varbind_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/config_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/read_config.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/default_store.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/vacm.h
+./helpers/mode_end_call.lo: ../include/net-snmp/output_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/mode_end_call.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/keytools.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/scapi.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/mode_end_call.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/instance.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/null.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/old_api.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/read_only.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/serialize.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/table.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/table_data.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/mode_end_call.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/multiplexer.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/multiplexer.lo: ../include/net-snmp/system/linux.h
+./helpers/multiplexer.lo: ../include/net-snmp/system/sysv.h
+./helpers/multiplexer.lo: ../include/net-snmp/system/generic.h
+./helpers/multiplexer.lo: ../include/net-snmp/machine/generic.h
+./helpers/multiplexer.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/multiplexer.lo: ../include/net-snmp/definitions.h
+./helpers/multiplexer.lo: ../include/net-snmp/types.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/asn1.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/multiplexer.lo: ../include/net-snmp/utilities.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/getopt.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/system.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/tools.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/int64.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/mt_support.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/data_list.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/callback.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/multiplexer.lo: ../include/net-snmp/version.h
+./helpers/multiplexer.lo: ../include/net-snmp/session_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/multiplexer.lo: ../include/net-snmp/pdu_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/mib_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/mib.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/parse.h
+./helpers/multiplexer.lo: ../include/net-snmp/varbind_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/config_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/read_config.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/default_store.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/vacm.h
+./helpers/multiplexer.lo: ../include/net-snmp/output_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/multiplexer.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/keytools.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/scapi.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/multiplexer.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/instance.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/null.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/old_api.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/read_only.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/serialize.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/table.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/table_data.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/multiplexer.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/null.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/null.lo: ../include/net-snmp/system/linux.h
+./helpers/null.lo: ../include/net-snmp/system/sysv.h
+./helpers/null.lo: ../include/net-snmp/system/generic.h
+./helpers/null.lo: ../include/net-snmp/machine/generic.h
+./helpers/null.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/null.lo:  ../include/net-snmp/definitions.h
+./helpers/null.lo: ../include/net-snmp/types.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/null.lo: ../include/net-snmp/library/asn1.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/null.lo: ../include/net-snmp/library/snmp.h
+./helpers/null.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/null.lo: ../include/net-snmp/utilities.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/null.lo: ../include/net-snmp/library/getopt.h
+./helpers/null.lo: ../include/net-snmp/library/system.h
+./helpers/null.lo: ../include/net-snmp/library/tools.h
+./helpers/null.lo: ../include/net-snmp/library/int64.h
+./helpers/null.lo: ../include/net-snmp/library/mt_support.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/null.lo: ../include/net-snmp/library/data_list.h
+./helpers/null.lo: ../include/net-snmp/library/callback.h
+./helpers/null.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/null.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/null.lo: ../include/net-snmp/version.h
+./helpers/null.lo: ../include/net-snmp/session_api.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/null.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/null.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/null.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/null.lo: ../include/net-snmp/pdu_api.h
+./helpers/null.lo: ../include/net-snmp/mib_api.h
+./helpers/null.lo: ../include/net-snmp/library/mib.h
+./helpers/null.lo: ../include/net-snmp/library/parse.h
+./helpers/null.lo: ../include/net-snmp/varbind_api.h
+./helpers/null.lo: ../include/net-snmp/config_api.h
+./helpers/null.lo: ../include/net-snmp/library/read_config.h
+./helpers/null.lo: ../include/net-snmp/library/default_store.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/null.lo: ../include/net-snmp/library/vacm.h
+./helpers/null.lo: ../include/net-snmp/output_api.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/null.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/null.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/null.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/null.lo: ../include/net-snmp/library/keytools.h
+./helpers/null.lo: ../include/net-snmp/library/scapi.h
+./helpers/null.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/null.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/null.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/null.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/null.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/null.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/null.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/null.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/null.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/null.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/null.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/null.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/null.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/null.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/null.lo: ../include/net-snmp/agent/instance.h
+./helpers/null.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/null.lo: ../include/net-snmp/agent/null.h
+./helpers/null.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/null.lo: ../include/net-snmp/agent/old_api.h
+./helpers/null.lo: ../include/net-snmp/agent/read_only.h
+./helpers/null.lo: ../include/net-snmp/agent/serialize.h
+./helpers/null.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/null.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/null.lo: ../include/net-snmp/agent/table.h
+./helpers/null.lo: ../include/net-snmp/agent/table_data.h
+./helpers/null.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/null.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/null.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/old_api.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/old_api.lo: ../include/net-snmp/system/linux.h
+./helpers/old_api.lo: ../include/net-snmp/system/sysv.h
+./helpers/old_api.lo: ../include/net-snmp/system/generic.h
+./helpers/old_api.lo: ../include/net-snmp/machine/generic.h
+./helpers/old_api.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/old_api.lo: ../include/net-snmp/definitions.h
+./helpers/old_api.lo: ../include/net-snmp/types.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/asn1.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/old_api.lo: ../include/net-snmp/utilities.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/old_api.lo: ../include/net-snmp/library/getopt.h
+./helpers/old_api.lo: ../include/net-snmp/library/system.h
+./helpers/old_api.lo: ../include/net-snmp/library/tools.h
+./helpers/old_api.lo: ../include/net-snmp/library/int64.h
+./helpers/old_api.lo: ../include/net-snmp/library/mt_support.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/old_api.lo: ../include/net-snmp/library/data_list.h
+./helpers/old_api.lo: ../include/net-snmp/library/callback.h
+./helpers/old_api.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/old_api.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/old_api.lo: ../include/net-snmp/version.h
+./helpers/old_api.lo: ../include/net-snmp/session_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/old_api.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/old_api.lo: ../include/net-snmp/pdu_api.h
+./helpers/old_api.lo: ../include/net-snmp/mib_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/mib.h
+./helpers/old_api.lo: ../include/net-snmp/library/parse.h
+./helpers/old_api.lo: ../include/net-snmp/varbind_api.h
+./helpers/old_api.lo: ../include/net-snmp/config_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/read_config.h
+./helpers/old_api.lo: ../include/net-snmp/library/default_store.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/old_api.lo: ../include/net-snmp/library/vacm.h
+./helpers/old_api.lo: ../include/net-snmp/output_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/old_api.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/old_api.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/old_api.lo: ../include/net-snmp/library/keytools.h
+./helpers/old_api.lo: ../include/net-snmp/library/scapi.h
+./helpers/old_api.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/old_api.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/old_api.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/old_api.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/old_api.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/old_api.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/old_api.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/old_api.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/old_api.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/old_api.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/old_api.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/old_api.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/old_api.lo: ../include/net-snmp/agent/instance.h
+./helpers/old_api.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/old_api.lo: ../include/net-snmp/agent/null.h
+./helpers/old_api.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/old_api.lo: ../include/net-snmp/agent/old_api.h
+./helpers/old_api.lo: ../include/net-snmp/agent/read_only.h
+./helpers/old_api.lo: ../include/net-snmp/agent/serialize.h
+./helpers/old_api.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/old_api.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/old_api.lo: ../include/net-snmp/agent/table.h
+./helpers/old_api.lo: ../include/net-snmp/agent/table_data.h
+./helpers/old_api.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/old_api.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/old_api.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/old_api.lo: ../include/net-snmp/agent/agent_callbacks.h
+./helpers/read_only.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/read_only.lo: ../include/net-snmp/system/linux.h
+./helpers/read_only.lo: ../include/net-snmp/system/sysv.h
+./helpers/read_only.lo: ../include/net-snmp/system/generic.h
+./helpers/read_only.lo: ../include/net-snmp/machine/generic.h
+./helpers/read_only.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/read_only.lo: ../include/net-snmp/definitions.h
+./helpers/read_only.lo: ../include/net-snmp/types.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/asn1.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/read_only.lo: ../include/net-snmp/utilities.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/read_only.lo: ../include/net-snmp/library/getopt.h
+./helpers/read_only.lo: ../include/net-snmp/library/system.h
+./helpers/read_only.lo: ../include/net-snmp/library/tools.h
+./helpers/read_only.lo: ../include/net-snmp/library/int64.h
+./helpers/read_only.lo: ../include/net-snmp/library/mt_support.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/read_only.lo: ../include/net-snmp/library/data_list.h
+./helpers/read_only.lo: ../include/net-snmp/library/callback.h
+./helpers/read_only.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/read_only.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/read_only.lo: ../include/net-snmp/version.h
+./helpers/read_only.lo: ../include/net-snmp/session_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/read_only.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/read_only.lo: ../include/net-snmp/pdu_api.h
+./helpers/read_only.lo: ../include/net-snmp/mib_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/mib.h
+./helpers/read_only.lo: ../include/net-snmp/library/parse.h
+./helpers/read_only.lo: ../include/net-snmp/varbind_api.h
+./helpers/read_only.lo: ../include/net-snmp/config_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/read_config.h
+./helpers/read_only.lo: ../include/net-snmp/library/default_store.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/read_only.lo: ../include/net-snmp/library/vacm.h
+./helpers/read_only.lo: ../include/net-snmp/output_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/read_only.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/read_only.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/read_only.lo: ../include/net-snmp/library/keytools.h
+./helpers/read_only.lo: ../include/net-snmp/library/scapi.h
+./helpers/read_only.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/read_only.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/read_only.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/read_only.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/read_only.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/read_only.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/read_only.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/read_only.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/read_only.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/read_only.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/read_only.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/read_only.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/read_only.lo: ../include/net-snmp/agent/instance.h
+./helpers/read_only.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/read_only.lo: ../include/net-snmp/agent/null.h
+./helpers/read_only.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/read_only.lo: ../include/net-snmp/agent/old_api.h
+./helpers/read_only.lo: ../include/net-snmp/agent/read_only.h
+./helpers/read_only.lo: ../include/net-snmp/agent/serialize.h
+./helpers/read_only.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/read_only.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/read_only.lo: ../include/net-snmp/agent/table.h
+./helpers/read_only.lo: ../include/net-snmp/agent/table_data.h
+./helpers/read_only.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/read_only.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/read_only.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/scalar1.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/scalar1.lo: ../include/net-snmp/system/linux.h
+./helpers/scalar1.lo: ../include/net-snmp/system/sysv.h
+./helpers/scalar1.lo: ../include/net-snmp/system/generic.h
+./helpers/scalar1.lo: ../include/net-snmp/machine/generic.h
+./helpers/scalar1.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/scalar1.lo: ../include/net-snmp/definitions.h
+./helpers/scalar1.lo: ../include/net-snmp/types.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/asn1.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/scalar1.lo: ../include/net-snmp/utilities.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/scalar1.lo: ../include/net-snmp/library/getopt.h
+./helpers/scalar1.lo: ../include/net-snmp/library/system.h
+./helpers/scalar1.lo: ../include/net-snmp/library/tools.h
+./helpers/scalar1.lo: ../include/net-snmp/library/int64.h
+./helpers/scalar1.lo: ../include/net-snmp/library/mt_support.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/scalar1.lo: ../include/net-snmp/library/data_list.h
+./helpers/scalar1.lo: ../include/net-snmp/library/callback.h
+./helpers/scalar1.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/scalar1.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/scalar1.lo: ../include/net-snmp/version.h
+./helpers/scalar1.lo: ../include/net-snmp/session_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/scalar1.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/scalar1.lo: ../include/net-snmp/pdu_api.h
+./helpers/scalar1.lo: ../include/net-snmp/mib_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/mib.h
+./helpers/scalar1.lo: ../include/net-snmp/library/parse.h
+./helpers/scalar1.lo: ../include/net-snmp/varbind_api.h
+./helpers/scalar1.lo: ../include/net-snmp/config_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/read_config.h
+./helpers/scalar1.lo: ../include/net-snmp/library/default_store.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/scalar1.lo: ../include/net-snmp/library/vacm.h
+./helpers/scalar1.lo: ../include/net-snmp/output_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/scalar1.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/scalar1.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/scalar1.lo: ../include/net-snmp/library/keytools.h
+./helpers/scalar1.lo: ../include/net-snmp/library/scapi.h
+./helpers/scalar1.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/scalar1.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/instance.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/null.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/old_api.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/read_only.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/serialize.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/table.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/table_data.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/scalar1.lo: ../include/net-snmp/agent/scalar.h
+./helpers/scalar.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/scalar.lo: ../include/net-snmp/system/linux.h
+./helpers/scalar.lo: ../include/net-snmp/system/sysv.h
+./helpers/scalar.lo: ../include/net-snmp/system/generic.h
+./helpers/scalar.lo: ../include/net-snmp/machine/generic.h
+./helpers/scalar.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/scalar.lo: ../include/net-snmp/definitions.h
+./helpers/scalar.lo: ../include/net-snmp/types.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/asn1.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/scalar.lo: ../include/net-snmp/utilities.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/scalar.lo: ../include/net-snmp/library/getopt.h
+./helpers/scalar.lo: ../include/net-snmp/library/system.h
+./helpers/scalar.lo: ../include/net-snmp/library/tools.h
+./helpers/scalar.lo: ../include/net-snmp/library/int64.h
+./helpers/scalar.lo: ../include/net-snmp/library/mt_support.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/scalar.lo: ../include/net-snmp/library/data_list.h
+./helpers/scalar.lo: ../include/net-snmp/library/callback.h
+./helpers/scalar.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/scalar.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/scalar.lo: ../include/net-snmp/version.h
+./helpers/scalar.lo: ../include/net-snmp/session_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/scalar.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/scalar.lo: ../include/net-snmp/pdu_api.h
+./helpers/scalar.lo: ../include/net-snmp/mib_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/mib.h
+./helpers/scalar.lo: ../include/net-snmp/library/parse.h
+./helpers/scalar.lo: ../include/net-snmp/varbind_api.h
+./helpers/scalar.lo: ../include/net-snmp/config_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/read_config.h
+./helpers/scalar.lo: ../include/net-snmp/library/default_store.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/scalar.lo: ../include/net-snmp/library/vacm.h
+./helpers/scalar.lo: ../include/net-snmp/output_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/scalar.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/scalar.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/scalar.lo: ../include/net-snmp/library/keytools.h
+./helpers/scalar.lo: ../include/net-snmp/library/scapi.h
+./helpers/scalar.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/scalar.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/scalar.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/scalar.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/scalar.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/scalar.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/scalar.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/scalar.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/scalar.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/scalar.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/scalar.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/scalar.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/scalar.lo: ../include/net-snmp/agent/instance.h
+./helpers/scalar.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/scalar.lo: ../include/net-snmp/agent/null.h
+./helpers/scalar.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/scalar.lo: ../include/net-snmp/agent/old_api.h
+./helpers/scalar.lo: ../include/net-snmp/agent/read_only.h
+./helpers/scalar.lo: ../include/net-snmp/agent/serialize.h
+./helpers/scalar.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/scalar.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/scalar.lo: ../include/net-snmp/agent/table.h
+./helpers/scalar.lo: ../include/net-snmp/agent/table_data.h
+./helpers/scalar.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/scalar.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/scalar.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/scalar.lo: ../include/net-snmp/agent/scalar.h
+./helpers/serialize.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/serialize.lo: ../include/net-snmp/system/linux.h
+./helpers/serialize.lo: ../include/net-snmp/system/sysv.h
+./helpers/serialize.lo: ../include/net-snmp/system/generic.h
+./helpers/serialize.lo: ../include/net-snmp/machine/generic.h
+./helpers/serialize.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/serialize.lo: ../include/net-snmp/definitions.h
+./helpers/serialize.lo: ../include/net-snmp/types.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/asn1.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/serialize.lo: ../include/net-snmp/utilities.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/serialize.lo: ../include/net-snmp/library/getopt.h
+./helpers/serialize.lo: ../include/net-snmp/library/system.h
+./helpers/serialize.lo: ../include/net-snmp/library/tools.h
+./helpers/serialize.lo: ../include/net-snmp/library/int64.h
+./helpers/serialize.lo: ../include/net-snmp/library/mt_support.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/serialize.lo: ../include/net-snmp/library/data_list.h
+./helpers/serialize.lo: ../include/net-snmp/library/callback.h
+./helpers/serialize.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/serialize.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/serialize.lo: ../include/net-snmp/version.h
+./helpers/serialize.lo: ../include/net-snmp/session_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/serialize.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/serialize.lo: ../include/net-snmp/pdu_api.h
+./helpers/serialize.lo: ../include/net-snmp/mib_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/mib.h
+./helpers/serialize.lo: ../include/net-snmp/library/parse.h
+./helpers/serialize.lo: ../include/net-snmp/varbind_api.h
+./helpers/serialize.lo: ../include/net-snmp/config_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/read_config.h
+./helpers/serialize.lo: ../include/net-snmp/library/default_store.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/serialize.lo: ../include/net-snmp/library/vacm.h
+./helpers/serialize.lo: ../include/net-snmp/output_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/serialize.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/serialize.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/serialize.lo: ../include/net-snmp/library/keytools.h
+./helpers/serialize.lo: ../include/net-snmp/library/scapi.h
+./helpers/serialize.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/serialize.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/serialize.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/serialize.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/serialize.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/serialize.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/serialize.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/serialize.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/serialize.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/serialize.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/serialize.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/serialize.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/serialize.lo: ../include/net-snmp/agent/instance.h
+./helpers/serialize.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/serialize.lo: ../include/net-snmp/agent/null.h
+./helpers/serialize.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/serialize.lo: ../include/net-snmp/agent/old_api.h
+./helpers/serialize.lo: ../include/net-snmp/agent/read_only.h
+./helpers/serialize.lo: ../include/net-snmp/agent/serialize.h
+./helpers/serialize.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/serialize.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/serialize.lo: ../include/net-snmp/agent/table.h
+./helpers/serialize.lo: ../include/net-snmp/agent/table_data.h
+./helpers/serialize.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/serialize.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/serialize.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/table_array.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/table_array.lo: ../include/net-snmp/system/linux.h
+./helpers/table_array.lo: ../include/net-snmp/system/sysv.h
+./helpers/table_array.lo: ../include/net-snmp/system/generic.h
+./helpers/table_array.lo: ../include/net-snmp/machine/generic.h
+./helpers/table_array.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/table_array.lo: ../include/net-snmp/definitions.h
+./helpers/table_array.lo: ../include/net-snmp/types.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/asn1.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/table_array.lo: ../include/net-snmp/utilities.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/table_array.lo: ../include/net-snmp/library/getopt.h
+./helpers/table_array.lo: ../include/net-snmp/library/system.h
+./helpers/table_array.lo: ../include/net-snmp/library/tools.h
+./helpers/table_array.lo: ../include/net-snmp/library/int64.h
+./helpers/table_array.lo: ../include/net-snmp/library/mt_support.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/table_array.lo: ../include/net-snmp/library/data_list.h
+./helpers/table_array.lo: ../include/net-snmp/library/callback.h
+./helpers/table_array.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/table_array.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/table_array.lo: ../include/net-snmp/version.h
+./helpers/table_array.lo: ../include/net-snmp/session_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/table_array.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/table_array.lo: ../include/net-snmp/pdu_api.h
+./helpers/table_array.lo: ../include/net-snmp/mib_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/mib.h
+./helpers/table_array.lo: ../include/net-snmp/library/parse.h
+./helpers/table_array.lo: ../include/net-snmp/varbind_api.h
+./helpers/table_array.lo: ../include/net-snmp/config_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/read_config.h
+./helpers/table_array.lo: ../include/net-snmp/library/default_store.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/table_array.lo: ../include/net-snmp/library/vacm.h
+./helpers/table_array.lo: ../include/net-snmp/output_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/table_array.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/table_array.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/table_array.lo: ../include/net-snmp/library/keytools.h
+./helpers/table_array.lo: ../include/net-snmp/library/scapi.h
+./helpers/table_array.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/table_array.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/table_array.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/table_array.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/table_array.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/table_array.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/table_array.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/table_array.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/table_array.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/table_array.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/table_array.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/table_array.lo: ../include/net-snmp/agent/instance.h
+./helpers/table_array.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/table_array.lo: ../include/net-snmp/agent/null.h
+./helpers/table_array.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/table_array.lo: ../include/net-snmp/agent/old_api.h
+./helpers/table_array.lo: ../include/net-snmp/agent/read_only.h
+./helpers/table_array.lo: ../include/net-snmp/agent/serialize.h
+./helpers/table_array.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/table_array.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/table_array.lo: ../include/net-snmp/agent/table.h
+./helpers/table_array.lo: ../include/net-snmp/agent/table_data.h
+./helpers/table_array.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/table_array.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/table_array.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/table_array.lo: ../include/net-snmp/agent/table_array.h
+./helpers/table_array.lo: ../include/net-snmp/library/container.h
+./helpers/table_array.lo: ../include/net-snmp/library/factory.h
+./helpers/table_array.lo: ../include/net-snmp/library/snmp_assert.h
+./helpers/table.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/table.lo: ../include/net-snmp/system/linux.h
+./helpers/table.lo: ../include/net-snmp/system/sysv.h
+./helpers/table.lo: ../include/net-snmp/system/generic.h
+./helpers/table.lo: ../include/net-snmp/machine/generic.h
+./helpers/table.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/table.lo: ../include/net-snmp/definitions.h
+./helpers/table.lo: ../include/net-snmp/types.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/table.lo: ../include/net-snmp/library/asn1.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/table.lo: ../include/net-snmp/library/snmp.h
+./helpers/table.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/table.lo: ../include/net-snmp/utilities.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/table.lo: ../include/net-snmp/library/getopt.h
+./helpers/table.lo: ../include/net-snmp/library/system.h
+./helpers/table.lo: ../include/net-snmp/library/tools.h
+./helpers/table.lo: ../include/net-snmp/library/int64.h
+./helpers/table.lo: ../include/net-snmp/library/mt_support.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/table.lo: ../include/net-snmp/library/data_list.h
+./helpers/table.lo: ../include/net-snmp/library/callback.h
+./helpers/table.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/table.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/table.lo: ../include/net-snmp/version.h
+./helpers/table.lo: ../include/net-snmp/session_api.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/table.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/table.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/table.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/table.lo: ../include/net-snmp/pdu_api.h
+./helpers/table.lo: ../include/net-snmp/mib_api.h
+./helpers/table.lo: ../include/net-snmp/library/mib.h
+./helpers/table.lo: ../include/net-snmp/library/parse.h
+./helpers/table.lo: ../include/net-snmp/varbind_api.h
+./helpers/table.lo: ../include/net-snmp/config_api.h
+./helpers/table.lo: ../include/net-snmp/library/read_config.h
+./helpers/table.lo: ../include/net-snmp/library/default_store.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/table.lo: ../include/net-snmp/library/vacm.h
+./helpers/table.lo: ../include/net-snmp/output_api.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/table.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/table.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/table.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/table.lo: ../include/net-snmp/library/keytools.h
+./helpers/table.lo: ../include/net-snmp/library/scapi.h
+./helpers/table.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/table.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/table.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/table.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/table.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/table.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/table.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/table.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/table.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/table.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/table.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/table.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/table.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/table.lo: ../include/net-snmp/agent/instance.h
+./helpers/table.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/table.lo: ../include/net-snmp/agent/null.h
+./helpers/table.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/table.lo: ../include/net-snmp/agent/old_api.h
+./helpers/table.lo: ../include/net-snmp/agent/read_only.h
+./helpers/table.lo: ../include/net-snmp/agent/serialize.h
+./helpers/table.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/table.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/table.lo: ../include/net-snmp/agent/table.h
+./helpers/table.lo: ../include/net-snmp/agent/table_data.h
+./helpers/table.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/table.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/table.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/table.lo: ../include/net-snmp/library/snmp_assert.h
+./helpers/table_data.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/table_data.lo: ../include/net-snmp/system/linux.h
+./helpers/table_data.lo: ../include/net-snmp/system/sysv.h
+./helpers/table_data.lo: ../include/net-snmp/system/generic.h
+./helpers/table_data.lo: ../include/net-snmp/machine/generic.h
+./helpers/table_data.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/table_data.lo: ../include/net-snmp/definitions.h
+./helpers/table_data.lo: ../include/net-snmp/types.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/asn1.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/table_data.lo: ../include/net-snmp/utilities.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/table_data.lo: ../include/net-snmp/library/getopt.h
+./helpers/table_data.lo: ../include/net-snmp/library/system.h
+./helpers/table_data.lo: ../include/net-snmp/library/tools.h
+./helpers/table_data.lo: ../include/net-snmp/library/int64.h
+./helpers/table_data.lo: ../include/net-snmp/library/mt_support.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/table_data.lo: ../include/net-snmp/library/data_list.h
+./helpers/table_data.lo: ../include/net-snmp/library/callback.h
+./helpers/table_data.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/table_data.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/table_data.lo: ../include/net-snmp/version.h
+./helpers/table_data.lo: ../include/net-snmp/session_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/table_data.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/table_data.lo: ../include/net-snmp/pdu_api.h
+./helpers/table_data.lo: ../include/net-snmp/mib_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/mib.h
+./helpers/table_data.lo: ../include/net-snmp/library/parse.h
+./helpers/table_data.lo: ../include/net-snmp/varbind_api.h
+./helpers/table_data.lo: ../include/net-snmp/config_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/read_config.h
+./helpers/table_data.lo: ../include/net-snmp/library/default_store.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/table_data.lo: ../include/net-snmp/library/vacm.h
+./helpers/table_data.lo: ../include/net-snmp/output_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/table_data.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/table_data.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/table_data.lo: ../include/net-snmp/library/keytools.h
+./helpers/table_data.lo: ../include/net-snmp/library/scapi.h
+./helpers/table_data.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/table_data.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/table_data.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/table_data.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/table_data.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/table_data.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/table_data.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/table_data.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/table_data.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/table_data.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/table_data.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/table_data.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/table_data.lo: ../include/net-snmp/agent/instance.h
+./helpers/table_data.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/table_data.lo: ../include/net-snmp/agent/null.h
+./helpers/table_data.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/table_data.lo: ../include/net-snmp/agent/old_api.h
+./helpers/table_data.lo: ../include/net-snmp/agent/read_only.h
+./helpers/table_data.lo: ../include/net-snmp/agent/serialize.h
+./helpers/table_data.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/table_data.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/table_data.lo: ../include/net-snmp/agent/table.h
+./helpers/table_data.lo: ../include/net-snmp/agent/table_data.h
+./helpers/table_data.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/table_data.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/table_data.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/table_dataset.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/table_dataset.lo: ../include/net-snmp/system/linux.h
+./helpers/table_dataset.lo: ../include/net-snmp/system/sysv.h
+./helpers/table_dataset.lo: ../include/net-snmp/system/generic.h
+./helpers/table_dataset.lo: ../include/net-snmp/machine/generic.h
+./helpers/table_dataset.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/table_dataset.lo: ../include/net-snmp/definitions.h
+./helpers/table_dataset.lo: ../include/net-snmp/types.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/asn1.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/table_dataset.lo: ../include/net-snmp/utilities.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/getopt.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/system.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/tools.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/int64.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/mt_support.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/data_list.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/callback.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/table_dataset.lo: ../include/net-snmp/version.h
+./helpers/table_dataset.lo: ../include/net-snmp/session_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/table_dataset.lo: ../include/net-snmp/pdu_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/mib_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/mib.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/parse.h
+./helpers/table_dataset.lo: ../include/net-snmp/varbind_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/config_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/read_config.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/default_store.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/vacm.h
+./helpers/table_dataset.lo: ../include/net-snmp/output_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/table_dataset.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/keytools.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/scapi.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/table_dataset.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/instance.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/null.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/old_api.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/read_only.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/serialize.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/table.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/table_data.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/table_dataset.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/table_iterator.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/table_iterator.lo: ../include/net-snmp/system/linux.h
+./helpers/table_iterator.lo: ../include/net-snmp/system/sysv.h
+./helpers/table_iterator.lo: ../include/net-snmp/system/generic.h
+./helpers/table_iterator.lo: ../include/net-snmp/machine/generic.h
+./helpers/table_iterator.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/table_iterator.lo: ../include/net-snmp/definitions.h
+./helpers/table_iterator.lo: ../include/net-snmp/types.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/asn1.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/table_iterator.lo: ../include/net-snmp/utilities.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/getopt.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/system.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/tools.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/int64.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/mt_support.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/data_list.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/callback.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/table_iterator.lo: ../include/net-snmp/version.h
+./helpers/table_iterator.lo: ../include/net-snmp/session_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/table_iterator.lo: ../include/net-snmp/pdu_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/mib_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/mib.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/parse.h
+./helpers/table_iterator.lo: ../include/net-snmp/varbind_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/config_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/read_config.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/default_store.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/vacm.h
+./helpers/table_iterator.lo: ../include/net-snmp/output_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/table_iterator.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/keytools.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/scapi.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/table_iterator.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/instance.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/null.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/old_api.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/read_only.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/serialize.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/table.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/table_data.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/table_iterator.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/watcher.lo: ../include/net-snmp/net-snmp-config.h
+./helpers/watcher.lo: ../include/net-snmp/system/linux.h
+./helpers/watcher.lo: ../include/net-snmp/system/sysv.h
+./helpers/watcher.lo: ../include/net-snmp/system/generic.h
+./helpers/watcher.lo: ../include/net-snmp/machine/generic.h
+./helpers/watcher.lo: ../include/net-snmp/net-snmp-includes.h
+./helpers/watcher.lo: ../include/net-snmp/definitions.h
+./helpers/watcher.lo: ../include/net-snmp/types.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/asn1.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_impl.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp-tc.h
+./helpers/watcher.lo: ../include/net-snmp/utilities.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_client.h
+./helpers/watcher.lo: ../include/net-snmp/library/getopt.h
+./helpers/watcher.lo: ../include/net-snmp/library/system.h
+./helpers/watcher.lo: ../include/net-snmp/library/tools.h
+./helpers/watcher.lo: ../include/net-snmp/library/int64.h
+./helpers/watcher.lo: ../include/net-snmp/library/mt_support.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_alarm.h
+./helpers/watcher.lo: ../include/net-snmp/library/data_list.h
+./helpers/watcher.lo: ../include/net-snmp/library/callback.h
+./helpers/watcher.lo: ../include/net-snmp/library/oid_stash.h
+./helpers/watcher.lo: ../include/net-snmp/library/check_varbind.h
+./helpers/watcher.lo: ../include/net-snmp/version.h
+./helpers/watcher.lo: ../include/net-snmp/session_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_transport.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./helpers/watcher.lo: ../include/net-snmp/library/ucd_compat.h
+./helpers/watcher.lo: ../include/net-snmp/pdu_api.h
+./helpers/watcher.lo: ../include/net-snmp/mib_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/mib.h
+./helpers/watcher.lo: ../include/net-snmp/library/parse.h
+./helpers/watcher.lo: ../include/net-snmp/varbind_api.h
+./helpers/watcher.lo: ../include/net-snmp/config_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/read_config.h
+./helpers/watcher.lo: ../include/net-snmp/library/default_store.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_parse_args.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_enum.h
+./helpers/watcher.lo: ../include/net-snmp/library/vacm.h
+./helpers/watcher.lo: ../include/net-snmp/output_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_debug.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_logging.h
+./helpers/watcher.lo: ../include/net-snmp/snmpv3_api.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpv3.h
+./helpers/watcher.lo: ../include/net-snmp/library/transform_oids.h
+./helpers/watcher.lo: ../include/net-snmp/library/keytools.h
+./helpers/watcher.lo: ../include/net-snmp/library/scapi.h
+./helpers/watcher.lo: ../include/net-snmp/library/lcd_time.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmp_secmod.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./helpers/watcher.lo: ../include/net-snmp/library/snmpusm.h
+./helpers/watcher.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./helpers/watcher.lo: ../include/net-snmp/agent/snmp_agent.h
+./helpers/watcher.lo: ../include/net-snmp/agent/snmp_vars.h
+./helpers/watcher.lo: ../include/net-snmp/agent/agent_handler.h
+./helpers/watcher.lo: ../include/net-snmp/agent/var_struct.h
+./helpers/watcher.lo: ../include/net-snmp/agent/agent_registry.h
+./helpers/watcher.lo: ../include/net-snmp/agent/ds_agent.h
+./helpers/watcher.lo: ../include/net-snmp/agent/agent_read_config.h
+./helpers/watcher.lo: ../include/net-snmp/agent/agent_trap.h
+./helpers/watcher.lo: ../include/net-snmp/agent/all_helpers.h
+./helpers/watcher.lo: ../include/net-snmp/agent/instance.h
+./helpers/watcher.lo: ../include/net-snmp/agent/multiplexer.h
+./helpers/watcher.lo: ../include/net-snmp/agent/null.h
+./helpers/watcher.lo: ../include/net-snmp/agent/debug_handler.h
+./helpers/watcher.lo: ../include/net-snmp/agent/old_api.h
+./helpers/watcher.lo: ../include/net-snmp/agent/read_only.h
+./helpers/watcher.lo: ../include/net-snmp/agent/serialize.h
+./helpers/watcher.lo: ../include/net-snmp/agent/bulk_to_next.h
+./helpers/watcher.lo: ../include/net-snmp/agent/mode_end_call.h
+./helpers/watcher.lo: ../include/net-snmp/agent/table.h
+./helpers/watcher.lo: ../include/net-snmp/agent/table_data.h
+./helpers/watcher.lo: ../include/net-snmp/agent/table_dataset.h
+./helpers/watcher.lo: ../include/net-snmp/agent/table_iterator.h
+./helpers/watcher.lo: ../include/net-snmp/agent/mib_module_config.h
+./helpers/watcher.lo: ../include/net-snmp/agent/watcher.h
+./helpers/watcher.lo: ../include/net-snmp/agent/scalar.h
+./mibgroup/header_complex.lo: ../include/net-snmp/net-snmp-config.h
+./mibgroup/header_complex.lo: ../include/net-snmp/system/linux.h
+./mibgroup/header_complex.lo: ../include/net-snmp/system/sysv.h
+./mibgroup/header_complex.lo: ../include/net-snmp/system/generic.h
+./mibgroup/header_complex.lo: ../include/net-snmp/machine/generic.h
+./mibgroup/header_complex.lo: ../include/net-snmp/net-snmp-includes.h
+./mibgroup/header_complex.lo: ../include/net-snmp/definitions.h
+./mibgroup/header_complex.lo: ../include/net-snmp/types.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/asn1.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_impl.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp-tc.h
+./mibgroup/header_complex.lo: ../include/net-snmp/utilities.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_client.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/getopt.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/system.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/tools.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/int64.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/mt_support.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_alarm.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/data_list.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/callback.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/oid_stash.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/check_varbind.h
+./mibgroup/header_complex.lo: ../include/net-snmp/version.h
+./mibgroup/header_complex.lo: ../include/net-snmp/session_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_transport.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/ucd_compat.h
+./mibgroup/header_complex.lo: ../include/net-snmp/pdu_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/mib_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/mib.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/parse.h
+./mibgroup/header_complex.lo: ../include/net-snmp/varbind_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/config_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/read_config.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/default_store.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_parse_args.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_enum.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/vacm.h
+./mibgroup/header_complex.lo: ../include/net-snmp/output_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_debug.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_logging.h
+./mibgroup/header_complex.lo: ../include/net-snmp/snmpv3_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpv3.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/transform_oids.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/keytools.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/scapi.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/lcd_time.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmp_secmod.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./mibgroup/header_complex.lo: ../include/net-snmp/library/snmpusm.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/snmp_agent.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/snmp_vars.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/agent_handler.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/var_struct.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/agent_registry.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/ds_agent.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/agent_read_config.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/agent_trap.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/all_helpers.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/instance.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/multiplexer.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/null.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/debug_handler.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/old_api.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/read_only.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/serialize.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/bulk_to_next.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/mode_end_call.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/table.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/table_data.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/table_dataset.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/table_iterator.h
+./mibgroup/header_complex.lo: ../include/net-snmp/agent/mib_module_config.h
+./mibgroup/header_complex.lo: ./mibgroup/header_complex.h
+./mibgroup/kernel_sunos5.lo: ../include/net-snmp/net-snmp-config.h
+./mibgroup/kernel_sunos5.lo: ../include/net-snmp/system/linux.h
+./mibgroup/kernel_sunos5.lo: ../include/net-snmp/system/sysv.h
+./mibgroup/kernel_sunos5.lo: ../include/net-snmp/system/generic.h
+./mibgroup/kernel_sunos5.lo: ../include/net-snmp/machine/generic.h
+./mibgroup/testhandler.lo: ../include/net-snmp/net-snmp-config.h
+./mibgroup/testhandler.lo: ../include/net-snmp/system/linux.h
+./mibgroup/testhandler.lo: ../include/net-snmp/system/sysv.h
+./mibgroup/testhandler.lo: ../include/net-snmp/system/generic.h
+./mibgroup/testhandler.lo: ../include/net-snmp/machine/generic.h
+./mibgroup/testhandler.lo: ../include/net-snmp/net-snmp-includes.h
+./mibgroup/testhandler.lo: ../include/net-snmp/definitions.h
+./mibgroup/testhandler.lo: ../include/net-snmp/types.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/asn1.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_impl.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp-tc.h
+./mibgroup/testhandler.lo: ../include/net-snmp/utilities.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_client.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/getopt.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/system.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/tools.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/int64.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/mt_support.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_alarm.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/data_list.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/callback.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/oid_stash.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/check_varbind.h
+./mibgroup/testhandler.lo: ../include/net-snmp/version.h
+./mibgroup/testhandler.lo: ../include/net-snmp/session_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_transport.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/ucd_compat.h
+./mibgroup/testhandler.lo: ../include/net-snmp/pdu_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/mib_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/mib.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/parse.h
+./mibgroup/testhandler.lo: ../include/net-snmp/varbind_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/config_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/read_config.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/default_store.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_parse_args.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_enum.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/vacm.h
+./mibgroup/testhandler.lo: ../include/net-snmp/output_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_debug.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_logging.h
+./mibgroup/testhandler.lo: ../include/net-snmp/snmpv3_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpv3.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/transform_oids.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/keytools.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/scapi.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/lcd_time.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmp_secmod.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./mibgroup/testhandler.lo: ../include/net-snmp/library/snmpusm.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/snmp_agent.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/snmp_vars.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/agent_handler.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/var_struct.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/agent_registry.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/ds_agent.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/agent_read_config.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/agent_trap.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/all_helpers.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/instance.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/multiplexer.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/null.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/debug_handler.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/old_api.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/read_only.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/serialize.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/bulk_to_next.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/mode_end_call.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/table.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/table_data.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/table_dataset.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/table_iterator.h
+./mibgroup/testhandler.lo: ../include/net-snmp/agent/mib_module_config.h
+./mibgroup/testhandler.lo: ./mibgroup/testhandler.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/net-snmp-config.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/system/linux.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/system/sysv.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/system/generic.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/machine/generic.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/net-snmp-includes.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/definitions.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/types.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/asn1.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_impl.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp-tc.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/utilities.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_client.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/getopt.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/system.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/tools.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/int64.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/mt_support.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_alarm.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/data_list.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/callback.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/oid_stash.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/check_varbind.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/version.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/session_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_transport.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpCallbackDomain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpUnixDomain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpUDPDomain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpTCPDomain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpUDPIPv6Domain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpTCPIPv6Domain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpIPXDomain.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/ucd_compat.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/pdu_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/mib_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/mib.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/parse.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/varbind_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/config_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/read_config.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/default_store.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_parse_args.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_enum.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/vacm.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/output_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_debug.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_logging.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/snmpv3_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpv3.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/transform_oids.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/keytools.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/scapi.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/lcd_time.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmp_secmod.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpv3-security-includes.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/library/snmpusm.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/net-snmp-agent-includes.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/snmp_agent.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/snmp_vars.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/agent_handler.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/var_struct.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/agent_registry.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/ds_agent.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/agent_read_config.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/agent_trap.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/all_helpers.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/instance.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/multiplexer.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/null.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/debug_handler.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/old_api.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/read_only.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/serialize.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/bulk_to_next.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/mode_end_call.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/table.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/table_data.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/table_dataset.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/table_iterator.h
+./mibgroup/util_funcs.lo: ../include/net-snmp/agent/mib_module_config.h
+./mibgroup/util_funcs.lo: mibgroup/struct.h ./mibgroup/util_funcs.h
+./mibgroup/util_funcs.lo: ./mibgroup/ucd-snmp/errormib.h ./mibgroup/mibdefs.h
diff -rupN net-snmp-5.0.9-original/Makefile.in net-snmp-5.0.9-patched/Makefile.in
--- net-snmp-5.0.9-original/Makefile.in	2003-09-05 22:00:53.000000000 -0700
+++ net-snmp-5.0.9-patched/Makefile.in	2015-03-20 12:00:21.920290967 -0700
@@ -4,7 +4,7 @@
 
 top_builddir	= .
 
-SUBDIRS		= snmplib agent apps local man mibs
+SUBDIRS		= snmplib agent
 TESTDIRS	= testing
 
 CPP		= @CPP@ 					        \
@@ -150,10 +150,7 @@ distclean: clean configclean tarclean
 makefileclean:
 	rm -f Makefile snmplib/Makefile				\
 		agent/Makefile agent/mibgroup/Makefile		\
-		agent/helpers/Makefile				\
-		apps/Makefile  apps/snmpnetstat/Makefile	\
-		man/Makefile mibs/Makefile ov/Makefile		\
-		local/Makefile testing/Makefile
+		agent/helpers/Makefile
 
 configclean: makefileclean
 	rm -f config.cache config.status config.log \
diff -rupN net-snmp-5.0.9-original/Makefile.top net-snmp-5.0.9-patched/Makefile.top
--- net-snmp-5.0.9-original/Makefile.top	2003-09-05 23:25:55.000000000 -0700
+++ net-snmp-5.0.9-patched/Makefile.top	2015-04-13 16:47:37.579551524 -0700
@@ -9,6 +9,17 @@ VERSION		= @VERSION@
 @SET_MAKE@
 
 #
+# NEXUS dependency
+#
+NEXUS ?= $(shell cd $(top_srcdir)/../../../../nexus; pwd)
+NEXUS_TOP ?= $(shell cd $(top_srcdir)/../../../../nexus; pwd)
+
+include $(NEXUS_TOP)/platforms/$(NEXUS_PLATFORM)/build/platform_app.inc
+
+NEXUS_INCLUDE_DIRS = -I$(NEXUS)/lib/os/include -I$(NEXUS)/lib/os/include/linuxuser
+NEXUS_INCLUDE_DIRS += $(addprefix -I,$(NEXUS_APP_INCLUDE_PATHS)) $(addprefix -D,$(NEXUS_APP_DEFINES)) -I$(NEXUS_TOP)/../BSEAV/lib/netaccel/include
+
+#
 # Paths
 #
 prefix		= @prefix@
@@ -42,7 +53,7 @@ AUTOHEADER	= @AUTOHEADER@
 #
 # Compiler arguments
 #
-CFLAGS		= @CFLAGS@ @DEVFLAGS@
+CFLAGS		= @CFLAGS@ @DEVFLAGS@ $(NEXUS_INCLUDE_DIRS) -DBSTD_CPU_ENDIAN=${NEXUS_ENDIAN}
 EXTRACPPFLAGS	= @EXTRACPPFLAGS@
 LDFLAGS		= @LDFLAGS@ 
 LIBTOOL		= @LIBTOOL@ @LIBTOOLFLAGS@
diff -rupN net-snmp-5.0.9-original/snmplib/b_snmp_lib.c net-snmp-5.0.9-patched/snmplib/b_snmp_lib.c
--- net-snmp-5.0.9-original/snmplib/b_snmp_lib.c	1969-12-31 16:00:00.000000000 -0800
+++ net-snmp-5.0.9-patched/snmplib/b_snmp_lib.c	2015-03-20 11:45:16.828905323 -0700
@@ -0,0 +1,763 @@
+/***************************************************************************
+ *     (c)2007-2010 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its licensors,
+ *  and may only be used, duplicated, modified or distributed pursuant to the terms and
+ *  conditions of a separate, written license agreement executed between you and Broadcom
+ *  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
+ *  no license (express or implied), right to use, or waiver of any kind with respect to the
+ *  Software, and Broadcom expressly reserves all rights in and to the Software and all
+ *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
+ *  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
+ *  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
+ *  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
+ *  and to use this information only in connection with your use of Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ *  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
+ *  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ *  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
+ *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
+ *  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
+ *  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
+ *  USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
+ *  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
+ *  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
+ *  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
+ *  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
+ *  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
+ *  ANY LIMITED REMEDY.
+ *
+ * $brcm_Workfile: b_snmp_lib.c $
+ * $brcm_Revision: Hydra_Software_Devel/9 $
+ * $brcm_Date: 6/30/10 2:02p $
+ *
+ * Module Description:  SNMP interface
+ *
+ * Revision History:
+ *
+ * $brcm_Log: /rockford/lib/ocap/snmp/snmplib/b_snmp_lib.c $
+ * 
+ * Hydra_Software_Devel/9   6/30/10 2:02p haisongw
+ * SW7400-2687: Add SNMP trap support
+ *
+ * Hydra_Software_Devel/8   4/9/10 11:10a haisongw
+ * SW7400-2687: set default format mode to 'g" for string type MIB
+ *
+ * Hydra_Software_Devel/7   4/7/10 12:10p haisongw
+ * SW7400-2687: Don't always reallocate memory in to prevent memory leak
+ * snprint_variable().
+ *
+ * Hydra_Software_Devel/6   4/2/10 3:35p haisongw
+ * SW7400-2687: correct SNMP output format setting
+ *
+ * Hydra_Software_Devel/5   3/31/10 3:05p haisongw
+ * SW7400-2687: add SNMP getnext support
+ *
+ * Hydra_Software_Devel/4   3/22/10 12:11p haisongw
+ * SW7400-2687: need use multi-thrad API for SNMP get/set/trap
+ *
+ * Hydra_Software_Devel/3   3/17/10 6:10p haisongw
+ * SW7400-2687: Add SNMP trap support
+ *
+ * Hydra_Software_Devel/2   3/8/10 3:33p haisongw
+ * SW7400-2687: change default community to "public"
+ *
+ *
+ ***************************************************************************/
+/***********************************************************************
+	Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+/*=Module Overview: ********************************************************
+The purpose of this module is to support OpenCable SNMP based diagnostics
+B_SNMP_Gets()/B_SNMP_Get() are mainly copied from snmpget.c in NET-SNMP
+B_SNMP_Sets()/B_SNMP_Set() are mainly copied from snmpset.c in NET-SNMP
+B_SNMP_Informs()/B_SNMP_Inform() are mainly copied from snmptrap.c in NET-SNMP
+B_SNMP_Traps()/B_SNMP_Trap() are mainly copied from snmptrap.c in NET-SNMP
+***************************************************************************/
+#include "b_snmp_lib.h"
+#include "bstd.h"
+#include "bkni.h"
+
+static int snmp_version;
+static b_snmp_setting snmp_setting;
+
+
+BDBG_MODULE(b_snmp_lib);
+
+
+#define B_SNMP_TRAP_PORT 16977
+
+/*
+#define BDBG_WRN(x)	printf x
+#define BDBG_ERR(x)	printf x
+#define BDBG_MSG(x) printf x
+*/
+
+static char  *B_SNMP_P_SetFormat(char *options);
+
+NEXUS_Error B_SNMP_Init()
+{
+    /*
+     * Initialize the SNMP library
+     */
+    init_snmp("b_snmp_lib");
+
+	strcpy(snmp_setting.format,"qvg"); /* default format is "qvg" */
+	B_SNMP_P_SetFormat(snmp_setting.format);
+
+	strcpy(snmp_setting.community, "public");
+	snmp_setting.version = B_SNMP_VERSION_2c;
+    snmp_version = SNMP_VERSION_2c;
+	snmp_setting.timeout = 2*1000000L; /* 2 second*/
+	snmp_setting.retries = 5;
+	return NEXUS_SUCCESS;
+}
+
+void B_SNMP_Shutdown()
+{
+}
+
+
+static void B_SNMP_P_ResetFormat()
+{
+
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES, 0);
+    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                              NETSNMP_OID_OUTPUT_NUMERIC);
+    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
+                                              NETSNMP_STRING_OUTPUT_GUESS);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, 0);
+
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE, 0);
+    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX, 0);
+
+}
+
+
+static char  *B_SNMP_P_SetFormat(char *options)
+{
+	B_SNMP_P_ResetFormat();
+
+    while (*options) {
+        switch (*options++) {
+        case 'a':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
+                                                      NETSNMP_STRING_OUTPUT_ASCII);
+            break;
+        case 'b':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS, 1);
+            break;
+        case 'e':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM, 1);
+            break;
+        case 'E':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES, 1);
+            break;
+        case 'f':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                                      NETSNMP_OID_OUTPUT_FULL);
+			break;
+        case 'g':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
+                                                      NETSNMP_STRING_OUTPUT_GUESS);
+            break;
+        case 'n':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                                      NETSNMP_OID_OUTPUT_NUMERIC);
+            break;
+        case 'q':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, 1);
+            break;
+        case 'Q':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 1);
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, 1);
+            break;
+        case 's':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                                      NETSNMP_OID_OUTPUT_SUFFIX);
+            break;
+        case 'S':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                                      NETSNMP_OID_OUTPUT_MODULE);
+            break;
+        case 't':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS, 1);
+            break;
+        case 'T':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT, 1);
+            break;
+        case 'u':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
+                                                      NETSNMP_OID_OUTPUT_UCD);
+            break;
+        case 'U':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS, 1);
+            break;
+        case 'v':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE, 1);
+            break;
+        case 'x':
+            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
+                                                      NETSNMP_STRING_OUTPUT_HEX);
+            break;
+        case 'X':
+            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX, 1);
+            break;
+        default:
+            return options - 1;
+        }
+    }
+    return NULL;
+}
+
+NEXUS_Error B_SNMP_Set_Setting(b_snmp_setting *setting)
+{
+	switch (setting->version) {
+		case B_SNMP_VERSION_1:
+			snmp_version = SNMP_VERSION_1;
+			break;
+		case B_SNMP_VERSION_2c:
+			snmp_version = SNMP_VERSION_2c;
+			break;
+		case B_SNMP_VERSION_3:
+			snmp_version = SNMP_VERSION_3;
+			break;
+		default:
+			return NEXUS_NOT_SUPPORTED;
+	}
+
+	/* apply new setting */
+	B_SNMP_P_SetFormat(setting->format);
+
+	snmp_setting = *setting;
+
+	return NEXUS_SUCCESS;
+}
+
+
+NEXUS_Error B_SNMP_Get_Setting(b_snmp_setting *setting)
+{
+	*setting = snmp_setting;
+	return NEXUS_SUCCESS;
+}
+
+NEXUS_Error B_SNMP_Sets(const char *ipaddr, const int num_oid, const char **name, B_SNMP_Type *snmp_type, const char **value)
+{
+	netsnmp_session session, *ss = NULL;
+    netsnmp_pdu *pdu;
+    netsnmp_pdu *response = NULL;
+    oid anOID[MAX_OID_LEN];
+    size_t anOID_len;
+    int status, i;
+	char type;
+	NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
+
+    snmp_sess_init( &session );                   /* set up defaults */
+    session.peername = (char*)ipaddr;
+
+    /* set the SNMP version number */
+    session.version = snmp_version;
+
+    /* set the SNMP community name, timeput and retry time*/
+    session.community = (u_char*)snmp_setting.community;
+    session.community_len = strlen(snmp_setting.community);
+
+	session.retries = snmp_setting.retries;
+	session.timeout = snmp_setting.timeout;
+	session.remote_port = SNMP_PORT;
+    /*
+     * open an SNMP session
+     */
+    ss = snmp_sess_open(&session);
+	if (!ss) goto err;
+
+    /*
+     * create PDU for SET request and add object names and values to request
+     */
+    pdu = snmp_pdu_create(SNMP_MSG_SET);
+
+
+	for (i=0;i <num_oid;i++)
+	{
+		switch (snmp_type[i]) {
+	    	case B_SNMP_TYPE_INTEGER:
+				type = 'i'; break;
+	  		case B_SNMP_TYPE_BITS:
+				type = 'b'; break;
+	    	case B_SNMP_TYPE_OCTETSTRING:
+				type = 's'; break;
+	    	case B_SNMP_TYPE_OBJECTID:
+				type = 'o'; break;
+			case B_SNMP_TYPE_IPADDRESS:
+				type = 'a'; break;
+	    	case B_SNMP_TYPE_COUNTER32:
+				type = 'c'; break;
+	    	case B_SNMP_TYPE_GAUGE32:
+				type = 'u'; break;
+	    	case B_SNMP_TYPE_TIMETICKS:
+				type = 't'; break;
+	    	case B_SNMP_TYPE_COUNTER64:
+				type = 'U'; break;
+			case B_SNMP_TYPE_OPAQUE:
+				type = '='; break;
+	    	case B_SNMP_TYPE_INVALID:
+			default:
+				goto err;
+		}
+
+		anOID_len = MAX_OID_LEN;
+	    if (read_objid(name[i], anOID, &anOID_len) == 0) {
+			anOID_len = MAX_OID_LEN;
+		  	if (get_node(name[i], anOID, &anOID_len) == 0)
+				goto err;
+	    }
+
+	    if (snmp_add_var(pdu, anOID, anOID_len, type, value[i])) {
+			goto err;
+	    }
+	}
+    /*
+     * do the request
+     */
+    status = snmp_sess_synch_response(ss, pdu, &response);
+    if (status == STAT_SUCCESS) {
+        if (response->errstat == SNMP_ERR_NOERROR) {
+			// bingo
+			BDBG_MSG((" SNMP SET is done\n"));
+			rc = NEXUS_SUCCESS;
+        } else {
+			BDBG_WRN((" Error in SNMP packet\n"));
+        }
+    } else if (status == STAT_TIMEOUT) {
+		BDBG_WRN((" Timeout: No Response from %s.\n", session.peername));
+		rc = NEXUS_TIMEOUT;
+    } else {
+		BDBG_WRN((" error in SNMP set\n"));
+    }
+
+err:
+    if (response)
+        snmp_free_pdu(response);
+	if (ss)
+    	snmp_sess_close(ss);
+	return rc;
+}
+
+
+NEXUS_Error B_SNMP_P_Gets(bool is_next, const char *ipaddr, const int num_oid, const char **name, char **buf, int *buf_len)
+{
+    netsnmp_session session, *ss = NULL;
+    netsnmp_pdu *pdu;
+    netsnmp_pdu *response = NULL;
+    oid anOID[MAX_OID_LEN];
+    size_t anOID_len;
+
+    netsnmp_variable_list *vars;
+    int status, i;
+	size_t out_len;
+	NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
+
+    snmp_sess_init( &session );                   /* set up defaults */
+    session.peername = (char*)ipaddr;
+
+    /* set the SNMP version number */
+    session.version = snmp_version;
+
+    /* set the SNMP community name, timeput and retry time*/
+    session.community = (u_char*)snmp_setting.community;
+    session.community_len = strlen(snmp_setting.community);
+
+	session.retries = snmp_setting.retries;
+	session.timeout = snmp_setting.timeout;
+	session.remote_port = SNMP_PORT;
+
+    /*
+     * Open the session
+     */
+    ss = snmp_sess_open(&session);                     /* establish the session */
+
+    if (!ss) goto err;
+
+    pdu = snmp_pdu_create((is_next)? SNMP_MSG_GETNEXT : SNMP_MSG_GET);
+
+	for (i=0;i<num_oid;i++)
+	{
+		if (buf[i] == NULL || buf_len[i] <= 0)  goto err;
+
+		anOID_len = MAX_OID_LEN;
+
+	    if (read_objid(name[i], anOID, &anOID_len) == 0) {
+			anOID_len = MAX_OID_LEN;
+		  	if (get_node(name[i], anOID, &anOID_len) == 0)
+				 goto err;
+	    }
+	    if (snmp_add_null_var(pdu, anOID, anOID_len) == 0)
+			 goto err;
+	}
+
+    /*
+     * Send the Request out.
+     */
+	status = snmp_sess_synch_response(ss, pdu, &response);
+     /*
+     * Process the response.
+     */
+   	if (status == STAT_SUCCESS) {
+		if (response->errstat == SNMP_ERR_NOERROR) {
+			/*
+			* SUCCESS: Print the result variables
+			*/
+			i = 0;
+			for(vars = response->variables; vars; vars = vars->next_variable) {
+				if (vars->type == SNMP_NOSUCHOBJECT)
+				{
+					BDBG_ERR(("No Such Object available on this agent at this OID\n"));
+					goto err;
+				} else if ( vars->type == SNMP_NOSUCHINSTANCE)
+				{
+					BDBG_ERR(("No Such Instance currently exists at this OID\n"));
+					goto err;
+				} else if ( vars->type == SNMP_ENDOFMIBVIEW) {
+					BDBG_ERR(("No more variables left in this MIB View (It is past the end of the MIB tree)\n"));
+					goto err;
+				} else {
+					out_len = snprint_variable(buf[i], (size_t)buf_len[i], vars->name, vars->name_length, vars);
+					BDBG_MSG((" query result: len %d string %s\n", out_len, buf[i]));
+					if ( out_len == -1 || out_len > buf_len[i] ) {
+						rc = NEXUS_OUT_OF_DEVICE_MEMORY;
+						goto err;
+					}
+				}
+				if (++i >= num_oid) break;
+			}
+			rc = NEXUS_SUCCESS;
+			BDBG_MSG((" SNMP query is done\n"));
+		} else {
+			BDBG_ERR((" Error in SNMP packet\n"));
+		}
+    } else if (status == STAT_TIMEOUT) {
+		BDBG_ERR((" Timeout: No Response from %s.\n", session.peername));
+		rc = NEXUS_TIMEOUT;
+    } else {
+		BDBG_ERR((" error in SNMP query\n"));
+    }
+
+err:
+
+   /*
+     * Clean up:
+     *  1) free the response.
+     *  2) close the session.
+     */
+    if (response)
+        snmp_free_pdu(response);
+	if (ss)
+        snmp_sess_close(ss);
+	return rc;
+
+
+}
+
+
+
+oid             objid_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
+oid             objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };	/* snmp system uptime*/
+oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };/* snmpTrapOID.0 */
+NEXUS_Error B_SNMP_P_Notify(bool is_inform, const char *ipaddr, const char *trap_oid, const int num_oid, const char **name, B_SNMP_Type *snmp_type, const char **value)
+{
+	netsnmp_session session, *ss = NULL;
+    netsnmp_pdu *pdu;
+    netsnmp_pdu *response = NULL;
+    oid anOID[MAX_OID_LEN];
+    size_t anOID_len;
+    int status, i;
+	char type;
+	NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
+
+	if (snmp_version == SNMP_VERSION_3)
+	{
+		BDBG_WRN((" TODO:: V3 trap is NOT implemented\n"));
+		return rc;
+	}
+
+    snmp_sess_init( &session );                   /* set up defaults */
+    session.peername = (char*)ipaddr;
+
+    /* set the SNMP version number */
+    session.version = snmp_version;
+
+    /* set the SNMP community name, timeput and retry time*/
+    session.community = (u_char*)snmp_setting.community;
+    session.community_len = strlen(snmp_setting.community);
+
+	session.retries = snmp_setting.retries;
+	session.timeout = snmp_setting.timeout;
+	session.remote_port = B_SNMP_TRAP_PORT;
+
+	/*TODO: seems remote port can't be passed to UDP socket, we have to use
+	NETSNMP_DS_LIB_DEFAULT_PORT instead*/
+	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT,
+		       B_SNMP_TRAP_PORT);
+
+    /*
+     * open an SNMP session
+     */
+    ss = snmp_sess_open(&session);
+	if (!ss) goto err;
+    /*
+     * create PDU for Notification and add object names and values to request
+     */
+    if (session.version == SNMP_VERSION_1) {
+        if (is_inform) {
+            BDBG_ERR(("SNMP v1 doesn't support inform PDU\n"));
+            goto err;
+        }
+#if 1
+		BDBG_WRN(("TODO; snmp v1 trap\n"));
+		goto err;
+#else
+        pdu = snmp_pdu_create(SNMP_MSG_TRAP);
+        pdu_in_addr_t = (in_addr_t *) pdu->agent_addr;
+        if (arg == argc) {
+            fprintf(stderr, "No enterprise oid\n");
+            usage();
+            SOCK_CLEANUP;
+            exit(1);
+        }
+        if (argv[arg][0] == 0) {
+            pdu->enterprise = (oid *) malloc(sizeof(objid_enterprise));
+            memcpy(pdu->enterprise, objid_enterprise,
+                   sizeof(objid_enterprise));
+            pdu->enterprise_length =
+                sizeof(objid_enterprise) / sizeof(oid);
+        } else {
+            name_length = MAX_OID_LEN;
+            if (!snmp_parse_oid(argv[arg], name, &name_length)) {
+                snmp_perror(argv[arg]);
+                usage();
+                SOCK_CLEANUP;
+                exit(1);
+            }
+            pdu->enterprise = (oid *) malloc(name_length * sizeof(oid));
+            memcpy(pdu->enterprise, name, name_length * sizeof(oid));
+            pdu->enterprise_length = name_length;
+        }
+        if (++arg >= argc) {
+            fprintf(stderr, "Missing agent parameter\n");
+            usage();
+            SOCK_CLEANUP;
+            exit(1);
+        }
+        agent = argv[arg];
+        if (agent != NULL && strlen(agent) != 0) {
+            *pdu_in_addr_t = parse_address(agent);
+        } else {
+            *pdu_in_addr_t = get_myaddr();
+        }
+        if (++arg == argc) {
+            fprintf(stderr, "Missing generic-trap parameter\n");
+            usage();
+            SOCK_CLEANUP;
+            exit(1);
+        }
+        trap = argv[arg];
+        pdu->trap_type = atoi(trap);
+        if (++arg == argc) {
+            fprintf(stderr, "Missing specific-trap parameter\n");
+            usage();
+            SOCK_CLEANUP;
+            exit(1);
+        }
+        specific = argv[arg];
+        pdu->specific_type = atoi(specific);
+        if (++arg == argc) {
+            fprintf(stderr, "Missing uptime parameter\n");
+            usage();
+            SOCK_CLEANUP;
+            exit(1);
+        }
+        description = argv[arg];
+        if (description == NULL || *description == 0)
+            pdu->time = get_uptime();
+        else
+            pdu->time = atol(description);
+#endif
+    } else {
+        long            sysuptime;
+        char            csysuptime[20];
+		char 			trap[128];
+        pdu = snmp_pdu_create(is_inform ? SNMP_MSG_INFORM : SNMP_MSG_TRAP2);
+        sysuptime = get_uptime();
+        sprintf(csysuptime, "%ld", sysuptime);
+
+        snmp_add_var(pdu, objid_sysuptime,
+                     sizeof(objid_sysuptime) / sizeof(oid), 't', csysuptime);
+
+        if (snmp_add_var
+            (pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid),
+             'o', trap_oid) != 0) {
+				BDBG_ERR((" error in adding trap OID %s\n", trap_oid));
+				goto err;
+        }
+    }
+
+	for (i=0;i <num_oid;i++)
+	{
+		switch (snmp_type[i]) {
+	    	case B_SNMP_TYPE_INTEGER:
+				type = 'i'; break;
+	  		case B_SNMP_TYPE_BITS:
+				type = 'b'; break;
+	    	case B_SNMP_TYPE_OCTETSTRING:
+				type = 's'; break;
+	    	case B_SNMP_TYPE_OBJECTID:
+				type = 'o'; break;
+			case B_SNMP_TYPE_IPADDRESS:
+				type = 'a'; break;
+	    	case B_SNMP_TYPE_COUNTER32:
+				type = 'c'; break;
+	    	case B_SNMP_TYPE_GAUGE32:
+				type = 'u'; break;
+	    	case B_SNMP_TYPE_TIMETICKS:
+				type = 't'; break;
+	    	case B_SNMP_TYPE_COUNTER64:
+				type = 'U'; break;
+			case B_SNMP_TYPE_OPAQUE:
+				type = '='; break;
+	    	case B_SNMP_TYPE_INVALID:
+			default:
+				goto err;
+		}
+
+		anOID_len = MAX_OID_LEN;
+	    if (read_objid(name[i], anOID, &anOID_len) == 0) {
+			anOID_len = MAX_OID_LEN;
+		  	if (get_node(name[i], anOID, &anOID_len) == 0)
+				goto err;
+	    }
+
+	    if (snmp_add_var(pdu, anOID, anOID_len, type, value[i])) {
+			goto err;
+	    }
+	}
+
+    if (is_inform) {
+        status = snmp_sess_synch_response(ss, pdu, &response);
+	    if (status == STAT_SUCCESS) {
+	        if (response->errstat == SNMP_ERR_NOERROR) {
+				// bingo
+				BDBG_MSG((" SNMP inform is done\n"));
+				rc = NEXUS_SUCCESS;
+	        } else {
+				BDBG_ERR((" Error in SNMP packet\n"));
+	        }
+	    } else if (status == STAT_TIMEOUT) {
+			BDBG_ERR((" Timeout: No Response from %s.\n", session.peername));
+			rc = NEXUS_TIMEOUT;
+	    } else {
+			BDBG_ERR((" error in SNMP inform\n"));
+	    }
+
+    } else {
+        status = snmp_sess_send(ss, pdu) == 0;
+		if (status) {
+			if (pdu != NULL) snmp_free_pdu(pdu);
+			BDBG_ERR((" error in SNMP trap\n"));
+		} else {
+			rc = NEXUS_SUCCESS;
+			BDBG_MSG((" SNMP trap is done\n"));
+		}
+    }
+
+err:
+	netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT,
+		       SNMP_PORT);
+
+    if (response)
+        snmp_free_pdu(response);
+	if (ss)
+    	snmp_sess_close(ss);
+	return rc;
+}
+
+NEXUS_Error B_SNMP_Traps(const char *ipaddr, const char *trap_oid, const int num_oid, const char **oid, B_SNMP_Type *type, const char **value)
+{
+	return B_SNMP_P_Notify(false, ipaddr, trap_oid, num_oid, oid, type, value);
+}
+
+NEXUS_Error B_SNMP_Trap(const char *ipaddr, const char *trap_oid, const char *oid, B_SNMP_Type type, const char *value)
+{
+	return B_SNMP_P_Notify(false, ipaddr, trap_oid, 1, &oid, &type, &value);
+}
+
+NEXUS_Error B_SNMP_Informs(const char *ipaddr, const char *trap_oid, const int num_oid, const char **oid, B_SNMP_Type *type, const char **value)
+{
+	return B_SNMP_P_Notify(true, ipaddr, trap_oid, num_oid, oid, type, value);
+}
+
+NEXUS_Error B_SNMP_Inform(const char *ipaddr, const char *trap_oid, const char *oid, B_SNMP_Type type, const char *value)
+{
+	return B_SNMP_P_Notify(true, ipaddr, trap_oid, 1, &oid, &type, &value);
+}
+
+
+NEXUS_Error B_SNMP_Set(const char *ipaddr, const char *name, B_SNMP_Type snmp_type, const char *value)
+{
+	return B_SNMP_Sets(ipaddr, 1, &name, &snmp_type, &value);
+}
+
+NEXUS_Error B_SNMP_GetNext(const char *ipaddr, const char *name,  char *buf, int buf_len)
+{
+	return B_SNMP_P_Gets(true, ipaddr, 1, &name, &buf, &buf_len);
+}
+
+
+NEXUS_Error B_SNMP_GetsNext(const char *ipaddr, const int num_oid, const char **oid, char **buf, int *buf_len)
+{
+	return B_SNMP_P_Gets(true, ipaddr, num_oid, oid,  buf, buf_len);
+}
+
+NEXUS_Error B_SNMP_Gets(const char *ipaddr, const int num_oid, const char **oid, char **buf, int *buf_len)
+{
+	return B_SNMP_P_Gets(false, ipaddr, num_oid, oid,  buf, buf_len);
+}
+
+NEXUS_Error B_SNMP_Get(const char *ipaddr, const char *name,  char *buf, int buf_len)
+{
+	return B_SNMP_P_Gets(false, ipaddr, 1, &name, &buf, &buf_len);
+}
+
+
diff -rupN net-snmp-5.0.9-original/snmplib/Makefile.in net-snmp-5.0.9-patched/snmplib/Makefile.in
--- net-snmp-5.0.9-original/snmplib/Makefile.in	2003-09-05 22:00:54.000000000 -0700
+++ net-snmp-5.0.9-patched/snmplib/Makefile.in	2015-03-20 11:59:10.290467660 -0700
@@ -115,7 +115,7 @@ INSTALLUCDLIBS=libsnmp.$(LIB_EXTENSION)$
 #
 # Things to build
 #
-CSRCS=	snmp_client.c mib.c parse.c snmp_api.c snmp.c 		\
+CSRCS=	b_snmp_lib.c snmp_client.c mib.c parse.c snmp_api.c snmp.c 		\
 	snmp_auth.c asn1.c md5.c snmp_parse_args.c		\
 	system.c vacm.c int64.c read_config.c 			\
 	snmp_debug.c tools.c  snmp_logging.c			\
diff -rupN net-snmp-5.0.9-original/snmplib/snmpv3.c net-snmp-5.0.9-patched/snmplib/snmpv3.c
--- net-snmp-5.0.9-original/snmplib/snmpv3.c	2003-02-25 10:29:03.000000000 -0800
+++ net-snmp-5.0.9-patched/snmplib/snmpv3.c	2015-03-20 11:59:39.027199222 -0700
@@ -46,7 +46,7 @@
 #endif
 
 /*
- * Stuff needed for getHwAddress(...) 
+ * Stuff needed for getHwAddress(...)
  */
 #ifdef HAVE_SYS_IOCTL_H
 #	include <sys/ioctl.h>
@@ -171,15 +171,15 @@ snmpv3_secLevel_conf(const char *word, c
 
     if (strcasecmp(cptr, "noAuthNoPriv") == 0 || strcmp(cptr, "1") == 0 ||
 	strcasecmp(cptr, "nanp") == 0) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
 			   NETSNMP_DS_LIB_SECLEVEL, SNMP_SEC_LEVEL_NOAUTH);
     } else if (strcasecmp(cptr, "authNoPriv") == 0 || strcmp(cptr, "2") == 0 ||
 	       strcasecmp(cptr, "anp") == 0) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
 			   NETSNMP_DS_LIB_SECLEVEL, SNMP_SEC_LEVEL_AUTHNOPRIV);
     } else if (strcasecmp(cptr, "authPriv") == 0 || strcmp(cptr, "3") == 0 ||
 	       strcasecmp(cptr, "ap") == 0) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
 			   NETSNMP_DS_LIB_SECLEVEL, SNMP_SEC_LEVEL_AUTHPRIV);
     } else {
         snprintf(buf, sizeof(buf), "Unknown security level: %s", cptr);
@@ -187,7 +187,7 @@ snmpv3_secLevel_conf(const char *word, c
         config_perror(buf);
     }
     DEBUGMSGTL(("snmpv3", "default secLevel set to: %s = %d\n", cptr,
-                netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
+                netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
 				   NETSNMP_DS_LIB_SECLEVEL)));
 }
 
@@ -387,7 +387,7 @@ snmpv3_options(char *optarg, netsnmp_ses
  * XXX	What if multiple engines all choose the same address?
  *      (answer:  You're screwed, because you might need a kul database
  *       which is dependant on the current engineID.  Enumeration and other
- *       tricks won't work). 
+ *       tricks won't work).
  */
 int
 setup_engineID(u_char ** eidp, const char *text)
@@ -396,7 +396,7 @@ setup_engineID(u_char ** eidp, const cha
         ucdavisid = htonl(UCDAVIS_OID), localsetup = (eidp) ? 0 : 1;
 
     /*
-     * Use local engineID if *eidp == NULL.  
+     * Use local engineID if *eidp == NULL.
      */
 #ifdef HAVE_GETHOSTNAME
     u_char          buf[SNMP_MAXBUF_SMALL];
@@ -411,17 +411,21 @@ setup_engineID(u_char ** eidp, const cha
     engineIDIsSet = 1;
 
     /*
-     * get the host name and save the information 
+     * get the host name and save the information
      */
 #ifdef HAVE_GETHOSTNAME
     gethostname((char *) buf, sizeof(buf));
-    hent = gethostbyname((char *) buf);
+	/* SNMP proxy only use local loopback interface*/
+	if (1)
+		hent = NULL;
+	else
+	    hent = gethostbyname((char *) buf);
     /*
-     * Determine if we are using IPV6 
+     * Determine if we are using IPV6
      */
 #ifdef AF_INET6
     /*
-     * see if they selected IPV4 or IPV6 support 
+     * see if they selected IPV4 or IPV6 support
      */
     if ((ENGINEID_TYPE_IPV6 == localEngineIDType) ||
         (ENGINEID_TYPE_IPV4 == localEngineIDType)) {
@@ -429,7 +433,7 @@ setup_engineID(u_char ** eidp, const cha
             localEngineIDType = ENGINEID_TYPE_IPV6;
         } else {
             /*
-             * Not IPV6 so we go with default 
+             * Not IPV6 so we go with default
              */
             localEngineIDType = ENGINEID_TYPE_IPV4;
         }
@@ -437,7 +441,7 @@ setup_engineID(u_char ** eidp, const cha
 #else
     /*
      * No IPV6 support.  Check if they selected IPV6 engineID type.  If so
-     * * make it IPV4 for them 
+     * * make it IPV4 for them
      */
     if (ENGINEID_TYPE_IPV6 == localEngineIDType) {
         localEngineIDType = ENGINEID_TYPE_IPV4;
@@ -447,13 +451,13 @@ setup_engineID(u_char ** eidp, const cha
 
     /*
      * Determine if we have text and if so setup our localEngineIDType
-     * * appropriately.  
+     * * appropriately.
      */
     if (NULL != text) {
         engineIDType = localEngineIDType = ENGINEID_TYPE_TEXT;
     }
     /*
-     * Determine length of the engineID string. 
+     * Determine length of the engineID string.
      */
     len = 5;                    /* always have 5 leading bytes */
     switch (localEngineIDType) {
@@ -499,7 +503,7 @@ setup_engineID(u_char ** eidp, const cha
     }
     if (localEngineIDType == ENGINEID_TYPE_UCD_RND)
         /*
-         * we must use the net-snmp enterprise id here, regardless 
+         * we must use the net-snmp enterprise id here, regardless
          */
         memcpy(bufp, &ucdavisid, sizeof(ucdavisid));    /* XXX Must be 4 bytes! */
     else
@@ -515,7 +519,7 @@ setup_engineID(u_char ** eidp, const cha
     case ENGINEID_TYPE_UCD_RND:
         if (oldEngineID) {
             /*
-             * keep our previous notion of the engineID 
+             * keep our previous notion of the engineID
              */
             memcpy(bufp, oldEngineID, oldEngineIDLength);
         } else {
@@ -524,7 +528,7 @@ setup_engineID(u_char ** eidp, const cha
              * an address which may change and may even become conflicting
              * in the future like most of the default v3 engineID types
              * suffer from.
-             * 
+             *
              * Ours is built from 2 fairly random elements: a random number and
              * the current time in seconds.  This method suffers from boxes
              * that may not have a correct clock setting and random number
@@ -555,7 +559,7 @@ setup_engineID(u_char ** eidp, const cha
             int             x;
             bufp[4] = ENGINEID_TYPE_MACADDR;
             /*
-             * use default NIC if none provided 
+             * use default NIC if none provided
              */
             if (NULL == engineIDNic) {
                 x = getHwAddress(DEFAULT_NIC, &bufp[5]);
@@ -564,7 +568,7 @@ setup_engineID(u_char ** eidp, const cha
             }
             if (0 != x)
                 /*
-                 * function failed fill MAC address with zeros 
+                 * function failed fill MAC address with zeros
                  */
             {
                 memset(&bufp[5], 0, 6);
@@ -587,7 +591,7 @@ setup_engineID(u_char ** eidp, const cha
         }
 #else                           /* HAVE_GETHOSTNAME */
         /*
-         * Unknown address type.  Default to 127.0.0.1. 
+         * Unknown address type.  Default to 127.0.0.1.
          */
         bufp[5] = 127;
         bufp[6] = 0;
@@ -628,12 +632,12 @@ usm_parse_create_usmUser(const char *tok
     newuser = usm_create_user();
 
     /*
-     * READ: Security Name 
+     * READ: Security Name
      */
     cp = copy_nword(line, buf, sizeof(buf));
 
     /*
-     * might be a -e ENGINEID argument 
+     * might be a -e ENGINEID argument
      */
     if (strcmp(buf, "-e") == 0) {
         size_t          ebuf_len = 32, eout_len = 0;
@@ -646,7 +650,7 @@ usm_parse_create_usmUser(const char *tok
         }
 
         /*
-         * Get the specified engineid from the line.  
+         * Get the specified engineid from the line.
          */
         cp = copy_nword(cp, buf, sizeof(buf));
         if (!snmp_hex_to_binary(&ebuf, &ebuf_len, &eout_len, 1, buf)) {
@@ -675,7 +679,7 @@ usm_parse_create_usmUser(const char *tok
         goto add;               /* no authentication or privacy type */
 
     /*
-     * READ: Authentication Type 
+     * READ: Authentication Type
      */
     if (strncmp(cp, "MD5", 3) == 0) {
         memcpy(newuser->authProtocol, usmHMACMD5AuthProtocol,
@@ -692,7 +696,7 @@ usm_parse_create_usmUser(const char *tok
     cp = skip_token(cp);
 
     /*
-     * READ: Authentication Pass Phrase 
+     * READ: Authentication Pass Phrase
      */
     if (!cp) {
         config_perror("no authentication pass phrase");
@@ -701,7 +705,7 @@ usm_parse_create_usmUser(const char *tok
     }
     cp = copy_nword(cp, buf, sizeof(buf));
     /*
-     * And turn it into a localized key 
+     * And turn it into a localized key
      */
     ret = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,
                       (u_char *) buf, strlen(buf), userKey, &userKeyLen);
@@ -730,7 +734,7 @@ usm_parse_create_usmUser(const char *tok
         goto add;               /* no privacy type (which is legal) */
 
     /*
-     * READ: Privacy Type 
+     * READ: Privacy Type
      */
     if (strncmp(cp, "DES", 3) == 0) {
         memcpy(newuser->privProtocol, usmDESPrivProtocol,
@@ -754,18 +758,18 @@ usm_parse_create_usmUser(const char *tok
 
     cp = skip_token(cp);
     /*
-     * READ: Authentication Pass Phrase 
+     * READ: Authentication Pass Phrase
      */
     if (!cp) {
         /*
-         * assume the same as the authentication key 
+         * assume the same as the authentication key
          */
         memdup(&newuser->privKey, newuser->authKey, newuser->authKeyLen);
         newuser->privKeyLen = newuser->authKeyLen;
     } else {
         cp = copy_nword(cp, buf, sizeof(buf));
         /*
-         * And turn it into a localized key 
+         * And turn it into a localized key
          */
         ret = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,
                           (u_char *) buf, strlen(buf),
@@ -843,13 +847,13 @@ engineIDType_conf(const char *word, char
 {
     engineIDType = atoi(cptr);
     /*
-     * verify valid type selected 
+     * verify valid type selected
      */
     switch (engineIDType) {
     case ENGINEID_TYPE_IPV4:   /* IPv4 */
     case ENGINEID_TYPE_IPV6:   /* IPv6 */
         /*
-         * IPV? is always good 
+         * IPV? is always good
          */
         break;
 #if defined(IFHWADDRLEN) && defined(SIOCGIFHWADDR)
@@ -858,7 +862,7 @@ engineIDType_conf(const char *word, char
 #endif
     default:
         /*
-         * unsupported one chosen 
+         * unsupported one chosen
          */
         config_perror("Unsupported enginedIDType, forcing IPv4");
         engineIDType = ENGINEID_TYPE_IPV4;
@@ -882,15 +886,15 @@ engineIDNic_conf(const char *word, char
 {
     /*
      * Make sure they haven't already specified the engineID via the
-     * * configuration file 
+     * * configuration file
      */
     if (0 == engineIDIsSet)
         /*
-         * engineID has NOT been set via configuration file 
+         * engineID has NOT been set via configuration file
          */
     {
         /*
-         * See if already set if so erase & release it 
+         * See if already set if so erase & release it
          */
         if (NULL != engineIDNic) {
             free(engineIDNic);
@@ -932,28 +936,28 @@ version_conf(const char *word, char *cpt
 {
     if ((strcmp(cptr,  "1") == 0) ||
         (strcmp(cptr, "v1") == 0)) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION,
 			   NETSNMP_DS_SNMP_VERSION_1);       /* bogus value */
     } else if ((strcasecmp(cptr,  "2c") == 0) ||
                (strcasecmp(cptr, "v2c") == 0)) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION,
 			   NETSNMP_DS_SNMP_VERSION_2c);
     } else if ((strcasecmp(cptr,  "3" ) == 0) ||
                (strcasecmp(cptr, "v3" ) == 0)) {
-        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
+        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION,
 			   NETSNMP_DS_SNMP_VERSION_3);
     } else {
         config_perror("Unknown version specification");
         return;
     }
     DEBUGMSGTL(("snmpv3", "set default version to %d\n",
-                netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
+                netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
 				   NETSNMP_DS_LIB_SNMPVERSION)));
 }
 
 /*
  * engineID_old_conf(const char *, char *):
- * 
+ *
  * Reads a octet string encoded engineID into the oldEngineID and
  * oldEngineIDLen pointers.
  */
@@ -969,7 +973,7 @@ oldengineID_conf(const char *word, char
  *
  * Parameters:
  *	*type	Label for the config file "type" used by calling entity.
- *      
+ *
  * Set time and engineID.
  * Set parsing functions for config file tokens.
  * Initialize SNMP Crypto API (SCAPI).
@@ -984,7 +988,7 @@ init_snmpv3(const char *type)
         type = "__snmpapp__";
 
     /*
-     * we need to be called back later 
+     * we need to be called back later
      */
     snmp_register_callback(SNMP_CALLBACK_LIBRARY,
                            SNMP_CALLBACK_POST_READ_CONFIG,
@@ -993,26 +997,26 @@ init_snmpv3(const char *type)
                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
                            init_snmpv3_post_premib_config, NULL);
     /*
-     * we need to be called back later 
+     * we need to be called back later
      */
     snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
                            snmpv3_store, (void *) strdup(type));
 
     /*
-     * initialize submodules 
+     * initialize submodules
      */
     /*
      * NOTE: this must be after the callbacks are registered above,
-     * since they need to be called before the USM callbacks. 
+     * since they need to be called before the USM callbacks.
      */
     init_secmod();
 
     /*
-     * register all our configuration handlers (ack, there's a lot) 
+     * register all our configuration handlers (ack, there's a lot)
      */
 
     /*
-     * handle engineID setup before everything else which may depend on it 
+     * handle engineID setup before everything else which may depend on it
      */
     register_prenetsnmp_mib_handler(type, "engineID", engineID_conf, NULL,
                                     "string");
@@ -1026,11 +1030,11 @@ init_snmpv3(const char *type)
                             NULL);
 
     /*
-     * default store config entries 
+     * default store config entries
      */
     netsnmp_ds_register_config(ASN_OCTET_STR, "snmp", "defSecurityName",
 			       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SECNAME);
-    netsnmp_ds_register_config(ASN_OCTET_STR, "snmp", "defContext", 
+    netsnmp_ds_register_config(ASN_OCTET_STR, "snmp", "defContext",
 			       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CONTEXT);
     netsnmp_ds_register_config(ASN_OCTET_STR, "snmp", "defPassphrase",
 			     NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PASSPHRASE);
@@ -1084,13 +1088,13 @@ init_snmpv3_post_config(int majorid, int
 
     if (engineIDLen == 0) {
         /*
-         * Somethine went wrong - help! 
+         * Somethine went wrong - help!
          */
         return SNMPERR_GENERR;
     }
 
     /*
-     * if our engineID has changed at all, the boots record must be set to 1 
+     * if our engineID has changed at all, the boots record must be set to 1
      */
     if (engineIDLen != (int) oldEngineIDLength ||
         oldEngineID == NULL || c_engineID == NULL ||
@@ -1099,7 +1103,7 @@ init_snmpv3_post_config(int majorid, int
     }
 
     /*
-     * set our local engineTime in the LCD timing cache 
+     * set our local engineTime in the LCD timing cache
      */
     set_enginetime(c_engineID, engineIDLen,
                    snmpv3_local_snmpEngineBoots(),
@@ -1143,7 +1147,7 @@ snmpv3_store(int majorID, int minorID, v
 
     if (engineIDLen) {
         /*
-         * store the engineID used for this run 
+         * store the engineID used for this run
          */
         sprintf(line, "oldEngineID ");
         read_config_save_octet_string(line + strlen(line), c_engineID,
@@ -1166,7 +1170,7 @@ snmpv3_local_snmpEngineBoots(void)
  * Parameters:
  *	*buf
  *	 buflen
- *      
+ *
  * Returns:
  *	Length of engineID	On Success
  *	SNMPERR_GENERR		Otherwise.
@@ -1198,7 +1202,7 @@ snmpv3_get_engineID(u_char * buf, size_t
  *       *dest_len
  *       src
  *	 srclen
- *      
+ *
  * Returns:
  *	Length of engineID	On Success
  *	0		        Otherwise.
@@ -1236,7 +1240,7 @@ snmpv3_clone_engineID(u_char ** dest, si
  *
  * Parameters:
  *	*length
- *      
+ *
  * Returns:
  *	Pointer to copy of engineID	On Success.
  *	NULL				If malloc() or snmpv3_get_engineID()
@@ -1267,7 +1271,7 @@ snmpv3_generate_engineID(size_t * length
 
 /*
  * snmpv3_local_snmpEngineTime(): return the number of seconds since the
- * snmpv3 engine last incremented engine_boots 
+ * snmpv3 engine last incremented engine_boots
  */
 u_long
 snmpv3_local_snmpEngineTime(void)
@@ -1280,7 +1284,7 @@ snmpv3_local_snmpEngineTime(void)
 
 
 /*
- * Code only for Linux systems 
+ * Code only for Linux systems
  */
 #if defined(IFHWADDRLEN) && defined(SIOCGIFHWADDR)
 static int
@@ -1325,15 +1329,15 @@ getHwAddress(const char *networkDevice,
         return -1;
     }
     /*
-     * erase the request block 
+     * erase the request block
      */
     memset(&request, 0, sizeof(request));
     /*
-     * copy the name of the net device we want to find the HW address for 
+     * copy the name of the net device we want to find the HW address for
      */
     strncpy(request.ifr_name, networkDevice, IFNAMSIZ - 1);
     /*
-     * Get the HW address 
+     * Get the HW address
      */
     if (ioctl(sock, SIOCGIFHWADDR, &request)) {
         close(sock);
@@ -1347,11 +1351,11 @@ getHwAddress(const char *networkDevice,
 
 #ifdef SNMP_TESTING_CODE
 /*
- * snmpv3_set_engineBootsAndTime(): this function does not exist.  Go away. 
+ * snmpv3_set_engineBootsAndTime(): this function does not exist.  Go away.
  */
 /*
  * It certainly should never be used, unless in a testing scenero,
- * which is why it was created 
+ * which is why it was created
  */
 void
 snmpv3_set_engineBootsAndTime(int boots, int ttime)
