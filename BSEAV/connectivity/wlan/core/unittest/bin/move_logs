#!/usr/bin/tclsh

# Written by John Brearley 2011

# Data to be customized by user.
# BUT you may NOT delete / comment out any of these variables!

#set username $::tcl_platform(user)
#set src_location "/projects/hnd_sig_extN/$username"
#set sub_dirs "mcx1 mcx2"
#set dest_location "/projects/hnd_sig_extN/$username"
#set file_del_patterns "*.pcap *.log.html" ;# file types to be deleted

set username $::tcl_platform(user)
set src_location "/projects/hnd_sig_ext4/$username"
set sub_dirs "mc11 mc33 mc38 mc52 mc56 mc30 mc45"
set dest_location "/projects/hnd_sig_arc2/$username"
set file_del_patterns "*.pcap *.log.html" ;# file types to be deleted

# END of customization section.

#===============================================================================
# Common procs
#===============================================================================
proc check_disk_usage {type path} {

    # Get current disk usage for whole volume
    # puts "check_disk_usage $path"
    set catch_resp [catch "set df \[exec df \"$path\"\]" catch_msg]
    if {$catch_resp != 0} {
        log_warn "check_disk_usage could not get df for $path, $catch_msg"
        return OK
    }
    # puts "df=$df"

    # Parse out nn%
    if {![regexp {\s+(\d+)\s*%} $df - percent]} {
        log_warn "check_disk_usage parsing failure for $path, df=$df"
        return OK
    }
    # puts "percent=$percent"

    # Warn user if dest >= 95% full.
    # set percent 96 ;# test code
    if {$type == "dest" && $percent >= 95} {
        log_warn "check_disk_usage $type $path ${percent}% full!!!"
    } else {
        log_info "check_disk_usage $type $path ${percent}% full"
    }
    return OK
}

#===============================================================================
proc del_files {src_path patterns} {

    # Delete files that match patterns from src_path
    puts "del_files $src_path $patterns"
    foreach type $patterns {
        # Glob pattern search current directory and up to 2 subdirectories down.
        set file_list [glob -nocomplain $src_path/{,/*/,/*/*/}$type]
        # puts "type=$type file_list=$file_list"
        foreach file $file_list {
            puts "del_files deleting: $file"
            set catch_resp [catch "file delete -force \"$file\"" catch_msg]
            if {$catch_resp == 0} {
                incr ::deleted
            } else {
                log_warn "del_files could not delete $file, $catch_msg"
            }
        }
    }
}

#===============================================================================
proc exit_rtn {rc} {
    # rc=0 is success, otherwise got error.

    # Did we move anything?
    if {$rc == 0 && $::moved == 0} {
       log_warn "Nothing moved!"
    }

    # Adjust warning count. We add 2 warnings below if there were any other warnings.
    if {$::warnings > 0} {
        incr ::warnings 2 
    }

    # Show stats.
    set end_sec [clock seconds]
    set min [expr ($end_sec - $::start_sec) / 60]
    set msg1 "checked $::checked directories, moved $::moved directories, deleted $::deleted files, $::warnings warnings."
    set msg3 "$::self all done, time $min min, see log $::log_name"
    if {$rc == 0} {
        if {$::warnings == 0 && $::moved > 0} {
            # We did move some directories, no warnings.
            set msg2 "Migrate was successful, $msg1"
            log_ok "$msg2"
            log_ok "$msg3"
        } else {
            if {$::moved > 0} {
            # We did move some directories, but got warnings.
                set msg2 "Migrate was successful, $msg1"
            } else {
                set msg2 $msg1
            }
            log_warn "$msg2"
            log_warn "$msg3"
        }
    } else {
        # We got an error.
        set msg2 "Migrate stopped on ERROR above, $msg1"
        log_error "$msg2"
        log_error "$msg3"
    }

    # restore normal setting
    fconfigure stdin -blocking 1 

    # Use rc on exit.
    exit $rc
}

#===============================================================================
proc get_mtime_days {path} {

    # Returns days since path last modified.
    # Get mtime in Unix time, seconds.
    set catch_resp [catch "set mtime_sec \[file mtime \"$path\"\]" catch_msg]
    if {$catch_resp != 0} {
        log_error "get_mtime_days could not get mtime for $path, $catch_msg"
        exit_rtn 1
    }

    # mtime must be integer.
    if {![regexp {^\d+$} $mtime_sec]} {
        log_error "get_mtime_days invalid mtime_sec=$mtime_sec for $path, must be integer!"
        exit_rtn 1
    }

    # Convert to relative age, in days .
    set delta [expr $::start_sec - $mtime_sec]
    set mtime_days [expr $delta / 24 / 3600]
    # puts "get_mtime_days $path mtime_sec=$mtime_sec delta=$delta mtime_days=$mtime_days"
    return $mtime_days
}

#===============================================================================
proc log_bold {msg} {

    # Add bold tags, call log_info
    set msg "<b>${msg}</b>"
    log_info $msg
}

#===============================================================================
proc log_error {msg} {

    # Add RED bold tags, call log_info
    set msg "<b><font color=\"red\">ERROR: ${msg}</font></b>"
    log_info $msg
}

#===============================================================================
proc log_info {msg} {

    # Show msg on stdout, add html tags for log file.
    puts "$msg"
    puts $::out "${msg}<br>"
    flush $::out
    return OK
}

#===============================================================================
proc log_ok {msg} {

    # Add GREEN bold tags, call log_info
    set msg "<b><font color=\"green\">OK: ${msg}</font></b>"
    log_info $msg
}

#===============================================================================
proc log_warn {msg} {

    # Add GOLD bold tags, call log_info
    set msg "<b><font color=\"gold\">WARNING: ${msg}</font></b>"
    log_info $msg
    incr ::warnings
}

#===============================================================================
proc migrate_dir {src_path dest_path msg} {

    # NB: We NEVER delete the new destination directory. This is to allow the user
    # to manually recover from the scenario that the were files copied OK, but during the
    # file deletion, there was a file with messed up permissions and the delete stopped.
    # In this scenario the files are all safely in their new home. If we tried migrating
    # this directory again, and we were to start by deleting the destination directory,
    # we would end up with a partial directory, as some of the source files had been
    # deleted already. So for permission issues, its best to let the user sort out the 
    # manual recovery needed for the specific error that occurred. 

    # Get new destination subdirectory from src_path
    set new_dest_sub_dir [file tail "$src_path"]

    # Copy the src to dest
    # NB: TCL will create new destination directory
    # NB: If destination directory exists, TCL will put a new copy inside existing directory
    set dest_path "$dest_path/$new_dest_sub_dir"
    puts "migrate_dir copy $src_path to $dest_path..."
    set catch_resp [catch "file copy -force \"$src_path\" \"$dest_path\"" catch_msg]
    if {$catch_resp != 0} {
        log_error "migrate_dir could not copy $src_path to $dest_path, $catch_msg"
        exit_rtn 1
    }

    # Delete src
    puts "migrate_dir delete $src_path..."
    set catch_resp [catch "file delete -force \"$src_path\"" catch_msg]
    if {$catch_resp != 0} {
        log_error "migrate_dir could not delete $src_path, $catch_msg"
        exit_rtn 1
    }

    # Add symbolic link from src to dest
    puts "migrate_dir add sym link..."
    set catch_resp [catch "file link -symbolic \"$src_path\" \"$dest_path\"" catch_msg]
    if {$catch_resp != 0} {
        log_error "migrate_dir could not link $src_path to $dest_path, $catch_msg"
        exit_rtn 1
    }

    # Log the successfull migration.
    incr ::moved
    log_info "migrate_dir migrated $src_path to $dest_path OK $msg"
    return OK
} 

#===============================================================================
proc open_log { } {

    # If necessary, create public_html directory
    set log_dir "/home/$::env(LOGNAME)/public_html"
    set public 0
    if {![file isdirectory "$log_dir"]} {
        set catch_resp [catch "file mkdir \"$log_dir\"" catch_msg]
        if {$catch_resp != 0} {
            error "ERROR: open_log could not create $log_dir $catch_msg"
        } else {
            set public 1
        }
    }

    # Open log file for results.
    set ::log_name "$log_dir/$::self.results.html"
    set catch_resp [catch "set ::out \[open \"$::log_name\" a\]" catch_msg]
    if {$catch_resp != 0} {
        error "ERROR: open_log could not open $::log_name, $catch_msg"
    }
    # puts "log_name=$::log_name out=$::out"

    # Delay message until log file is opened OK.
    if {$public} {
        log_bold "\n\n<br><br>Created $log_dir"
    }
    return OK
}

#===============================================================================
proc stop_loop { } {

    # Gracefully stops main loop if user typed "s" + "Enter" while program is running.
    puts "----> Type \"s\" + \"Enter\" to GRACEFULLY stop this program. DONT use Ctl-C!"
    # Main program sets stdin to non-blocking mode so
    # script will continue on if there is no keyboard input
    gets stdin in_str ;# read from keyboard
    set in_str [string trim $in_str]
    set in_str [string tolower $in_str]
    # puts "in_str=$in_str"
    if {$in_str != "s"} {
        return
    }

    # User said to stop.
    log_warn "Gracefully halting $::self ..."

    # Are disks getting full?
    check_disk_usage src $::src_location
    check_disk_usage dest $::dest_location
    exit_rtn 0
}

#===============================================================================
# Main program
#===============================================================================
# Basic initialization
set ::self [file root [file tail $::argv0]]
set checked 0
set deleted 0
set moved 0
set warnings 0

# Check calling tokens
set x [lindex $argv 0]
set x [string range $x 0 1]
set x [string tolower $x]
if {$argc == 0 || $x == "-h" || $x == "/?"} {
    puts " "
    puts "Basic uasge: $::self <daterange>"
    puts "Basic uasge: $::self -age <days>"
    puts " "
    puts "Script will move specific directories to a new destination volume"
    puts "and put symbolics link from the source volume to the destination volume."
    puts " "
    puts "Directories to be moved are chose by a specific daterange or a greater"
    puts "than age. Daterange can be a simple numeric string, eg \"201102\" or a"
    puts "simple regexp, eg: \"20110\[0-5\]\""
    puts " "
    puts "For manual moves, daterange is often the preferred choice."
    puts "For cron job usage, the -days option is the preferred choice."
    puts " "
    puts "Customized for:"
    puts "src: $src_location"
    puts "dest: $dest_location"
    puts "sub_dirs=$sub_dirs"
    puts "file_del_patterns=$file_del_patterns"
    exit -1
}

# Open log file
open_log
set start_sec [clock seconds]
set now [clock format $start_sec -format %Y%m%d.%H%M%S]
puts $::out "\n\n" ;# add separator lines in log file
log_bold "<br><br><hr>$now $::argv0 starting, file_del_patterns: $file_del_patterns command_line_args: $::argv"

# Parse calling tokens.
set age ""
set age_lim 30
set date_range ""
for {set i 0} {$i < $::argc} {incr i} {
    # Get next command line token
    set token [lindex $::argv $i]

    # Check for -age nn
    if {$age == "" && $token == "-age"} {
        # Next token must be integer
        incr i
        set age [lindex $::argv $i]
        if {![regexp {^\d+$} $age]} {
            log_warn "Invalid age: $age, must be positive integer, set to $age_lim"
            set age $age_lim
        }
        if {$age < $age_lim} {
            log_warn "age $age to low, set to $age_lim"
            set age $age_lim
        }
        continue
    }

    # Look for date_range, which could be a simple regexp. 
    if {$date_range == ""} {
        set date_range $token
        regsub -all {\*} $date_range "" date_range ;# wildcard messes things up!
        if {![regexp {^[\d\-\[\]]+$} $date_range]} {
            log_warn "date_range: $date_range does not seem numeric or simple regexp. This might be OK for some specialized moves."
        }
        continue
    }

    # Unknown token 
    log_error "Unknown token: $token"
    exit_rtn 1
}

# src must be different from dest.
if {$src_location == $dest_location} {
    log_error "src_location=$src_location MUST BE DIFFERENT FROM dest_location=$dest_location"
    exit_rtn 1
}

# Environment checks
foreach path "$src_location $dest_location" {
    # Check base volume exists
    set volume [file dirname "$path"]
    if {![file isdirectory "$volume"]} {
        log_error "ERROR: volume=$volume not found!"
        exit_rtn 1
    }

    # Create user subdirectory if needed
    if {![file isdirectory "$path"]} {
        # Try to create path
        set catch_resp [catch "file mkdir \"$path\"" catch_msg] 
        if {$catch_resp == 0} {
            log_bold "Created $path"
        } else {
            log_error "Could not create path=$path, $catch_msg"
            exit_rtn 1
        }
    }

    # Check user directory is writable
    if {![file writable "$path"]} {
        log_error "path=$path not writable!"
        exit_rtn 1
    }
}
puts "Src/Dest paths OK"

# Are disks getting full?
check_disk_usage src $src_location
check_disk_usage dest $dest_location

# Get today, yesterday & tomorrow dates, for additional error prevention.
set date_today [clock format $start_sec -format %Y%m%d]
set temp [expr $start_sec - (24*60*60)] 
set date_yesterday [clock format $temp -format %Y%m%d]
set temp [expr $start_sec + (24*60*60)] 
set date_tomorrow [clock format $temp -format %Y%m%d]
# log_info "date_yesterday=$date_yesterday date_today=$date_today date_tomorrow=$date_tomorrow"

# Main loop
fconfigure stdin -blocking 0 ;# script will continue on if there is no keyboard input
foreach sub $sub_dirs {

    # More environment checks
    puts "**************************************************************************************"
    set dest_path "$dest_location/$sub"
    if {![file isdirectory "$dest_path"]} {
        # Try to create path
        set catch_resp [catch "file mkdir \"$dest_path\"" catch_msg] 
        if {$catch_resp == 0} {
            log_bold "Created $dest_path"
        } else {
            log_error "Could not create dest_path=$dest_path, $catch_msg"
            exit_rtn 1
        }
    }
    set src_path "$src_location/$sub"
    if {![file isdirectory "$src_path"]} {
        log_error "src_path=$src_path not found!"
        exit_rtn 1
    }

    # Show age or date_range in description
    if {$age != ""} {
        set desc "age GT $age days"
    } else {
        set desc "date_range MATCHING $date_range"
    }

    # Get list of files in src_path
    # set src_path "$src_location/aaa" ;# test code
    log_bold "----> Processing: $sub $desc"
    set dir_list [glob -nocomplain $src_path/*]
    # puts "dir_list=$dir_list"
    if {[llength $dir_list] == 0} {
        log_error "src_path=$src_path has no files/directories!"
        exit_rtn 1
    }

    # Process each directory.
    set dir_list [lsort $dir_list] ;# easier for humans to have sorted list
    foreach dir $dir_list {

        # Skip symbolic links, anything not a directory.
        # Do this first to avoid confusion with age checks.
        # puts "processing $dir" 
        incr checked
        set type [file type "$dir"]
        if {$type != "directory"} {
            # Dont put in log file, but show user on stdout.
            puts "Skipping $type: $dir"
            continue
        }

        # Age option, if present takes precedance over date_range.
        set dir_digits [file tail $dir] ;# always needed
        set msg ""
        # puts "sub=$sub dir=$dir dir_digits=$dir_digits"
        if {$age != ""} {
            set dir_age [get_mtime_days $dir]
            set msg "age: $dir_age days"
            if {$dir_age <= $age} {
                # Dont put in log file, but show user on stdout.
                puts "Skipping $dir too new, $msg"
                continue
            }

        } else {
            # Does dir match date_range?
            # puts "sub=$sub dir=$dir dir_digits=$dir_digits"
            if {![regexp ^$date_range $dir_digits]} {
                # puts  "$dir not in range: $date_range"
                continue
            }
        }

        # If dir matches yesterday / today / tomorrow dates, there is a risk
        # of moving the directory of a test still running / in progress.
        # This is a very bad thing to do, can result in tests just stopping
        # and / or mangled test report files.
        if {[regexp ^$date_today $dir_digits] || [regexp ^$date_yesterday $dir_digits] ||\
            [regexp ^$date_tomorrow $dir_digits]} {
            log_info "Skipping yesterday/today/tomorrow directory: $dir"
            continue
        }

        # Never move the perfcache!
        if {[regexp {perfcache} $dir]} {
            log_info "Skipping $dir"
            continue
        }

        # First we clean up selected files.
        puts "********************************** $desc"
        del_files "$dir" "$file_del_patterns"

        # Check if user wants to gracefully stop main loop.
        puts "********************************** $desc"
        stop_loop

        # Now we migrate the directory
        migrate_dir $dir $dest_path $msg
    }

    # Are disks getting full?
    check_disk_usage src $src_location
    check_disk_usage dest $dest_location
}

# Thats it.
exit_rtn 0


