#!/usr/local/bin/tclsh

# Written by John Brearley 2009

# Used to fix path names in UTF log file summary.html files.

#==================== Cleanup =====================================
# Routine that cleans up when script is done. 
#
# Calling parameters: none
# Returns: exits the script.
#==================================================================
proc cleanup { } {
   global changed_lines in in_file out out_file self

   # We are done with the input file.
   catch "close $in"

   # Flush & close the output file.
   catch "flush $out"
   catch "close $out"

   # Rename out_file to be the new in_file.
   catch "file rename -force \"$out_file\" \"$in_file\""

   # Display final stats. Exit code is number of lines added.
   # This allows a higher level script to keep track of overall
   # total items added.
   puts "$self All done, changed_lines=$changed_lines." 
   exit
}

#==================== Help ========================================
# Routine that gives online help.
#
# Calling parameters: none
# Returns: OK or exits script.
#==================================================================
proc help { } {
   global argv argv0 self 

   # Check if help was requested or not.
   set self [file tail $argv0]
   set x [lindex $argv 0]
   set x [string tolower $x]
   set x [string range $x 0 1]
   if {[string compare $x "-h"] != 0 && [string compare $x "/?"] != 0} {
      return OK
   }

   # Give help
   puts " "
   puts "Usage: $self \[file_name.html\] "
   puts " "
   puts "When you move a UTF directory with a summary.html results web page"
   puts "and associated files to another directory, the fullpath web links"
   puts "in the summary.html file become invalid. This script fixes them"
   puts "up to match the new parent directory."
   exit -1
}

#==================== Read_Line_Dump ==============================
# Routine that reads a line of data from the input file & decides
# when & where to add traces. The line of data from the input file 
# is always added to output file so that we never lose any code.
#
# Calling parameters: none
# Returns: OK or exits script on error.
# Sets various global variables.
#==================================================================
proc read_line_dump { } {
   global changed_lines dir_path in line_cnt out self wrong_path

   # Get line of data.
   incr line_cnt ;# file line number
   set catch_resp [catch "gets $in line" catch_msg]
   if {$catch_resp != 0} {

      # When we exit here, the original file is not replaced by the new
      # output file. Thus the original file is not changed at all.
      puts "$self ERROR: reading input file line_cnt=$line_cnt catch_msg=$catch_msg"
      exit -1
   } 
   # puts "line_cnt=$line_cnt line=$line"

   # Look for the base href line in the file.
   if {$wrong_path == "" && [regexp -nocase {<base href=} $line]} {
      # puts "found base href line_cnt=$line_cnt line=$line"
      # Extract the old wrong path 
      if {[regexp {\.com(.*)\.htm} $line - wrong_path]} {
         set wrong_path [file dirname "$wrong_path"]
         puts "line_cnt=$line_cnt wrong_path=$wrong_path"
         puts "dir_path=$dir_path"

      } else {
         puts "$self ERROR: could not extract old wrong path line_cnt=$line_cnt line=$line"
         exit -1
      }
   }

   # Sanity check that we got wrong_path
   if {$line_cnt >= 30 && $wrong_path == ""} {
      puts "$self ERROR: could not find base href"
      exit -1
   }

   # Fix wrong path in each line.
   if {$wrong_path != "" && [regexp -nocase "$wrong_path" $line]} {
      # puts "\nBefore: line_cnt=$line_cnt line=$line"
      regsub -all -nocase "$wrong_path" $line "$dir_path" line
      # puts "\nAfter:  line_cnt=$line_cnt line=$line"
      incr changed_lines
   }

   # Always put a line on the output file
   puts $out "$line"
   return OK
}

#==================== Setup ======================================
# Routine that does basic setup, parses command line tokens, opens
# the input file and output file.
#
# Calling parameters: none
# Returns: OK or exits script.
#==================================================================
proc setup { } {
   global argc argv0 argv changed_lines dir_path in in_file line_cnt\
      out out_file wrong_path

   # Miscellaneous initialization.
   set changed_lines 0
   set line_cnt 0
   set wrong_path ""

   # Get our own script name.
   set self [file tail $argv0]

   # Get required input file name from command line tokens.
   if {$argc > 0} {
      set in_file [lindex $argv 0]
   } else {
      puts "$self ERROR: You must specify the input file. \nFor more info, type: tclsh $argv0 -h"
      exit -1
   }

   # Convert \ to / in file path.
   set in_file [split $in_file \\]
   set in_file [join $in_file /]

   # Ensure we have full pathname.
   # If filename doesnt start with something like c:/ or /, add pwd.
   if {![regexp {^.:/} $in_file] && ![regexp {^/} $in_file]} {
      set in_file "[pwd]/${in_file}"
   }

   # Check input file exists.
   if {![file exists "$in_file"]} {
      puts "$self ERROR: file $in_file not found!"
      exit -1
   }

   # Get directory path from input file
   set dir_path [file dirname "$in_file"]
   # puts "dir_path=$dir_path"

   # Open input file.
   set catch_resp [catch "set in \[open \"$in_file\" r\]" catch_msg]
   if {$catch_resp != 0} {
      puts "$self ERROR: could not open $in_file catch_msg=$catch_msg"
      exit -1
   }
   # puts "in_file=$in_file in=$in"

   # Create output file name, with .tmp appended to input filename. 
   set out_file "${in_file}.tmp"

   # Open output file. Existing file, if any, is blown away.
   set catch_resp [catch "set out \[open \"$out_file\" w\]" catch_msg]
   if {$catch_resp != 0} {
      puts "$self ERROR: could not open $out_file catch_msg=$catch_msg"
      exit -1
   }
   # puts "out_file=$out_file out=$out"
   return OK
}

#==================== Main Program ================================
# This is the main program. 
#==================================================================

# Check if online help was requested
help

# Basic setup
setup

# Now we process the input file one line at a time.
while {![eof $in]} {

   # Read a line of input file, update paths as needed.
   read_line_dump
}

# Thats it!
cleanup

