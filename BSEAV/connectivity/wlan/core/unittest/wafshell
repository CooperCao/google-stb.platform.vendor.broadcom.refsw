#!/usr/bin/expect
# -*-tcl-*-
#
# $Copyright Broadcom Corporation$
# $Id$
#

proc connect {} {
    global spawn_id
    exp_send "\r"
    interact {
	"\u0016\u0004" {
	    exp_send "\u0016\u0004"
	}
	"\u0004" {
	    return
	}
    }
    send_user "\r"
}



proc command {args} {
    set cmd [join $args " "]

    global spawn_id
    exp_send "\r"
    set deadcount 0
    expect {
	-timeout 1
	-re {\u00ff..} {
	    # pause if we see a telnet negotiation, otherwise
	    # expect may read an early EOF
	    sleep 0.1
	    exp_continue
	}
	default {
	    puts stderr "connect failed"
	    #exp_send "\b"
	    #exit 1
	}
	-re {WAF> $}
    }

    # Send command
    exp_send -- "$cmd\r"

    # Skip command echo.  If we don't spot the echo quickly, ignore it
    # and move on
#    expect {
#	-timeout 1 timeout {}
#	-re "$cmd\r\n"
#    }

    set ret_code ""
    expect {
	-re "WAFCmdOut: (.*\r)" {
	    exp_send_user -- "$expect_out(1,string)"
	    exp_continue
	}
	-re "WAFCmdResult: (\[0-9\]+)\r" {
	    set ret_code $expect_out(1,string)
	}
    }
    if {$ret_code == ""} {
	set ret_code 255
    }
    # Send some data - workaround for 1-second close down bug on older
    # versions of expect
    exp_send "\b"
    exit $ret_code
}

proc usage {} {
    puts stderr "Usage: $::argv0 \[-\](dev|ip:port) \[cmd \[args ...\]\]"
    exit 1
}

# Args
if {[llength $argv] > 0 && [set host [lindex $argv 0]] != "-man"} {

    if {[info exists env(EXP_INTERNAL)]} {
	exp_internal 1
    } else {
	exp_internal 0
    }
    log_user 0
    set logger [regexp {^-(.*)} $host - host]
    if {[catch {
	if {[string match "*/*" $host]} {
	    # reject background (logging) processes if they try to
	    # talk to the device directly.
	    if {$logger} {
		exit
	    }
	    set fd [open $host {RDWR NONBLOCK}]
	    fconfigure $fd \
		-mode {115200,n,8,1} -buffering none -blocking 0
	    catch {fconfigure $fd -handshake xonxoff}
	    spawn -noecho -open $fd
	} else {
	    # Telnet gets a new session so no reset needed
	    if {![regexp {(.*):(.*)} $host - host port]} {
		set port 23
	    }
	    spawn -noecho -open [socket $host $port]
	}

	# Make sure we're using the same encoding as consolelogger
	fconfigure $spawn_id -encoding binary

	set timeout 60

	if {[llength $argv] == 1} {
	    connect
	} else {
	    set cmd [lindex $argv 1]
	    if {[llength $argv] == 2} {
		# Whole commandline probably quoted as one string
		set argv [lreplace $cmd 0 0]
		set cmd  [lindex $cmd 0]
	    } else {
		set argv [lreplace $argv 0 1]
	    }
	    eval command $cmd $argv
	}
    } ret]} {
	puts stderr $ret
	exit 1
    }
    exit 0
}

# Leave this 'til last to improve performance
lappend auto_path . /projects/hnd/tools/linux/share/unittest \
    /projects/hnd/tools/linux/share/tcllib1.10
package require UTF::doc

UTF::doc {
    # [manpage_begin wafshell n 1.0]
    # [moddesc {HND Wireless Test Framework}]
    # [titledesc {tool for managing Olympic devices}]
    # [copyright {2015 Broadcom Corporation}]
    # [description]
    # [para]

    # [cmd wafshell] is a command for communicating with a proprietory
    # test framework via consolelogger.

    # [list_begin arguments]

    # [arg_def "" connection]

    # Every [cmd wafshell] command requires a [arg connection]
    # argument which specifies the mechanism for communicating with
    # the device.

    # [list_begin arguments]

    # [arg_def "" address:port]

    # The hostname or IP address and TCP port of a terminal server or
    # [cmd consolelogger] session.

    # [list_end]
    # [list_end]
    # [list_begin definitions]

    # [call [cmd wafshell] [arg connection] [lb][cmd {cmd ...}][rb]]

    # Passes [cmd {cmd ...}] to the framework.  Returns results and
    # exit status.  If a command line is not specified, an interactive
    # terminal session is started.  To disconnect from the session use
    # ^D (however, like a regular tty. if you need to input a literal
    # ^D to the session you can escape it by using ^V^D).

    # [list_end]

    # [see_also [uri APdoc.cgi?consolelogger consolelogger]]
    # [see_also [uri APdoc.cgi?apshell apshell]]

    # [manpage_end]
}

UTF::man
exit

