#!/usr/bin/expect
# -*-tcl-*-
#
# $Copyright Broadcom Corporation$
# $Id$
#

# This shell is used to talk to Agilent power supplies that
# use a serial port. The Agilent requires a line-feed character
# (not new-line) as the command string termination character.
# The use of the line-feed is the primary reason for a separate
# shell script for the Agilent power supply serial port.

#==============================================================================
# Common procedures
#==============================================================================
proc command {args} {
    global spawn_id
    set cmd [join $args " "];# flattens the list, removing braces
    # puts "command cmd=$cmd"

    # Flush any unprocessed output
    set catch_resp [catch "expect -timeout 0 -re {.+$} { }" catch_msg]
    # puts "command catch_resp=$catch_resp catch_msg=$catch_msg"

    # Send the command string to the Agilent power supply.
    # Key point here is to use \012, which is a line-feed.
    # Agilent power supply ignores new-line!
    exp_send "$cmd\012" ;# \012 = line-feed

    # Many Agilent commands do not generate any output at all.
    # NB: Commands can be daisy-chained together with semi-colons
    # into a larger composite command string. 
    # Some commands in the larger command string may be silent, but
    # others may genereate output. So, if there is a "?" anywhere in
    # the command string, we have a reasonable expectation of a 
    # response from the Agilent power supply. Otherwise, rather than
    # wait for a timeout to occur, we return immediately.
    if {![regexp {\?} $cmd]} {
       # puts "$::self command no response expected for: $cmd"
       return
    }

    # We really do expect a response.
    set timeout 5
    expect {
        -re {\n?(.*)\n} {
            # puts "command expect_out(1,string)=$expect_out(1,string)"
            if {[regexp {^(\d+)$} $expect_out(1,string) - code]} {
                puts "command trace 0 code=$code"
                
            } elseif {[regexp {(.*);(\d+)$} $expect_out(1,string) - ret code]} {
                exp_send_user -- "$ret\n"
                puts "command trace 1 ret=$ret code=$code"

            } else {
                # Return for normal output. 
                return
            }
        }
        timeout {
            error "$::self ERROR timeout for: $cmd"
        }
    }

    # So far I have never been able to make the code go down here.
    # In the fullness of time this code will probably get removed.
    switch $code {
        0 { exit "0" }
        8 { error "DDE: Device Dependent error" }
        16 { error "EXE: Execution error" }
        32 { error "CME: Command error" }
        default { error "$code: Unknown error" }
    }
}

#==============================================================================
# Main program starts here.
#==============================================================================
set ::self [file tail $::argv0] ;# get our own name

# Skip main program if first token is null or "-man", so we hit the man page 
# info section at the end of the file.
set host [string trim [lindex $argv 0]]
if {$host != "" && $host != "-man"} {

    # If environment variable EXP_INTERNAL exists and is set to 1,
    # turn on the expect internal traces for debugging.
    if {[info exists env(EXP_INTERNAL)] && $env(EXP_INTERNAL) == 1} {
        exp_internal 1
        puts "$::self expect internal tracing on"
    } else {
        exp_internal 0
        # puts "$::self expect internal tracing off"
    }

    # Remove ip:port token from argv. The command string is left.
    set argv [lreplace $argv 0 0]
    set argv [join $argv " "] ;# flattens the list, removing braces
    # puts "$::self host token removed argv=$argv"

    # If no command string available, exit.
    if {[llength $argv] == 0} {
        error "$::self ERROR: no command string supplied! For more info, type: $::self"       
    } 

    # log_user controls expect stdout. We need it ON!
    log_user 1

    # There may be some background UTF processes poking around,
    # which we reject.
    set logger [regexp {^-(.*)} $host - host]
    # puts "$::self host=$host logger=$logger"
    if {$logger} {
        puts "$::self rejecting logger"
        exit 0
    }

    # Start new telnet session.
    if {![regexp {(.*):(.*)} $host - host port]} {
        set port 40000 ;# default consolelogger port number
    }
    # puts "$::self setup for telnet host=$host port=$port"
    set catch_resp [catch "spawn -noecho -open \[socket $host $port\]" catch_msg]
    if {$catch_resp != 0} {
        error "$::self ERROR: spawn host=$host port=$port catch_resp=$catch_resp catch_msg=$catch_msg"
    }

    # Send the command string to the Agilent power supply.
    eval command $argv
    exit 0
}

#==============================================================================
# Pseudo man page to display when user types: agshell
#                                         or: agshell -man
#==============================================================================
# Skip help info if being sourced
if {![info exists ::argv0] || ![string match [info script] $::argv0]} {
    return
}

puts "\nUsed to control Agilent power supplies via their serial port.\n"
puts "To configure the Agilent power supply to use the serial port, push the"
puts "\"I/O Config\" button, turn the large white knob to select RS-232, wait a moment,"
puts "turn the knob again to select 9600 baud, wait a moment, use the knob to select"
puts "8-bits and then push the \"I/O Config\" button to save the changes. Please"
puts "power cycle the unit and then check that the config is still set to serial.\n" 
puts "The Agilent power supply is expected to have a consolelogger process providing"
puts "network access to the serial port. Typically the Agilent serial port is set to"
puts "9600 baud, so on the consolelogger process will need to use the option"
puts "\"-baud 9600\" on the linux event.d script or windows shortcut used to start"
puts "consolelogger. Consolelogger defaults to 115,200 baud. There will be no response"
puts "from the Agilent if the baud rate is mismatched.\n"
puts "If you want to use TeraTerm to access the consolelogger and Agilent, you must"
puts "set the Setup menu --> Terminal --> Transmit to CR+LF. The Agilent requires a"
puts "line-feed (not new-line) as the command termination character. Linux & Windows"
puts "telnet programs both seem to send the required line-feed by default.\n"
puts "NB: Linux telnet backspace works OK for command editing, but not for TeraTerm"
puts "or Windows telnet.\n"
puts "In the commands below, ip:port are the ip address and port number of the"
puts "consolelogger process. The key commands for the Agilent power supply are:"
puts "1) To check if the unit is alive, type: $self <ip:port> \\*idn\\?"
puts "2) To turn the output on, type: $::self <ip:port> outp on" 
puts "3) To turn the output off, type: $::self <ip:port> outp off"
puts "4) To set the output voltage to 3.3, type: $::self <ip:port> volt 3.3"
puts "5) To check the desired voltage, type: $::self <ip:port> volt\\?"
puts "6) To check the actual voltage, type: $::self <ip:port> meas:volt\\?"
puts "7) To check the actual current, type: $::self <ip:port> meas:curr\\?\n"
puts "NB: Setting the voltage doesnt mean the output is on. You have to explicitly"
puts "turn the output on!\n"
exit
