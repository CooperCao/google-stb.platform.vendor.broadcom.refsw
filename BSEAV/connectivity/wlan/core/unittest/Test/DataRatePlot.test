#!/bin/env utf
# -*-tcl-*-

#
# UTF test script to set data rate
# $Id: b2df4579099dfcb9a8c617917744019cf54ee98a $
#

package require UTF

package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart
package require UTF::MpduStats

package provide UTF::Test::DataRatePlot 2.0

UTF::Test DataRatePlot {AP STA args}  {

    # Pull out dut option since we need it before we can fetch the
    # rest of the arguments.
    if {[set dix [lsearch -exact $args -dut]] >= 0} {
	set vix [expr {$dix + 1}]
	set (dut) [lindex $args $vix]
    } else {
	set (dut) $STA
    }

    # If FBDefault is set, and devices support it, enable fb
    if {[info exists ::UTF::FBDefault] &&
	![$STA cget -noframeburst] && ![$AP cget -noframeburst]} {
	set fbdefault 1
    } else {
	set fbdefault 0
    }

    # User can specify per device defaults in config.  This is useful
    # in cases where the auto detected rates are known to not all
    # work.  Special case - if either DUT specifies just "false", then
    # disable the test.
    if {[string is false -strict [$(dut) cget -datarate]]} {
	UTF::Message INFO $(dut) "DataRate test skipped"
	return
    }
    set args [concat [$(dut) cget -datarate] $args]

    UTF::Getopts [subst {
	{dut.arg "$(dut)" "dut"}
	{skiprx.arg "" "Skip listed AP->STA rates.  Expanded by UTF::Rateexpand."}
	{skiptx.arg "" "Skip listed STA->AP rates.  Expanded by UTF::Rateexpand."}
	{i.arg 1 "Interval"}
	{s.arg 2 "Samples"}
	{chanspec.arg "3" "Chanspec"}
	{security.arg "open" "Security"}
	{key.arg "" "Key"}
	{loop.arg "" "deprecated"}
	{perfloop.parg 1 "Performance loop"}
	{msg.arg "" "Message"}
	{perfcache.parg "" "Performance Cache"}
	{history.parg 30 "Performance History"}
	{nocache "Don't update performance cache"}
	{b.arg "[$(dut) cget -udp]" "UDP data rate. (0 for TCP)"}
	{frameburst.arg "$fbdefault" "Use frameburst"}
	{symmetric.arg 0 "Symmetric - only test one way"}
	{ibss "Use IBSS instead of STA mode"}
	{auto "Only plot rates used in auto rate selection"}
	{sgi "Include SGI rates"}
    }]

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    if {$(loop) ne  ""} {
	set (perfloop) $(loop)
    }

    if {$(msg) eq ""} {
	set (msg) $(dut)
    }
    set branch [$(dut) branchname]
    set key [concat $branch rates "ch=$(chanspec)" $(key)]
    set plotkey [concat $key $AP $STA]
    # Sanitize key for use as a filename
    # / cannot be used in a filename is it is a directory seperator <>
    # are legal in filenames (but very confusing), but they will mess
    # up any URL's that point to them.
    regsub -all {[/<>]} $plotkey "." plotkey

    if {$(b) ne "0"} {
	set proto "UDP"
	lappend key "udp"
	lappend plotkey "udp"
    } else {
	set proto "TCP"
    }
    if {$(ibss)} {
	lappend key "ibss"
	lappend plotkey "ibss"
    }
    set oldkey $key
    if {$(frameburst)} {
	lappend key "fb"
	lappend plotkey "fb"
    }

    # nativename is needed to avoid confusing gnuplot with ~ and
    # other special path components.
    set f [file nativename \
	       [file join [file dir $UTF::Logfile] $plotkey]]

    # Make unique files in case we're looping in the same test run.
    for {set file $f; set i 1} {[file exists "${file}_tx.png"]} {incr i} {
	set file "${f}_$i"
    }

    set rxfile "${file}_rx.gpf"
    set rxctrlfile "${file}_rx.gpc"
    set rxplotfile_sm "${file}_rx_sm.png"
    set rxplotfile "${file}_rx.png"

    set txfile "${file}_tx.gpf"
    set txctrlfile "${file}_tx.gpc"
    set txplotfile_sm "${file}_tx_sm.png"
    set txplotfile "${file}_tx.png"

    # Expand skip args into skip lists.
    set skiprx [UTF::Rateexp $(skiprx)]
    set skiptx [UTF::Rateexp $(skiptx)]

    UTF::Try "$(msg): CH=$(chanspec): Upstream $proto" {
	set setup 0
	# Area tracking variables.
	# For each attn step we compute the area of the Right-angled
	# trapezium formed between the previous and current
	# datapoints.  This gives us a much less biased estimate than
	# simply using the current datapoint.
	array set sum {mean 0 min 0 max 0}; # Total area
	array set c {mean 0 min 0 max 0}; # Current Downstream
	array set p {mean 0 min 0 max 0}; # Previous Downstream

	if {$(ibss)} {
	    package require UTF::Test::APChanspec
	    package require UTF::Test::Join
	    APChanspec $AP $(chanspec) -loose -nobandlock
	    APChanspec $STA $(chanspec) -loose -nobandlock
	    Join $AP $STA -imode ibss -security $(security)
	} else {
	    ConnectAPSTA $AP $STA -security $(security) -chanspec $(chanspec)
	}

	if {$(frameburst)} {
	    $STA wl frameburst 1
	    $AP wl frameburst 1
	} else {
	    $STA wl -u frameburst 0
	    $AP wl -u frameburst 0
	}
	set band [$AP band]

	$AP txrate $band auto
	$STA txrate $band auto

	set APIP [$AP ipaddr]

	# Check vht_features before obtaining ratesets
	$STA wl -u vht_features
	$AP wl -u vht_features

	# Ask the STA for the rateset, since that will be the common set
	# negotiated between AP and STA for this BSS.
	set RATESET [$STA wl rateset]

	if {$(auto)} {
	    set rates [$STA allrates -auto $RATESET]
	    lappend rates auto
	} else {
	    set rates [$STA allrates $RATESET]
	}
	# Exclude rates not supported by the Router.  This is because
	# An RSDB router may deliberately advertise rates it cannot
	# support, eg in order to change to MIMO later.
	set rates [UTF::Common $rates [$AP allrates]]

	if {$(sgi)} {
	    set st ""
	    foreach r $rates {
		lappend st $r
		if {$r ne "auto" && ![regexp {\(.*\)} $r]} {
		    lappend st ${r}s
		}
	    }
	    set rates $st
	    unset st
	}

	# Don't change STF when changing rates
	set w "-w"
	set bigwindow [$STA tcpautowindow $RATESET]

	set rxfilefd [open $rxfile w]
	set txfilefd [open $txfile w]

	set setup 1

	set xlist ""
	set i -1

	set check_bssid 0

	set collector [UTF::MpduStats init $STA $AP ${file}_tx]

	if {$skiptx ne ""} {
	    UTF::Message INFO $STA "skip list: $skiptx"
	}

	foreach r $rates {
	    if {$skiptx eq "all" || [lsearch $skiptx $r] >= 0} {
		UTF::Message INFO $STA "skipped $r"
		continue
	    }

	    UTF::Try "$(msg): CH=$(chanspec): Upstream rate $r" {

		incr i
		lappend xlist $r

		if {$check_bssid} {
		    if {[$STA wl bssid] eq "00:00:00:00:00:00"} {
			puts $txfilefd ""
			error "Roaming"
		    }
		    set check_bssid 0
		}

		$STA txrate $band $r
		set b $(b)
		if {[regexp {\((.*)\)} $r - m]} {
		    # Use small TCP window size for legacy to improve
		    # convergence on low throughput.
		    set window 0
		    if {$(b) ne "0"} {
			# Use smaller UDP offer rate.
			set b "${m}M"
		    }
		} else {
		    set window $bigwindow
		}

		# Clear stats
		$collector clear

		array unset CC
		try {
		    controlchart [list $STA $AP] -stats CC \
			-failcriteria "ZERO" -perfcache $(perfcache) \
			-history $(history) \
			-oldkey [concat $oldkey up $r] \
			-key [concat $key up $r] -i $(i) -s $(s) \
			-window $window \
			-nopretest -pingmax 0 -loop $(perfloop) -N 0 -b $b
		} finally {

		    $collector collect $r

		    if {[info exists CC(mmm)]} {
			puts $txfilefd "$i $CC(mmm) $CC(Ux) $CC(Lx)"
			if {[lindex $CC(mmm) 0] == 0} {
			    set check_bssid 1
			}
			set c(mean) [lindex $CC(mmm) 0]
			set c(min) [lindex $CC(mmm) 1]
			set c(max) [lindex $CC(mmm) 2]
			set sum(mean) [expr {$sum(mean) + ($c(mean)+$p(mean))}]
			set sum(min) [expr {$sum(min) + ($c(min)+$p(min))}]
			set sum(max) [expr {$sum(max) + ($c(max)+$p(max))}]
			set p(mean) $c(mean)
			set p(min) $c(min)
			set p(max) $c(max)
		    }
		    if {$r eq "auto"} {
			$STA wl nrate
		    }
		}
	    }
	}

	$STA txrate $band auto
	close $txfilefd

	if {[file size $txfile] <= 0} {
	    # Nothing to do
	    return
	}

	set xtics ""
	set i 0
	set interval [expr {[llength $xlist] / 20}]
	foreach r $xlist {
	    if {$interval == 0 || $i % $interval == 0} {
		lappend xtics "'$r' $i"
	    }
	    incr i
	}
	lappend xtics "'$r' [expr {$i-1}]"

	# Plot
	set G [open $txctrlfile w]
	if {[UTF::GnuplotVersion] >= 5.0} {
	    puts $G {set colors classic}
	}
	if {[UTF::GnuplotVersion] > 4.0} {
	    puts $G {set terminal png transparent size 62,13}
	    puts $G {set tmargin 0.1; set bmargin 0}
	    puts $G {set lmargin 0; set rmargin 0.1}
	} else {
	    puts $G {set terminal png transparent; set size 0.15,0.08}
	    # Gnuplot 4.0 loops if margins are zero - use mogrify below
	}
	puts $G {unset y2tics}
	puts $G {unset ytics}
	puts $G {unset xtics}
	puts $G {unset key}
	puts $G {unset border}
	puts $G "set output \"$txplotfile_sm\""
	puts $G "plot \"$txfile\" using 1:5 notitle with lines lt 2, \
		 \"\" using 1:6 notitle with lines lt 2, \
		 \"\" using 1:2 notitle with lines lt 1"

	puts $G {reset}
	puts $G {set terminal png notransparent size 1280,1280 truecolor}
	puts $G "set output '$txplotfile'"
	puts $G "set multiplot title '$(msg) Upstream rates ($(chanspec))'"
	if {[UTF::GnuplotVersion] > 4.2} {
	    puts $G "set xtics rotate by -20"
	} else {
	    puts $G "set xtics rotate"
	}
	puts $G "set origin 0,0.59; set size 1.0,0.4"
	puts $G "set title '$proto (Mb/s)'"
	puts $G "set xtics ([join $xtics ,])"
	puts $G {unset x2tics}
	puts $G {unset ytics}
	puts $G {set y2tics}
	puts $G "plot \"$txfile\" using 1:5 axes x1y2 notitle with lines lt 2, \
		 \"\" using 1:6 axes x1y2 notitle with lines lt 2, \
		 \"\" using 1:2:3:4 axes x1y2 notitle with errorlines lt 1"
	puts $G [$collector plotscripts]
	puts $G {unset multiplot}
	puts $G {quit}
	close $G

	$collector destroy

	# Run gnuplot on plot file.  Catch is needed because gnuplot
	# often writes to stderr.  Report any output even if we think
	# it was ok.
	catch {exec $::UTF::Gnuplot $txctrlfile} ret
	UTF::Message WARN "gnuplot" $ret

	# Controlchart Area under the curve
	UTF::ControlChart CC -s $(s) \
	    -key [concat $plotkey area up] \
	    -perfcache $(perfcache) -history $(history) \
	    -title "$(msg) Rate area" -format %.0f \
	    -ylabel "Area" -units "Mb" -norangecheck 1
	set area [CC plotcontrolchart \
		      [CC addsample [list $sum(mean) $sum(min) $sum(max)]]]
	regsub {^html:} $area { } area

	set ret "html:<a href=\"[UTF::URI $txplotfile]\">[UTF::ThumbData $txplotfile_sm]</a>$area"
	if {[set END [lindex $UTF::TryStack end]] ne "NONE"} {
	    regsub {^html:} $END { } END
	    set ret "$ret $END"
	}

	if {[lindex $UTF::TryStack end] ne "NONE"} {
	    # Replace a cascading fail with our plot
	    throw FAIL $ret
	} else {
	    return $ret
	}
    }

    if {!$setup || [$AP hostis Airport] || $(symmetric)} {
	return
    }

    # Second pass, adjust AP rates
    UTF::Try "$(msg): CH=$(chanspec): Downstream $proto" {

	# Area tracking variables.
	# For each attn step we compute the area of the Right-angled
	# trapezium formed between the previous and current
	# datapoints.  This gives us a much less biased estimate than
	# simply using the current datapoint.
	array set sum {mean 0 min 0 max 0}; # Total area
	array set c {mean 0 min 0 max 0}; # Current Downstream
	array set p {mean 0 min 0 max 0}; # Previous Downstream

	$AP txrate $band auto
	$STA txrate $band auto

	if {[UTF::CanonicalChanspec [$STA wl chanspec]] ne
	    [UTF::CanonicalChanspec $(chanspec)] ||
	    [catch {$STA ping $AP -c 1}]} {
	    ConnectAPSTA $AP $STA -security open -chanspec $(chanspec)
	}
	if {$(frameburst)} {
	    $STA wl frameburst 1
	    $AP wl frameburst 1
	} else {
	    $STA wl -u frameburst 0
	    $AP wl -u frameburst 0
	}

	set xlist {}
	set i -1
	set check_bssid 0

	set collector [UTF::MpduStats init $AP $STA ${file}_rx]

	if {$skiprx ne ""} {
	    UTF::Message INFO $STA "skip list: $skiprx"
	}

	foreach r $rates {
	    if {$skiprx eq "all" || [lsearch $skiprx $r] >= 0} {
		UTF::Message INFO $STA "skipped $r"
		continue
	    }

	    UTF::Try "$(msg): CH=$(chanspec): Downstream rate $r" {

		incr i
		lappend xlist $r

		if {$check_bssid} {
		    if {[$STA wl bssid] eq "00:00:00:00:00:00"} {
			puts $rxfilefd ""
			error "Roaming"
		    }
		    set check_bssid 0
		}

		$AP txrate $band $r

		set b $(b)
		if {[regexp {\((.*)\)} $r - m]} {
		    # Use small TCP window size for legacy to improve
		    # convergence on low throughput
		    set window 0
		    if {$(b) ne "0"} {
			# Use smaller UDP offer rate.
			set b "${m}M"
		    }
		} else {
		    set window $bigwindow
		}

		$collector clear

		array unset CC
		try {
		    controlchart [list $AP $STA] -stats CC \
			-failcriteria "ZERO" -perfcache $(perfcache) \
			-history $(history) \
			-oldkey [concat $oldkey down $r] \
			-key [concat $key down $r] \
			-i $(i) -s $(s) -window $window -nopretest \
			-pingmax 0 -loop $(perfloop) -N 0 -b $b
		} finally {

		    $collector collect $r

		    if {[info exists CC(mmm)]} {
			puts $rxfilefd "$i $CC(mmm) $CC(Ux) $CC(Lx)"
			if {[lindex $CC(mmm) 0] == 0} {
			    set check_bssid 1
			}
			set c(mean) [lindex $CC(mmm) 0]
			set c(min) [lindex $CC(mmm) 1]
			set c(max) [lindex $CC(mmm) 2]
			set sum(mean) [expr {$sum(mean) + ($c(mean)+$p(mean))}]
			set sum(min) [expr {$sum(min) + ($c(min)+$p(min))}]
			set sum(max) [expr {$sum(max) + ($c(max)+$p(max))}]
			set p(mean) $c(mean)
			set p(min) $c(min)
			set p(max) $c(max)
		    }
		    if {$r eq "auto"} {
			$AP wl nrate
		    }
		}
	    }
	}
	$AP txrate $band auto
	close $rxfilefd

	if {[file size $rxfile] <= 0} {
	    # Nothing to do
	    return
	}

	set xtics ""
	set i 0
	set interval [expr {[llength $xlist] / 20}]
	foreach r $xlist {
	    if {$interval == 0 || $i % $interval == 0} {
		lappend xtics "'$r' $i"
	    }
	    incr i
	}
	lappend xtics "'$r' [expr {$i-1}]"

	# Plot
	set G [open $rxctrlfile w]
	if {[UTF::GnuplotVersion] >= 5.0} {
	    puts $G {set colors classic}
	}
	if {[UTF::GnuplotVersion] > 4.0} {
	    puts $G {set terminal png transparent size 62,13}
	    puts $G {set tmargin 0; set bmargin 0}
	    puts $G {set lmargin 0; set rmargin 0.1}
	} else {
	    puts $G {set terminal png transparent; set size 0.15,0.08}
	    # Gnuplot 4.0 loops if margins are zero - use mogrify below
	}
	puts $G {unset y2tics}
	puts $G {unset ytics}
	puts $G {unset xtics}
	puts $G {unset key}
	puts $G {unset border}
	puts $G "set output \"$rxplotfile_sm\""
	puts $G "plot \"$rxfile\" using 1:5 notitle with lines lt 2, \
		 \"\" using 1:6 notitle with lines lt 2, \
		 \"\" using 1:2 notitle with lines lt 1"

	puts $G {reset}
	puts $G {set terminal png notransparent size 1280,1280 truecolor}
	puts $G "set output '$rxplotfile'"
	puts $G "set multiplot title '$(msg) Downstream rates ($(chanspec))'"
	if {[UTF::GnuplotVersion] > 4.2} {
	    puts $G "set xtics rotate by -20"
	} else {
	    puts $G "set xtics rotate"
	}
	puts $G "set origin 0,0.59; set size 1.0,0.4"
	puts $G "set title '$proto (Mb/s)'"
	puts $G "set xtics ([join $xtics ,])"
	puts $G {unset x2tics}
	puts $G {unset ytics}
	puts $G {set y2tics}
	puts $G "plot \"$rxfile\" using 1:5 axes x1y2 notitle with lines lt 2, \
		 \"\" using 1:6 axes x1y2 notitle with lines lt 2, \
		 \"\" using 1:2:3:4 axes x1y2 notitle with errorlines lt 1"
	puts $G [$collector plotscripts]
	puts $G {unset multiplot}
	puts $G {quit}
	close $G

	$collector destroy
	# Run gnuplot on plot file.  Catch is needed because gnuplot
	# often writes to stderr.  Report any output even if we think
	# it was ok.
	catch {exec $::UTF::Gnuplot $rxctrlfile} ret
	UTF::Message WARN "gnuplot" $ret

	# Controlchart Area under the curve
	UTF::ControlChart CC -s $(s) \
	    -key [concat $plotkey area down] \
	    -perfcache $(perfcache) -history $(history) \
	    -title "$(msg) Rate area" -format %.0f \
	    -ylabel "Area" -units "Mb" -norangecheck 1
	set area [CC plotcontrolchart \
		      [CC addsample [list $sum(mean) $sum(min) $sum(max)]]]
	regsub {^html:} $area { } area

	set ret "html:<a href=\"[UTF::URI $rxplotfile]\">[UTF::ThumbData $rxplotfile_sm]</a>$area"
	if {[set END [lindex $UTF::TryStack end]] ne "NONE"} {
	    regsub {^html:} $END { } END
	    set ret "$ret $END"
	}

	if {[lindex $UTF::TryStack end] ne "NONE"} {
	    # Replace a cascading fail with our plot
	    throw FAIL $ret
	} else {
	    return $ret
	}
    }
}
