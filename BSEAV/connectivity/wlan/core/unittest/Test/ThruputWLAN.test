#!/bin/env utf
# -*-tcl-*-

# To get online help, type: Test/ThruputWLAN.test -h

# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::ThruputWLAN_help "\n\nBasic usage: Test/ThruputWLAN.test <options>\
    \n\nThis script does a thruput test on multiple WLAN devices concurrently.\
    \nYou can have several AP with active traffic to/from many STA in arbitrary\
    \nconnections, as specified by options -conn0 ... -conn4 below. The -connN\
    \noptions can also be used to test only the specified devices and exclude\
    \nthe other devices in the testbed. You can also define the default connection\
    \nlists in your utfconf file using the variables UTF::conn0, UTF::conn1, ...\
    \n\nvalid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set ::ThruputWLAN_getopts {
    {branch.arg "auto"             "Branch override"}
    {conn0.arg ""                  "AP-STA connection list 0, format: \"AP1 STA1 ... STAn\""}
    {conn1.arg ""                  "AP-STA connection list 1, format: \"AP2 STAn+1 ... STAm\""}
    {conn2.arg ""                  "AP-STA connection list 2, format: \"AP3 STAm+1 ... STAo\""}
    {conn3.arg ""                  "AP-STA connection list 3, format: \"AP4 STAo+1 ... STAp\""}
    {conn4.arg ""                  "AP-STA connection list 4, format: \"AP5 STAp+1 ... STAq\""}
    {connect                       "Make the AP - STA connections per -connN lists above"}
    {email.arg ""                  "Email address list, format: userid1,userid2,... default is your userid"}
    {key.arg ""                    "Additional keys to keep perfcache data separated by test, STA, etc"}
    {history.arg 30                "Performance history samples to keep in perfcache data"}
    {notune                        "Use TCP as is, dont run TCP tune routine"}
    {perfint.arg 2                 "Test interval in seconds for each iperf test sample"}
    {perfloop.arg 1                "Total performance test iterations"}
    {perfsize.arg 5                "Number of samples stored in each entry of controlchart & perfcache file"}
    {perftime.arg 10               "Total time duration, in seconds, for each performance tests"}
    {reloadsta                     "Reload the STA"}
    {reloadap                      "Reload the AP"}
    {softap                        "AP is really a STA running SoftAP code"}
    {title.arg ""                  "Title text for web page report & email"}
    {title_png.arg ""              "Title text for timeplot .png graph"}
    {title_try.arg "WLAN test"     "Title text for web report UTF::Try line item"}
    {window.arg 512k               "Tcp Window for iperf tests"}
    {wlan_dir.arg "bidirectional"  "WLAN test direction: bidirectional dut2tg tg2dut"}
}

# Setup online help info.
UTF::setup_help $::ThruputWLAN_help $::ThruputWLAN_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any 
# additional code in this script.

# Load packages
package require UTF
package require UTF::ControlChart
package require UTF::utils

namespace eval ThruputWLAN {}
package provide UTF::Test::ThruputWLAN 2.0

#======================= Start Common Procs  ==================================

#======================= control_chart ========================================
# Feeds thruput samples to control chart in set sizes that the control
# chart can handle (2 - 25).
# Calling args: 
# The first four args are text strings used to help create unique keys
# for the perfcache data.
# sample_list is a space separated list of decimal thruput values.
# Returns: html string with control chart png file & thumbnail data
#==============================================================================
proc ThruputWLAN::control_chart  {direction sta1 sta2 sample_list} {

    # Create ControlChart object regardless of samples being
    # available or not. We may need to generate control chart
    # graphics from previous iteration data.
    set sample_cnt [llength $sample_list]
    set cc_keys "$::ThruputWLAN::key $direction $sta1 $sta2"
    set cc_keys [string trim $cc_keys]
    set logname "${sta1}-${sta2}"
    UTF::Message LOG "$logname" "ThruputWLAN::control_chart\
        history=$::ThruputWLAN::history cc_keys=$cc_keys\
        sample_size=$::ThruputWLAN::perf_size sample_cnt=$sample_cnt\
        sample_list=$sample_list"
    UTF::ControlChart CC -s $::ThruputWLAN::perf_size -key $cc_keys\
        -history $::ThruputWLAN::history

    # Do we have enough samples to process?
    set cc_errors "" ;# list of error from control chart
    set cc_others "" ;# list of other results from control chart
    set cc_result "" ;# result string from control chart
    set sample_cnt [llength $sample_list]
    set min_samples [expr int(0.8 * $::ThruputWLAN::perf_size)]
    # puts "sample_cnt=$sample_cnt min_samples=$min_samples"
    if {$sample_cnt < $min_samples} {
        set msg "CC too few samples!"
        lappend ::ThruputWLAN::current_error_list "$msg"
        lappend ::ThruputWLAN::running_error_list "$msg"
        UTF::Message ERROR "$logname" "ThruputWLAN::control_chart\
           $direction $sta1 $sta2 $msg"
        # NB: We dont return here. We may still need to generate the 
        # overall CC for previous iterations.

    } else {
        # Process the samples.
        if {$sample_cnt < $::ThruputWLAN::perf_size} {
            UTF::Message WARN "$logname" "ThruputWLAN::control_chart\
                $direction $sta1 $sta2 only $sample_cnt samples!"
        }

        # Process samples in groups of perf_size. This allows hundreds
        # of samples from a large run to be fed into the controlchart
        # within the limits of the controlchart sample size restrictions.
        set i 0
        while { 1 } {

            # Get next perf_size group of samples.
            set j [expr $i + $::ThruputWLAN::perf_size - 1]
            set cc_samples [lrange $sample_list $i $j]
            UTF::Message LOG "$logname" "ThruputWLAN::control_chart\
                i=$i j=$j cc_samples=$cc_samples"

            # Are there enough samples in this group to work with?
            set cnt [llength $cc_samples]
            if {$cnt < $min_samples} {
                UTF::Message WARN "$logname" "ThruputWLAN::control_chart\
                    $direction $sta1 $sta2 dropping samples: $cc_samples"
                break
            }

            # Use the common UTF routine for mean, min, max
            set cc_mmm [UTF::MeanMinMax $cc_samples]
            # set cc_mmm "0.1 0.1 0.1" ;# test data

            # Add data sample, check for errors & other messages from
            # the ControlChart.
            set cc_result [CC addsample $cc_mmm]
            # puts "cc_result=$cc_result"
            if {[regexp -nocase {(LOW|WIDE|ZERO)} $cc_result - code]} {
                append cc_errors " $code"
            }
            if {[regexp -nocase {(HIGH)} $cc_result - code]} {
                append cc_others " $code"
            }

            # Exit loop when we hit end of sample list.
            incr i $::ThruputWLAN::perf_size
            if {$i >= $sample_cnt} {
                break
            }
        }

        # Make list of codes unique. Selectively add errors to error lists.
        set cc_errors [lsort -unique $cc_errors]
        set cc_errors [string trim $cc_errors]
        set cc_others [lsort -unique $cc_others]
        set cc_others [string trim $cc_others]
        # puts "cc_errors=$cc_errors cc_others=$cc_others"
        if {$cc_errors != ""} {
            set msg "$cc_errors"
            UTF::Message ERROR "$logname" "ThruputWLAN::control_chart\
                $direction $sta1 $sta2 CC $msg"
            lappend ::ThruputWLAN::current_error_list "$msg"

            # The running error list is shown on the web summary page.
            # To avoid redundant error messages, if there are already 
            # other errors, there is no need to add these errors.
            # However if there are no other errors, we do need to a token
            # error msg so that the higher level routines will correctly
            # throw an error as the overall result.
            if {$::ThruputWLAN::running_error_list == ""} {
                set ::ThruputWLAN::running_error_list "$cc_errors"
            }
        }
    }

    # If not the last iteration, return
    if {$::ThruputWLAN::perf_cnt != $::ThruputWLAN::perf_loop} {
        CC destroy
        return
    }

    # Update the last result with any error/other codes that occured.
    # puts "cc_result=$cc_result"
    if {$cc_errors != ""} {
        regsub -nocase -all " OK| LOW| WIDE| ZERO" $cc_result "" cc_result
        append cc_result " $cc_errors"
    }
    if {$cc_others != ""} {
        regsub -nocase -all " OK| HIGH" $cc_result "" cc_result
        append cc_result " $cc_others"
    }
    set cc_result [string trim $cc_result]
    if {$cc_result == ""} {
        set cc_result "---"
    }
    # puts "cc_result=$cc_result"

    # Get the control chart graphics
    set chart [CC plotcontrolchart $cc_result]
    CC destroy

    # Add formating to identify the control chart. When there
    # is more than one control chart on a single line on the web
    # summary page, you need some additional identifiers to tell 
    # whats what. 
    regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
    set arrow "<->"
    if {$direction == "dut2tg"} {
       set arrow "<--"
    } elseif {$direction == "tg2dut"} {
       set arrow "-->"
    }
    if {$sta2 == ""} {
        set arrow "" ;# allows for aggregate AP level control chart
    }
    set chart " ${chart}&nbsp;${sta1}${arrow}${sta2}<br>"
    return "$chart"
}

#======================= error_recovery_procedure =============================
# When request, usually after a fatal error, reload both bluetooth devices and
# make a new BT connection. This ensures the next test or iteration will have
# a relatively clean starting point. Keep track of how often this happens.
# Calling args: none
# Returns: nothing, does NOT throw errors.
#==============================================================================
proc ThruputWLAN::error_recovery_procedure {} {

    # If necessary, initialize counter for error recovery procedures
    if {![info exists ::ThruputWLAN::erp_cnt]} {
        set ::ThruputWLAN::erp_cnt 0
    }
    incr ::ThruputWLAN::erp_cnt
    UTF::Message LOG "$::localhost" "ThruputWLAN::error_recovery_procedure\
       START erp_cnt=$::ThruputWLAN::erp_cnt"



 
    # Time will tell if we need to restart the WLAN devices.
    UTF::Message LOG "$::localhost" "ThruputWLAN::error_recovery_procedure\
       END erp_cnt=$::ThruputWLAN::erp_cnt\
       ================================================================="
    return
}

#======================= get_lan_tg ===========================================
# Figures out name of LAN traffic generator from connection list, with support
# for SoftAP.
#
# Returns lan_tg
#==============================================================================
proc ThruputWLAN::get_lan_tg {conn_list} {

    # If AP not available, return
    set AP [lindex $conn_list 0]
    if {$AP == ""} {
        return
    }

    # Get LAN traffic generator name
    if {[eval UTF::check_host_type $AP $::ap_type_list]} {
        # Real AP
        set ap_host [$AP cget -host] ;# finds parent object
        set lan_tg [$ap_host cget -lanpeer]
        set lan_tg [lindex $lan_tg 0];# in case there is more than one 
    } else {
        # SoftAP doesnt have lanpeer.
        # But we want to test against SoftAP, so lan_tg=SoftAP
        set lan_tg $AP
    }
    UTF::Message LOG "$::localhost" "ThruputWLAN::get_lan_tg conn_list=$conn_list AP=$AP lan_tg=$lan_tg"
    return $lan_tg
}

#======================= get_remote_clock_delta ===============================
# Routine use to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# host: host object to get clock delta for
# tries: optional number of iterations for computing clock delta
# Returns: clock delta, in seconds
# A positive delta means the remote host clock is faster than the local clock
# A negative delta means the remote host clock is slower than the local clock
#==============================================================================
proc ThruputWLAN::get_remote_clock_delta {host {tries 10} {debug 0}} {

    # If we have cached value that has not been used too often,
    # then use the cached value.
    set logname $host
    if {[info exists ::clock_delta($logname,uses)]} {
        if {$::clock_delta($logname,uses) < 10} {
            incr ::clock_delta($logname,uses)
            set result $::clock_delta($logname,value)
            UTF::Message LOG "$logname" "ThruputWLAN::get_remote_clock_delta use\
                #$::clock_delta($logname,uses) of cached result=$result"
            return $result
        }
    }

    # Get N clock time samples from the remote host. Need 3 samples
    # minimum so that later we can delete high/low values and still
    # have something left to use.
    if {$tries == "" || $tries < 3} {
        set tries 10
    }
    set clock_delta_list ""
    for {set i 0} {$i < $tries} {incr i} {

        # Get remote date/time stamp and timing info for how
        # long that took. 
        set start_sec [clock seconds]
        set catch_resp [catch "set remote_date \[$host rexec -quiet\
            -silent date\]" catch_msg]
        set stop_sec [clock seconds]
        if {$catch_resp != 0} {
            UTF::Message ERROR "$logname" "get_remote_clock_delta $catch_msg"
            return 0
        }

        # Compute clock delta
        set round_trip_sec [expr $stop_sec - $start_sec] ;# total transaction time
        regexp {\s([\d:]{8})\s} $remote_date remote_time ;# extract remote hh:mm:ss
        set remote_sec [clock scan $remote_time] ;# convert to unix seconds
        set start_time [clock format $start_sec]
        set clock_delta [expr $remote_sec - $start_sec - ($round_trip_sec/2)]
        if {$debug == 1} {
            UTF::Message LOG "$::localhost" "ThruputWLAN::get_remote_clock_delta\
                 start_time=$start_time start_sec=$start_sec stop_sec=$stop_sec\
                 round_trip_sec=$round_trip_sec"
            UTF::Message LOG "$logname" "ThruputWLAN::get_remote_clock_delta\
                 remote_date=$remote_date remote_time=$remote_time\
                 remote_sec=$remote_sec clock_delta=$clock_delta"
        }
        lappend clock_delta_list $clock_delta
    }
    # puts "clock_delta_list=$clock_delta_list"

    # Locate the lowest clock deltas and delete it.
    # NB: If you try to locate highest & lowest in same loop,
    # you may get indexing error when you delete items that
    # arent there as the list has shifted positions.
    set i 0
    set min_delta ""
    set min_i ""
    foreach delta $clock_delta_list {
        if {$min_delta == ""} {
            set min_delta $delta
            set min_i $i
        } elseif {$delta < $min_delta} {
            set min_delta $delta
            set min_i $i
        }
        # puts "i=$i delta=$delta min_delta=$min_delta min_i=$min_i" 
        incr i 
    }
    set clock_delta_list [lreplace $clock_delta_list $min_i $min_i]
    # puts "clock_delta_list=$clock_delta_list"
 
    # Locate the highest clock delta and delete it.
    set i 0
    set max_delta ""
    set max_i ""
    foreach delta $clock_delta_list {
        if {$max_delta == ""} {
            set max_delta $delta
            set max_i $i
        } elseif {$delta >= $max_delta} {
            set max_delta $delta
            set max_i $i
        }
        # puts "i=$i delta=$delta max_delta=$max_delta max_i=$max_i"
        incr i
    }
    set clock_delta_list [lreplace $clock_delta_list $max_i $max_i]
    # puts "clock_delta_list=$clock_delta_list"

    # Average the remaining clock deltas
    set cnt 0
    set total 0
    foreach delta $clock_delta_list {
        set total [expr $total + $delta]
        incr cnt        
    } 
    if {$cnt != 0} {
        # puts "total=$total cnt=$cnt"
        set result [expr int($total / $cnt)]
    } else {
        set result 0
    }
    
    # Log results, update cache & return result.
    UTF::Message LOG "$logname" "ThruputWLAN::get_remote_clock_delta\
        high=$max_delta low=$min_delta clock_delta_list=$clock_delta_list\
        result=$result"
    set ::clock_delta($logname,value) $result
    set ::clock_delta($logname,uses) 0
    return $result
}

#======================= get_WLAN_results =====================================
# Extracts thruput test results from collect_rpopen_data.
# Calling parms:
# host1: name of first host to look for in data stream
# host2: name of second host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
#
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)
#==============================================================================
proc ThruputWLAN::get_WLAN_results {host1 host2 data_list samples} {

    # Get time correction delta for the target host
    set time_delta_sec [ThruputWLAN::get_remote_clock_delta $host1]
    set logname "${host1}-${host2}"

    # Variables to track socket delays
    set ::ThruputWLAN::max_socket_delay 0
    set ::ThruputWLAN::max_socket_timestamp ""

    # Match the host names at start of the data_list item.
    set sample_list ""
    set host1 [string trim $host1]
    set host2 [string trim $host2]
    # UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results search host1=$host1 host2=$host2 samples=$samples ======================================================================"
    foreach subitem $data_list {
        # UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results subitem=$subitem"
        # Skip data not matching host1-host2. The data often has tabs, which we convert to spaces.
        regsub -all {\011} $subitem " " subitem

        # There are some fatal errors that need to be flagged.
        # When a fatal error is found, we request the error recovery 
        # procedures in order to continue testing. We save only the
        # first fatal error that we find, so as not to clutter up the
        # web summary page with repeated copies of a similar message.
        # But we log all fatal errors.
        if {[regexp -nocase {(connection.*lost)} $subitem] &&\
            ![regexp -nocase {fsh} $subitem]} {
            set ::ThruputWLAN::need_erp yes
            set msg "connection lost (set $::ThruputWLAN::perf_cnt of $::ThruputWLAN::perf_loop)"
            UTF::Message ERROR "$logname" "ThruputWLAN::get_WLAN_results fatal error:\
               $msg $subitem"
            if {![info exists ::ThruputWLAN::fatal_error] ||\
                $::ThruputWLAN::fatal_error == ""} {
                set ::ThruputWLAN::fatal_error "$msg"
            }
            continue
        }

        # Match on host1-host2.
        if {![regexp -nocase " $host1-$host2 " $subitem]} {
            continue
        }
        # UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results matched host $host1-$host2: $subitem"

        # Get local & remote timestamps & current thruput data from results.
        # The regexp filters out the negative values.
        # NB: 0 or 0.0 is a legitimate value!
        if {[regexp -nocase {^([\d:]{8})\s.*\s([\d:]{8})\s.*\sBytes\s+([\.\d]+) bits/sec$}\
            $subitem - time1 time2 tput]} {
            set corrected_timestamp [ThruputWLAN::timestamp_correction WLAN $time1\
                $time2 $time_delta_sec]
            # NB: iperf reports thruput in bits/s!
            set tput [expr double($tput) / 1000000] ;# UTF likes numbers in Mb/s
            set tput [format "%6.6f" $tput]
            lappend sample_list $corrected_timestamp $tput
            # UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results found\
                sample: time1=$time1 time2=$time2\
                corrected=$corrected_timestamp tput=$tput subitem: $subitem"
            continue
        }

        # Currently there are no stats or other events related to iperf to look for.
    }

    # Log UTF delays
    UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results\
        max_socket_delay=$::ThruputWLAN::max_socket_delay seconds occured at:\
        $::ThruputWLAN::max_socket_timestamp"

    # Always discard the last iperf sample (time tput), as it is the overall average.
    # We do this before the duplicate check, so we know we are discarding just the
    # last sample.
    set sample_list [lrange $sample_list 0 end-2]

    # Discard duplicate time samples. Usually doesnt occur with iperf, but
    # there is no harm checking anyway.
    # Burst of zero's does not happen any more, but we could get 0 throughput
    # which is valid and we should not remove them as duplicates
    # set sample_list [ThruputWLAN::remove_duplicate_samples $host WLAN $sample_list]

    # If necessary, drop some of the earlier samples.
    set sample_cnt [llength $sample_list]
    set sample_cnt [expr $sample_cnt / 2] ;# sample == time tput
    if {$samples > 0} {
        if {$sample_cnt < $samples} {
            UTF::Message WARN "$logname" "ThruputWLAN::get_WLAN_results Only\
                found $sample_cnt samples!"
        } else {
            set i [expr ($sample_cnt - $samples) * 2]
            set sample_list [lrange $sample_list $i end]
            set sample_cnt $samples
        }
    }

    # Log the results
    UTF::Message LOG "$logname" "ThruputWLAN::get_WLAN_results\
        cnt=$sample_cnt samples=$sample_list"

    # Too few samples is a good indicator of serious problems. Request 
    # the error recovery procedures. We save only the first fatal error.
    # But we log all fatal errors.
    if {$sample_cnt < $::ThruputWLAN::sample_threshold} {
        set ::ThruputWLAN::need_erp yes
        set msg "$logname Only $sample_cnt samples, required\
            $::ThruputWLAN::sample_threshold (set $::ThruputWLAN::perf_cnt\
            of $::ThruputWLAN::perf_loop)"
        UTF::Message ERROR "$logname" "ThruputWLAN::get_WLAN_results fatal error: $msg"
        if {![info exists ::ThruputWLAN::fatal_error] ||\
            $::ThruputWLAN::fatal_error == ""} {
            set ::ThruputWLAN::fatal_error "$msg"
        }
    }

    # Return the results
    return $sample_list
}

#======================= merge_samples ========================================
# Merges two unidirectional series of thruput values to give a composite
# bidirectional data series for use in a control chart.
# Calling args: space separated series of decimal thruput values
# Returns:space separated series of decimal thruput values 
#==============================================================================
proc ThruputWLAN::merge_samples {host1 host2 series1 series2} {

     # Check series sizes. If different, drop earlier samples 
     # from the longer series.
     set logname "${host1}-${host2}"
     set cnt1 [llength $series1]
     set cnt2 [llength $series2]
     if {$cnt1 > $cnt2} {
         set i [expr $cnt1 - $cnt2]
         set series1 [lrange $series1 $i end]
         UTF::Message WARN "$logname" "ThruputWLAN::merge_samples\
             dropping $i samples during merge"
     } elseif {$cnt1 < $cnt2} {
         set i [expr $cnt2 - $cnt1]
         set series2 [lrange $series2 $i end]
         UTF::Message WARN "$logname" "ThruputWLAN::merge_samples\
             dropping $i samples during merge"
     }
     # UTF::Message LOG "$logname" "ThruputWLAN::merge_samples series1=$series1"
     # UTF::Message LOG "$logname" "ThruputWLAN::merge_samples series2=$series2"

     # Add the 2 series together value by value to get bidirectional
     # series of values.
     set cnt [llength $series1]
     set series3 ""
     for {set i 0} {$i < $cnt} {incr i} {
         set value [expr [lindex $series1 $i] + [lindex $series2 $i]]
         lappend series3 $value
     }

    # Log & return the results
    UTF::Message LOG "$logname" "ThruputWLAN::merge_samples $host1 $host2 bidirectional\
        cnt=$cnt series=$series3"
    return "$series3"
}

#======================= perf_hook ============================================
# Runs pre & post perf hook commands
#
# Returns nothing, logs errors.
#==============================================================================
proc ThruputWLAN::perf_hook {conn_list lan_tg type} {

    # Log data non-null data
    if {$conn_list == "" || $lan_tg == ""} {
        return
    }
    UTF::Message LOG "$::localhost" "\n\nThruputWLAN::perf_hook conn_list=$conn_list lan_tg=$lan_tg type=$type"

    # Run commands for each device
    foreach object "$conn_list $lan_tg" {
        # Get command list, based on type.
        set cmd_list [$object cget -${type}_perf_hook]
        if {$cmd_list == ""} {
            continue
        }
        regsub -all {\}\{} $cmd_list "\} \{" cmd_list ;# fix malformed lists, add space between elements
        # UTF::Message LOG "$object" "cmd_list=$cmd_list"

        foreach cmd $cmd_list {
            # Use standard mapping of %S to object name.
            # UTF::Message LOG "$object" "before cmd: $cmd"
            set cmd [string map [list %S $object] $cmd]
            # UTF::Message LOG "$object" "after cmd: $cmd"

            # Run cmd, log errors.
            set catch_resp [catch "$cmd" catch_msg]
            if {$catch_resp != 0} {
                UTF::Message ERROR $object "$cmd got: $catch_msg"
            }
        }
    }
    return
}

#======================= process_results ======================================
# Supervises the extraction of result data, creates one control chart for
# each connN string and one overall time plot graph.
# Calling arg: data list returned by collect_rpopen_data
#
# Returns: html formated string with links to graphs.
#==============================================================================
proc ThruputWLAN::process_results {data} {
    upvar {} {} ;# gives access to unamed array from getopts

    # Process each connN connection list.
    set ::ThruputWLAN::current_error_list ""
    set direction $::ThruputWLAN::wlan_dir
    set html_results ""
    set time_plot_data ""
    for {set i 0} {$i <= $::conn_max} {incr i} {
        set temp $(conn$i)
        set rtr [lindex $temp 0]
        set sta [lrange $temp 1 end]
        set lan_tg $(lan_tg$i)
        if {$rtr == "" || $sta == "" || $lan_tg == ""} {
            continue
        }
        UTF::Message INFO "$::localhost" "\n\nThruputWLAN::process_results i=$i rtr=$rtr lan_tg=$lan_tg sta=$sta direction=$direction"

        # Extract data, store in results array. For iperf TCP, only TX data is available.
        # Data format: time1 value 1 ... timeN valueN
        set agg_cc_data "" ;# aggregate for AP / lan_tg view
        foreach item $sta {
            set cc_data ""
            if {[string match "dut2*" $direction] || $direction == "bidirectional"} {
                set tx_data1 [ThruputWLAN::get_WLAN_results $item $lan_tg "$data" $::ThruputWLAN::expected_samples]
                if {$tx_data1 != ""} {
                    append ::ThruputWLAN::time_plot_array(${lan_tg}<--${item}) " $tx_data1"
                }
                set cc_data [ThruputWLAN::remove_timestamps $tx_data1]
            }
            if {[string match "*2dut" $direction] || $direction == "bidirectional"} {
                set tx_data2 [ThruputWLAN::get_WLAN_results $lan_tg $item "$data" $::ThruputWLAN::expected_samples]
                if {$tx_data2 != ""} {
                    append ::ThruputWLAN::time_plot_array(${lan_tg}-->${item}) " $tx_data2"
                }
                set cc_data [ThruputWLAN::remove_timestamps $tx_data2]
			}

            # For bidirectional test, merge the two sets of samples for the control chart
            if {$direction == "bidirectional"} {
                set cc_data [ThruputWLAN::merge_samples $item $lan_tg [ThruputWLAN::remove_timestamps\
                $tx_data1] [ThruputWLAN::remove_timestamps $tx_data2]]
            }
 
            # Create new ControlChart object & graphics file for this AP-STA pair
            append html_results " [ThruputWLAN::control_chart $direction $lan_tg $item $cc_data]"

            # Aggregate the data at the AP / lan_tg level
            if {$agg_cc_data == ""} {
                # First STA goes here
                set agg_cc_data $cc_data
            } else {
                # Subsequent STA go here
                set agg_cc_data [ThruputWLAN::merge_samples $item "" $agg_cc_data $cc_data]
            }
        }

        # Create aggregate controlchart
        # UTF::Message LOG "$lan_tg" "agg_cc_data=$agg_cc_data"
        append html_results " [ThruputWLAN::control_chart $direction $lan_tg "" $agg_cc_data]"
    }

  	# Create composite time plot graph on last iteration.
    append html_results " [ThruputWLAN::timeplot]"

    # On last iteration, add fatal error, if any.
    if {$::ThruputWLAN::perf_cnt == $::ThruputWLAN::perf_loop && \
        $::ThruputWLAN::fatal_error != ""} {
        append html_results " &nbsp;<font color=\"red\"><b>FATAL ERROR</b>&nbsp;$::ThruputWLAN::fatal_error </font>"
    }

    # On the last iteration add running error list, from parsing data streams.
    # Condense the error lists to the minimum sized list with just one unique
    # copy of each error type that occured. This minimizes how messy the web
    # summary page gets when there are many errors in one test.
    set ::ThruputWLAN::current_error_list [lsort -unique $::ThruputWLAN::current_error_list]
    set ::ThruputWLAN::running_error_list [lsort -unique $::ThruputWLAN::running_error_list]
    UTF::Message LOG "$::localhost" "::ThruputWLAN::current_error_list=$::ThruputWLAN::current_error_list"
    if {$::ThruputWLAN::perf_cnt == $::ThruputWLAN::perf_loop && \
        $::ThruputWLAN::running_error_list != ""} {
        append html_results " &nbsp;<font color=\"orange\"><b>ERRORS</b>&nbsp;$::ThruputWLAN::running_error_list </font>"
    }

    # Restore the "html:" header, or UTF wont process results correctly.
    # NB: MUST NOT have leading whitespace!
    set html_results [string trim $html_results]
    if {$html_results != ""} {
        set html_results "html: $html_results"
    }
    set html_results [string trim $html_results]
    UTF::Message LOG "$::localhost" "process_results iteration\
        $::ThruputWLAN::perf_cnt of $::ThruputWLAN::perf_loop:\
        html_results=$html_results"

    # How we return html_results depends on error lists & iteration counter.
    # For intermediate iterations, we dont throw errors. This allows all the
    # interations to be completed.
    if {$::ThruputWLAN::perf_cnt == $::ThruputWLAN::perf_loop &&\
       ($::ThruputWLAN::running_error_list != "") ||\
       $::ThruputWLAN::fatal_error != ""} {
        error "$html_results"
    } else {
        return "$html_results"
    }
}

#======================= remove_duplicate_samples =============================
# Removes duplicate samples based on time stamps. Due slightly fuzzy timing of
# various datastreams, two samples in the same second are allowed, but no more.
# The timestamps are expected to be in ascending sequence.
# Sample_list & returned data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value
# calling args host, id are strings shown in the log messages
#==============================================================================
proc ThruputWLAN::remove_duplicate_samples {host id type sample_list} {

    # Discard duplicate time samples. We seem to get duplicate messages
    # as the BlueTool tests shut down, so we toss them. Due slightly fuzzy
    # timing of various datastreams, two samples in the same second are
    # allowed, but no more. Check for timestamps not in ascending sequence.
    set discard_list "" ;# discarded samples
    set last_time "" ;# timestamp of previous sample
    set logname [UTF::get_name $host]
    set results "" ;# list of unique samples
    set same_time_cnt 0 ;# count of consecutive samples with same timestamp
    set warn_list "" ;# out of sequence samples
    foreach {time tput} $sample_list {
        if {$time > $last_time} {
            # Sample is in ascending order, as expected.
            lappend results $time $tput
            # puts "$time $tput ascending, keep"

        } elseif {$time == $last_time} {
            # Sample is in same second as previous sample.
            incr same_time_cnt
            if {$same_time_cnt == "1"} {
                # Allow 2 samples in same second
                lappend results $time $tput
                # puts "$time $tput duplicate, keep"

            } else {
                # After two samples in same second, samples are
                # discarded
                lappend discard_list $time $tput
                # puts "$time $tput duplicate, discard"
            }

        } else {
            # Sample is out of the expected ascending sequence.
            # Gnuplot will handle them, so we keep them as well
            # as warning the user.
            lappend results $time $tput
            lappend warn_list $time $tput
            # puts "$time $tput out of sequence, keep, warn"
        }

        # Update state variables
        if {$time != $last_time} { 
            set last_time $time
            set same_time_cnt 0
        }
    }

    # Warn user if samples discarded or out of sequence, return results
    if {$discard_list != ""} {
        UTF::Message WARN "$logname" "ThruputWLAN::remove_duplicate_samples $id $type\
            dropped [expr [llength $discard_list] / 2] duplicate samples: $discard_list"
    }
    if {$warn_list != ""} {
        UTF::Message WARN "$logname" "ThruputWLAN::remove_duplicate_samples $id $type\
            [expr [llength $warn_list] / 2] out of sequence samples: $warn_list"
    }
    return $results
}

#======================= remove_timestamps ====================================
# Routine removes the timestamps from a series of samples.
# Calling arg: space separated string in format:
# time1 tput1 ... timeN tputN
# Returns data in space separated string in format:
# tput1 ... tputN
#==============================================================================
proc ThruputWLAN::remove_timestamps {series} {

     # Remove the time stamps from the series.
     set results ""
     foreach {time tput} $series {
         lappend results $tput
     }

     # Return results
     return $results
}

#======================= setup ================================================
# Setup routine for throughput tests.
#
# Returns nothing, throws errors as needed.
#==============================================================================
proc ThruputWLAN::setup {} {
    upvar {} {} ;# gives access to unamed array from getopts

    # Count the number of -connN options currently allowed. If more -connN
    # options are needed, they will be dynamically detected here and processed.
    set temp [array names ""]
    set ::conn_max -1
    foreach item $temp { 
        if {[regexp -nocase {^conn\d+} $item]} {
            incr ::conn_max
        }
    }
    # puts "conn_max=$::conn_max temp=$temp"

    # Keep track of any connection lists found anywhere. Command line -connN
    # lists take precedance over config file variables. Get list of all AP.
    set ap_list ""
    set conn_lists no
    for {set i 0} {$i <= $::conn_max} {incr i} {
        if {$(conn$i) != ""} {
            set conn_lists yes

        } else {
            # Use catch/set to cycle thru the config file UTF::connN variables.
            set catch_resp [catch "set UTF::conn$i" catch_msg]
            # puts "i=$i catch_resp=$catch_resp catch_msg=$catch_msg"
            if {$catch_resp == 0} { 
                set (conn$i) $catch_msg
                set conn_lists yes
            }
        }
        # puts "conn$i=$(conn$i)"
        append ap_list " [lindex $(conn$i) 0]"
        set ap_list [string trim $ap_list]
    }
    # puts "ap_list=$ap_list"

    # If there are no connection lists specified, stop.
    if {$conn_lists == "no"} {
        error "Sanity.test ERROR: No -connN lists specified!"
    }

    # Sanity check the contents of the connection lists. This covers the
    # lists in the config file & the command line lists.
    set conn_error 0
    for {set i 0} {$i <= $::conn_max} {incr i} { 
        if {[UTF::check_connection_list $i $(conn$i) $(softap)] == "ERROR"} {
            incr conn_error
        }
    } 
    if {$conn_error != 0} {
        error "Sanity.test ERROR: Connection list(s) got error(s)"
    }

    # Validate the WLAN test direction.
    set ::ThruputWLAN::wlan_dir $(wlan_dir)
    set ::ThruputWLAN::wlan_dir [string trim $::ThruputWLAN::wlan_dir]
    set ::ThruputWLAN::wlan_dir [string tolower $::ThruputWLAN::wlan_dir]
    set wlan_dir_list "bidirectional dut2tg tg2dut"
    set i [lsearch -exact $wlan_dir_list $::ThruputWLAN::wlan_dir]
    if {$i < 0} {
        error "ThruputWLAN setup ERROR: Invalid wlan_dir=$::ThruputWLAN::wlan_dir,\
            must be one of: $wlan_dir_list"
    }
			
    # More initialization & sanity checks on parameters.
    # Checks for \d+ ensure positive integers, so no need to convert to integer.
    # Some items stored as double float.
    set ::ThruputWLAN::current_error_list "" ;# error list for current interation
    if {![info exists ::ThruputWLAN::erp_cnt]} {
        # Counter is maintained over many test runs.
        set ::ThruputWLAN::erp_cnt 0
    }
    set ::ThruputWLAN::fatal_error "" ;# save first fatal error that occurs
    set ::ThruputWLAN::history $(history)
    if {![regexp {^\d+$} $::ThruputWLAN::history] || $::ThruputWLAN::history < 30} {
        set ::ThruputWLAN::history 30
        UTF::Message WARN "$::localhost" "setup history set to $::ThruputWLAN::history"
    }

    # We need branch name when we call get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    set stream [UTF::get_stream_name end]

    # ControlChart keys include stream, scriptname, all AP used, user supplied keys,
    # and keys added later for the specific devices used & direction.
    # NB: Scriptname is hardcoded as argv0 shows the higher level scriptname, not
    # necessarily this script.
    set ::ThruputWLAN::key "$stream ThruputWLAN.test $ap_list"
    if {$(key) != ""} {
        append ::ThruputWLAN::key " $(key)"
    }

    set ::ThruputWLAN::need_erp no ;# request for error recovery procedure 
    set ::ThruputWLAN::perf_int [expr double($(perfint))] ;# allow 0.1 lower limit
    if {![regexp {^[\d\.]+$} $::ThruputWLAN::perf_int] || $::ThruputWLAN::perf_int < 0.1} {
        set ::ThruputWLAN::perf_int 0.1 ;# avoids divide by 0 later on.
        UTF::Message WARN "$::localhost" "setup perf_int set to $::ThruputWLAN::perf_int"
    }
    set ::ThruputWLAN::perf_loop $(perfloop)
    if {![regexp {^\d+$} $::ThruputWLAN::perf_loop] || $::ThruputWLAN::perf_loop < 1} {
        set ::ThruputWLAN::perf_loop 1
        UTF::Message WARN "$::localhost" "setup perf_loop set to $::ThruputWLAN::perf_loop"
    }
    set ::ThruputWLAN::perf_size $(perfsize)
    if {![regexp {^\d+$} $::ThruputWLAN::perf_size]} {
        set ::ThruputWLAN::perf_size 5
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputWLAN::perf_size"
    }
    if {$::ThruputWLAN::perf_size > 25} {
        set ::ThruputWLAN::perf_size 25 ;# ControlChart object limits size
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputWLAN::perf_size"
    }
    if {$::ThruputWLAN::perf_size < 2} {
        set ::ThruputWLAN::perf_size 2 ;# avoids divide by 0 later on, also CC lower limit is 2
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputWLAN::perf_size"
    }
    set ::ThruputWLAN::perf_time [expr double($(perftime))]
    if {![regexp {^[\d\.]+$} $::ThruputWLAN::perf_time]} { 
        set ::ThruputWLAN::perf_time 10
        UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputWLAN::perf_time"
    }
    if {$::ThruputWLAN::perf_time < 2.5} { 
        set ::ThruputWLAN::perf_time 2.5
        UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputWLAN::perf_time"
    }
    set ::ThruputWLAN::running_error_list "" ;# error list for test with many iterations
    # Keep track of overall running worst time delay introduced by sockets.
    if {![info exists ::ThruputWLAN::running_max_socket_delay]} {
        set ::ThruputWLAN::running_max_socket_delay 0
        set ::ThruputWLAN::running_max_socket_timestamp ""
    }
    set ::ThruputWLAN::timer_cmds ""
    set ::ThruputWLAN::title $(title_png)
    set ::ThruputWLAN::window $(window)

    # Set history based on actual groups of samples that will 
    # be generated across multiple iterations.
    set predicted_history [expr ($::ThruputWLAN::perf_time * $::ThruputWLAN::perf_loop)\
        /($::ThruputWLAN::perf_int * $::ThruputWLAN::perf_size)]
    set predicted_history [expr int($predicted_history)]
    # puts "predicted_history=$predicted_history"
    if {$predicted_history > $::ThruputWLAN::history} {
        set ::ThruputWLAN::history $predicted_history
        UTF::Message WARN "$::localhost" "setup for longer test run, history\
            set to $::ThruputWLAN::history"
    }

    # Set expected samples for a single iteration of main loop.
    puts "$::ThruputWLAN::perf_time $::ThruputWLAN::perf_int"
    set ::ThruputWLAN::expected_samples [expr int($::ThruputWLAN::perf_time / $::ThruputWLAN::perf_int)]
    if {$::ThruputWLAN::expected_samples < 1} {
        set ::ThruputWLAN::expected_samples 1
    }

    # Set sample threshold for declaring a fatal error and invoking
    # error recovery procedure, based on a single iteration of main loop.
    set ::ThruputWLAN::sample_threshold [expr int(0.7 * $::ThruputWLAN::perf_time / $::ThruputWLAN::perf_int)]
    if {$::ThruputWLAN::sample_threshold < 1} {
       set ::ThruputWLAN::sample_threshold 1
    }

    # Clean out any time plot data from a previous run.
    set names [array names ::ThruputWLAN::time_plot_array]
    set names [lsort $names]
    # UTF::Message LOG "$::localhost" "time_plot_array names=$names"
    foreach name $names {
       unset ::ThruputWLAN::time_plot_array($name)
    }

    # Log the setup data.
    UTF::Message LOG "$::localhost" "ThruputWLAN setup perfint=$::ThruputWLAN::perf_int\
        perfloop=$::ThruputWLAN::perf_loop perfsize=$::ThruputWLAN::perf_size\
        perftime=$::ThruputWLAN::perf_time history=$::ThruputWLAN::history\
        ThruputWLAN::sample_threshold=$::ThruputWLAN::sample_threshold\
        ThruputWLAN::expected_samples=$::ThruputWLAN::expected_samples\
        ThruputWLAN::key=$::ThruputWLAN::key"

    # If requested, reload devices, setup AP - STA connections.
    for {set i 0} {$i <= $::conn_max} {incr i} {
        set temp $(conn$i)
        set rtr [lindex $temp 0]
        set sta [lrange $temp 1 end]
        UTF::Message INFO "" "Open connections i=$i rtr=$rtr sta=$sta"
        if {$rtr == "" || $sta == ""} {
            continue
        }

        # If requested, reload AP.
        if {$(reloadap)} {
            UTF::Try "Reload AP $rtr" {
                if {[eval UTF::check_host_type $rtr $::ap_type_list]} {
                    # Real AP
                    UTF::reload_rtr $rtr
                } else {
                    # SoftAP
                    UTF::reload_sta $rtr
                }
            }
        }

        # If requested, reload STA
        if {$(reloadsta)} {
            foreach item $sta {
                UTF::Try "Reload STA $item" {
                    UTF::reload_sta $item
                }
            }
        }

        # If requested, connect AP & STA
        if {$(connect)} {
            foreach item $sta {
                UTF::Try "Open Connection $rtr $item" {
                    UTF::open_connection_retry $rtr $item
                }
            }
        }
    }
}

#======================= tcp_tune =============================================
# Does TCP tuning for all PC before iperf is launched. When many PC are used,
# the TCP tuning time can exceed the iperf test time, so that some tests are
# done before others start. So we do all the TCP tuning in one shot first.
# We also cache IP addresses even if we dont tune TCP.
#
# Returns: null
#==============================================================================
proc ThruputWLAN::tcp_tune {conn_list lan_tg notune} {

    # Tune the TCP windows on all machines. When the test has multiple
    # iterations, only do the tuning for the first iteration. 
    if {$::ThruputWLAN::perf_cnt != 1} {
        return
    }

    # Get AP, STA. Return if any data is null.
    set AP [lindex $conn_list 0]
    set STA  [lrange $conn_list 1 end]
    # Log connection info. Return if any data is null.
    if {$AP == "" || $STA == ""} {
        return
    }
    UTF::Message LOG "$::localhost" "\n\nThruputWLAN::tcp_tune AP=$AP lan_tg=$lan_tg STA=$STA notune=$notune"

    # TCP tune each PC. Cache the IP address of all PC.
    foreach item "$lan_tg $STA" {

        # Try to tune the device
        if {$notune == 0} {
            UTF::Message LOG "$item" "ThruputWLAN::tcp_tune Tuning TCP"
            set resp [$item tcptune $::ThruputWLAN::window]
        } else {
            set resp ""
        }

        # If the OS doesnt allow the TCP stack to be tuned, then we
        # apply the -w option to iperf. This typically only gets used
        # on Windows machines. Supposedly if we apply the -w option to
        # iperf on a Linux machine, the thruput will suffer greatly.
        if {$resp == 1 && $::ThruputWLAN::window ne 0} {
            set ::ThruputWLAN::wlan($item,opt) "-w $::ThruputWLAN::window"
        } else {
            set ::ThruputWLAN::wlan($item,opt) ""
        }

        # Get the device IP address.
        set ::ThruputWLAN::wlan($item,ip) [$item ipaddr]
        UTF::Message LOG "$item" "ThruputWLAN::tcp_tune\
            Caching IP: $::ThruputWLAN::wlan($item,ip)"
    }
}

#======================= test_profile =========================================
# WLAN iperf traffic run on an existing connection(s).
#
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
proc ThruputWLAN::test_profile {} {
    upvar {} {} ;# gives access to unamed array from getopts

    # First TCP tune all PC. This ensures that all TCP tuning is done before
    # any of the iperf tests are launched. When testing many STA, TCP tuning
    # is a significant time component. We also cache IP addresses, even if we
    # dont tune TCP.
    for {set i 0} {$i <= $::conn_max} {incr i} {
        set lan_tg [ThruputWLAN::get_lan_tg $(conn$i)]
        set (lan_tg$i) $lan_tg ;# creates new entry in unamed array
        ThruputWLAN::tcp_tune $(conn$i) $lan_tg $(notune)
    }

    # Do pre_perf_hook commands for all PC
    for {set i 0} {$i <= $::conn_max} {incr i} {
        ThruputWLAN::perf_hook $(conn$i) $(lan_tg$i) "pre"
    }

    # Start WLAN iperf tests for all PC
    set fd_list ""
    for {set i 0} {$i <= $::conn_max} {incr i} {
        append fd_list " [ThruputWLAN::thruput_wlan_traffic $(conn$i) $(lan_tg$i)]"
    }

    # Collect data from parallel processes.
    set resp1 ""
    set resp2 ""
    set timeout_sec [expr int($::ThruputWLAN::perf_time + 20)]
    UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
    # UTF::Message LOG "" "\n\nThruputWLAN::test_profile resp1=$resp1\n\n"

    # Do post_perf_hook commands for all PC
    for {set i 0} {$i <= $::conn_max} {incr i} {
        ThruputWLAN::perf_hook $(conn$i) $(lan_tg$i) "post"
    }

    # Process results
    set results [ThruputWLAN::process_results $resp1]
    return "$results"
}

#======================= thruput_wlan_traffic =================================
# Routine starts up iperf traffic between WLAN devices specified in connN list.
# Optional arg direction can be used to override the global direction setting.
#
# NB: TCP tuning is now done in a separate routine, and is expected to be 
# taken care of before this routine runs.
#
# Returns hosts & file handles for parallel process started.
#==============================================================================
proc ThruputWLAN::thruput_wlan_traffic {conn_list lan_tg {direction ""}} {

    # Get AP, STA. Return if any data is null.
    set AP [lindex $conn_list 0]
    set STA  [lrange $conn_list 1 end]
    if {$AP == "" || $STA == "" || $lan_tg == ""} {
        return
    }

    # On occasion, calling routine may wish to use a different
    # traffic direction than the default value. Most of the time
    # the default value is appropriate.
    set direction [string trim $direction]
    set direction [string tolower $direction]
    if {$direction == ""} {
        if {[info exists ::ThruputWLAN::wlan_dir]} {
            set direction $::ThruputWLAN::wlan_dir
        } else {
            set direction bidirectional
        }
    }
    UTF::Message LOG "$::localhost" "\n\nThruputWLAN::thruput_wlan_traffic\
        AP=$AP lan_tg=$lan_tg STA=$STA direction=$direction"

    # iperf is normally running as a service on all UTF machines, and is
    # supposed to be ready to accept in incoming iperf TCP connections at
    # all times. UDP currently not supported here.

    # Start wlan iperf traffic for dut2tg or bidirectional.
    # To get the data with a timestamp from the remote host, we use a
    # wrapper script, iperf_timestamps.tcl. 
    set results ""
    if {$direction == "dut2tg" || $direction == "bidirectional"} {

        # Start iperf as parallel task via rpopen.
        # UTF::Message LOG "$::localhost" "\n\nThruputWLAN::thruput_wlan_traffic dut2tg"
        foreach item $STA {
             set fd_dut [$item rpopen iperf_timestamps.tcl\
                -c $::ThruputWLAN::wlan($lan_tg,ip)\
                -i $::ThruputWLAN::perf_int -t $::ThruputWLAN::perf_time -fb\
                $::ThruputWLAN::wlan($lan_tg,opt)]
            fconfigure $fd_dut -blocking 0
            fileevent $fd_dut readable {set ::utils_reading READY}

            # Add the host & file handle to results.
            # Show both hosts with fd so we can match iperf data up later on.
            UTF::Message LOG "$item" "ThruputWLAN::thruput_wlan_traffic dut2tg created fd=$fd_dut"
            append results " ${item}-${lan_tg} $fd_dut"
        }
    }

    # Start wlan iperf traffic for tg2dut or bidirectional.
    if {$direction == "tg2dut" || $direction == "bidirectional"} {

        # Start iperf as parallel task via rpopen.
        # UTF::Message LOG "$::localhost" "\n\nThruputWLAN::thruput_wlan_traffic tg2dut"
        foreach item $STA {
            set fd_tg [$lan_tg rpopen iperf_timestamps.tcl\
                -c $::ThruputWLAN::wlan($item,ip)\
                -i $::ThruputWLAN::perf_int -t $::ThruputWLAN::perf_time -fb\
                $::ThruputWLAN::wlan($item,opt)]
            fconfigure $fd_tg -blocking 0
            fileevent $fd_tg readable {set ::utils_reading READY}

            # Add the host & file handle to results
            # Show both hosts with fd so we can match iperf data up later on.
            UTF::Message LOG "$lan_tg" "ThruputWLAN::thruput_wlan_traffic tg2dut created fd=$fd_tg"
            append results " ${lan_tg}-${item} $fd_tg"
        }
    }

    # Thats it.
    return "$results"
}

#======================= timeplot =============================================
# Takes data from global array time_plot_array and creates a composite time
# plot graph.
# Calling args: none
# Returns: html string with control chart png file & thumbnail
#==============================================================================
proc ThruputWLAN::timeplot {} {

    # Create composite time plot graph just on the last iteration.
    if {$::ThruputWLAN::perf_cnt != $::ThruputWLAN::perf_loop} {
        return
    }

    # Get list of data series from the time_plot_array.
    # Array is wiped clean in the process.
    set names [array names ::ThruputWLAN::time_plot_array]
    set names [lsort $names]
    set series ""
    foreach name $names {

        # Format name into series title.
        regsub -all "_" $name " " series_title 

        # Axes to use for plot is determined by ID, the first token in title
        set id [lindex $series_title 0]
        set id [string trim $id]
        set id [string toupper $id]
        if {$id == "BT"} {
            set axes x1y2 ;# plot BT data on right Y-axis
        } else {
            set axes x1y1 ;# plot WLAN data on left Y-axis
        }
        # puts "series_title=$series_title id=$id axes=$axes"

        # Add series data to list. Dont purge the time plot array!
        lappend series "\"$series_title\" $axes $::ThruputWLAN::time_plot_array($name)"
    }

    # If there are series, plot them.
    set series [string trim $series]
    # puts "series=$series"
    if {$series == ""} {
        return
    }

    UTF::Message LOG "$::localhost" "ThruputWLAN::timeplot processing..."
    set chart [UTF::gnuplot_lines "$::ThruputWLAN::title" "Time HH:MM:SS" "time"\
        "WLAN Throughput (Mbit/sec)" "" "Time Plot" "$series"]
    regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
    return $chart
}

#======================= timestamp_correction =================================
# Routine used to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# id: bt|wlan
# time1 is localhost / UTF timestamp
# time2 is remote host timestamp
# time_delta_sec is the known time difference, in seconds, between the localhost
# and the remotehost
# Returns corrected time
# times are all in format: hh:mm:ss
#==============================================================================
proc ThruputWLAN::timestamp_correction {id time1 time2 time_delta_sec} {
    # puts "ThruputWLAN::timestamp_correction time1=$time1 time2=$time2\
    #    time_delta_sec=$time_delta_sec"

    # Convert time2 to seconds, adjust time2 and reformat
    set catch_resp [catch "set time2_sec \[clock scan $time2\]" catch_msg]
    if {$catch_resp !=0} {
        UTF::Message ERROR "$::localhost" "ThruputWLAN::timestamp_correction\
            ERROR: invalid time2=$time2 $catch_msg"
        return "$time2" 
    }
    set corrected_time_sec [expr $time2_sec - $time_delta_sec] ;# adjust to localhost timebase
    set corrected_timestamp [clock format $corrected_time_sec -format %H:%M:%S]

    # Keep track of worst time delay introduced by sockets
    set catch_resp [catch "set time1_sec \[clock scan $time1\]" catch_msg]
    if {$catch_resp !=0} {
        UTF::Message ERROR "$::localhost" "ThruputWLAN::timestamp_correction\
            ERROR: invalid time1=$time1 $catch_msg"
        return "$corrected_timestamp" 
    }
    set socket_delay_sec [expr abs($time1_sec - $corrected_time_sec)]
    if {![info exists ::ThruputWLAN::max_socket_delay]} {
        set ::ThruputWLAN::max_socket_delay 0
        set ::ThruputWLAN::max_socket_timestamp ""
    }
    if {$socket_delay_sec > $::ThruputWLAN::max_socket_delay} {
        set ::ThruputWLAN::max_socket_delay $socket_delay_sec
        set ::ThruputWLAN::max_socket_timestamp "$id time1=$time1\
            time2=$time2 corrected=$corrected_timestamp"
    }

    # Keep track of overall running worst time delay introduced by sockets.
    if {![info exists ::ThruputWLAN::running_max_socket_delay]} {
        set ::ThruputWLAN::running_max_socket_delay 0
        set ::ThruputWLAN::running_max_socket_timestamp ""
    }
    if {$socket_delay_sec > $::ThruputWLAN::running_max_socket_delay} {
        set ::ThruputWLAN::running_max_socket_delay $socket_delay_sec
        set ::ThruputWLAN::running_max_socket_timestamp "$id time1=$time1\
            time2=$time2 corrected=$corrected_timestamp"
    }

    # Return corrected_timestamp
    # puts "time1_sec=$time1_sec time2_sec=$time2_sec\
    #    corrected_time_sec=$corrected_time_sec"
    # puts "corrected_timestamp=$corrected_timestamp\
    #    socket_delay_sec=$socket_delay_sec"
    return "$corrected_timestamp"
}

#======================= End Common Procs  ==================================

#======================= ThruputWLAN ============================================
# Main test program. Supervises the initialization, runs the desired test
# multiple times as needed.
# 
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
UTF::Test ThruputWLAN {args} {

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts "$::ThruputWLAN_getopts" "$::ThruputWLAN_help"

    # Set email subject & report title.
    set email_subject [UTF::setup_email_subject $(title)]

    # Start web report
    UTF::WrapSummary $UTF::SummaryDir "$email_subject" "" "$(email)" {

        # Run setup routine. The "" passes the unnamed array to setup.
        ThruputWLAN::setup

        UTF::Try "$(title_try)" {

            # Log the setup data.
            UTF::Message LOG "$::localhost" "ThruputWLAN setup perfint=$::ThruputWLAN::perf_int\
                perfloop=$::ThruputWLAN::perf_loop perfsize=$::ThruputWLAN::perf_size\
                perftime=$::ThruputWLAN::perf_time history=$::ThruputWLAN::history\
                ThruputWLAN::sample_threshold=$::ThruputWLAN::sample_threshold\
                ThruputWLAN::expected_samples=$::ThruputWLAN::expected_samples\
                ThruputWLAN::key=$::ThruputWLAN::key"

            # Run the test perfloop times.
            # NB: process_results and other routines are watching ::ThruputWLAN::perf_cnt
            # and expects the final value to be ::ThruputWLAN::perf_loop, which is why
            # ::ThruputWLAN::perf_cnt needs to start at 1, not 0.
            set iteration_errors 0 ;# keep track of all errors across all iterations.
            for {set ::ThruputWLAN::perf_cnt 1} {$::ThruputWLAN::perf_cnt <=\
                $::ThruputWLAN::perf_loop} {incr ::ThruputWLAN::perf_cnt} {
    
                # When running multiple iterations, put a marker line in the log.
                if {$::ThruputWLAN::perf_loop > 1} {
                    UTF::Message LOG "$::localhost" "ThruputWLAN getting sample\
                        set $::ThruputWLAN::perf_cnt of $::ThruputWLAN::perf_loop\
                        ============================================================="
                }
    
                # Run the desired test, count all errors.
                set results ""
                set catch_msg ""
                set catch_resp [catch "set results \[ThruputWLAN::test_profile\]" catch_msg]
                if {$catch_resp != 0} {
                    incr iteration_errors ;# keep track of all errors across all iterations.
                }
                UTF::Message LOG "$::localhost" "ThruputWLAN main loop iteration:\
                    $::ThruputWLAN::perf_cnt of $::ThruputWLAN::perf_loop \
                    iteration_errors=$iteration_errors catch_resp=$catch_resp\
                    catch_msg=$catch_msg\nresults=$results"
            
                # Reset the timer cmds, or they accumulate from one iteration to
                # the next.
                set ::ThruputWLAN::timer_cmds ""
        
                # NB: Never reset the fatal_error, or  it wont show up on the web
                # page summary.
    
                # When requested, do the error recovery procedure. This ensures
                # that the next test or iteration will have a relatively clean
                # starting point.
                # Sometimes error_recovery_procedure fails and retry is needed
                for {set retry_cnt 1} {$retry_cnt <= 3} {incr retry_cnt} {
                    if {$::ThruputWLAN::need_erp == "yes"} {
                        UTF::Message LOG "$::localhost" "======================================================================================================="
                        UTF::Message LOG "$::localhost" "error_recovery_procedure try $retry_cnt"
                        ThruputWLAN::error_recovery_procedure
                    }
                }
            }

            # Return the results.
            UTF::Message LOG "$::localhost" "ThruputWLAN main loop completed\
                iteration_errors=$iteration_errors\
                erp_cnt=$::ThruputWLAN::erp_cnt"
            UTF::Message LOG "$::localhost" "max_socket_delay=$::ThruputWLAN::running_max_socket_delay\
                seconds occured at: $::ThruputWLAN::running_max_socket_timestamp"
            if {$iteration_errors == 0} {
                return "$results"
            } else {
                set error_result "$results $catch_msg"
                set error_result [string trim $error_result]
                error "$error_result"
            }
        }
    }
}
