#!/bin/env utf
# -*-tcl-*-

# AP and STA for all channel and rates.
# $Id$ 
# $Copyright Broadcom Corporation$
# Modified from ChannelSweep and EmbeddedNightly by Jeff Galiotto

#

package require UTF
package require UTF::utils
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::ControlChart
package require UTF::Test::controlchart
package require UTF::Test::DataRate
package require UTF::Test::memchart
package require UTF::Test::ratetput
package require UTF::Test::rssinoise


# package provide UTF::Test::ChannelPerf

package provide UTF::Test::ChannelPerf 2.0

    UTF::Test ChannelPerf {AP STA args} {
    
    upvar {} testopts
    UTF::Getopts {
    {branch.arg "auto" "Branch override"}
	{band.arg "" "Band"}
	{bw.arg "" "BandWidth"}
	{chanspec.arg "" "Chanspec list"}
	{count.arg "30" "Retry count"}
	{date.arg "" "Image date"}
	{email.arg "" "Email Address"}
	{history.arg 30 "History size for control charts"}
	{msg.arg "" "Message"}
	{noapload "Don't load new AP images"}
	{noapreload "Don't reload AP image"}
	{nocache "Don't update performance cache"}
	{nosetup "No Setup"}
	{nostaload "Don't reload STA drivers"}
	{nostareload "Don't even reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{nounload "Don't unload driver after test"}
	{norate "Disable Fixed Rate tests"}
	{perfloop.arg 1 "Performance test loops"}
	{ratelist.arg "" "Channels to test legacy and mcs rates"}
	{skip.arg "" "Chanspec skip list"}
	{title.arg "" "Title"}
	{nobx "No Bidirectional Performance tests"}
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
	set ::UTF::MemChart::readonly 1
    }
    
    # User can specify per device defaults in config.  This is useful
    # in cases where the auto detected channels are known to not all
    # work.
    # I need to compare this with chanspec 
    set args [concat [$AP cget -channelsweep] [$STA cget -channelsweep] $args]
    
    if {$(date) ne ""} {
	  set date $(date)
	
	  foreach S $(sta) {
	    $S configure -date $(date)
	  }
		unset S
      } else {
	    set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	    # Clean up whitespace (RH9 compat)
	    regsub -all {\s+} $date {} date
      }

    # Compact build list for title
    set build [UTF::BuildTitle $STA]

    if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}

	if {[regexp {(\d+sd)} $AP - c]} {
	    append (title) " with $c AP"
	}
    }
    
    set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    
    
    
    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build
    
    if {$(branch) eq "auto"} {
	    set branch [$STA branchname]
	} else {
	    set branch $(branch)
	}

	UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	
	if {!$(nosetup)} {
	    if {$(noapload)} {
		if {!$(noapreload)} {
		    UTF::Try "$AP reload" {
			$AP reload
		    }
		}
	    } else {
		UTF::Try "$AP load" {
		    $AP load
		}
	    }
	}
	
	
	# Find images
	 if {!$(nostaload)} {
	   UTF::Try "$STA Find STA Image" {
	     UTF::CheckImage $STA $date unknown
	   }
	 }
	
	# EN does a much more complex version of nosetup
	if {!$(nosetup)} {
	    if {$(nostaload)} {
		if {!$(nostareload)} {
		    UTF::Try "$STA reload" {
			$STA reload
		    }
		}
	    } else {
		UTF::Try "$STA load" {
		    $STA load
		}
	    }
	}
	
	UTF::Try "$STA defaults" {

		$STA services stop
		catch {$STA wl msglevel +error +assoc}
		if {![$STA cget -nomimo_bw_cap]} {
		    catch {$STA wl down}
		    # Enable 40 in 2.4, if available.
		    # Doesn't work for LMAC since LMAC is never "down"
		    $STA wl -u mimo_bw_cap 1
		    $STA wl up
		    UTF::Sleep 1
		}

		$STA wl ver
		set what [$STA whatami]
		
		if {!$(nostaload)} {
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		}
		set what
	    }

	    if {!$(nostaload) && [set reclaim [$STA reclaim]]} {
		UTF::Try "$STA: Reclaim" {
#		    if {$(bin) eq ""} {
#			# Only do MemSave for official builds
#			UTF::MemSave $reclaim "reclaim" [$STA imageinfo]
#		    }
		    # MemChart
		    memchart $reclaim -key [list $branch $STA reclaim] \
			-failonlow
		}
	    }
	
    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

    proc systime {STA} {
	catch { $STA rexec {vmstat 1 6 | awk 'FNR>3{print $14}' } }
    }
    
    # If no message, set it to the AP name
    if {$(msg) eq ""} {
	set (msg) $AP
    }

    UTF::decomment (chanspec)

    set SSID [$AP wl ssid]

    if {$(chanspec) eq ""} {
	# default to finding chanspecs AP and STA have in common
	set (chanspec) [UTF::Common [$AP allchanspecs] [$STA allchanspecs]]
    }

    UTF::Message INFO [$AP cget -name] "Testing $(chanspec)"

           
    # Partition into bands and bandwidths for convenient reporting
    foreach chanspec $(chanspec) {
	  if {[lsearch -exact $(skip) $chanspec] >= 0} {
	    UTF::Message INFO  [$AP cget -name] "Skipping $chanspec"
	    continue
	  }
	  if {[regexp {^(\d+)(\w*)} $chanspec - c sb]} {
	    if {$c > 15} {
		if {[lsearch {"" "5" "a"} $(band)] < 0} {
		    continue
		} else {
		    set band "5GHz"
		}
	    } else {
		if {[lsearch {"" "2.4" "b" "g"} $(band)] < 0} {
		    continue
		} else {
		    set band "2.4GHz"
		}
	    }
	    if {$sb eq ""} {
		if {[lsearch {"" "20"} $(bw)] < 0} {
		    continue
		} else {
		    set bw "20MHz"
		}
	    } else {
		if {[lsearch {"" "40"} $(bw)] < 0} {
		    continue
		} else {
		    set bw "40MHz"
		}
	    }
	    
	    # Group the channels by $band and $bw  
	    lappend clist($band,$bw) $chanspec
	    # lappend clist $chanspec
	  } else {
	    error "bad chanspec $chanspec"
	  }
    }

  # start of EN setup info
  
    UTF::Getopts {
	    {PM.arg "0" "Power Management"}
	    {fb.arg "" "Frameburst"}
	    {ch.arg "" "Chanspec"}
	    {security.arg "open" "security"}
	}

	if {$(fb) eq ""} {
	    # Frameburst default depends on OS
	    if {![$STA cget -noframeburst] && [$STA hostis MacOS]} {
		set (fb) 1
	    } else {
		set (fb) 0
	    }
	} else {
	    # canonicalize
	    set (fb) [string is true $(fb)]
	}

	if {[$AP hostis Router Vx BSDAP DSL]} {
	    set LAN [$AP lan]
	} else {
	    set LAN $AP
	}
	if {$(PM) == 1} {
	    # Low performance tests may need longer to reduce
	    # quantization errors
	    set i 5
	} else {
	    set i 2
	}

	if {$(ch) ne ""} {
	    append (msg) ": CH=$(ch)"
	}
	if {$(fb)} {
	    append (msg) ": FB=$(fb)"
	}
	if {$(PM)} {
	    append (msg) ": PM=$(PM)"
	}
	if {$(security) ne "open"} {
	    append (msg) ": $(security)"
	}
    
    UTF::Try "$(msg): Setup" {
	    # Put STAs into PM mode before association, to make sure
	    # we can associate in PM mode.
	    if {![$STA cget -apmode]} {
		if {[catch {$STA wl PM $(PM)} ret] &&
		    ([regexp {killed} $ret] ||
		     ($(PM) && ![regexp {Not STA} $ret]))} {
		    error $ret
		}
	    }
	    if {[$STA wl frameburst] ne $(fb)} {
		$STA wl frameburst $(fb)
		if {[$STA wl frameburst] ne $(fb)} {
		    if {$(fb)} {
			error "failed to enable frameburst"
		    } else {
			error "failed to disable frameburst"
		    }
		}
	    }
	    if {$(ch) ne ""} {
		if {[$STA cget -apmode]} {
		    APChanspec $STA $(ch)
		} else {
		    APChanspec $AP $(ch)
		}
	    }
	    if {$(security) ne [$AP cget -security]} {
		ConnectAPSTA $AP $STA -security $(security)
	    } elseif {[catch {$STA wl bssid} ret] || \
			  $ret eq "00:00:00:00:00:00"} {
		ConnectAPSTA $AP $STA
	    }
	    # Set frameburst after any AP restarts
	    $AP wl frameburst $(fb)

	    # If we're in SoftAP mode, set PM on the router.  Do this
	    # after assoc, since WET assoc may restart the router.
	    if {[$STA cget -apmode]} {
		$AP wl PM $(PM)
	    }

	    set k [concat $(branch) $AP $(PM)]
	    
	    # This isn't the place to do this! or at least do an else and use chanspec
	    if {$(ch) ne ""} {
		lappend k "ch=$(ch)"
	    }
	    if {$(fb)} {
		lappend k "fb=$(fb)"
	    }

	    if {$(security) ne "open"} {
		lappend k "$(security)"
	    }

	    if {[$STA cget -dosystime]} {
		after 5000 [namespace current]::systime $STA
	    }
	    set setup 1
	    }
	    
	    # foreach band/bw group 
       foreach bb [lsort [array names clist]] {
       
       # clear list of channel mean values each time we go to a new band/bw
	   set meanlist1 {"WLAN<-LAN" x1y1 }
	   set meanlist2 {"WLAN->LAN" x1y1 }
	   set meanlist3 {"WLAN<>LAN" x1y1 }
	   
	   set Lxlist1 {"LowerControlLimit" x1y1 }
	   set Lxlist2 {"LowerControlLimit" x1y1 }
	   set Lxlist3 {"LowerControlLimit" x1y1 }
	   
	   set Uxlist1 {"UpperControlLimit" x1y1 }
	   set Uxlist2 {"UpperControlLimit" x1y1 }
	   set Uxlist3 {"UpperControlLimit" x1y1 }
       
       # Test the performance of each supported channel in the band/bw group
       UTF::Try "$(msg): Channel Performance ($bb)" {

	   # Display all channels in the band/bw group that will be tested  
       UTF::Message INFO [$AP cget -name] "Testing $clist($bb)"
	    
	    # Make sure devices are associated.  NULL bssid check is
	    # in case the AP was last used in STA mode.
	    if {$SSID eq "" || [$STA wl ssid] ne $SSID} {
		ConnectAPSTA $AP $STA
	    }

	    set apip [$AP ipaddr]
	    
        # Auto TCP window size setting based on phy rate
	    set w [$STA tcpautowindow]
	    }
	    
	    foreach c $clist($bb) {
	  
		$STA wl bssid
		# Abort quickly if the association is lost.  We could
		# try reassociating, but if there is something seriously
		# wrong, we could waste a long time here.
		
		
		# reset the key for each channel
			set key ""
			
			set key $k
		    
		    lappend key $c
		    
		  UTF::Try "$STA: Chanspec $c WLAN<-LAN" {  
                    
		  # is this everything, looks stats in controlchart.test
		     # Make sure we dont pick up data from previous test.
                        set catch_msg_cc ""
                        set catch_resp_cc 0
                        set CC(Lx) 0
                        set CC(mmm) "0 0 0"
                        set CC(samples) ""
                        set CC(Ux) 0
                        
		  		APChanspec $AP $c
         			    
		 		 # Is this doing anything?  If not, get rid of it
		  		set success 0
		    		  			
		    	# need to use a different error check for ping and/or cc
		    	$STA ping $apip -c $(count)
			                     
				catch {$STA wl rssi} rssi
		    			
				# Test next channel and chart it
				set code [catch {controlchart [list $LAN $STA] -key $key -i $i -window $w \
		    	-loop 1 -history 30 -stats CC} ret]
		    
		    	# controlchart.test now provide results in variables in
                        # user specified array CC.
                        lappend meanlist1 Ch$c [lindex $CC(mmm) 0] ;# retreive the mean
                        # set tput_mean1 [lindex $mmm 0] ;# used by several routines
                        lappend Lxlist1 Ch$c $CC(Lx)
                        lappend Uxlist1 Ch$c $CC(Ux)
                        
				set ret "$ret RSSI: $rssi"
		    
				set success 1
			
			# run rate throughput test with MCS and legacy rates
			# [lsearch -exact $(skip) $chanspec]
			if {!$(norate) && ([lsearch $(ratelist) $c] || [$(ratelist) eq ""])} {
		      UTF::Try "$STA: Check different rate settings" {
			  UTF::Message INFO "" "Before call ratetput without down in key"
		        lappend key "down"
		        UTF::Message INFO "" "Before call ratetput with down in key"
		        ratetput $AP $STA -nodisassoc -key $key
		        UTF::Message INFO "" "After calling ratetput with down in key"
		        set key [lreplace $key end end]
		        UTF::Message INFO "" "After calling ratetput without down in key"
		        		        
		      }
		    }
				
				# Cleanup for next loop by returning results and pass/fail code
                if {$code == 0} {
                    return $ret
                    } else {
                        error $ret
                    }
            }
			            
          UTF::Try "$STA: Chanspec $c WLAN->LAN" { 
          
           	# is this everything, looks stats in controlchart.test
		    # Make sure we dont pick up data from previous test.
                        set catch_msg_cc ""
                        set catch_resp_cc 0
                        set CC(Lx) 0
                        set CC(mmm) "0 0 0"
                        set CC(samples) ""
                        set CC(Ux) 0
                                  
          	APChanspec $AP $c
         			    
		  	# Is this doing anything?  If not, get rid of it
		  	set success 0
		    		  			
		    # need to use a different error check for ping and/or cc
		    $STA ping $apip -c $(count)
			                     
			catch {$STA wl rssi} rssi
		    			
			# Test next channel and chart it
			set code [catch {controlchart [list $STA $LAN] -key $key -i $i -window $w \
		    -loop 1 -history 30 -stats CC} ret]
		    
		    	   
		    # controlchart.test now provide results in variables in
                        # user specified array CC.
                        lappend meanlist2 Ch$c [lindex $CC(mmm) 0]
                                                                        
                        lappend Lxlist2 Ch$c $CC(Lx)
                        lappend Uxlist2 Ch$c $CC(Ux)
                                   
		    
		    	set ret "$ret RSSI: $rssi"
		    
				set success 1
			
				# run rate throughput test with MCS and legacy rates
			# [lsearch -exact $(skip) $chanspec]
			if {!$(norate) && ([lsearch $(ratelist) $c] || [$(ratelist) eq ""])} {
		      UTF::Try "$STA: Check different rate settings" {
		        lappend key "up"
		        ratetput $AP $STA -nodisassoc -key $key
		        set key [lreplace $key end end]
		      }
		    }
				
				# Cleanup for next loop by returning results and pass/fail code
                if {$code == 0} {
                    return $ret
                    } else {
                        error $ret
                    }
            }
            
            # if bi-directional testing chosen
            if {!$(nobx)} {
            UTF::Try "$STA: Chanspec $c WLAN<>LAN" {  
            
            # is this everything, looks stats in controlchart.test
		     # Make sure we dont pick up data from previous test.
                        set catch_msg_cc ""
                        set catch_resp_cc 0
                        set CC(Lx) 0
                        set CC(mmm) "0 0 0"
                        set CC(samples) ""
                        set CC(Ux) 0
                        # set mmm3 "0 0 0"
                        # set tput_mean3 0
                        # set Lx3 0
                        # set Ux3 0
            
            # Change the AP channel so the STA will roam to it		
		    APChanspec $AP $c
         			    
		  # Is this doing anything?  If not, get rid of it
		  set success 0
		    		  			
		    # need to use a different error check for ping and/or cc
		    $STA ping $apip -c $(count)
			                     
			catch {$STA wl rssi} rssi
		    			
			# Test next channel and chart it
			set code [catch {controlchart [list $STA $LAN $LAN $STA] -key $key -i $i -window $w \
		    -loop 1 -history 30 -stats CC} ret]
		    
		    		    
		    # controlchart.test now provide results in variables in
                        # user specified array CC.
                        lappend meanlist3 Ch$c [lindex $CC(mmm) 0] ;# retreive the mean
                        # set mmm3 $CC(mmm) ;# mean min max
                        # set tput_mean3 [lindex $mmm 0] ;# used by several routines
                        # set Lx3 $CC(Lx)
                        # set Ux3 $CC(Ux)
                        lappend Lxlist3 Ch$c $CC(Lx)
                        lappend Uxlist3 Ch$c $CC(Ux)
                                                
                        # parray CC

                        # Setup scale factors for beacon / assoc state data
                        # UTF::setup_scale_factors $tput_mean
		    
		    
		    set ret "$ret RSSI: $rssi"
		    
			set success 1
			
				# run rate throughput test with MCS and legacy rates
			# [lsearch -exact $(skip) $chanspec]
			if {!$(norate) && ([lsearch $(ratelist) $c] || [$(ratelist) eq ""])} {
		      UTF::Try "$STA: Check different rate settings" {
		         lappend key "bidir"
		        ratetput $AP $STA -nodisassoc -key $key
		        set key [lreplace $key end end]
		      }
		    }
			
			# Cleanup for next loop by returning results and pass/fail code
                if {$code == 0} {
                    return $ret
                    } else {
                        error $ret
                    }
            } ;# end of UTF::Try "$STA: Chanspec $c WLAN<>LAN"
            } ;# end of if {!$(nobx)} 
            } ;# end of foreach c $clist($bb)    
            	set allmeanvalues ""
            	set meanLxUx1 ""
            	set meanLxUx2 ""
            	set meanLxUx3 ""
                        
            # call gnuplot_lines with meanlist1, meanlist2, and meanlist3 (if !nobx)
            if {!$(nobx)} { 
            	lappend allmeanvalues "$meanlist1" "$meanlist2" "$meanlist3"
            	lappend meanLxUx1 "$meanlist1" "$Uxlist1" "$Lxlist1"
            	lappend meanLxUx2 "$meanlist2" "$Uxlist2" "$Lxlist2"
            	lappend meanLxUx3 "$meanlist3" "$Uxlist3" "$Lxlist3"
            	
            	UTF::Try "$STA: Composite Control Charts" {
            		UTF::gnuplot_lines "($bb) Mean Tput" "Channel #" category "Mb/s" "" "($bb) Mean Values" "$allmeanvalues"
            	}
            	UTF::Try "$STA: ($bb) WLAN<-LAN" {
            		UTF::gnuplot_lines "($bb) WLAN<-LAN" "Channel #" category "Mb/s" "" "WLAN<-LAN Performance" "$meanLxUx1"
            	}
            	UTF::Try "$STA: ($bb) WLAN->LAN" {
            		UTF::gnuplot_lines "($bb) WLAN->LAN" "Channel #" category "Mb/s" "" "WLAN->LAN Performance" "$meanLxUx2"
            	}
            	UTF::Try "$STA: ($bb) WLAN<>LAN" {
            		UTF::gnuplot_lines "($bb) WLAN<>LAN" "Channel #" category "Mb/s" "" "WLAN<>LAN Performance" "$meanLxUx3"
            	}
        	} else {
            	lappend allmeanvalues "$meanlist1" "$meanlist2"
            	lappend meanLxUx1 "$meanlist1" "$Uxlist1" "$Lxlist1"
            	lappend meanLxUx2 "$meanlist2" "$Uxlist2" "$Lxlist2"
            	UTF::Try "$STA: Composite Control Charts" {
            		UTF::gnuplot_lines "($bb) Mean Tput" "Channel #" category "Mb/s" "" "($bb) Mean Values" "$allmeanvalues"
            	}	
				UTF::Try "$STA: ($bb) WLAN<-LAN" {
            		UTF::gnuplot_lines "($bb) Downstream Tput" "Channel #" category "Mb/s" "" "WLAN<-LAN Performance" "$meanLxUx1"
            	}
            	UTF::Try "$STA: ($bb) WLAN->LAN" {
            		UTF::gnuplot_lines "($bb) Upstream Tput" "Channel #" category "Mb/s" "" "WLAN->LAN Performance" "$meanLxUx2"
            	}
            	} ;# end of else
            	
          
			}	;# end of foreach bb [lsort [array names clist]]
            
		  foreach S [list $STA $AP] {
		    if {[$S hostis DHD WinDHD PXA LMAC] &&
			![$S cget -nomaxmem] && [$S cget -console] ne ""} {
			UTF::Try "$S: MaxMem in use" {
			    memchart [$S maxmem] \
				-key [list $branch $S maxmem] \
				-history $(history)
			}
		    }
		}
			
			
		if {!$(nounload)} {
	        UTF::Try "$STA: unload driver" {
		      $STA unload
	        }
	      }
	      
	      catch {$STA deinit}
		  		  
		  } ;# end of Wrap summary
		} 
	