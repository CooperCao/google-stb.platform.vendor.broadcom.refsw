#!/bin/env utf
# -*-tcl-*-

#
# UTF test script to test ampdu tuning
# $Id: 8415b4c6586be6044bf52750d45bdcc624131392 $
#

package require UTF
package require UTF::MpduStats
package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart

#package provide UTF::Test::ampdusweep 2.0

namespace eval UTF::Test::ampdusweep {

    proc ampdu_release {sta val} {
	$sta wl ampdu_release $val
	$sta wl reassoc [$sta wl bssid]
	UTF::Sleep 5
    }

    proc ampdu_mpdu {sta val} {
	$sta wl ampdu_mpdu $val
    }

    proc sweep {SRC SNK key code} {

	upvar {} {}

	lappend key $SRC $SNK

	# Sanitize for use as a filename
	regsub -all {[/<>]} $key "." plotkey

	set title "$SRC->$SNK ampdurelease Chanspec $(chanspec)"

	set t [format {%g} [expr {$(s) * $(i)}]]

	set file [file nativename \
	       [file join [file dir $UTF::Logfile] \
		    [file rootname $UTF::Logfile].$plotkey]]

	set tputfile "${file}.csv"
	set ctrlfile "${file}.gpc"
	set plotfile_sm "${file}_sm.png"
	set plotfile "${file}.png"

	set collector [UTF::MpduStats init $SRC $SNK $file]

	set ix 0
	set tputs {}
	set xlist {}
	set tputfd [open $tputfile w]

	foreach val $(val) {

	    lappend xlist $val

	    {*}$code $val

	    # Clear stats
	    $collector clear
	    set cmd [list UTF::Multiperf [list $SRC $SNK] \
			 -b $(b) -i $(i) -t $t -l 128k \
			 -w $(window) -noping -callback {
			     UTF::Sleep $(i); $collector clear
			 }]

	    foreach ret [eval $cmd] {
		puts $tputfd "$ix, $ret"
	    }
	    flush $tputfd

	    $collector collect $val

	    incr ix

	}
	close $tputfd

	set xtics ""
	set i 0
	set interval [expr {[llength $xlist] / 20}]
	foreach a $xlist {
	    if {$interval == 0 || $i % $interval == 0} {
		lappend xtics "'$a' $i"
	    }
	    incr i
	}
	lappend xtics "'$a' [expr {$i-1}]"

	# Plot
	set G [open $ctrlfile w]
	puts $G {set datafile separator ","}

	# thumbnails
	if {[UTF::GnuplotVersion] >= 5.0} {
	    puts $G {set colors classic}
	}
	if {[UTF::GnuplotVersion] > 4.0} {
	    puts $G {set terminal png transparent size 62,13 medium}
	    puts $G {set tmargin 0.1; set bmargin 0}
	    puts $G {set lmargin 0; set rmargin 0.1}
	} else {
	    puts $G {set terminal png transparent; set size 0.15,0.08}
	    # Gnuplot 4.0 loops if margins are zero - use mogrify below
	}
	puts $G {unset y2tics}
	puts $G {unset ytics}
	puts $G {unset xtics}
	puts $G {unset key}
	puts $G {unset border}
	puts $G "set output '$plotfile_sm'"
	puts $G "\
plot '$tputfile' using 1:2 axes x1y2 smooth unique notitle ls 1"

	puts $G {reset}
	puts $G {set terminal png notransparent size 1280,1280 truecolor}
	puts $G "set output '$plotfile'"

	puts $G {set key above}
	puts $G "set multiplot title \"$title\""
	puts $G "set origin 0,0.59; set size 1.0,0.4"
	puts $G "set xtics ([join $xtics ,])"
	puts $G {set y2tics}
	puts $G {set ytics nomirror}

	# Tput
	puts $G "\
plot '$tputfile' using 1:2 axes x1y2 title 'Tput' ls 1, \
'' using 1:2 axes x1y2 smooth unique notitle ls 1"
	puts $G {set yrange [*:*]}
	puts $G {set y2range [*:*]}

	puts $G [$collector plotscripts]

	puts $G {unset multiplot}
	puts $G {quit}
	close $G

        # Run gnuplot on plot file.  Catch is needed because gnuplot
        # often writes to stderr.  Report any output even if we think
        # it was ok.
	catch {exec $::UTF::Gnuplot "$ctrlfile"} ret
	UTF::Message WARN "gnuplot" $ret

	$collector destroy

	set ret "html:<a href=\"[UTF::URI $plotfile]\">[UTF::ThumbData $plotfile_sm]</a>"
	return $ret
    }
}

UTF::Test ampdusweep {AP STA args}  {

    # Pull out dut option since we need it before we can fetch the
    # rest of the arguments.
    if {[set dix [lsearch -exact $args -dut]] >= 0} {
	set vix [expr {$dix + 1}]
	set (dut) [lindex $args $vix]
    } else {
	set (dut) $STA
    }

    # If FBDefault is set, and devices support it, enable fb
    if {[info exists ::UTF::FBDefault] &&
	![$STA cget -noframeburst] && ![$AP cget -noframeburst]} {
	set fbdefault 1
    } else {
	set fbdefault 0
    }

    UTF::Getopts [subst {
	{dut.arg "$(dut)" "dut"}
	{i.arg 0.3 "Interval"}
	{s.arg 3 "Samples"}
	{var.arg "ampdu_mpdu" "variable"}
	{val.arg "32-64" "values"}
	{chanspec.arg "36/80" "Chanspec"}
	{security.arg "open" "Security"}
	{key.arg "" "Key"}
	{loop.arg 1 "Loop"}
	{msg.arg "" "Message"}
	{perfcache.arg "" "Performance Cache"}
	{history.arg 30 "Performance History"}
	{nocache "Don't update performance cache"}
	{b.arg "[$(dut) cget -udp]" "UDP data rate. (0 for TCP)"}
	{frameburst.arg "$fbdefault" "Use frameburst"}
	{symmetric.arg 0 "Symmetric - only test one way"}
    }]

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }
    set (val) [UTF::Numexpand $(val)]

    if {$(msg) eq ""} {
	set (msg) $(dut)
    }

    switch $(var) {
	ampdu_mpdu {
	    set code [list ampdu_mpdu $STA]
	}
	ampdu_release {
	    set code [list ampdu_release $STA]
	}
	default {
	    error "Unknown tunable: $(var)"
	}
    }

    set branch [$(dut) branchname]
    set key [concat $branch $(var) "ch=$(chanspec)" $(key)]

    append (msg) ": $(chanspec)"

    if {$(frameburst)} {
	lappend key "fb"
	append (msg) ": FB"
    }

    set setup 0

    UTF::Try "$(msg): $(var): WLAN->LAN" {
	ConnectAPSTA $AP $STA -security $(security) -chanspec $(chanspec)

	$AP wl frameburst $(frameburst)
	$STA wl frameburst $(frameburst)

	set (window) [$STA tcpautowindow]

	set setup 1

	sweep $STA $AP $key $code
    }

}

