#!/bin/env utf
# -*-tcl-*-
#
# UTF test lib to quickly discover the range for:
# 1. throuput when traffic is still flowing between an AP and a STA in a BSS without roaming
# 2. rx beacon rate on sta is lower than 20% as expected
# It can be also used to find the attenuation when beacon rate reaches 0 by increasing attenuation steadily. 
# Graph of BeaconRate vs ATTN will be returned. 
# It returns 
#     errorcode 0 if success
#     errorcode 1 if script fails
#     errorcode 4 if controlchart reports LOW|HIGHT|WIDE
# 
#
# Written by: Robert J. McMahon/Jessica (Yaqin) Zhu April 2015
#
# $Copyright Broadcom Corporation$
#
#
package require UTF
package require UTF::Streams
package require UTF::ControlChart
package require UTF::Streamslib

package provide UTF::Test::RangeDiscovery 2.0

namespace eval UTF::Test {
    variable doloop
}

proc _beaconrate {AP STA} {

    set bcnrate "-1"
    set sleeptime "0.5"
#    set sleeptimes "0.25 0.5 1.0"

    set b0 [$STA wl_counter rxbeaconmbss]

    set time1 [clock clicks -milliseconds]
    UTF::Sleep $sleeptime

    set b1 [$STA wl_counter rxbeaconmbss]

    set time2 [clock clicks -milliseconds]
    set delta [expr {$time2 - $time1}]
    set bcnrate [expr {1000.0/$delta * ($b1 - $b0)}]
    UTF::Message INFO [lindex [info level 0] 0] "rxBeaconRate: [format %.2f $bcnrate]/s"

    return $bcnrate
}

UTF::Test RangeDiscovery {args} {
    UTF::Getopts {
	{s.arg "5" "number of samples for controlchart"}
	{key.arg "" "controlchart key"}
	{history.arg "30" "Performance History"}
	{nocache "Don't update performance cache"}
	{date.arg "" "Image date"}
	{ap.arg "" "AP under test"}
	{sta.arg "" "STA under test"}
	{discovery.arg "beacon" "Edge discovery for beacon or throughput"}
	{startattn.arg "" "Desired STA attenuation to start"}
	{attnstep.arg "0.5" "Minimum stepsize supported by attenuator"}
	{maxattn.arg "95.0" "Maximum attenuation supported by attenuator"}
	{stream.arg "" "Traffic stream between AP and STA"}
	{streamtype.arg "UDP" "TCP/UDP traffic type used during discovery"}
	{direction.arg "down" "Traffic direction up/down"}
	{pktsize.arg "1470" "Packet size"}
	{rate.arg "40M" "Traffic rate"}
	{holdtime.arg "30" "timer to check traffic loss"}
 	{reportinterval.arg "2" "Desired reportinterval during discovery"}
	{bi.arg "10" "beacon interval on ap"}
	{temperature "Run TemperatureConvergence test before discovery"}
	{trafficon "Traffic flows during beacon discovery"}
	{setup "Setup connection between AP and STA"}
	{fixedstep "searching algorithm using fixed step to change attenuation"}
	{training "Return a list of {edgeattn elpsetime peakattn} rather than the range"}
    }

    set range -1
    set procname [namespace tail [lindex [info level 0] 0] ]
    set code 0

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    set bssid "00:00:00:00:00:00"
    if {$(setup)} {
	UTF::Try "Image loading and connection setup" {
	    if {[info exists ::UTF::SetupTestBed]} {
		UTF::Try "Setup testbed" {
		    eval $::UTF::SetupTestBed
		}
	    }
	    foreach apsta "$(ap) $(sta)" {
		UTF::Try "$apsta Find APSTA Image" {
		    UTF::CheckImage $apsta unknown
		}
		UTF::Try "Image loading on $apsta" {
		    $apsta load
		    if {[$apsta hostis router]} {
			$apsta restore_defaults
		    }
		}
		set what [$apsta whatami]
		# Pull out chip info and replace whitespace to
		# make it easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $apsta $ret
		}
		$apsta dbrecord DUT
		set what
	    }
	    UTF::Try "Setting up connection" {
		if {![$(ap) wl -u isup]} {
		    catch {$(ap) wl -u up}
		}
		package require UTF::Test::ConnectAPSTA
		UTF::Test::ConnectAPSTA $(ap) $(sta)
		set bssid [$(ap) wl -u bssid]
	    }

	}
    } else {
	#check that $(ap) and $(sta) are connected
	set apbssid [$(ap) wl -u bssid]
	set stabssid [$(sta) wl -u bssid]
	if { $apbssid ne $stabssid} {
	    UTF::Message FAIL "${procname}:" "$(sta) bssid $stabssid not matching $(ap) bssid $apbssid."
	    error "$range"
	}
    }
    set apattngrp [$(ap) cget -attngrp]
    set staattngrp [$(sta) cget -attngrp]
    set origdutattn 0
    set dutattn 0
    if {$apattngrp eq {} && $staattngrp eq {}} {
	UTF::Message FAIL "${procname}:" "Cannot get either $(sta) or $(ap) attenuation group."
	error "$range"
    }

    if {$(startattn) ne "" && $(startattn) > $(maxattn)} {
	UTF::Message FAIL "${procname}:" "Start attn $(startattn) is out of adjustable range."
	error "$range"
    }

    if {$apattngrp eq {} } {
	set apattn 0
    } else {
	set apattn [lindex [$apattngrp attn?] 0]
    }

    if {$staattngrp ne {} } {
	set DUT $(sta)
	set dutattngrp $staattngrp
	set staattn [lindex [$staattngrp attn?] 0]
	set origdutattn $staattn
	#if {$(startattn) eq "" } {
	#    set (startattn) $staattn
	#}
    } else {
	set DUT $(ap)
	set dutattngrp $apattngrp
	set origdutattn $apattn
	#if {$(startattn) eq ""} {
	#    set (startattn) $apattn
	#}
    }

    UTF::Message INFO "${procname}:" "$dutattngrp original attenuation = $origdutattn"

    #get STA current roam_trigger
    catch {$(sta) wl roam_trigger [$(sta) band]} output
    if {[regexp {\((-[0-9]+)\)} $output dummy origroamtrigger]} {
	UTF::Message INFO "${procname}:" "$(sta) current roam_trigger=$origroamtrigger"
    } else {
	UTF::Message ERROR "${procname}:" "Unable to get $(sta) current roam_trigger."
    }

    #get current AP bi = beacon interval, units is ms
    set origapbi [$(ap) wl -u bi]
    UTF::Message INFO "${procname}:" "$(ap) original beacon interval = $origapbi"

    set origPM [$(sta) wl -u PM]
    if {[regexp {Unsupported} $origPM]} {
	set origPM 0
    }
    UTF::Message INFO "${procname}:" "$(sta) original PM mode = $origPM"

    set traffic $(stream)
    if {[catch {$(stream) cget -rate} RATETXT]} {
	set RATETXT  $(rate)
    }

    #data for plotting grapharray
    array set arrbrate {}
    array set arrattn {}
    if {$(fixedstep)} {
	array set arrbratervr {}
    }

    UTF::Try "Finding $(discovery) attenuation boundary" {


	set t0 [UTF::stream clock]
	#for beacon discovery, we may need to change beacon interval
	if {$(bi) ne $origapbi} {

	    if {$bssid eq "00:00:00:00:00:00"} {
		set bssid [$(ap) wl -u bssid]
	    }
	    set slowassoc [$(sta) cget -slowassoc]
	    $(ap) wl down
	    $(ap) wl -u bi $(bi)
	    $(ap) wl up
	    $(sta) wl join [$(ap) wl ssid]
	    set timer [after [expr {$slowassoc * 1000}] {}]

	    set BSSID ""
	    while {![catch {after info $timer}]} {
		UTF::Sleep 1
		if {[$(sta) wl -u isup]} {
		    catch {$(sta) wl -u bssid} BSSID
		}
		if {$BSSID eq $bssid} {
		    break
		}
	    }
	    if {$BSSID eq "00:00:00:00:00:00"} {
		UTF::Message DEBUG "${procname}:" "$(ap) bssid=$bssid; $(sta) bssid="
		UTF::Message FAIL "${procname}:" "$(sta) is not associated with $(ap)."
		set code 1
		throw FAIL "Range = $range"
	    } else {
		catch {after cancel $timer}
	    }
	}

	#if stream is not passed by caller, define traffic streams
	if {$(stream) == ""} {
	    if {$(direction) eq "up"} {
		if {$(streamtype) eq "TCP"} {
		    set traffic [UTF::stream %AUTO% -rx $(ap) -tx $(sta) -pktsize $(pktsize) \
				     -rate $(rate) -protocol tcp -w 1M -reportinterval $(reportinterval) -name TCP-up]
		} else {
		    set traffic [UTF::stream %AUTO% -rx $(ap) -tx $(sta) -pktsize $(pktsize) \
				     -rate $(rate) -w 1M -reportinterval $(reportinterval) -name UDP-up]
		}

	    } else {

		if {$(streamtype) eq "TCP"} {
		    set traffic [UTF::stream %AUTO% -rx $(ap) -tx $(sta) -pktsize $(pktsize) \
				     -rate $(rate) -protocol tcp -w 1M -reportinterval $(reportinterval) -name TCP-down]

		} else {
		    set traffic [UTF::stream %AUTO% -tx $(ap) -rx $(sta) -pktsize $(pktsize) \
				     -rate $(rate) -w 1M -reportinterval $(reportinterval) -name UDP-down]
		}
	    }

	} else {
	    #if stream is passed by caller, using the reference
	    set originterval $traffic cget -reportinterval
	    $traffic configure -reportinterval $(reportinterval)
	}

	$traffic id

	set apbi [$(ap) wl -u bi]

	$dutattngrp attn $(startattn)
	set dutattn [lindex [$dutattngrp attn?] 0]

	UTF::Message INFO "${procname}:" "$dutattngrp start attenuation = $dutattn"

	#disable STA roamming before discovery
	if {$origroamtrigger ne "-100"} {
	    if {[catch {$(sta) wl roam_trigger -100 [$(sta) band]} err]} {
		UTF::Message ERROR "${procname}:" $err
	    }
	}

	$(sta) wl scansuppress 0
	$(sta) wl PM 0
	$(sta) wl status

	# adding a controlchart
	set key [concat $(discovery) RangeDiscovery $(key) $(ap) $(sta)]
	set sample {}
	UTF::ControlChart CC -s $(s) -key $key \
		-history $(history) \
	        -allowzero true -norangecheck true \
		-title "$(discovery) range discovery" \
		-ylabel "ATTN" -units db
	#UTF::Break "CC controlchart"
	set ret {}

	# Fail criteria for control chart
	set FAILMATCH "HIGH|LOW|WIDE|ZERO"

	if {$(temperature)} {
	    UTF::Try "Test TemperatureConvergence before sampling" {

		package require UTF::Test::TemperatureConvergence
		$traffic start
		set temp [UTF::Test::TemperatureConvergence -ap $(ap) -sta $(sta) -notraffic]
		if {$(discovery) eq "throughput"} {
		    $traffic stop
		}
		return $temp
	    }
	}

	if {$(trafficon)} {
	    if {$(discovery) eq "beacon"} {
		$traffic start
	    }
	}

	#if training is set, then this run will return a list of traing data instead of range to caller
	if {$(training)} {
	    set trainingsets {}
	}
	for {set i 1} {$i <= $(s)} {incr i} {
	    set range -1
	    $(sta) wl -u dump rssi
	    switch -nocase $(discovery) {
		"throughput" {
		    $traffic start
		    $traffic linkcheck -now

		    if {[catch {$traffic linkcheck -txstrict -now} err]} {
			$traffic stop
			$(sta) wl -u dump rssi
			UTF::Message ERROR "${procname}:" $err
			UTF::Message FAIL "${procname}:" "Check RF: Traffic not 100% received at start of $(discovery) discovery."
			set code 1
			throw FAIL "Range = $range"
		    }

		    set incrfactor 1
		    set lastworkingattn 0
		    set lastnotworkingattn $(maxattn)
		    set stepsize [expr $(attnstep) * [expr (1 << ($incrfactor -1))]]

		    #wait for device to be stable before sampling
		    UTF::Sleep 1

		    while {![catch {$traffic linkcheck -txstrict -now}]} {
			if {[catch {$dutattngrp incr +$(attnstep)}]} {
			    break
			}
		    }
		    $dutattngrp incr -$(attnstep)
		    $traffic stop


		    while {[lindex [$dutattngrp attn?] 0] >= 0} {
			# Force a new socket
			$traffic incr_dstport
			$traffic start
			if {![catch {$traffic linkcheck -now} err]} {
			    set aid [after [expr {$(holdtime) * 1000}] {}]
			    while {![catch {after info $aid}] && ![catch {$traffic linkcheck -strict -now}]} {
				UTF::Sleep 0 quiet
			    }
			    # If aid expired this is a lossless stream
			    if {[catch {after info $aid}]} {
				UTF::Message INFO "${procname}:" "Strict Linkcheck timer expired, and the stream is lossless."
				$traffic stop
				break
			    }
			} else {
			    UTF::Message ERROR "${procname}:" $err
			    set code 1
			}
			catch {after cancel $aid}
			$dutattngrp incr -$(attnstep)
			$traffic stop
		    }

		}
		"beacon" {
		    set edge [expr {2*$origapbi/$(bi)}]
		    set closestrssi [$(sta) wl rssi]
		    #wait for device to be stable before sampling
		    UTF::Sleep 1
		    UTF::Message INFO "${procname}:" "$(sta) rssi at start of discovery: $closestrssi"

		    set t1 [expr {[UTF::stream clock] - $t0}]

		    set arrattn($t1) $dutattn
		    set bcnrate [_beaconrate $(ap) $(sta)]

		    set arrbrate($t1) $bcnrate

		    if { $bcnrate <= 0} {
			UTF::Message FAIL "${procname}:" "Check RF: No beacons at start of $(discovery) discovery."
			set code 1
			throw FAIL "Range = $range, beaconrate=[format %.2f $bcnrate] at start rssi $closestrssi"
		    }
		    set err 0
		    if {$(fixedstep)} {
			set stepsize $(attnstep)
			while {![catch {$dutattngrp incr $stepsize} err]} {
			    set dutattn [lindex [$dutattngrp attn?] 0]
			    $(sta) wl rssi
			    set t1 [expr {[UTF::stream clock] - $t0}]
			    set arrattn($t1) [expr {$dutattn + $apattn}]
			    set bcnrate [_beaconrate $(ap) $(sta)]
			    set arrbrate($t1) $bcnrate
			    set arrbratervr([expr {$dutattn + $apattn}]) $bcnrate
			    if { $bcnrate <= 0 } {
				break
			    }
			}
		    } else {
			set farthestrssi -1
			set lastworkingattn $dutattn
			set lastnotworkingattn $(maxattn)
			set f [int [floor [expr {($lastnotworkingattn - $dutattn)/2}]]]
			set r  [int [round [expr {($lastnotworkingattn - $dutattn)/2}]]]
			if { $f == $r} {
			    set stepsize $f
			} else {
			    set stepsize [expr {$f + $(attnstep)}]
			}
			if {$(training)} {
			    set time_elapsed [UTF::stream clock]
			}
			while {![catch {$dutattngrp incr $stepsize} err]} {
			    set dutattn [lindex [$dutattngrp attn?] 0]
			    set t1 [expr {[UTF::stream clock] - $t0}]
			    set bcnrate [_beaconrate $(ap) $(sta)]
			    set arrbrate($t1) $bcnrate
			    set arrattn($t1) $dutattn

			    if { $bcnrate > $edge} {
				if { [expr {$lastnotworkingattn - $dutattn}] <= $(attnstep)} {
				    if {$lastnotworkingattn == $(maxattn)} {
					UTF::Message FAIL "${procname}:" \
					    "Beacon rate not dropping when reaching maxattn $(maxattn) of attenuator."
					set code 1
					throw FAIL "Range = $range; max attenuator value $(maxattn) reached"
				    }
				    UTF::Message INFO "${procname}:" \
					"Beacon rate=[format %.2f $bcnrate];lastnotworkingattn=$lastnotworkingattn; current attn=$dutattn EDGE"

				    set farthestrssi [$(sta) wl rssi]
				    break
				}

				set farthestrssi [$(sta) wl rssi]
				if {$dutattn > $lastworkingattn} {
				    set lastworkingattn $dutattn
				}
				UTF::Message INFO "${procname}:" "Last working attn=$lastworkingattn, stepsize=$stepsize"
			    } else {
				if {$(training)} {
				    if {![info exists peak]} {
					set peak $dutattn
				    } else {
					if {$dutattn > $peak} {
					    set peak $dutattn
					}
				    }
				}
				if { $lastnotworkingattn > $dutattn } {
				    set lastnotworkingattn $dutattn
				}

				UTF::Message INFO "${procname}:" "Beacon rate=[format %.2f $bcnrate] at current attn $dutattn, backoff."
				UTF::Message INFO "${procname}:" "Last not working attn=$lastnotworkingattn, stepsize=$stepsize"

				$dutattngrp incr -$stepsize
				set dutattn [lindex [$dutattngrp attn?] 0]

				set t1 [expr {[UTF::stream clock] - $t0}]
				set bcnrate [_beaconrate $(ap) $(sta)]
				set arrbrate($t1) $bcnrate
				set arrattn($t1) $dutattn

				if {[expr {$lastnotworkingattn - $dutattn}] <= $(attnstep) } {
				    UTF::Message INFO "${procname}:" "Converged: EDGE"
				    #backoff minimum step to make sure receiving beacon rate on sta is high enough 
				    #to keep the connection
				    if {$bcnrate <= $edge } {
					UTF::Message INFO "${procname}:" \
					    "Beacon rate=[format %.2f $bcnrate] < $edge after backing off to $dutattn."
					$dutattngrp incr -$(attnstep)
					set dutattn [lindex [$dutattngrp attn?] 0]
					set t1 [expr {[UTF::stream clock] - $t0}]
					set bcnrate [_beaconrate $(ap) $(sta)]
					set arrbrate($t1) "$bcnrate"
					set arrattn($t1) "$dutattn"
				    }
				    set farthestrssi [$(sta) wl rssi]
				    break
				}
				if {$bcnrate <= $edge && $dutattn <= $lastworkingattn} {

				    UTF::Message INFO "${procname}:" \
				    "Beacon rate [format %.2f $bcnrate] < $edge after backing off to $dutattn."
				    $dutattngrp incr -$(attnstep)
				    set dutattn [lindex [$dutattngrp attn?] 0]
				    set t1 [expr {[UTF::stream clock] - $t0}]
				    set bcnrate [_beaconrate $(ap) $(sta)]
				    set arrbrate($t1) "$bcnrate"
				    set arrattn($t1) "$dutattn"

				    if {$bcnrate <= $edge} {

					UTF::Message INFO "${procname}:" \
					    "Beacon rate [format %.2f $bcnrate] < $edge after backing off to $dutattn."
					$dutattngrp incr -$(attnstep)
					set dutattn [lindex [$dutattngrp attn?] 0]
					set t1 [expr {[UTF::stream clock] - $t0}]
					set bcnrate [_beaconrate $(ap) $(sta)]
					set arrbrate($t1) "$bcnrate"
					set arrattn($t1) "$dutattn"
				    }
				    set farthestrssi [$(sta) wl rssi]
				    UTF::Message INFO "${procname}:" \
					"Beacon rate [format %.2f $bcnrate] after backing off to $dutattn: EDGE"
				    break
				}
			    }
			    if {$bcnrate <= [expr {2*$edge}]} {
				set stepsize $(attnstep)
			    } else {
				set f [int [floor [expr {($lastnotworkingattn - $dutattn)/2}]]]
				       set r  [int [round [expr {($lastnotworkingattn - $dutattn)/2}]]]
				if { $f == $r} {
				    set stepsize $f
				} else {
				    set stepsize [expr {$f + $(attnstep)}]
				}
				unset r
				unset f
			    }
			    if {$stepsize == 0} {
				if {[expr {($lastnotworkingattn - $dutattn)/2}] >= $(attnstep)} {
				    set stepsize $(attnstep)
				} else {
				    #$(attnstep) is the minimum step allowed to change in attenuator
				    set farthestrssi [$(sta) wl rssi]
				    UTF::Message INFO "${procname}:" "stepsize < $(attnstep) minimum allowed step: EDGE"
				    break
				}
			    }
			}

                        #UTF::Message INFO "${procname}:" "err =${err}end"
                        # in some attenuator, even though it returns 0 \
                        # after setting attenuation, the err is set to empty string
                        # so adding check for empty string as well
                        if {$err ne 0 && $err ne ""} {
                            UTF::Message FAIL "${procname}:" "err=$err"
			    set code 1
			    throw FAIL "Range = $range, err = $err"
			}

			UTF::Message INFO "${procname}:" \
			    "$(sta) rxbeacon rate = [format %.2f $bcnrate]; farthestrssi = $farthestrssi"
			$(sta) wl status
			$(sta) wl -u dump rssi
			#$(ap) wl -u dump phycal
			#$(ap) wl -u curpower
		    }
		}
		default {
		    UTF::Message ERROR "${procname}:" "Invalid option $(discovery). Expecting throughput or beacon."
		    set code 1
		    throw FAIL "Range = $range; invalid option $(discovery)"
		}
	    }

	    set DUTEDGEATTN [lindex [$dutattngrp attn?] 0]

	    if {$staattngrp ne {} } {
		set range [expr $DUTEDGEATTN + $apattn]
	    } else {
		set range $DUTEDGEATTN
	    }
	    UTF::Message INFO "${procname}:" "Controlchart #sample $i: range = $range; DUTEDGEATTN = $DUTEDGEATTN"
	    lappend samples $range


	    if {$(startattn) eq ""} {
		$dutattngrp attn $origdutattn
	    } else {
		$dutattngrp attn $(startattn)
	    }
	    set t1 [expr {[UTF::stream clock] - $t0}]
	    set dutattn [lindex [$dutattngrp attn?] 0]
	    set arrattn($t1) "$dutattn"
	    if {$(training)} {
		set time_elapsed [format %.2f [expr {[UTF::stream clock] - $time_elapsed}]]
		lappend trainingsets "$range $time_elapsed $peak [format %.2f $bcnrate]"
		UTF::Message DEBUG "${procname}:" "trainingsets=$trainingsets"
	    }
	}

	lsort $samples
	set range [lindex $samples 0]; #minimum value of all samples
	set ret [CC addsample [UTF::MeanMinMax $samples]]

	set title "BeaconRate vs ATTN"
	if {$(trafficon)} {
	    set title "$title with traffic"
	}
	set xlabel "Time (second)"
	set ylabel "BeaconRate (beacons per second)"
	set htmltxt "brate vs attn overlay"
	set yrange 1400/$apbi
	set plot [UTF::Streamslib::grapharray arrbrate -overlay arrattn \
		      -yrange "0:${yrange}" -title $title -style "points" -pointtype 7 -htmltxt $htmltxt \
		     -xlabel $xlabel -ylabel $ylabel -append]
	if {$(fixedstep)} {
	    set rvr [UTF::Streamslib::grapharray arrbratervr \
			 -yrange "0:${yrange}" -title $title -style "points" -pointtype 7 -htmltxt "BeaconRate RvR" \
			 -xlabel "ATTN" -ylabel $ylabel -append] 
	}
	if {[regexp $FAILMATCH $ret]} {
	    UTF::Message FAIL "" $ret
	    set code 4
	} else {
	    UTF::Message PASS "" $ret
	}
	set ret [CC plotcontrolchart $ret]
	UTF::Message DEBUG "${procname}:" "samples = $samples; code = $code; range = $range"
	if {!$code} {
	    if {$(fixedstep)} {
		return "$ret $plot $rvr"
	    } else {
		return "$ret $plot"
	    }
	} else {
	    if {$(fixedstep)} {
		throw FAIL "$ret $plot $rvr"
	    } else {
		throw FAIL "$ret $plot"
	    }
	}
    } finally {

	$dutattngrp attn $origdutattn
	#UTF::Message INFO localhost "Resetting $DUT Attngrp to original value $origdutattn"

	$(sta) wl roam_trigger $origroamtrigger [$(sta) band]
	#UTF::Message INFO localhost "Resetting $(sta) roam_trigger to original value $origroamtrigger"

	$(sta) wl PM $origPM

	if {$(bi) ne $origapbi} {

	    set bssid [$(ap) wl -u bssid]
	    set slowassoc [$(sta) cget -slowassoc]
	    $(ap) wl down
	    $(ap) wl -u bi $origapbi
	    $(ap) wl up
	    $(ap) wl -u bi

	    $(sta) wl join [$(ap) wl ssid]
	    set timer [after [expr {$slowassoc * 1000}] {}]

	    set BSSID ""
	    while {![catch {after info $timer}]} {
		UTF::Sleep 1
		if {[$(sta) wl -u isup]} {
		    catch {$(sta) wl -u bssid} BSSID
		}
		if {$BSSID eq $bssid} {
		    break
		}
	    }
	    if {$BSSID eq "00:00:00:00:00:00"} {
		UTF::Message DEBUG "${procname}:" "$(ap) bssid=$bssid; $(sta) bssid="
		UTF::Message FAIL "${procname}:" "$(sta) is not associated with $(ap) after cleanup."
		set code 4
	    } else {
		catch {after cancel $timer}
	    }
	}

	# if stream is not passed as a parameter, destroy the object;
	# otherwise, keep it as is and recover the original reportinterval
	if {$(stream) != ""} {
	    $traffic configure -reportinterval $originterval
	} else {
	    catch {$traffic destroy}
	}

	array unset arrbrate
	array unset arrattn
	if {$(fixedstep)} {
	    array unset arrbratervr
	}

    }

    if {!$(training)} {
	#return error code and last result to caller
	return -code $code $range
    } else {
	return $trainingsets
    }

}

