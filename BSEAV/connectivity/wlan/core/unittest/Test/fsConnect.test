#!/bin/env utf
# -*-tcl-*-

#
# fsConnect.test
# Streams-based test script for testing 10 STAs communicating with 1 soft AP
# Need to add handler for STAs that aren't up
# Need a handler for DHD drivers that are already loaded
#

package require UTF
package require UTF::Test::Scan
package require UTF::Test::ConnectAPSTA
package require UTF::ControlChart

package provide UTF::Test::fsConnect.test 

UTF::Test fsConnect {args} {

    UTF::Getopts {
    {sta.arg "4325sdio" "Sta list name"}
    {ap.arg "4704/4318" "AP name"}
    {apdate.arg "" "AP Image date"}
    {branch.arg "auto" "Branch override"}
	{chanspec.arg "" "Test Channel"}
	{date.arg "" "Image date"}
	{email.arg "" "Email Address"}
	{logdir.arg "" "Log directory override"}
	{noapload "Don't load images"}
	{nosetup "No Setup"}
	{nostaload "Don't reload STA drivers"}
	{nostareload "Don't even reload STA drivers"}
	{security.arg "" "Security Type"}
	{title.arg "" "Title"}
	}
    
	set Router  $(ap)
	set STA [lindex $(sta) 0]
	
	 if {$(date) ne ""} {
	  set date $(date)
	
	  foreach S $(sta) {
	    $S configure -date $(date)
	  }
		unset S
      } else {
	    set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	    # Clean up whitespace (RH9 compat)
	    regsub -all {\s+} $date {} date
      }
	
	# Compact build list for title
    set build [UTF::BuildTitle $(sta)]

    if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}

	if {[regexp {(\d+sd)} $Router - c]} {
	    append (title) " with $c AP"
	}
	}
	
	set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

    proc systime {STA} {
	catch {
	    $STA rexec {vmstat 1 6 | awk 'FNR>3{print $14}'}
	}
    }
	
	
	UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]
	 
	
# If necessary, override the config file log directory setting.
if {$(logdir) != ""} {
      set UTF::SummaryDir $(logdir)
      UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }
	
    if {!$(noapload)} {
	    UTF::Try "$Router: Find Router Image" {
		UTF::CheckImage $Router $date unknown
	    }
    
	# Load the AP
	UTF::Try "$Router: Load Image" {
		if {[$Router hostis Router Vx BSDAP DSL Airport]} {
		    if {[catch {$Router lan ifconfig [$Router lan cget -ipaddr]}]} {
			$Router lan ifconfig 192.168.1.50
		    }
		}
		set ver [$Router load]
		set what [$Router whatami]
		# Pull out chip info and replace whitespace to make it
		# easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $Router $ret
		}
		return "$what $ver"
	    }
	}
	
	# Load and associate each member of stalist...one STA at a time
	foreach STA $(sta) {
		
	set phyname ""

	if {$(branch) eq "auto"} {
	    set branch [$STA branchname]
	} else {
	    set branch $(branch)
	}
	
    # Find images
	if {!$(nostaload)} {
	    UTF::Try "$STA Find STA Image" {
		UTF::CheckImage $STA $date unknown
	    }

	 if {!$(nosetup)} {
	    if {$(nostaload)} {
		if {!$(nostareload)} {
		    UTF::Try "$STA reload" {
			$STA reload
		    }
		}
	    } else {
		UTF::Try "$STA load" {
		    $STA load
		}
	    }
    	      	
          UTF::Try "$STA defaults" {

		$STA services stop
		  catch {$STA wl msglevel +error +assoc}
		  if {![$STA cget -nomimo_bw_cap]} {
		     catch {$STA wl down}
		     # Enable 40 in 2.4, if available.
		     # Doesn't work for LMAC since LMAC is never "down"
		     $STA wl -u mimo_bw_cap 1
		     $STA wl up
		     UTF::Sleep 1
		  }
		}
	    
	    UTF::Try "$STA wl ver" {    	  
          # make sure STA is ready before we associate it to the AP
          # Add an error check (what value does this return, if any?)
          $STA wl ver
          }

          UTF::Try "$STA whatami" {
            set what [$STA whatami]
		  }
		  
          if {!$(nostaload)} {
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		}
		set what
	    }
          
          if {!$(nostaload) && [set reclaim [$STA reclaim]]} {
		UTF::Try "$STA: Reclaim" {
#		    if {$(bin) eq ""} {
#			# Only do MemSave for official builds
#			UTF::MemSave $reclaim "reclaim" [$STA imageinfo]
#		    }
		    # MemChart
		    memchart $reclaim -key [list $branch $STA reclaim] \
			-failonlow
		}
	    }
	    
      # Try to connect the STA to the AP up to 3 times
	  set try_count 1
	  set catch_resp 1  
	  
	  while {$try_count < 4 && $catch_resp != 0} {
	     UTF::Try "Connect the STA $STA to the AP $(ap) Attempt $try_count" {	
	  
	     set catch_resp [catch {ConnectAPSTA $(ap) $STA  -security open -chanspec 3} catch_msg]
		
       # Report each failure to connect the STA to the AP
       if {$catch_resp !=0} {
			UTF::Message ERROR $STA "Join Failed...catch_msg $catch_msg catch_resp $catch_resp"
		}
		
    	incr try_count
		
    	# Give up and return the error_msg after 3 trys
    	if {$try_count==4} {
    		error $catch_msg
    	}
    	
	  }
	  # end of Try "Connect  the STA $STA
	  }
	  # end of try 3 times
	  }
	  # end of if !nosetup
	
        	
    	$Router wl status    
        
     }
     # end of foreach STA
    
    foreach S [list $STA $Router] {
		    if {[$S hostis DHD WinDHD PXA LMAC] &&
			![$S cget -nomaxmem] && [$S cget -console] ne ""} {
			UTF::Try "$S: MaxMem in use" {
			    memchart [$S maxmem] \
				-key [list $branch $S maxmem] \
				-history $(history)
			}
		    }
		}
     
     
     }
    # end of WrapSummary
    }
    # end of fsConnect

