#!/bin/env utf
# -*-tcl-*-

# UTF script to test ZPL and other customer scenarios
# zhuj
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Test::ConnectAPSTA
#package require UTF::Test::ConfigBridge
package require UTF::Streams
package require UTF::Streamslib
package require UTF::wlstats

package provide UTF::Test::TrafficScheduling 2.0
namespace eval UTF::Test::TrafficScheduling {

    proc Reconnect {AP STAS} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	set bssid [$AP wl -u bssid]
	foreach STA $STAS {
	    set res 0
	    $STA wl join [$AP wl -u ssid]
	    set slowassoc [$STA cget -slowassoc]
	    set timer [after [expr {$slowassoc * 1000}] {}]

	    set BSSID [$STA wl -u bssid]
	    while {![catch {after info $timer}]} {
		UTF::Sleep 1
		set BSSID [$STA wl -u bssid]
		if {$BSSID eq $bssid} {
		    set res 1
		    catch {after cancel $timer}
		    break
		}
	    }
	    if {$res} {
		continue
	    }
	    if {$BSSID eq "00:00:00:00:00:00"} {
		UTF::Message INFO "" "$MSG: $AP bssid=$bssid; $STA bssid=$BSSID"
		UTF::Message FAIL "" "$MSG: $STA failed to associate with $AP."
		#throw FAIL "STA $STA failed to associate with AP $AP"
		error "Reconnect failed."
	    }
	}
    }

    #To configure AP/STA features which can be only done with wl down
    #STAS/AP options are for reconnecting associated STAS/AP.
    proc ConfigureDevFeature {DUT FVpairs {STAS {}} {AP ""}} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	if {![llength $FVpairs]} {
	    error "Feature not specified."
	}
	set reconnect 0
	UTF::Message DEBUG "" "$MSG DUT=$DUT FVpairs=$FVpairs"
	foreach {f v} $FVpairs {
	    set f [string tolower $f]
	    if {$f eq "taf"} {
		set f "$f enable"
	    }
	    UTF::Message DEBUG "" "$MSG $f=$v"
	    if {![catch {$DUT wl -u $f} old]} {
		UTF::Message DEBUG "" "$MSG old $f=$old"
		if {$old ne $v} {
		    if {[$DUT wl -u isup]} {
			UTF::Message INFO "" "$MSG shutting down $DUT wl interface to configure $f"
			$DUT wl -u down
			set reconnect 1
		    }
		    $DUT wl -u $f $v
		}
	    } else {
		#if some feature not recognized, print a warning in the log."
		UTF::Message WARNING "" "$MSG $old"
		unset old
	    }
	}
	if {![$DUT wl -u isup]} {
	    $DUT wl -u up
	}
	if {$reconnect && [info exists STAS] && [llength $STAS]} {
	    if {[catch {Reconnect $DUT $STAS} ret]} {
		error "$MSG: $ret"
	    }
	} elseif {$reconnect && [info exists AP] && $AP ne ""} {
	    if {[catch {[Reconnect $AP $DUT] ret}]} {
		error "$MSG: $ret"
	    }
	}
	foreach {f v} $FVpairs {
	    set f [string tolower $f]
	    if {$f eq "taf"} {
		set f "$f enable"
	    }
	    if {![catch {$DUT wl -u $f} new] && $new ne $v} {
		error "$MSG: Failed to set $f to $v."
	    }
	    UTF::Message INFO "" "$MSG new $f=$new"
	}
    }

    #Configure traffic scheduler
    #TAFSchedulers is dictionary
    proc ConfigureTAF {TAFSchedulers} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	UTF::Message DEBUG "" "$MSG: $TAFSchedulers"
	UTF::Try "Configuring $TAFSchedulers" {
	    dict for {AP Schedulers} $TAFSchedulers {
		UTF::Message DEBUG "" "$MSG: [$AP wl -u status]"
		if {![$AP wl -u isup]} {
		    UTF::Sleep 1
		}
		foreach {S STAS} [dict get $Schedulers] {
		    set S [string tolower $S]
		    UTF::Message DEBUG "" "$MSG: AP=$AP TS=$S STAS=$STAS"
		    if {$S ne "na"} {
			set i 0
			foreach STA $STAS {
			    set stamac [$STA macaddr]
			    UTF::Message DEBUG "" "$MSG: $STA macaddr = $stamac."
			    #ebos prio set based on the order of (stas) list
			    if {$S eq "ebos"} {
				incr i
				$AP wl -u taf $stamac $S $i
			    } else {
				$AP wl -u taf $stamac $S
			    }

			    $AP wl -u taf $S
			}
			catch {$AP wl -u taf $S dump}
		    }
		}
	    }
	}
    }

    proc tos2txt {tos} {
	switch -exact [string tolower $tos] {
	    "0x20" {
		return "BK"
	    }
	    "0x00" {
		return "BE"
	    }
	    "0x80" {
		return "VI"
	    }
	    "0xC0" {
		return "VO"
	    }
	    default {
		return "BE"
	    }
	}
    }

    proc txt2tos {txt} {
	switch -exact [string toupper $txt] {
	    "BK" {
		return "0x20"
	    }
	    "BE" {
		return "0x00"
	    }
	    "VI" {
		return "0x80"
	    }
	    "VO" {
		return "0xC0"
	    }
	    default {
		return "0x00"
	    }
	}
    }

    proc _StartStreamExcludeInitLoss {stream} {
	set ret 0
	$stream start
	if {[catch {$stream linkcheck} err]} {
	    UTF::Message ERROR "" "$err"
	    set ret 1
	}
	$stream stats -clear
	return $ret
    }

    proc _CollectMUInfo {AP STAS} {
	$AP wl -u mu_group
	$AP wl -u dump vasip_counters
	foreach STA $STAS {
	    $STA wl -u phy_rssi_ant
	}
	set assoclist [$AP wl -u assoclist]
	regsub -all -nocase "assoclist " $assoclist "" assoclist

	foreach mac $assoclist {
	    $AP wl -u rssi $mac
	}
    }

    #proc/uplevel variables called inside this proc has to use fully qualified name required by event loop processing
    #
    proc _SequentialEventCallback {AP stream t0} {
	UTF::Test::TrafficScheduling::_CollectMUInfo $AP [$stream cget -rx]
	set t1 [format "%.3f" [expr {1.000 * ([UTF::stream clock] - $t0)}]]
	UTF::Message INFO "" "#------------------------------------------------------------------------------------"
	UTF::Message INFO "" "# Sequentially sending streams [$stream cget -name] at $t1                       "
	UTF::Message INFO "" "#------------------------------------------------------------------------------------"
	if {[catch {UTF::Test::TrafficScheduling::_StartStreamExcludeInitLoss $stream} err]} {
	    #set code 1
	    #catch [after cancel $timer]
	    break
	}
	UTF::Sleep 1
	UTF::Test::TrafficScheduling::_CollectMUInfo $AP [$stream cget -rx]
    }

    proc Scheduler {ts args} {
	UTF::Getopts {
	    {rates.arg {} "array of offered rates for UDP streams"}
	    {tos.arg "" "array of tosbits. 0x00:best effort; 0x20:background; 0x80:voice; 0xC0:video"}
	    {protocol.arg "UDP" "traffic type"}
	    {direction.arg "DOWN" "traffic direction: up or down"}
	    {security.arg "open" ""}
	    {connected.arg "0" "If 0, this proc will connect AP and STAs."}
	    {disconnect.arg "1" "If 0, this proc won't shutdown STA wlan interface"}
	    {assocretries.arg "1" "number of tries to do assoc"}
	    {attempts.arg "5" "maximum number of attempts to take the measurements"}
	    {flows.arg "1" "number of iperf sessions between src/dst pair"}
	    {pktsize.arg "1470" "Packet size for UDP BE/BK/VI"}
	    {vopktsize.arg "200" "Packet size for UDP VO"}
	    {tcpwsize.arg "4M" "TCP window size"}
	    {w.arg "1M" "UDP buffer size"}
	    {vrate.arg "15M" "EBOS traffic rate for stas not specified in rates"}
	    {rate.arg "1G" "Traffic rate for non-ebos for stas not specified in rates"}
	    {vstresser "add ebos stresser for multiple streams with ebos"}
	    {modes.arg "" "STA Object mode (vhtmode | nmode) value"}
	    {g.arg "" "Attenuating group/sta while traffic on"}
	    {warmup.arg "0"  "Send traffic before testing to collect info"}
	    {maxattn.arg "90" "Maximum attnuation allowed by attenuator"}
	    {attnstep.arg "1" "Attenuation step"}
	    {attntimeslices.arg "60" "# of timeslices for attenuation test, time for each timeslice = attninterval"}
	    {attninterval.arg "3" "Attenuating interval in seconds"}
	    {holdtime.arg "20" "Sending traffic for 20 seconds for non-attenuating test"}
	    {reportinterval.arg "0.1" "Desired iperf reportinterval"}
	    {delays.arg "" "Format: pair of STA object and time in seconds to delay the start of traffic"}
	    {stats2plot.arg "" "What straffic stream stats to be plotted"}
	    {roamtrigger.arg "-100" "roamtrigger value"}
	    {fb.arg "1" "fb on/off"}
	    {atf.arg "1" "ATF on/off"}
	    {notaf "not to test TAF"}
	    {pktqstats "collect pktstat"}
	    {callback.arg "" "This callback is called before traffic start and after traffic stop"}
	    {mu.arg "1" "If 0, won't collect MU related info during test"}
	    {aggregate.arg "0" "whether to collect aggreate stats"}
	    {graphsize.arg "1024,1536" "Graph size"}
	    {debug.arg "0" "debug mode"}
	    {key.arg "" ""}
	}
	upvar $(rates) myrates
	upvar $(tos) mytos
	#upvar $(ch) chanspec
	set MSG [namespace tail [lindex [info level 0] 0]]

	set res 0
	array set traffic {}
	set total_stas {}
	set total_streams {}
	set ckey [list $(key) $(security) $(protocol)]
	if {$(g) ne ""} {
	    set holdtime [expr {$(attninterval) * $(attntimeslices)}]
	    set origattn [lindex [$(g) attn?] 0]
	} else {
	    set holdtime $(holdtime)
	}
	# Define gnuplopt style values to use. See gnuplot manual for more details of parameters.
	set lt0 0 ;# line type 0 - dashed grey
	set lt1 1 ;# line type 1 - solid light red
	set lt2 2 ;# line type 2 - olid light green
	set lt3 3 ;# line type 3 - solid light blue
	set lt4 4 ;# line type 4 - solid light purple
	set lt5 5 ;# line type 5 - solid aqua
	set lt6 6 ;# line type 6 - solid brown
	set lt7 7 ;# line type 7 - solid yellow
	set lt8 8 ;# line type 8 - solid dark blue
	set lt9 9 ;# line type 9 - solid gold
	set lt10 10 ;# line type 10 - solid dark green
	set lt11 11 ;# line type 11 - solid dark purple
	set lt12 12 ;# line type 12 - solid dark brown
	set lt13 13 ;# line type 13 - solid light pink
	set lt14 14 ;# line type 14 - solid lime green
	set lt15 15 ;# line type 15 - solid grey blue
	set lt154 154 ;# line type 154 - solid orange

	set linetypes [list $lt1 $lt2 $lt3 $lt4 $lt5 $lt6 $lt7 $lt8 $lt9 $lt10 $lt11 $lt12 $lt13 $lt14 $lt15 $lt154]
	UTF::Try "$(protocol): \{$ts\}" {
	    catch {UTF::stream allstreams destroy}
	    set lrssi {}
	    UTF::Message DEBUG "" "ts=$ts"
	    dict for {AP Schedulers} $ts {
		UTF::Message DEBUG "" "AP=$AP; Schedulers=$Schedulers"
		set ckey [concat $ckey $AP [$AP branchname] [$AP cget -brand] [$AP cget -host]]
		set ap_features ""
		foreach {S STAS} [dict get $Schedulers] {
		    UTF::Message DEBUG "" "S=$S; STAS=$STAS"
		    set res 0

		    #configure AP features before test
		    if {[string tolower $S] ne "na"} {
			set ap_features "taf 1"
		    }
		    append ap_features " atf $(atf)"

		    if {$ap_features ne ""} {

			UTF::Try "Configuring \($ap_features\)" {
			    UTF::Message DEBUG "" "$MSG: $ap_features"
			    if {[catch {ConfigureDevFeature $AP $ap_features} err]} {
				set res 1
				error $err
			    }
			}
		    }
		    if {[llength $(modes)]} {
			foreach {STA m v} $(modes) {
			    lappend origmodelist "$STA $m [$STA wl -u $m]"
			    UTF::Try "Configuring $STA $m $v" {
				UTF::Message DEBUG "" "$MSG: $STA $m $v"
				if {[catch {ConfigureDevFeature $STA "$m $v" {}} err]} {
				    set res 1
				    error $err
				}
			    }
			}
			unset m v
		    }
		    if {$res} {
			UTF::Message ERROR "" "$MSG: $err."
			exit $res
		    }
		    foreach STA $STAS {
			set res 0
			set err ""
			UTF::Try "Configuring Streams" {
			    for {set j 1} {$j <= $(flows)} {incr j} {
				if {[regexp -nocase "DOWN" $(direction)]} {
				    set cmd {UTF::stream %AUTO% -rx $STA -tx $AP -reportinterval $(reportinterval)}
				    set cmd [join [list $cmd -name $AP-${STA}-$(direction)-${j} -linkcheckfailcount 5]]
				}
				if {[regexp -nocase "UP" $(direction)]} {
				    set cmd {UTF::stream %AUTO% -rx $AP -tx $STA -reportinterval $(reportinterval)}
				    set cmd [join [list $cmd -name ${STA}-$AP-$(direction)-${j} -linkcheckfailcount 5]]
				}
				set r $(rate)
				UTF::Message INFO "" "$MSG: (rate)=$(rate); (rates)=[array get myrates]"
				if {[lsearch [array names myrates] $STA] ne "-1"} {
				    UTF::Message INFO "" "$MSG: \[$j\] myrates($STA)=$myrates($STA)"
				    set r [lindex $myrates($STA) [expr {$j -1}]]
				}
				if {[string toupper $S] eq "EBOS"} {
				    #set ebos as video traffic
				    set r $(vrate)
				    set cmd [join [list $cmd -tos "0x80"]]
				    #only use the second ebos stream as stresser if there are more than one ebos clients
				    if {$(vstresser)} {
					if {![info exists vstresser_enabled]} {
					    set vstresser_enabled 0
					} elseif {!$vstresser_enabled} {
					    set r $dr
					    set vstresser_enabled 1
					}
				    }
				}
				if {[string toupper $(protocol)] eq "TCP"} {
				    set cmd [join [list $cmd -protocol [string tolower $(protocol)]]]
				    set cmd [join [list $cmd -w $(tcpwsize)]]
				    if {[string toupper $S] eq "EBOS"} {
					set cmd [join [list $cmd -rate $r]]
				    } else {
					set r -1
				    }
				} else {
				    set cmd [join [list $cmd -w $(w)]]
				}
				set pktsize $(pktsize)
				if {[array size mytos]} {
				    if {[lsearch [array names mytos] $STA] ne "-1"} {
 					UTF::Message INFO "" "mytos($STA)=$mytos($STA)"
					if {$j <= [llength $mytos($STA)]} {
					    set t [lindex $mytos($STA) [expr {$j - 1}]]
					} else {
					    set t [lindex $mytos($STA) 0]
					}
					if {[regexp {BE|BK|VI|VO} $t]} {
					    set cmd [join [list $cmd -tos [txt2tos $t]]]
					}
					if {[regexp {VO} $t]} {set pktsize $(vopktsize)}

				    }
				}

				if {[string toupper $(protocol)] eq "UDP"} {
				    set cmd [join [list $cmd -rate $r -pktsize $pktsize]]
				}
				UTF::Message INFO "" "traffic cmd=$cmd"
				UTF::Message INFO "" "rate = $r"

				set traffic($STA,$j) [eval $cmd]

				UTF::Message INFO "" "traffic($STA,$j)=$traffic($STA,$j)"
				append retstr "\[${j}\]:[$traffic($STA,$j) cget -tx]->[$traffic($STA,$j) cget -rx]: $S $r [$traffic($STA,$j) cget -tos] "
				$traffic($STA,$j) id
				if {$(debug)} {
				    UTF::stream logginglevel "DEBUG"
				}
				lappend total_streams $traffic($STA,$j)
			    }
			    return $retstr
			}
			if {[lsearch $total_stas $STA] eq "-1"} {
			    lappend total_stas $STA
			}

			UTF::Message INFO "" "$MSG: total_stas=$total_stas"
			UTF::Try "$AP<->$STA FB=$(fb)" {
			    $STA wl -u roam_trigger $(roamtrigger) all
			    if {!$(connected)} {
				for {set n 1} {$n <= $(assocretries)} {incr n} {
				    if {[catch {UTF::Test::ConnectAPSTA $AP $STA -security $(security)} err]} {
					UTF::Message ERROR "" "$err after $n tries"
					if {[catch {$STA wl_escanresults} ret_escanresults]} {
					    UTF::Message ERROR "" "$ret_escanresults"
					}
					if {$n == $(assocretries)} {
					    set res 1
					} else {
					    continue
					}
				    } else {
					break
				    }
				}
				if {$res} {
				    set connection_failure($STA) 1
				    throw FAIL "STA $STA failed to connect to AP $AP after $(assocretries) attempts."
				}
			    }

			    $STA wl -u status
			    $AP wl -u status
			    $AP wl -u assoclist

			    #set frameburst after any AP restarts
			    if {$(fb) ne [$AP wl -u frameburst]} {
				$AP wl -u frameburst $(fb)
			    }
			    if {$(fb) ne [$STA wl -u frameburst]} {
				$STA wl -u frameburst $(fb)
			    }
			    $STA wl -u dump rssi
			    set rssi [$STA wl -u rssi]
			    lappend lrssi "$STA $rssi"
			    return "$STA RSSI=$rssi $STA FB=[$STA wl -u frameburst] $AP FB=[$AP wl -u frameburst]"
			}
			if {[array exists connection_failure]} {
			    UTF::Message INFO "" "Exiting due to connection failure: [array get connection_failure]"
			    exit 1
			}
			if {$(pktqstats)} {
			    $STA wl msglevel +time
			    set pktqstats(${STA}) [UTF::wlstats::pktqstat %AUTO% -ap $AP -sta $STA]
			    set pktqstats($AP) [UTF::wlstats::pktqstat %AUTO% -ap $AP -common 1]
			    $AP wl msglevel +time
			    foreach index [array names pktqstats] {
				$pktqstats($index) sample
			    }
			}
		    }
		    #eof loop foreach STA
		}
		#eof loop foreach {S STAS}
	    }
	    #eof loop foreach AP

	    if {!$(notaf)} {
		ConfigureTAF $ts
	    }
	    return "RSSI: $lrssi"
	}

	for {set ix 1} {$ix <= $(attempts)} {incr ix} {
	    if {$(aggregate)} {
		catch {aggrtput destroy}
	    }
	    set code 0
	    UTF::Try "TPUT $(protocol) $(direction)) $ix" {
		if {$(pktqstats)} {
		    foreach index [array names pktqstats] {
			$pktqstats($index) sample
		    }
		}
		UTF::stream allstreams stop
		UTF::stream allstreams stats -clear
		foreach dut [join [list $AP $total_stas] " "] {
		    #if dump ampdu supported, clear it first
		    if {![catch {$dut [$dut cget -wl] -silent dump ampdu} ret] && [regexp {AMPDU} $ret]} {
			#try old style clear
			if {[catch {$dut [$dut cget -wl] -u ampdu_clear_dump}]} {
			    #old style clear not supported, try new format
			    $dut [$dut cget -wl] dump_clear ampdu
			}
		    }
		}
		UTF::Message INFO "" "#------------------------"
		UTF::Message INFO "" "#STA <-> MACAddr Mapping"
		UTF::Message INFO "" "#------------------------"
		foreach sta $total_stas {
		    UTF::Message INFO "" "$sta <-> [$sta macaddr]"
		}
		#send all traffic before testing to collect info
		if {$(warmup)} {
		    UTF::Message INFO "" "#---------------------------------------"
		    UTF::Message INFO "" "#Start Warmup for 2 seconds."
		    UTF::Message INFO "" "#---------------------------------------"
		    UTF::stream allstreams start
		    set timer [after 2 [list set expired 1]]
		    UTF::Message INFO "" "[after info $timer]"
		    UTF::Message INFO "" "#Collecting info during Warmup."
		    while {![catch {after info $timer}]} {
			if {$(mu)} {
			    _CollectMUInfo $AP $total_stas
			}
			#vwait in UTF::Sleep causes TCL to enter event loop to process events
			UTF::Sleep 0 quiet
		    }
		    UTF::stream allstreams stop
		    UTF::stream allstreams stats -clear
		    if {$(pktqstats)} {
			foreach index [array names pktqstats] {
			    $pktqstats($index) sample
			}
		    }
		    UTF::Message INFO "" "Warmup done."
		    foreach dut [join [list $AP $total_stas] " "] {
			#if dump ampdu supported, clear it first
			if {![catch {$dut [$dut cget -wl] -silent dump ampdu} ret] && [regexp {AMPDU} $ret]} {
			    #try old style clear
			    if {[catch {$dut [$dut cget -wl] -u ampdu_clear_dump}]} {
				#old style clear not supported, try new format
				$dut [$dut cget -wl] dump_clear ampdu
			    }
			}
		    }
		}
		if {$(callback) ne ""} {
		    UTF::Message INFO "" "#------------------------------------"
		    UTF::Message INFO "" "#Callback_dump before test start"
		    UTF::Message INFO "" "#------------------------------------"
		    uplevel 1 $(callback)
		}

		if {$(aggregate)} {
		    UTF::StreamStatAggregate aggrtput -period $(reportinterval)
		    aggrtput clear
		}

		if {$(delays) eq ""} {
		    UTF::Message INFO "" "#--------------------------------"
		    UTF::Message INFO "" "#Sending all streams in parallel."
		    UTF::Message INFO "" "#--------------------------------"
		    UTF::stream allstreams start
		    if {[catch {UTF::stream allstreams linkcheck} err]} {
			UTF::stream allstreams stop
			UTF::Message ERROR "" "$err"
			set code 1
			return $err
		    }
		} else {
		    #to allow streams start at different times specified in $(delays) later
		    set delaystartstreams {}
		    set immediatestartstreams {}
		    foreach sta $total_stas {
			set id [lsearch $(delays) $sta]
			if {$id ne "-1"} {
			    incr id
			    set delay [lindex $(delays) $id]
			    UTF::Message INFO "" "$MSG: sta=$sta delay=$delay delays=$(delays)"
			    #if there are multiple flows for same dst, always delay the first flow
			    lappend delaystartstreams "$traffic($sta,1)"
			    lappend delaystartstreams "$delay"
			    #remove the entry after it is queued in delaystartstreams
			    set (delays) [lreplace $(delays) [expr {$id -1}] $id]
			    UTF::Message INFO "" "$MSG: delaystartstreams=$delaystartstreams"
			    set ims 2
			} else {
			    set ims 1
			}
			#the rest of streams are queued in immediatestart streams
			for {set j $ims} {$j <= $(flows)} {incr j} {
			    lappend immediatestartstreams $traffic($sta,$j)
			    UTF::Message INFO "" "$MSG: adding traffic($sta,$j)=$traffic($sta,$j) to immediatestartstreams=$immediatestartstreams"
			}
			unset ims j
		    }

		    UTF::Message INFO "" "#---------------------------------------------------------------"
		    UTF::Message INFO "" "#Sending first batch streams $immediatestartstreams in parallel"
		    UTF::Message INFO "" "#---------------------------------------------------------------"
		    foreach s $immediatestartstreams {
			if {[catch {_StartStreamExcludeInitLoss $s} err ]} {
			    set code 1
			}
		    }
		}
		set t0 [format "%.3f" [UTF::stream clock]]
		if {$(aggregate)} {
		    aggrtput start
		}

		#set timer for holdtime
		set timer [after [expr {int($holdtime * 1000)}] [list set expired 1]]
		UTF::Message INFO "" "[after info $timer]"

		#set timer for each stream to be started at different times
		if {[info exists delaystartstreams]} {
		    foreach {stream delaytime} $delaystartstreams {
			# have to use fully qualified name for the arg of after command
			set eventid($stream) [after [expr {int($delaytime * 1000)}] \
						  [list UTF::Test::TrafficScheduling::_SequentialEventCallback $AP $stream $t0]]
			#set eventid($stream) [after [expr {int($delaytime * 1000)}] [list $stream start]]
		    }
		}
		while {![catch {after info $timer}]}  {

		    #Such info as reference already collected during warmup.
		    #Here only collecting same info for debug purpose for MU testing.
		    if {$(mu) && $(debug)} {
			_CollectMUInfo $AP  $total_stas
		    }

		    #vwait in UTF::Sleep causes TCL to enter event loop to process async events 
		    #such as collecting stats data.
		    UTF::Sleep 0 quiet

		    if {$(g) ne ""} {
			UTF::Sleep $(attninterval)
			if {[set currentattn [lindex [$(g) attn?] 0]] < $(maxattn)} {
			    $(g) incr $(attnstep)
			    set t2 [format "%.3f" [expr {1.000 * ([UTF::stream clock] - $t0)}]]
			    UTF::Message INFO "" "Attenuated $currentattn to [expr $currentattn + $(attnstep)] at $t2"
			} else {
			    UTF::Message INFO "" "$MSG: maximum attenuation $currentattn reached."
			}
			$AP wl -u bs_data
			$AP wl -u atf
			if {$(debug)} {
			    $AP wl -u bus:dumptxrings
			    UTF::Message DEBUG "" "origattn=$origattn, currentattn=$currentattn"
			}
			$AP wl -u assoclist
		    }
		}

		#all streams stop at the same time after holdtimer expires
		UTF::stream allstreams stop
		if {$(aggregate)} {
		    aggrtput stop
		}
		#if stream linkcheck failed, skip the rest of testing
		if {$code} {
		    if {$(g) ne "" && [info exists origattn]} {
			UTF::Message INFO "" "Reset $(g) to $origattn:"
			catch {$(g) attn $origattn} attn_err
			UTF::Message ERROR  "" "$attn_err. Current $(g)=[$(g) attn?]"
		    }
		    return $err
		}
		if {$(callback) ne ""} {
		    UTF::Message INFO "" "#------------------------------"
		    UTF::Message INFO "" "#Callback Dump after test stop"
		    UTF::Message INFO "" "#------------------------------"
		    if {[catch {uplevel 1 $(callback)} err]} {
			#set code 1
			UTF::Message WARNING  "" "$err"
		    }
		}

		if {$(pktqstats)} {
		    foreach index [array names pktqstats] {
			$pktqstats($index) sample
		    }
		}
		foreach dut [join [list $AP $total_stas] " "] {
		    if {![catch {$dut [$dut cget -wl] dump ampdu} ret] && [regexp {AMPDU} $ret]} {
			package require UTF::Dump::AMPDU
			#package require UTF::HistMode
			UTF::Dump::AMPDU dutampdu -raw $ret
			foreach item {
			    MPDUdens MPDUdens%
			    TXVHT TXVHT% TXVHTs TXVHTs%
			    TXMCS TXMCS% TXMCSs TXMCSs%
			    MCSPER MCSPER%
			    RXVHT RXVHT% RXVHTs RXVHTs%
			    RXMCS RXMCS% RXMCSs RXMCSs%
			    VHTPER VHTPER%
			    Frameburst Frameburst%
			    TXMode
			} {
			    UTF::Message INFO "" "$dut $item = \n[dutampdu $item]"
			}
			#set ampduHistMode($dut) [UTF::HistMode [concat [$ret TXVHT] [$ret TXMCS]]]
			#UTF::Message INFO "" "ampduHistMode($dut) = $ampduHistMode($dut)"
		    }
		}

		set datasum($ix) 0
		foreach STA $total_stas {
		    for {set j 1} {$j <= $(flows)} {incr j} {
			set name [$traffic($STA,$j) cget -name]
			if {[regexp -nocase "udp" $(protocol)]} {
			    set stats "rate lost"
			} else {
			    set stats "rate rtt cwnd"
			}
			foreach stat $stats {
			    dict set retdict $STA $stat $j [$traffic($STA,$j) stats -${stat} -meanminmax]
			}
		    }
		    unset j
		}
		UTF::Message INFO "" "retdict=$retdict"
		if {$(aggregate)} {
		    set aggrtputmmm [aggrtput stats -meanminmax]
		    if {$aggrtputmmm eq ""} {
			UTF::Message ERROR "" "Failed to get aggregate tput"
		    }
		}
		if {[string toupper $(protocol)] eq "TCP"} {
		    if {$(stats2plot) eq ""} {
			set (stats2plot) "rate rtt cwnd"
		    }
		} else {
		    if {$(stats2plot) eq ""} {
			set (stats2plot) "rate pktlatency lost"
		    }
		}
		set gtitle "[string toupper $(protocol)] [string toupper $(direction)] "
		UTF::Message INFO "" "total_streams=$total_streams"
		set i 1
		foreach stream $total_streams {
		    if {$i >= [llength $linetypes]} {
			set i 1
		    }
		    set lt [lindex $linetypes $i]
		    $stream configure -linetype $lt
		    UTF::Message INFO "" "name=[$stream cget -name]:"
		    UTF::Message INFO "" \
			"dst=[$stream cget -rx]; src=[$stream cget -tx];rxsta=[$stream cget -receivesta]; lt=[$stream cget -linetype]"
		    incr i
		}

		append gtitle "[string toupper $(stats2plot)] \\n"
		UTF::streamgraph graph -stat $(stats2plot) -yrange "0:*" -title "$gtitle" \
		    -graphsize $(graphsize) -lmargin "0.11" -streams $total_streams

		if {[catch {set plot [graph plot -composite]} ploterr]} {
		    UTF::Message ERROR "" "$ploterr"
		    throw FAIL "$ploterr"
		}
		return $plot
	    }
	    #objects are created and destroyed in each iteration
	    #outside of try block to gurantee cleanup will still happen
	    #if anything failed inside the try block
	    catch {graph destroy; rtt destroy; cwnd destroy; latency destroy; pktlost destroy; aggrtput destroy}
	    if {$(g) ne "" && [info exists origattn]} {
		UTF::Message INFO "" "Reset $(g) to $origattn:"
		catch {$(g) attn $origattn} catch_msg
		UTF::Message ERROR  "" "$catch_msg. Current $(g)=[$(g) attn?]"
	    }
	    if {$(modes) ne "" && [info exists origmodelist]} {
		foreach {STA m v} $origmodelist {
		    catch {ConfigureDevFeature $STA "$m $v" {}} err
		}
	    }
	    if {$code} {
		continue
	    } else {
		break
	    }
	}
	catch {UTF::stream allstreams destroy}

	foreach STA $total_stas {
	    if {$(disconnect)} {
		UTF::Message INFO "" "[$STA wl down]"
	    }
	}

	set rv {}
	if {[info exists retdict] && $retdict ne {} && [info exists plot] && $plot ne ""} {
	    if {$(aggregate)} {
		lappend rv $retdict $aggrtputmmm $plot
	    } else {
		lappend rv $retdict $plot
	    }
	    if {$(debug)} {
		UTF::Message DEBUG "" $rv
	    }
	    return $rv
	} else {
	    if {![info exists plot] || $plot eq ""} {
		UTF::Message WARNING "" "Failed to plot"
	    } else {
		error "Failed to get traffic stats"
	    }
	}
    }
}

