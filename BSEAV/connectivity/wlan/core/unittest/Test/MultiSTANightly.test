#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for nightly run
# $Id: 5a7eb6f6cf31dd633c929ac14d8d6e6447931f2d $
# $Copyright Broadcom Corporation$
#

package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::controlchart

package provide UTF::Test::MultiSTANightly 2.0

namespace eval UTF::Test::MultiSTANightly {

    proc ConnectPerf {AP1 STA1 AP2 STA2 args} {
	upvar {} testopts
	UTF::Getopts {
	    {mode1.arg "sta" "Mode1"}
	    {mode2.arg "sta" "Mode1"}
	    {security1.arg "open" "Security1"}
	    {security2.arg "open" "Security2"}
	    {finally.arg "" "Finally block"}
	}
	set i 2

	if {$(mode1) eq "ap"} {
	    lassign [list $STA1 $AP1] RAP1 RSTA1
	} else {
	    lassign [list $AP1 $STA1] RAP1 RSTA1
	}
	if {$(mode2) eq "ap"} {
	    lassign [list $STA2 $AP2] RAP2 RSTA2
	} else {
	    lassign [list $AP2 $STA2] RAP2 RSTA2
	}

	set k "$STA1 $(mode1) $(security1) + $(mode2) $(security2)"
	UTF::Try $k {

	    APConfigureSecurity $RAP1 -security $(security1)
	    APConfigureSecurity $RAP2 -security $(security2)
	    foreach s [list $RAP1 $RSTA1 $RAP2 $RSTA2] {
		if {[$s cget -hasdhcpd]} {
		    $s rexec "ps -ef | grep dhcp"
		}
	    }
	    ConnectAPSTA $RAP1 $RSTA1
	    ConnectAPSTA $RAP2 $RSTA2

	    # make sure FB is consistent
	    foreach s [list $AP1 $STA1 $AP2 $STA2] {
		if {[info exists UTF::FBDefault] && ![$s cget -noframeburst]} {
		    $s wl frameburst 1
		} else {
		    $s wl -u frameburst 0
		}
	    }

	    # Auto TCP window size setting based on phy rate
	    set w [$STA1 tcpautowindow]

	    controlchart \
		[list $STA1 $AP1 $AP1 $STA1 $STA2 $AP2 $AP2 $STA2] \
		-key $k -i $i -window $w \
		-loop $testopts(perfloop) -history $testopts(history) \
		-perfcache $testopts(perfcache)
	} finally {
	    uplevel 1 $(finally)
	}
    }

    proc clean {} {
	uplevel 1 {
	    # Disassoc to reduce roaming messages in logs
	    catch {$STA wl disassoc}
	    catch {$STA1 wl disassoc}
	}
    }
}

UTF::Test MultiSTANightly {args} {
    UTF::Getopts {
	{sta.arg "43224 4329f" "sta name"}
	{ap1.arg "4717" "First AP"}
	{ap2.arg "4717b" "Second AP"}
	{trx.arg "" "Router trx"}
	{tag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{bin.arg "" "STA dongle image"}
        {history.parg 30 "History size for control charts"}
	{perfloop.parg 1 "Performance test loops"}
	{perfcache.parg "" "Performance Cache"}
	{nocache "Don't update performance cache"}
	{nowep "No WEP security"}
	{notkip "No TKIP security"}
	{noaes "No AES security"}
	{noopen "No Open security STA tests"}
	{noap "No Open security APSTA tests"}
	{noenvscan "No Environment scan"}
	{title.arg "MultiSTA" "Title"}
	{chanspec.arg "" "Override autodetected chanspec"}
	{branch.arg "auto" "unused"}
	{email.arg "" "unused"}
	{noapload "unused"}
	{nostaload "unused"}
	{nostareload "unused"}
	{norestore "unused"}
	{nosetup "unused"}
	{date.arg "" "unused"}
	{nounload "unused"}
	{logdir.arg "" "unused"}
	{nosetuptestbed "unused"}
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }
    set AP1 $(ap1)
    set AP2 $(ap2)
    set STA $(sta)

    catch {$STA wl disassoc}

    # Force new AP setup
    $AP1 configure -security ""
    $AP2 configure -security ""

    UTF::Try "$STA: pick channel" {
	if {[set c $(chanspec)] eq ""} {
	    set c [lindex [UTF::PerfChans $AP1 $AP2 $STA] 0]
	}
	APConfigureSecurity $AP1 -security open
	APConfigureSecurity $AP2 -security open
	APChanspec $AP1 $c
	APChanspec $AP2 $c
	return $c
    }

    UTF::Try "$STA: Create virtual STA interfaces" {

	# Note these interfaces have the same MAC address, but
	# this is ok so long as they are associated to different
	# peers.

	set STA1 [$STA wl_interface_create sta #1]
	UTF::Message INFO $STA "Created $STA1 as a STA"
	return
    }


    if {!$(noenvscan)} {
	UTF::Try "$STA: Environment Scans" {
	    $STA wl up
	    $AP1 wl_escanresults -t passive
	    $STA wl_escanresults -t passive
	    $AP2 wl_escanresults -t passive
	    return
	}
    }

    if {!$(noopen)} {
	ConnectPerf $AP1 $STA $AP2 $STA1 -security2 open \
	    -finally clean
    }

    if {!$(noaes) && ![$STA cget -noaes]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 -security2 aespsk2 \
	    -finally clean
    }

    if {!$(nowep) && ![$STA cget -nowep]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 -security2 wep \
	    -finally clean
    }

    if {!$(notkip) && ![$STA cget -notkip]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 -security2 tkippsk \
	    -finally clean
    }

    if {!$(noaes) && ![$STA cget -noaes]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 \
	    -security1 aespsk2 -security2 aespsk2 \
	    -finally clean
    }

    if {!$(notkip) && ![$STA cget -notkip]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 \
	    -security1 tkippsk -security2 tkippsk \
	    -finally clean
    }

    if {!$(nowep) && ![$STA cget -nowep]} {
	ConnectPerf $AP1 $STA $AP2 $STA1 -security1 wep -security2 wep \
	    -finally clean
    }

    if {!$(noap)} {
	UTF::Try "$STA: Create virtual AP interface" {

	    catch {$STA1 wl_interface_remove}
	    UTF::Sleep 1

	    # Set global apsta mode to indicate we have both APs and STAs
	    $STA wl down
	    $STA wl apsta 1
	    $STA wl up

	    set STA1 [$STA wl_interface_create ap #2]

	    $STA1 wl up
	    $STA1 wl ssid [UTF::NewSSID]
	    $STA1 wl status
	    return
	}
	ConnectPerf $AP1 $STA $AP2 $STA1 -mode2 ap \
	    -finally {
		catch {$STA wl disassoc}
		catch {$STA1 wl bss down}
		catch {$STA1 wl_interface_remove}
		catch {$STA1 destroy}
		UTF::Sleep 1
		# Make sure AP2 goes back to AP mode
		APConfigureSecurity $AP2 -security renew
	    }
    }

    catch {$STA deinit}
}
