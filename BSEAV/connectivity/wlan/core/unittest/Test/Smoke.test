#!/bin/env utf
# -*-tcl-*-

set __doc__ "Top smoke test script.  Run at controller."
set __version__  {$Id: fc3f229a2e0bdf3503c3a6bac25c99e37b0ec85b $}
set __url__ {$URL$}

package provide UTF::Test::Smoke 2.0

package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::SmokeP2P

UTF::Test Smoke {AP STA args} {

    # Report script info.
    UTF::Message INFO {} "In: [pwd]"
    UTF::Message INFO {} "Called as: $::argv0 $::__cmdline"

    foreach var {WEBROOT HTTPWEBROOT} {
        if {[catch {UTF::Message INFO {} "$var=$::env($var)"} res]} {
            UTF::Message WARN {} "$res"
        }
    }
    # Unpack options.
    UTF::Getopts {
        {tag.arg "" "Build tag"}
        {bin.arg "" "Build image path"}
	{date.arg "" "Image date"}
        {dhd.arg "" "DHD arguments"}
        {p2p.arg "" "P2P arguments"}
        {ap_ssid.arg "" "unused"}
        {ap_bssid.arg "" "unused"}
        {test_id.arg "" "Smoke test id"}
        {sta_suspect.arg "yes" "STA sanity suspect"}
        {repeats.arg "1,1" \
            "Number of overall repetitions, connect repetitions"}
        {reboot_on_fail "Reboot STA on failure"}
	{reload "Reload existing driver instead of loading new driver"}
	{noload "Skip load"}
	{noconnect "Skip connect"}
	{nounload "Skip unload"}
    }
    # Adjust options.
    if {$(tag) ne ""} {
        $STA configure -tag $(tag)
    }
    if {$(date) ne ""} {
	$STA configure -date $(date)
    }

    if {$(bin) ne ""} {
        if {[$STA hostis Cygwin]} {
            $STA configure -altsys $(bin)
        } else {
            $STA configure -image $(bin)
        }
	# XXX DEBUG
        catch {exec ls -l $(bin)/wl/sys/wdm} ret
        UTF::Message DEBUG {} "$ret"
        catch {exec ls -l $(bin)/wl/sys/wdm/buildwin7} ret
        UTF::Message DEBUG {} "$ret"
    }
#    if {$(dhd_image) ne ""} {
#            # This actually splits on white space.
#        set dhd_image [join $(dhd_image)]
#        set dhd_dir [lindex $dhd_image 0]
#        set dongle_dir [lindex $dhd_image end]
#            # dhd.ko
#        $STA configure -dhd_image $dhd_dir
#            # dongle
#        $STA configure -image $dongle_image
#            # nvram full path
#        $STA configure -nvram [file join $dhd_dir [$STA cget -nvram]]
#    }

    $STA configurelist $(dhd)

    # Wait STA to recover after power cycle or crash
    # for up to 10 minutes.
    # Use some wait time after power cycle because $STA -n :
    # does not return an error on "Connection refused" so
    # the underlying rexec does not wait.
    proc wait_recover {STA wait} {
        $STA configure -initialized 0
        for {set i 0} {[catch {$STA -n :}] && $i < 20} {incr i} {
            if {$wait > 0} {
                UTF::Sleep $wait
            }
        }
    }
    # Unpack repeats.
    foreach {repeats connect_repeats} [split $(repeats) ","] {break}
    if {$repeats eq ""} {
        set repeats 1
    }
    if {$connect_repeats eq ""} {
        set connect_repeats 1
    }
    # Repeat load/connect/unload.
    for {set rep 1} {$rep <= $repeats} {incr rep} {

	UTF::Try "Repetition $rep of $repeats." {

	    set sta_suspect $(sta_suspect)
	    set load_stat "FAIL"
	    set connect_stat "FAIL"
	    set unload_stat "FAIL"
	    set p2p_msg "P2P NRUN"

	    set load_atts 2
	    set join_atts 3
	    if {[string is false $sta_suspect]} {
		set load_atts 1
		set join_atts 1
	    }
	    # Load.
	    if {$(noload)} {
		set load_stat "SKIPPED"
	    } else {
		if {$(reload)} {
		    set load "reload"
		} else {
		    set load "load"
		}
		UTF::Try "$STA $load" {
		    # Allow one load retry with reboot if STA sanity is suspect.
		    for {set att 1} {$att <= $load_atts} {incr att} {
			if {[catch {$STA $load} ret]} {
			    if {$att == $load_atts} {
				error $ret $::errorInfo
			    } else {
				UTF::Message WARN {} "$ret"
				UTF::Message WARN {} "$STA power cycle after $load fail"
				$STA power cycle
				wait_recover $STA 30
			    }
			} else {
			    # Load successful.
			    set load_stat "PASS"
			    break
			}
		    }
		}
	    }

	    if {$load_stat eq "FAIL"} {
		set connect_stat "NA"
	    } elseif {$(noconnect)} {
		set connect_stat "SKIPPED"
	    } else {
		set p2p_msg_err ""
		set connect_pass_ct 0
		for {set crep 1} {$crep <= $connect_repeats} {incr crep} {
		    UTF::Try "$STA connect repetition $crep of $connect_repeats" {

			$STA wl up
			foreach {s p} [$STA pre_reclaim] {
			    UTF::XPASS $STA $p \
				[list stage pre_reclaim$s data free]
			}
			if {![$STA cget -nomaxmem] && [$STA rte_available]} {
			    foreach {key val} [$STA memstats] {
				UTF::XPASS $STA $val \
				    [list stage up data $key]
			    }
			}
			if {$crep == 1} {
			    UTF::Message WHATAMI $STA "Start."
			    $STA whatami
			    UTF::Message WHATAMI $STA "End."
			}
			ConnectAPSTA $AP $STA -tries $join_atts
			incr connect_pass_ct
			if {![$STA cget -nomaxmem] && [$STA rte_available]} {
			    foreach {key val} [$STA memstats] {
				UTF::XPASS $STA $val \
				    [list stage ConnectAPSTA data $key]
			    }
			}
			# Run point-to-point helper if required.
			if {$(p2p) ne ""} {
			    set p2p_msg_rep [SmokeP2P $AP $STA {*}$(p2p)]
			    if {$p2p_msg_rep ne ""} {
				# Save latest p2p error.
				set p2p_msg_err $p2p_msg_rep
			    }
			    if {![$STA cget -nomaxmem] && [$STA rte_available]} {
				foreach {key val} [$STA memstats] {
				    UTF::XPASS $STA $val \
					[list stage ConnectP2P data $key]
				}
			    }
			}
			$STA wl down
			# End connect repeat loop.
		    }
		    # End connect repeats.
		}
		if {$connect_pass_ct == $connect_repeats} {
		    set connect_stat "PASS"
		}
		if {$p2p_msg_err ne ""} {
		    set p2p_msg $p2p_msg_err
		}
	    }
	    # Unload.
	    if {$(nounload)} {
		set unload_stat "SKIPPED"
	    } else {
		UTF::Try "$STA unload" {
		    set res [catch {$STA wl disassoc} ret]
		    if {$res} {
			UTF::Message WARN {} "$STA wl disassoc fail, $ret"
		    }
		    if {[$STA hostis Cygwin]} {
			$STA unload -rm
		    } else {
			$STA unload
		    }
		    set unload_stat "PASS"
		}
	    }
	    UTF::Try "check host" {
		# If STA crashed, try to reconnect.
		wait_recover $STA 0
		# Trigger crashcheck after recovery.
		catch {$STA :}
	    }
	    # Report status.
	    set all_stats [list $load_stat $connect_stat $unload_stat]
	    set all_stat_names [list "load" "connect" "unload"]
	    foreach stat $all_stats {
		if {$stat ne "PASS"} {
		    break
		}
	    }
	    set msg ""
	    if {$stat ne "PASS" || [regexp {.*FAIL} $p2p_msg]} {
		for {set i 0} {$i < [llength $all_stats]} {incr i} {
		    set msg [concat $msg " " [lindex $all_stat_names $i] " " \
				 [lindex $all_stats $i]]
		}
		UTF::Message FINAL FAIL "$msg $p2p_msg"
		if {$(reboot_on_fail)} {
		    UTF::Message INFO $STA "Rebooting on failure."
		    $STA power cycle
		    wait_recover $STA 30
		}
	    } else {
		UTF::Message FINAL PASS All
	    }
	    # End repeat loop.
	}
        # End repeats.
    }
}
