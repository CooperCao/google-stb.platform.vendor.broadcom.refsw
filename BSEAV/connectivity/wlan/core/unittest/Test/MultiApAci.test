#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for aci nightly run script editing:fidha
# $Id: 76fe0f7bd514d68d0f48b2c3d3b648e0bf70381a $
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set MultiApAci_help "\n\nBasic usage: Test/MultiApAci.test <options>\
    \n\nThis Rate vs Range script will setup your testrig by loading the desired\
    \nbuilds, produce high level summary web pages and calls the script that does\
    \nthe lower level work, aci.test. The script aci.test is called for up to 4\
    \ndifferent channels. Each channel is tested for the upstream and downstream\
    \ntraffic directions.\
    \n\nThese scripts have many default values, not all of which will work optimally\
    \non your testrig. Consequently, there are a number of environment variables that\
    \nyou can set in your config file to customize the behavior to better suit your\
    \ntestrig:\
    \n\nYou can customize the attenuation ranges to be tested for each channel:\
    \n    set ::cycle5G40AttnRange \"0-50 50-0\"\
    \n    set ::cycle5G20AttnRange \"0-50 50-0\"\
    \n    set ::cycle2G40AttnRange \"10-60 60-10\"\
    \n    set ::cycle2G20AttnRange \"10-60 60-10\"\
    \n\nIf the pathloss is the same for all devices in the testrig, specify:\
    \n    set ::testbed_pathloss ll\
    \n    where ll is a positive integer\
    \n\nYou can specify pathloss for each specific band:\
    \n    set ::testbed_pathloss_2G 52\
    \n    set ::testbed_pathloss_5G 63\
    \n\nIf each device has a different pathloss, you can specify the pathloss for each\
    \nSTA as shown below:\
    \n    set ::mc351_4319USB_pathloss 40\
    \n    set ::mc356_43236USB_pathloss 34\
    \n    set ::mc355_4336SDIO_pathloss 38\
    \n\nYou can specify pathloss per band or per channel per STA:\
    \n    set ::mc356_43236USB_pathloss_2G 34\
    \n    set ::mc356_43236USB_pathloss_5G 44\
    \n    set ::mc358_4312NIC_pathloss_36l 55\
    \n\nYou can take complete control of the AP & STA initialization sequence by\
    \nspecifying the variables ::rvr_ap_init and ::rvr_sta_init in your config\
    \nfile. The defaults are defined in aci.test proc get_user_parms. Alternately,\
    \nlook in the RvR logfiles in the Setup AP & STA section to see the defaults.\
    \nFor SoftAP, you can specify the initialization in ::rvr_softap_init. SoftAP\
    \ndefaults to the values from ::rvr_sta_init.\
    \n\nSome people may have more complex initialization needs which depend on the\
    \nSTA talking to a real AP versus a SoftAP, and other variations. So this\
    \ninitialization variable heirarchy is available to allow customization\
    \nfor all devices in the testrig, as well as STA specific customizations:\
    \nFor STA to SoftAP ::rvr_sta_{STA}_to_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_softap_init ::rvr_sta_init\
    \nFor STA to AP     ::rvr_sta_{STA}_to_ap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_ap_init ::rvr_sta_init\
    \nFor SoftAP        ::rvr_sta_{STA}_am_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_softap_init ::rvr_sta_init\
    \nFor AP            ::rvr_ap_{AP}_init ::rvr_ap_init\
    \nIn the above variables, {STA} & {AP} mean the UTF STA name.\
    \nWhen the script looks for the initialization, the list is searched from left\
    \nto right, with the STA specific variable having the highest priority.\
    \nBecause the script knows which AP & STA you are using, and if you specified\
    \nthe -softap option or not, the script can locate and use the appropriate\
    \ninitialization variables without any additional user intervention.\
    \n\nIf you want to use the -warmup option, you can override the default 5Mb/s pass\
    \ncriteria by specifying:\
    \n    set ::rvr_warmup nn\
    \n    Set this parameter to 0 or -1 if you dont want a pass criteria.\
    \n\nTo keep tests from running away for hours at a time, the aci.test script has a\
    \ntime limit of 90 minutes for each rampdown/rampup test. If you want to override\
    \nthe default 90 minute per test timeout value, then specify:\
    \n    set ::rvr_overall_timeout_min mm\
    \n    Set this parameter to 0 or -1 for no timeout, unlimited test run time.\
    \n\nBy default the script will try 1 time to rejoin the AP and STA. This default\
    \ncan be changed in your config file:\
    \n    set ::rvr_rejoin_tries ii\
    \n    The minimum value for this parameter is 1.\
    \n\nBy default, the script will wait 10 seconds after a rejoin attempt. This\
    \ndefault can be changed in your config file:\
    \n    set ::rvr_rejoin_wait_sec jj\
    \n    The minimum value for this parameter is 5.\
    \n\nBy default, the script will perform 3 progressive recovery attempts during the\
    \ntests if things go wrong. This default can be changed in your config file:\
    \n    set ::recovery_max kk\
    \n    Set this parameter to 0 or -1 for no recovery actions.\
    \n\nBy default, the script will stop the rampdown portion of the test after 3\
    \nconsecutive attenuator steps with no beacons. This default can be changed in\
    \nyour config file:\
    \n    set ::rvr_rampdown_nobeacons bb\
    \n    Set this parameter to 0 or -1 to disable this feature.\
    \n\nThe optional -stopslowrampup algorithm is controlled by two parameters, whose\
    \ndefaults are 10 & 1 respectively. These defaults can be changed in your config file:\
    \n    set ::rvr_slowrampup_cnt cc\
    \n    set ::rvr_slowrampup_tput tt\
    \n\nThere may be times that a specific STA needs the router to do something\
    \nspecifically for that STA. You can add STA specific variables to set the\
    \nrouter nvram accordingly in your config file. Dont forget to turn these\
    \nsettings back for theSTAs.\
    \n    set ::mc351_4319USB_rtr_nvram {antswitch=3}\
    \n    set ::mc356_43326USB_rtr_nvram {antswitch=0}\
    \n\nAfter each occasional repeated error attenuator occurs, the attenuator\
    \nrecovery is attempted. If you choose to specify the variable shown below in\
    \nyour config file, your attenuator will be power cycled for you, and the\
    \ncommand retried after the power cycle:\
    \n    set ::rvr_attn_power \"mcxxwsy 1\"\
    \nAfter 3 repeated attenuator errors, the aci.test is halted. Should you\
    \nwish to alter the default 3 attenuator error limit, you may specify the\
    \nvariable shown below in your config file:\
    \n    set ::rvr_attn_max_errors N\
    \n    Set this parameter to 0 or -1 to allow unlimited errors to occur.\
    \n\nThe optional fastrampup test will test 10 samples at the final attenuator\
    \nvalue. You can alter this value by specifying ::rvr_fastrampup_cnt in your\
    \nconfig file. Variable ::rvr_fastrampup_tput controls the thruput at which\
    \nthe fastrampup is made, default is 1 Mb/s.\
    \n\nFor SoftAP tests, the RF wiring on the attenuator needs to be set up to\
    \nattenuate the RF path between the SoftAP and the STA being tested. Most\
    \ntestrigs need to be modified for this to work, as they tend to have a real\
    \nAP connected to the attenuator, not a SoftAP.\
    \n\nFor SoftAP tests, you need to ensure the SoftAP and STAs will get IP\
    \naddresses. A real AP has a built-in DHCP server. If the SoftAP is running\
    \non Linux, you can run dhcpd on the Linux host. You will still need to\
    \nconfigure a static IP address for the SoftAP itself. If the SoftAP does\
    \nnot provide dhcpd, then you must configure static IP addresses for the\
    \nSTA that will be tested. See examples in utfconf/pb4a.tcl & mc49.tcl.\
    \n\nThe AP connect time check looks for drops of 30 seconds or more as\
    \nan indicator of issues. The variable ::rvr_connect_time_drop can be used\
    \nto alter this threshold. Set to -1 to turn off this test.\
    \n\nTrenderrors looks at how many consecutive errors occur as well as total\
    \nerrors in the test. Initially most controlchart tests are shown as PASS,\
    \nexcept for major errors like assert or ping fail. Then, at the end of the\
    \ntests, the trend errors analysis is done and the overall PASS/FAIL criteria\
    \nis determined. Config file variable ::rvr_trend_error_length defaults to 6,\
    \nand is the minimum number of consecutive errors needed to trigger a trend\
    \nerror FAIL. Variable ::rvr_trend_error_max defaults to 18, and is the total\
    \nnumber of errors that can occur, consecutive or not, without causing a FAIL.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set MultiApAci_getopts {
 {allhooks                  "Use all the perf_hooks, etc as is - currently the default"}
     {allhooks                  "Use all the perf_hooks, etc as is - currently the default"}
    {ap.arg "4717"             "AP name"}
    {attnstep.arg "1"          "Step value that attenuator is changed by"}
    {attngrp.arg ""            "Attenuator group to use for test"}
    {bin.arg ""                "STA image, usefull for private build testing"}
    {branch.arg "auto"         "Branch override"}
    {chan2G20.arg 1            "Channel(s) for 2G20band"}
    {chan2G40.arg 1l           "Channel(s) for 2G40band"}
    {chan5G20.arg 36           "Channel(s) for 5G20band"}
    {chan5G40.arg 36l          "Channel(s) for 5G40band"}
    {chan5G80.arg ""           "Channel(s) for 5G80band"}
    {chanint                   "Collect chanspec info and graph as integer"}
    {channels                  "Run channel sweep tests"}
    {comparesta                "Run STA comparison test upon 2 STAs. Require 2 and only 2 STAs."}
    {comparestaoneloop         "Run STA comparison test upon 2 STAs in multiple loops, but only 1 loop for first STA. Require -comparesta option."}
    {compareap                 "Run AP comparison test upon 2 APs. Require 2 and only 2 APs."}
    {cont2G20AttnRange.arg ""  "Depracated"}
    {cont2G40AttnRange.arg ""  "Depracated"}
    {cont5G20AttnRange.arg ""  "Depracated"}
    {cont5G40AttnRange.arg ""  "Depracated"}
    {cycle2G20AttnRange.arg "" "Cycle-based aci attenuation range for 2G20band, default: 25-75 75-25"}
    {cycle2G40AttnRange.arg "" "Cycle-based aci attenuation range for 2G40band, default: 20-75 75-20"}
    {cycle5G20AttnRange.arg "" "Cycle-based aci attenuation range for 5G20band, default: 0-50 50-0 "}
    {cycle5G40AttnRange.arg "" "Cycle-based aci attenuation range for 5G40band, default: 0-50 50-0 "}
    {cycle5G80AttnRange.arg "" "Cycle-based aci attenuation range for 5G80band, default: 0-50 50-0 "}
    {date.arg ""               "depracated, please use rtrdate & stadate"}
    {downstreamonly            "RvR downstream only tests are done, dont do upstream tests"}
    {edithooks                 "Selectively edit the perf_hooks, etc for some test speedup"}
    {email.arg ""              "Email Address, defaults to your email address"}
    {fastrampup                "Do fast rampup only, saves test time"}
    {fb0                       "Use frameburst=0, currently the default"}
    {fb1                       "Use frameburst=1 for maximum throughput"}
    {forcesniffercapture       "Always save the sniffer capture .pcap file, consumes lots of disk space"}
    {fullrange                 "Test full attenuator range specified, default is to rampup after 3 steps of no beacons"}
    {fullrampup                "Do not stop the rampup test, regardless of slow rejoin issues"}
    {history.arg 30            "History size for control charts"}
    {iperfnobeacons            "Run iperf tests even if STA has no beacons"}
    {intattn2G20.arg ""        "secondary attn_grp & attn_val for 2G20 interference, eg: G3 7"}
    {intattn2G40.arg ""        "secondary attn_grp & attn_val for 2G40 interference, eg: G3 7"}
    {intattn5G20.arg ""        "secondary attn_grp & attn_val for 5G20 interference, eg: G3 7"}
    {intattn5G40.arg ""        "secondary attn_grp & attn_val for 5G40 interference, eg: G3 7"}
    {intattn5G80.arg ""        "secondary attn_grp & attn_val for 5G80 interference, eg: G3 7"}
    {intattnoem.arg ""         "secondary attn_grp & attn_val for oem interference, eg: G3 7"}
    {intchan2G20.arg "6"       "2G20 channel setting for interference source"}
    {intchan2G40.arg "11u"     "2G40 channel setting for interference source"}
    {intchan5G20.arg "40"      "5G20 channel setting for interference source"}
    {intchan5G40.arg "44l"     "5G40 channel setting for interference source"}
    {intchan5G80.arg ""        "5G80 channel setting for interference source"}
    {intchanoem.arg ""         "oem channel setting for interference source"}
    {intgap.arg "50"           "pkteng interference time between frames, in usec"}
    {intgraph                  "Monitor / create interference data graphs even if interference test not active"}
    {intnrate.arg "7"          "MCS rate to test pkteng interference with"}
    {intquiet                  "Suppress interference STA error messages, which can flood the error report."}
    {intrate.arg ""            "Legacy rate test pkteng interference with, if specified, rate will override intnrate"}
    {intsize.arg "1400"        "pkteng interference frame size, in bytes"}
    {intsta.arg ""             "STA to be used as the interference source, this is not the DUT STA"}
    {inttype.arg "pkteng"      "pkteng can be used to generate interference, tone not supported"}
    {intwl2G20.arg "4"         "For interference tests, AP/STA wl interference setting to use for 2G20 band"}
    {intwl2G40.arg "4"         "For interference tests, AP/STA wl interference setting to use for 2G40 band"}
    {intwl5G20.arg "1"         "For interference tests, AP/STA wl interference setting to use for 5G20 band"}
    {intwl5G40.arg "1"         "For interference tests, AP/STA wl interference setting to use for 5G40 band"}
    {intwl5G80.arg "1"         "For interference tests, AP/STA wl interference setting to use for 5G80 band"}
    {intwloem.arg "4"          "For interference tests, STA wl interference setting to use for oem band"}
    {keepgoing                 "No time limit for test, keep going no matter what"}
    {logdir.arg ""             "Log directory override"}
    {loop.arg 1                "Main test loops"}
    {max.arg 1700              "Expected maximum througput, -1 means no checks done"}
    {min.arg 0                 "Expected minimum througput, -1 means no checks done"}
    {mingraphs                 "Produce minimum quantity of graphs"}
    {musta.arg ""              "Multi user mode. It loads up to 4 additional STAs"}
    {no2G20                    "No 2G 20Mhz Tests"}
    {no2G40                    "No 2G 40Mhz Tests"}
    {no5G20                    "No 5G 20Mhz Tests"}
    {no5G40                    "No 5G 40Mhz Tests"}
    {noapload                  "Don't load images"}
    {noattnchange              "Do not change attenuator (for fixed attenuation tests)"}
    {nobtreset                 "Don't reset BlueTooth devices. WARNING: can lead to low WLAN thruput!"}
    {nocache                   "Don't update performance cache"}
    {nochannels                "Does nothing, depracated"}
    {nocomposite               "Don't generate composite RvR graphs for each STA"}
    {nocompositemainpage       "Generate composite RvR graphs for each STA, but dont show them on the main web page"}
    {nocontrvr                 "Depracated"}
    {nocyclervr                "No cycle-based rvr tests, default is run the cycle-based rvr tests"}
    {nodbuxpost                "Dont post test info to dbux"}
    {nographs                  "Dont produce any graphs"}
    {nohistograms              "Do not produce histograms"}
    {nohooks                   "Dont use any perf_hooks, etc for maximum test speedup"}
    {noinit                    "Use the testbed as is, no initialization"}
    {nointstaload              "Don't load Interference STA drivers"}
    {nomalloc                  "Dont check the serial console for malloc failures"}
    {nopretest                 "Dont do short warmup test for each controlchart test, defaults on for udp"}
    {noredundant               "Dont execute redundant wl calls, test runs a bit faster"}
    {norestore                 "Don't reset AP to defaults"}
    {norvr                     "No rvr tests, default is run the rvr tests"}
    {nosetup                   "No loading of AP or STAs, no testbed setup"}
    {nosetuptestbed            "Don't run Setup Testbed hooks"}
    {nosniffer                 "No Sniffer"}
    {nostaload                 "Don't load STA drivers"}
    {nostareload               "Don't even reload STA drivers (need -nostaload)"}
    {nostahighlevelsetup       "Let aci.test do all the STA setup."}
    {nosymmetry                "Dont run symmetry tests for rampdown / rampup tests"}
    {nounload                  "Don't unload driver after test"}
    {oemAttnRange.arg ""       "Cycle-based aci attenuation range for OEM AP, default: 20-75 75-20"}
    {oemband.arg ""            "When OEM AP broadcasts on both bands, used to choose the desired band: 2.4 or 5"}
    {pathloss.arg ""           "Known testbed path loss, in db, from AP to STA when variable attenuator is set to default"}
    {perfloop.arg 1            "Total performance test iterations for iperf controlchart tests"}
    {perfsize.arg 5            "Sample size for performance tests"}
    {perftime.arg 10           "Total time duration, in seconds, for performance tests"}
    {pingmax.arg ""            "Maximum times to try ping in RvR, default is 10"}
    {rampdownonly              "Dont do rampup portion of RvR tests, test time is halved"}
    {rampuponly                "Dont do rampdown portion of RvR tests, test time is halved"}
    {refreshaddralways         "Always do dhcp before each attenuator step change & iperf test"}
    {refreshaddrasneeded       "Do dhcp after reassociation for each attenuator step until dhcp succeeds once, then stop"}
    {restoreaponly             "Do not load or reload AP, just restore the AP NVRAM"}
    {ringfilecnt.arg ""        "Specify sniffer ring buffer file count. Null means no ring buffer."}
    {ringfilesize.arg ""       "Specify sniffer ring buffer file size in MBytes. Null means no ring buffer."}
    {rtrdate.arg ""            "Desired Router build date, format: yyyy.mm.dd"}
    {rtrtag.arg ""             "Router release tag"}
    {security.arg "open"       "Security used for tests"}
    {softap                    "AP is really a STA running softap code"}
    {sniffer.arg ""            "Sniffer object name"}
    {sniffercapture.arg ""     "Start/stop commands for when to capture continuous .pcap files. To collect rampdown steps 44-54, specify: d44 d54"}
    {sta.arg "Sta4321"         "sta name(s)"}
    {stadate.arg ""            "Desired STA build date, format: yyyy.mm.dd"}
    {stadhd.arg ""             "STA .ko linux DHD file, usefull for testing private builds"}
    {statag.arg ""             "STA release tag"}
    {steplist.arg ""           "List of specific attenuator steps to test, in whatever order"}
    {steploop.arg 1            "Number of times to repeat attenuator steplist"}
    {stoponerror               "Stops test on first error, no progressive recovery done. Useful when developer want to see testrig in failed state."}
    {stopslowrampup            "Stop the rampup test if severe slow rejoin issues are detected"}
    {tag.arg ""                "depracated, please use rtrtag"}
    {test.arg "0"              "Test mode for script development, experts only, values: 0 1 2"}
    {timeout.arg ""            "Overall test timeout, in minutes, default is 90 min"}
    {title.arg "Rate vs Range Test" "Report title text"}
    {titleap                   "Use AP name in report & graph titles, default is STA name"}
    {trenderrors               "Show only trend errors, not 1 error per controlchart"}
    {trx.arg ""                "Router trx image, usefull for private build testing"}
    {txbf                      "Run comparison test in this pattern: AP1<->STA1, AP2<->STA2 (useful for TxBF test)"}
    {udp.arg "0"               "udp test starting value in Mb/s, 0 means off, use tcp"}
    {udpopt.arg ""             "more options for iperf for udp tests"}
    {upstreamonly              "RvR upstream only tests are done, dont do downstream tests"}
    {va.arg "Aflex"            "variable attenuator name"}
    {warmup                    "Do 60 second iperf warmup tests"}
    {wet                       "Allow AP in the -sta setting, for WET test"}
    {windhdbin.arg ""          "WinDHD dongle image file, usefull for testing private builds, in particular for BTAMP"}
    {window.arg 512k           "Window size for iperf tests, has major impact on thr"}
	{loop1.arg					"rate loop"}
	
	}


# Setup online help info.
UTF::setup_help $MultiApAci_help $MultiApAci_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

package require UTF
package require UTF::utils
package require UTF::Test::APConfigureSecurity
package require UTF::Test::ChannelSweep
package require UTF::Test::aci

package provide UTF::Test::MultiApAci 2.0
#============== proc create_composite_graphs ========================
# Proc to create composite graphs
#====================================================================
proc create_composite_graphs {focus nocomposite nocompositemainpage\
    rampdownonly rampuponly fastrampup nographs mingraphs AP STA udp} {

    # NB: focus could be AP or STA name.

    # Some users may not want composite graphs at all.
    if {$nocomposite || $nographs || $mingraphs} {
        UTF::Message LOG $::localhost "create_composite_graphs\
            User requested no composite graphs"
        return
    }

    # proc setup_summaries should have given us a testnum to use.
    # We need a different one for each STA tested, to keep filenames unique.
    if {![info exists ::saved_testnum]} {
        error "ERROR: create_composite_graphs ::saved_testnum not defined"
    }

    # Log the composite graph files & titles to be used.
    # ::rvr_composite_input is formated as: file1 title1 ... fileN titleN
    # test code below
    # set ::rvr_composite_input "/projects/hnd_sig_ext2/brearley/mc35/20101005193736/15.4_mc353_43236_bmac_rvr5G40_cycle_Upstream_2010_10_05_19_42.csv CH36l_Upstream_mc353_43236_bmac /projects/hnd_sig_ext2/brearley/mc35/20101005193736/15.5_mc353_43236_bmac_rvr5G40_cycle_Downstream_2010_10_05_20_08.csv CH36l_Downstream_mc353_43236_bmac /projects/hnd_sig_ext2/brearley/mc35/20101005193736/15.6_mc353_43236_bmac_rvr24G20_cycle_Upstream_2010_10_05_20_32.csv CH1_Upstream_mc353_43236_bmac /projects/hnd_sig_ext2/brearley/mc35/20101005193736/15.7_mc353_43236_bmac_rvr24G20_cycle_Downstream_2010_10_05_21_11.csv CH1_Downstream_mc353_43236_bmac"
    UTF::Message LOG $::localhost "create_composite_graphs\
        ::rvr_composite_input=$::rvr_composite_input"

    # We need 2 file/title pairs at the minimum to create a composite graph.
    # If the user is running tests on just 1 channel in only 1 direction, say upstreamonly,
    # we can hit situations where there is only 1 RvR graph.
    # The merge routine wants 2 file/titles minimum.
    if {[llength $::rvr_composite_input] < 4} {
        UTF::Message LOG $::localhost "create_composite_graphs\
            Need 2 file/titles minimum to create composite graph."
        return
    }

    # Specify filter, option, description triplets for each composite graph to be created.
    set filter_option_description_list [list * {} "All"\
	Upstream {} "Upstream" \
	Downstream {} "Downstream" \
        * {-nominmax} "All no min/max"\
        * {-rampdownonly} "All rampdownonly"\
        * {-nominmax -rampdownonly} "All no min/max rampdownonly"\
        24G {} "2.4 GHz"\
        24G {-rampdownonly} "2.4 GHz rampdownonly"\
        5G {} "5 GHz"\
        5G {-rampdownonly} "5 GHz rampdownonly"]

    # Create composite graph based on filter & option
    set i 0
    source "$::UTF::unittest/bin/merge_rvr_data.tcl"
    foreach {filter option description} $filter_option_description_list {

        # Do rampdownonly graph if necessary. Always do the rampdown/rampup graph.
        if {[regexp {rampdownonly} $option] && ($rampdownonly || $rampuponly)} {
            continue
        }

        # Set fastrampup option only for rampdown/rampup graph
        set fr ""
        if {![regexp {rampdownonly} $option] && $fastrampup == 1} {
            set option "$option -fastrampup"
        }
        UTF::Message LOG $::localhost "option=$option"

        # Select the CSV files & titles that match the filter.
        set file_title_list ""
        foreach {file title} $::rvr_composite_input {
            if {$filter == "*" || [regexp "$filter" "$file"]} {
                append file_title_list " $file $title"
            }
        }

        # Must have at least 2 files/titles.
        if {[llength $file_title_list] < 4} {
            UTF::Message LOG $::localhost "create_composite_graphs\
                Not enough files/titles"
            continue
        }

    	# Set Y-Axis transport type.
    	# Text "transport:" is used so that transport info 
    	# can be retrieved easily later in MergeRvrData{}.
    	if {$udp > 0} {
    	    set transport "transport:UDP"
    	} else {
    	    set transport "transport:TCP"
    	}

	# Set device names for title.
	# Text "devicenames:" is used so that device info
	# can be retrieved easily later in MergeRvrData{}.
	set device_name "devicenames:$AP<=>$STA"

        # Create composite graph using multiple CSV files & titles
        set graph ""
        set catch_resp [catch "eval UTF::Test::MergeRvrData $file_title_list\
	    $option $device_name $transport" graph]
        UTF::Message LOG $::localhost "create_composite_graphs\
            catch_resp=$catch_resp graph=$graph"
        if {[regexp {no_data_to_plot} $graph]} {
            UTF::Message ERROR $::localhost "create_composite_graphs\
                MergeRvrData catch_resp=$catch_resp graph=$graph"
            continue
        }

        # Rename graph so it wont conflict with any other composite graphs.
        incr i
        set temp [file dirname "$graph"]
        set temp "$temp/${::saved_testnum}_composite${i}.png"
        set catch_resp [catch "file rename \"$graph\" \"$temp\"" catch_msg]
        if {$catch_resp != 0} {
            UTF::Message ERROR $::localhost "create_composite_graphs\
                rename catch_resp=$catch_resp catch_msg=$catch_msg"
            continue
        }

        # Dump graph on the Composite page, 2 graphs per row.
        if {[expr $i % 2] == 1} {
            puts $::COMP "   <tr><td><img src=\"$temp\"></td>"
        } else {
            puts $::COMP "       <td><img src=\"$temp\"></td></tr>"
        }
        flush $::COMP

        # Dump each graph in row by itself on the All Graphs page.
        puts $::ALL "   <tr><td>Composite $description</td><td><img src=\"$temp\"></td></tr>"
        flush $::ALL

        # Some people dont want the composite graphs on the main summary page,
        # but are happy to have them their own composite only summary web page.
        if {$nocompositemainpage == 0} {
            # Push the composite graph to main summary web page.
            UTF::Try "$focus Composite $description" {
                return "html: <img src=\"$temp\">"
            }
        }
    }
}

#============== proc main_aci_multiapaci ==============================
# Proc main_aci_multiapaci does all the STA loading, setup and then
# calls aci1fidha.test foreach STA. Router is loaded elsewhere.
#
# NB: proc is uniquely named to avoid conflict with other scripts
# that have a proc main.
#====================================================================
proc main_aci_multiapaci {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts
upvar {} {} ;# gives access to unamed array from getopts

    # A single RvR run can test multiple STA or clones.
    # If user and aci.test said to stop, we stop everything.
    UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
    if {$(stoponerror) && $::stop_tests == "yes"} {
       error "$STA stopping tests due to previous error"
    }

    # Ensure each STA gets full initialization the first time thru aci.test
    set ::rvr_init_done 0

    # Find STA image.
    set id ""
    if {!$(nostaload) && !$(nosetup) && !$(noinit)} {
        UTF::Try "$STA: Find STA Image" {
            set catch_resp [catch {$STA findimages} catch_msg]
	    # Needed for updating title tag numbers.
            $STA configure -image $catch_msg
            if {$catch_resp == 0} {
                return $catch_msg
            } else {
                error $catch_msg
            }
        }

        # Add report summary table row for STA.
        set id [UTF::get_build_id $catch_msg]
        set notes [UTF::get_build_notes $catch_msg]
        set status [UTF::get_build_status $catch_msg $catch_resp]
        set ::summaryinfo [UTF::update_report_add $::summaryinfo $STA $(bin)\
	    $(statag) $(stadate) $id $notes $status]

        # Halt tests if STA image not found.
        if {$catch_resp != 0} {
            UTF::Try "Could not find $STA image" {
                error "Halting $STA test"
            }
            return
        }
    }

    # Load/reload/setup STA image.
    if {!$(nosetup) && !$(noinit)} {
        if {$(nostaload)} {
            if {!$(nostareload)} {
                UTF::Try "$STA: Reload STA Image" {
                    if {$(wet)} {
                        # For WET test, this is an AP.
                        UTF::reload_rtr $STA
                    } else {
			$STA reload
                    }
                }
            }
        } else {
            UTF::Try "$STA: Load STA Image" {
                if {$(wet)} {
                    # For WET test, this is an AP.
                    UTF::load_rtr_retry $STA
                } else {
		    $STA load
                }
            }

            # Update report header table with actual OS and HW versions.
            set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

            # Update report title with actual TAG numbers.
            UTF::update_report_title $STA
        }

        # User may want to let the lower level aci.test do all the STA setup.
        if {!$(nostahighlevelsetup)} {
            UTF::Try "$STA: Set STA Defaults" {
                if {!$(wet)} {
                    $STA services stop
                    catch {$STA wl msglevel +error +assoc}
                    catch {$STA wl down}
                    # Enable 40 in 2.4, if available.
                    catch {$STA wl mimo_bw_cap 1}
                    $STA wl up
                    UTF::Sleep 1
                    $STA wl ver
                } else {
                    $STA nvram get os_version ;# WET AP
                }

                set hw_ver [$STA chipname]
                regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
                return $hw_ver
            }
        }
    }

    # Determine which bands are supported by STA.
    set catch_resp [catch "set sta_bands \[$STA wl bands\]" catch_msg]
    if {$catch_resp != 0} {
        UTF::Try "Could not get $STA bands" {
            error "Halting $STA test: $catch_msg"
        }
        return
    }

    # For muSTA, find image, load driver and set it up
    if {$(musta) != ""} {
        foreach MUSTA $(musta) {
            UTF::Try "$MUSTA: Find muSTA Image" {
                set catch_resp [catch {$MUSTA findimages} catch_msg]
                $MUSTA configure -image $catch_msg
                if {$catch_resp == 0} {
                    return $catch_msg
                } else {
                    error $catch_msg
                }
            }

            # Add report summary table row for muSTA
            set id [UTF::get_build_id $catch_msg]
            set notes [UTF::get_build_notes $catch_msg]
            set status [UTF::get_build_status $catch_msg $catch_resp]
            set ::summaryinfo [UTF::update_report_add $::summaryinfo $MUSTA $(bin)\
		$(statag) $(stadate) $id $notes $status]

            # Halt tests if muSTA image not found
            if {$catch_resp != 0} {
                UTF::Try "Could not find $MUSTA image" {
                    error "Halting $MUSTA test"
                }
                return
            }

            # Load muSTA
            UTF::Try "$MUSTA: Load Image" {
		$MUSTA load
            }

            # Update the report header table with actual OS and HW versions
            set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

            # Update report title with actual TAG numbers
            UTF::update_report_title $MUSTA

            # Setup muSTA
            UTF::Try "$MUSTA: Set Defaults" {
                $MUSTA services stop
                catch {$MUSTA wl msglevel +error +assoc}
                catch {$MUSTA wl down}
                catch {$MUSTA wl mimo_bw_cap 1}
                $MUSTA wl up
                UTF::Sleep 1
                $MUSTA wl ver
                set hw_ver [$MUSTA chipname]
                regsub -all {\s} $hw_ver "_" hw_ver
                return $hw_ver
            }

            # Determine which bands are supported by the muSTA
            set catch_resp [catch "set musta_bands \[$MUSTA wl bands\]" catch_msg]
            if {$catch_resp != 0} {
                UTF::Try "Could not get $MUSTA bands" {
                    error "Halting $MUSTA test: $catch_msg"
                }
                return
            }
            UTF::Message LOG $MUSTA "musta_bands=$musta_bands"

            # Check disk utilization of all muSTA to be tested
            UTF::check_disk_usage "$MUSTA"
        }
    }

    # Now get AP bands.
    if {$::is_oem_ap == 0} {
        set ap_bands [$Router wl bands]
    } else {
        set ap_bands ""
    }
    UTF::Message LOG $STA "sta_bands=$sta_bands ap_bands=$ap_bands"

    # aci.test needs branch name when it calls get_stream.
    lappend ::branch_list [$STA branchname]
    UTF::Message LOG $STA "updated branch_list=$::branch_list"

    # Check disk utilization of all STA to be tested.
    UTF::check_disk_usage "$Router $STA $(sniffer) $(intsta)"

    # proc main_aci_multiapaci test loop starts here.
    if {$(titleap)} {
        set focus $Router
    } else {
        set focus $STA
    }
    update_summaries ver $focus $(softap) $(titleap)
    for {set i 0} {$i < $(loop)} {incr i} {
        if {!$(noinit) && $::is_oem_ap == 0} {
            UTF::Try "Setup $Router: $(security) security" {
                UTF::Test::APConfigureSecurity $Router -security $(security)
            }
        }

        # Scan all channels if appropriate.
        if {$(channels) && ![$STA cget -nochannels]} {
            if {$::is_oem_ap == 0} {
            	# BRCM RealAP/SoftAP
                UTF::Test::ChannelSweep $Router $STA -msg $STA
            } else {
                # OEM AP
                error "No control over OEM AP channel used!"
            }
        }

        # Do RvR tests if appropriate.
        if {!$(norvr)} {
            # Do cycle RvR tests if appropriate.
            if {!$(nocyclervr)} {
                # Setup common command string for aci.test.
                set cmd "UTF::Test::aci $Router $STA -musta \"$(musta)\" -sniffer \"$(sniffer)\"\
		    -va \"$(va)\" -perfloop \"$(perfloop)\" -perfsize \"$(perfsize)\"\
		    -perftime \"$(perftime)\" -test \"$(test)\" -attnstep \"$(attnstep)\"\
		    -pathloss \"$(pathloss)\" -timeout \"$(timeout)\" -security \"$(security)\"\
		    -attngrp \"$(attngrp)\" -window \"$(window)\" -history \"$(history)\" -udp \"$(udp)\"\
		    -udpopt \"$(udpopt)\" -min \"$(min)\" -max \"$(max)\" -intnrate \"$(intnrate)\"\
		    -intrate \"$(intrate)\" -intsta \"$(intsta)\" -inttype \"$(inttype)\"\
		    -intgap \"$(intgap)\" -intsize \"$(intsize)\" -steplist \"$(steplist)\"\
		    -steploop \"$(steploop)\" -pingmax \"$(pingmax)\" -sniffercapture \"$(sniffercapture)\"\
		    -ringfilecnt \"$(ringfilecnt)\" -ringfilesize \"$(ringfilesize)\""

                # Add binary options to command string.
                if {$(allhooks)} {
                    append cmd " -allhooks"
                }
                if {$(chanint)} {
                    append cmd " -chanint"
                }
                if {$(edithooks)} {
                    append cmd " -edithooks"
                }
                if {$(fastrampup)} {
                    append cmd " -fastrampup"
                }
                if {$(fb0)} {
                    append cmd " -fb0"
                }
                if {$(fb1)} {
                    append cmd " -fb1"
                }
                if {$(forcesniffercapture)} {
                    append cmd " -forcesniffercapture"
                }
                if {$(fullrange)} {
                    append cmd " -fullrange"
                }
                if {$(fullrampup)} {
                    append cmd " -fullrampup"
                }
                if {$(intgraph)} {
                    append cmd " -intgraph"
                }
                if {$(intquiet)} {
                    append cmd " -intquiet"
                }
                if {$(iperfnobeacons)} {
                    append cmd " -iperfnobeacons"
                }
                if {$(keepgoing)} {
                    append cmd " -keepgoing"
                }
                if {$(mingraphs)} {
                    append cmd " -mingraphs"
                }
                if {$(noattnchange)} {
                    append cmd " -noattnchange"
                }
                if {$(nobtreset)} {
                    append cmd " -nobtreset"
                }
                if {$(nographs)} {
                    append cmd " -nographs"
                }
                if {$(nohistograms)} {
                    append cmd " -nohistograms"
                }
                if {$(nohooks)} {
                    append cmd " -nohooks"
                }
                if {$(noinit)} {
                    append cmd " -noinit"
                }
                if {$(nomalloc)} {
                    append cmd " -nomalloc"
                }
                if {$(nopretest)} {
                    append cmd " -nopretest"
                }
                if {$(noredundant)} {
                    append cmd " -noredundant"
                }
                if {$(nosetuptestbed)} {
                    append cmd " -nosetuptestbed"
                }
                if {$(nosymmetry)} {
                    append cmd " -nosymmetry"
                }
                if {$(rampdownonly)} {
                    append cmd " -rampdownonly"
                }
                if {$(rampuponly)} {
                    append cmd " -rampuponly"
                }
                if {$(refreshaddralways)} {
                    append cmd " -refreshaddralways"
                }
                if {$(refreshaddrasneeded)} {
                    append cmd " -refreshaddrasneeded"
                }
                if {$(softap)} {
                    append cmd " -softap"
                }
                if {$(stoponerror)} {
                    append cmd " -stoponerror"
                }
                if {$(stopslowrampup)} {
                    append cmd " -stopslowrampup"
                }
                if {$(titleap)} {
                    append cmd " -titleap"
                }
                if {$(trenderrors)} {
                    append cmd " -trenderrors"
                }
                if {$(comparesta)} {
                    append cmd " -comparesta"
                }
                if {$(comparestaoneloop)} {
                    append cmd " -comparestaoneloop"
                }
                if {$(compareap)} {
                    append cmd " -compareap"
                }
                if {$(txbf)} {
                    append cmd " -txbf"
                }
                if {$(warmup)} {
                     append cmd " -warmup"
                }
                if {$(wet)} {
                     append cmd " -wet"
                }

                # For OEM AP we dont have control over the channel used. So we just do one
                # set of tests, using whatever channel we find the OEM AP is currently using.
                if {$::is_oem_ap == 1} {
                    if {!$(downstreamonly)} {
                        eval $cmd -direction Up -chanspec "TBD" -attnlist \"$(oemAttnRange)\" -oemband \"$(oemband)\"\
			    -intattn \"$(intattnoem)\" -intchan \"$(intchanoem)\" -intwl \"$(intwloem)\"
                        update_summaries start rvr
                    }
                    if {!$(upstreamonly)} {
                        eval $cmd -direction Down -chanspec "TBD" -attnlist \"$(oemAttnRange)\" -oemband \"$(oemband)\"\
			    -intattn \"$(intattnoem)\" -intchan \"$(intchanoem)\" -intwl \"$(intwloem)\"
                        update_summaries end rvr
                    }
                }

                # Band A, BRCM RealAP/SoftAP
                if {[string match -nocase *a* $sta_bands] && [string match -nocase *a* $ap_bands] && $::is_oem_ap == 0} {
                    # 5G80 channel defaults to null. User must specify explicitly.
                    foreach ch $(chan5G80) {
                        set ::last_txbfm_counter 0
                        set ::last_txndp_counter 0
                        set ::last_rxsf_counter  0

                        UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                        if {$(stoponerror) && $::stop_tests == "yes"} {
                           error "$STA stopping tests due to previous error"
                        }
                        if {!$(downstreamonly)} {
                            eval $cmd -direction Up -chanspec $ch -attnlist \"$(cycle5G80AttnRange)\"\
				-intattn \"$(intattn5G80)\" -intchan \"$(intchan5G80)\" -intwl \"$(intwl5G80)\"
                            update_summaries start rvr
                        }
                        UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                        if {$(stoponerror) && $::stop_tests == "yes"} {
                           error "$STA stopping tests due to previous error"
                        }
                        if {!$(upstreamonly)} {
                            eval $cmd -direction Down -chanspec $ch -attnlist \"$(cycle5G80AttnRange)\"\
				-intattn \"$(intattn5G80)\" -intchan \"$(intchan5G80)\" -intwl \"$(intwl5G80)\"
                            update_summaries end rvr
                        }
                    }
                    if {!$(no5G40)} {
                        foreach ch $(chan5G40) {
			    set ::last_txbfm_counter 0
			    set ::last_txndp_counter 0
			    set ::last_rxsf_counter  0		

                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(downstreamonly)} {
                                eval $cmd -direction Up -chanspec $ch -attnlist \"$(cycle5G40AttnRange)\"\
				    -intattn \"$(intattn5G40)\" -intchan \"$(intchan5G40)\" -intwl \"$(intwl5G40)\"
                                update_summaries start rvr
                            }
                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(upstreamonly)} {
                                eval $cmd -direction Down -chanspec $ch -attnlist \"$(cycle5G40AttnRange)\"\
				    -intattn \"$(intattn5G40)\" -intchan \"$(intchan5G40)\" -intwl \"$(intwl5G40)\"
                                update_summaries end rvr
                            }
                        }
                    }
                    if {!$(no5G20)} {
                        foreach ch $(chan5G20) {
                            set ::last_txbfm_counter 0
                            set ::last_txndp_counter 0
                            set ::last_rxsf_counter  0

                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(downstreamonly)} {
                                eval $cmd -direction Up -chanspec $ch -attnlist \"$(cycle5G20AttnRange)\"\
				    -intattn \"$(intattn5G20)\" -intchan \"$(intchan5G20)\" -intwl \"$(intwl5G20)\"
                                update_summaries start rvr
                            }
                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(upstreamonly)} {
                                eval $cmd -direction Down -chanspec $ch -attnlist \"$(cycle5G20AttnRange)\"\
				    -intattn \"$(intattn5G20)\" -intchan \"$(intchan5G20)\" -intwl \"$(intwl5G20)\"
                                update_summaries end rvr
                            }
                        }
                    }
                }

                # Band B, BRCM RealAP/SoftAP
                if {[string match -nocase *b* $sta_bands] && [string match -nocase *b* $ap_bands] && $::is_oem_ap == 0} {
                    if {!$(no2G40)} {
                        foreach ch $(chan2G40) {
                            set ::last_txbfm_counter 0
                            set ::last_txndp_counter 0
                            set ::last_rxsf_counter  0

                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(downstreamonly)} {
                                eval $cmd -direction Up -chanspec $ch -attnlist \"$(cycle2G40AttnRange)\"\
				    -intattn \"$(intattn2G40)\" -intchan \"$(intchan2G40)\" -intwl \"$(intwl2G40)\"
                                update_summaries start rvr
                            }
                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(upstreamonly)} {
                                eval $cmd -direction Down -chanspec $ch -attnlist \"$(cycle2G40AttnRange)\"\
				    -intattn \"$(intattn2G40)\" -intchan \"$(intchan2G40)\" -intwl \"$(intwl2G40)\"
                                update_summaries end rvr
                            }
                        }
                    }
                    if {!$(no2G20)} {
                        foreach ch $(chan2G20) {
                            set ::last_txbfm_counter 0
                            set ::last_txndp_counter 0
                            set ::last_rxsf_counter  0

                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(downstreamonly)} {
                                eval $cmd -direction Up -chanspec $ch -attnlist \"$(cycle2G20AttnRange)\"\
				    -intattn \"$(intattn2G20)\" -intchan \"$(intchan2G20)\" -intwl \"$(intwl2G20)\"
                                update_summaries start rvr
                            }
                            UTF::Message LOG $STA "(stoponerror)=$(stoponerror) ::stop_tests=$::stop_tests"
                            if {$(stoponerror) && $::stop_tests == "yes"} {
                               error "$STA stopping tests due to previous error"
                            }
                            if {!$(upstreamonly)} {
                                eval $cmd -direction Down -chanspec $ch -attnlist \"$(cycle2G20AttnRange)\"\
				    -intattn \"$(intattn2G20)\" -intchan \"$(intchan2G20)\" -intwl \"$(intwl2G20)\"
                                update_summaries end rvr
                            }
                        }
                    }
                }
            }
        }

	# If we only want 1 loop for first STA, we get out the _for_ loop here.
	if {$(comparesta) && $(comparestaoneloop) && $(loop) > 0 && $::sta_counter == 0} {
	    UTF::Message LOG $::localhost "User requests only 1 loop for STA: $STA"  
	    #set i $(loop)
	    break
  	}

	# Keep track of test loop. Can be used elsewhere.
	incr ::loop_counter
	    
    } ;# End of proc main_aci_multiapaci test loop.

    # Create composite RvR graphs
    create_composite_graphs $focus $(nocomposite) $(nocompositemainpage) $(rampdownonly)\
	$(rampuponly) $(fastrampup) $(nographs) $(mingraphs) $Router $STA $(udp)

    # Dump the rampdown/rampup graphs on the main summary page.
    foreach file $::aci_list {
        set temp [file tail "$file"]
        UTF::Try "$focus $temp" {
            return "html: <img src=\"$file\">"
        }
    }

    # Close summary pages.
    update_summaries close


    # If requested, unload the driver.
    if {!$(nounload) && !$(noinit)} {
        UTF::Try "$STA: unload driver" {
            $STA unload
        }

	if {$(musta) != ""} {
	    foreach MUSTA $(musta) {
	    	UTF::Try "$MUSTA: unload driver" {
		    $MUSTA unload
		}
	    }
	}
    }
    catch {$STA deinit}

    if {$(musta) != ""} {
	foreach MUSTA $(musta) {
	    catch {$MUSTA deinit}
	}
    }
}

#============== proc setup_summaries ================================
# Proc setup_summaries initialize summary web pages and related 
# global variables.
#====================================================================
proc setup_summaries {AP STA nocyclervr nohistograms rampdownonly\
    rampuponly nocomposite fastrampup nosymmetry nomalloc chanint\
    titleap nographs mingraphs intsta intgraph comparesta compareap txbf} {

    # Get testrig name
    UTF::setup_config_testrig

    # Graphs may not be needed.
    set ::handle_title_list "" ;# used by other routines
    set ::aci_list "" ;# save list of rampdown/rampup graphs
    if {$nographs} {
        return
    }

    # The focus of the web page titles & graphs can be AP or STA. This allows
    # the user to choose the focus independantly, regardless of softap being
    # tested or not.
    if ($titleap) {
        set focus $AP
    } else {
        set focus $STA
    }

    UTF::Try "$focus Summary Graphs" {
        set SummaryLoc [file dirname "$UTF::Logfile"]
        set testnum [UTF::get_testnum]
        set ::saved_testnum $testnum ;# needed for composite graphs
        # puts "UTF::Logfile=$UTF::Logfile SummaryLoc=$SummaryLoc testnum=$testnum"
        set ::rvr_composite_input "" ;# data for composite graphs

        # Summmary pages created are based on flag nocyclervr.
        # There are many graphs from aci.
        # to be summarized. Put most important one first in list,
        # as that will be shown to users first.
        set ::handle_title_list "" ;# ensure variable always exists
        if {$nocyclervr == "0"} {

            # We may not have rampdown graphs.
            set ::handle_title_list ""
            if {$rampuponly == 0} {
               set ::handle_title_list "$::handle_title_list\
                   ::RVR0 RampdownThroughput"
            }
            if {$rampdownonly == 0 } {
                # If rampdownonly is off, we also have the rampdown/rampup
                # graphs and possibly the symmetry graphs.
                set ::handle_title_list "$::handle_title_list\
                    ::aci RampdownRampupThroughput"
                if {$nosymmetry == 0 && $fastrampup == 0 && $mingraphs == 0} {
                    set ::handle_title_list "$::handle_title_list\
                        ::RVR2 SymmetryThroughput"
                }
            }

            # We usually want these 5 AP/STA graphs
            if {$mingraphs == 0} {
                set ::handle_title_list "$::handle_title_list\
                    ::RVR3 ApNRate ::RVR4 ApTxRate\
                    ::RVR5 ApConnectTime ::RVR55 StaNRate ::RVR6 StaRssi\
                    ::RVR7 StaTxRate"
            }

            # Malloc fail & chanint graphs are optional
            if {$nomalloc == 0 && $mingraphs == 0} { 
                set ::handle_title_list "$::handle_title_list ::RVR8 StaMallocFail"
            }
            if {$chanint == 1 && $mingraphs == 0} { 
                set ::handle_title_list "$::handle_title_list ::RVR9 StaChanInt"
            }

            # We always want the Rejoin ControlCharts
            set ::handle_title_list "$::handle_title_list ::RVRA StaRejoin"

            # We always want the MCS/Legacy/Beacon ControlCharts
            set ::handle_title_list "$::handle_title_list ::RVRB StaMcsHi ::RVRC StaMcsLo ::RVRD StaBeacon"

            # We may not want histograms
            if {$nohistograms == 0 && $mingraphs == 0} {
                set ::handle_title_list "$::handle_title_list\
                    ::aci0 ApRxMcs ::aci1 ApTxMcs ::aci2 ApMpdu ::aci3 ApRxMcsSgi\
                    ::aci4 ApTxMcsSgi ::aci5 ApDelay ::aci6 ApCcdf ::aci7 ApPer\
                    ::RVR20 StaRxMcs ::RVR21 StaTxMcs ::RVR22 StaMpdu ::RVR23 StaRxMcsSgi\
                    ::RVR24 StaTxMcsSgi ::RVR25 StaDelay ::RVR26 StaCcdf ::RVR27 StaPer\
                    ::RVR30 ApRxVht ::RVR31 ApTxVht ::RVR32 ApRxVhtSgi ::RVR33 ApTxVhtSgi\
		    ::RVR33A ApVhtPer ::RVR34 StaRxVht ::RVR35 StaTxVht ::RVR36 StaRxVhtSgi\
		    ::RVR37 StaTxVhtSgi ::RVR38 StaVhtPer ::RVR39 TputMean ::RVR50 ApPktRetried\
		    ::RVR50A ApPktRetryRatio ::RVR51 ApPktRetryDropped ::RVR51A ApPktRetryDropRatio\
		    ::RVR52 ApTxbfm ::RVR53 ApTxndp ::RVR54 ApSfRatio ::RVR56 ApTemp ::RVR57 StaTemp"
            }

            # We may not want interference graphs
            if {($intsta != "" || $intgraph == 1) && $mingraphs == 0} {
                set ::handle_title_list "$::handle_title_list\
                    ::RVR40 ApRxBadFcs ::RVR41 ApRxBadPlcp ::RVR42 ApRxCrsGlitch\
                    ::RVR43 ApRxdFrmUcastMbss ::RVR44 ApRxStrt\
                    ::RVR45 StaRxBadFcs ::RVR46 StaRxBadPlcp ::RVR47 StaRxCrsGlitch\
                    ::RVR48 StaRxdFrmUcastMbss ::RVR49 StaRxStrt"
            }
        }

        # We may not want composite graphs.
        if {$nocyclervr == "0" && $nocomposite == 0 && $mingraphs == 0} {
            set ::handle_title_list "$::handle_title_list\
                ::COMP Composite"
        }

        # Always show ALL graphs; code expects ::ALL to be defined.
        set ::handle_title_list "$::handle_title_list ::ALL AllGraphs"

        # Add summary page headers.
        set title_links ""
        set result ""
        set composite_result ""
        foreach {handle title} $::handle_title_list {

            # Setup filename for summary. We prefer Rampdown/Rampup graphs for result.
            set file "${testnum}_${focus}_${title}.htm"
            if {$result == "" || $handle == "::aci"} {
                set result $file
            }

	    # Save up file name for composite graph page
            if {$composite_result == "" || $handle == "::COMP"} {
                set composite_result $file
            }

            # Open summary file, add html headers to file.
            set temp [open "$SummaryLoc/$file" w]
            set $handle $temp
            puts $temp "<head>"
            puts $temp "    <title>$::testrig MultiApAci $focus $title Summary</title>"
            puts $temp "</head>\n"
            puts $temp "<body>\n"
            flush $temp ;# leave handle open for more writes

            # Save a title link to this page. Add html break at selected points.
            # Not all items will be present, so add breaks before / after
            # items that are usually present.
            if {$handle == "::aci0"} {
                set title_links "$title_links <br>"
            }
            set title_links "$title_links <a href=\"$file\">$title</a>"
            if {$handle == "::RVR27" || $handle == "::RVR38" || $handle == "::RVR49"} {
                set title_links "$title_links <br>"
            }
        }

        # Add link so user can go back to detailed logfile.
        set title_links "$title_links <a href=\"$SummaryLoc/Summary.html\">DetailedLog</a>"

        # Add title_links & h2 to each page.
        foreach {handle title} $::handle_title_list {
            set temp [set $handle] ;# retrieve handle value
            puts $temp "<p>$title_links</p>"
            puts $temp "<h2>$::testrig MultiApAci $focus $title Summary</h2>\n"
            flush $temp ;# leave handle open for more writes
        }

	# Create symlink to composite graph page
	if {$comparesta} {
     	    set catch_resp [catch "file link -symbolic \"$SummaryLoc/link-$STA-Composite.htm\"\
		\"$SummaryLoc/$composite_result\"" catch_msg]
	} elseif {$compareap || $txbf} {
     	    set catch_resp [catch "file link -symbolic \"$SummaryLoc/link-$AP-Composite.htm\"\
		\"$SummaryLoc/$composite_result\"" catch_msg]
	}

        # Return link to first (thruput) summary page.
        if {$result == ""} {
            return "None!"
        } else {
            return "html:<a href=\"$result\">Graph Summaries</a>"
        }
    }
}

#============== proc update_summaries ===============================
# # Proc for updating summary web pages
#====================================================================
proc update_summaries {cmd args} {
    UTF::Message LOG $::localhost "update_summaries cmd=$cmd args=$args"
        
    # If necessary, log the device info on all summary files.
    # For cmd=ver, args are: device name, softap flag, titleap flag
    if {$cmd == "ver"} {
        set device [lindex $args 0]
        set softap [lindex $args 1]
        set titleap [lindex $args 2]

        # Get hardware info & clean it up.
        set hw_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set hw_ver "OEM"
        } else {
            set catch_resp [catch "set hw_ver \[$device whatami\]" catch_msg]
            if {[llength $hw_ver] > 1} {
                set hw_ver [lrange $hw_ver 1 end] ;# drop UTF object name
            }
        }
        regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification

        # Get host OS version
        set os_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set os_ver "OEM"
        } else {
            set catch_resp [catch "set os_ver \[UTF::check_host_os $device\]" catch_msg]
        }

        # Get driver software version
        set wl_ver ""
        if {$titleap} {
            if {$::is_oem_ap == 1} {
               set wl_ver "OEM"
            } else {
                if {$softap} {
                    # Soft AP
                    set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
                } else {
                    # Real AP
                    set catch_resp [catch "set wl_ver \[$device nvram get os_version\]" catch_msg]
                }
            }
        } else {
            # STA
            set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
        }

        # Add device info to each summary page
        UTF::Message LOG $::localhost  "hw_ver=$hw_ver os_ver=$os_ver wl_ver=$wl_ver"
        foreach {handle title} $::handle_title_list {
            set temp [set $handle] ;# retrieve handle value
            puts $temp "<p>$hw_ver &nbsp;&nbsp;&nbsp; $os_ver &nbsp;&nbsp;&nbsp; $wl_ver</p>"
            puts $temp "<table border=\"0\">"
            flush $temp ;# leave handle open for more writes
        }
        return
    }

    # If necessary, close all the summary files

    # Code for cmd=start|end
    # Add graphic(s) links based on args.
    
}

#============== Main MultiApAci test ===============================
UTF::Test MultiApAci {args} {
    UTF::Getopts "$::MultiApAci_getopts" "$::MultiApAci_help"
	set ::loop1_counter 0

    # The default attenuation ranges were based on Steve Lam's initial testrig.
    # To allow other people to customize the attenuation ranges to their own
    # testrig specific needs, this script will look for alternate default values
    # in the config file. As usual, values passed from the command line will take
    # precedance over the config file default values.
    set attn_var_def [list cycle5G40AttnRange "0-50 50-0" cycle5G20AttnRange "0-50 50-0"\
        cycle5G80AttnRange "0-50 50-0" cycle2G40AttnRange "20-75 75-20"\
        cycle2G20AttnRange "25-75 75-25" oemAttnRange "25-75 75-25"]
    foreach {variable default} $attn_var_def {
        # If command line has a non-blank value for the variable, we use that value, period.
        set ($variable) [string trim $($variable)]
        if {$($variable) != ""} {
            # puts "using command line value for $variable"
            continue
        }

        # If the config file has a non-blank value for the variable,
        # we use the testrig specific value.
        set temp1 "::${variable}"
        if {[info exists $temp1]} {
            set temp2 [set $temp1]
            set temp2 [string trim $temp2]
            if {$temp2 != ""} {
                set ($variable) $temp2
                continue
            }
        }

        # Use the orginal script default value, for lack of a better value.
        set ($variable) $default
    }

    # Display final attenuator ranges.
    foreach {variable default} $attn_var_def {
        UTF::Message LOG "" "($variable)=$($variable)"
    }

    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }

    # In case of conflicting options, make nosniffer override sniffer.
    if {$(nosniffer)} {
        set (sniffer) ""
    }

    # noinit implies nosetup. nosetup is for this script only.
    # noinit is passed to aci.test & has broader impact than nosetup.
    if {$(noinit)} {
        set (nosetup) 1
    }

    # Composite graphs no supported for steplist
    set (steplist) [string trim $(steplist)]
    if {$(steplist) != ""} {
        set (nocomposite) 1
    }

    # If specified, make sure attngrp exists.
    set (attngrp) [string trim $(attngrp)]
    if {$(attngrp) != ""} {
	 foreach ATTN $(attngrp) {
        UTF::check_host_os $ATTN
		}
    }

    # Ensure security is specified.
    set (security) [string trim $(security)]
    if {$(security) == ""} {
        set (security) open
    }

    # Set controlchart data cache option.
    if {$(nocache)} {
        set ::UTF::ControlChart::readonly 1
    }

    # Router could be a STA running softap code.
    set Router [lindex $(ap) 0]
    if {$(softap)} {
        # Dynamically set -ap flag so Router will be allowed to act as SoftAP.
        $Router configure -ap 1
    }
    set (softap) [UTF::is_softap $Router] ;# Is this a SoftAP?
    set ::is_oem_ap [UTF::is_oem_ap $Router] ;# Is this an OEM AP?

    set (sta) [string trim $(sta)]
    if {$(sta) == ""} {
        error "ERROR: Must specify at least one sta"
    }

    if {$(compareap) && $(titleap)} {
        error "ERROR: Can't use -compareap and -titleap at same time."
    }

    if {$(comparesta) && $(compareap)} {
        error "ERROR: Can't use -comparesta and -compareap at same time."
    }

    if {$(comparesta) && [llength $(sta)] != 2} {
        error "ERROR: STA comparison test requires 2 and only 2 STAs."
    }

    if {$(comparestaoneloop) && !$(comparesta)} {
        error "ERROR: Option -comparestaoneloop requires -comparesta."
    }

    if {$(compareap) && [llength $(ap)] != 2} {
        error "ERROR: AP comparison test requires 2 and only 2 APs."
    }

    if {$(txbf) && [llength $(ap)] != 2} {
        error "ERROR: TxBF test requires 2 and only 2 APs."
    }

    if {$(txbf) && [llength $(sta)] != 2} {
        error "ERROR: TxBF test requires 2 and only 2 STAs."
    }

    if {$(attnstep) < 1 && $(attnstep) != 0.5} {
	error "ERROR: Invalid -attnstep value: $(attnstep)"
    }

    if {$(musta) != "" && [llength $(musta)] > 4} {
	error "ERROR: MU-MIMO test only supports up to 4 STAs."
    }

    if {$(intsta) != ""} {
	if {[llength $(intwl2G20)] > 1 && [llength $(intwl2G20)] != $(loop)} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
	if {[llength $(intwl2G40)] > 1 && [llength $(intwl2G40)] != $(loop)} {
	    error "ERROR: Invalid loop number: $(loop)"
	}
	if {[llength $(intwl5G20)] > 1 && [llength $(intwl5G20)] != $(loop)} {
	    error "ERROR: Invalid loop number: $(loop)"
	}
	if {[llength $(intwl5G40)] > 1 && [llength $(intwl5G40)] != $(loop)} {
	    error "ERROR: Invalid loop number: $(loop)"
	}
	if {[llength $(intwl5G80)] > 1 && [llength $(intwl5G80)] != $(loop)} {
	    error "ERROR: Invalid loop number: $(loop)"
	}
    }

    if {$(intsta) != ""} {
	if {[llength $(intattn2G20)] > 2 && [llength $(intattn2G20)] != $(loop)+1} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
	if {[llength $(intattn2G40)] > 2 && [llength $(intattn2G40)] != $(loop)+1} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
	if {[llength $(intattn5G20)] > 2 && [llength $(intattn5G20)] != $(loop)+1} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
	if {[llength $(intattn5G40)] > 2 && [llength $(intattn5G40)] != $(loop)+1} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
	if {[llength $(intattn5G80)] > 2 && [llength $(intattn5G80)] != $(loop)+1} {
	    error "ERROR: Invalid loop number: $(loop)"
	} 
    }
	

    foreach STA $(sta) {
        if {$(wet)} {
            # AP is required for WET test.
            if {![UTF::is_ap $STA]} {
                error "ERROR: For WET test, need an AP in -sta setting, $STA is NOT an AP!"
            }
        } else {   
            UTF::check_sta_type $STA $::sta_type_list
        }
        if {$STA == $Router} {
            error "ERROR: Router=$Router EQ STA=$STA, need to use 2 different devices!"
        }
    }

    # If developer images were specified, they take precedance over tag & date.
    # Router options.
    foreach Router $(ap) {
    	if {$::is_oem_ap == 0} {
            if {$(trx) ne ""} {
            	$Router configure -image $(trx) -date {}
            } elseif {$(tag) != ""} {
            	# tag is depracated, prefer rtrtag.
             	$Router configure -tag $(tag) -date {}
            } elseif {$(rtrtag) != ""} {
            	$Router configure -tag $(rtrtag) -date {}
            }
    	}
    }

    # STA options
    foreach STA $(sta) {
        if {$(bin) != ""} {
            $STA configure -image $(bin) -date {}
        } elseif {$(statag) != ""} {
            $STA configure -tag $(statag) -date {}
        }

        # dhd_image option applies only to the DHD objects.
        if {$(stadhd) ne ""} {
            if {[UTF::check_host_type $STA DHD]} {
                $STA configure -dhd_image $(stadhd)
            }
        }
    
        # dongleimage option applies only to the WinDHD object.
        if {$(windhdbin) ne ""} {
            if {[UTF::check_host_type $STA WinDHD]} {
                $STA configure -dongleimage $(windhdbin)
            }
        }
    }

    # MUSTA options
    if {$(musta) != ""} {
	foreach MUSTA $(musta) {
	    if {$(bin) != ""} {
		$MUSTA configure -image $(bin) -date {}
	    } elseif {$(statag) != ""} {
		$MUSTA configure -tag $(statag) -date {}
	    }
	}
    }

    # Depracated date will override newer rtrdate & stadate options.
    # Done for backwards comptibility.
    if {$(date) != ""} {
        set (rtrdate) $(date)
        set (stadate) $(date)
    }

    # Add optional dates.
    if {$(rtrdate) != "" && $::is_oem_ap == 0} {
	foreach Router $(ap) {
            $Router configure -date $(rtrdate)
    	}
    }
    if {$(stadate) != ""} {
        foreach item $(sta) {
            $item configure -date $(stadate)
        }
    }

    # Get build name for use in report email subject.
    # When multiple STA are tested, they USUALLY use the same build.
    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(sta) 0]
    }   
    if {[set build [$item cget -image]] eq ""} {
        set build [$item cget -tag]
    }
    if {$build eq "NIGHTLY"} {
        set build "TOT"
    }

    # (branch) is used for comparison over time. For private builds
    # this should be specified explicitly so the tests know which
    # branch to test. (branch) defaults to auto.
    if {$(branch) eq ""} {
        if {[regexp {/} $build]} {
            error "Unable to determine branch name from build.  Please specify -branch"
        }
        set (branch) $build
    }

    # Truncate branch name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # aci.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list $build
    }

    # This script may be nested inside another higher level script. In this
    # case, setup_testbed_info may have already been run. It is also possible
    # that the lists of devices has been pared down to reduce the items being
    # tested. So we need to be careful and not modify the preparations made
    # by the higher level script.
    if {[info exists ::endpoint_device_list] &&\
        [info exists ::lan_peer_sta_list] &&\
        [info exists ::wan_peer_sta_list]} {
        UTF::Message INFO "" "using existing setup_testbed_info"
        if {![info exists ::UTF::trailer_info]} {
            set ::UTF::trailer_info "<br>Missing testbed info!<br>"
        }
    } else {
        UTF::Message INFO "" "running setup_testbed_info"
        set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]
    }

    # Create empty summary table. If there is a higher level calling script,
    # UTF will keep the existing summary table & related object and ignore this script.
    set ::summaryinfo [UTF::setup_report_table]
    append ::summaryinfo "</table>"

    set email_subject [UTF::setup_email_subject $(title)]
    UTF::Message INFO "$::localhost" "email_subject=$email_subject"

    # Main test report web page starts here.
    UTF::WrapSummary $UTF::SummaryDir $email_subject $::summaryinfo $(email) {

        set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

        # Add a web link to the test.log file
        UTF::Try "Link to test.log" {
            return "html: <a href=\"./test.log\">test.log</a>"
        }

	# For comparison test, add additional web link to composite graph page for quick access purpose.
	# The empty .htm file will be symlinked to the real file later. 
	if {$(comparesta)} {
	    set staname [lindex $(sta) 1]
            UTF::Try "Link to Composite Graphs" {
            	return "html: <a href=\"./link-$staname-Composite.htm\">Composite Graphs</a>"
            }
	} elseif {$(compareap) || $(txbf)} {
	    set apname [lindex $(ap) 1] 
            UTF::Try "Link to Composite Graphs" {
            	return "html: <a href=\"./link-$apname-Composite.htm\">Composite Graphs</a>"
            }
	}

        # User may want to stop tests on first error
        set ::stop_tests "no" ;# will be set by aci.test as appropriate
        if {$(stoponerror)} {
            set ::recovery_max 0;# tells progressive_recovery not to do anything
        }

        # Check start/stop steps for continuous sniffer capture.
        UTF::check_sniffer_capture_steps $(sniffer) $(sniffercapture)

        # Setup testbed. Some users may turn off AP radios!!!
        if {!$(noinit) && !$(nosetup)} {
            UTF::setup_testbed
        }

        # UTF::Message LOG "" "pid=[pid]"

        # Set router text msg.
        #if {$(softap)} {
        #    set msg "SoftAP"
        #} else {
        #    set msg "Router"
        #}

        # restoreaponly implies noapload
        if {$(restoreaponly)} {
            set (noapload) 1
        }

        # For AP and STA comparison tests 
        set ::saved_ResultsFilenames ""
        set ::file_appended 0
        set ::sta_counter 0
	set ::ap_counter 0

	# Used for interference test
	set ::loop_counter 1

	# Check if attenuator supports 0.5dB attnstep.
	if {$(attnstep) == 0.5} {
	    set sta_tmp [lindex $(sta) 0]
	    set ap_tmp  [lindex $(ap)  0]
	    UTF::choose_attn_grp $(va) $(attngrp) $ap_tmp $sta_tmp
    	    set catch_resp [catch {$::rvr_attn_grp attn 0.5} catch_msg]
    	    if {$catch_resp == 0} {
            	UTF::Message LOG "" "Check attenuator for 0.5dB support: va=$(va)\
		    ::rvr_attn_grp=$::rvr_attn_grp catch_resp=$catch_resp catch_msg=$catch_msg"
    	    } else {
            	error "ERROR: User specified 0.5dB attnstep, but attenuator doesn't support it."
    	    }
	}

        foreach AP $(ap) {
            if {!$(noinit) && !$(nosetup) && $::is_oem_ap == 0} {
            	if {!$(noapload)} {
                    set catch_msg ""
                    UTF::Try "$AP: Find AP Image" {
                    	set catch_resp [catch {$AP findimages} catch_msg]
			# Needed for updating title.
                    	$AP configure -image $catch_msg
                        if {$catch_resp == 0} {
                            return $catch_msg
                        } else {
                            error $catch_msg
                        }
                    }

                    # Add report summary table row for AP.
                    set id [UTF::get_build_id $catch_msg]
                    set notes [UTF::get_build_notes $catch_msg]
                    set status [UTF::get_build_status $catch_msg $catch_resp]
                    set ::summaryinfo [UTF::update_report_add $::summaryinfo $AP $(trx)\
			$(rtrtag) $(rtrdate) $id $notes $status]

                    # Halt tests if AP image not found.
                    if {$catch_resp != 0} {
                    	UTF::Try "Could not find AP Image" {
                            error "Halting tests"
                    	}
                    	error "Halting tests"
                    }

                    UTF::Try "$AP: Load AP Image" {
			$AP load
                    }

                    # Update report header table with actual OS and HW versions.
                    set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

                    # Update report title with actual TAG numbers.
                    UTF::update_report_title $AP

		} elseif {!$(restoreaponly)} {
		    UTF::Try "$AP: Reload AP Image" {
			$AP reload
		    }
		}

		if {!$(norestore)} {
		    if {[$AP hostis Router Vx BSDAP DSL Airport]} {
		    	UTF::Try "$AP: Restore Defaults" {
			    $AP restore_defaults
			}
		    } else {
		    	UTF::Try "$AP: AP Hardware" {
			    set hw_ver [$AP chipname]
			    regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
			    return $hw_ver
			}
		    }
		}

                # If AP is not responding, halt tests.
                set catch_resp [catch "set resp \[$AP wl ver\]" catch_msg]
                if {$catch_resp != 0} {
                    error "$AP not responding, Halting tests! $catch_msg"
            	}
            }

            # Load optional interference STA.
            set (intsta) [string trim $(intsta)]
			foreach intsta $(intsta) {
            if {$intsta != ""} {
            	# Sanity checks on intsta.
            	if {$intsta == $AP} {
                    error "ERROR: STA interference device must not be the Router DUT !"
            	}
            	if {[lsearch -exact $(sta) $intsta] >= 0} {
                    error "ERROR: STA interference device must not be a STA DUT !"
            	}
            	if {[UTF::is_oem_ap $intsta]} {
                    error "ERROR: Must use BRCM device for STA interference tests, NOT $(intsta) !"
            	}

            	# Load intsta.
             	if {[UTF::is_ap $intsta]} {
                    # Load AP interference source
                    if {$(nointstaload)} {
                    	UTF::Try "$intsta ReLoad Interference Source" {
                            UTF::reload_rtr $intsta
                    	}
					}	
					if {!$(nointstaload)} {
					    UTF::Try "$intsta Load Interference Source" {
					         $intsta load
						 
						 }
						}	
					
                    
            	} elseif {[UTF::is_sta $intsta]} {
                    # Load STA interference source
                    # Separate nointstaload is for benefit of Sanity.test
                    if {!$(nointstaload) && !$(noinit)} {
                    	UTF::Try "$(intsta) Load Interference Source" {
                            UTF::load_sta_retry $STA
                    	}
                    }
            	} else {
                    error "ERROR: (intsta)=$intsta not valid AP or STA for interference source!"
            	}

            	# If requested, suppress messages from interference STA.
                if {$(intquiet)} {
                    catch "$intsta deinit"
             	}
				}
            }

            # Test each STA in list.
	    if {$(txbf)} {
		# With txbf option, we do tests in this pattern: AP1<->STA1, AP2<->STA2.
		# Therefore, we pick a STA depending on what AP we have.
		if {$::ap_counter == 0} {
		    # This is first AP so we use first STA
		    set STA [lindex $(sta) 0]
		} elseif {$::ap_counter == 1} {
		    # This is second AP so we use second STA
		    set STA [lindex $(sta) 1]
		}
                setup_summaries $AP $STA $(nocyclervr) $(nohistograms)\
                    $(rampdownonly) $(rampuponly) $(nocomposite) $(fastrampup)\
                    $(nosymmetry) $(nomalloc) $(chanint) $(titleap) $(nographs)\
                    $(mingraphs) $(intsta) $(intgraph) $(comparesta) $(compareap) $(txbf)
                # Call proc main_aci_multiapaci for each STA
                main_aci_multiapaci $AP $STA

	    } else {            
		# This is regular test and we loop through each STA.
            	foreach STA $(sta) {
            	    setup_summaries $AP $STA $(nocyclervr) $(nohistograms)\
                     	$(rampdownonly) $(rampuponly) $(nocomposite) $(fastrampup)\
                    	$(nosymmetry) $(nomalloc) $(chanint) $(titleap) $(nographs)\
                    	$(mingraphs) $(intsta) $(intgraph) $(comparesta) $(compareap) $(txbf)
            	    # Call proc main_aci_multiapaci for each STA
     	    	    main_aci_multiapaci $AP $STA

	    	    incr ::sta_counter
            	}
	    }

	    incr ::ap_counter

            # Unload softap driver if necessary.
            if {$(softap) && !$(nounload) && !$(noinit)} {
            	UTF::Try "$AP: unload driver" {
                    $AP unload
                }
            }
	} ;# end of foreach AP
	}

	# Posting to dbux
    	if {!$(nodbuxpost)} {
            UTF::Try "Post test info to dbux" {
            	if {$(bin) != ""} {
                    UTF::post_to_dbux $STA 1
            	} else {
                    UTF::post_to_dbux $STA 0
            	}
            }
			        }

        # Do optional post test analysis. The "" passes the unnamed options array.
        UTF::do_post_test_analysis MultiApAci.test ""

        # Update the report header table with end test time.
        set ::summaryinfo [UTF::update_report_testtime $::summaryinfo]
    
}

