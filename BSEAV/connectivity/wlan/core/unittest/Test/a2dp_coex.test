#!/bin/env utf
# -*-tcl-*-

# coex versoin of a2dp.test

# $Id$
# $Copyright Broadcom Corporation$
#

### based on a2dp_coex_dev.test_work_copy032713
### Main mod: maintain consistent definition of mstr and slv and
###			  separate definitions of dev1/dev2 from mstr/slv to allow for 
###  		  easier control of connection type change sequence, necessitated 
###			  by the new BT DUT behavior (checking BT Ref supported types prior 
###			  to any BT frame type change)
###			  (Note: This is so to work around the way ThruputBT.test is called.)

package require UTF::help
# Script help string
set ::a2dp_help "\n\nBasic usage: Test/a2dp_coex.test <options>\
    \n\nThis script runs isochronous traffic tests on your Coexistence test rig.\
    \nIt makes connections between your wireless devices & running numerous\
    \ntests. Your testbed is expected to have the standard Coexistence configuration\
    \nwith a WLAN router, WLAN traffic generator, a combo WLAN/BlueTooth device and\
    \nBlueTooth reference device. The tests use IPERF.\
    \n\nvalid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

set ::a2dp_getopts {
    {ap.arg ""       "WLAN router to test"}
    {bt.arg ""       "BT device to test"}
	{chanspec.arg ""    "AP channel, default channel is set by NVRAM"}
    {relay.arg ""    "BT device relay; overrides utfconf setting, if present"}
    {email.arg ""    "Email address list, format: userid1,userid2,... default is your userid"}
    {logdir.arg ""   "Log directory override"}
    {noapload        "Don't load the AP images, default is load the AP images"}
    {nobase          "Don't run baseline tests, default is to run baseline tests"}
    {nobid           "Don't run bidirectional tests, default is to run bidirectional tests"}
    {nobtload		 "Do not load BT build"}
    {nocache         "Don't update performance cache files"}
    {nocoex          "Don't run Coex tests, default is to run Coex tests"}
    {noBDR           "Don't run BDR tests, default is run BDR tests"}
    {noEDR           "Don't run EDR tests, default is run EDR tests"}
    {nomaster        "Don't run BTCohost as master, default is to run BTCohost as master"}
    {noslave         "Don't run BTCohost as slave, default is to run BTCohost as slave"}
    {nodesense       "Turn off BT desense, default is BT desense ON"}
    {noWAF           "Don't set Automatic Flush Timeout, default is to set Automatic Flush Timeout"}
    {sta.arg ""      "WLAN STA to test"}
    {stabin.arg ""	 "STA .sys or .bin image file, usefull for testing private builds"}
    {stoponwlanerr	 "Stop test on wlan error, default is NOT to stop"}
    {title.arg ""    "Title description text string for use in the reports, eg: \"Linux 4322USB dongle\""}
}

#########################################################
# -- to do --
#########################################################
#     {btcgr.arg ""    "BT image file, usefull for testing private builds"}
#     {btdate.arg ""   "Desired BT build date, format: yyyy.mm.dd, default=null"}
#     {btver.arg ""    "BlueTooth build version, default is \*"}
#     {bt_testbed_path_loss.arg "40" "BT Testbed fixed path lose in dB"}
#     {disassoc        "Disassociate STAs at end of tests. By default, the STAs may be left associated"}
#     {ext             "Use external builds"}
#     {full            "Reboot all hosts no matter what. Default is a conditional check & reboot."}
#     {handle_acl_master.arg "12"  "ACL handle for existing bt_master connection, default is to use handle stored in object"}
#     {handle_acl_slave.arg "11"  "ACL handle for existing bt_slave connection, default is to use handle stored in object"}
#     {history.arg 30  "History size for control charts"}
#     {iso.arg ""      "BT ACL isochronous packet type(s) for tests, default is to test both BDR & EDR packet types"}
#     {max.arg 300     "Expected maximum througput, -1 means no checks done"}
#     {min.arg 0       "Expected minimum througput, -1 means no checks done"}
#     {noapload        "Don't load the AP images, default is load the AP images"}
#     {nobid           "Don't run bidirectional tests, default is to run bidirectional tests"}
#     {nocache         "Don't update performance cache files"}
#     {nocheck         "Don't check the testbed, default is to run RebootTestbed"}
#     {nocollect       "Don't collect AP/STA default info, default is to collect this info"}
#     {noping          "Don't run ping/ayt tests, default is run the ping/ayt tests"}
#     {norx            "Don't run receive direction tests, default is to run receive tests"}
#     {notx            "Don't run transmit direction tests, default is to run transmit tests"}
#     {nosetup         "Don't setup the radios & connections, default is to setup the radios & connections"}
#     {nostaload       "Don't load the STA images, default is load the STA images"}
#     {perfint.arg 2   "Test interval in seconds for each test sample"}
#     {perfloop.arg 1  "Total performance test iterations for controlchart tests"}
#     {perfsize.arg 15 "Sample size for performance tests"}
#     {perftime.arg 30 "Total time duration, in seconds, for performance tests"}
#     {retry.arg 3     "Number of times to try rebooting an unresponsive host"}
#     {rtrdate.arg ""  "Desired Router build date, format: yyyy.mm.dd|CURRENT|TODAY|\\\*, default=CURRENT"}
#     {rtrdef.arg ""   "Default Router STA for connections - not used"}
#     {rtrtag.arg ""   "Router release tag, default is NIGHTLY"}
#     {rtrtrx.arg ""   "Router image file, usefull for testing private builds"}
#     {setup           "Runs the setup method for each device in the testbed that uses SSH"}
#     {showenv         "Show environment variables in the log file"}
#     {stabin.arg ""   "STA .sys or .bin image file, usefull for testing private builds"}
#     {stadate.arg ""  "Desired STA build date, format: yyyy.mm.dd|CURRENT|TODAY|\\\*, default=CURRENT"}
#     {stadhd.arg ""   "STA .ko linux DHD file, usefull for testing private builds"}
#     {statag.arg ""   "STA release tag, default is NIGHTLY"}
#     {title.arg ""    "Title description text string for use in the reports, eg: \"Linux 4322USB dongle\""}
#     {va.arg ""       "Variable attenuator to use, default is to use first one defined in config file, if any"}
#     {window.arg 512k "Window size for iperf tests, does not impact Mimo/EmbeddedNightly tests"}

# Setup online help info.
UTF::setup_help $::a2dp_help $::a2dp_getopts

# load required packages
package require UTF
package require UTF::utils
package require UTF::WinBT
package require UTF::Test::ConnectBTdevices
package require UTF::Test::ThruputBT_dev
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec

# # get opts and set variables
UTF::Test a2dp {args} {
	# Basic command line option processing. Options are stored in the
	# unnamed array $()
	UTF::Getopts "$::a2dp_getopts" "$::a2dp_help"
	
	# To support testing of more build variations in the same config file,
	# which includes clone objects, the user can override the default STA
	# in the config file.
	if {$(ap) != ""} {
	    set ::wlan_rtr $(ap)
	}
	if {$(bt) != ""} {
	    set ::bt_dut $(bt)
	}
	if {$(sta) != ""} {
	    set ::wlan_dut $(sta)
	}
	if { [$(sta) hostis] == "HSIC" || [$::wlan_dut hostis] == "HSIC" } {
	   set hFlg 1
	   puts "This is an HSIC device. hFlg value is set to: $hFlg\n"
	   } else {
	   set hFlg 0
	   puts "This is a non-HSIC device. hFlg value is set to: $hFlg\n"
	   }
	   
	
	    if { $hFlg == 1 } {
		   if {$(relay) != ""} {
			  set ::wlan_relay $relay
		      } else {
			      if { ! [ info exists ::wlan_relay ] } {
				      set ::wlan_relay [ $(sta) cget -relay ] }
			      }
		   } else {
		      # remove ::wlan_relay for non-HSIC cases, even if given
		      if { [ info exists ::wlan_relay ] } {
		       UTF::Message DEBUG "" "\n\n::wlan_relay defined in utfconf where it is not required for non-HSIC platform. Removing ${::wlan_relay}...\n\n"
			   unset ::wlan_relay
		   }
		      if { $(relay) != "" } {
		       error "\n\n\-relay option used where it is not required for non-HSIC platform. Remove \-relay option and try again...\n\n"
		   }		      
		}
	
	#  puts "\$\::bt_dut is set to $::bt_dut\n"; error "Show bt device" ;# debug statement
	
	# The Coexistence config file is expected to map specific objects to
	# higher level names. We verify that the required names point to STA 
	# objects of the correct UTF type. Specify the required variable names
	# along with one or more object types, types delimited by "|".
	
	if  { $hFlg == 1 } {
	set coex_list "::bt_dut WinBT ::bt_ref WinBT ::wlan_dut DHD|HSIC|MacOS\
	    ::wlan_rtr Router ::wlan_tg Linux ::wlan_relay DHD"
	    } else {
	set coex_list "::bt_dut WinBT ::bt_ref WinBT ::wlan_dut DHD|HSIC|MacOS\
	    ::wlan_rtr Router ::wlan_tg Linux"
	    }
	    
	set error_cnt 0
	foreach {var type} $coex_list {
	
	    # Check var is defined
	    set catch_resp [catch "set $var" catch_msg]
	    # puts "catch_resp=$catch_resp catch_msg=$catch_msg" ;# debug statement
	    if {$catch_resp != 0} {
	        incr error_cnt
	        UTF::Message ERROR "" "Your UTF config file is missing variable\
	            $var, which needs to specify a STA of type $type"
	        continue
	    }
	    # Check var is a STA of the desired type.
	    set sta_name [set $var] ;# dereference var
	    regsub -all {\|} $type " " type ;# convert type to space separated list
	    # puts "sta_name=$sta_name type=$type" ;# debug statement
	    set catch_resp [catch "UTF::check_sta_type $sta_name \"$type\"" catch_msg]
	    # puts "catch_resp=$catch_resp catch_msg=$catch_msg" ;# debug statement
	    if {$catch_resp != 0} {
	        incr error_cnt
	        UTF::Message ERROR "" "$catch_msg"
	        continue
	    }
	}
	
	# Exit if any errors were found in the config file.
	if {$error_cnt > 0} {
	    UTF::Message ERROR "" "Please update your UTF config file and try again!"
	    exit 1
	}
	
	#  initialize variables
	global env
	set mstr $::bt_dut
	set slv $::bt_ref
	set ::mstr_bt_comm [$mstr cget -bt_comm]
	set ::slv_bt_comm [$slv cget -bt_comm]
	set ::highspeed 3000000
	set ::normalspeed 115200
	set ::iso_intvl 20
	set ::iso_delay 100
	set ::block_size 840
	set ::timeout_value 0 ;# original value = 120, Coex SVT use "0" --> infinite
	set ::priority_level "high"
	set ::max_association_tries 3
	set ::noWAF 0
	
	# set chgPktType "common/ChangeConnectionPacketType.pl"
	set ::chgPktType "change_bt_packet_type" ;# calling function from within WinBT
	set ::wAFTimeout "common/WriteAutomaticFlushTimeout.pl"
	set ::wPriority "common/WriteHighPriorityConnection.pl"
	
	if { $(logdir) == "" } {
			set ::UTF::SummaryDir "$::UTF::SummaryDir"
	}
	
	if { $(nocache) } {
		UTF::Message INFO "" "No cache update."
		set ::UTF::ControlChart::readonly 1
		} else {
		UTF::Message INFO "" "Cache update chosen."
		set ::UTF::ControlChart::readonly 0
	}
	
	set ::sepStr "-------------------------------------------------\n"
	
	set ::bdr_pkt_type "no*2-DH1_no*3-DH1_DM1_DH1_no*2-DH3_no*3-DH3_DM3_DH3_no*2-DH5_no*3-DH5_DM5_DH5"
	set ::edr_pkt_type 0
	
	# profile 0: BT baseline; profile 2: BT/WLAN coex
	set ::profiles "0 2"
	
	UTF::Message LOG "" "$::sepStr \nValue of nocoex: $(nocoex)\n$::sepStr"
	if { $(nocoex) } {
		set ::profiles "0"
	} else {
		if { $(nobase) } {
		set ::profiles "2"
		}
	}
	UTF::Message LOG "" "$::sepStr \nprofiles set to: $::profiles\n$::sepStr"
	# error "Exit nocoex check." ;# debug statement
	
	if { $(nobid) } {
		set ::wlan_dirs "dut2tg tg2dut"
		} else {	
		set ::wlan_dirs "dut2tg tg2dut bidirectional"
	#    set ::wlan_dirs "dut2tg" ;# for development only
	}
	# UTF::Message LOG "" "nobid value set to $(nobid); ::wlan_dirs set to $::wlan_dirs" ;# debug statement
	# error "Exit nobid check." ;# debug statement
	
	# set summary title base on selected test
	if { $(title) == "" } {
		if { $(nocoex) } {
			set sumTtl "Baseline A2DP Simulations"
		} else {
			if { $(nobase) } {
				set sumTtl "Coex A2DP Simulations"
			} else {
				set sumTtl "Baseline and Coex A2DP Simualtions"
			}
		}
	} else {
		set sumTtl $(title)
	}
	
	if { $(noWAF) } {
	# 	puts "noWAF is $(noWAF)" ;# debug statement
		set ::noWAF 1
	# 	puts "noWAF is $(noWAF); ::noWAF is $::noWAF" ;# debug statement
	}
							  
	# Set email subject & report title.
	# set email_subject [UTF::setup_email_subject $(title)]
	
	# # end get opts and set variables
	
	###############################################################
	# # # 
	# # # procedures
	# # # 
	###############################################################
	# proc setComm
	# proc get_bd_addr
	# proc get_bt_hndls
	# proc bt_load
	# proc bt_conn
	# proc wlan_load
	# proc wlan_conn
	# proc set_a2dp
	# proc run_tput
	# proc chg_pkt_type
	# proc reset_bt
	# proc del_bt_hndls
	# proc run_a2dp
	# proc get_dev_setting
	# proc set_dev_setting
	
	#-------------------------------------------------------
	# proc setComm
	#	setting bt DUT com port speed
	#-------------------------------------------------------
	proc setComm {dev comm speed} {
		set resp [catch "$dev run_perl_script bt_cohost/UpdateBaudRate.pl $comm $speed"]
		return $resp
	}
	
	#-------------------------------------------------------
	# proc wlan_load
	#	loading WLAN driver then connect WLAN devices
	#-------------------------------------------------------
	proc wlan_load {dut rtr args} {
	
		UTF::Try "Loading WLAN driver" {
			
			if {[llength $args] eq 1} {
			   set stabin [lindex $args 0]
			   set ldCode [catch {$dut load -stabin $stabin} ldMsg]
		    } else {
			   set ldCode [catch {$dut load} ldMsg]
		    }
			UTF::Message LOG "" "ldCode returned value:  $ldCode\n"
			if { [regexp "0" $ldCode] } {
				wlan_conn $rtr $dut
				set conn_info [get_conn_info $rtr $dut]
				return $conn_info
			} else {
				set errMsg "WLAN driver load failed"
				UTF::Message FAIL "" $errMsg 
				error $errMsg
			}					
		}
	# 	return $ldCode
	}
	
	
	#-------------------------------------------------------
	# proc wlan_conn
	#	connecting wlan AP and STA
	#-------------------------------------------------------
	proc wlan_conn {ap sta {retry 3}} {
		UTF::Try "Connecting WLAN devices" {
			foreach {STA AP} "$sta $ap" {
	
				for {set k 1} {$k <= $retry} {incr k} {
					UTF::Message INFO "" "Open Connection $AP $STA Try: $k"
					set catch_resp [catch "UTF::Test::ConnectAPSTA \"$AP\" \
						\"$STA\" -security open" catch_msg]
					if {$catch_resp == 0} {
						UTF::Message LOG "" "Open Connection $AP\
						   $STA Try: $k OK: $catch_msg"
						break
					} else {
						UTF::Message ERROR "" "Open Connection $AP\
							$STA Try: $k failed: $catch_msg"
					}
				}
			}
		return $catch_msg
		}
	}
	
	#-------------------------------------------------------
	# proc get_conn_info
	#	getting wlan AP and STA connection info
	#-------------------------------------------------------
	proc get_conn_info {ap sta {retry 3}} {
		
	# Check status & rssi.
	    foreach {STA AP} "$sta $ap" {
			set WLAN_RTR_RSSI [UTF::get_ap_rssi $AP $STA]
			if {[catch "set ::WLAN_DUT_CHAN \[$STA wl chanspec\]" catch_msg]} {
				set ::WLAN_DUT_CHAN ""
			}
			
			if {[catch "set WLAN_DUT_RSSI \[$STA wl rssi\]" catch_msg]} {
				set WLAN_DUT_RSSI ""
			}
		}
		
		return "WLAN_RTR_RSSI=$WLAN_RTR_RSSI\
			WLAN_DUT_RSSI=$WLAN_DUT_RSSI\
	        WLAN_DUT_CHAN=$::WLAN_DUT_CHAN"
	        
	}
	
	#-------------------------------------------------------
	# proc bt_load
	#	loading bt firmware
	#-------------------------------------------------------
	proc bt_load {dut} {
		# set err_Cnt 0
		catch "$dut reload" btLdMsg
		if { [regexp "brcmlib" $btLdMsg] } {
			# set err_Cnt [ expr $err_Cnt + 1 ]
			UTF::Message FAIL "" "Load BT image failed."
			error "Message $btLdMsg. Cannot load WLAN driver. Test abort.\n"
			} else {
			UTF::Message LOG "" "BT firmware load successful."
			}
		return $btLdMsg		
	}
	
	#-------------------------------------------------------
	# proc bt_conn
	#	connecting bt DUT and Ref
	#-------------------------------------------------------
	proc bt_conn {dev1 dev2} {
		UTF::Try "Connecting master $dev1 and slave $dev2" {
			set conn_resp [catch "UTF::Test::ConnectBTdevices $dev1 $dev2" conn_msg]
			
		if { $conn_resp != 0 } {
			set errMsg "BT connection $dev1 $dev2 failed.\n"
			UTF::Message FAIL "" $errMsg
			error $errMsg
			return $errMsg
		} else {
	 		UTF::Message LOG "" "BT connection $dev1 $dev2 OK; $conn_msg" 
	        return $conn_msg
		}
	  }
	}
	
	#-------------------------------------------------------
	# proc chg_pkt_type
	#	setting bt packet types; calls WinBT function
	#-------------------------------------------------------
	proc chg_pkt_type {dev type hndl} {
		global ::chgPktType
	
		$dev $::chgPktType $hndl $type 
		
		}
	
	#-------------------------------------------------------
	# proc set_a2dp
	#	setting bt parameters for isochronous tests
	#	steps:
	# 		ChangeConnectionPacketType
	# 		WriteHighPriorityConnection
	# 		WriteAutomaticFlushTimeout
	#-------------------------------------------------------		
	proc set_a2dp {testType dev1 dev2 dev1_comm dev2_comm dev1_hndl dev2_hndl} {
		global ::noWAF
		global ::sepStr
		global ::priority_level
		global ::wPriority
		global ::wAFTimeout
		global ::timeout_value
		
		UTF::Try "Changing Slave Packet Types to $testType" {
			set chg_type [catch "chg_pkt_type $dev2 $testType $dev2_hndl" chg_msg]
			
			if { $chg_type != 0 } {
				UTF::Message FAIL "$dev2" "Change Connection Packet Type failed."
			} else {
				UTF::Message LOG "$dev2" "Change Connection Packet Type successful."
			}
			UTF::Sleep 2
		}
		
		UTF::Try "Disable scanning in $dev2" {
			$dev2 run_perl_script common/InitScan.pl $dev2_comm 0
		}
		
		UTF::Try "Writing high priority connections" {
			UTF::Message LOG $dev1 "Writing high priority connecitons and Automatic Flush Timeout... \n\n"
			set mstr_wP [catch "$dev1 run_perl_script $::wPriority $dev1_comm $dev1_hndl $::priority_level" wp_msg1]
			UTF::Message LOG $dev1 $::sepStr
			UTF::Message LOG $dev1 "mstr_wP: $mstr_wP\nwp_msg1: $wp_msg1\n$::sepStr"
			if { $mstr_wP ne 0 } {UTF::Message FAIL $dev1 "\nWriteHighPriorityConnection for Master failed...\n"}
			UTF::Sleep 1
			
			set slv_wP [catch "$dev2 run_perl_script $::wPriority $dev2_comm $dev2_hndl $::priority_level" wp_msg2]
			UTF::Message LOG $dev2 $::sepStr
			UTF::Message LOG $dev2 "slv_wP: $slv_wP\nwp_msg2: $wp_msg2\n$::sepStr"
			if { $slv_wP ne 0 } {UTF::Message FAIL $dev2 "\nWriteHighPriorityConnection for Slave failed...\n"}
			UTF::Sleep 2
		}
		
		# skipped at BT dev team recommendation as workaround for Bit_Errors
		# to skip write automatic flush timeout, use -noWAF option at command line
		if { $::noWAF != 0 } {
		UTF::Try "Writing automatic flush timeout" {
			# UTF::Message INFO "" "This is noWAF branch." ;# debug statement	
			set skipMsg "WriteAutomaticFlushTimeout skipped..."
			UTF::Message INFO "" "$skipMsg"
			return $skipMsg
			UTF::Sleep 2
			}
		} else { 
			# UTF::Message INFO "" "This is WAF branch" ;# debug statement
			UTF::Try "Writing automatic flush timeout" {
				set mstr_aft [catch "$dev1 run_perl_script $wAFTimeout $dev1_comm $dev1_hndl $timeout_value" aft_msg1]
				UTF::Message LOG $dev1 $sepStr
				UTF::Message LOG $dev1 "mstr_aft: $mstr_aft\naft_msg1: $aft_msg1\n$sepStr"
				if { $mstr_aft ne 0 } {UTF::Message FAIL $dev1 "\nWriteAutomaticFlushTimeout for Master failed...\n"}
				UTF::Sleep 1
				
				set slv_aft [catch "$dev2 run_perl_script $wAFTimeout $dev2_comm $dev2_hndl $timeout_value" aft_msg2]
				UTF::Message LOG $dev2 $sepStr
				UTF::Message LOG $dev2 "slv_aft: $slv_aft\naft_msg2: $aft_msg2\n$sepStr"
				if { $slv_aft ne 0 } {UTF::Message FAIL $dev2 "\nWriteAutomaticFlushTimeout for Slave failed...\n"}
				UTF::Sleep 2
				}
		}
	}
	
	#-------------------------------------------------------
	# proc reset_bt
	#	reset bt DUT and Ref
	#-------------------------------------------------------
	proc reset_bt {dev1 dev2 dev1_comm dev2_comm} {
		global ::sepStr
		
		foreach dev {$dev2 $dev1} {
		# puts $::sepStr ;# debug statement
		# puts "device dev value $dev\n"
		# puts $::sepStr ;# end debug statements
			if { $dev == {$dev2} } { set ttlStr "Slave" } else { set ttlStr "Master" }
			UTF::Try "Resetting $ttlStr" {
				set rstDev [catch "$dev run_perl_script common/Reset.pl ${dev}_comm" devRstMsg]
				if { $rstDev ne 0 } {return "\n$dev reset failed...\n$devRstMsg\n"} 
			}
		UTF::Sleep 2
		}
		
	}
	
	#-------------------------------------------------------
	# proc get_bt_addr
	#	get bt addresses for DUT and Ref
	#-------------------------------------------------------
	proc get_bt_addr {dev1 dev2} {
		
		UTF::Try "Getting BT BD_ADDR of test devices" {
			set devAddrList ""
			foreach dev {$dev1 $dev2} {
				for {set i 0} {$i <= 2} {incr i} {
					set devResp [catch "$dev get_board_address" dev_BD_ADDR]
					if {$devResp !=0} { ;# retry
						# UTF::Message DEV "" "devResp is: $devResp; dev_BD_ADDR: $dev_BD_ADDR; attempt: $i"
						UTF::Sleep 3
					} else { ;# successful
						UTF::Message DEV "" "devResp is: $devResp; dev_DB_ADDR: $dev_BD_ADDR; attemp: $i"
						append devAddrList "$dev_BD_ADDR "
						# UTF::Message DEV "" "devAddrList value: $devAddrList" 
						break
					}
				}
			} ;# end foreach block
		return "$dev1 BD_ADDR = [lindex $devAddrList 0]; $dev2 BD_ADDR = [lindex $devAddrList 1]"
		} ;# end try BT BD_ADDR block
		
	} ;# end proc get_bt_addr
	
	#-------------------------------------------------------
	# proc del_hndls
	#	delete bt DUT and Ref ACL connection handles
	#-------------------------------------------------------
	proc del_hndls {dev1 dev1_hndl dev2 dev2_hndl} {
	
			UTF::Try "Deleting $dev1 ACL handle" {
				$dev1 delete_acl_handles $dev1_hndl
				}
			UTF::Sleep 2
			
			UTF::Try "Deleting $dev2 ACL handle" {
				$dev2 delete_acl_handles $dev2_hndl
				}
			UTF::Sleep 2
	}	
	
	#-------------------------------------------------------
	# proc run_a2dp
	#	core logic cycling through all A2DP traffic directions
	#-------------------------------------------------------
	proc run_a2dp {cmd dev1 dev2 tLoop tType profile tstTtl nobidir} {
	
		# 	case nobid flag was set at option
		if { $nobidir == 1 } { set endVal 3 } else { set endVal 4 }
		
		### DEBUG: checking btc_mode at top of test
		### set cur_btc_mode [ get_dev_setting $::wlan_dut wl btc_mode ]
		### UTF::Message DEBUG "" "btc_mode setting check at end of test: $cur_btc_mode"
		
		# puts "nobdir value is $nobidir; endVal is $endVal" ;# debug statement
		# error "nobidir value check" ;# debug statement
						
		for {set i 1} {$i < $endVal} {incr i} {
			switch -- $i {
				1 { set tdir dut2ref
					if { $tLoop == 0 } { set tdirLbl "$dev1\-\>$dev2" } else { set tdirLbl "$dev2\-\>$dev1" }
				}
				2 { set tdir ref2dut
					if { $tLoop == 0 } { set tdirLbl "$dev2\-\>$dev1" } else { set tdirLbl "$dev1\-\>$dev2" }
				}
				3 { set tdir bidirectional
					if { $tLoop == 0 } { set tdirLbl "$dev1\<\>$dev2" } else { set tdirLbl "$dev2\<\>$dev1" }
				}
			} ;# end of switch block
		
		UTF::Message LOG "" "\n\n*******************************************************************
		\nRunning $tType test => $tdir now...
		\n*******************************************************************\n"
	
		set runcmd "$cmd -bt_dir $tdir"
		set Ttl "$tstTtl $tdirLbl"
		  
		UTF::Try "$Ttl" {
			eval $runcmd
		}
		
		### DEBUG: checking btc_mode
		### set cur_btc_mode [ get_dev_setting $::wlan_dut wl btc_mode ]
		### UTF::Message DEBUG "" "btc_mode setting check at end of test: $cur_btc_mode"
		
		if {$i < 3} {
				UTF::Message LOG "" "\n---------------------------------------------
			\nPausing between tests...
			\n---------------------------------------------\n"
				UTF::Sleep 5
			}
		
		} ;# end of i loop
		
		UTF::Sleep 5 ;# pause before proceeding
		
	}
	
	#-------------------------------------------------------
	# proc get_dev_setting
	#	get device setting
	#-------------------------------------------------------
	proc get_dev_setting {dev cmd param} {
	UTF::Try "Getting $param from $dev" {
		set retVal [ $dev $cmd $param ]
		}
		return $retVal
	}
	
	#-------------------------------------------------------
	# proc set_dev_setting
	#	set device setting
	#-------------------------------------------------------
	proc set_dev_setting {dev cmd param val} {
	UTF::Try "Setting $dev $param to $val" {
		set setResp [catch "$dev $cmd $param $val" catch_messg]
		}
		### debug statements
		### UTF::Message DEBUG "" "catch_messg value: $catch_messg"
		### UTF::Message DEBUG "" "setResp value: $setResp"
		
		return $setResp
	}
	
	
	
	###############################################################
	# # # 
	# # # a2dp_coex test starts here
	# # # 
	###############################################################
			
	UTF::WrapSummary $UTF::SummaryDir "$sumTtl" "" $(email) {
	
	    # Add a web link to the test.log file
	    UTF::Try "Link to test.log" {
	        return "html: <a href=\"./test.log\">test.log</a>"
	    }
	     
		# Report driver info
		UTF::Try "$(ap) Router Image: " {
			$(ap) findimages
		}	
		UTF::Try "$(sta) WLAN Image: " {
		  if { $(stabin) == "" } {
			$(sta) findimages	
			} else {
			$(sta) findimages -stabin $(stabin)
			}		
		}
		UTF::Try "$(bt) BT Image: " {
			$(bt) findimages
		}
		
		# Load the Routers only if chanspec is specified.
		if { $(chanspec)!= "" } {
			UTF::Try "Load Routers" {
				foreach Router "$::wlan_rtr" {
					UTF::Try "Load Router $Router" {
						set catch_resp [catch "UTF::load_rtr_retry $Router" catch_msg]
	
						UTF::Test::APChanspec $Router $(chanspec)   
	
						set c [lindex [$Router wl chanspec] 0]
						if {$c ne $(chanspec)} {
							error "Chanspec $c != $(chanspec)"
						}
	
						# Set the antenna selection
						### catch "$Router wl down"
						### catch "$Router wl nphy_antsel $::wlan_rtr_antsel" ;# relevant only to 4717 with no antswitch=0 setting
						### catch "$Router wl up"
	
						# Check for loading errors
						if {$catch_resp == 0} {
							return "$catch_msg"
						} else {
							# AP may have loaded OK on the 2nd try.
							if {![string match -nocase "*try*pass:*" $catch_msg]} {
								incr ::error_cnt
							}
							error "$catch_msg"
						}
					}
				}
			}
		}
			
		# set flag if STA is HSIC
		### load HSIC trx image here so that device would not be affected by 
		### HSIC power cycle at top of trx image load
		
		if { $hFlg == 1 } {
		   UTF::Try "Loading WLAN driver" {
			   if { $(stabin) != "" } {
				   set ldCode [catch {$(sta) load -stabin $(stabin)} ldMsg
			   } else {
			   set ldCode [catch {$(sta) load} ldMsg]
		   }
			   UTF::Message LOG "" "ldCode returned value:  $ldCode\n"
			   if { ! [regexp "0" $ldCode] } {
				   set errMsg "WLAN driver load failed"
				   UTF::Message FAIL "" $errMsg 
				   error $errMsg
			   }					
		   }
			set msg "WLAN down until test run\n"
			puts $msg ; UTF::Message INFO "" $msg
			UTF::Try "WLAN down" {$::wlan_dut wl down}
		}								
		
	    # run setup testbed defined in UTF conf file
		if {[info exists ::UTF::SetupTestBed]} {
			UTF::Try "Setup testbed" {
				eval $::UTF::SetupTestBed
			}
		}
	
		# load BT image if specified in option	
		if { ! $(nobtload) } {
	
			catch {UTF::Try "Loading $::bt_dut BT image" {bt_load $::bt_dut}} retCode
			# UTF::Message INFO "" "BT load retCode value is $retCode" ;# debug statement
			if { [regexp "brcmlib" $retCode] } {
				error "Load BT firmware failed. Stop test.\n"
			}
			
		} else {
			
			# setup dut comm params, if BT image not loaded by option
			UTF::Try "Setting $mstr comm port" {
				set startup_speed [$mstr cget -bt_comm_startup_speed]
				set startup_speed [string trim $startup_speed]
				set bt_comm $::mstr_bt_comm]
				if {$startup_speed != ""} {
					if {[regexp "@" $bt_comm]} {
						set bt_comm [split $bt_comm "@"]
						set normal_speed [lindex $bt_comm 1]
						set bt_comm "[lindex $bt_comm 0]@$startup_speed"
					}
				set mstr_bt_start $bt_comm	
				}
				
				set comm_code [setComm $mstr $mstr_bt_start $::highspeed]
				UTF::Message LOG $mstr $::sepStr
				UTF::Message LOG $mstr "comm_code: $comm_code"
				UTF::Message LOG $mstr $::sepStr
				
				if { $comm_code != 0 } {
					UTF::Message LOG "$mstr" "Failed to set $mstr com port setting. Abort test." 
					exit }
			}
			
		}
		
		# main outer loop starts here: cycles through a2dp baseline (profile 0) 
		# and a2dp coex (profile 2)
	
		foreach profile $::profiles {
					
			# load WLAN driver, then connect AP and STA for coex test
			if { $profile == "2" } {
				
				# case: DUT is HSIC 
				if { $hFlg == 1 } {
	
					catch {UTF::Try "WLAN up" { $::wlan_dut wl up }}
					UTF::Sleep 3
	
					set conn_msg [catch {UTF::Try "Connecting $::wlan_dut $::wlan_rtr" { 
							wlan_conn $::wlan_rtr $::wlan_dut
					} 
				}]
				
					if { $conn_msg != 0 } { 
						error "WLAN devices connect failed. Halt test.\n" 
					} else {
						UTF::Message DEBUG "" "\nwlan_conn returned conn_msg: $conn_msg\n"
					}
					
				} else {
					
				# all other DUT types
						
				# load WLAN driver, if successful, then Connect AP STA
				# stop test if either BT firmware or WLAN driver load failed
				if { $(stabin) == "" } {
					catch {UTF::Try "Load WLAN driver" { wlan_load $::wlan_dut $::wlan_rtr } } wldCode
	# # # 				wlan_load $::wlan_dut $::wlan_rtr ;# commented out 4/4/13
				} else {
		           catch {UTF::Try "Load WLAN driver" { wlan_load $::wlan_dut $::wlan_rtr $(stabin) }} wldCode
	# # # 				wlan_load $::wlan_dut $::wlan_rtr $(stabin) ;# commented out 4/4/13 
				}
	
	# commented out 2/29/12 to run 4334B2Tmp which has memory leak issue	
	# # # 			if { $wldCode != "" } {
	# # # 			   error "WLAN driver load failed. Stop test.\n"
	# # # 		    }	;# temporarily disabled for development 1/11/12
	
			if { $(stoponwlanerr) } {
					UTF::Message DEBUG "" "\nstoponwlanerr option set to : $(stoponwlanerr); \nchecking for wlan load or connect error...\n"
					if { $wldCode != "" } {
					   error "WLAN driver load failed. Stop test.\n"
				    } else {
					    UTF::Message DEBUG "" "\nWLAN driver loaded with return code: $wldCode\n"
				    }
			    }
			} ;# end hFlg check
			
														
			} ;# end connect AP STA
		
			# main a2dp/acl loop starts here:
			# cycles through DUT<->REF master/slave (outer loop)
			# then BDR/EDR tests (inner loop)
			
			if { $(nomaster) } { set tStart 1 ; set tStop 2 } else {
				if { $(noslave) } { set tStart 0 ; set tStop 1 } else {
					set tStart 0; set tStop 2 }
			}
			
			for {set tLoop $tStart} {$tLoop < $tStop} {incr tLoop} {
			
			# 	dev1 is always Master, dev2 is always Slave
			#	$mstr is DUT; $slv is BTRef (as defined in set variables setction, above)
			
				if { $tLoop == 0 } {
					set dev1 $mstr
					set dev2 $slv
					set dev1_comm $::mstr_bt_comm
					set dev2_comm $::slv_bt_comm
				} else { ;# case $tLoop == 1
					set dev1 $slv
					set dev2 $mstr
					set dev2_comm $::mstr_bt_comm
					set dev1_comm $::slv_bt_comm
				}
				
				# acquire BD_ADDR for both BT devices
				get_bt_addr $dev1 $dev2
				# exit ;# development and debug pause

				set testType "BDR"; set bType "bdr"

				# set errCnt 0

				# connect BT devices
				## ? UTF::Message LOG "" "Connecting master $dev1 and slave $dev2\n"
	
				# check if connection successful; halt test if not			
				## catch "bt_conn $dev1 $dev2" connRet
				UTF::Try "Connecting master $dev1 and slave $dev2" {
					set retMsg [bt_conn $dev1 $dev2]
					### UTF::Message DEBUG "" "\nretMsg from bt_conn is: $retMsg\n\n" 	
				} 
				if {[regexp "failed" $retMsg] || [regexp "ERROR" $retMsg] } {
					error "Halt test."
				}
			    ### UTF::Message DEBUG "" "\nretMsg from bt_conn is: $retMsg\n\n"
				### exit
				
				UTF::Sleep 5
				
				UTF::Try "Getting ACL handles of test devices" { 
					# get connection handles   
					set mstr_hndl [$mstr show_acl_handles]
					set slv_hndl [$slv show_acl_handles]
					set dev1_hndl [$dev1 show_acl_handles]
					set dev2_hndl [$dev2 show_acl_handles]
					UTF::Message LOG "" $::sepStr
					UTF::Message LOG "" "\nMaster device $dev1 handle: $dev1_hndl
					      \nSlave device $dev2 handle: $dev2_hndl\n"
					UTF::Message LOG "" $::sepStr
					
					return "Master_BT_handle = $dev1_hndl; Slave_BT_handle = $dev2_hndl"
				}
				
				UTF::Try "Setting A2DP paramters" {
					
					set_a2dp $testType $dev1 $dev2 $dev1_comm $dev2_comm $dev1_hndl $dev2_hndl
	
					UTF::Message LOG "" "Done setting up for A2DP tests. Pause for 5 seconds..."
					UTF::Sleep 5
				}
	
				#
				# now run the thruput test
				# vary WLAN traffic, then A2DP
				# Outerloop: profile; innerloop: tType
				#
				
				# 	first run BDR test
				if { $(noEDR) } {
				   set tests "BDR"
				} else {
					if { $(noBDR) } {
						set tests "EDR"
					} else {
				   set tests "BDR EDR"
			        }
				}
				set loop 0
				UTF::Message ERROR "" "Tests set selected: $tests\n"
			    			
				foreach tType $tests {			
					
					if { $tType == "BDR" } { set bType "bdr" } else { set bType "edr" }
					UTF::Message LOG "" "Test selected is: $tType\n"
					if { [$(sta) hostis] == "HSIC" } {
						set cmd "UTF::Test::ThruputBT_dev $dev1 $dev2 -bt_pkt $tType -wlan_relay $::wlan_relay\
					  -profile $profile -handle_acl_master $dev1_hndl -handle_acl_slave $dev2_hndl\
					  -iso_interval $::iso_intvl -iso_delay_tolerance $::iso_delay -block_size $::block_size"
					  } else {
						set cmd "UTF::Test::ThruputBT_dev $dev1 $dev2 -bt_pkt $tType\
					  -profile $profile -handle_acl_master $dev1_hndl -handle_acl_slave $dev2_hndl\
					  -iso_interval $::iso_intvl -iso_delay_tolerance $::iso_delay -block_size $::block_size"
					  }
					  
					if { $profile == 2 } {
						
						# profile 2: Coex tests 
						# loop dut2tg, tg2dut, and bidirectional WLAN traffic here
					
						### Adding checking and setting required coex settings
						UTF::Try "Setting up for coex tests" {
							UTF::Message DEBUG "" "Setting btc_mode and btc_params 82 here..."
							### set cur_btc_mode [ $::wlan_dut wl btc_mode ]
							set cur_btc_mode [ get_dev_setting $::wlan_dut wl btc_mode ]
							UTF::Message DEBUG "" "Checking current btc_mode setting. btc_mode value is set to $cur_btc_mode"
							if { $cur_btc_mode != 1 } { set chg_resp [ set_dev_setting $::wlan_dut wl btc_mode 1 ] } else { set chg_resp 0 }
							if { $chg_resp != 0} {
								UTF::Message DEBUG "" "btc_mode value change failed."
								} else {
								UTF::Message DEBUG "" "btc_mode value change succeeded."
								set cur_btc_mode [ get_dev_setting $::wlan_dut wl btc_mode ]
								UTF::Message DEBUG "" "btc_mode setting for the following tests: $cur_btc_mode"
							}
							### set cur_bparams82 [ $::wlan_dut wl btc_params 82 ]
							set cur_bparams82 [ get_dev_setting $::wlan_dut wl "btc_params 82" ]
							UTF::Message DEBUG "" "btc_params 82 value is set to $cur_bparams82"
							### if { $cur_bparams82 != 0 } { catch "$::wlan_dut wl btc_params 82 0" }
							if { $cur_bparams82 != 0 } { catch [set_dev_setting $::wlan_dut wl "btc_params 82" 0] }
							set cur_bparams82 [ get_dev_setting $::wlan_dut wl "btc_params 82" ]
							UTF::Message DEBUG "" "btc_params 82 value for the following tests: $cur_bparams82"						
							if { $(nodesense) } {
								UTF::Try "Turning BT desense off" {
									UTF::Message DEBUG "" "Turn off BT desense"
									### catch "$::wlan_dut wl btc_dynctl -f 0x00"
									set cur_desense [ set_dev_setting $::wlan_dut wl btc_dynctl "-f 0x00" ]
								UTF::Message DEBUG "" "Desense value is changed to: $cur_desense"
								}				
							}
						}
						### end coex setting check
					
						foreach wlan_dir $::wlan_dirs {
	
							set prof2_cmd "$cmd -wlan_dut $::wlan_dut -wlan_tg $::wlan_tg -wlan_dir $wlan_dir"
							set tstTtl "Coex WLAN $wlan_dir; A2DP $tType:"
							UTF::Message LOG "" "\n\nProfile 2 cmd: $cmd\n\n"
		
							run_a2dp $prof2_cmd $dev1 $dev2 $tLoop $tType $profile $tstTtl $(nobid)
							
							# error "Check here.\n" ; break
							
							} ;# loop through all WLAN traffic directions 	
			
					} else {
						
						# profile 0: Baseline tests
					    set tstTtl "Base A2DP $tType:"		    
						run_a2dp $cmd $dev1 $dev2 $tLoop $tType $profile $tstTtl $(nobid)
						
					}				
					
	# 				error "Check here.\n" ; break
					
					if { $loop < 1 } {
						UTF::Message LOG "" "\n---------------------------------------------
						\nPausing between $tType and [lindex $tests $loop] tests...
						\n---------------------------------------------\n"
						}
					UTF::Sleep 5
					
					if { $tType != "EDR" } {
	
						if { $(noEDR) } {
						   continue
						} else {
						   set tType [lindex $tests [expr $loop + 1]]; set bType "edr" ; set edr_val 0
					    }
						
						UTF::Try "Change to $tType packet types" {
							
							### No need to keep track of tLoop to determine master/slave mode
							### Always set up BTRef prior to BT DUT: BT DUT = mstr; BT Ref = slv (see top of script)
						
							UTF::Try "Change to $tType packet types: $slv" {
								catch "chg_pkt_type $slv $tType $slv_hndl" sPkt
								# UTF::Message INFO "$slv" "sPkt value is set to: $sPkt" ;# expected value: null
								if { $sPkt != "" } {
									set serrMsg "$slv changing to $tType packet type failed."
									UTF::Message FAIL "" $serrMsg
									error $serrMsg
								}
							}						
							UTF::Sleep 5
							
							UTF::Try "Change to $tType packet types: $mstr" {
								catch "chg_pkt_type $mstr $tType $mstr_hndl" sPkt
								# UTF::Message INFO "$mstr" "sPkt value is set to: $sPkt" ;# expected value: null
								if { $sPkt != "" } {
									set serrMsg "$mstr changing to $tType packet type failed."
									UTF::Message FAIL "" $serrMsg
									error $serrMsg
								}
							}						
							UTF::Sleep 5
	
						}
					}
					incr loop
								
				} ;# end of inner loop --> test types BDR/EDR
				
				# device reset messages
				if { $tLoop < 1 } {
					UTF::Message LOG "" "\n\n*******************************************************************
					\nResetting connections before next test...
					\n*******************************************************************\n"
					UTF::Message INFO "" "Resetting connections before next test..."
				} else { 
					UTF::Message LOG "" "\n\n*******************************************************************
					\nResetting connections...
					\n*******************************************************************\n"
					UTF::Message INFO "" "Resetting connections..."
				}
				
					# reset connections		
					reset_bt $dev1 $dev2 $dev1_comm $dev2_comm
	
					# Delete the connection handles				
					del_hndls $dev1 $dev1_hndl $dev2 $dev2_hndl
	
			} ;# end of tLoop
		
		    # Do optional post test analysis. The "" passes the unnamed options array.
			# UTF::do_post_test_analysis a2dp.test ""
	        	
			UTF::Message LOG "" "\n\n*******************************************************************
	***********\t\t\t\t\t\t***********
	***********\t\tEnd of A2DP tests\t\t***********
	***********\t\t\t\t\t\t***********
	*******************************************************************\n"
	
		} ; #end of profile loop
	
		# resetting DUT com port setting before exiting
		UTF::Try "Restoring $mstr comm port setting" {
			catch "setComm $mstr $::mstr_bt_comm $::normalspeed" setComMsg
			return $setComMsg
		}
				
		# unload WLAN driver if in Coex test
		if { $profile == 2 } {
			UTF::Try "Probe into final device coex settings" {
				### set cur_bmode [ $::wlan_dut wl btc_mode ] ; set cur_bparams82 [ $::wlan_dut wl btc_params 82 ]
				set cur_bmode [ get_dev_setting $::wlan_dut wl btc_mode ]; set cur_bparams82 [ get_dev_setting $::wlan_dut wl "btc_params 82" ]
				UTF::Message DEBUG "" "Final driver settings: btc_mode $cur_bmode; btc_params 82: $cur_bparams82"
			}
			UTF::Try "Unloading $(sta) WLAN driver" {
				catch "$(sta) unload"
				}
		}
	
	set report_url "http://www.sj.broadcom.com$::UTF::Logdir/summary.html"
	UTF::Message DEBUG "" "The report URL location is $report_url"	
			
	} ;# end of summary wrap

} ;# end of ad2p test
