#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for RvR1 test run
# $Id$
# $Copyright Broadcom Corporation$
#

package require UTF
package require UTF::Linux
package require UTF::utils
package require UTF::Sniffer
package require UTF::Test::controlchart
package require UTF::Test::APChanspec

package provide UTF::Test::RvR1 2.0

#============== Common procs used in main test ======================

#============== proc beacon_cc ======================================
# Produces separate control charts for beacon loss & recovery.
#
# Puts 2 control chart on the summary web page.
#====================================================================
proc beacon_cc {STA LAN routerConfig direction history key_template readonly\
    udp focus chanspec attnstep} {

    # Do 2 beacon control charts as one result.
    set ::rvrd "" ;# variable to pass controlchart pathnames back
    UTF::Try "$STA $routerConfig $direction Beacons" {

        # Set Y-Axis title
        if {$udp > 0} {
            set xport UDP
        } else {
            set xport TCP
        }
        set title1 "$::testrig $::int_desc BeaconLossDown $xport $routerConfig Ch=$chanspec $focus $direction"
        set title2 "$::testrig $::int_desc BeaconLossUp $xport $routerConfig Ch=$chanspec $focus $direction"

        # Beacon Loss Down CC. Take first consisent beacon loss.
        regsub -nocase "AttnUp" $key_template "" key_template
        regsub -nocase "\{step\}" $key_template "BeaconLossDown" keys
        set val [UTF::find_consecutive_values "$::rvr_rampdown_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward 0 $attnstep]
        set catch_msg1 ""
        if {$val != ""} {
            catch {UTF::update_control_chart_data $keys $val $readonly CC\
		"ZERO|LOW|WIDE|HIGH" $STA $LAN $direction 1 $history $title1 dB Attenuation} catch_msg1
            lappend ::rvrd $::uccd_png_path ;# save first CC graphic
            save_results $STA $LAN "$keys" $routerConfig $chanspec $direction BeaconLossDown $val
        }

        # Beacon Loss Up CC. Take last consisent beacon loss, using negative step.
        regsub -nocase "\{step\}" $key_template "BeaconLossUp" keys
        set val [UTF::find_consecutive_values "$::rvr_rampup_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward end -$attnstep]
        set catch_msg2 ""
        if {$val != ""} {
            catch {UTF::update_control_chart_data $keys $val $readonly CC\
		"ZERO|LOW|WIDE|HIGH" $STA $LAN $direction 1 $history $title2 dB Attenuation} catch_msg2
            lappend ::rvrd $::uccd_png_path ;# save second CC graphic
            save_results $STA $LAN "$keys" $routerConfig $chanspec $direction BeaconLossUp $val
        }

        # Massage into one composite result.
        regsub {^html:} $catch_msg1 "" catch_msg1
        regsub {^html:} $catch_msg2 "" catch_msg2
        set result "html: <b>BeaconLossDown</b> $catch_msg1 <br><b>BeaconLossUp</b> $catch_msg2"

        return $result
    }
}

#============== proc check_ap_connect_time ==========================
# Checks for more than 1 drop in the AP connect time.
#====================================================================
proc check_ap_connect_time {csv_path ap_type attnstep routerConfig direction is_oem_ap} {
    UTF::Message INFO "" "check_ap_connect_time csv_path=$csv_path ap_type=$ap_type\
        attnstep=$attnstep routerConfig=$routerConfig direction=$direction is_oem_ap=$is_oem_ap\
        ::rvr_connect_time_drop=$::rvr_connect_time_drop"

    # Some users may wish to turn off this test. Dont do test for OEM AP.
    if {$::rvr_connect_time_drop <= 0 || $is_oem_ap != "0"} {
        return
    }

    UTF::Try "$routerConfig $direction $ap_type Check Connect Time" {

        # Get list of loss & AP connect time.
        set ap_time_col [find_csv_column apConnectTime]
        set ap_time [UTF::read_csv_data $csv_path 0 $ap_time_col]

        # Look for drops in AP connect time. The connect time may have
        # dropped to 0 and then started to rise again. Due to the
        # discrete sampling done by the scripts, we may see a large drop
        # in the connect time, but it wont necessarily hit zero. So we 
        # look for drops that exceed 30 seconds (ref ::rvr_connect_time_drop),
        # as well as 0.
        set issue_list ""
        set prev_loss "" 	;# last loss we examined
        set prev_time "" 	;# last time we examined
        set prev_issue_loss -1 	;# loss for last issue that occurred
        set ramp "" 		;# tracks place on graph: down bottom up flat
        foreach pair $ap_time {

            # Get current pair of loss & time, ignore blanks.
            set loss [lindex $pair 0]
            set loss [string trim $loss]
            set time [lindex $pair 1]
            set time [string trim $time]
            set extra [lindex $pair 2] ;# boobytrap, should always be null
            set extra [string trim $extra]
 
            if {$loss == "" || $time == "" || $extra != ""} {
                UTF::Message WARN "" "check_ap_connect_time\
                    missing or extra data: loss=$loss time=$time extra=$extra"
                continue
            }

            # First pair are used to initialize the checks.
            if {$prev_loss == "" || $prev_time == ""} {
                set prev_loss $loss
                set prev_time $time
                continue
            }

            # Keep track of ramp status.
            if {$loss > $prev_loss} {
                # Curve is ramping down
                set ramp down
            } elseif {$loss == $prev_loss && ($ramp == "" || $ramp == "down")} {
                # This is the bottom of the curve
                set ramp bottom
            } elseif {$loss < $prev_loss} {
                # Curve is ramping up
                set ramp up
            } elseif {$loss == $prev_loss && $ramp == "up"} {
                # This is the right flat side of the curve
                set ramp flat
            }

            # Did we get a significant drop or hit 0? Curve may start at 0,
            # stay there for a while and then rampup, which we allow for.
            set drop [expr $prev_time - $time]
            if {$drop >= $::rvr_connect_time_drop ||\
                ($time == 0 && $prev_time >= $::rvr_connect_time_drop)} {

                # We dont want to record errors that are adjacent, but
                # we can get adjacent errors on fastrampup flat part of curve.
                # NB: for ramp=bottom, step can be 0.
                # NB: for fastramp flat right side of curve, step can be 0.
                set step [expr abs($loss - $prev_issue_loss)]
                if {($ramp == "bottom" && $step == 0) || $step == $attnstep} {
                    UTF::Message INFO "" "check_ap_connect_time step=$step\
                        ramp=$ramp ignoring adjacent issue: $loss"
                } else {
                    lappend issue_list $loss
                    UTF::Message INFO "" "check_ap_connect_time step=$step\
                    ramp=$ramp new issue: $loss"
                }
                set prev_issue_loss $loss
            }

            # Update tracking state info
            set prev_loss $loss
            set prev_time $time
        }

        # Always allow 1 issue. If we did rampuponly, the AP connect
        # time starts off GT 0 because we always make a connection at
        # a low attenuation at the start of the test.
        UTF::Message INFO "" "check_ap_connect_time issue_list=$issue_list"
        if {[llength $issue_list] <= 1} {
            UTF::Message INFO "" "check_ap_connect_time 1 issue is always expected"
            return
        } else {
            error "check_ap_connect_time issues at loss: $issue_list"
        }
    }
}

#============== proc check_malloc_fail ==============================
# Returns the STA malloc fail count. Counts total errors so user
# gets only one composite error at the end of the test.
#====================================================================
proc check_malloc_fail {STA nomalloc routerConfig direction} {

    # User may choose to not look for malloc failures.
    if {$nomalloc} {
        return
    }

    # Here we test whether the STA device is a dongle device. 
    # If so, check the buffer alloc fail count.
    if {[$STA hostis DHD WinDHD]} {
        set catch_resp [catch {UTF::check_rte_mu_output $STA ".*malloc.*count:"} catch_msg]
        # UTF::Message INFO "" "check_malloc_fail catch_resp=$catch_resp catch_msg=$catch_msg"
    } else {
        return
    }

    # If malloc fail count is 0 or no serial console is defined, we are done.
    if {![info exists catch_msg]} {
        set catch_msg "???"
    }
    if {$catch_msg == "0" || $catch_msg == "no serial console"} {
        return $catch_msg 
    }

    # Return numeric value or a very short error msg. This data goes into the
    # .CSV file, and we dont need huge error messages in there. If the error
    # were to contain a comma, that would really mess up parsing of the .CSV
    # data file and subesequent plotting of the graphs.
    if {![regexp {^\d+$} $catch_msg]} {
        UTF::Message ERROR $STA "++++ serial console error: $catch_msg"
        set catch_msg "serial console error"
    }

    # Save the malloc fail count or other errors for a single composite error.
    set ::rvr_malloc_fail_errors $catch_msg
    return $catch_msg
}

#============== proc check_trend_errors =============================
# Checks for overall trend errors. 
#====================================================================
proc check_trend_errors {trend routerConfig direction} {

    # Many users will want the default PASS/FAIL mode.
    if {$trend == 0} {
        return
    }

    UTF::Try "$routerConfig $direction Check Trend Errors" {

        # Log the data and parameters.
        UTF::Message INFO "" "check_trend_errors\
            process_cc_results_list=$::process_cc_results_list"
        UTF::Message INFO "" "check_trend_errors\
            rvr_trend_error_length=$::rvr_trend_error_length\
            rvr_trend_error_max=$::rvr_trend_error_max"

        # Look for consecutive errors as well as total errors.
        set all_error_list "";# shows all error pairs
        set curr_trend_error_list "" ;# build up possible trend error
        set trend_error_cnt 0 ;# counter for trend errors found
        set trend_error_list "" ;# shows actual trend errors
        foreach pair $::process_cc_results_list {
            set loss [lindex $pair 0]
            set result [lindex $pair 1]
            set result [string toupper $result]
            if {$result == "LOW" || $result == "WIDE" || $result == "ZERO" || $result == "OTHER"} {
                # Save each error found.
                UTF::Message INFO "" "check_trend_errors\
                    new ERROR: loss=$loss result=$result"
                lappend curr_trend_error_list $pair
                lappend all_error_list $pair

            } else {
                # Good result. Did we an existing possible error trend?
                set len [llength $curr_trend_error_list]
                if {$len >= $::rvr_trend_error_length} {
                    incr trend_error_cnt 
                    UTF::Message INFO "" "check_trend_errors\
                        new TRENDERROR: $trend_error_cnt: $curr_trend_error_list"
                    lappend trend_error_list "$trend_error_cnt: $curr_trend_error_list"
                }

                # Reset curr_trend_error_list
                set curr_trend_error_list ""
             }
        }

        # At the end of the data, did we have a possible error trend?
        set len [llength $curr_trend_error_list]
        if {$len >= $::rvr_trend_error_length} {
            incr trend_error_cnt 
            UTF::Message INFO "" "check_trend_errors\
                new TRENDERROR: $trend_error_cnt: $curr_trend_error_list"
            lappend trend_error_list "$trend_error_cnt: $curr_trend_error_list"
        }

        # Now we decide the overall PASS / FAIL status.
        set len [llength $all_error_list]
        if {$trend_error_cnt == 0 &&  $len <= $::rvr_trend_error_max} {
            # No trend errors & acceptable total errors => PASS
            if {$all_error_list == ""} {
                return
            } else {
                return "acceptable errors: $len $all_error_list"
            }

        } else {
            if {$trend_error_cnt == 0} {
                # Show all errors
                error "ALLERRORS: $len $all_error_list" 
            } else {
                # Just show trend errors. Dont show list of all errors, 
                # it really clutters the report on top of the trend errors.
                error "TRENDERRORS: $trend_error_cnt $trend_error_list ALLERRORS: $len" 
            }
        }
    }
}

#============== proc check_testmode =================================
# Complains is we are using test_mode != 0
#====================================================================
proc check_testmode {test_mode} {

    if {$::test_mode != 0} {
        UTF::Try "WARNING: ::test_mode is not 0" {
            error $::test_mode
        }
    }
}

#============== proc choose_attn_step ===============================
# Choose the next value the attenuator will use.
# Also implements the optional fastrampup test.
# Also implements the arbitrary steplist.
#
# Returns: step
#====================================================================
proc choose_attn_step {step attnstep attnDirection range2 fastrampup mean_tput steplist cc_samples} {

    # Keep track of when we rejoin / get traffic on the rampup.
    if {$attnDirection == "down" && $mean_tput >= $::rvr_rejoin_tput && $::rvr_rejoin_result == ""} {
        # Save attn & samples for separate controlchart usage.
        set ::rvr_rejoin_result "$step $cc_samples"
        UTF::Message INFO "" "choose_attn_step rvr_rejoin_result=$::rvr_rejoin_result"
    }

    # If appropriate, pick the next totaly arbitrary step from the steplist.
    set steplist [string trim $steplist]
    if {$steplist != ""} {
        incr ::step_index
        set step [lindex $steplist $::step_index]
        UTF::Message INFO "" "choose_attn_step step=$step step_index=$::step_index\
            steplist=$steplist"
        return $step
    }

    # Attenuator is adjusted at the top of the loop.
    if {$attnDirection == "up"} {
        # AKA rampdown test
        set step [expr $step + $attnstep]
    } else {
        # AKA rampup test
        set step [expr $step - $attnstep]
    }

    # For fastrampup test, we use a different step algorithm.
    if {$attnDirection != "up" && $fastrampup == 1} {
        UTF::Message INFO "" "choose_attn_step attnDirection=$attnDirection\
            fastrampup=$fastrampup rvr_fastrampup_active=$::rvr_fastrampup_active\
            mean_tput=$mean_tput rvr_fastrampup_tput=$::rvr_fastrampup_tput"

        # First we wait for traffic to start, GE ::rvr_fastrampup_tput
        if {$mean_tput >= $::rvr_fastrampup_tput && $::rvr_fastrampup_active == 0} {
            set ::rvr_fastrampup_active 1
        }

        # If fastrampup is active, we jump the attenuator to the final
        # value of the rampup range and kick the duration counter.
        if {$::rvr_fastrampup_active > 0} {
            set step $range2
            incr ::rvr_fastrampup_duration
            # Update description to keep TC titles unique
            set ::aux_desc "FastRampUp${::rvr_fastrampup_duration}"
        }

        # When we have done the required number of tests at the 
        # attenuator final value, stop the fastrampup test.
        if {$::rvr_fastrampup_active > 0 && \
            $::rvr_fastrampup_duration > $::rvr_fastrampup_cnt} {
            set ::rvr_fastrampup_active 2
        }
        UTF::Message INFO "" "choose_attn_step attnDirection=$attnDirection\
            fastrampup=$fastrampup step=$step\
            rvr_fastrampup_active=$::rvr_fastrampup_active\
            rvr_fastrampup_duration=$::rvr_fastrampup_duration\
            rvr_fastrampup_cnt=$::rvr_fastrampup_cnt\
            mean_tput=$mean_tput rvr_fastrampup_tput=$::rvr_fastrampup_tput"
    }
    return $step
}

#============== proc edit_hooks =====================================
# Edits the perf_hooks and related config items to remove redundant
# items that are explicitly done by RvR tests. This speeds up the
# tests by not doing selected actions twice times 100+ attenuator 
# steps.
#====================================================================
proc edit_hooks {AP LAN STA allhooks edithooks nohooks} {
    UTF::Message INFO "" "edit_hooks AP=$AP LAN=$LAN STA=$STA\
        allhooks=$allhooks edithooks=$edithooks nohooks=$nohooks"

    # Log the existing hooks, if any.
    log_hooks $AP $LAN $STA

    # For allhooks=1, we are done. User said to use everything the way 
    # it is. For time being, if user specified none of the 3 options,
    # act as though allhooks was specified.
    if {$allhooks == "1" || ($allhooks == "0" && $edithooks == "0" && $nohooks == "0")} {
       UTF::Message INFO "" "edit_hooks leaving your hooks as is, no changes"
       return
    }

    # For nohooks=1, set them all to null.
    if {$nohooks== "1"} {
        UTF::Message INFO "" "edit_hooks removing all hooks"
        catch {unset UTF::controlchart_cmds}
        foreach item "$AP $LAN $STA" {
            foreach option "pre_perf_hook post_perf_hook" {
                $item configure -${option} ""
            }
        }
        log_hooks $AP $LAN $STA
        return
    }

    # Selectively edit the hooks. This will eventually become the default.
    UTF::Message INFO "" "edit_hooks selectively editing hooks"
    # catch {unset UTF::controlchart_cmds}

    # We remove the items that the RvR script always does on the STA. 
    # With advent of SoftAP, we edit hooks on AP also to avoid duplication.
    # Leave the LAN alone, as the script doesnt query the LAN for info.
    foreach item "$AP $STA" {
        foreach option "pre_perf_hook post_perf_hook" {
            set value [$item cget -${option}]
            # NB: Some users put specific STA names in the commands.
            # Other users use the UTF %S syntax.
            regsub -all -nocase {\{\s*\S+\s+wl\s+ampdu_clear_dump\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+assoc\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+dump\s+ampdu\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+nrate\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+rate\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+rssi\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+rte\s+mu\s*\}} $value "" value
            set value [string trim $value]
            $item configure -${option} $value
        }
    }

    # Do similar edits on UTF::controlchart_cmds.
    if {[info exists UTF::controlchart_cmds]} {
        set value $UTF::controlchart_cmds
        #puts "UTF::controlchart_cmds value=$value"
        regsub -all -nocase {%S\s+wl\s+ampdu_clear_dump} $value "" value
        regsub -all -nocase {%S\s+wl\s+assoc} $value "" value
        regsub -all -nocase {%S\s+wl\s+dump\s+ampdu} $value "" value
        regsub -all -nocase {%S\s+wl\s+nrate} $value "" value
        regsub -all -nocase {%S\s+wl\s+rate} $value "" value
        regsub -all -nocase {%S\s+wl\s+rssi} $value "" value
        regsub -all -nocase {%S\s+rte\s+mu} $value "" value
        set value [string trim $value]
        set UTF::controlchart_cmds $value
    }
    log_hooks $AP $LAN $STA
    return
}

#============== proc find_csv_column ================================
# Finds the column number in the CSV titles for the specified field.
#====================================================================
proc find_csv_column {field} {

    # Get column number for field. Titles are comma separated.
    regsub -all {\s} $::csv_titles "" titles ;# clean out whitespace
    set titles [split $titles ","]
    set i [lsearch -exact $titles $field]
    if {$i >= 0} {
        UTF::Message INFO "" "find_csv_column field=$field i=$i"
    } else {
        UTF::Message ERROR "" "find_csv_column field=$field i=$i\
            titles=$titles" ;# gives error trace
    }
    return $i
}

#============== proc get_user_parms =================================
# gets users parameters from config file, sets defaults as needed.
#====================================================================
proc get_user_parms {timeout softap AP STA intsta intwl} {

    # Command line timeout takes precedance.
    if {$timeout != ""} {
        set ::rvr_overall_timeout_min $timeout
    }

    # If variables are not defined, use specified defaults.
    set msg ""
    foreach {var def lowlim} "::recovery_max 3 -1 \
        ::rvr_attn_max_errors 3 -1\
        ::rvr_connect_time_drop 30 -1\
        ::rvr_fastrampup_cnt 10 -1 ::rvr_fastrampup_tput 1 -1\
        ::rvr_overall_timeout_min 90 -1\
        ::rvr_rampdown_nobeacons 3 -1 ::rvr_rate_cnt 3 1\
        ::rvr_rejoin_tries 1 1 ::rvr_rejoin_tput 1 0 ::rvr_rejoin_wait_sec 10 5\
        ::rvr_slowrampup_cnt 10 -1 ::rvr_slowrampup_tput 1 -1\
        ::rvr_trend_error_length 6 2 ::rvr_trend_error_max 18 2" {
 
        if {![info exists $var]} {
            set $var $def
        }

        # Check variable value is numeric and not less than lowlim.
        set temp [set $var]
        if {![regexp {^[\-\d\.]+$} $temp] || $temp < $lowlim} {
            UTF::Message ERROR "" "get_user_parms invalid\
                $var=$temp, using $def"
            set $var $def
        }

        # Build list of final values.
        set temp [set $var]
        append msg " $var=$temp"
    }

    # Log the final values used.
    UTF::Message INFO "" "get_user_parms config file: $UTF::args(utfconf)"
    set msg [string trim $msg]
    UTF::Message INFO "" "get_user_parms $msg"

    # Get rvr STA init string & log it. We have a hierarchy of possible customizations.
    # See what user has defined in their config file, if anything. 
    set sta_default ::rvr_sta_init
    if {$softap == 1} {
        set var_list "::rvr_sta_${STA}_to_softap_init ::rvr_sta_${STA}_init ::rvr_sta_to_softap_init"
    } else {
        set var_list "::rvr_sta_${STA}_to_ap_init ::rvr_sta_${STA}_init ::rvr_sta_to_ap_init" 
    }
    set var_list "$var_list $sta_default"
    set found ""
    foreach var $var_list {
        if {[info exists $var]} {
            set found $var
            break
        }
    }

    # Use first item in hierarchy found from config file.
    if {$found != ""} {
        set temp [set $found]
        set $sta_default $temp
    }

    # If no default value exists, use original defaults.
    if {![info exists $sta_default]} {
        set $sta_default {{%S wl isup} {%S wl msglevel +error +assoc} {%S services stop}\
            {%S wl PM 0} {%S wl roam_trigger -100 all}}
    }
    set temp [set $sta_default]
    UTF::Message INFO "" "get_user_parms STA $found: $temp"

    # Get rvr AP init string & log it. We have a hierarchy of possible customizations.
    # See what user has defined in their config file, if anything. 
    set ap_default ::rvr_ap_init
    if {$softap == 1} {
        # For softap, final value is STA defaults.
        set var_list "::rvr_sta_${AP}_am_softap_init ::rvr_sta_${AP}_init ::rvr_softap_init ::rvr_sta_init"
    } else {
        set var_list "::rvr_ap_${AP}_init $ap_default" 
    }
    set found ""
    foreach var $var_list {
        if {[info exists $var]} {
            set found $var
            break
        }
    }

    # Use first item in hierarchy found from config file.
    if {$found != ""} {
        set temp [set $found]
        set $ap_default $temp
    }

    # If no default value exists, use original defaults.
    if {![info exists $ap_default]} {

        # nphy_percal is an old default -- needs to be removed.
        set $ap_default {{%S wl nphy_percal 1}}
    }
    set temp [set $ap_default]
    UTF::Message INFO "" "get_user_parms AP $found: $temp"

    # Add commands for interference tests.
    set intsta [string trim $intsta]
    if {$intsta != ""} {
        foreach var "$ap_default $sta_default" {
            # Remove interference_override setting from previous test, if any.
            set value [set $var]
            regsub -all -nocase {\{%S\s+wl\s+interference_override\s+\d+\}} $value "" value
            lappend value "%S wl interference_override $intwl"
            set $var $value
        }
        UTF::Message INFO "" "get_user_parms added/replaced: %S wl interference_override $intwl"
    }
    return
}

#============== proc iperf_ramp =====================================
# Do this only if user explicitly specified the -warmup option.
#====================================================================
proc iperf_ramp {STA LAN direction attnDirection window tput_mean warmup} {

    # We do this for Upstream only, attnuation decreasing, which is the
    # rampup right side of a normal RvR curve, once we managed to get
    # some data thoughput going again. Do only if user explicitly asked for -warmup.
    if {$warmup == 0} {
        return
    }

    UTF::Message INFO "" "iperf_ramp STA=$STA LAN=$LAN\
        direction=$direction attnDirection=$attnDirection window=$window\
        ::iperfRamp=$::iperfRamp tput_mean=$tput_mean"

    # Do iperf ramp once, if necessary.
    if {$direction == "Upstream" && $attnDirection == "down" && $tput_mean > 0 &&\
        $::iperfRamp == ""} {
        set PAIRS [list $STA $LAN]
        UTF::Try "Doing iperf ramp" {
            set resp [UTF::Multiperf $PAIRS -w $window -N -t 120 -i 120]
            set resp [string trim $resp]
            if {$resp == ""} {
                set resp 0
            }
            return [format "%.2f Mb/s" $resp]
        }
        set ::iperfRamp done
    }
}


#============== proc log_hooks =====================================
# Logs the perf_hooks and related config items.
#====================================================================
proc log_hooks {args} {

    # Log the existing hooks, if any.
    if {[info exists UTF::controlchart_cmds]} {
        UTF::Message INFO "" "log_hooks found\
            UTF::controlchart_cmds=$UTF::controlchart_cmds"
    }
    foreach item $args {
        foreach option "pre_perf_hook post_perf_hook" {
            set value [$item cget -${option}]
            set value [string trim $value]
            UTF::Message INFO "" "log_hooks found $item $option=$value"
        }
    }
    return
}

#============== proc monitor_interference ===========================
# Monitor interference STA & DUTs settings, collect stats.
# Returns: CSV list of 10 interference counters, 5 for AP, 5 for STA.
#====================================================================
proc monitor_interference {int_sta int_graph int_type dut_ap dut_sta step int_quiet int_wl} {

    # Is there anything to do? We may need to collect stats even if there is 
    # no interference test running. This allows for comparison of stats with 
    # and without interference.
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    set msg ", , , , , , , , , ,"
    UTF::Message INFO "" "monitor_interference int_sta=$int_sta int_graph=$int_graph\
        int_type=$int_type dut_ap=$dut_ap dut_sta=$dut_sta step=$step\
        int_quiet=$int_quiet int_wl=$int_wl"
    if {$int_sta == "" && $int_graph == 0} {
        return $msg
    }

    # wl shmem 0xe0 indicates if pkteng is running or not.
    # NB: counter wraps to 0 very quickly.
    if {$int_sta != "" && $int_type == "pkteng"} {
        if {$int_quiet} {
            # If requested, suppress messages from interference STA.
            set opt "-noinit"
        } else {
            set opt ""
        }
        set catch_resp [catch "eval $int_sta $opt wl shmem 0xe0" catch_msg]
        if {$catch_resp == 0} {
            lappend ::intsta_activity "$step $catch_msg"
            # UTF::Message INFO $int_sta "monitor_interference intsta_activity=$::intsta_activity"
        } else {
            UTF::Message WARN $int_sta "monitor_interference got: $catch_msg"
            lappend ::intsta_activity "$step WARN"
        }
    }

    # wl counters is supported on more builds than wl dump stats command.
    set result ""
    foreach item "$dut_ap $dut_sta" {

        # If DUT is known to be in trouble, leave it alone.
        set var "::${item}_state"
        if {[set $var] != "OK"} {
            append result " , , , , ,"
            continue
        }

        # Get counters delta from DUT. Getting all the counters every time
        # simplifies parsing delta values later on.
        set catch_resp [catch {UTF::access_counters $item getupdate showall silent} catch_msg]
        # UTF::Message INFO $item  "item=$item catch_msg=$catch_msg"
        UTF::save_device_state $item $catch_msg
        if {$catch_resp != 0} {
            # NB: These counters may not be supported on all chips
            UTF::Message WARN $item "monitor_interference got: $catch_msg"
            append result " , , , , ,"
            continue
        }

        # Parse out 5 stats delta. Data is formatted: countername=value=delta
        # NB: We want the delta from last iperf test, not the running total!
        if {![regexp -nocase {rxbadfcs=\d*=(\d*).*rxbadplcp=\d*=(\d*).*rxcrsglitch=\d*=(\d*).*rxdfrmucastmbss=\d*=(\d*).*rxstrt=\d*=(\d*)} $catch_msg - s0 s1 s2 s3 s4]} {
            UTF::Message ERROR $item "monitor_int_sta parsing error for: $catch_msg"
            append result " , , , , ,"
            continue
        }
        append result " $s0, $s1, $s2, $s3, $s4,"

        # Check interference settings have not changed.
        if {$int_sta == ""} {
            # NB: For regular tests, interference_override will be disabled.
            set cmd_list "interference"
        } else {
            set cmd_list "interference_override interference"
        }
	UTF::Message INFO "" "monitor_interference item=$item"
	foreach cmd $cmd_list {
	    set cur_str [$item wl $cmd]
	    if {$cur_str == ""} {
	        # Older chips may not return anything 
		set cur_val $int_wl
            } elseif {![regexp -nocase {mode\s+=?\s*(\d+)} $cur_str - cur_val]} {
                # Parse out N from 'mode N' or 'mode = N' in response $cur_str
                set cur_val "-"
                UTF::Message ERROR $item "monitor_interference could not parse: $cur_str"
            }
            # UTF::Message INFO $item "monitor_interference cur_str=$cur_str cur_val=$cur_val"

            # If appropriate, collect any errors as one list for use later
            if {$int_sta != "" && $cur_val != $int_wl} {
                # Allow AP to have interference mode 3 for 2G band as default for regular tests.
                if {$cur_val == 3 && $int_wl == 4 && $int_sta == "" && [UTF::is_ap $item]} {
                    UTF::Message WARN $item "monitor_interference allowing AP wl $cmd value $cur_val"
                } else {
                    UTF::Message ERROR $item "monitor_interference wl $cmd is $cur_val, should be $int_wl"
                    lappend ::intwl_errors "$item attn=$step $cmd=$cur_val" 
                    # For interference tests, set it back to desired value  
                    if {$int_sta != ""} {
                        $item wl $cmd $int_wl
                    }
                }
            }
        }
    }
    # UTF::Message ERROR $item "monitor_interference intwl_errors=$::intwl_errors"

    # Return CSV formatted stats
    UTF::Message INFO "" "monitor_interference result=$result"
    return $result
}

#============== proc monitor_beacons ================================
# Keeps track of when we have N consecutive no-beacon steps in a row
# for the rampdown / attenuator up test. Keeps track of when beacons
# have returned in the rampup / attenuator down test.
#
# Returns "yes" to stop the test if we had N consecutive no-beacon
# steps in a row on the rampdown / attenuator up test. 
# Returns "no" to keep tests going if user specified fullrange
# option or ::rvr_rampdown_nobeacons LE 0.
#====================================================================
proc monitor_beacons {step attnstep attnDirection fullrange} {
    UTF::Message INFO "" "monitor_beacons step=$step attnstep=$attnstep\
        attnDirection=$attnDirection fullrange=$fullrange\
        rvr_rampdown_nobeacons=$::rvr_rampdown_nobeacons"

    # Rampdown / attenuator up case
    if {$attnDirection == "up"} {

        # Update the rampdown no beacon list. List will be integers GE 0.
        if {![regexp -nocase {BEACONS} $::rejoin_old_state]} {
            lappend ::rvr_rampdown_no_beacons_list $step
        }

        # In some cases, we always keep testing.
        if {$fullrange == "1" || $::rvr_rampdown_nobeacons <= 0} {
            return no
        }

        # Should we stop the rampdown test?
        set val [UTF::find_consecutive_values "$::rvr_rampdown_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward end $attnstep]
        if {$val != ""} {
            UTF::Message INFO "" "monitor_beacons\
                stopping the rampdown test, found $::rvr_rampdown_nobeacons no beacon steps,\
                attnstep=$attnstep rvr_rampdown_no_beacons_list=$::rvr_rampdown_no_beacons_list\
                val=$val"
            UTF::Try "monitor_beacons stopping rampdown test" {
                return "$::rvr_rampdown_nobeacons no beacons at attenuator: $::rvr_rampdown_no_beacons_list"
            }
            return yes
        } else {
            return no
        }

    } else {
        # Rampup / attenuator down case
        # Update the rampup no beacon list. List will be integers GE 0.
        if {![regexp -nocase {BEACONS} $::rejoin_old_state]} {
            lappend ::rvr_rampup_no_beacons_list $step
        }
        return no
    }
}

#============== proc monitor_rampup_issues ==========================
# Returns yes if there is a severe rejoin / rampup issue and the
# user requested we stop on this condition.
#====================================================================
proc monitor_rampup_issues {tput_mean step attnDirection\
    fullrampup stopslowrampup} {

    UTF::Message INFO "" "monitor_rampup_issues tput_mean=$tput_mean\
        step=$step attnDirection=$attnDirection fullrampup=$fullrampup\
        stopslowrampup=$stopslowrampup"

    # If user wanted fullrampup, regardless of issues, we are done. For the short
    # term, if user did not specify either option, the default is fullrampup.
    if {$fullrampup == "1" || ($fullrampup == "0" && $stopslowrampup == "0")} {
        return no
    }

    # If either control parameter is LE 0, we are done.
    if {$::rvr_slowrampup_cnt <= 0 || $::rvr_slowrampup_tput <= 0} {
        return no
    }

    # For the rampdown / attenuator up portion of the test, we save the 
    # last N attenuator steps where the thruput is GT >= ::rvr_slowrampup_tput
    if {$attnDirection == "up"} {
        if {$tput_mean >= $::rvr_slowrampup_tput} {
            lappend ::monitor_rampdown_steps $step
            # Save the most recent N=::rvr_slowrampup_cnt steps
            set len [llength $::monitor_rampdown_steps]
            set end [expr $len - 1]
            set start [expr $end - $::rvr_slowrampup_cnt + 1] 
            set ::monitor_rampdown_steps [lrange $::monitor_rampdown_steps $start $end]
        }
        UTF::Message INFO "" "monitor_rampup_issues\
            ::monitor_rampdown_steps=$::monitor_rampdown_steps"
        return no
    }
    
    # For rampup / attenuator down portion of the test, we count the steps
    # where the thruput is GE the threshold value.
    if {$tput_mean >= $::rvr_slowrampup_tput} {
        incr ::monitor_rampup_good_tput_cnt
    }

    # The stop step for the slow rejoin / rampup test is the first attenuator
    # step in the ::monitor_rampdown_steps list. This is smallest of the last N
    # attenuation steps where the tput was GT 0 on the rampdown.
    set stop_step [lindex $::monitor_rampdown_steps 0]

    # On the rampup test, when we get to the stop_step, we had better have
    # at least one good thruput result, or we shut down the rampup test.
    if {$step <= $stop_step && $::monitor_rampup_good_tput_cnt == "0"} {
        UTF::Try "monitor_rampup_issues stopping rampup test" {
            error "no tput GE $::rvr_slowrampup_tput at Attn: $stop_step"
        } 
        return yes
    } else {
        UTF::Message INFO "" "monitor_rampup_issues\
            stop_step=$stop_step ::monitor_rampup_good_tput_cnt=$::monitor_rampup_good_tput_cnt"
        return no
    }
}

#============== proc monitor_rates ==================================
# Keeps track of MCS / Legacy rates in global variables.
#
# Returns: nothing
#====================================================================
proc monitor_rates {STA step attnDirection} {

    # Get data left for us by UTF::sta_stats routine.
    set temp "::${STA}_rate"
    if {![info exists $temp]} {
        UTF::Message WARN "$STA" "monitor_rates no info for: $temp"
        return
    }
    set val [set $temp]
    UTF::Message INFO "$STA" "monitor_rates step=$step\
        attnDirection=$attnDirection val=$val"
    set $temp "" ;# wipe the current value

    # Keep separate rate lists for rampdown vs rampup.
    if {$attnDirection == "up"} {
        # Rampdown / Attn up 
        lappend ::rvr_rampdown_rates_list "$step $val"
    } else {
        # Rampup / Attn down
        lappend ::rvr_rampup_rates_list "$step $val"
    }
    return ""
}

#============== proc overall_timeout ================================
# Returns yes if we have exceeded overall test time allocated.
#====================================================================
proc overall_timeout {keepgoing routerConfig direction} {

    # User may override timer with -keepgoing option.
    if {$keepgoing} {
        return no
    }

    # NB: Dont force framework to halt tests here. We still need to
    # plot graphs for the incomplete data that we did collect.
    if {$::rvr_overall_timeout_min > 0} {
        set overall_min [expr (double([clock seconds] - $::rvr_overall_start_sec)) / 60]
        set overall_min [format "%.1f" $overall_min]
        UTF::Message INFO "" "overall_timeout overall_min=$overall_min"
        if {$overall_min > $::rvr_overall_timeout_min} {
            UTF::Try "$routerConfig $direction RvR test overall timeout after $overall_min min" {
                error "halting tests after $overall_min min!" 
            }
            return yes
        }
    }
    return no
}

#============== proc plot_graphs ====================================
# Plots the RvR graphs
#====================================================================
proc plot_graphs {file name legend focus AP STA routerConfig direction type arrow plot_graph_ctl\
    nohistograms rampdownonly sta_mfc nomalloc chanint fastrampup nosymmetry udp is_oem_ap\
    nographs mingraphs intsta intgraph chanspec ap_vht_len sta_vht_len musta cst} {

    UTF::Message INFO "" "plot_graphs file=$file name=$name legend=$legend\
        focus=$focus AP=$AP STA=$STA direction=$direction type=$type arrow=$arrow\
        plot_graph_ctl=$plot_graph_ctl nohistograms=$nohistograms rampdownonly=$rampdownonly\
        sta_mfc=$sta_mfc nomalloc=$nomalloc chanint=$chanint fastrampup=$fastrampup\
        nosymmetry=$nosymmetry udp=$udp is_oem_ap=$is_oem_ap\
        nographs=$nographs mingraphs=$mingraphs intsta=$intsta intgraph=$intgraph chanspec=$chanspec\
	ap_vht_len=$ap_vht_len sta_vht_len=$sta_vht_len musta=$musta"

    # Sometimes graphs are not needed.
    if {$nographs} {
        return
    }

    # Define gnuplopt style values to use. See gnuplot manual for more details of parameters.
    set lt0 0 ;# line type 0 - dashed grey
    set lt1 1 ;# line type 1 - solid light red
    set lt2 2 ;# line type 2 - solid light green
    set lt3 3 ;# line type 3 - solid light blue
    set lt4 4 ;# line type 4 - solid light purple
    set lt5 5 ;# line type 5 - solid aqua
    set lt6 6 ;# line type 6 - solid brown
    set lt7 7 ;# line type 7 - solid yellow
    set lt8 8 ;# line type 8 - solid dark blue
    set lt9 9 ;# line type 9 - solid gold
    set lt10 10 ;# line type 10 - solid dark green
    set lt11 11 ;# line type 11 - solid dark purple
    set lt12 12 ;# line type 12 - solid dark brown
    set lt13 13 ;# line type 13 - solid light pink
    set lt14 14 ;# line type 14 - solid lime green
    set lt15 15 ;# line type 15 - solid grey blue
    set lt154 154 ;# line type 154 - solid orange

    set lw1 1 ;# line width 1 point
    set lw2 2 ;# line width 2 points
    set pt0 0 ;# point type 0 - none
    set pt1 1 ;# point type 1 - horizontal bar
    set pt7 7 ;# point type 7 - open box 
    set ps0 0 ;# point size 0 - none
    set ps1 1 ;# point size 1 - smallest

    # Common Thruput CSV fields
    set tput_mean [find_csv_column TputMean]
    set tput_min  [find_csv_column TputMin]
    set tput_max  [find_csv_column TputMax]
    set lower_ctl [find_csv_column LowerControlLimit] 
    set upper_ctl [find_csv_column UpperControlLimit]
    set ap_assoc_authen  [find_csv_column ApAssocAuthen]
    set sta_assoc_beacon [find_csv_column StaBeaconAssoc]

    # For MU graphs plotting
    set stalist "$STA $musta"
    set stalength [llength "$STA $musta"]
    set typelist1 "1 8 7 5 15 10 11 12  2 3 4 6 9  13 14 154"
    set typelist2 "2 3 4 6 9  13 14 154 1 5 7 8 10 11 12 15"
    set typelist3 ""
    set typelist4 ""
    set typelist5 ""
    if {$stalength > 16} {
	for {set i 1} {$i <= $stalength} {incr i} {
	    append typelist3 "8 " 	;# solid dark blue 
	    append typelist4 "9 "	;# solid gold
	}

	# Each 4 clients use same color.
	set j 0
	set colors "1 8 7 5 15 10 11 12"
	for {set i 1} {$i <= $stalength} {incr i} {
	    append typelist5 "[lindex $colors $j] "
	    if {[expr $i % 4] == 0} {
		incr j
	    }
	}
    }

    set mu_graph_list ""

    # Select Y labels for 11ac VHT rate histograms.
    # Newer chips (e.g. 4365) use up to MCS11 rates while older chips only use up to MCS9 rates.
    # Also, newer branches (e.g. EAGLE) support MCS11 rates while older branches only support MCS9 rates.
    # Hence, we need to select label based on the combination of chip and branch used.
    set ap_vht_ylabel ""
    if {$ap_vht_len == 12} {   
	set ap_vht_ylabel "'1x0' 0, '1x5' 5, '1x9' 9, '1x11' 11, '2x0' 12, '2x5' 17, '2x9' 21, '2x11' 23, '3x0' 24, '3x5' 29, '3x9' 33, '3x11' 35, '4x0' 36, '4x5' 41, '4x9' 45, '4x11' 47"
	UTF::Message INFO "" "AP using MCS11 label"
    } else {
	set ap_vht_ylabel "'1x0' 0, '1x5' 5, '1x9' 9, '2x0' 10, '2x5' 15, '2x9' 19, '3x0' 20, '3x5' 25, '3x9' 29"
	UTF::Message INFO "" "AP using MCS9 label"
    }

    set sta_vht_ylabel ""
    if {$sta_vht_len == 12} {
	set sta_vht_ylabel "'1x0' 0, '1x5' 5, '1x9' 9, '1x11' 11, '2x0' 12, '2x5' 17, '2x9' 21, '2x11' 23, '3x0' 24, '3x5' 29, '3x9' 33, '3x11' 35, '4x0' 36, '4x5' 41, '4x9' 45, '4x11' 47"
	UTF::Message INFO "" "STA using MCS11 label"
    } else {
	set sta_vht_ylabel "'1x0' 0, '1x5' 5, '1x9' 9, '2x0' 10, '2x5' 15, '2x9' 19, '3x0' 20, '3x5' 25, '3x9' 29"
	UTF::Message INFO "" "STA using MCS9 label"
    }

    # Palette for CCDF and PER histograms
    set ccdf_palette {( 0 "black", 0.00001 "purple", 0.2 "blue", 0.4 "green", 0.6 "red", 0.8 "yellow", 1 "white")}
    set per_palette  {( -1 "black", 0 "white", 50 "orange", 100 "red")}

    # Add test numbers to graphic names, so they are sorted properly in the summary directory.
    # This also ensures uniqueness when multiple STA are tested in the same testrun.
    # Each STA will have graphs with numbers unique to that test section.
    set name "[UTF::get_testnum]_${name}"

    # Set Y-Axis transport type.
    if {$udp > 0} {
        set transport UDP
    } else {
        set transport TCP
    }

    # Only do the rampdown graph once, includes control limits.
    if {$plot_graph_ctl == "0" || $rampdownonly == "1"} {
        UTF::Try "$routerConfig $direction Performance Test Rampdown Throughput Graph $arrow" {
            set graph [UTF::gnuplot_rvr_lines "$file"\
                "${name}RampdownThroughput" "$::testrig $focus Ch=$chanspec" $direction "Throughput $transport (Mbit/sec)" $type\
                [list linespoints "" $upper_ctl $lt2 $lw1 $pt0 $ps0\
                      errorlines  "" $tput_mean $lt1 $lw1 $pt1 $ps1\
                      linespoints "" $lower_ctl $lt2 $lw1 $pt0 $ps0\
                      linespoints StaBeaconAssoc $sta_assoc_beacon $lt3 $lw1 $pt0 $ps0\
                      linespoints ApAssocAuthen  $ap_assoc_authen  $lt8 $lw1 $pt0 $ps0] rampdown]
            set ::rvr0 $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }

        # Dont do any other graphs for plot_graph_ctl=0. They will be done
        # after the rampup data is available, plot_graph_ctl>0.
        if {$plot_graph_ctl == "0"} {
            return 
        }
    }

    # Show full throughput rampdown/rampup graph, includes control limits.
    if {$fastrampup == 0 } {
        set fr ""
    } else {
        set fr fastrampup
    }
    if {$rampdownonly == "0"} {
        UTF::Try "$routerConfig $direction Performance Test RampdownRampup Throughput Graph $arrow" {
            set graph [UTF::gnuplot_rvr_lines "$file"\
            	"${name}RampdownRampupThroughput" "$::testrig $focus Ch=$chanspec" $direction "Throughput $transport (Mbit/sec)" $type\
                [list linespoints "" $upper_ctl $lt2 $lw1 $pt0 $ps0\
                      errorlines  "" $tput_mean $lt1 $lw1 $pt1 $ps1\
                      linespoints "" $lower_ctl $lt2 $lw1 $pt0 $ps0\
                      linespoints StaBeaconAssoc $sta_assoc_beacon $lt3 $lw1 $pt0 $ps0\
                      linespoints ApAssocAuthen  $ap_assoc_authen  $lt8 $lw1 $pt0 $ps0] $fr]
            set ::rvr1 $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }
    }

    if {$mingraphs} {
        return
    }

    # Show AP graphs (only apply to BRCM AP, not to OEM AP).
    if {$is_oem_ap == "0"} {
        set graph_data [list ::RVR3   ApNRate "MCS (Index), BW (x10 MHz), NSS (#)"\
            		     ::RVR4   ApTxRate "Rate (Mbit/sec)"\
			     ::RVR5   ApConnectTime "Connection time (sec)"\
	    		     ::RVR50  ApPktRetried "Packets (#)"\
			     ::RVR50A ApPktRetryRatio "Percent (%)"\
	    		     ::RVR51  ApPktRetryDropped  "Packets (#)"\
			     ::RVR51A ApPktRetryDropRatio "Percent (%)"\
	    		     ::RVR52  ApTxbfm "Steered Frames (#)"\
			     ::RVR53  ApTxndp "Sounding Frames (#)"\
	    		     ::RVR54  ApSfRatio "Percent (%)"\
			]

	# Show these graphs only for MU tests. 
	if {$musta != "" && $::mumode == "mu"} {
	    lappend graph_data ::RVR58 ApTxAsMu "Frames (#)"
	}

        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {

		if {$field == "ApTxndp"} {
                    set graph [UTF::gnuplot_rvr_lines "$file"\
                    	"${name}${field}" "$::testrig $field+ApRxsf $focus Ch=$chanspec" $direction "$ytitle" $type\
                    	[list linespoints ApTxndp [find_csv_column $field] $lt1 $lw1 $pt7 $ps1\
			      linespoints ApRxsf  [find_csv_column ApRxsf] $lt3 $lw1 $pt7 $ps1] $fr]

		} elseif {$field == "ApNRate"} {
		    # Add ApNss and ApBw to ApMcs to create combo graph.
		    set graph [UTF::gnuplot_rvr_lines "$file"\
			"${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
			[list linespoints Mcs [find_csv_column ApMcs] $lt1 $lw1 $pt7 $ps1\
			      linespoints Bw  [find_csv_column ApBw]  $lt5 $lw1 $pt7 $ps1\
			      linespoints Nss [find_csv_column ApNss] $lt8 $lw1 $pt7 $ps1] $fr]

		} elseif {$field == "ApTxAsMu" && $musta != "" && $::mumode == "mu"} {
		    set aptxasmu_list ""
		    set i 0
		    if {$stalength > 16} {
			foreach sta $stalist {
			    append aptxasmu_list "linespoints $sta [find_csv_column ApTxAsMuSta${i}] [lindex $typelist3 $i] $lw1 $pt7 $ps1 "
			    incr i
			}
			set i 0
		    	foreach sta $stalist {
			    append aptxasmu_list "linespoints $sta [find_csv_column ApTxTotSta${i}] [lindex $typelist4 $i] $lw1 $pt1 $ps1 "
			    incr i
		    	}
		    } else {
		    	foreach sta $stalist {
			    append aptxasmu_list "linespoints $sta [find_csv_column ApTxAsMuSta${i}] [lindex $typelist1 $i] $lw1 $pt7 $ps1 "
			    incr i
			}
			set i 0
		    	foreach sta $stalist {
			    append aptxasmu_list "linespoints $sta [find_csv_column ApTxTotSta${i}] [lindex $typelist1 $i] $lw1 $pt1 $ps1 "
			    incr i
		    	}
		    }

		    set graph [UTF::gnuplot_rvr_lines "$file"\
			"${name}${field}" "$::testrig ApTxAsMu(o)/ApTxTot(+) $focus Ch=$chanspec" $direction "$ytitle" $type\
			$aptxasmu_list $fr]

		    # Add to MuGraphs page.
		    lappend mu_graph_list $graph

		} else {
                    set graph [UTF::gnuplot_rvr_lines "$file"\
                    	"${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    	[list linespoints "" [find_csv_column $field] $lt1 $lw1 $pt7 $ps1] $fr]
		}
                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                return "html:<img src=\"$graph\">"
            }
        }
    }
    
    # Show STA graphs.
    set graph_data [list ::RVR55 StaNRate "MCS (Index), BW (x10 MHz), NSS (#)"\
			 ::RVR6  Rssi "RSSI (dB)"\
		 	 ::RVR7  StaTxRate "Rate (Mbit/sec)"\
			 ::RVR39 TputMean "Rate (Mbit/sec)"\
			 ::RVR57 Temperature "Temperature (C)"\
		   ]
    if {!$nomalloc} {
        lappend graph_data ::RVR8 StaMallocFail "Malloc Fail (count)"
    }
    if {$chanint} {
        lappend graph_data ::RVR9 StaChanInt "STA Channel (number)"
    }

    foreach {handle field ytitle} $graph_data {
        UTF::Try "$routerConfig $direction $field $arrow" {
            set option ""

            if {$field == "Rssi"} {
                set option zerosuppress
		set rssi_list ""
		set i 0
		if {$stalength > 16} {
		    foreach sta $stalist {
		    	append rssi_list "linespoints $sta [find_csv_column StaRssi${i}] [lindex $typelist3 $i] $lw1 $pt7 $ps1 "
		    	incr i
		    }
		    set i 0
		    foreach sta $stalist {
		    	append rssi_list "linespoints \"AP($sta)\" [find_csv_column ApRssi${i}] [lindex $typelist4 $i] $lw1 $pt1 $ps1 "
		    	incr i
		    }
		} else {
                    foreach sta $stalist {
                        append rssi_list "linespoints $sta [find_csv_column StaRssi${i}] [lindex $typelist1 $i] $lw1 $pt7 $ps1 "
                        incr i
                    }
                    set i 0
                    foreach sta $stalist {
                        append rssi_list "linespoints \"AP($sta)\" [find_csv_column ApRssi${i}] [lindex $typelist2 $i] $lw1 $pt1 $ps1 "
                        incr i
                    }
		}

		set graph [UTF::gnuplot_rvr_lines "$file"\
		    "${name}${field}" "$::testrig $field+ApRssi $focus Ch=$chanspec" $direction "$ytitle" $type\
		    $rssi_list zerosuppress $fr]

	    } elseif {$field == "Temperature"} {
		set i 0
		set temp_list "linespoints AP [find_csv_column ApTemp] $lt1 $lw1 $pt7 $ps1 "
		if {$stalength > 16} {
		    foreach sta $stalist {
		    	append temp_list "linespoints $sta [find_csv_column StaTemp${i}] [lindex $typelist4 $i] $lw1 $pt7 $ps1 "
		    	incr i
		    }
		} else {
		    foreach sta $stalist {
		    	append temp_list "linespoints $sta [find_csv_column StaTemp${i}] [lindex $typelist2 $i] $lw1 $pt7 $ps1 "
		    	incr i
		    }
		}

                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    $temp_list zerosuppress $fr]

	    } elseif {$field == "StaNRate"} {
		# Add StaNss and StaBw to StaMcs to create combo graph.
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    [list linespoints Mcs [find_csv_column StaMcs] $lt1 $lw1 $pt7 $ps1\
		    	  linespoints Bw  [find_csv_column StaBw]  $lt5 $lw1 $pt7 $ps1\
                    	  linespoints Nss [find_csv_column StaNss] $lt8 $lw1 $pt7 $ps1] zerosuppress $fr]

	    } elseif {$field == "TputMean" && $musta != ""} {
		set i 0
		# not printing 'Total' curve for mu tests.
		#set tputmean_list "linespoints (Total) [find_csv_column $field] $lt0 $lw1 $pt7 $ps1 "
		set tputmean_list ""
		if {$stalength > 16} {
		    foreach sta $stalist {
		    	append tputmean_list "linespoints $sta [find_csv_column MuTputSta${i}] [lindex $typelist5 $i] $lw1 $pt7 $ps1 "
		    	incr i
		    }
		} else {
		    foreach sta $stalist {
		    	append tputmean_list "linespoints $sta [find_csv_column MuTputSta${i}] [lindex $typelist1 $i] $lw1 $pt7 $ps1 "
		    	incr i
		    }
		}

		set graph [UTF::gnuplot_rvr_lines "$file"\
		    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
		    $tputmean_list zerosuppress $fr]

		# Add to MuGraphs page, but only want mu-version of TputMean graph.
		if {$::mumode == "mu"} {
		    lappend mu_graph_list $graph
		}

            } else {
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    [list linespoints "" [find_csv_column $field] $lt1 $lw1 $pt7 $ps1] $option $fr]
            }

            set var [string tolower $handle]
            set $var $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }
    }

    # Show AP histograms.
    if {!$nohistograms && $is_oem_ap == "0"} {
        set graph_data [list ::RVR10 ApRxMcs "MCS Rate (Index #)"\
            		     ::RVR11 ApTxMcs "MCS Rate (Index #)"\
			     ::RVR12 ApMpdu "MPDU Density"\
            		     ::RVR13 ApRxMcsSgi "MCS Rate (Index #)"\
			     ::RVR14 ApTxMcsSgi "MCS Rate (Index #)"\
            		     ::RVR15 ApDelay "Delay (milli-seconds)"\
			     ::RVR16 ApCcdf "Delay (milli-seconds)"\
            		     ::RVR17 ApPer PER\
			     ::RVR30 ApRxVht "VHT Rate"\
			     ::RVR31 ApTxVht "VHT Rate"\
            		     ::RVR32 ApRxVhtSgi "VHT Rate"\
			     ::RVR33 ApTxVhtSgi "VHT Rate"\
			     ::RVR33A ApVhtPer PER\
			]
        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {
                set col [find_csv_column $field]
                if {$field == "ApCcdf"} {
                    # ApCcdf uses special palette & scale 
                    set ::gnuplot_rvr_palette $ccdf_palette
                    set option logscale
		} elseif {$field == "ApVhtPer" || $field == "ApPer"} {
		    # PER histograms use different palette.
		    set ::gnuplot_rvr_palette $per_palette
		    # PER histograms use -1 to fill up all non-used spots.
		    set option perhistogram
                } else {
                    set option normalize
                }
                if {[regexp -nocase {Vht} $field]} {
                    # Vht uses special list of y-axis labels
                    set ::gnuplot_rvr_ylabel $ap_vht_ylabel
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    [list image "" $col $lt1 $lw1 $pt0 $ps0] $option $fr]

                if {$field == "ApTxVht" && $musta != "" && $::mumode == "mu"} {
		    lappend mu_graph_list $graph
                }

                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                catch {unset ::gnuplot_rvr_palette}
                catch {unset ::gnuplot_rvr_ylabel}
                return "html:<img src=\"$graph\">"
            }
        }
    }
    
    # Show STA histograms.
    if {!$nohistograms} {
        set graph_data [list ::RVR20 StaRxMcs "MCS Rate (Index #)"\
            		     ::RVR21 StaTxMcs "MCS Rate (Index #)"\
			     ::RVR22 StaMpdu "MPDU Density"\
            		     ::RVR23 StaRxMcsSgi "MCS Rate (Index #)"\
			     ::RVR24 StaTxMcsSgi "MCS Rate (Index #)"\
            		     ::RVR25 StaDelay "Delay (milli-seconds)"\
			     ::RVR26 StaCcdf "Delay (milli-seconds)"\
            		     ::RVR27 StaPer PER\
			     ::RVR34 StaRxVht "VHT Rate"\
			     ::RVR35 StaTxVht "VHT Rate"\
            		     ::RVR36 StaRxVhtSgi "VHT Rate"\
			     ::RVR37 StaTxVhtSgi "VHT Rate"\
			     ::RVR38 StaVhtPer PER\
			]
        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {
                set col [find_csv_column $field]
                if {$field == "StaCcdf"} {
                    # StaCcdf uses special palette & scale
                    set ::gnuplot_rvr_palette $ccdf_palette
                    set option logscale
                } elseif {$field == "StaVhtPer" || $field == "StaPer"} {
		    # PER histograms use different palette. 
		    set ::gnuplot_rvr_palette $per_palette
                    # PER histograms use -1 to fill up all non-used spots.
                    set option perhistogram
                } else {
                    set option normalize
                }
                if {[regexp -nocase {Vht} $field]} {
                    # Vht uses special list of y-axis labels
                    set ::gnuplot_rvr_ylabel $sta_vht_ylabel
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "$ytitle" $type\
                    [list image "" $col $lt1 $lw1 $pt0 $ps0] $option $fr]

		if {$field == "StaRxVht" && $musta != "" && $::mumode == "mu"} {
		    lappend mu_graph_list $graph
		}

                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                catch {unset ::gnuplot_rvr_palette}
                catch {unset ::gnuplot_rvr_ylabel}
                return "html:<img src=\"$graph\">"
            }
        }
    }   

    # Do we want the interference count graphs?
    if {$intsta != "" || $intgraph == 1} {
        if {$is_oem_ap == "0"} {
            set graph_data [list ::RVR40 ApRxBadFcs\
				 ::RVR41 ApRxBadPlcp\
				 ::RVR42 ApRxCrsGlitch\
            			 ::RVR43 ApRxdFrmUcastMbss\
				 ::RVR44 ApRxStrt\
            			 ::RVR45 StaRxBadFcs\
				 ::RVR46 StaRxBadPlcp\
				 ::RVR47 StaRxCrsGlitch\
            			 ::RVR48 StaRxdFrmUcastMbss\
				 ::RVR49 StaRxStrt\
			   ]
        } else {
            set graph_data [list ::RVR45 StaRxBadFcs\
				 ::RVR46 StaRxBadPlcp\
				 ::RVR47 StaRxCrsGlitch\
            			 ::RVR48 StaRxdFrmUcastMbss\
				 ::RVR49 StaRxStrt\
			   ]
        }
        foreach {handle field} $graph_data {
            UTF::Try "$routerConfig $direction Performance Test $field $arrow" {
                set col [find_csv_column $field]
                if {[regexp -nocase {^Ap} $field]} {
                    set dev $AP
                } else {
                    set dev $STA
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $focus Ch=$chanspec" $direction "Delta Count / Step" $type\
                    [list linespoints $dev $col $lt1 $lw1 $pt7 $ps1] $fr]
                set var [string tolower $handle] ;# global variable corresponding to the handle
                set $var $graph ;# for calling routine
                return "html:<img src=\"$graph\">"
            }
        }
    }

    if {$musta != "" && $::mumode == "mu"} {
	lappend ::mu_graph_list $mu_graph_list
    }
    return 
}

#============== proc rate_adapt_cc ==================================
# Produces separate control charts for MCS/Legacy rates.
#
# Puts 4 control charts on the summary web page.
#====================================================================
proc rate_adapt_cc {STA LAN routerConfig direction history key_template readonly\
    udp focus chanspec attnstep fastrampup} {

    # Do 2 rate adaptation control charts as one result. Repeat for Hi & Low values.
    # We have separate lists of attn/rate pairs for rampdown & rampup.
    # For Hi, we want the last hi rates from either end of the RvR curve
    # For Lo, we want the first lo rates from the centre of the RvR curve
    # For Hi & fastrampup, need inc2=0, not attnstep.
    if {$fastrampup} {
        set inc2_hi 0
    } else {
        set inc2_hi $attnstep
    }
    foreach {handle desc dir1 ind1 inc1 dir2 ind2 inc2}\
        "::rvrb StaMcsHi forward end $attnstep reverse end $inc2_hi\
        ::rvrc StaMcsLo reverse end -$attnstep forward end -$attnstep" {

        UTF::Try "$STA $routerConfig $direction $desc" {
            # Initialization
            UTF::Message INFO "" "handle=$handle desc=$desc dir1=$dir1 ind1=$ind1\
                inc1=$inc1 dir2=$dir2 ind2=$ind2 inc2=$inc2"
            set $handle "" ;# variable to pass controlchart pathnames back
            # Set Y-Axis title
            if {$udp > 0} {
                set xport UDP
            } else {
                set xport TCP
            }
            set title1 "$::testrig $::int_desc ${desc}Down $xport $routerConfig Ch=$chanspec $focus $direction"
            set title2 "$::testrig $::int_desc ${desc}Up $xport $routerConfig Ch=$chanspec $focus $direction"

            # Rampdown rate adapation CC. dir1 & ind1 are used to choose value.
            regsub -nocase "AttnUp" $key_template "" key_template
            regsub -nocase "\{step\}" $key_template "${desc}Down" keys
            set val [UTF::find_consecutive_values "$::rvr_rampdown_rates_list" $::rvr_rate_cnt $dir1 $ind1 $inc1]
            set catch_msg1 ""
            if {$val != ""} {
                catch {UTF::update_control_chart_data $keys $val $readonly CC\
		    "ZERO|LOW|WIDE|HIGH" $STA $LAN $direction 1 $history $title1 dB Attenuation} catch_msg1
                lappend $handle $::uccd_png_path ;# save first CC graphic
                save_results $STA $LAN "$keys" $routerConfig $chanspec $direction "${desc}Down" $val
            }

            # Rampup rate adaptation CC. dir2 & ind2 are used to choose value.
            regsub -nocase "\{step\}" $key_template "${desc}Up" keys
            set val [UTF::find_consecutive_values "$::rvr_rampup_rates_list" $::rvr_rate_cnt $dir2 $ind2 $inc2]
            set catch_msg2 ""
            if {$val != ""} {
                catch {UTF::update_control_chart_data $keys $val $readonly CC\
		    "ZERO|LOW|WIDE|HIGH" $STA $LAN $direction 1 $history $title2 dB Attenuation} catch_msg2
                lappend $handle $::uccd_png_path ;# save second CC graphic
                save_results $STA $LAN "$keys" $routerConfig $chanspec $direction "${desc}Up" $val
            }

            # Massage into one composite result.
            regsub {^html:} $catch_msg1 "" catch_msg1
            regsub {^html:} $catch_msg2 "" catch_msg2
            set result "html: <b>${desc}Down</b> $catch_msg1 <br><b>${desc}Up</b> $catch_msg2"

            return $result
        }
    }
}

#============== proc refresh_addr ===================================
# After reassociation, refreshes STA ip address.
#
# returns null
#====================================================================
proc refresh_addr {STA reassoc refreshaddralways refreshaddrasneeded i routerConfig direction loss} {

    # Some devices may need IP address refreshed at this point.
    set sta_name [UTF::get_name $STA]
    UTF::Message INFO "$sta_name" "refresh_addr loss=$loss reassoc=$reassoc \
        refreshaddralways=$refreshaddralways\
        refreshaddrasneeded=$refreshaddrasneeded i=$i\
        ::refresh_addr=$::refresh_addr"
    if {$refreshaddralways == 0 && $refreshaddrasneeded == 0} {
        return
    }

    # Change state as appropriate.
    if {($reassoc == 1 && $refreshaddrasneeded == 1) ||\
        $refreshaddralways == 1} {
        set ::refresh_addr "NEEDED"
    }
    if {$::refresh_addr != "NEEDED"} {
        return
    }

    # Some devices may need IP address refreshed at this point.
    UTF::Try "$routerConfig $direction Loss: $loss $STA refresh IP address after rejoin ($i)" {
        set ip [$STA cget -ipaddr]
        UTF::Message INFO "$sta_name" "refresh_addr reassoc=$reassoc \
            refreshaddralways=$refreshaddralways\
            refreshaddrasneeded=$refreshaddrasneeded i=$i\
            ::refresh_addr=$::refresh_addr"
        set new_addr [$STA ifconfig $ip]
        set ::refresh_addr "DONE"
        UTF::Message INFO "$sta_name" "refresh_addr ::refresh_addr=$::refresh_addr new_addr=$new_addr"
        return $new_addr
    }
}

#============== proc rejoin =========================================
# Rejoins connection as needed. Add web page entries when we lose
# beacons and/or association and when we regain beacons and/or 
# association.
#
# returns 1 when STA is re-associated.
#====================================================================
proc rejoin {apSsid STA musta step pathloss noredundant refreshaddralways refreshaddrasneeded\
    routerConfig direction is_oem_ap chanspec} {

    # If STA is known to be in trouble, return.
    set var "::${STA}_state"
    if {[set $var] != "OK"} {
        #UTF::Message INFO "" "rejoin sta_state=[set $var]"
        return
    }

    # Some people really want to have this redundant call made to preserve timing.
    set sta_name [UTF::get_name $STA]
    if {$noredundant == "0"} {
        # Get beacon & association state info. Uses same logic as proc UTF::sta_stats.
        set catch_msg ""
        set catch_resp [catch {$STA wl assoc} catch_msg]
        UTF::save_device_state $STA $catch_msg
        set curr_state "NULL"
        if {[regexp -nocase {not.*associated} $catch_msg]} {
            set curr_state ROAMING
        } elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $catch_msg]} {
            set curr_state ASSOCIATED ;# but no beacons
        } elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $catch_msg]} {
            set curr_state "ASSOCIATED BEACONS"
        }

    } else {
        # UTF::sta_stats leaves the STA assoc info for us.
        set temp "::${STA}_assoc"
        if {![info exists $temp]} {
            set $temp "NULL"
        }
        set curr_state [set $temp]
        set temp "::${STA}_msg"
        if {![info exists $temp]} {
            set $temp ""
        }
        set catch_msg [set $temp]
        UTF::Message INFO "$sta_name" "duplicated msg from sta_stats: $catch_msg"
    }
    set loss [expr $step + $pathloss]
    UTF::Message INFO "$::localhost" "rejoin step=$step loss=$loss\
        ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid\
        noredundant=$noredundant refreshaddralways=$refreshaddralways\
        refreshaddrasneeded=$refreshaddrasneeded routerConfig=$routerConfig\
        direction=$direction is_oem_ap=$is_oem_ap chanspec=$chanspec"

    # Push the state change onto the main web page.
    set reassoc ""
    if {$curr_state != $::rejoin_old_state} {
        UTF::Try "$routerConfig $direction $::aux_desc STA state change: $::rejoin_old_state --> $curr_state" {
            UTF::Message INFO "$::localhost" "rejoin step=$step loss=$loss\
                ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid\
                noredundant=$noredundant"
            UTF::Message INFO "$sta_name" "duplicated msg: $catch_msg"

	    foreach sta "$STA $musta" {
		$sta wl escanresults -s $apSsid -t active
		$sta wl escanresults -s $apSsid -t passive
	    }

            set chan [$STA wl chanspec]  
            return $chan
        }

        # Did we reassociate?
        if {$::rejoin_old_state == "ROAMING" && [regexp {ASSOCIATED} $curr_state]} {
            set reassoc 1
        }
    }

    # Refresh addr as needed
    refresh_addr $STA $reassoc $refreshaddralways $refreshaddrasneeded 1 $routerConfig $direction $loss 

    # If STA is associated, with/without beacons, then we are done.
    set ::rejoin_old_state $curr_state
    if {[regexp {ASSOCIATED} $curr_state]} {
        return $reassoc
    }

    # STA is NOT associated, so try to join. 
    for {set i 1} {$i <= $::rvr_rejoin_tries} {incr i} {
        # Join if STA is OK.
        if {[set $var] != "OK"} {
            return
        }
        UTF::Message INFO "$::localhost" "rejoin Try#$i"
        set catch_msg ""
        if {$is_oem_ap == 0} {
            set catch_resp [catch {$STA wl join $apSsid} catch_msg]
        } else {
            # Some OEM AP will broadcast the same SSID on both bands simultaneously.
            # So we need to specify which channel / band to use.
            set catch_resp [catch {$STA wl join $apSsid --chanspec=$chanspec} catch_msg]
        }
        UTF::save_device_state $STA $catch_msg
        UTF::Sleep $::rvr_rejoin_wait_sec
        if {[set $var] != "OK"} {
            return
        }

        # Parse for association & beacon state. Uses same logic as proc UTF::sta_stats.
        set catch_msg ""
        set catch_resp [catch {$STA wl assoc} catch_msg]
        UTF::save_device_state $STA $catch_msg
        set curr_state "NULL"
        if {[regexp -nocase {not.*associated} $catch_msg]} {
            set curr_state ROAMING
        } elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $catch_msg]} {
            set curr_state ASSOCIATED ;# but no beacons
        } elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $catch_msg]} {
            set curr_state "ASSOCIATED BEACONS"
        }

        # If assocated, with/without beacons, push the state change onto the main web page.
        if {[regexp {ASSOCIATED} $curr_state]} {
            UTF::Try "$routerConfig $direction $::aux_desc STA state change: $::rejoin_old_state --> $curr_state Try#$i" {
                UTF::Message INFO "$::localhost" "rejoin step=$step loss=$loss\
                    ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid"
                UTF::Message INFO "$sta_name" "duplicated msg $catch_msg"
                set chan [$STA wl chanspec]  
                return $chan
            }
            set ::rejoin_old_state $curr_state

            # Support for -post_assoc_hook
            if {[$STA cget -post_assoc_hook] ne ""} {
                UTF::Message INFO "$STA" "running -post_assoc_hook"
                eval [string map [list %S $STA] [$STA cget -post_assoc_hook]]
            }

            # Some devices may need IP address refreshed at this point.
            refresh_addr $STA 1 $refreshaddralways $refreshaddrasneeded 2 $routerConfig $direction $loss
            return 1 ;# let calling routine know we have now successfully reassociated.
        }
    }

    # One (or more) join attempts failed. That happens all the time with 
    # high attenuation. Nothing more to do here.
    return
}

#============== proc rejoin_cc ======================================
# Produces separate control charts for rejoin attn & tput values.
#
# Puts 2 control chart on the summary web page.
#====================================================================
proc rejoin_cc {STA LAN routerConfig direction history key_template readonly udp focus chanspec} {

    # For rampdownonly, there wont be any result data.
    set ::rvra "" ;# variable to pass controlchart pathnames back
    if {$::rvr_rejoin_result == ""} {
        return
    }

    # Parse rejoin results
    set attn [lindex $::rvr_rejoin_result 0]
    set size1 1 ;# make sure we always use MemChart, not ControlChart
    set tput [lrange $::rvr_rejoin_result 1 end]
    set size2 [llength $tput]
    if {$size2 < 2} {
        set size2 2 ;# make sure we always use ControlChart, not MemChart
    }

    # Do 2 control charts as one result.
    UTF::Try "$STA $routerConfig $direction Rejoin" {

        # Set Y-Axis title
        if {$udp > 0} {
            set xport UDP
        } else {
            set xport TCP
        }
        set title1 "$::testrig $::int_desc Rejoin Attn $xport $routerConfig Ch=$chanspec $focus $direction"
        set title2 "$::testrig $::int_desc Rejoin Tput $xport $routerConfig Ch=$chanspec $focus $direction"

        # Attn CC
        regsub -nocase "AttnUp" $key_template "AttnDown" key_template
        regsub -nocase "\{step\}" $key_template "RejoinAttn" keys
        catch {UTF::update_control_chart_data $keys $attn $readonly CC\
	    "ZERO|LOW|WIDE|HIGH" $STA $LAN $direction $size1 $history $title1 dB Attenuation} catch_msg1
        lappend ::rvra $::uccd_png_path ;# save first CC graphic

        # Tput CC
        regsub -nocase "\{step\}" $key_template "RejoinTput" keys
        catch {UTF::update_control_chart_data $keys $tput $readonly CC\
	    "ZERO|LOW|WIDE|HIGH" $STA $LAN $direction $size2 $history $title2 "Mbit/sec" "Throughput $xport"} catch_msg2
        lappend ::rvra $::uccd_png_path ;# save second CC graphic

        # Massage into one composite result.
        regsub {^html:} $catch_msg1 "" catch_msg1
        regsub {^html:} $catch_msg2 "" catch_msg2
        set result "html: <b>RejoinAttn</b> $catch_msg1 <br><b>RejoinTput</b> $catch_msg2"

        return $result
    }
}

#============== proc rename_perfcache_file ==========================
# Transition aid to rename old format perfcache data files.
#
# Not used anymore.
#====================================================================
proc rename_perfcache_file {old_keys new_keys STA LAN direction stream} {
    UTF::Message INFO "" "rename_perfcache_file old_keys=$old_keys\
        new_keys=$new_keys STA=$STA LAN=$LAN direction=$direction stream=$stream"
    return ;# not used anymore

    # Define file names of perfcache files.
    set perfcache [file dirname "$UTF::Logfile"]
    set perfcache [file dirname "$perfcache"]
    set perfcache "$perfcache/perfcache"
    if {$direction == "Upstream"} {
        set old_file "$old_keys \{$STA $LAN\}.data"
        set new_file "$new_keys \{$STA $LAN\}.data"
    } else {
        set old_file "$old_keys \{$LAN $STA\}.data"
        set new_file "$new_keys \{$LAN $STA\}.data"
    }

    # Try to locate new perfcache data file. If new one exists 
    # already, we leave any old one alone.
    if {[file exists "$perfcache/$new_file"]} {
        UTF::Message INFO "" "rename_perfcache_file found new: $new_file"
    } else {
        UTF::Message INFO "" "rename_perfcache_file NOT found new: $new_file"

        # If old perfcache data file exists, rename it to new format.
        if {[file exists "$perfcache/$old_file"]} {
            UTF::Message INFO "" "rename_perfcache_file found old: $old_file\
                renaming to new: $new_file"
            set catch_resp [catch {file rename -force $perfcache/$old_file $perfcache/$new_file} catch_msg]
            if {$catch_resp != 0} {
                UTF::Message ERROR "" "rename_perfcache_file: catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        } else {
            UTF::Message INFO "" "rename_perfcache_file: NOT found old $old_file"
        }
    }

    # Now we deal with the issue of stream being "---"
    if {$stream == "---"} {
        return
    }

    # If we have an existing data file with stream "---", we rename it.
    regsub $stream $new_keys "---" temp_keys
    if {$direction == "Upstream"} {
        set old_file "$temp_keys \{$STA $LAN\}.data"
    } else {
        set old_file "$temp_keys \{$LAN $STA\}.data"
    }
    if {[file exists "$perfcache/$new_file"]} {
        UTF::Message INFO "" "rename_perfcache_file found new: $new_file"
    } else {
        UTF::Message INFO "" "rename_perfcache_file NOT found new: $new_file"

        # If old perfcache data file exists, rename it to new format.
        if {[file exists "$perfcache/$old_file"]} {
            UTF::Message INFO "" "rename_perfcache_file found old: $old_file\
                renaming to new: $new_file"
            set catch_resp [catch {file rename -force $perfcache/$old_file $perfcache/$new_file} catch_msg]
            if {$catch_resp != 0} {
                UTF::Message ERROR "" "rename_perfcache_file: catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        } else {
            UTF::Message INFO "" "rename_perfcache_file: NOT found old $old_file"
        }
    }
    return
}

#============== proc rvr_symmetry_control_charts ====================
# Does control chart tests of rampup data against the rampdown 
# perfcache data.
#====================================================================
proc rvr_symmetry_control_charts {attnDirection key_template STA LAN direction\
    arrow pathloss csv_file rampdown_attn_range start_rampup_step attnstep\
    iperf_sample_size zero_samples history fastrampup routerConfig} {

    # Nothing to do for attn direction up / rampdown part of tests.
    # Not relevant for fastrampup
    if {$attnDirection eq "up" || $fastrampup == 1} {
        return
    }

    # On occasion, a rampup test may get cut short, and not generate a full 
    # set of data. For the symmetry tests, we want to test all the points that 
    # were generated on the rampdown test. So we use the rampdown range of
    # attenuator values to generate the list of points we will verify here. 
    set steps ""
    set range1 [lindex $rampdown_attn_range 0]
    set range2 [lindex $rampdown_attn_range 1]
    if {$range1 == "" || $range2 == ""} {
        return
    }
    if {$start_rampup_step == ""} {
        set maxstep $range2
    } else {
        set maxstep $start_rampup_step ;# rampdown was stopped due to no beacons.
    }

    # When adding support to use -attnstep=0.5, has to replace 'for' loop with 'while' loop
    # because 'incr' command only supports integer increment. 02/04/2014
    # for {set i $range1} {$i <= $maxstep} {incr i $attnstep} {
    #     lappend steps $i
    # }
    set i $range1
    while {$i <= $maxstep} {
	lappend steps $i
	set i [expr $i + $attnstep]
    }    

    # Put all symmetry control charts under a single heading.
    UTF::Try "$routerConfig $direction RvR Symmetry Control Chart Tests $arrow" {
        UTF::Message INFO "" "rvr_symmetry_control_charts\
            attnDirection=$attnDirection key_template=$key_template STA=$STA\
            LAN=$LAN direction=$direction arrow=$arrow pathloss=$pathloss\
            csv_file=$csv_file rampdown_attn_range=$rampdown_attn_range\
            start_rampup_step=$start_rampup_step attnstep=$attnstep\
            iperf_sample_size=$iperf_sample_size zero_samples=$zero_samples\
            history=$history fastrampup=$fastrampup"
        UTF::Message INFO "" "rvr_symmetry_control_charts range1=$range1 range2=$range2\
            start_rampup_step=$start_rampup_step steps=$steps"

        # If perfcache file is not found by update_control_chart_data, issues will be save here.
        catch {unset ::perfcache_not_found}

        foreach step $steps {
            if {[info exists ::rvr_rampup_data($step)]} {
                set samples $::rvr_rampup_data($step)
            } else {
                set samples $zero_samples
            }
            set loss [expr $step + $pathloss] ;# total pathloss for this test
            UTF::Message INFO "" "rvr_symmetry_control_charts step=$step\
                loss=$loss samples=$samples"

            # Check the specific attenuation point rampup samples against the
            # control chart rampdown data. Do not update the perfcache data.
            UTF::Try "Rvr Symmetry Attn: $step Loss: $loss $arrow" {
                set keys ""
                regsub "\{step\}" $key_template $step keys ;# replace {step} with attenuator step value
                UTF::Message INFO "" "rvr_symmetry_control_charts step=$step\
                    loss=$loss samples=$samples keys=$keys"
                set catch_resp ""
                set catch_msg ""
                set catch_resp [catch {UTF::update_control_chart_data $keys $samples 1 CC\
		    "LOW|WIDE|HIGH" $STA $LAN $direction $iperf_sample_size $history} catch_msg]
                if {$catch_resp != 0} {
                    # Collect list of all non-symmetric loss points.
                    append ::rvr_symmetry_errors " $loss,"
                    set catch_msg "$catch_msg symmetry error" ;# discretely flag error
                }

                # We always return the individual control chart comparison as a PASS.
                # We dont want to generate 50 or more errors from one symmetry test.
                return $catch_msg
            }
        }

        # Log the symmetry errors, if any, in the CSV file.
        set resultsfileId [open $csv_file a]
        puts $resultsfileId "rvr symmetry errors at loss: $::rvr_symmetry_errors"
        close $resultsfileId

        # Check for any percache files not found.
        if {[info exists ::perfcache_not_found]} {
            UTF::Message INFO "" "rvr_symmetry_control_charts\
                perfcache_not_found=$::perfcache_not_found"
        }

        # Overall symmetry test result is based on ::rvr_symmetry_errors
        set ::rvr_symmetry_errors [string trim $::rvr_symmetry_errors]
        if {$::rvr_symmetry_errors == ""} {
            return 
        } else {
            error "symmetry issues at loss: $::rvr_symmetry_errors dB"
        }
    }
    return
}

#============== proc save_results ===================================
# Adds an entry to running rvr results file for this testrig.
# Data is used by other scripts, such as RvRFastSweep.
#====================================================================
proc save_results {STA LAN keys routerConfig chan direction desc val} {

    # Open running results file for this specific testrig
    set SummaryLoc [file dirname "$UTF::Logfile"]
    set results_path "$SummaryLoc/../${::testrig}_rvr_results.data"
    set fd [open $results_path a]
    # UTF::Message INFO "" "save_results results_path=$results_path fd=$fd"

    # Use keyword=value syntax, with commas to separate strings.
    # The keys often have spaces embedded, so comma delimiter helps
    # the other scripts parsing routines.
    puts $fd "STA=$STA, LAN=$LAN, keys=$keys, routerConfig=$routerConfig, chan=$chan,\
        direction=$direction, desc=$desc, val=$val, report=$SummaryLoc/summary.html,"
    close $fd
    return
}

#============== proc set_arrow_label ================================
# Returns a text label string
#====================================================================
proc set_arrow_label {STA musta LAN direction} {

    # Set direction label for web page headers.
    if {$musta != ""} {
    	set arrow "$LAN<=STAs"
	if {$direction == "Downstream"} {
	    set arrow "$LAN=>STAs"
	}
    } else {
    	set arrow "$LAN<=$STA"
    	if {$direction == "Downstream"} {
	    set arrow "$LAN=>$STA"
	}
    }
    return $arrow
}

#============== proc setup_ap_sniffer ===============================
# Does setup for AP & optional sniffer.
#====================================================================
proc setup_ap_sniffer {AP STA sniffer chanspec fb0 fb1 nobtreset softap is_oem_ap} {

    if {[info exists ::test_mode] && $::test_mode == 1} {
        return
    }

    # ap_type is used for titles, etc
    if {$softap} {
        set ap_type "SoftAP"
    } else {
        set ap_type "AP"
    }

    set ap_chan_resp -1 ;# -1 used to detect failures

    UTF::Try "APChanspec $ap_type $chanspec" {
        if {$softap == 0 && !$is_oem_ap} {
            # Do this setup only for Real BRCM AP
            # Restore AP nvram is done by the higher level RvRNightly1.test
            # AP setup - turn on the radio!!!
            UTF::Message INFO "" "\n\nTurn on $ap_type radio\n\n"
            set catch_resp [catch {UTF::set_ap_nvram $AP wlN_radio=1} catch_msg]
            if {$catch_resp != 0} {
                error "Could not turn on radio: $catch_msg"
            }

            # User may have specified additional AP nvram settings to be used only for a specific STA.
            # EG: set ::mc356_43236USB_rtr_nvram {antswitch=0 a=b c=d}
            set var "::${STA}_rtr_nvram"
            if {[info exists $var]} {
                set value [set $var]
                UTF::Message INFO "" "\n\nsetup_ap_sniffer found: $var=$value\n\n"
                $AP restart $value
                $AP reboot
            }
        }

        # Dont set channel for OEM AP.
        if {!$is_oem_ap} {
            UTF::Message INFO "" "\n\n$ap_type chanspec=$chanspec\n\n"
            set ap_chan_resp [catch {UTF::Test::APChanspec $AP $chanspec} catch_msg]
            if {$ap_chan_resp != 0} {
                error "setup_ap_sniffer ERROR: invalid Ch $chanspec, $catch_msg"
            }
        }

        # AP/SoftAP setup
        catch {$AP wl interference} ;# log current setting
        UTF::init_device $AP $::rvr_ap_init

        # Reset all BT devices in testrig, if any. If you dont do this,
        # your WLAN throughput can be only 50% of what you expect.
        if {$nobtreset == 0} {
            UTF::reset_all_bt_devices
        }

        # If user didnt specify either frameburst option, the default is currently frameburst=off
        # Eventually the default will be frameburst on.
        UTF::Message INFO "" "\n\nFrameburst setup\n\n"
        if {($fb0 == 0 && $fb1 == 0) || $fb0 == 1} {
            set catch_resp [catch {$AP wl frameburst 0} catch_msg]
            set ::rvr_fb 0
        } elseif {$fb1 == 1} {
            set catch_resp [catch {$AP wl frameburst 1} catch_msg]
            set ::rvr_fb 1
        }
        if {$catch_resp != 0} {
            UTF::Message ERROR "" "setup_ap_sniffer setting frameburst got: $catch_msg"
        }

        # Log AP version info
        UTF::Message INFO "" "\n\nGet AP driver versions & hardware\n\n"
        if {$is_oem_ap} {
            set ap_ver OEM
        } elseif {$softap} {
            set ap_ver [$AP wl ver]
        } else {
            set ap_ver [$AP nvram get os_version]
        }
        if {$is_oem_ap} {
            set ap_hw OEM
        } else {
            set ap_hw [$AP whatami]
        }
        regsub -all { } $ap_hw "_" ap_hw
        set msg "html: $ap_type: $ap_ver $ap_hw"
        regsub -all {\n} $msg " " msg
        return "$msg"
    }

    # If AP general setup failed, halt the tests.
    if {$ap_chan_resp == "-1" && $is_oem_ap == 0} {
        error "setup_ap_sniffer ERROR: halting tests, $ap_type $AP setup failed"
    }

    # If AP could not set the chanspec, halt the tests. We dont
    # want to proceed using the previous channel, whatever that may be.
    # The graphs and perfcache data would all show the wrong channel, which would be very bad!
    if {$ap_chan_resp != 0 && $is_oem_ap == 0} {
        error "setup_ap_sniffer ERROR: halting tests, invalid Ch $chanspec"
    }

    # Setup the optional sniffer.
    UTF::setup_sniffer $sniffer $chanspec
}

#=============== proc setup_sta =====================================
# Does setup for STAs.
#====================================================================
proc setup_sta {STA chanspec fb0 fb1 wet} {

    if {[info exists ::test_mode] && $::test_mode == 1} {
        return
    }

    UTF::Try "Setup STA $STA" {
        catch {$STA wl interference} ;# log current setting
        if {$wet} {
            UTF::Message INFO "" "\n\nSTA chanspec=$chanspec\n\n"
            UTF::Test::APChanspec $STA $chanspec
            UTF::init_device $STA $::rvr_ap_init
        } else {
            UTF::init_device $STA $::rvr_sta_init
        }

        # If user didnt specify either frameburst option, the default is currently frameburst=off.
        # Eventually the default will be frameburst on.
        UTF::Message INFO "" "\nFrameburst setup\n"
        if {($fb0 == 0 && $fb1 == 0) || $fb0 == 1} {
            set catch_resp [catch {$STA wl frameburst 0} catch_msg]
            set ::rvr_fb 0
        } elseif {$fb1 == 1} {
            set catch_resp [catch {$STA wl frameburst 1} catch_msg]
            set ::rvr_fb 1
        }
        if {$catch_resp != 0} {
            UTF::Message ERROR "" "setup_sta setting frameburst got: $catch_msg"
        }

        # Log STA version info
        UTF::Message INFO "" "\nGet STA driver versions & hardware\n"
        if {$wet} {
            set sta_ver [$STA nvram get os_version]
        } else {
            set sta_ver [$STA wl ver]
        }
        set sta_hw [$STA whatami]
        regsub -all { } $sta_hw "_" sta_hw
        set msg "html: STA: $sta_ver $sta_hw"
        regsub -all {\n} $msg " " msg
        return "$msg"
    }
}

#============== proc setup_int_sta ==================================
# Does optional setup interference STA 
#====================================================================
proc setup_int_sta {int_sta band int_attn int_chan int_type rate nrate pkt_gap pkt_size int_quiet} { 

    # Interference test is optional
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    if {$int_sta == ""} {
        UTF::Message INFO "" "setup_int_sta int_sta is null"
        return
    }

    # Used by other routines & controlchart keys.
    set ::int_chan $int_chan

    # Save rate / nrate for other routines & controlchart keys.
    set rate [string trim $rate]
    if {$rate != ""} {
        set ::intNrate "R=$rate"
    } else {
        set ::intNrate "MCS=$nrate"
    }

    # Description string for graphs
    set ::int_desc "Interf: CH=$::int_chan $int_type $::intNrate"

    set setup_OK no ;# detect setup error
    UTF::Try "Setup interference STA=$int_sta CH=$::int_chan int_type=$int_type $::intNrate" {
        UTF::Message INFO "" "setup_int_sta int_sta=$int_sta band=$band\
            int_attn=$int_attn int_chan=$int_chan int_type=$int_type\
            rate=$rate nrate=$nrate pkt_gap=$pkt_gap pkt_size=$pkt_size\
            int_quiet=$int_quiet"

        # RvRNightly1.test checks that we have a valid STA and loads it.
        set var "::${int_sta}_state"
        set $var Check
        UTF::progressive_recovery $int_sta 0 - 1 0

        # Setup optional attenuator for interference STA.
        if {$int_attn != ""} {
	    # Variable int_attn is expected to be: attn_grp attn_val [attn_val1, attn_val2...].
	    # If more than 1 attn values are present (eg: int_attn=G2 0 30), we are expecting
	    # a same-numbered loop test (i.e loop=2) where each loop will use a different attn value.
	    # Otherwise, it's just a regular loop test where each loop uses the same attn value.
            set grp [lindex $int_attn 0]
            set val [lindex $int_attn 1]
	    if {[llength $int_attn] > 2} {
		# More than 1 attn value exist and we're going to use them for loop test.
		set val [lindex $int_attn $::loop_counter]
		UTF::Message INFO $int_sta "setup_int_sta: loop_counter=$::loop_counter"
	    }
            UTF::Message INFO $int_sta "setup_int_sta: $grp attn $val"
            $grp attn $val
        }

        # Set interference channel
        set is_ap [UTF::is_ap $int_sta]
        catch {$int_sta wl disassoc}
        catch {$int_sta wl down}
        catch {$int_sta wl mimo_bw_cap 1}
        # Need to band lock STA so shmem command will work
        if {$band == "5" || $band == "a"} {
            catch {$int_sta wl band a}
        } else {
            catch {$int_sta wl band b}
        }
        catch {$int_sta wl up}
        catch {$int_sta wl mpc 0}
        if {$is_ap} {
            # AP setup
            UTF::set_ap_nvram $int_sta wl0_radio=1 wl1_radio=1
            UTF::Test::APChanspec $int_sta $::int_chan
        } else {
            # STA setup
            $int_sta wl radio on
            $int_sta wl chanspec $::int_chan 
        }
        $int_sta wl chanspec ;# query the chanspec

        # Turn on the interference.
        if {$int_type == "tone"} {
            # Play a 4 MHz tone. DOESNT WORK!!
            error "setup_int_sta int_type=$int_type doesnt work!"
            # $int_sta wl out
            # $int_sta wl phy_tx_tone 4000  

        } elseif {$int_type == "pkteng"} {
            # Now start packet engine.
            # NB: pkteng does NOT work with rate AUTO
            # You MUST use a fixed rate!
            if {$rate != ""} {
                set catch_resp [catch {$int_sta wl nrate -r $rate} catch_msg]
            } else {
                set catch_resp [catch {$int_sta wl nrate -m $nrate} catch_msg]
            }
            $int_sta wl nrate ;# query the rate / nrate

            # Sometimes nrate (eg 43237sdio) doesnt work, but a_rate or bg_rate does work.
            if {$catch_resp != 0} {
                if {$band == 5 || $band == "a"} {
                   set cmd a_rate ;# A band
                } else {
                    set cmd bg_rate ;# B band
                }
                if {$rate != ""} {
                    $int_sta wl $cmd -r $rate
                } else {
                    $int_sta wl $cmd -m $nrate
                }
                $int_sta wl $cmd ;# query the rate/nrate
            }
            set dest_mac "00:aa:00:aa:00:aa"
            set frame_cnt 0 ;# 0 means continuous test
            set src_mac "00:99:00:99:00:99"
            $int_sta wl pkteng_start $dest_mac tx $pkt_gap $pkt_size $frame_cnt $src_mac
        } else {
            error "setup_int_sta int_type=$int_type not supported!"
        }

        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch {$int_sta deinit}
        }

        # Set the success flag
        set setup_OK yes
        return ""
    }

    # If setup failed, stop RvR tests.
    if {$setup_OK == "no"} {
         error "setup_int_sta $int_sta failed, halting tests!"
    } else {
       UTF::Message INFO $int_sta "setup_int_sta setup_OK=$setup_OK"
       return ""
    }
}

#============== proc setup_rvr_symmetry =============================
# Does setup for rvr symmetry tests.
#====================================================================
proc setup_rvr_symmetry { } {

    # Initialize globals used.
    set ::rvr_symmetry_errors ""

    # Take out the trash from previous run.
    set ::rvr_rampup_data(0) "-"
    set names [array names ::rvr_rampup_data]
    puts "setup_rvr_symmetry names=$names"
    foreach item $names {
        unset ::rvr_rampup_data($item)
    }
}

#============== proc stop_int_sta ===================================
# Stops optional interference STA 
#====================================================================
proc stop_int_sta {int_sta int_graph int_type int_quiet routerConfig direction} { 

    # Interference test is optional
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    UTF::Message INFO "" "stop_int_sta int_sta=$int_sta int_graph=$int_graph\
        int_type=$int_type int_quiet=$int_quiet routerConfig=$routerConfig\
        direction=$direction"
    if {$int_sta == ""} {
        return
    }

    # Check for unexpected interference values found
    UTF::Try "$routerConfig $direction Interference setting errors" {
        set cnt [llength $::intwl_errors]
        if {$cnt == 0} {
            return $cnt
        } else {
            error "$cnt $::intwl_errors"
        }
    }

    UTF::Try "$routerConfig $direction Stop interference STA=$int_sta" {
        set is_ap [UTF::is_ap $int_sta]
        set radio_off 0
        # Turn off the interference.
        if {$int_type == "tone"} {
            error "setup_int_sta int_type=$int_type not supported!"
            # Stop the tone
            $int_sta wl phy_tx_tone 0
            $int_sta wl in

        } elseif {$int_type == "pkteng"} {
            # Stop packet engine
            $int_sta wl pkteng_stop tx

        } else {
            error "setup_int_sta int_type=$int_type not supported!"
        }

        # Turn off the radio
        if {$is_ap} {
            UTF::set_ap_nvram $int_sta wl0_radio=0 wl1_radio=0
        } else {
            $int_sta wl radio off
        }

        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch {$int_sta deinit}
        }
        set radio_off 1
        return
    }

    # Make sure radio was turned off.
    if {$radio_off == 0} {
        UTF::Message INFO $int_sta "stop_int_sta make sure radio is off"
        if {$is_ap} {
            catch {UTF::set_ap_nvram $int_sta wl0_radio=0 wl1_radio=0}
        } else {
            catch {$int_sta wl radio off}
        }
        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch {$int_sta deinit}
        }
    }

    # Sanity check on pkteng - if we got multiple identical activity counts in a row, this
    # usually means pkteng died partway thru the test, maybe never started. In which case
    # the interference test results are probably meaningless.
    # NB: The activity is a 2 byte counter, so it wraps to 0 quite often.
    if {$int_type == "pkteng"} {
        UTF::Try "$routerConfig $direction Check pkteng activity on $int_sta" {
            UTF::Message INFO $int_sta "stop_int_sta intsta_activity=$::intsta_activity"
            set max 2 ;# allowable consecutive identical counts
            set same_val ""
            foreach pair $::intsta_activity {
                # Initialization
                set step [lindex $pair 0]
                set val [lindex $pair 1]
                set last [lindex $same_val 0]
                if {$last == ""} {
                    puts "stop_int_sta startup step=$step val=$val same_val=$same_val"
                    lappend same_val $val
                    continue
                }
    
                # Collect consecutive identical values
                if {$val == $last} {
                    # Another consecutive identical values
                    puts "stop_int_sta identical step=$step val=$val same_val=$same_val"
                    lappend same_val $val
                } else {
                    # Different value, reset list.
                    puts "stop_int_sta reset step=$step val=$val same_val=$same_val"
                    set same_val $val
                }
    
                # Have we hit the error threshold?
                set cnt [llength $same_val]
                if {$cnt > $max} {
                    error "stop_int_sta ERROR: too many pkteng consecutive identical activity values cnt=$cnt same_val=$same_val step=$step"
                }
            }
        }
    }
}

#============== proc track_ap_state =================================
# Tracks the AP state view of STA, logs state transitions.
#====================================================================
proc track_ap_state {AP StaMac step pathloss noredundant sta_reassoc\
    routerConfig direction is_oem_ap} {

    # If AP is known to be in trouble, or OEM AP return.
    set var "::${AP}_state"
    if {[set $var] != "OK" || $is_oem_ap != "0"} {
        return
    }
    # Some people really want this redundant call to preserve timing.
    set ap_name [UTF::get_name $AP]
    if {$noredundant == "0" || $sta_reassoc == "1"} {
        # Get latest AP association state info.
        set catch_resp [catch {$AP wl sta_info $StaMac} catch_msg]
        UTF::save_device_state $AP $catch_msg
        set curr_state "NULL"
        if {[regexp {state:\s*(.*)flags} $catch_msg - state]} {
            set curr_state [string trim $state]
        }
        set curr_state [string trim $curr_state]
        set curr_state [string toupper $curr_state]

    } else {
        # UTF::ap_stats leaves association state info for us.
        set temp "::${AP}_assoc"
        if {![info exists $temp]} {
            set $temp "NULL"
        }
        set curr_state [set $temp]
        set temp "::${AP}_msg"
        if {![info exists $temp]} {
            set $temp ""
        }
        set catch_msg [set $temp]
        UTF::Message INFO "$ap_name" "duplicated msg from ap_stats: $catch_msg"
    }
    UTF::Message INFO "" "track_ap_state step=$step loss=[expr $step + $pathloss]\
        ::ap_old_state=$::ap_old_state curr_state=$curr_state noredundant=$noredundant\
        sta_reassoc=$sta_reassoc"

    # Push the state change onto the main web page.
    if {0} {
    if {$curr_state != $::ap_old_state} {
        UTF::Try "$routerConfig $direction $::aux_desc AP state change: $::ap_old_state --> $curr_state" {
            UTF::Message INFO "" "track_ap_state step=$step loss=[expr $step + $pathloss]\
                ::ap_old_state=$::ap_old_state curr_state=$curr_state noredundant=$noredundant"
            UTF::Message INFO "$ap_name" "duplicated msg: $catch_msg"
            return
        }
    }
    }
    set ::ap_old_state $curr_state
    return
}

#============== proc warmup_test ===================================
# Run iperf for 60 secs to stabilize rate.
#====================================================================
proc warmup_test {LAN STA direction window va warmup} {

    # If requested, run iperf for 60 secs to stabilize rate.
    if {$warmup == 0} {
        return
    }

    # Check ::rvr_warmup for minimum thruput.
    if {[info exists ::rvr_warmup]} {
        set tput_min $::rvr_warmup
    } else {
        set tput_min 5
    }

    UTF::Try "60 sec warmup test, pass criteria: $tput_min Mb/s or more" {
        if {$direction == "Upstream"} {
            set PAIRS [list $STA $LAN]
        } else {
            set PAIRS [list $LAN $STA]
        }
        # Do test as one long burst, so we get only one number as a result.
        # We dont use controlchart here as we arent trying to control this test,
        # and we dont want failures showing up in the logs & email.
        # But we DO want to show the user that something useful happened, or if we are totally dead.
        set catch_resp [catch {UTF::Multiperf $PAIRS -w $window -N -i 60 -t 60} catch_msg]
        if {$catch_resp == 0} {
            set catch_msg [string trim $catch_msg]
            if {$catch_msg == ""} {
                set catch_msg 0
            }
            return [format "%.2f Mb/s" $catch_msg] ;# show user the single result!!!
        } else {
            error $catch_msg  ;# show user the error!!!
        }
    }

    # Check if warmup test met spec or not.
    if {$tput_min > 0} {
        if {$catch_resp != 0 || $catch_msg < $tput_min} {
            error "ERROR: warmup test did not meet pass criteria $tput_min Mb/s\
              or more. Halting tests!"
        }
    }
}

#============== Main RvR test =======================================
UTF::Test RvR1 {AP STA args} {
    UTF::Getopts {
        {allhooks              "Use all the perf_hooks, etc as is - currently the default"}
        {attngrp.arg ""        "Attenuator group to use for test"}
        {attngrp2.arg ""       "2nd attenuator group to use for test"}
        {attnlist.arg ""       "list of attenuation values"}
        {attnstart.arg 0       "does nothing!"}
        {attnstep.arg "1"      "Step value that attenuator is changed by"}
        {attnstop.arg 35       "does nothing!"}
        {branch.arg "auto"     "Branch override"}
        {chanint               "Collect chanspec info and graph as integer"}
        {chanspec.arg 36l      "AP channel"}
	{comparesta            "Run STA comparison test upon 2 STAs. Require 2 and only 2 STAs."}
	{comparestaoneloop     "Run STA comparison test upon 2 STAs in multiple loops, but only 1 loop for first STA. Require -comparesta option."}
	{compareap             "Run AP comparison test upon 2 APs. Require 2 and only 2 APs."}
	{cst                   "Run Client Scaling Test - associate all STAs to AP, but add them to traffic one at a time"}
	{cast                  "Run Client Assoc Scaling Test - associate STA and send traffic one at a time"}
	{chantest4mu           "Run a special test where all 6 conbinations out of 4 clients are tested"}
	{chantest8mu           "Run a special test where all 28 conbinations out of 8 clients are tested"}
    	{direction.arg "Up"    "Traffic Direction - Up or Down"}
        {edithooks             "Selectively edit the perf_hooks, etc for some test speedup"}
    	{email.arg ""          "Email Address"}
        {fastrampup            "Do fast rampup only, saves test time"}
        {fb0                   "Use frameburst=0, currently the default"}
        {fb1                   "Use frameburst=1 for maximum throughput"}
        {forcesniffercapture   "Always save the sniffer capture .pcap file, consumes lots of disk space"}
        {fullrange             "Test full attenuator range specified, default is to rampup after 3 steps of no beacons"}
        {fullrampup            "Do not stop the rampup test, regardless of slow rejoin issues"}
        {history.arg 30        "History size for control charts"}
        {iperfnobeacons        "Run iperf tests even if STA has no beacons"}
        {intattn.arg ""        "secondary attn_grp & attn_val for interference, eg: G3 7"}
        {intchan.arg "44l"     "channel setting for interference source"}
        {intgap.arg "50"       "pkteng interference time between frames, in usec"}
        {intgraph              "Monitor / create interference data graphs even if interference test not active"}
        {intnrate.arg "7"      "MCS rate to test pkteng interference with"}
        {intquiet              "Suppress interference STA error messages, which can flood the error report."}
        {intrate.arg ""        "Legacy rate test pkteng interference with, if specified, rate will override intnrate"}
        {intsize.arg "1400"    "pkteng interference frame size, in bytes"}
        {intsta.arg ""         "STA to be used as the interference source, this is not the DUT STA"}
        {inttype.arg "pkteng"  "pkteng can be used to generate interference, tone not supported"}
        {intwl.arg "0"         "For interference tests, AP/STA wl interference setting to use"}
        {keepgoing             "No time limit for test, keep going no matter what"}
        {max.arg 1700          "Expected maximum througput, -1 means no checks done"}
        {min.arg 0             "Expected minimum througput, -1 means no checks done"}
        {mingraphs             "Produce minimum quantity of graphs"}
        {msm                   "Mixed SU-MU test"}
        {mvm                   "Mixed VHT-MU test"}
        {mhm                   "Mixed HT-MU test"}
        {mlm                   "Mixed Legacy-MU test"}
        {mat                   "Mixed antenna test, start all clients with 1 ant and turn into 2 ant one by one"}
	{musta.arg ""          "Multi user mode. It loads up to 7 additional STAs"}
	{noattnchange.arg ""   "Do not change attenuator (for fixed attenuation tests)"}
	{noattnchange2.arg ""  "Do not change attenuator on 2nd attn group (for fixed attenuation tests)"}
        {nobtreset             "Don't reset BlueTooth devices. WARNING: can lead to low WLAN thruput!"}
        {nocache               "Don't update performance cache"}
        {nographs              "Dont produce any graphs"}
        {nohistograms          "Do not produce histograms"}
        {nohooks               "Dont use any perf_hooks, etc for maximum test speedup"}
        {noinit                "Use the testbed as is, no initialization"}
        {nomalloc              "Dont check the serial console for malloc failures"}
        {nopretest             "Dont do short warmup test for each controlchart test, defaults on for udp"}
        {noredundant           "Dont execute redundant wl calls, test runs a bit faster"}
        {nosetuptestbed        "Don't run Setup Testbed hooks"}
        {nosniffer             "Do not use Sniffer"}
        {nosymmetry            "Dont run symmetry tests for rampdown / rampup tests"}
        {oemband.arg ""        "When OEM AP broadcasts on both bands, used to choose the desired band: 2.4 or 5"}
        {pathloss.arg ""       "Known testbed path loss, in db, from AP to STA when variable attenuator is set to default"}
        {perfloop.arg 1        "Total performance test iterations for iperf controlchart tests"}
        {perfsize.arg 5        "Sample size for performance tests"}
        {perftime.arg 10       "Total time duration, in seconds, for performance tests"}
        {pingmax.arg ""        "Maximum times to try ping"}
        {rampdownonly          "Dont do rampup portion of RvR tests, test time is halved"}
        {rampuponly            "Dont do rampdown portion of RvR tests, test time is halved"}
        {refreshaddralways     "Always do dhcp before each attenuator step change & iperf test"}
        {refreshaddrasneeded   "Do dhcp after reassociation for each attenuator step until dhcp succeeds once, then stop"}
        {ringfilecnt.arg ""    "Specify sniffer ring buffer file count. Null means no ring buffer."}
        {ringfilesize.arg ""   "Specify sniffer ring buffer file size in MBytes. Null means no ring buffer."}
	{rmt                   "Randomly Mixed test"}
        {security.arg "open"   "Security used for tests"}
        {sniffer.arg ""        "Sniffer object name"}
        {sniffercapture.arg "" "Start/stop commands for when to capture continuous .pcap files. To collect rampdown steps 44-54, specify: d44 d54"}
        {softap                "AP is really a STA running softap code"}
        {steplist.arg ""       "List of specific attenuator steps to test, in whatever order"}
        {steploop.arg 1        "Number of times to repeat attenuator steplist"}
        {stoponerror           "Stops test on first error, no progressive recovery done. Useful when developer want to see testrig in failed state."}
        {stopslowrampup        "Stop the rampup test if severe slow rejoin issues are detected"}
        {test.arg "0"          "Test mode for script development, experts only, values: 0 1 2"}
        {timeout.arg ""        "Overall test timeout, in minutes, default is 90 min"}
        {title.arg "RvR test"  "Report title text"}
        {titleap               "Use AP name in report & graph titles, default is STA name"}
        {trenderrors           "Show only trend errors, not 1 error per controlchart"}
        {txbf                  "Run comparison test in this pattern: AP1<->STA1, AP2<->STA2 (useful for TxBF test)"}
        {udp.arg "0"           "udp test starting value in Mb/s, 0 means off, use tcp"}
        {udpopt.arg ""         "more options for iperf for udp tests"}
        {udpofferratetest      "Run udp tests using imcremental offer rate"}
        {va.arg "Aflex"        "variable attenuator name"}
        {warmup                "Do 60 second iperf warmup tests"}
        {wet                   "Allow AP in the STA position, for WET test"}
        {window.arg 512k       "Window size for iperf tests, has major impact on throughput"}
    }

    # NB: attnstart & attnstop are not used for anything! 

    # Save start time
    set ::rvr_overall_start_sec [clock seconds]

    # Set globals for interference tests
    set ::int_desc ""
    set ::int_wl ""
    set ::int_chan ""
    set ::intNrate ""

    # ::test_mode=1 is used to turn off most of the data collection 
    # so tests run faster and you can debug the code being modified.
    # ::test_mode=2 turns off some data collection.
    set ::test_mode $(test)

    # In case of conflicting options, make nosniffer override sniffer.
    if {$(nosniffer)} {
        set (sniffer) ""
    }

    # Sanity checks
    set AP [string trim $AP]
    if {$AP == ""} {
        error "ERROR: Must specify AP"
    }

    # AP could be a STA running softap code.
    if {$(softap)} {
        # Dynamically set -ap flag so Router will be allowed to act as SoftAP.
        $AP configure -ap 1
    }
    set (softap) [UTF::is_softap $AP] ;# Is this a SoftAP?
    if {$(softap)} {
        set ap_type "SoftAP"
    } else {
        set ap_type "AP"
    }
    set ::is_oem_ap [UTF::is_oem_ap $AP] ;# Is this an OEM AP?

    # Check STA type.
    set STA [string trim $STA]
    if {$STA == ""} {
        error "ERROR: Must specify STA"
    }

    # For WET test, STA must be an AP.
    if {$(wet)} {
        if {![UTF::is_ap $STA]} {
            error "ERROR: For WET test, need an AP in STA postion, $STA is NOT an AP!"
        }
    } else {
        UTF::check_sta_type $STA $::sta_type_list
    }
    # Ensure security is specified.
    set (security) [string trim $(security)]
    if {$(security) == ""} {
        set (security) open
    }

    # Set controlchart data cache option.
    if {$(nocache)} {
        set ::UTF::ControlChart::readonly 1
    }

    # Checks on direction
    set (direction) [string tolower $(direction)]
    if {$(direction) == "up"} {
        set (direction) "Upstream"
    } elseif {$(direction) == "down"} {
        set (direction) "Downstream"
    } else {
        error "ERROR: -direction must be Up or Down"
    }

    # Checks on attnlist.
    set (attnlist) [string trim $(attnlist)]
    if {$(attnlist) == ""} {
        error "ERROR: Must specify -attnlist"
    }
    if {[llength $(attnlist)] == 1} {
        set (nosymmetry) 1
    } 

    # Checks on attnstep
    set (attnstep) [string trim $(attnstep)]
    # Comment out when adding -attnstep=0.5 support. 02/04/2014
    #if {![regexp {^\d+$} $(attnstep)] || $(attnstep) < 1} {
    #    error "ERROR:  -attnstep must be integer, 1 or more"
    #}

    # For OEM AP, we need to scan the airwaves to see what AP are
    # available and what channel is in use. Any chanspec user passed
    # to us from the command line is ignored.
    set oem_band [string tolower [string trim $(oemband)]] ;# need oem_band defined no matter what!
    if {$::is_oem_ap == 1} {
        # Check desired oem band. Some OEM AP broadcast on both bands simultaneously.
        # So we need to be able to specify the preferred band.
        if {$oem_band == "a"} {
            set oem_band "5"
        }
        if {$oem_band == "b"} {
            set oem_band "2.4"
        }
        if {$oem_band != "2.4" && $oem_band != "5" && $oem_band != ""} {
            UTF::Message WARN "" "Invalid oem_band=$oem_band, should be 2.4 or 5, set to null."
            set oem_band ""
        }

        # Get SSID that OEM AP is expected to be broadcasting.
        set oem_ssid [UTF::get_oem_ap_ssid $AP]

        # Get chanspec of OEM AP on preferred oem_band.
        set resp [UTF::find_oem_ap_chanspec $oem_ssid $oem_band $STA]
        set (chanspec) [lindex $resp 0]
        set oem_ssid [lrange $resp 1 end] ;# may have multiple tokens
        puts "(chanspec)=$(chanspec) oem_ssid=$oem_ssid" 
    }

    # Parse out channel, band, bw from chanspec.
    # Check for 11AC format first. Otherwise it is mistaken for BW=20MHz.
    set bw ""
    set cap ""
    if {[regexp {(\d+)(/\d+)} $(chanspec) - channel bw]} {
        # 11AC format channel spec
        # NB: Keep "/" as part of bw, so it shows up nicely on the graphs
        regsub -all {/} $bw "" cap ;# remove "/"
        if {$channel >= 36} {
            set band "5"
        } else {
            set band "2.4"
        }

    } elseif {[regexp {(\d+)([ab]?)([ul])?} $(chanspec) - channel band bw]} {
        # 11N format channel spec
        if {$band eq ""} {
            if {$channel >= 36} {
                set band "5"
            } else {
                set band "2.4"
            }
        }
        if {$bw eq "l" || $bw eq "u"} {
            set cap "40"
        } else {
            set cap "20"
        }

    } else {
        error "ERROR: Bad chanspec: $(chanspec)"
    }

    # Set band without a "."
    if {$band == "5"} {
        set noDotBand "5"
    } else {
        set noDotBand "24"
    }

    # Command line pathloss will override testrig config file values, if any.
    set (pathloss) [UTF::get_pathloss $(pathloss) $STA $band $(chanspec)]

    # Setup labels, output filename
    set routerConfig "rvr${noDotBand}G${cap}"
    set TestAPBand "${band}Ghz"
    set TestAPCapacity "${cap}Mhz"
    set TestAPChannel "Channel $channel"
    set description "$(direction) $TestAPChannel $TestAPBand $TestAPCapacity"
    set GPFFileName "RvR1$(direction)Cycle${noDotBand}G${cap}Ch${channel}"

    # rvr1.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }

    # Parse out intwl values.
    set intwlval $(intwl)
    if {$(intsta) != "" && [llength $(intwl)] > 1} {
    	# This is interference loop test because more than 1 intwl values are specified,
    	# and we are going to use a different intwl value for each loop. Note that the loop number
   	# should match with the number of intwl values.
    	set intwlval [lindex $(intwl) $::loop_counter-1] ;# because ::loop_counter is initialized to 1
	UTF::Message INFO "" "intwl=$(intwl), loop_counter=$::loop_counter, intwlval=$intwlval"
    }

    # Start web summary report page
    set TITLE $(title)
    set summaryinfo ""
    UTF::WrapSummary $UTF::SummaryDir $TITLE $summaryinfo $(email) {

        UTF::Try "$routerConfig $(direction) CH=$(chanspec) $ap_type=$AP" {
            # NB: The entire RvR test is reported under this single UTF::Try
            # entry on the web summary page!

            # Get testrig name
            UTF::setup_config_testrig

            # Add a web link to the test.log file
            UTF::Try "Link to test.log" {
                return "html: <a href=\"./test.log\">test.log</a>"
            }

            # Check start/stop steps for continuous sniffer capture.
            UTF::check_sniffer_capture_steps $(sniffer) $(sniffercapture)

            UTF::Message INFO "$::localhost" "routerConfig=$routerConfig\
                TestAPBand=$TestAPBand TestAPCapacity=$TestAPCapacity\
                TestAPChannel=$TestAPChannel description=$description\
                GPFFileName=$GPFFileName pid=[pid]"

            # For udp, load the standalone Multiperf package
            if {$(udp) > 0} {
                set ver [package require UTF::Multiperf]
                UTF::Message INFO "" "UDP loading Multiperf ver=$ver"
            }

            # Check test_mode setting.
            check_testmode $::test_mode

            # Setup testbed. Some users may turn off AP radios!!!
            if {!$(noinit) && !$(nosetuptestbed)} {
                UTF::setup_testbed
            }

            # Get other RvR parameters from user config file
            set (intsta) [string trim $(intsta)]
            get_user_parms $(timeout) $(softap) $AP $STA $(intsta) $intwlval

            # Setup for frameburst, in case of -noinit
            set ::rvr_fb 0
            if {$(fb1)} {
                set ::rvr_fb 1
            }

            # Check AP & STA drivers are responding, reload if necessary.
            # State variables will be updated.
            set start_up 1
            if {$(softap)} {
                set softap_sta $AP
            } else {
                set softap_sta ""
            }
            UTF::progressive_recovery "$AP $STA $(musta)" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band

            # Log users nvram settings.
            if {!$(softap) && !$::is_oem_ap} {
                set temp [$AP cget -nvram]
                UTF::Message INFO "" "$ap_type nvram $temp"
            }

            # Get mac addr of STA. Push error to main web page. Stop tests on error.
            set catch_resp [catch {set testStaMac [$STA macaddr]} catch_msg]
            if {$catch_resp != 0} {
                UTF::Try "Could not get mac addr for $STA" {
                    error "$catch_msg"
                }
                # Force script to halt.
                error "Halting tests!"
            }

            # If user is trying to use a channel for a band that is not
            # supported, stop the tests. First we check the STA bands.
            foreach sta "$STA $(musta)" {
		set sta_bands [$sta wl bands]
		set sta_mac   [$sta macaddr]
		UTF::Message INFO "" "sta=$sta mac=$sta_mac chanspec=$(chanspec) band=$band sta_bands=$sta_bands"
            	if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $sta_bands]) ||\
                    (($band == "b" || $band == "2.4") && ![string match -nocase *b* $sta_bands])} {
                    error "Requested chanspec $(chanspec) band $band not in sta_bands=$sta_bands"
		}
            }

            # Now we check the AP bands.
            if {$::is_oem_ap == 0} {
                set ap_bands [$AP wl bands]
                UTF::Message INFO "" "ap_bands=$ap_bands"
                if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $ap_bands]) ||\
                    (($band == "b" || $band == "2.4") && ![string match -nocase *b* $ap_bands])} {
                    error "Requested chanspec $(chanspec) band $band not in ap_bands=$ap_bands"
                }
            }

            # Choose the attenuator group to use (::rvr_attn_grp & ::rvr_attn_grp2 will be set) .
            UTF::choose_attn_grp $(va) $(attngrp) $(attngrp2) $AP $STA

            # Set Attenuator in case users testbed setup didnt.
            set user_attn_start_value [UTF::get_attn_start_value]
            set ::attn_error_cnt 0;# keep track of attenuator errors
            UTF::set_attn_grp $user_attn_start_value $::rvr_attn_grp ""
	    if {$::rvr_attn_grp2 != ""} {
            	UTF::set_attn_grp $user_attn_start_value $::rvr_attn_grp2 ""
	    }

            # AP, STA, sniffer setup. Includes turning on AP radio!!!
            # This is optimized to run only once foreach STA being tested.
            if {$(noinit) || ([info exists ::rvr_init_done] && $::rvr_init_done == 1)} {
                # While user wants no initialation done, we can get really 
                # misleading results and garbage data in the perfcache if
                # we are on the wrong channel. So we always set the AP channel.
                if {!$::is_oem_ap} {
                    UTF::Try "Set $AP CH=$(chanspec)" {
                        UTF::Test::APChanspec $AP $(chanspec)
                        if {$(wet)} {
                            UTF::Test::APChanspec $STA $(chanspec)
                        }
                    }
                }

                # Also set the interference mode for each different band.
                # [cchai, 7/30/2014] This is where interference mode gets set
                # if it is NOT the very first sub-test (e.g. second loop in looped test).
                # For the very first test, interference mode gets set in UTF::init_device{}. 
                if {$(intsta) != ""} {
                    UTF::Try "Set AP/STA interference mode" {
                        if {!$::is_oem_ap} {
                            $AP wl interference_override $intwlval
                        }
                        $STA wl interference_override $intwlval
                    }
                }

                # Make sure sniffer is on correct channel. We wont get much
                # data in the .pcap if we are on the wrong channel.
                UTF::setup_sniffer $(sniffer) $(chanspec)

            } else {
                # Do the full AP initialization once.
                # RvRNightly1.test resets flag below when tests for new AP/STA start.
                setup_ap_sniffer $AP $STA $(sniffer) $(chanspec) $(fb0) $(fb1) $(nobtreset) $(softap) $::is_oem_ap

                # Do STA setup
                foreach sta "$STA $(musta)" {
                    setup_sta $sta $(chanspec) $(fb0) $(fb1) $(wet)
		}
                set ::rvr_init_done 1
            }

            # Setup parameters for controlchart / iperf
            set iperf_sample_size [expr int($(perfsize))]
            if {$iperf_sample_size < 2 || $iperf_sample_size > 25} {
                # This is a limitation inside ControlChart.tcl
                error "ERROR: Number of samples must be from 2 to 25"
            }
            set iperf_total_sec $(perftime) ;# can be fraction of a second 
            if {$iperf_total_sec <= 0} {
                error "ERROR: perftime must be GT 0"
            }

            # Iperf will work with interval=0.5 seconds.
            # Havent had any success for less than 0.5 seconds.
            set iperf_interval_sec [expr (double($iperf_total_sec)) / $iperf_sample_size]
            if {$iperf_interval_sec < 0.1} {
                set iperf_interval_sec 0.1
            }

            # Setup zero samples for case when iperf is not run.
            set zero_samples ""
            for {set i 1} {$i <= $iperf_sample_size} {incr i} {
                lappend zero_samples 0
            }
            UTF::Message INFO "" "iperf_interval_sec=$iperf_interval_sec\
                iperf_sample_size=$iperf_sample_size zero_samples=$zero_samples"

            # Setup stream needed for control chart keys
            set stream [UTF::get_stream_name end]

            # A number of routines need to know what directory to put things in.
            set SummaryLoc [file dirname "$UTF::Logfile"]

            # Get ready to create .csv file.
            set testnum [UTF::get_testnum]
            set timestamp [clock format [clock seconds] -format {%Y_%m_%d_%H_%M}]
            set ResultsFilename "${testnum}_${STA}_${routerConfig}_cycle_$(direction)_${timestamp}.csv"

	    if {$(cst)||$(cast)||$(msm)||$(mvm)||$(mhm)||$(mlm)||$(mat)||$(chantest4mu)||$(chantest8mu)||$(udpofferratetest)} {
                set type "" ;# Don't need 'type' in these tests
            } elseif {$(pathloss) == 0} {
                set type "Relative"
            } else {
                set type "Estimated"
            }

	    # Open .csv file for write.
            set resultsfileId [open "$SummaryLoc/$ResultsFilename" a]

	    # Write header line to .csv file.
            puts $resultsfileId "$::testrig $description AP $AP STA $STA ${type}PathLoss $(pathloss)"

            # Columns are organized to avoid reparsing of results from the
            # common test procs. AP stats are created in a block. AP mcs/mpdu
            # distributions are created in a block. Same for STA.
            # NB: When you add a new title here, you need to make sure the
            # actual data is added in the correct place later on!
            set ::csv_titles "$type Path Loss, ApAssocAuthen, ApConnectTime,\
                ApIdleTime, ApMcs, ApNss, ApBw, ApRxRate, ApState, ApTxFailures,\
                ApTxPkts, ApTxRate, ApRxMcs, ApTxMcs, ApMpdu, ApRxMcsSgi, ApTxMcsSgi,\
                ApPer, ApRxVht, ApTxVht, ApRxVhtSgi, ApTxVhtSgi, ApVhtPer, ApDelay, ApCcdf,\
                StaBeaconAssoc, StaMcs, StaNss, StaBw, StaRxRate, StaState, StaTxRate,\
                StaRxMcs, StaTxMcs, StaMpdu, StaRxMcsSgi, StaTxMcsSgi, StaPer,\
                StaRxVht, StaTxVht, StaRxVhtSgi, StaTxVhtSgi, StaVhtPer, StaDelay, StaCcdf,\
                StaMallocFail, TputMean, TputMin, TputMax, LowerControlLimit,\
                UpperControlLimit, StaChanSpec, StaChanInt,\
                ApRxBadFcs, ApRxBadPlcp, ApRxCrsGlitch, ApRxdFrmUcastMbss, ApRxStrt,\
                StaRxBadFcs, StaRxBadPlcp, StaRxCrsGlitch, StaRxdFrmUcastMbss, StaRxStrt,\
		ApPktRequested, ApPktStored, ApPktDropped, ApPktRetried, ApPktRtsFailed, ApPktRetryDropped,\
		ApPktAcked, ApPktRetryRatio, ApPktRetryDropRatio, ApTxbfm, ApTxndp, ApRxsf, ApSfRatio, ApTemp,"

            # Get number of STAs.
            set nsta [llength "$STA $(musta)"]

	    for {set i 0} {$i < $nsta} {incr i} {
		append ::csv_titles " StaTemp$i,"
	    }

	    if {$(musta) != ""} {
		for {set i 0} {$i < $nsta} {incr i} {
		    append ::csv_titles " MuTputSta$i,"
		}
	    }
	    if {$(musta) != "" && $::mumode == "mu"} {
		for {set i 0} {$i < $nsta} {incr i} {
		    append ::csv_titles " ApTxAsMuSta$i,"
		}
		for {set i 0} {$i < $nsta} {incr i} {
		    append ::csv_titles " ApTxTotSta$i,"
		}
	    }

	    for {set i 0} {$i < $nsta} {incr i} {
		append ::csv_titles " ApRssi$i,"
	    }
	    for {set i 0} {$i < $nsta} {incr i} {
		append ::csv_titles " StaRssi$i,"
	    }

            puts $resultsfileId $::csv_titles
            close $resultsfileId

            # On web summary page, add hyperlink to .csv file for easy access.
            UTF::Try "CSV results file" {
                return "html: <a href=\"$ResultsFilename\">$ResultsFilename</a>"
            }
	
            # Higher level scripts need .CSV path and title info to create 
            # composite graphs of all runs.
	    if {$(intsta) != "" && [llength $(intattn)] > 2} {
		# We are doing interference loop test with different attenuations
		set val [lindex $(intattn) $::loop_counter] 
		set focus "${STA}_(int_attn_${val})"
	    } elseif {$(intsta) != "" && [llength $(intwl)] > 1} {
		# We are doing interference loop test with different modes
		set val [lindex $(intwl) $::loop_counter-1] ;# because ::loop_counter is initialized to 1 
		set focus "${STA}_(int_mode_${val})"
            } else {
		set focus "$AP=>$STA"
            }
 
	    if {$(comparesta) || $(compareap) || $(txbf)} {
            	lappend ::rvr_composite_input "$SummaryLoc/$ResultsFilename" "CH$(chanspec)_$(direction)_${focus}"
	    } else {
            	lappend ::rvr_composite_input "$SummaryLoc/$ResultsFilename" "Ch=$(chanspec)_$(direction)"
	    }

            # Halt tests if we find duplicate MAC addresses.
            # Duplicate MAC addresses really mess up WET tests, including initial connection.
            UTF::check_mac_addr "$AP $STA"

	    # Turn off MU capability on 4366/4359/4357 STA side in order to run SU tests
            if {$(musta) != ""} {
		if {$::mumode == "su"} {
		    UTF::Try "Turn off client MU" {
			# Disable TxBF/MU on STA side to run SU traffic
			foreach sta "$STA $(musta)" {
			    catch {$sta wl down}
			    catch {$sta wl txbf_bfe_cap 1}
			    catch {$sta wl up}
			    catch {UTF::Sleep 1}
			}
			return
		    }
		}
	    }

	    # Execute iovars on AP right before assoc
            if {$::apbeforeassoc != ""} {
	    	UTF::Try "Before Assoc" {
                    foreach e $::apbeforeassoc {
                    	catch {$AP $e}
                    }
		    return
                }
	    }

	    # Setup connection for all STAs, but not for CAST test.
	    if {!$(cast)} {
	    	foreach sta "$STA $(musta)" {
	    	    UTF::setup_connection $AP $sta $(chanspec) $(security) $(wet)
		}
	    }

	    # Execute iovars on AP right after assoc
            if {$::apafterassoc != ""} {
                UTF::Try "After Assoc" {
                    foreach e $::apafterassoc {
                        catch {$AP $e}
                    }
                    return
                }
            }

	    # Dump driver configuration (requested by Chunyu)
	    UTF::Try "Check driver configuration" {
		catch {$AP wl dump wlc}
		foreach sta "$STA $(musta)" {
		    catch {$sta wl dump wlc}
		}
		return
	    }

	    # WAR for fixed rate MU test
	    # (This will be executed right AFTER association and BEFORE iperf traffic)
	    if {0} {
	    	UTF::Try "Set MCS rate" {
		    if {$::loop_counter == 1} {
			# auto rate, do nothing.
		    }
		    if {$::loop_counter == 2} {
			catch {$AP wl mu_rate 0x9 0x9}
		    }
		    if {$::loop_counter == 3} {
			catch {$AP wl mu_rate 0x8 0x8}
		    }
		    if {$::loop_counter == 4} {
			catch {$AP wl mu_rate 0x7 0x7}
		    }
		    if {$::loop_counter == 5} {
			catch {$AP wl mu_rate 0x6 0x6}
		    }
		    if {$::loop_counter == 6} {
			catch {$AP wl mu_rate 0x5 0x5}
		    }
		    if {$::loop_counter == 7} {
			catch {$AP wl mu_rate 0x4 0x4}
		    }
		    if {$::loop_counter == 8} {
			catch {$AP wl mu_rate 0x3 0x3}
		    }
		    if {$::loop_counter == 9} {
			catch {$AP wl mu_rate 0x2 0x2}
		    }
		    if {$::loop_counter == 10} {
			catch {$AP wl mu_rate 0x1 0x1}
		    }
		    if {$::loop_counter == 11} {
			catch {$AP wl mu_rate 0x0 0x0}
		    }
		    return
		}
  	    }

            # Use of interference STA is optional
            setup_int_sta $(intsta) $band $(intattn) $(intchan) $(inttype) $(intrate) $(intnrate) $(intgap) $(intsize) $(intquiet)

            # Get current ssid from actual AP device, not what the config file
            # object thinks it might be. Same command works for SoftAP.
            # NB: Do this after connection has been opened, to ensure SoftAP ssid is set!
            if {$::is_oem_ap} {
                set apSsid "$oem_ssid"
            } else {
                set apSsid [$AP wl ssid]
            }
            UTF::Message INFO "" "$ap_type ssid: $apSsid"

            # Router is required to have a LAN traffic generator.
            if {$(softap)} {
                # For softap, iperf traffic generator is on the softap host PC.
                set LAN $AP
            } else {
                # For real AP & OEM AP, -lanpeer option points to traffic generator.
                set LAN [$AP lan]
                set LAN [string trim $LAN]
                if {$LAN == ""} {
                    error "Halting tests, no LAN traffic generator found!"
                }
            }

            # Edit the optional perf_hooks, etc to reduce test time.
            edit_hooks $AP $LAN $STA $(allhooks) $(edithooks) $(nohooks) 

            # Optionally run iperf for 60 secs to stabilize rate.
            warmup_test $LAN $STA $(direction) $(window) $(va) $(warmup)

            # Initialization for ******** main data collection loop ********
            if {$::test_mode == 1 || $::test_mode == 2} {
                set (attnlist) "0-1 1-0" ;# test code for shorter tests
            }
            set attn_element_cnt 0 ;# counter for main foreach loop.
            set attn_element_total [llength $(attnlist)]
            if {$(rampdownonly) || $(rampuponly) || $attn_element_total == 1} {
                set plot_graph_ctl 1 ;# do all graphs
            } else {
                set plot_graph_ctl 0 ;# start with just the rampdown graph
            }
            UTF::Message INFO "" "(attnlist)=$(attnlist)\
                attn_element_total=$attn_element_total\
                plot_graph_ctl=$plot_graph_ctl"
            set ::aux_desc ""
            set ::intsta_activity "" ;# used by monitor_interference
            set ::intwl_errors "" 
            set ::iperfRamp "" ;# needed by proc iperf_ramp
            set ::monitor_rampdown_steps "" ;# needed by proc monitor_rampup issues
            set ::monitor_rampup_good_tput_cnt 0
            set ::process_cc_results_list "" ;# used for trend error analysis
            set ::rejoin_old_state "ASSOCIATED BEACONS" ;# needed by proc rejoin
            set ::ap_old_state "AUTHENTICATED ASSOCIATED" ;# needed by proc track_ap_state
            set ::sta_scale_factor 0 ;# used to scale beacon/assoc state data
            set rampdown_attn_range "" ;# save rampdown attenuator range
            set ::refresh_addr "" ;# tracks when to do dhcp
            set ::rvr_rampdown_no_beacons_list "" ;# tracks consecutive no beacon states
            set ::rvr_rampup_no_beacons_list ""
            set ::rvr_rampdown_rates_list "" ;# tracks MCS/Legacy rates
            set ::rvr_rampup_rates_list ""
            set ::rvr_fastrampup_active 0;# indicates fastrampup in progress
            set ::rvr_fastrampup_duration 0;# duration counter for fastrampup test
            set ::rvr_malloc_fail_errors 0;# malloc fail errors
            set ::rvr_rejoin_result "" ;# attn & iperf samples for controlchart use
            set ::sniffer_capture_active "" ;# on/off sniffer state for large .pcap file
            set ::sniffer_capture_index "" ;# current index into list of sniffer commands for large .pcap file(s)
            set cc_samples "" ;# needed by choose_attn_step.
            set pretest_cnt 0 ;# keep track of controlchart warmup pretests
            set start_rampup_step ""
            set tput_mean 0 ;# needed by warmup tests.
            setup_rvr_symmetry

            # We may need the wl counter data saved.
            if {$(intsta) != "" || $(intgraph)} {
                UTF::access_counters $AP savecurrent silent
                UTF::access_counters $STA savecurrent silent
            }

            # If necessary, repeat the step pattern for a longer test.
            set (steplist) [string trim $(steplist)]
            if {$(steplist) != "" && $(steploop) > 1} {
                set (nosymmetry) 1
                set temp $(steplist)
                for {set i 2} {$i <= $(steploop)} {incr i} {
                    append (steplist) " $temp"
                }
            }

            # Step list is just an arbitrary series of steps for the attenuator.
            set ::step_total [llength $(steplist)]
            set ::step_index 0
            if {$::step_total > 0} {
                # Pretend there is only 1 element to process
                set (attnlist) [lindex $(steplist) $::step_index]

                # Do all graphs. If we do only the rampdown graph, what happens
                # is that only the first few steps get show, as the graph routine
                # stops when it sees the attenuator going back to 0, which is
                # normally the rampup data.
                set plot_graph_ctl 1 
            }

	    # For calculating mutx gain.
            set attn_loop_counter  0
            set tput_sum_mutx0 0
            set tput_sum_mutx1 0

            # Main RvR test data collection loop starts here.
            # Process each element in attnlist, eg: 0-50
            foreach attnelement $(attnlist) {
                if {[regexp {^(\d+)\-(\d+)$} $attnelement - range1 range2]} {
                    # element is of form "x-y"
                    # For x LE y, attnDirection up == rampdown test
                    if {$range1 <= $range2} {
                        set step $range1
                        set attnDirection up ;# rampdown test
                        set rampdown_attn_range "$range1 $range2"
                        set ::aux_desc "RampDown"

                    } else {
                        # attnDirection down == rampup test
                        set step $range1
                        set attnDirection down ;# rampup test
                        set ::aux_desc "RampUp"
                        # If we stopped the rampdown test due to no beacons, then
                        # we adjust the rampup test to the same starting step.
                        if {$start_rampup_step != ""} {
                            set step $start_rampup_step
                        }
                    }

                } elseif {[regexp {^\d+$} $attnelement]} {
                    # element is one integer
                    set step   $attnelement
                    set range1 $attnelement
                    set range2 $attnelement
                    set attnDirection up
                    set ::aux_desc "RampDown"

                } else {
                    error "ERROR: Invalid attnlist element: $attnelement"
                }

                # If rampdownonly option was specified, we exit after
                # processing one attn_element
                incr attn_element_cnt
                if {$attn_element_cnt > 1 && $(rampdownonly)} {
                    UTF::Try "User requested rampdownonly!" {
                        return
                    }
                    break
                }

                # If rampuponly option was specified, we skip the first
                # attn_element and move on to the second attn_element.
                if {$attn_element_cnt == 1 && $(rampuponly)} {
                    UTF::Try "User requested rampuponly!" {
                        return
                    }
                    continue
                }

		if {$(chantest4mu)} {
		    set ctcnt 0
		    set ctstalist "{[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 1]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 2]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 3]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 2]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 3]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 3]}"
		    UTF::Message INFO "" "chantest4mu: $ctstalist" 
	 	} elseif {$(chantest8mu)} {
		    set ctcnt 0
		    set ctstalist "{[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 1]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 2]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 3]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 4]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 5]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 0] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 2]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 3]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 4]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 5]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 1] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 3]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 4]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 5]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 2] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 3] [lindex "$STA $(musta)" 4]}\
				   {[lindex "$STA $(musta)" 3] [lindex "$STA $(musta)" 5]}\
				   {[lindex "$STA $(musta)" 3] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 3] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 4] [lindex "$STA $(musta)" 5]}\
				   {[lindex "$STA $(musta)" 4] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 4] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 5] [lindex "$STA $(musta)" 6]}\
				   {[lindex "$STA $(musta)" 5] [lindex "$STA $(musta)" 7]}\
				   {[lindex "$STA $(musta)" 6] [lindex "$STA $(musta)" 7]}"
		    UTF::Message INFO "" "chantest8mu: $ctstalist" 
	    	} else {
                    set nstalist "$STA $(musta)"
		}

                if {$(cst) || $(cast)} {
                    set nstalist "" 
		    set ncounter 0
		    set mcounter 0
                }
		if {$(msm) || $(mvm) || $(mhm) || $(mlm) || $(mat)} {
		    set scnt 0
		    set mcnt [expr [llength $nstalist] - 1]
		}
		if {$(udpofferratetest)} {
		    set offerrate_counter 1
		}

                # Loop to collect data for the current attnelement.
                while {($step >= $range1 && $step <= $range2) ||\
                    ($step >= $range2 && $step <= $range1) ||
                    $::step_index < $::step_total} {

		    # For collecting rssi data from callback function.
                    set ::sta_rssi ""
                    set ::ap_rssi  ""

		    if {(($(chantest4mu) && $ctcnt < 6) || ($(chantest8mu) && $ctcnt < 28)) && [expr $attn_loop_counter % 5] == 0} {
			set nstalist [lindex $ctstalist $ctcnt] 
			UTF::Try "Sending traffic to: $nstalist" {
			    incr ctcnt
			}
		    }

		    # For scaling tests, we modify STA list (nstalist) every 5 test points as follows:
		    #   - In scale up session, sta is added to nstalist one after another
		    #   - In scale down session, sta is removed (from end) from nstalist one after another
		    #
                    if {($(cst) || $(cast)) && [expr $attn_loop_counter % 5] == 0} {
			if {$ncounter < [llength "$STA $(musta)"]} {
			    # Scale up session (increasing clients) 
			    UTF::Try "Sending iperf traffic to [expr $ncounter + 1] client(s)" {
				set s [lindex "$STA $(musta)" $ncounter]
				if {$(cast)} {
				    UTF::setup_connection $AP $s $(chanspec) $(security) $(wet)
				    $AP wl assoclist
				}
                            	lappend nstalist $s
			    	incr ncounter
			    	incr mcounter
			    }
			} elseif {$mcounter >= 2} {
			    # Scale down session (decreasing clients)
			    UTF::Try "Sending iperf traffic to [expr $mcounter - 1] client(s)" {
				if {$(cast)} {
				    set s [lindex $nstalist [expr $mcounter - 1]] ;# get last client and disassoc it
				    $s wl disassoc
				    $AP wl assoclist
				}
                            	set nstalist [lreplace $nstalist end end] ;# remove last client from $nstalist
			    	set mcounter [expr $mcounter - 1]
			    }
			}
                    }

		    # For udp offer rate test, we do:
		    #   - Use fixed attenuation (0dB) with 2dB step.
		    #   - Start with 100M offer rate with an increment of 100M. 
		    #
		    if {$(udpofferratetest) && [expr $attn_loop_counter % 2] == 0} {
			set newofferrate [expr $offerrate_counter * 100]
			UTF::Try "Using udp offer rate: $newofferrate" {
			    set (udp) $newofferrate
			}
			incr offerrate_counter
		    }

		    # For mixed sweeping tests, we do:
		    #   - Initially assoc all STAs as MU client
		    #   - Then Turn MU clients into non-MU client one at a time until all cliets are non-MU
		    #
		    # To set STA into VHT/HT/Legacy mode:
		    #     VHT(su): wl txbf_bfe_cap 1;
		    #   VHT(11ac): wl txbf_bfe_cap 1; wl vht_features 3;
		    #     HT(11n): wl vht_features 0; wl vhtmode 0;
		    #      Legacy: wl vht_features 0; wl vhtmode 0; wl nmode 0; 
		    #
		    if {($(msm) || $(mvm) || $(mhm) || $(mlm) || $(mat)) && [expr $attn_loop_counter % 5] == 0} {
			if {$scnt <= [llength $nstalist]} {
			    UTF::Try "Changing configuration to ->" {
			      	# Increasing non-MU client until all clients are non-MU.
			    	set msta [expr [llength $nstalist] - $scnt] ;# number of MU sta at runtime
			    	if {$scnt > 0} { ;# skip first case so we have all MU clients
			    	    set s [lindex $nstalist [expr $scnt - 1]] ;# pick up STA from front of list
			    	    $s wl down
				    if {$(msm)} {
			    	    	$s wl txbf_bfe_cap 1 
				    } elseif {$(mvm)} {
					$s wl vht_features 3
			    	    	$s wl txbf_bfe_cap 1 
				    } elseif {$(mhm)} {
			    	    	$s wl vht_features 0 
			    	    	$s wl vhtmode 0 
				    } elseif {$(mlm)} {
					$s wl vht_features 0
					$s wl vhtmode 0
					$s wl nmode 0
				    } elseif {$(mat)} {
					$s wl rxchain 3
					$s wl txchain 3
				    }
				    UTF::setup_connection $AP $s $(chanspec) $(security) $(wet)
				}
				if {$(msm)} {
				    set msg "${scnt}su-${msta}mu"
				} elseif {$(mvm)} {
				    set msg "${scnt}vht-${msta}mu"
				} elseif {$(mhm)} {
				    set msg "${scnt}ht-${msta}mu"
				} elseif {$(mlm)} {
				    set msg "${scnt}legacy-${msta}mu"
				} elseif {$(mat)} {
				    set msg "${scnt}double-${msta}single"
				}
				$AP wl assoclist
			        incr scnt
				return $msg
			    }
			} elseif {$mcnt >= 0} {
			    UTF::Try "Changing configuration to ->" {
			    	# Decreasing non-MU client until all clients are MU
			    	set msta [expr [llength $nstalist] - $mcnt] ;# number of MU sta at runtime
                                if {$mcnt >= 0} { ;# skip last case so we have all MU clients
                                    set s [lindex $nstalist $mcnt] ;# pick up STA from end of list
                                    $s wl down
				    if {$(msm)} {
                                    	$s wl txbf_bfe_cap 2
				    } elseif {$(mvm)} {
			    	    	$s wl vht_features 7 
                                    	$s wl txbf_bfe_cap 2
				    } elseif {$(mhm)} {
			    	    	$s wl vht_features 7 
					$s wl vhtmode 1
				    } elseif {$(mlm)} {
			    	    	$s wl vht_features 7 
					$s wl vhtmode 1
					$s wl nmode 1
				    } elseif {$(mat)} {
					$s wl rxchain 1
					$s wl txchain 1
				    }
				    UTF::setup_connection $AP $s $(chanspec) $(security) $(wet)
                                }
				if {$(msm)} {
				    set msg "${mcnt}su-${msta}mu"
				} elseif {$(mvm)} {
				    set msg "${mcnt}vht-${msta}mu"
				} elseif {$(mhm)} {
				    set msg "${mcnt}ht-${msta}mu"
				} elseif {$(mlm)} {
				    set msg "${mcnt}legacy-${msta}mu"
				} elseif {$(mat)} {
				    set msg "${mcnt}double-${msta}single"
				}
				$AP wl assoclist
				set mcnt [expr $mcnt - 1]
				return $msg
			    }
			}
		    }

                    # Changing attenuation step is done at the end of the loop.
                    # If -noattnchange and/or -noattnchange2 is specified, we fix the attenuation.
                    UTF::set_attn_grp $step $::rvr_attn_grp $(noattnchange)
                    if {$::rvr_attn_grp2 != ""} {
                        UTF::set_attn_grp $step $::rvr_attn_grp2 $(noattnchange2)
		    }

                    set sta_malloc_fail [check_malloc_fail $STA $(nomalloc) $routerConfig $(direction)]
                    iperf_ramp $STA $LAN $(direction) $attnDirection $(window) $tput_mean $(warmup)

                    # Do control chart & data collection inside the same utf_try
                    # so that all related data is in the same logfile.
                    set arrow [set_arrow_label $STA $(musta) $LAN $(direction)]
                    set loss [expr $step + $(pathloss)]

		    # For all tests below, make sure we display correct attn value.
		    if {$(cst)||$(cast)||$(msm)||$(mvm)||$(mhm)||$(mlm)||$(mat)||$(chantest4mu)||$(chantest8mu)} { 
			set attnvalue $(noattnchange)
		    } else {
			set attnvalue $step
		    }

		    # Here to start each test point log 
                    #UTF::Try "$routerConfig $(direction) Attn=$step Loss=$loss $arrow $::aux_desc"
                    UTF::Try "$routerConfig $(direction) Attn=$attnvalue $arrow $::aux_desc" {

                        # NB: We separate the rampdown perfcache data from the rampup data.
                        # NB: We also separate perfcache data by chanspec.
                        set keys "$stream $AP ${routerConfig}$(direction)${step}Ch$(chanspec)Attn${attnDirection}"

                        # For rvr symmetry control charts, set key_template to find the
                        # rampdown / attenuation up data files. {step} is a placeholder.
                        # While this variable is needed only much later on, it is set here
                        # to keep it in sync with other updates done for variable keys.
                        set key_template "$stream $AP ${routerConfig}$(direction)\{step\}Ch$(chanspec)Attnup"

                        # Update keys & key_template for security, fb1, fastrampup, udp, interference & steplist
                        if {$(security) != "open"} {
                            append keys " $(security)"
                            append key_template " $(security)"
                        }
                        if {$::rvr_fb == 1} {
                            append keys " fb1"
                            append key_template " fb1"
                        }
                        if {$::rvr_fastrampup_active > 0} {
                            append keys " fr$::rvr_fastrampup_duration"
                            append key_template " fr$::rvr_fastrampup_duration"
                        }
                        if {$(udp) > 0} {
                            append keys " udp"
                            append key_template " udp"
                        }
                        if {$(intsta) != ""} {
                            # Including attn grp name & inteference setting allows tracking of
                            # history for all sorts of different tests.
                            append keys " intCh=${::int_chan} $::intNrate attn=$::rvr_attn_grp int=$intwlval"
                            append key_template " intCh=${::int_chan} $::intNrate attn=$::rvr_attn_grp int=$intwlval"
                        }

                        if {$(steplist) != ""} {
                            append keys " sl${::step_index}"
                            append key_template " sl${::step_index}"
                        }

			UTF::Message INFO "" "Starting test for current attenuation point"
                        UTF::Message INFO "" "step=$step loss=$loss\
                            keys=$keys iperf_interval_sec=$iperf_interval_sec\
                            iperf_sample_size=$iperf_sample_size"

                    	# Execute iovars on AP at each attn step
                    	if {$::apateachattn != ""} {
                            UTF::Message INFO "" "Executing iovars on AP at each attn step"
                            foreach e $::apateachattn {
                            	catch {$AP $e}
                            }
                        }

                    	# Execute iovars on STAs at each attn step
                     	# (Only options from 1st STA are honored and applied to all STAs)
                    	if {$::staateachattn != ""} {
                            UTF::Message INFO "" "Executing iovars on STAs at each attn step"
                            foreach sta $nstalist {
                            	foreach e $::staateachattn {
                                    catch {$sta $e}
                                }
                            }
                        }

                        # Make sure we dont pick up data from previous test.
                        set catch_msg_cc ""
                        set catch_resp_cc 0
                        set CC(Lx) 0
                        set CC(mmm) "0 0 0"
                        set CC(samples) ""
                        set CC(Ux) 0
                        set mmm "0 0 0"
                        set tput_mean 0
			set tput_mean_list ""

                        # Setup ylabel, units & title for this specific controlchart graph
                        set transport TCP
                        if {$(udp) > 0} {
                            set transport UDP
                        }
                        set cc_ylabel "Throughput $transport"
                        set cc_unit "Mbit/sec"
                        set temp [UTF::get_testnum] ;# need current value, not value used in csv filename
                        set cc_title "$::testrig ${temp}.log $routerConfig $(direction) Attn $step $arrow $::aux_desc"

                        # If STA has no beacons, iperf will get 0 throughput,
                        # so skip tests, unless user specified -iperfnobeacons.
                        # Get controlchart results. Use sniffer if requested.
                        UTF::start_sniffer $(sniffer) $(ringfilecnt) $(ringfilesize) $(sniffercapture) $::aux_desc $step
                        # set ::rejoin_old_state ROAMING ;# test code
                        set skipped_iperf 0 ;# another optimization
                        if {![regexp -nocase {BEACONS} $::rejoin_old_state] && $(iperfnobeacons) == 0} {
                            # Add samples of all zeros to the control chart.
			    UTF::Message WARN $::localhost "No beacons detected, skipped iperf. Last state: rejoin_old_state=$::rejoin_old_state"
                            set skipped_iperf 1
                            set catch_resp_cc [catch {UTF::update_control_chart_data $keys $zero_samples 0 CC\
				"LOW|WIDE" $STA $LAN $(direction) $iperf_sample_size $(history) $cc_title $cc_unit $cc_ylabel} catch_msg_cc]
                            append catch_msg_cc " NULL BSSID, skipped iperf" ;# so user will know
                        } else {
			    UTF::Message INFO "" "Last state: rejoin_old_state=$::rejoin_old_state"
			    # test_mde=1 means to skip the actual test for debugging purpose.
                            if {$::test_mode != 1} {
				# Assemble device list for passing to Multiperf and controlchart.
				set ::device_list {}	
				if {$(direction) == "Upstream"} {
				    foreach sta $nstalist {
					lappend ::device_list $sta $AP
				    }
				} else {
				    foreach sta $nstalist {
					lappend ::device_list $AP $sta 
				    }
				}

				# Print out AP and STA mac info.
				UTF::Message INFO "" "AP mac info:"
				UTF::Message INFO [UTF::get_name $AP] "$AP --> [$AP macaddr]"
				UTF::Message INFO "" "STA mac info:"
				foreach sta $nstalist {
				    UTF::Message INFO [UTF::get_name $sta] "$sta --> [$sta macaddr]"
				}

				# Callback function to Multiperf 
            			proc dump_callback {} {
                		    uplevel {
                    			UTF::Sleep 1
					# This is how to query rssi: "$STA wl rssi ap-macaddr", "$AP wl rssi sta-macaddr"
                                        foreach sta $nstalist {
                                            catch {$sta wl rssi [$AP macaddr]} ret
                                            lappend ::sta_rssi $ret
                                            catch {$AP wl rssi [$sta macaddr]} ret
                                            lappend ::ap_rssi $ret
                                        }

					if {$(musta) != "" && $::mumode == "mu"} {
                                            catch {$AP wl mu_group}
                                            #catch {$AP wl mu_rate}
                                            catch {$AP wl dump vasip_counters}
					}

					if {$::apdumpintraffic != ""} {
					    UTF::Message INFO "" "Executing iovars on AP during warm-up traffic"
					    foreach e $::apdumpintraffic {
					   	catch {$AP $e}
					    }
					}
                		    }
            			}

				UTF::Message INFO "" "#"
				UTF::Message INFO "" "# Warm-up test to stabilize rate and make callback calls"
				UTF::Message INFO "" "#"
				UTF::Message INFO "" "device_list=$::device_list"
				
				# Always use TCP in warm-up to avoid a slow ramp-up issue in measuring rssi (e.g. AP rssi in UDP downlink).
				if {[catch {UTF::Multiperf $::device_list -w 4m -i 0.5 -t 2 -noping -b 0 -callback dump_callback} ret]} {
				    UTF::Message WARN "" "$ret $::errorInfo"
				}

				UTF::Message INFO "" "#"
				UTF::Message INFO "" "# Calling iovars before iperf to clear counters"
				UTF::Message INFO "" "#"
				# Note:
				#   1. 'pktq_stats' and 'dump mutx' are self-clearing 
				#   2. 'dump txbf' is not self-clearing (it's cumulative). 
				#      So, delta needs to be used and it's handled in utils.tcl.
				catch {$AP wl -silent pktq_stats} ret
				catch {$AP wl amsdu_clear_counters} ret
				if {[regexp {Unsupported} $ret]} {
				    UTF::Message INFO "" "Try newer iovar:"
				    catch {$AP wl dump_clear amsdu}
				}
				catch {$AP wl ampdu_clear_dump} ret
				if {[regexp {Unsupported} $ret]} {
				    UTF::Message INFO "" "Try newer iovar:"
				    catch {$AP wl dump_clear ampdu}
				}
				catch {$AP wl reset_cnts} ret ;# to clear counters for "wl counters" iovar 

				if {$(musta) != "" && $::mumode == "mu"} {
				    catch {$AP wl -silent dump mutx}
				    foreach sta $nstalist {
					catch {$sta wl -silent dump murx}
				    }
				}		    

				foreach sta $nstalist {
				    catch {$sta wl amsdu_clear_counters} ret
				    if {[regexp {Unsupported} $ret]} {
					UTF::Message INFO "" "Try newer iovar:"
				    	catch {$sta wl dump_clear amsdu}
				    }
				}

				foreach sta $nstalist {
				    catch {$sta wl ampdu_clear_dump} ret
				    if {[regexp {Unsupported} $ret]} {
				 	UTF::Message INFO "" "Try newer iovar:"
				    	catch {$sta wl dump_clear ampdu}
				    }
				}

				# Assemble commands for passing to controlchart.
				set COMP ""
				set cc_cmd "controlchart \"$::device_list\" -nopretest -comp COMP"
                                append cc_cmd " -key \"$keys\" -i $iperf_interval_sec -s $iperf_sample_size -min $(min) -max $(max) -loop $(perfloop) -history $(history) -window $(window) -stats CC"
                                if {[regexp {^\d+$} $(pingmax)] && $(pingmax) > 0} {
                                    append cc_cmd " -pingmax \"$(pingmax)\""
                                }

                                # For UDP, specify adapted offer rate & extra options.
                                if {$(udp) > 0} {
                                    if {$(udpopt) == ""} {
                                        append cc_cmd " -iperf \"-b $(udp)M\""
                                    } else {
                                        append cc_cmd " -iperf \"-b $(udp)M $(udpopt)\""
                                    }
                                }

                                # Add ylabel & title for this specific controlchart graph
                                append cc_cmd " -ylabel \"$cc_ylabel\" -title \"$cc_title\""

				UTF::Message INFO "" "#"
				UTF::Message INFO "" "# Running iperf"
				UTF::Message INFO "" "#"

				# Execute iovars on AP before iperf.
				if {$::apbeforeiperf != ""} {
				    UTF::Message INFO "" "Executing iovars on AP before iperf"
				    foreach e $::apbeforeiperf {
					catch {$AP $e}
				    }
				}

				# Execute iovars on STAs before iperf.
				if {$::stabeforeiperf != ""} {
				    UTF::Message INFO "" "Executing iovars on STAs before iperf"
				    foreach sta $nstalist {
					foreach e $::stabeforeiperf {
					    catch {$sta $e}
					}
				    }
				}

                                # Run the control chart command.
                                if {[catch $cc_cmd catch_msg_cc]} {
				    set catch_resp_cc 1
				    UTF::Message WARN "" "$catch_msg_cc $::errorInfo"
				}
                                incr pretest_cnt

				# Calculate tput_mean for each individual STAs.
				UTF::Message INFO "" "COMP: $COMP"
                            	foreach samples $COMP {
                                    set total 0.0
                                    foreach e $samples {
                                    	set total [expr {$total + $e}]
                                    }
                                    lappend tput_mean_list [expr $total / $iperf_sample_size]
                            	}
                            	UTF::Message INFO "" "tput_mean_list: $tput_mean_list"

				# If we have more than 1 controller, we need to get tput sum for each controller. 
				# Sample data (2 STAs, 2 controllers):
				#   1x1MUsta1  [0] Results(mbps): 81.834347 61.961707 62.373227 56.304853 51.17536
				#   1x1MUsta1  [1] Results(mbps): 121.28448 77.76064 67.09728 84.807573 67.4448
				#   1x1MUsta2  [2] Results(mbps): 71.318827 99.6544 97.266987 108.464853 123.562667
				#   1x1MUsta2  [3] Results(mbps): 42.525973 71.827413 105.523627 79.72384 89.28672
				#   tput_mean_list: 62.7298988 83.6789546 100.0535468 77.7775146
				# After execution of the block below, we should have:
				#   tput_mean_list: 146.4088534 177.8310614
				#
				if {[llength $tput_mean_list] > [llength $nstalist]} {
				    set ncontroller [expr {[llength $tput_mean_list] / [llength $nstalist]}]
				    set tput_mean_list_tmp ""
				    set tmp 0
				    set i 1
				    foreach e $tput_mean_list {
					if {$i < $ncontroller} {
					    set tmp [expr {$tmp + $e}] 
					    incr i
					} elseif {$i == $ncontroller} {
					    lappend tput_mean_list_tmp [expr {$tmp + $e}] 
					    set tmp 0
					    set i 1
					}
				    }
				    set tput_mean_list $tput_mean_list_tmp
				    UTF::Message INFO "" "Modified tput_mean_list: $tput_mean_list"
				}

				# Execute iovars on AP after iperf.
                                if {$::apafteriperf != ""} {
                                    UTF::Message INFO "" "Executing iovars on AP after iperf"
                                    foreach e $::apafteriperf {
                                        catch {$AP $e}
                                    }
                                }

				# Execute iovars on STAs after iperf.
                                if {$::staafteriperf != ""} {
                                    UTF::Message INFO "" "Executing iovars on STAs after iperf"
                                    foreach sta $nstalist {
                                        foreach e $::staafteriperf {
                                            catch {$sta $e}
                                        }
                                    }
                                }
                            }
                        }

                        # controlchart.test now provide results in variables in user specified array CC.
                        set mmm $CC(mmm) ;# mean min max
                        set tput_mean [lindex $mmm 0] ;# used by several routines
                        set cc_samples $CC(samples)

			# Calculate mutx gain (based on first 5 data).
			# (mutx gain is finally calculated in RvRNightly1.test)
			if {!$(cst) && $(compareap) && $(musta) != "" && $attn_loop_counter < 5} {
			    if {$::mumode == "su"} {
			   	set tput_sum_mutx0 [format {%0.2f} [expr $tput_sum_mutx0 + $tput_mean]]
				UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_sum_mutx0=$tput_sum_mutx0"
				if {$attn_loop_counter == 4} {
				    set tput_mean_mutx0 [format {%0.2f} [expr round($tput_sum_mutx0 / 5)]]
				    UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_mean_mutx0=$tput_mean_mutx0"
				    lappend ::tput_mean_list_mutx0 "$(chanspec) $tput_mean_mutx0"
				    UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_mean_list_mutx0=$::tput_mean_list_mutx0"
				}
			    } elseif {$::mumode == "mu"} {
			    	set tput_sum_mutx1 [format {%0.2f} [expr $tput_sum_mutx1 + $tput_mean]]
				UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_sum_mutx1=$tput_sum_mutx1"
				if {$attn_loop_counter == 4} {
				    set tput_mean_mutx1 [format {%0.2f} [expr $tput_sum_mutx1 / 5]]
				    UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_mean_mutx1=$tput_mean_mutx1"
				    lappend ::tput_mean_list_mutx1 "$(chanspec) $tput_mean_mutx1"
				    UTF::Message INFO "" "mutx gain: ch=$(chanspec) attn_loop_counter=$attn_loop_counter tput_mean_list_mutx1=$::tput_mean_list_mutx1"
				}
			    }
			}
			incr attn_loop_counter

                        # Setup scale factors for beacon / assoc state data
                        UTF::setup_scale_factors $tput_mean

			# Call AP iovars to make information available for debugging (requested by Chunyu)
			catch {$AP wl assoclist}
			catch {$AP wl ratedump}
			catch {$AP wl dump amsdu}
			if {$(musta) != ""} {
			    catch {$AP wl mu_features}
			    catch {$AP wl txbf_mutimer}
			    catch {$AP wl counters}

			    # WAR for processing iovar returned messages. 
			    # (it calls 'wl counters' 3 times with post-processing)
			    if {0} {
				for {set i 0} {$i < 3} {incr i} {
                            	    catch {$AP wl counters} ret 
                            	    catch {exec /bin/echo $ret | /bin/grep rxf} msg
                            	    UTF::Message DEBUG "" "Calling 'wl counters | grep rxf' for $AP"
                            	    UTF::Message DEBUG "" "$msg"
                            	    UTF::Sleep 1
				}

				foreach sta $nstalist {
				    for {set i 0} {$i < 3} {incr i} {
				    	catch {$sta wl counters} ret
				    	catch {exec /bin/echo $ret | /bin/grep rxf} msg
				    	UTF::Message DEBUG "" "Calling 'wl counters | grep rxf' for $sta"
				    	UTF::Message DEBUG "" "$msg"
				    	UTF::Sleep 1
				    }
				}
			    }
			}

			# WAR for calling additional STA iovars
			# Call STA iovars to make information available for debugging (requested by Chunyu)
			# (Most STA iovars are called from utils.tcl, and additional ones can be called here)
			if {0} {
			    foreach sta $nstalist {
				catch {$sta wl dump murx}
			    }
			}

			# Append 0 in case callback function is not invoked when iperf is skipped.
                        if {$::sta_rssi == ""} {
                            for {set i 0} {$i < [llength $nstalist]} {incr i} {
                                lappend ::sta_rssi 0
                            }
                        }
                        if {$::ap_rssi == ""} {
                            for {set i 0} {$i < [llength $nstalist]} {incr i} {
                                lappend ::ap_rssi 0
                            }
                        }
                        UTF::Message INFO "" "attnstep=$step sta_rssi=$::sta_rssi"
                        UTF::Message INFO "" "attnstep=$step  ap_rssi=$::ap_rssi"

                        # Get stats.
                        set ap_ampdu        [UTF::ap_ampdu $AP 0 $::is_oem_ap]
                        set ap_stats        [UTF::ap_stats $AP $STA $testStaMac $::is_oem_ap]
			if {$(musta) != ""} {
			    UTF::Try "Dump more STA info" {
			 	catch {$STA wl status}
                            	set sta_ampdu [UTF::sta_ampdu $STA]
				foreach sta $(musta) {
				    catch {$sta wl status}
				    catch {$sta wl dump ampdu} ;# dump only, no graphs yet
				}
			    }
			} else {
			    set sta_ampdu [UTF::sta_ampdu $STA]
			}
                        set sta_stats       [UTF::sta_stats $STA $(musta)]
                        set sta_chaninfo    [UTF::sta_chan_info $STA $(chanint)]
                        #set ap_delay_stats  [UTF::delay_stats $AP $::is_oem_ap]
                        #set sta_delay_stats [UTF::delay_stats $STA 0]
                        set ap_pktq_stats   [UTF::ap_pktq_stats $AP 0 $::is_oem_ap]
                        set ap_txbf_stats   [UTF::ap_txbf_stats $AP $nstalist]
                        set ap_sta_temp     [UTF::get_temperature $AP $STA $(musta)]

			set tx_as_mu ""
			set tx_tot   ""
			if {$(musta) != "" && $::mumode == "mu"} {
			    set ap_mutx_stats [UTF::ap_mutx_stats $AP $nstalist]
			    set tx_as_mu [lindex $ap_mutx_stats 0]
			    set tx_tot   [lindex $ap_mutx_stats 1]

                            foreach sta $nstalist {
                                catch {$sta wl dump murx}
                            }
			}

			# WAR for calling additional iovars (after iperf and all other iovars)
			if {0} {
			    if {$(musta) != "" && $::ap_counter == 0} {
				UTF::Message DEBUG "" "calling iovar at each attn"
				catch {$AP wl muclient_pfmon 0}
			    }
			}

			# Temporarily stop calling delay_stats routine, but need to satisfy gnuplot.
			set ap_delay_stats " , ,"
			set sta_delay_stats " , ,"

			# ap_vht_len and sta_vht_len are returned back as the first elelment in the list.
			# They need to be saved first and then removed from the list. 
			set ap_vht_len  0
			set sta_vht_len 0
			set ap_vht_len [lindex $ap_ampdu 0]   	;# get first element
			set ap_ampdu [lrange $ap_ampdu 1 end]   ;# remove first element
			set sta_vht_len [lindex $sta_ampdu 0] 	;# get first element
			set sta_ampdu [lrange $sta_ampdu 1 end]	;# remove first element

                        # Check on interference source, if any.
                        set int_stats [monitor_interference $(intsta) $(intgraph) $(inttype) $AP $STA $step $(intquiet) $intwlval]

                        # Add data for this path loss to the .csv results file.
                        # Individual stats/ampdu strings have commas embedded.
                        # NB: The order of the data added here absolutely must
                        # match the order of the titles specified in ::csv_titles!
                        set resultsfileId [open "$SummaryLoc/$ResultsFilename" a]
                        set csv_data_list "$loss, $ap_stats\
                            $ap_ampdu $ap_delay_stats $sta_stats $sta_ampdu $sta_delay_stats $sta_malloc_fail,\
                            $tput_mean, [lindex $mmm 1], [lindex $mmm 2], $CC(Lx), $CC(Ux), $sta_chaninfo\
                            $int_stats $ap_pktq_stats $ap_txbf_stats $ap_sta_temp"

			if {$(musta) != ""} {
			    for {set i 0} {$i < [llength "$STA $(musta)"]} {incr i} {
				set t [lindex $tput_mean_list $i]
				if {$t == ""} {
				    # This is mainly for handling a special case in CST test
				    # where assoc'd STAs may not have iperf traffic (so, no tput data).
				    set t 0
				}
			    	append csv_data_list " $t,"
			    }
			}

			if {$(musta) != "" && $::mumode == "mu"} {
			    for {set i 0} {$i < [llength "$STA $(musta)"]} {incr i} {
				set t [lindex $tx_as_mu $i]
				if {$t == ""} {
				    # This is mainly for handling a special case in CST test
				    # where assoc'd STAs may not have iperf traffic (so, no tput data).
				    set t 0
				}
			    	append csv_data_list " $t,"
			    }

			    for {set i 0} {$i < [llength "$STA $(musta)"]} {incr i} {
				set t [lindex $tx_tot $i]
				if {$t == ""} {
				    # This is mainly for handling a special case in CST test
				    # where assoc'd STAs may not have iperf traffic (so, no tput data).
				    set t 0
				}
			    	append csv_data_list " $t,"
			    }
			}

			for {set i 0} {$i < [llength "$STA $(musta)"]} {incr i} {
			    set t [lindex $::ap_rssi $i]
			    if {$t == ""} {
				# This is mainly for handling a special case in CST test
				# where assoc'd STAs may not have iperf traffic (so, no tput data).
				set t 0
			    }
			    append csv_data_list " $t,"
			}

			for {set i 0} {$i < [llength "$STA $(musta)"]} {incr i} {
			    set t [lindex $::sta_rssi $i]
			    if {$t == ""} {
				# This is mainly for handling a special case in CST test
				# where assoc'd STAs may not have iperf traffic (so, no tput data).
				set t 0
			    }
			    append csv_data_list " $t,"
			}
			
			puts $resultsfileId $csv_data_list
                        close $resultsfileId

                        # Save attnDown / rampup samples for symmetry test.
                        if {$attnDirection == "down"} {
                            set ::rvr_rampup_data($step) $CC(samples)
                            UTF::Message INFO "" "CC(samples)=$CC(samples)"
                        }

                        # If we ran iperf, for 0 thruput, restart iperf to cleanup any zombie
                        # processes that may be left, or ping STAs if iperf skipped to wait for driver to re-connect.
                        # (When doing pings with Multiperf, it will quit as soon as ping is successful)
                        if {!$skipped_iperf} {
                            UTF::restart_iperf $tput_mean $LAN $STA
                        } else {
                            # iperf skipped, do pings to wait for driver to re-connect.
                            UTF::Message INFO "" "Ping STAs to check for re-connection"
			    eval set catch_resp_mp [catch {UTF::Multiperf $::device_list -t 0.5 -b 0 -pingmax 20} catch_msg_mp]
                        }

                        # Process the results of controlchart.
                        UTF::process_cc_results $catch_resp_cc $catch_msg_cc $(trenderrors) $loss
                    } ;# End UTF::Try block

                    # Rejoin as needed. Rejoin is done here so result will 
                    # appear on web page at same level as control chart results.
                    set sta_reassoc [rejoin $apSsid $STA $(musta) $step $(pathloss) $(noredundant) $(refreshaddralways) $(refreshaddrasneeded) $routerConfig $(direction) $::is_oem_ap $(chanspec)]
                    track_ap_state $AP $testStaMac $step $(pathloss) $(noredundant) $sta_reassoc $routerConfig $(direction) $::is_oem_ap

                    # Stop sniffer is done here so result will appear on web 
                    # page at same level as control chart results.
                    set capt 0
                    if {$catch_resp_cc || $(forcesniffercapture)} {
                        set capt 1
                    }
                    UTF::stop_sniffer $(sniffer) $capt $SummaryLoc $(ringfilecnt) $(sniffercapture) $::aux_desc $step

                    # Have we exceeded our allocated overall test time?
                    # On timeout, we need to gracefully exit the loop so
                    # that we will plot the graphs of the incomplete data.
                    set test_timeout [overall_timeout $(keepgoing) $routerConfig $(direction)]
                    if {$test_timeout == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Take recovery action as needed. If we exceeded our recovery
                    # maximum, we gracefully exit the loop and do graphs.
                    set start_up 0
                    set ::stop_tests [UTF::progressive_recovery "$AP $STA" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band $(stoponerror)] 
                    if {$::stop_tests == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Monitor MCS / Legacy rates.
                    monitor_rates $STA $step $attnDirection

                    # Monitor beacon activity. Stop the rampdown test after N consecutive no-beacons
                    # unless user specified the fullrange option.
                    set stop_rampdown [monitor_beacons $step $(attnstep) $attnDirection $(fullrange)]
                    if {$stop_rampdown == "yes"} {
                        # NB: We are just cutting the rampdown test short here.
                        # Dont change plot_graph_ctl. Keep going with the main
                        # outer loop.
                        set start_rampup_step $step ;# save for rampup test
                        break
                    }

                    # Check for severe rejoin / no rampup issue
                    set stop_rampup [monitor_rampup_issues $tput_mean $step $attnDirection\
                        $(fullrampup) $(stopslowrampup)]
                    if {$stop_rampup == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Choose the next value the attenuator will use.
                    # Attenuator itself is adjusted at the top of the loop.
                    set step [choose_attn_step $step $(attnstep) $attnDirection $range2 $(fastrampup) $tput_mean $(steplist) $cc_samples]
                    if {$::rvr_fastrampup_active >= 2} {
                        break ;# stop inner while test loop
                    }

		    # WAR for calling additional iovars 
		    # (This will be executed at beginning of rampup)
		    if {0} {
		    	if {$attnDirection == "down"} {
		    	    if {$step == 58 || $step == 56 || $step == 54} {
			    	UTF::Try "Debug Settings" {
                    	    	    catch {$AP wl phyreg 0x601 0x1d49}
                    	    	    catch {$AP wl phyreg 0x801 0x1d49}
                    	    	    catch {$AP wl phyreg 0xa01 0x1d49}
                    	    	    catch {$AP wl phyreg 0xc01 0x1d49}
                    	    	    catch {UTF::Sleep 2}
                    	    	    catch {$AP wl phyreg 0x601 0xd49}
                    	    	    catch {$AP wl phyreg 0x801 0xd49}
                    	    	    catch {$AP wl phyreg 0xa01 0xd49}
                    	    	    catch {$AP wl phyreg 0xc01 0xd49}
                    	    	    catch {UTF::Sleep 2}
                    	    	    return
			    	}
			    }
			}
		    }

                } ;# End while attnelement

		if {0} { ;# comment out - not show symmetry graph
                # Run rvr symmetry control charts.
                rvr_symmetry_control_charts $attnDirection $key_template $STA $LAN\
                    $(direction) $arrow $(pathloss) "$SummaryLoc/$ResultsFilename"\
                    $rampdown_attn_range $start_rampup_step $(attnstep)\
                    $iperf_sample_size $zero_samples $(history) $(fastrampup)\
                    $routerConfig
		} ;# comment out

                # We have completed data collection for an attnelement.
                # For the first attnelement, we can now create just the rampdown
                # throughput graph, as we have the required data. For the 
                # second attnelement, we create the other graphs, but not the
                # rampdown throughput graph. Use common graph routine.
                set legend "$TestAPBand, $TestAPCapacity, ${TestAPChannel}${bw},"
                plot_graphs "$SummaryLoc/$ResultsFilename" "$GPFFileName" $legend $focus $AP $STA\
                    $routerConfig $(direction) $type $arrow $plot_graph_ctl $(nohistograms)\
                    $(rampdownonly) $sta_malloc_fail $(nomalloc) $(chanint) $(fastrampup)\
                    $(nosymmetry) $(udp) $::is_oem_ap $(nographs) $(mingraphs) $(intsta) $(intgraph) $(chanspec)\
		    $ap_vht_len $sta_vht_len $(musta) $(cst)
                incr plot_graph_ctl

                # Stop outer foreach test loop on timeout, excess recovery or
                # severe rejoin rampup issue.
                if {$test_timeout == "yes" || $::stop_tests == "yes"||\
                   $stop_rampup == "yes"} {
                     break 
                }

            } ;# End foreach element in attnlist

            # Turn off optional interference STA
            stop_int_sta $(intsta) $(intgraph) $(inttype) $(intquiet) $routerConfig $(direction)

            # Its possible the sniffer was left on due to some weird combination of
            # sniffer start/stop steps, so use the force option to ensure sniffer is off.
            set result 0
            set force 1
            UTF::stop_sniffer $(sniffer) $result $SummaryLoc $(ringfilecnt) $(sniffercapture) $::aux_desc $step $force

            # Check AP connect time for more than one drop to zero
            check_ap_connect_time "$SummaryLoc/$ResultsFilename" $ap_type $(attnstep) $routerConfig $(direction) $::is_oem_ap

            # Check for optional trend errors.
            check_trend_errors $(trenderrors) $routerConfig $(direction)

            # Did we get any malloc fail errors?
            if {$::rvr_malloc_fail_errors != "0"} {
                # Push the malloc fail total errors to the main web page.
                UTF::Try "$routerConfig $(direction) $STA malloc fail errors" {
                    error "$::rvr_malloc_fail_errors, see malloc fail graph for details"
                }           
            }

            # End of of all data collection tests. Reset attenuator to default.
            UTF::set_attn_grp $user_attn_start_value $::rvr_attn_grp ""
	    if {$::rvr_attn_grp2 != ""} {
            	UTF::set_attn_grp $user_attn_start_value $::rvr_attn_grp2 ""
	    }

            # Do control charts for beacons, MCS/Legacy rate adaptations.
            beacon_cc     $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec) $(attnstep)
            rate_adapt_cc $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec) $(attnstep) $(fastrampup)

            # Do 2 separate control charts for rejoin results. Push result to main web page
            set result [rejoin_cc $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec)]
            return $result

        } ;# End UTF::Try for complete script
    } ;# End WebSummary
} ;# End UTF::Test
