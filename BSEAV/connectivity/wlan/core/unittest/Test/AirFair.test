#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script to characterize Airtime Fairness feature
#
# Written by: Robert J. McMahon November 2012
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Streams
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::netstats
package require UTF::Test::ConfigTAF
package require UTF::Test::RangeDiscovery
package require UTF::Streamslib

UTF::Test AirFair {args} {
    UTF::Getopts {
	{ap.arg "4360ap" "AP under test"}
	{sta.arg "4360sta_AC 4360sta_11N" "STAs for test"}
	{profile.arg "45" "attenuator profile max"}
	{frameburst.arg "1" "frameburst off/on"}
	{dwell.arg "2" "dwell time per RvR step"}
	{hold.arg "15" "hold time for simultaneous streams"}
	{settle.arg "15" "hold time for single stream"}
	{protocol.arg "udp tcp" "ip protocol(s) to test"}
	{quantums.arg "4000" "airtime fairness quantums to test"}
	{udprate.arg "1G" "Per stream UDP offered rate"}
	{roamtrigger.arg "-100" "Roam trigger (default set to -100 for no roaming)"}
	{scansuppress "Do scansuppress during test run"}
	{updown "do down/up RvR ramp"}
	{branch.arg "" "Branch override"}
	{brand.arg "" "Brand override"}
	{apbrand.arg "" "Router brand override"}
	{wetbrand.arg "" "Brand override"}
 	{date.arg "" "Image date"}
	{rtrdate.arg "" "Desired Router build date, format: yyyy.mm.dd"}
	{stadate.arg "" "Desired STA build date, format: yyyy.mm.dd"}
	{tag.arg "" "Router release tag"}
	{rtrtag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{email.arg "" "Email Address"}
	{title.arg "MC80" "Title"}
	{noload "Don't load images"}
	{noapload "Don't load ap image"}
	{norestore "Don't reset to defaults"}
	{nostaload "Don't load STA image(s)"}
	{trx.arg "" "Router trx"}
	{bin.arg "" "STA image"}
	{loglevel.arg "DISPLAY" "logging level"}
	{notcptune "disable tcp tuning"}
	{chanspec.arg "36/80" "Chanspec to use"}
	{security.arg "open" "Default security"}
	{tos.arg "0x0" "ToS list to test"}
	{nophycal "" "Disable phycal watchdog"}
	{rvr "do attenuator tests"}
	{rssi.arg "45 65"}
	{window.arg "1M 512K" "TCP window size"}
	{PM.arg "0" "powersave mode"}
	{pspretend.arg "0 5"}
	{unbalanced ""}
	{burst.arg "default" "Frameburst size"}
	{rtsthresh.arg "default" "RTS threshhold"}
	{ackratio.arg "default" "Ack ratios to test"}
	{nodump ""}
	{txbf.arg "default" "txbf setting"}
	{congest ""}
	{mpdudense.arg "-1" "MPDUs per AMPDU"}
	{ATF.arg "0 1" "ATF settings"}
	{notcptrace "" }
	{ssstats ""}
	{tcpackpriority.arg "" ""}
	{latency ""}
	{iptvmode ""}
	{PR ""}
	{nopktqstats ""}
	{ebos}
	{ebos_prr_transit.arg "" "Set non default value for ebos_prr_transit"}
    }
    foreach {rx1 rx2} $(sta) { break }
    eval [concat [$rx1 cget -host] configure -name "AC"]
    eval [concat [$rx2 cget -host] configure -name "11N"]

    if {$(scansuppress)} {
	set ss 1
    } else {
	set ss 0
    }
    if {$(notcptune)} {
	set tcptune 0
    } else {
	set tcptune 1
    }
    if {$(burst) eq ""} {
	set (burst) "default"
    }
    if {$(notcptrace)} {
	set _tcptrace 0
    } else {
	set _tcptrace 1
    }
    if {$(ebos)} {
	set EBOS "0 1"
    } else {
	set EBOS -1
    }
    #
    # Figure out what's being tested by parsing the sta list
    #
    # Note: $(sta) can contain a list inside the list, i.e.
    # for multicast testing it would look like
    # {43331Lx5 {iptv_br1 iptv_br2}}
    set WETS ""
    set STAS ""
    foreach STA $(sta) {
	if {[$STA hostis Router] && [lsearch $WETS $STA] == -1} {
	    lappend WETS $STA
	} elseif {![$STA hostis Router] && [lsearch $STAS $STA] == -1} {
	    lappend STAS $STA
	}
    }
    if {![$(ap) hostis Router]} {
	lappend STAS $(ap)
    }
    if {[$(ap) hostis Router]} {
	set ROUTERS [concat $(ap) $WETS]
    } else {
	set ROUTERS $WETS
    }
    if {$(trx) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -image $(trx) -date {}
	    lappend cckey_common "${Router}=$(trx)"
	}
    } elseif {$(rtrtag) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -tag $(rtrtag) -date {}
	    lappend cckey_common "${Router}=$(rtrtag)"
	}
    } else {
	foreach Router $ROUTERS {
	    lappend cckey_common "${Router}=[$Router cget -tag]"
	}
    }
    # In the case of no STAS, use brand
    # to set both AP and bridges
    if {![llength $STAS] && $(brand) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -brand $(brand)
	}
    }
    if {$(apbrand) eq ""} {
	lappend cckey_common [$(ap) cget -brand]
    } else {
	$(ap) configure -brand $(apbrand)
	lappend cckey_common $(apbrand)
    }
    foreach wet $WETS {
	if {$(wetbrand) ne ""} {
	    $wet configure -brand $(wetbrand)
	} elseif {$(brand) ne ""} {
	    $wet configure -brand $(brand)
	}
	lappend cckey_common "${wet}=[$wet cget -brand]"
    }
    if {$(date) ne {}} {
	foreach dut [concat $(ap) $WETS $STAS] {
	    $dut configure -date $(date)
	}
    }
    if {$(rtrdate) ne {}} {
	foreach Router $ROUTERS {
	    $Router configure -date $(rtrdate)
	}
    }
    if {$(stadate) ne {}} {
	foreach STA $STAS {
	    $STA configure -date $(stadate)
	}
    }
    foreach STA $STAS {
	if {$(bin) ne ""} {
	    $STA configure -image $(bin) -date {}
	} elseif {$(statag) eq ""} {
	    lappend cckey_common "${STA}=[$STA cget -tag]"
	} else {
	    $STA configure -tag $(statag)
	    lappend cckey_common "${STA}=$(statag)"
	}
    }
    UTF::stream logginglevel $(loglevel)
    set FAILMATCH "HIGH|LOW|WIDE|ZERO"
    if {$(title) eq "" && $(sta) ne ""} {
	set sta [lindex $(sta) 0]
	if {[$sta hostis WinDHD Cygwin]} {
	    set (title) [$sta host whatami]
	} elseif {[$sta hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$sta hostis]
	}
	if {[regexp {(\d+sd)} $(ap) - c]} {
	    append (title) " with $c AP"
	}
    }
    # Compact build list for title
    # Include the WDS list, in case the AP list is empty.  Duplicates
    # will be removed automatically.
    set build [UTF::BuildTitle [concat $STAS $ROUTERS]]
    set TITLE "AirFair $(title) ($build) (ch=$(chanspec)) (tos=$(tos))"
    UTF::Message INFO "" $TITLE
    # $build is used in the title.  For private builds this will
    # indicate special images.
    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.
    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    # error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build
    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		catch {unset ::ramseyreboot}
		eval $::UTF::SetupTestBed
	    }
	}
	UTF::Streamslib::force_cleanup [concat $(ap) $(sta)]
	if {!$(noload)} {
	    if {$(noapload)} {
		set devices $WETS
	    } else {
		set devices $ROUTERS
	    }
	    foreach Router $devices {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    set date [$Router cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $Router $date unknown
		}
		UTF::Try "[$Router cget -name]: Load Image" {
		    $Router load
		}
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
		    set what [$Router whatami]
		    append what "/[$Router macaddr]"
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		}
	    }
	} elseif {!$(norestore)} {
	    foreach Router $ROUTERS {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    set date [$Router cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $Router $date unknown
		}
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
		    set what [$Router whatami]
		    append what "/[$Router macaddr]"
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		}
	    }
	}
	# Load STA image(s)
	if {!$(noload) && !$(nostaload)} {
	    foreach STA $STAS {
		if {$(branch) eq "auto"} {
		    set branch [$STA branchname]
		} else {
		    set branch $(branch)
		}
		lappend cckey_common $(branch)
		UTF::Try "[$STA cget -name]: Find STA Image" {
		    set date [$STA cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $STA $date unknown
		}
		UTF::Try "[$STA cget -name]: load" {
		    $STA load
		}
		UTF::Try "[$STA cget -name]: defaults" {
		    $STA services stop
		    catch {$STA wl msglevel +error +assoc}
		    if {![$STA cget -nomimo_bw_cap]} {
			catch {$STA wl down}
			# Enable 40 in 2.4, if available.
			# Doesn't work for LMAC since LMAC is never "down"
			$STA wl -u mimo_bw_cap 1
			$STA wl up
			UTF::Sleep 1
		    }
		    $STA wl ver
		    set what [$STA whatami]
		    append what "/[$STA macaddr]"
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		    set what
		}
	    }
	}
	# rjm fix - should use router object in some places vs sta
	UTF::Try "Test defaults" {
	    # Use SoftAP for case of STA/STA
	    if {![$(ap) hostis Router]} {
		$(ap) configure -ap 1
		$(ap) configure -ipaddr 192.168.1.60
		$(ap) configure -ssid "SoftAP"
		if {![$rx1 hostis Router]} {
		    $rx1 configure -ipaddr 192.168.1.61
		    $rx1 configure -wlinitcmds "ifconfig [$rx1 cget -device] 192.168.1.61"
		}
		if {![$rx2 hostis Router]} {
		    $rx2 configure -ipaddr 192.168.1.62
		    $rx2 configure -wlinitcmds "ifconfig [$rx2 cget -device] 192.168.1.61"
		}
		$(ap) configure -wlinitcmds "ifconfig [$(ap) cget -device] 192.168.1.60"
		set APMSG "(soft)AP"
	    } else {
		if {[$(ap) nvram get wl_mode] ne "ap"} {
		    append testnvram($(ap)) "wl_mode=ap "
		}
		if {$(ebos)} {
		    append testnvram($(ap)) "[$(ap) wlname]_taf_enable=1 "
		} else {
		    append testnvram($(ap)) "[$(ap) wlname]_taf_enable=0 "
		}
	    }
	    # Set SSID to SoftAP is using a SoftAP
	    if {![$(ap) hostis Router]} {
		foreach WET $WETS {
		    append testnvram($WET) "[$WET wlname]_ssid=SoftAP "
		}
	    }
	    # Enable either WET or ProxySTA on the bridges,
	    foreach WET $WETS {
		if {![catch {$WET wl cap} output] && \
			[regexp { psta } $output]} {
		    append testnvram($WET) "wl_mode=psta [$WET wlname]_mode=psta "
		} elseif {[$WET nvram get wl_mode] ne "wet"} {
		    append testnvram($WET) "wl_mode=wet [$WET wlname]_mode=wet "
		}
	    }
	    if {[array exists testnvram]} {
		foreach dut [array names testnvram] {
		    UTF::Try "Apply nvram: $dut" {
			eval [concat $dut restart $testnvram($dut)]
		    }
		}
	    }
	    if {[llength $WETS]} {
		foreach WET $WETS {
		    $WET rexec "brctl stp [$WET brname] 1"
		}
		if {[$(ap) hostis Router]} {
		    $(ap) rexec "brctl stp [$(ap) brname] 1"
		}
		# Give spanning tree time to converge
		UTF::Sleep 30
	    }
	    if {$(nophycal)} {
		foreach sta [concat $(ap) $WETS $STAS] {
		    catch {$sta wl phy_watchdog 0}
		}
	    }
	}
	UTF::Try "Chanspec $(chanspec)" {
	    UTF::Test::APChanspec $(ap) $(chanspec)
	    foreach WET $WETS {
		UTF::Test::APChanspec $WET $(chanspec) -loose
	    }
	}
	UTF::Try "Security: $(security)" {
	    UTF::Test::APConfigureSecurity $(ap) -security $(security)
	}
	foreach STA $(sta) {
	    if {![$STA hostis Router]} {
		UTF::Try "Connect STA $STA" {
		    UTF::Test::ConnectAPSTA $(ap) $STA
		    if {$(rtsthresh) ne "default"} {
			$STA wl down
			$STA wl rtsthresh $(rtsthresh)
			$STA wl up
		    }
		    $STA wl chanspec
		}
	    }
	}
	if {$(txbf) ne "default"} {
	    package require UTF::Test::ConfigTXBF
	    UTF::Try "TXBF=$(txbf)" {
		UTF::Test::ConfigTXBF -ap $(ap) -sta $STAS
		if {$(txbf) ne ""} {
		    $(ap) wl -u dump txbf
		    $(ap) wl -u curpower
		    $(ap) wl -u spatial_policy
		    $(ap) wl -u country
		    foreach STA $STAS {
			$STA wl -u country
		    }
		}
	    }
	}
	if {$(nophycal)} {
	    UTF::Try "Disable phycal watchdog" {
		catch {$(ap) wl phy_watchdog 0}
	    }
	}
	set rx1furthest [UTF::Test::RangeDiscovery -ap $(ap) -sta $rx1]
	if {$rx1furthest < 0} {
	    set rx1furthest 0
	}
	set rx2furthest [UTF::Test::RangeDiscovery -ap $(ap) -sta $rx2]
	if {$rx2furthest < 0} {
	    set rx2furthest 0
	}
	foreach protocol $(protocol) {
	    if {[info exists dorestart]} {
		$(ap) rc restart
		UTF::Sleep 20
	    } else {
		set dorestart 1
	    }
	    foreach ebos $EBOS {
		switch $ebos {
		    "0" {
			UTF::Test::ConfigTAF $(ap) -disable
		    }
		    "1" {
			if {$(ebos_prr_transit) ne ""} {
			    UTF::Test::ConfigTAF $(ap) -ebos_prr_transit $(ebos_prr_transit)
			} else {
			    UTF::Test::ConfigTAF $(ap)
			}
		    }
		    default {
			UTF::Message INFO $(ap) "EBOS in default state"
		    }
		}
		set protocol [string toupper $protocol]
		foreach rssi $(rssi) {
		    set a [expr {$rx1furthest - $rssi}]
		    if {$a < 0} {
			set a 0
		    }
		    catch {[$rx1 cget -attngrp] attn $a}
		    set a [expr {$rx2furthest - $rssi}]
		    if {$a < 0} {
			set a 0
		    }
		    catch {[$rx2 cget -attngrp] attn $a}
		    set RSSITXT "[$rx1 cget -name]=[lindex [[$rx1 cget -attngrp] attn?] 0]dB [$rx2 cget -name]=[lindex [[$rx2 cget -attngrp] attn?] 0]dB"
		    foreach p $(pspretend) {
			UTF::Try "Sebtup RT=$(roamtrigger) SS=$ss $RSSITXT PM=$(PM) PS=$p" {
			    set errflag 0
			    foreach STA [concat $rx1 $rx2] {
				$STA wl PM $(PM)
				$STA wl scansuppress 0
				$STA wl join [$(ap) wl ssid]
				if {[catch {$STA wl scansuppress $ss} err]} {
				    UTF::Message ERROR $STA "wl scansuppress: $err"
				    set errflag 1
				}
				if {[catch {$STA wl roam_trigger $(roamtrigger) [$STA band]} err]} {
				    UTF::Message ERROR $STA "wl roamtrigger: $err"
				    set errflag 1
				}
				$STA wl status
			    }
			    # $(ap) wl PM $(PM)
			    #			$(ap) wl ampdu_ps_retry_limit $p
			    $(ap) wl -u pspretend_retry_limit $p
			    UTF::Sleep 20.0
			    foreach STA [concat $rx1 $rx2] {
				$STA wl dump rssi
			    }
			    $(ap) wl assoclist
			    # [$(ap) cget -lanpeer] rexec iptables -F
			    set RSSITXT "${rx1}/[$rx1 wl rssi] ${rx2}/[$rx2 wl rssi]"
			    if {$errflag} {
				error "${rx1}/[$rx1 wl rssi] ${rx2}/[$rx2 wl rssi]"
			    } else {
				return "${rx1}/[$rx1 wl rssi] ${rx2}/[$rx2 wl rssi]"
			    }
			}
			set W $(window)
			if {$protocol eq "UDP" && [lindex $(window) 0] eq "-1"} {
			    set W "-1"
			}
			foreach w $W {
			    foreach ATF $(ATF) {
				if {$ATF ne "-1"} {
				    UTF::Try "ATF=$ATF MPDU=$(mpdudense)" {
					#$(ap) wlconf [$(ap) cget -device] down
					$(ap) wl down
					$(ap) wl atf $ATF
					if {$(mpdudense) ne "-1"} {
					    $(ap) wl ampdu_mpdu $(mpdudense)
					}
					$(ap) wl up
					#$(ap) wlconf [$(ap) cget -device] up
					foreach STA $STAS {
					    # $STA wl down
					    # $STA wl atf $ATF
					    # $STA wl up
					}
					set checkstas $(sta); set ix 0
					while {[llength $checkstas] && $ix < 60} {
					    UTF::Sleep 1; incr ix;
					    foreach STA $checkstas {
						if {[catch {$STA wl bssid} bssid] || $bssid ne [$(ap) macaddr]} {
						    if {![expr {$ix % 10}]} {
							UTF::Test::ConnectAPSTA $(ap) $STA
						    }
						    continue
						} else {
						    set checkstas [lsearch -all -not -inline $checkstas $STA]
						}
					    }
					}
					return [lindex [$(ap) wl ampdu_mpdu] 0]
				    }
				}
				UTF::stream allstreams destroy
				if {$protocol eq "TCP"} {
				    if {$w eq -1 && !$(notcptune)} {
					$rx1 tcptune 4M
					$rx2 tcptune 4M
					[$(ap) lan] tcptune 4M
					UTF::stream stream1 -tx $(ap) -rx $rx1 -protocol tcp -tos $(tos) -linetype 1 -txdisplay 0 -name "AC" -format a -tcptrace $_tcptrace
					UTF::stream stream2 -tx $(ap) -rx $rx2 -protocol tcp -tos $(tos) -linetype 2 -txdisplay 0 -name "11N" -format a -tcptrace $_tcptrace
					set WINTXT "W=auto"
					if {$(congest)} {
					    UTF::stream stream3 -tx $(rx2) -rx $(ap) -protocol tcp -w $w -shaperrate 5M
					}
				    } else {
					UTF::stream stream1 -tx $(ap) -rx $rx1 -protocol tcp -w $w -tcptune $tcptune -tos $(tos) -linetype 1 -txdisplay 0 -name "AC" -format a -tcptrace $_tcptrace
					UTF::stream stream2 -tx $(ap) -rx $rx2 -protocol tcp -w $w -tcptune $tcptune -tos $(tos) -linetype 2 -txdisplay 0 -name "11N" -format a -tcptrace $_tcptrace
					set WINTXT "W=$w"
					if {$(congest)} {
					    UTF::stream stream3 -tx $(rx2) -rx $(ap) -protocol tcp -w $w -shaperrate 5M
					}
				    }
				} else {
				    if {$(latency)} {
					set lat 1
				    } else {
					set lat 0
				    }
				    UTF::stream stream1 -tx $(ap) -rx $rx1 -protocol udp -pktsize 1460 -rate $(udprate) -tos $(tos) -linetype 1 -name "AC" -format a -latency $lat -clockip 10.19.87.1 -w $w
				    UTF::stream stream2 -tx $(ap) -rx $rx2 -protocol udp -pktsize 1460 -rate $(udprate) -tos $(tos) -linetype 2 -name "11N" -format a -latency $lat -clockip 10.19.87.1 -w $w
				    set WINTXT ""
				}
				foreach fb $(frameburst) {
				    switch $fb {
					"0" {
					    set stafb 0
					    set apfb 0
					}
					"1" {
					    set stafb 1
					    set apfb 1
					}
					"10" {
					    set stafb 0
					    set apfb 1
					}
					"01" {
					    set stafb 1
					    set apfb 0
					}
					default {
					    error "invalid fb $fb"
					}
				    }
				    foreach b $(burst) {
					set BTXT ""
					if {$b ne "default"} {
					    if {$fb ne "1"} {
						error "Burst size requires frameburst to be on"
						continue
					    }
					    set BTXT "B=$b"
					}
					if {$ATF > 0} {
					    set quantums $(quantums)
					} else {
					    set quantums -1
					}
					foreach quantum $quantums {
					    set FBTEXT "AP_FB=$apfb STA_FB=$stafb"
					    foreach ackratio $(ackratio) {
						set ACKTXT ""
						if {$ackratio ne "default"} {
						    set ACKTXT "ACK=$ackratio"
						}
						set RTSTXT ""
						foreach STA $(sta) {
						    append RTSTXT "[$STA wl rtsthresh] "
						}
						if {$ackratio ne "default"} {
						    foreach STA $(sta) {
							$STA wl ack_ratio $ackratio
						    }
						    $(ap) wl ack_ratio $ackratio
						}
						# $(ap) wl frameburst $apfb
						foreach STA $(sta) {
						    #  $STA wl frameburst $stafb
						}
						if {$b ne "default"} {
						    $(ap) wl shmem 0x80 $b a
						}
						#						$(ap) wlconf [$(ap) cget -device] down
						UTF::Try "ATF=$ATF EBOS=$ebos [string toupper $protocol] $WINTXT $FBTEXT RQ=$quantum us $BTXT $RTSTXT $ACKTXT" {
						    set checkstas $(sta); set ix 0
						    while {[llength $checkstas] && $ix < 60} {
							UTF::Sleep 1; incr ix;
							foreach STA $checkstas {
							    if {[catch {$STA wl bssid} bssid] || $bssid ne [$(ap) macaddr]} {
								if {![expr {$ix % 10}]} {
								    UTF::Test::ConnectAPSTA $(ap) $STA
								}
								continue
							    } else {
								set checkstas [lsearch -all -not -inline $checkstas $STA]
							    }
							}
						    }
						    if {$(tcpackpriority) ne ""} {
							$(tcpackpriority) wl -u wme_ac sta be txop 0x2f ecwmin 2 ecwmax 3 aifsn 2
							#						    $rx2 wl -u wme_ac sta be txop 0x2f ecwmin 2 ecwmax 3 aifsn 2
							#						    $rx2 wl -u wme_ac sta be txop 0 ecwmin 2 ecwmax 2
						    }
						    if {$quantum ne "-1"} {
							$(ap) wl -u ampdu_atf_us $quantum
							# RJM, flush the datapath so new quantum is in effect
							set flush [UTF::stream %AUTO% -tx $(ap) -rx [lindex $(sta) 0]]
							$flush start; $flush linkcheck -now
							$flush destroy
						    }
						    foreach STA $(sta) {
							$STA wl ampdu_clear_dump
						    }
						    if {!$(nopktqstats)} {
							$(ap) wl -u pktq_stats a:[[stream1 cget -receivesta] macaddr]
						    }
						    $(ap) wl -u ampdu_clear_dump
						    UTF::Sleep 1
						    UTF::stream allstreams stats -clear
						    # Only enable ss sampling if tcptrace isn't being used
						    if {$protocol eq "TCP" && $(ssstats)} {
							catch {N destroy}
							catch {AC destroy}
							UTF::tcpstats AC -tx $(ap) -rx $rx1 -color "Red"
							UTF::tcpstats N -tx $(ap) -rx $rx2 -color "Blue"
							AC start
							N start
						    }
						    stream1 start
						    UTF::Sleep $(settle)
						    stream1 stop
						    if {!$(nodump)} {
							foreach STA $(sta) {
							    $STA wl dump ampdu
							    $STA wl ampdu_clear_dump
							}
							$(ap) wl -u dump ampdu
							if {!$(nopktqstats)} {
							    eval [concat [$(ap) cget -host] wl -u pktq_stats]
							    $(ap) wl -u pktq_stats a:[[stream1 cget -receivesta] macaddr]
							}
							$(ap) wl -u ampdu_clear_dump
						    }
						    stream2 start
						    UTF::Sleep $(settle)
						    if {!$(nodump)} {
							UTF::stream allstreams stop
							foreach STA $(sta) {
							    $STA wl dump ampdu
							    $STA wl ampdu_clear_dump
							}
							$(ap) wl -u dump ampdu
							$(ap) wl -u ampdu_clear_dump
							UTF::stream allstreams start
						    }
						    stream1 start
						    set t0 [UTF::stream clock]
						    UTF::Sleep $(hold)
						    if {$(PR)} {
							stream2 stop
							UTF::Sleep $(hold)
							stream2 start
							UTF::Sleep $(hold)
						    }
						    catch {g destroy; lg destroy}
						    UTF::stream allstreams samplers -disable
						    set mmm1 [UTF::MeanMinMax [stream1 stats -rate -include $t0]]
						    set mmm2 [UTF::MeanMinMax [stream2 stats -rate -include $t0]]
						    set m1 "[format %0.0f [expr {[lindex $mmm1 0] / 1000000}]]M"
						    set m2 "[format %0.0f [expr {[lindex $mmm2 0] / 1000000}]]M"
						    set gtitle "ATF/EBOS=$ATF/$ebos [string toupper $protocol] $FBTEXT RQ=$quantum us $RSSITXT $BTXT $ACKTXT\\n$WINTXT stream1 avg=$m1 stream2 avg=$m2"
						    set ymax1 [lindex [stream1 stats -rate -meanminmax] end]
						    set ymax2 [lindex [stream2 stats -rate -meanminmax] end]
						    if {$ymax2 > $ymax1} {
							set ymax $ymax2
						    } else {
							set ymax $ymax1
						    }
						    set ym 700000000
						    if {$ymax < 500000000} {
							set ym 500000000
						    }
						    UTF::streamgraph g -stat rate -yticsynch 1 -title $gtitle -details 1 -graphsize "640,480" -outputtype "canvas"
						    if {$protocol eq "UDP" && $(latency)} {
							UTF::streamgraph lg -stat latency -yticsynch 1 -title $gtitle -details 1 -graphsize "640,480" -outputtype "canvas"
						    }
						    # UTF::Debug
						    UTF::stream allstreams stop
						    if {!$(nodump)} {
							foreach STA $(sta) {
							    $STA wl dump ampdu
							}
							$(ap) wl -u dump ampdu
							if {$(ebos)} {
							    set output [$(ap) wl dump taf]
							    foreach line [split $output "\n"] {
								if {[regexp {please do 'dump (.+)'} $line - detail]} {
								    $(ap) wl dump $detail
								}
							    }
							}
						    }
						    set res [UTF::stream allstreams tcptrace xfer]
						    foreach link $res {
							UTF::Try "PCAP [file tail $link]" {
							    # get the file name on the filer
							    if {[info exists ::UTF::WebServer] && [regexp "http://${::UTF::WebServer}(.+)" $link - filename]} {
								set cmd "/usr/local/bin/tcptrace -lr $filename"
								catch {localhost rexec -t 30 $cmd}
								set cmd "/usr/local/bin/tcptrace -lW $filename"
								catch {localhost rexec -t 30 $cmd}
							    }
							    return "html:<a href=\"$link\">pcap</a>"
							}
						    }
						    set res "[g plot -composite ] [g plot -composite -smoothing -append]"
						    if {$protocol eq "UDP" && $(latency)} {
							set res "$res [lg plot -composite -append]"
						    }
						    return $res
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	    if {$(rvr)} {
		foreach dut [list $(ap) $rx1 $rx2] {
		    foreach protocol $(protocol) {
			catch {UTF::stream allstreams destroy}
			if {[string toupper $protocol] eq "TCP"} {
			    UTF::stream stream1 -tx $(ap) -rx $rx1 -protocol tcp -w $(window) -tcptune $tcptune -tos $(tos) -linetype 1
			    UTF::stream stream2 -tx $(ap) -rx $rx2 -protocol tcp -w $(window) -tcptune $tcptune -tos $(tos) -linetype 2
			    set ptxt "T-"
			} else {
			    UTF::stream stream1 -tx $(ap) -rx $rx1 -protocol udp -pktsize 1460 -rate $(udprate) -tos $(tos) -linetype 1
			    UTF::stream stream2 -tx $(ap) -rx $rx2 -protocol udp -pktsize 1460 -rate $(udprate) -tos $(tos) -linetype 2
			    set ptxt "U-"
			}
			foreach fb $(frameburst) {
			    foreach quantum $(quantums) {
				foreach p $(pspretend) {
				    UTF::Try "${ptxt}RVR FB=$fb (${dut}/${(profile)}) RQ=$quantum PS=$p" {
					UTF::stream allstreams stop
					::setrssi 50
					$(ap) wl frameburst $fb
					$(ap) wl ampdu_ps_retry_limit $p
					if {!$(nostafb)} {
					    foreach STA $(sta) {
						$STA wl frameburst 0
					    }
					}
					$(ap) wl -u ampdu_atf_us $quantum
					foreach STA [concat $rx1 $rx2] {
					    $STA wl scansuppress 0
					    $STA wl join [$(ap) wl ssid]
					    UTF::Sleep 30.0
					    if {[catch {$STA wl scansuppress $ss} err]} {
						UTF::Message ERROR $STA "wl scansuppress: $err"
					    }
					    $STA wl status
					}
					$(ap) wl -u assoclist
					stream1 start; stream2 start
					UTF::Sleep 30
					# stream1 linkcheck -now
					# stream2 linkcheck -now
					UTF::stream allstreams stats -clear
					UTF::Sleep 0.5
					catch {unset overlay}
					set currattn [expr {int([lindex [[$dut cget -attngrp] attn?] 0])}]
					set start [clock clicks -milliseconds]
					lappend overlay [list 0 $currattn]
					for {set ix 0} {$ix < $(profile)} {incr ix} {
					    UTF::Sleep $(dwell)
					    [$dut cget -attngrp] incr 1
					    incr currattn +1
					    set now [clock clicks -milliseconds]
					    lappend overlay [list [expr {($now - $start) / 1000.0}] $currattn]
					}
					if {$(updown)} {
					    for {set ix 0} {$ix < $(profile)} {incr ix} {
						UTF::Sleep $(dwell)
						[$dut cget -attngrp] incr -1
						incr currattn -1
						set now [clock clicks -milliseconds]
						lappend overlay [list [expr {($now - $start) / 1000.0}] $currattn]
					    }
					}
					UTF::stream allstreams samplers -disable
					UTF::stream allstreams stop
					catch {g destroy}
					set gtitle "$dut/$(profile) [string toupper $protocol] FB=$fb RQ=$quantum us Dwell=$(dwell) s PS=$p"
					set ymax1 [lindex [stream1 stats -rate -meanminmax] end]
					set ymax2 [lindex [stream2 stats -rate -meanminmax] end]
					if {$ymax2 > $ymax1} {
					    set ymax $ymax2
					} else {
					    set ymax $ymax1
					}
					set ym 700000000
					if {$ymax < 500000000} {
					    set ym 500000000
					}
					UTF::streamgraph g -stat rate -yticsynch 1 -title $gtitle -details 1 -graphsize "1024,768" -cutoff 10
					return "[g plot -composite $overlay] [string range [g plot -composite -smoothing $overlay] 5 end]"
				    }
				}
			    }
			}
		    }
		}
	    }
	    UTF::Try "Exit" {
		UTF::stream exitstreams
	    }
	}
    }
}