#!/bin/env utf
# -*-tcl-*-
#
# A script to test basic power throttle features as a quick
# smoke type test nightly.  Therefore, not comprehensive
# Script borrows heavily from tests created by Tim A., Bob M. and others.
# Input to this script provided by Manas/Sherman/Nitin/etc.
# some input items:
# 
# $Id$
#

package require UTF

package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart

package provide UTF::Test::throttle 2.0

UTF::Test throttle {AP STA args}  {

    # User can specify per device defaults in config.
    #set args [concat [$STA cget throttle] $args]

    UTF::Getopts [subst {
	{i.arg 2 "Interval"}
	{s.arg 5 "Samples"}
	{chanspec.arg "36l" "Chanspec"}
	{key.arg "" "Key"}
	{msg.arg "" "Message"}
	{perfcache.arg "" "Performance Cache"}
	{loop.arg 1 "Performance loop"}
	{history.arg 30 "Performance History"}
	{nocache "Don't update performance cache"}
	{b.arg 0 "UDP data rate.  Defaults to 0 for TCP"}
	{wait.arg 15 "sleep time between setting tempreture and testing TP"}
	{nothermalthrottle.arg "" "No Thermal Throttle Test"}
	{nopowerthrottle.arg "" "No Power Throttle Test"}
	{nocombinedthrottle.arg 1 "Thermal and Power Throttle Test"}
	{nonthrottlecompare.arg "" "run non-throttle test to compare to"}
	{frameburst.arg 0 "Use frameburst"}
	{force "Run test, even if not enabled in config file"}
	}]

	if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    if {$(msg) eq ""} {
	set (msg) $STA
    }

    # Check which end is really taking the STA role
    if {[$STA cget -apmode]} {
	set RSTA $AP
	set RAP $STA
    } else {
	set RSTA $STA
	set RAP $AP
    }

    set branch [$STA branchname]
    set key [concat $branch throttle "ch=$(chanspec)" $(key)]

    if {$(b) ne "0"} {
	set proto "UDP"
	lappend key "udp"
    } else {
	set proto "TCP"
    }
    set oldkey $key
    if {$(frameburst)} {
	lappend key "fb"
    }

	# implment foreach as a way to reduce number of lines for similar tests
    set testlist ""
	if {$(nothermalthrottle) == ""} {
		lappend testlist thermalthrottle
	}
	if {$(nopowerthrottle) == ""} {
		lappend testlist powerthrottle
	}	
	if {$(nocombinedthrottle) == ""} {
		lappend testlist combinedthrottle
	}	
	if {$(nonthrottlecompare) != ""} {
		lappend testlist nonthrottlecompare
	}
	if {$testlist == ""} {
		UTF::Message INFO $STA "No tests to run"
		return error
	} 
	
	UTF::Message INFO $STA "Testing $testlist"    
	
	
	# add msglevel thermal if its not there -1 indicates not there anything else means its there
	UTF::Try "$(msg): Turn on Msglevel" {
		# put device into thermal msglevel if not there already
		set tempmsglevel [lsearch [$STA wl phymsglevel] thermal]
		if {$tempmsglevel == -1} {
			$STA wl phymsglevel +thermal
		}
	}

	# need to make sure we aren't in PM at all
	set pmstart [$STA wl PM]
	if {$pmstart != 3} {
		$STA wl PM 3
	}
	
	# main loop
	foreach x $testlist {
	    UTF::Try "$(msg):CH=$(chanspec): $x $proto" {
	
			if {[UTF::CanonicalChanspec [$STA wl chanspec]] ne
			    [UTF::CanonicalChanspec $(chanspec)] ||
			    [catch {$STA ping $AP -c 1}]} {
			    ConnectAPSTA $AP $STA -security open -chanspec $(chanspec)
			}
			set mac [$RSTA macaddr]
		
			if {$(frameburst)} {
			    $STA wl frameburst 1
			    $AP wl frameburst 1
			} else {
			    $STA wl -u frameburst 0
			    $AP wl -u frameburst 0
			}
		
			set APIP [$AP ipaddr]
			
			# get the band for some statistics
			set band [$STA band $(chanspec)]
		
			set window [$STA tcpautowindow]
		
			# determine current number of tx chains is a bit map 7 is 3X3 5 is 2X2, etc.
			# poll what the hw can actually do vs. the sw state before tests
			set startchains [UTF::CountBitsSet [$STA wl hw_txchain]]
			UTF::Message INFO $STA "Using $startchains number of tx chains by default"
			
			# add polling of power throttle state to determine what is happening
			# based on read of the variable 32 bit (1st bit indicates power throttle on/off, 2nd bit indicate thermal throttle or no)
			# per http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/WlCommandHelp#pwrthrottle
			# So, a 3 is both thermal and power throttle, 2 is thermal power throttling, 1 is power throttling, 0 is none
			set startpwrstate [$STA wl pwrthrottle_state]

			# if returns anything other than 0, we need to get back to default state before any tests
			if {$startpwrstate != 0} {
				# make sure we aren't in thermal throttle
		    	$STA wl phy_tempsense_override 0
		    	# Next make sure we aren't in power throttle
				$STA wl pwrthrottle 0
			}
						
			# temporary work with Nitin to return what duty cycle state says
			# Per Nitin All Fs in D6 is an AC indication that thermal throttling is on
			# Per Nitin any value other than all 0s for 0xA4,0xB4 indicated duty cycle is in use
			#$STA wl shmem 0xD6 $band
			#$STA wl shmem 0xA4 $band
			#$STA wl shmem 0xB4 $band
			# during pwrthrottle wl dutycycle_pwr returns duty cycle for power throttle
			catch {$STA wl dutycycle_pwr}
			# during thermalthrottle wl dutycycle_thermal returns duty cycle for thermal throttle
			catch {$STA wl dutycycle_thermal}
			
			# determine what to change
			if {$x == "thermalthrottle"} {
				# now determine where STA should power throttle
				set tempthresh [lindex [$STA wl phy_tempthresh] 0]
			
				# set a value above by 5
				set testtemp [expr $tempthresh + 5]
			
				# need something here to make sure we got a value
				UTF::Message INFO "" "STA: $STA Tempreture Threshold is $tempthresh"
			
				# now arttificially set the tempreture above threshold and measure TP
				$STA wl phy_tempsense_override $testtemp
			
				if {[lindex [$STA wl phy_tempsense_override] 0] != $testtemp} {
					UTF::Message INFO $STA "didn't actually set the threshold temp requested per: [$STA wl phy_tempsense_ovveride]"
				return
				}
			}

			# determine what to change
			if {$x == "powerthrottle"} {
				# make sure we aren't in thermal throttle
			    $STA wl phy_tempsense_override 0
				
				# make sure that we are now in power throttle
		    	$STA wl pwrthrottle 1
			}			
			
			# determine what to change
			if {$x == "combinedthrottle"} {
				# make sure that we are now in power throttle
		    	$STA wl pwrthrottle 1
			
				# now determine where STA should power throttle
				set tempthresh [lindex [$STA wl phy_tempthresh] 0]
			
				# set a value above by 5
				set testtemp [expr $tempthresh + 5]
			
				# need something here to make sure we got a value
				UTF::Message INFO "" "STA: $STA Tempreture Threshold is $tempthresh"
			
				# now arttificially set the tempreture above threshold and measure TP
				$STA wl phy_tempsense_override $testtemp
			
				if {[lindex [$STA wl phy_tempsense_override] 0] != $testtemp} {
					UTF::Message INFO $STA "didn't actually set the threshold temp requested per: [$STA wl phy_tempsense_ovveride]"
				return
				}
			}

			# determine what to change
			if {$x == "nonthrottlecompare"} {
				# Next return number of chains back to normal and measure again
				$STA wl phy_tempsense_override 0
				
				# Next make sure we aren't in power throttle
				$STA wl pwrthrottle 0
			}				
			
			
			# by Manas, need to sleep her for about 10 to 15 seconds to ensure chains changed
			UTF::Sleep $(wait)
			
			# get current number of chanins post setting override
			set testchains [UTF::CountBitsSet [$STA wl txchain]]
			UTF::Message INFO $STA "Using $testchains number of tx chains after enabling throttle"
			
			# add polling for now of wl dutycycle to see if it can be polled and have value
			set testpwrstate [$STA wl pwrthrottle_state]
			
			# we have to ensure that the number of chains is lower than start value or quit
			#temporarily disabled as some devices don't drop chains but do duty cycle or both
			#  comment out to still measure traffic even if is didn't change
			if { $startchains == $testchains } {
				UTF::Message INFO $STA "Did not reduce number of chains for testing"
				#error "STA:$STA Did not reduce number of chains for testing"
			}
			
			# temporary work with Nitin to return what duty cycle state says
			# Per Nitin All Fs in D6 is an AC indication that thermal throttling is on
			# Per Nitin any value other than all 0s for 0xA4,0xB4 indicated duty cycle is in use
			#$STA wl shmem 0xD6 $band
			#$STA wl shmem 0xA4 $band
			#$STA wl shmem 0xB4 $band
			# during pwrthrottle wl dutycycle_pwr returns duty cycle for power throttle
			catch {$STA wl dutycycle_pwr}
			# during thermalthrottle wl dutycycle_thermal returns duty cycle for thermal throttle
			catch {$STA wl dutycycle_thermal}	
			
			controlchart [list $STA $AP] -failcriteria "ZERO" -perfcache $(perfcache) \
				-history $(history) -oldkey [concat $oldkey $x $(chanspec)] \
				-key [concat $key $x $(chanspec)] -i $(i) -s $(s) \
				-window $window -pingmax 0 -loop $(loop) -N 0 -b $(b)
			
		}
	}

	# cleanup
	UTF::Try "$(msg): Cleanup Msglevel and Throttle State" {
		# put things back where we found them hopefully
		$STA wl phy_tempsense_override 0
		$STA wl pwrthrottle -1
		if {$tempmsglevel == -1} {
			$STA wl phymsglevel -thermal
		}
	}
}
		
	