#!/bin/env utf
# -*-tcl-*-

# To get online help, type: Test/LEConnectBTdevices.test -h

# $Id: 8b74b3b4c1fdab7e78b676983d57a31cbd52caa2 $
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set LEConnectBTdevices_help "\n\nBasic usage: Test/LEConnectBTdevices.test bt_master bt_slave <options>\
    \n\nThis script connects 2 BlueTooth devices, which are assumed to be already\
    \nloaded. bt_master & bt_slave are the BT object STA names defined in your config file."

# Command line options string
set LEConnectBTdevices_getopts {
    {scan_master.arg 3  "scan type for bt_master"}
    {scan_slave.arg 3  "scan type for bt_slave"}
    {type.arg auto   "packet type for connection"}
    {sco_routing.arg "TRANSPORT" "PCM or TRANSPORT for SCO/ESCO routing"}
    {sco_input_coding.arg "Linear" "Linear, u-law, or A-law for SCO/ESCO input coding"}
    {sco_input_data_format.arg "2\\'s_complement" "1's_complement, 2's_complement, or Sign-magnitude for SCO/ESCO input data format"}
    {sco_air_coding_format.arg "CVSD" "CVSD, u-law, or A-law for SCO/ESCO air coding format"}
    {sco_sample_size.arg "16-bit" "8-bit | 16-bit (only used if INPUT_CONFIG = linear) for SCO/ESCO sample size"}
    {sco_linear_pcm_bit_pos.arg "0" "0-7 (only used if INPUT_CONFIG = Linear) for SCO/ESCO linear pcm bit pos"}
    {sco_retransmit_effort.arg "0" "0=no, 1= atleast 1 with optimized pwr, 2= atleast 1 with optimized link quality, 0xFF=dontcare for SCO/ESCO retransmit effort"}
    {sco_max_latency.arg "0xFFFF" "SCO/ESCO max latency"}
    {link_policy.arg "4" "link policy"}
    {sniff_policy.arg "2" "enable sniff mode=2"}
	{noreset		"Skip device reset. Default is to reset devices during connect."}
	}

# Setup online help info.
UTF::setup_help $LEConnectBTdevices_help $LEConnectBTdevices_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any 
# additional code in this script.

# Load packages
package require UTF
package require UTF::utils
package require UTF::WinBT

package provide UTF::Test::LEConnectBTdevices 2.0

UTF::Test LEConnectBTdevices {bt_master bt_slave args} {

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts "$::LEConnectBTdevices_getopts" "$::LEConnectBTdevices_help"

    # Check STA's exist and are correct type.
    UTF::check_sta_type $bt_master WinBT
    UTF::check_sta_type $bt_slave WinBT

    # Check STAs are different
    if {$bt_master == $bt_slave} {
       error "LEConnectBTdevices ERROR: bt_master=$bt_master MUST NOT be same as\
           bt_slave=$bt_slave!"
    }

    # Get both board addresses.
# # #     set board_addr_master [$bt_master show_board_address]
# # #     set board_addr_slave [$bt_slave show_board_address]

    if { $(type) == "BLE" || $(type) == "ble" } {
	    
	    # BLE
 	    set bt_comm_master [$bt_master cget -bt_comm]
	    set bt_comm_slave [$bt_slave cget -bt_comm]
	    
	    # # # reset devices
	    if { !$(noreset) } {
		    $bt_master run_perl_script common/Reset.pl $bt_comm_master; UTF::Sleep 3
		    $bt_slave run_perl_script common/Reset.pl $bt_comm_slave ; UTF::Sleep 3
	    }
	    
	    set board_addr_slave [$bt_slave show_board_address]
	    set board_addr_master [$bt_master show_board_address]
	    
	    set resp_adv [$bt_slave run_perl_script common/LESetAdvParams.pl $bt_comm_slave];# puts $resp_adv
	    UTF::Message BLE_DEBUG "" "Return message from LESetAdvParams: $resp_adv\n"
	    UTF::Sleep 1
	    	    
	    set resp_adv_enable [$bt_slave run_perl_script common/LESetAdvEnable.pl $bt_comm_slave];# puts $resp_adv_enable
	    UTF::Message BLE_DEBUG "" "Return message from LESetAdvEnable: $resp_adv_enable\n"
	    UTF::Sleep 1
	    	    
	    set resp_ble_conn [$bt_master run_perl_script common/LECreateConnection.pl $bt_comm_master $board_addr_slave]
# # # 	    UTF::Message BLE_DEBUG "" "Return message from LECreateConnetion: $resp_ble_conn\nEnd of resp_ble_conn\n" ;# display response stack for debug
		UTF::Sleep 2

		if { [regexp -nocase {Connection\s+Successful} $resp_ble_conn] } {
			UTF::Message BLE_DEBUG "" "BLE: Connection Successful\n"
# # # 			debug statements
# # # 			set conn_hdl [regexp -nocase {Connection_Handle*} $resp_ble_conn]
# # # 			UTF::Message BLE_DEBUG "" "BLE handle matched: $conn_hdl\n"
# # # 			end debug statements
			regexp -nocase {Master\s*handle:\s*([\d]+)} $resp_ble_conn match hdl
			UTF::Message BLE_DEBUG "" "BLE Master handle returned: $hdl\n"			
		}
		
	    return $hdl
    } else {
    
	    # non-BLE
        set board_addr_master [$bt_master show_board_address]
	    set board_addr_slave [$bt_slave show_board_address]
	    
	    # Run the InitScan.pl script on both devices.
	    set bt_comm_master [$bt_master cget -bt_comm]
	    $bt_master run_perl_script common/InitScan.pl $bt_comm_master $(scan_master)
	    UTF::Sleep 2
	    set bt_comm_slave [$bt_slave cget -bt_comm]
	    $bt_slave run_perl_script common/InitScan.pl $bt_comm_slave $(scan_slave)
	
	    # Do inquiry for each device & get RSSI. This checks if the other
	    # device can be heard on the airwaves.
	    UTF::Sleep 2
	    set resp_master [$bt_master run_perl_script common/Inquiry.pl $bt_comm_master $board_addr_slave RSSI]
	    set resp_slave [$bt_slave run_perl_script common/Inquiry.pl $bt_comm_slave $board_addr_master RSSI]
	
	    # Parse out RSSI values
	    # puts "resp_master=$resp_master resp_slave=$resp_slave"
	    if {![regexp -nocase {RSSI\s*=\s*([\-\d]+)} $resp_master - rssi_master]} {
	        set rssi_master ""
	    }
	    if {![regexp -nocase {RSSI\s*=\s*([\-\d]+)} $resp_slave - rssi_slave]} {
	        set rssi_slave ""
	    }
	    UTF::Message LOG "$::localhost" "BT_MASTER_RSSI=$rssi_master BT_SLAVE_RSSI=$rssi_slave"
	
	    # Convert packet type to list of excludes / includes to ensure BT uses only
	    # the desired packet type.
	}

# added case for A2DP BDR and EDR types
# frame definition already in WinBT.tcl 
 	if {$(type) == "BDR" || $(type) == "EDR" } {
	set packet_type [map_bt_packet_type $(type)]
	} else {
	set packet_type [map_bt_packet_type "AUTO"]
	}

# 	set packet_type [map_bt_packet_type $(type)]

	if {$(type) == "SCO" || $(type) == "ESCO"} {

		# Open Persistent Transports
		# Keeping the transports open is required for SCO, otherwise the connection breaks
		# do not do this if only doing ACL because I saw issues in the bidirectional test.
		set fd_master [$bt_master run_perl_script common/OpenTransportAndWaitForSemaphore.pl $bt_comm_master BTMasterPersistentSemaphore -rpopen]
    	UTF::Sleep 1
		set fd_slave [$bt_slave run_perl_script common/OpenTransportAndWaitForSemaphore.pl $bt_comm_slave BTSlavePersistentSemaphore -rpopen]
		# Collect data from parallel processes.
		set resp1 ""
		set resp2 ""
		UTF::collect_rpopen_data 5 "$bt_slave $fd_slave $bt_master $fd_master" resp1 "" resp2
 
    	set packet_type2 [map_bt_packet_type $(type)]
    	
    	# Write the voice settings
    	$bt_master run_perl_script common/WriteSCOPCMIntParam.pl $bt_comm_master $(sco_routing)
    	$bt_slave run_perl_script common/WriteSCOPCMIntParam.pl $bt_comm_slave $(sco_routing)

        # WriteVoiceSetting.pl port Coding DataFormat CodingFormat SampleSize LinearPCMBitPos
     	$bt_master run_perl_script common/WriteVoiceSetting.pl $bt_comm_master $(sco_input_coding) $(sco_input_data_format) $(sco_air_coding_format) $(sco_sample_size) $(sco_linear_pcm_bit_pos)
   		$bt_slave run_perl_script common/WriteVoiceSetting.pl $bt_comm_slave $(sco_input_coding) $(sco_input_data_format) $(sco_air_coding_format) $(sco_sample_size) $(sco_linear_pcm_bit_pos)
    }

    # bt_slave will be slave end of connection. Use -rpopen option so script
    # is launched as a parallel task.
    set fd_slave [$bt_slave run_perl_script common/CreateConnectionSlave.pl $bt_comm_slave $board_addr_master -rpopen]
    UTF::Sleep 1
    # bt_master will be the master end of connection. Use -rpopen option so script
    # is launched as a parallel task.
    set fd_master [$bt_master run_perl_script common/CreateConnectionMaster.pl $bt_comm_master $board_addr_slave $packet_type -rpopen]

    # Collect data from parallel processes.
    set resp1 ""
    set resp2 ""
    UTF::collect_rpopen_data 30 "$bt_slave $fd_slave $bt_master $fd_master" resp1 "" resp2

    # Extract & save the ACL connection handles.
# # #     hard code BLE handles for now 3/10/14
	if { $(type) == "BLE" || $(type) == "ble" } {
		set ble_handle_master 64
		set ble_handle_slave 64
	} else {
# 		if not BLE connection type
    set acl_handle_master [UTF::parse_rpopen_data "$resp1" "$bt_master" "handle\\s*=\\s*(\\d+)"]
    $bt_master save_acl_handles $acl_handle_master
    set acl_handle_slave [UTF::parse_rpopen_data "$resp1" "$bt_slave" "handle\\s*=\\s*(\\d+)"]
    $bt_slave save_acl_handles $acl_handle_slave
}

	# create connection with specific acl packet type is effected on master side only (tx)
	# need to issue the change_connection_packet_type command to the remote
	
# 	added cases for A2DP BDR and EDR types
	if {$(type) == "BDR" || $(type) == "EDR" } {
	$bt_slave change_bt_packet_type $acl_handle_slave $(type)
	} else {
	$bt_slave change_bt_packet_type $acl_handle_slave "AUTO"
	}

	if {$(type) == "SCO" || $(type) == "ESCO"} {
	
    	UTF::Message LOG "$::localhost" "$(type) connection"
    	
    	UTF::Sleep 1
    	
		# enable sniff mode
		$bt_master run_perl_script common/WriteLinkPolicySettings.pl $bt_comm_master $acl_handle_master $(link_policy)
    	$bt_slave run_perl_script common/WriteLinkPolicySettings.pl $bt_comm_slave $acl_handle_slave $(link_policy)
    	$bt_master run_perl_script common/SniffMode_Cell.pl $bt_comm_master $acl_handle_master $(sniff_policy)

		# bt_slave will be slave end of connection. Use -rpopen option so script
		# is launched as a parallel task.
		if {$(type) == "SCO"} {
			set fd_slave2 [$bt_slave run_perl_script common/Add$(type)\ConnectionSlave.pl $bt_comm_slave $board_addr_master -rpopen]
    		UTF::Sleep 1
			set fd_master2 [$bt_master run_perl_script common/Add$(type)\ConnectionMaster.pl $bt_comm_master $acl_handle_master $packet_type2 -rpopen]
		} else {
			# ESCO
			set fd_slave2 [$bt_slave run_perl_script common/Add$(type)\ConnectionSlave.pl $bt_comm_slave $board_addr_master $packet_type2 $(sco_retransmit_effort) $(sco_max_latency) -rpopen]
    		UTF::Sleep 1
			set fd_master2 [$bt_master run_perl_script common/Add$(type)\ConnectionMaster.pl $bt_comm_master $acl_handle_master $packet_type2 $(sco_retransmit_effort) $(sco_max_latency) -rpopen]
		}

		# Collect data from parallel processes.
		set resp3 ""
		set resp4 ""
		UTF::collect_rpopen_data 30 "$bt_slave $fd_slave2 $bt_master $fd_master2" resp3 "" resp4

		# Extract & save the connection handles.
		set handle_master2 [UTF::parse_rpopen_data "$resp3" "$bt_master" "handle\\s*=\\s*(\\d+)"]
		$bt_master save_sco_handles $handle_master2
		set handle_slave2 [UTF::parse_rpopen_data "$resp3" "$bt_slave" "handle\\s*=\\s*(\\d+)"]
		$bt_slave save_sco_handles $handle_slave2
	}

    # Wait for the connection to stabilize
    UTF::Sleep 5

    # Return RSSI info for use on summary web page.
    return "BT_MASTER_RSSI=$rssi_master BT_SLAVE_RSSI=$rssi_slave"
}

