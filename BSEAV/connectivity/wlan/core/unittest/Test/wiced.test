#!/bin/env utf
# -*-tcl-*-

#
# WICED test
#
# $Id: 05d6a69524302d0a7c37b5551506191ad370fae3 $
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::wiced_help "\n\nBasic usage: Test/wiced.test <options>\
    \n\nvalid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set ::wiced_getopts {
	{email.arg "mirabadi" "Email Address"} \
	{title.arg ""	"Title description text string for use in the reports"}
	{ap.arg "4704/4318" "AP name"}
	{trx.arg "" "Router trx"}
	{tag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{bin.arg "" "STA dongle image"}
	{sta.arg ""	"WICED DUT"}
	{date.arg "" "Image date"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{nostareload "Don't even reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{nocache "Don't update performance cache"}
	{branch.arg "auto" "Branch override"}
    {logdir.arg "" "Log directory override"}
	{nosetup "No Setup"}
	{nosetuptestbed "Don't run Setup Testbed hooks"}
	{noposttesthook "Don't run Post Test hooks"}
	{wiced_bin_location.arg "" "WICED bin file location. This is to override the default location in the config file"}
}

# Setup online help info.
UTF::setup_help $::wiced_help $::wiced_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# Load packages
package require UTF
package require UTF::utils
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::controlchart
package require UTF::MemChart
package require UTF::Test::memchart
package require UTF::Test::RebootTestbed

namespace eval WICED {}
package provide UTF::Test::WICED 2.0

proc WICED::control_chart {sample_list cc_keys cc_title cc_units cc_zero} {

	set ::WICED::cc_error_flag 0

	set sample_cnt [llength $sample_list]

	UTF::Message INFO "" "sample_cnt=$sample_cnt sample_list=$sample_list"

	# Create control chart	
	# Control chart needs more than 2 samples
	if {$sample_cnt > 2} {
    	UTF::ControlChart CC -s $sample_cnt -key $cc_keys -format "%.2f" -units $cc_units -title $cc_title -history 30 -allowzero $cc_zero
    	
		# Get the Mean, Min, Max
		set cc_mmm [UTF::MeanMinMax $sample_list]

		# Add it to control chart
		set cc_result [CC addsample $cc_mmm]
    } else {
    	UTF::MemChart CC -key $cc_keys -format "%.2f" -units $cc_units -title $cc_title -history 30 -cachemin -500 -cachemax 900
    	
		# Add it to control chart
		set cc_result [CC addsample $sample_list]
    }

	if {[regexp -nocase {(LOW|HIGH|WIDE)} $cc_result - code]} {

		if {[regexp -nocase {, range (\d+.\d+)\s*} $cc_result match range_value]} {
			UTF::Message LOG "$::localhost" "range value=$range_value"
			if {$range_value != 0} {
				UTF::Message ERROR "" "Control chart value is $code"
				set ::WICED::cc_error_flag 1
			}
		}
	}
	
    # Get the control chart graphics
    set chart [CC plotcontrolchart $cc_result]
    
	# Delete control chart	
    CC destroy

	# remove the "html:" from the beginning
    regsub -nocase {^html:} $chart "" chart

    return "$chart"
}

proc WICED::start_consolelogger {endpoint test_time} {

	set ids ""

	UTF::Message LOG "$::localhost" "start_consolelogger endpoint=$endpoint test time=$test_time"

	# Start consolelogger as background task    
	set fd [$endpoint rpopen "expect /home/user/consolelogger -p 40003 $::consolelogger_tty"]

	# let background process initialize
	UTF::Sleep .1

	fconfigure $fd -blocking 0
	fileevent $fd readable {set ::utils_reading READY}
	set ids "$endpoint $fd"

	set fd [lindex $ids end]
	set pid [pid $fd]
	UTF::Message INFO "" "WICED::start_consolelogger ids=$ids pid=$pid"  
	set catch_resp [catch "exec ps $pid" catch_msg]
	UTF::Message INFO "" "ps $pid catch_msg=$catch_msg"

	# Collect results data from parallel processes.
	set resp1 ""
	set resp2 ""
	set timeout_sec $test_time
	UTF::collect_rpopen_data $timeout_sec "$ids" resp1 "" resp2

	UTF::Message INFO "" "Check the consolelogger process"
	set catch_resp [catch "exec ps $pid" catch_msg]
	UTF::Message INFO "" "ps $pid catch_msg=$catch_msg"

	return $resp1
}

UTF::Test WICED {args} {
    global env

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts "$::wiced_getopts" "$::wiced_help"

	# test_enabled test_name test_bin_name test_result
	set test_sets [list	"$::test1_enabled"  "$::test1_name"  "$::test1_bin_name"  "$::test1_max_time"  "$::test1_delay"  "$::test1_result"  "$::test1_channel_list"   "$::test1_security_list"  \
						"$::test2_enabled"  "$::test2_name"  "$::test2_bin_name"  "$::test2_max_time"  "$::test2_delay"  "$::test2_result"  "$::test2_channel_list"   "$::test2_security_list"  \
						"$::test3_enabled"  "$::test3_name"  "$::test3_bin_name"  "$::test3_max_time"  "$::test3_delay"  "$::test3_result"  "$::test3_channel_list"   "$::test3_security_list"  \
						"$::test4_enabled"  "$::test4_name"  "$::test4_bin_name"  "$::test4_max_time"  "$::test4_delay"  "$::test4_result"  "$::test4_channel_list"   "$::test4_security_list"  \
						"$::test5_enabled"  "$::test5_name"  "$::test5_bin_name"  "$::test5_max_time"  "$::test5_delay"  "$::test5_result"  "$::test5_channel_list"   "$::test5_security_list"  \
						"$::test6_enabled"  "$::test6_name"  "$::test6_bin_name"  "$::test6_max_time"  "$::test6_delay"  "$::test6_result"  "$::test6_channel_list"   "$::test6_security_list"  \
						"$::test7_enabled"  "$::test7_name"  "$::test7_bin_name"  "$::test7_max_time"  "$::test7_delay"  "$::test7_result"  "$::test7_channel_list"   "$::test7_security_list"  \
						"$::test8_enabled"  "$::test8_name"  "$::test8_bin_name"  "$::test8_max_time"  "$::test8_delay"  "$::test8_result"  "$::test8_channel_list"   "$::test8_security_list"  \
						"$::test9_enabled"  "$::test9_name"  "$::test9_bin_name"  "$::test9_max_time"  "$::test9_delay"  "$::test9_result"  "$::test9_channel_list"   "$::test9_security_list"  \
						"$::test10_enabled" "$::test10_name" "$::test10_bin_name" "$::test10_max_time" "$::test10_delay" "$::test10_result" "$::test10_channel_list"  "$::test10_security_list" \
						"$::test11_enabled" "$::test11_name" "$::test11_bin_name" "$::test11_max_time" "$::test11_delay" "$::test11_result" "$::test11_channel_list"  "$::test11_security_list" \
						"$::test12_enabled" "$::test12_name" "$::test12_bin_name" "$::test12_max_time" "$::test12_delay" "$::test12_result" "$::test12_channel_list"  "$::test12_security_list" ]

    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
	set ::UTF::MemChart::readonly 1
    }

    set Router  $(ap)
    set STA [lindex $(sta) 0]

    # Override default tags
    if {$(trx) ne ""} {
	$Router configure -image $(trx) -date {}
    } elseif {$(tag) ne ""} {
	$Router configure -tag $(tag) -date {}
    }
    if {$(bin) ne ""} {
	foreach STA $(sta) {
	    $STA configure -image $(bin) -date {}
	}
    }
    if {$(statag) ne ""} {
	foreach STA $(sta) {
	    $STA configure -tag $(statag) -date {}
	}
    }
    if {$(date) ne ""} {
	set date $(date)
	foreach S $(sta) {
	    $S configure -date $(date)
	}
	unset S
    } else {
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	# Clean up whitespace (RH9 compat)
	regsub -all {\s+} $date {} date
    }

    # Compact build list for title
    set build [UTF::BuildTitle $(sta)]

    if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}

	if {[regexp {(\d+sd)} $Router - c]} {
	    append (title) " with $c AP"
	}
    }
    set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}

	if {!$(noapload)} {
	    UTF::Try "$Router: Find Router Image" {
		UTF::CheckImage $Router $date unknown
	    }

	    UTF::Try "$Router: Load Image" {
		if {[$Router hostis Router Vx BSDAP DSL]} {
		    if {[catch {$Router lan ifconfig [$Router lan cget -ipaddr]}]} {
			$Router lan ifconfig 192.168.1.50
		    }
		}
		set ver [$Router load]
		set what [$Router whatami]
		# Pull out chip info and replace whitespace to make it
		# easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $Router $ret
		}
		return "$what $ver"
	    }
	}
	if {!$(norestore)} {
	    UTF::Try "$Router: Restore Defaults" {
		if {[$Router hostis Router Vx BSDAP DSL]} {
		    $Router restore_defaults
		} else {
		    $Router wl radio on
		    $Router wl ap 0
		    catch {$Router wl down}
		    # Enable 40 in 2.4, if available.
		    $Router wl -u mimo_bw_cap 1
		    $Router wl up
		    $Router wl disassoc
		    $Router services stop
		    $Router wl msglevel +error +assoc
		    $Router chipname
		}
	    }
	}

	if {$(branch) eq "auto"} {
	    set branch [$STA branchname]
	} else {
	    set branch $(branch)
	}

	# Find images
	if {!$(nostaload)} {
	    UTF::Try "$STA Find STA Image" {
		UTF::CheckImage $STA $date unknown
	    }
	}
	if {!$(nosetup)} {
	    if {$(nostaload)} {
		if {!$(nostareload)} {
		    UTF::Try "$STA reload" {
			$STA reload
		    }
		}
	    } else {
		UTF::Try "$STA load" {
		    $STA load
		}
	    }
	    UTF::Try "$STA defaults" {
		$STA services stop
		catch {$STA wl msglevel +error +assoc}
		if {![$STA cget -nomimo_bw_cap]} {
		    catch {$STA wl down}
		    # Enable 40 in 2.4, if available.
		    # Doesn't work for LMAC since LMAC is never "down"
		    $STA wl -u mimo_bw_cap 1
		    $STA wl up
		    UTF::Sleep 1
		}
		$STA wl ver
		set what [$STA whatami]
		if {!$(nostaload)} {
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		}
		set what
	    }

	    if {!$(nostaload) && [set reclaim [$STA reclaim]]} {
		UTF::Try "$STA: Reclaim" {
		    # MemChart
		    memchart $reclaim -key [list $branch $STA reclaim] \
			-failonlow
		}
	    }
	}

	# all the test results will be moved to under the UTF Logfile directory
	
	set LogLoc $UTF::Logfile
	# replace the "test.log" from the end with blank
	set Index [string last "test.log" $LogLoc]
	if {$Index >= 0} {
		set LogLoc [string replace $LogLoc $Index end ""]
	}

	set STAIP [$STA cget -lan_ip]
	set TestName "WICED"
	# Set control chart keys
	set stream [UTF::get_stream_name end]
	set base_keys "$stream AP=$Router wiced.test"
	UTF::Message INFO "" "base_keys stream=$stream"  
	UTF::Message INFO "" "base_keys=$base_keys"

    if {$(wiced_bin_location) == ""} {

		# This is the default. The latest build from the server is picked up
		
		UTF::Try "WICED: Find latest build" {

			foreach filename [glob -nocomplain -directory $::build_loc "sig_*.*"] {

				if {[file isdirectory $filename]} {
					# this is a sig_ directory
					regsub "$::build_loc\/" $filename "" filename
					lappend sig_dirs_list $filename
				}
			}

			# sort the sig_ directories
			set new_sig_dirs_list [lsort -decreasing $sig_dirs_list]
			set latest_build [lindex $new_sig_dirs_list 0]

			set ::latest_build "$::build_loc\/$latest_build"

			UTF::Message INFO "debug" "latest_build=$::latest_build"

			return "$latest_build"	
		}
	} else {
	
		# This is a custom test. The bin file location is passed as parameter

		UTF::Try "WICED: Custom build" {

			set ::latest_build "$(wiced_bin_location)"

			UTF::Message INFO "debug" "latest_build=$::latest_build"

			return "$::latest_build"	
		}
	}

	# Process each test_sets paramters
	foreach {test_enabled test_name test_bin_name test_max_time test_delay test_result ap_channel_list ap_security_list} $test_sets {

		UTF::Message INFO "debug" "test_enabled=$test_enabled test_name=$test_name test_bin_name=$test_bin_name test_max_time=$test_max_time test_delay=$test_delay test_result=$test_result ap_channel_list=$ap_channel_list ap_security_list=$ap_security_list"

		if {$test_enabled == 0} {
			# do not run this test
			UTF::Message INFO "debug" "Do not run test $test_name"
			continue
		}

		set wiced_load_flag 1
		set ::WICED::cc_error_flag 0
		set html_results ""
		
		foreach ap_security $ap_security_list {

			UTF::Try "$Router: $ap_security Security" {

				$Router configure -ssid $::ap_ssid

				if {$ap_security == "aespsk2"} {
					$Router configure -wpakey $::ap_wpakey
				}

				APConfigureSecurity $Router -security $ap_security
			}

			foreach ap_channel $ap_channel_list {

				UTF::Try "$Router: Channel $ap_channel" {
					UTF::Test::APChanspec $Router $ap_channel
				}
	
				set err_str ""
				set scan_test_flag 0
				set ping_test_flag 0
				set sensor_test_flag 0
				set web_server_test_flag 0
				set throughput_test_flag 0

				if {[string match -nocase "*scan*" $test_name]} {
					set scan_test_flag 1
				} elseif {[string match -nocase "*ping*" $test_name]} {
					set ping_test_flag 1
				} elseif {[string match -nocase "*sensor*" $test_name]} {
					set sensor_test_flag 1
				} elseif {[string match -nocase "*web server*" $test_name]} {
					set web_server_test_flag 1
				} elseif {[string match -nocase "*throughput*" $test_name]} {
					set throughput_test_flag 1
				}

				if {$web_server_test_flag == 1 || $throughput_test_flag == 1} {
				
					UTF::Try "$STA: Join AP $::ap_ssid" {
						ConnectAPSTA $Router $STA -security $ap_security
					}
				} else {
					catch {$STA wl disassoc}
				}
				
				UTF::Try "CH=$ap_channel: $test_name" {

					# kill any existing consolelogger expect shell
					UTF::Message INFO "" "############# Kill any consolelogger ################"
					set catch_resp [catch {$STA rexec -t 60 -T 60 "taskkill /IM expect.exe /F"} catch_msg]

					if {$wiced_load_flag == 1} {
					
						if {$(wiced_bin_location) == ""} {

							# This is the default. The latest build from the server is picked up

							UTF::Message INFO "" "############# Copy the test from the build area to WICED machine ################"
							UTF::Message INFO "" "scp -Bqr $::latest_build/$test_bin_name/Binary/$test_bin_name.bin user@$STAIP:/tmp"
							exec scp -Bqr "$::latest_build/$test_bin_name/Binary/$test_bin_name.bin" "user@$STAIP:/tmp"
						} else {

							# This is a custom test. The bin file location is passed as parameter

							UTF::Message INFO "" "############# Copy the test from the CUSTOM build area to WICED machine ################"
							UTF::Message INFO "" "scp -Bqr $::latest_build/$test_bin_name.bin user@$STAIP:/tmp"
							exec scp -Bqr "$::latest_build/$test_bin_name.bin" "user@$STAIP:/tmp"
						}

						UTF::Message INFO "" "############# Load the test ################"
						set wiced_tool_loc "/cygdrive/c/Wiced/$::sdk_ver/Tools/OpenOCD"
						$STA rexec -t $test_max_time -T $test_max_time "cd $wiced_tool_loc ; $wiced_tool_loc/openocd-all-brcm-libftdi.exe -f BCM9WCD1EVAL1.cfg -f $::stm_cfg -f $::app_cfg -c \"flash write_image erase /tmp/$test_bin_name\.bin 0x08000000 bin\" -c shutdown"

						UTF::Sleep 1 "" "delay for test"
						
						set wiced_load_flag 0
					}

					UTF::Message INFO "" "############# Reset the WICED board ################"
					set dev_reset [$STA cget -device_reset]
					set dev_reset [string trim $dev_reset]
					$STA device_reset

					UTF::Message INFO "" "############# Start consolelogger to caputure results ################"
					set results [WICED::start_consolelogger $STA $test_delay]

					UTF::Message INFO "" "############# validate the results ################"

					UTF::Message INFO "" "----------------------------------------------"
					UTF::Message INFO "" "$results"
					UTF::Message INFO "" "----------------------------------------------"

					# if this is a sensor test
					if {$sensor_test_flag == 1} {
						UTF::Message INFO "" "----------------------------------------------"
						
						UTF::Sleep 3 "" "delay for sensor test (WICED is an AP now)"
						UTF::Message INFO "" "*************** WICED is Server **************"
						
						UTF::Message INFO "" "STA to join WICED AP"
						$STA wl join $::wiced_ap_ssid
						UTF::Sleep 15 "" "Wait for association"
						$STA wl assoc
						UTF::Message INFO "" "STA client is connected to WICED Server ssid $::wiced_ap_ssid"

						UTF::Message INFO "" "----------------------------------------------"

						UTF::Message INFO "" "Launch a browser 192.168.1.1 to access WICED sensor configuration"
						UTF::Message INFO "" "WICED to connect to AP ssid $::ap_ssid and become a client"
						UTF::Message INFO "" "Run Python HTTP code sensor_ap_connect.py to do this"

						# workaround:
						#	do not use taskkill & tasklist. It will launch Python.exe process.
						#	use python_clean.bat instead						
						#catch {$STA rexec -t $test_max_time -T $test_max_time "taskkill /F /T /IM \"python.exe\""}
						#catch {$STA rexec -t $test_max_time -T $test_max_time "tasklist /FI \"IMAGENAME eq python.exe\""}

						catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_test_loc/python_clean.bat"}
						$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_loc\/python.exe -udv sensor_ap_connect.py $ap_channel $::ap_ssid $::ap_wpakey"

						UTF::Message INFO "" "WICED is connected to AP ssid $::ap_ssid as a client"

						UTF::Message INFO "" "----------------------------------------------"
						
						UTF::Message INFO "" "*************** WICED is Client **************"

						UTF::Message INFO "" "WICED client builds 26 fake sensor data. connects to UDP port 50007 and sends the data out"
						UTF::Message INFO "" "Run Python report_server.py code to collect UDP port 50007 sensor data"

						catch {$STA rexec -t $test_max_time -T $test_max_time "rm -rf /cygdrive/c$::python_test_loc/report_server.txt"}
						catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_test_loc/python_clean.bat"}
						
						set wiced_python_loc "/cygdrive/c/Wiced/$::sdk_ver/Apps/sensor"
						catch {$STA rexec -t 45 -T 45 "cd $wiced_python_loc ; /cygdrive/c$::python_loc\/python.exe -udv report_server.py >/cygdrive/c$::python_test_loc/report_server.txt"}
						
						catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_test_loc/python_clean.bat"}
						
						UTF::Message INFO "" "Copy UDP port 50007 sensor data to UTF report location"
						exec scp -p -r "user@$STAIP:/cygdrive/c$::python_test_loc/report_server.txt" $LogLoc
						UTF::Message INFO "" "Change the permission of sensor data report_server.txt"
						# change the permission of the file copied
						exec chmod -R 777 $LogLoc/report_server.txt
						
						UTF::Message INFO "" "----------------------------------------------"
						
						UTF::Message INFO "" "Validate sensor data in report_server.txt"
						
						set sensor_udp_log [open "$LogLoc\/report_server.txt"]

						set sensor_test_passed 0
								
						while {[gets $sensor_udp_log line]>=0} { 
							UTF::Message INFO "debug" "$line"
							if {[regexp -nocase {sample\[25\] : ([-+]?[0-9]*\.?[0-9]+)} $line match value]} {
								set sensor_test_passed 1
								UTF::Message INFO "debug" "Test passed with sample 25=$value"
								# log all the messages
								#break
							}
						}
						
						if {$sensor_test_passed == 0} {
							UTF::Message ERROR "" "***Failed. Could not find sensor UDP results"
							set err_str "Could not find sensor UDP results"
						}						
					} elseif {$web_server_test_flag == 1} {
					
						# this is a web server test
						UTF::Message INFO "" "----------------------------------------------"
						
						UTF::Sleep 3 "" "delay for web server test (WICED is a web server now)"
						UTF::Message INFO "" "*************** WICED is Web Server **************"
					
						catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_test_loc/python_clean.bat"}

						set catch_resp [catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_loc\/python.exe -u web_server_connect.py"} catch_msg]

						UTF::Message INFO "" "--------------------------------------------"
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						UTF::Message INFO "" "--------------------------------------------"
						if {$catch_resp != 0} {
							UTF::Message LOG "" "***Failed. Web Server test failed."
							set err_str $catch_msg
						} else {
							if {[regexp -nocase {.*Server Information.*} $catch_msg] &&
								[regexp -nocase {.*Firmware Download.*} $catch_msg] &&
								[regexp -nocase {.*Speed test.*} $catch_msg]} {
								UTF::Message INFO "" "WICED Web Server is running"
							} else {
								UTF::Message LOG "" "***Failed. Web page is not correct."
								set err_str "Web page is not correct"
							}							
						}						

						UTF::Message INFO "" "----------------------------------------------"
						
					} elseif {$throughput_test_flag == 1} {
					
						# this is a web server throughput test
						UTF::Message INFO "" "----------------------------------------------"
						
						UTF::Sleep 3 "" "delay for web server throughput test (WICED is a web server now)"
						UTF::Message INFO "" "*************** WICED is Web Server **************"
					
						catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_test_loc/python_clean.bat"}

						if {[string match -nocase "*download*" $test_name]} {

							set catch_resp [catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_loc\/python.exe -u web_server_download_speed.py"} catch_msg]
						} else {
							set catch_resp [catch {$STA rexec -t $test_max_time -T $test_max_time "cd /cygdrive/c$::python_test_loc ; /cygdrive/c$::python_loc\/python.exe -u web_server_upload_speed.py"} catch_msg]
						}

						UTF::Message INFO "" "--------------------------------------------"
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						UTF::Message INFO "" "--------------------------------------------"
						if {$catch_resp != 0} {
							UTF::Message LOG "" "***Failed. Web Server throughput test failed."
							set err_str $catch_msg
						} else {
							set throughput_values ""
								
							if {[regexp -nocase {throughput =\s*(\d+.\d+)\s*Mbps} $catch_msg match throughput_value]} {
								# send the value 3 times, so the memchart is not used
								lappend throughput_values $throughput_value
								lappend throughput_values $throughput_value
								lappend throughput_values $throughput_value
								UTF::Message INFO "debug" "throughput value=$throughput_value"

								set keys "$::wlan_card_type APChan=$ap_channel $test_name $base_keys"
								UTF::Message INFO "" "keys=$keys"

								# Create new ControlChart object & graphics file
								set html_results [WICED::control_chart $throughput_values $keys "Throughput" "Mbps" 0]
							}
						}						

						UTF::Message INFO "" "----------------------------------------------"
					} else {
					
						set result_items [split $test_result "|"]

						foreach result_item $result_items {

							UTF::Message INFO "debug" "validate expected result \"$result_item\""

							# For ping validation, we do control chart
							if {$ping_test_flag == 1} {

								# get the ping time expected
								if {![regexp -nocase {Ping Reply\s*(\d+)ms} $result_item match ping_time_expected]} {
									set ping_time_expected ""
								}
								UTF::Message INFO "debug" "ping time expected=$ping_time_expected"

								##############################
								
								# break up the pings
								
								regsub -all "Ping " $results "|" results2
								set split_results [split $results2 "|"]
								# 1st element is not a ping, delete it
								set split_results2 [lreplace $split_results 0 0]
								
								set ping_actual_values ""
								set sample_cnt 0
								
								foreach ping_data $split_results2 {
			
									UTF::Message INFO "" "ping_data=$ping_data"
									
									# get the actual ping value
									if {[regexp -nocase {Reply\s*(\d+)ms} $ping_data match ping_time_actual]} {
										lappend ping_actual_values $ping_time_actual
										UTF::Message INFO "debug" "Ping time actual=$ping_time_actual"
										set sample_cnt [expr $sample_cnt + 1]
										if {$sample_cnt >= 3} {
											break
										}
									}
								}			

								if {[llength $ping_actual_values] == 0} {
									set err_str "Could not read ping value"					
								}

								#set ping_time_diff [expr $ping_time_expected - $ping_time_actual]
								#set ping_time_diff [expr abs(int($ping_time_diff))]
								#if {$ping_time_diff > 3} {
									#set err_str "ping time value change is $ping_time_diff ms"					
								#}

								set keys "$::wlan_card_type APChan=$ap_channel $test_name $base_keys"
								UTF::Message INFO "" "keys=$keys"

								# Create new ControlChart object & graphics file
								set html_results [WICED::control_chart $ping_actual_values $keys "Ping Time" "ms" 1]

							} elseif {$scan_test_flag == 1 && [string match -nocase "*rssi*" $result_item]} {

								# For RSSI value validation, we do control chart

								# get the RSSI value expected
								if {![regexp -nocase {RSSI\s*:\s*(-\d+)dBm} $result_item match rssi_expected]} {
									set rssi_expected ""
								}
								UTF::Message INFO "debug" "RSSI expected=$rssi_expected"

								##############################
								
								# break up the scans
								
								regsub -all "#001" $results "|" results2
								set split_results [split $results2 "|"]
								# 1st element is not a scan, delete it
								set split_results2 [lreplace $split_results 0 0]
								
								set rssi_actual_values ""
								set sample_cnt 0
								
								foreach scan_data $split_results2 {
			
									UTF::Message INFO "" "scan_data=$scan_data"
									
									# get the actual RSSI value
									if {[regexp -nocase {RSSI\s*:\s*(-\d+)dBm} $scan_data match rssi_actual]} {
										lappend rssi_actual_values $rssi_actual
										UTF::Message INFO "debug" "RSSI actual=$rssi_actual"
										set sample_cnt [expr $sample_cnt + 1]
										if {$sample_cnt >= 2} {
											break
										}
									}
								}			

								if {[llength $rssi_actual_values] == 0} {
									set err_str "Could not read RSSI value"					
								}

								#set rssi_diff [expr $rssi_expected - $rssi_actual]
								#set rssi_diff [expr abs(int($rssi_diff))]
								#if {$rssi_diff > 3} {
									#set err_str "RSSI value change is $rssi_diff dBm"					
								#}

								set keys "$::wlan_card_type APChan=$ap_channel $test_name $base_keys"
								UTF::Message INFO "" "keys=$keys"

								# Create new ControlChart object & graphics file
								set html_results [WICED::control_chart $rssi_actual_values $keys "RSSI" "dBm" 0]

							} else {				
								if {[string match "*$result_item*" $results]} {
									UTF::Message INFO "debug" "found \"$result_item\""
								} else {
									UTF::Message ERROR "" "***Failed. Could not find \"$result_item\""
									set err_str "Could not find \"$result_item\""
									break
								}
							}
						}
					}

					if {$scan_test_flag == 1 || $ping_test_flag == 1 || $throughput_test_flag == 1} {
						if {$::WICED::cc_error_flag == 1} {
							error "html: $html_results"
						} elseif {$err_str != ""} {
							error "$err_str"
						} else {
							return "html: $html_results"
						}
					} else {
						if {$err_str == ""} {
							return ""
						} else {
							error "$err_str"
						}
					}
				}
			}
		}
	}

	PreservedReport

	if {!$(noposttesthook) && [info exists ::UTF::PostTestHook]} {
	    UTF::Try "Post Test" {
		eval $::UTF::PostTestHook
	    }
	}

	# WrapSummary bracket
	}
}
