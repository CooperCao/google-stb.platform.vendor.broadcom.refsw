#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for aci1fidha test run
# $Id: 0634e0a581b45aeb5ec798269fa868581df43e8e $
# $Copyright Broadcom Corporation$
#

package require UTF
package require UTF::Linux
package require UTF::utils
package require UTF::Sniffer
package require UTF::Test::controlchart
package require UTF::Test::APChanspec

package provide UTF::Test::aci1fidha 2.0

#============== Common procs used in main test ======================

#============== proc beacon_cc ======================================
# Produces separate control charts for beacon loss & recovery.
#
# Puts 2 control chart on the summary web page.
#====================================================================
proc beacon_cc {STA LAN routerConfig direction history key_template readonly\
    udp focus chanspec attnstep} {

    # Do 2 beacon control charts as one result.
    set ::rvrd "" ;# variable to pass controlchart pathnames back
    UTF::Try "$STA $routerConfig $direction Beacons" {

        # Set Y-Axis title
        if {$udp > 0} {
            set xport UDP
        } else {
            set xport TCP
        }
        set title1 "$::testrig $::int_desc BeaconLossDown $xport $routerConfig Ch=$chanspec $focus $direction"
        set title2 "$::testrig $::int_desc BeaconLossUp $xport $routerConfig Ch=$chanspec $focus $direction"

        # Beacon Loss Down CC. Take first consisent beacon loss.
        regsub -nocase "AttnUp" $key_template "" key_template
        regsub -nocase "\{step\}" $key_template "BeaconLossDown" keys
        set val [UTF::find_consecutive_values "$::rvr_rampdown_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward 0 $attnstep]
        set catch_resp1 0
        set catch_msg1 ""
        if {$val != ""} {
            puts "keys=$keys val=$val"
            set catch_resp1 [catch "UTF::update_control_chart_data \"$keys\" \"$val\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction 1 $history \"$title1\" \"dB\" \"Attenuation\"" catch_msg1]
            lappend ::rvrd $::uccd_png_path ;# save first CC graphic
            save_results $STA $LAN "$keys" $routerConfig $chanspec $direction BeaconLossDown $val
        }

        # Beacon Loss Up CC. Take last consisent beacon loss, using negative step.
        regsub -nocase "\{step\}" $key_template "BeaconLossUp" keys
        set val [UTF::find_consecutive_values "$::rvr_rampup_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward end -$attnstep]
        set catch_resp2 0
        set catch_msg2 ""
        if {$val != ""} {
            puts "keys=$keys val=$val"
            set catch_resp2 [catch "UTF::update_control_chart_data \"$keys\" \"$val\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction 1 $history \"$title2\" \"dB\" \"Attenuation\"" catch_msg2]
            lappend ::rvrd $::uccd_png_path ;# save second CC graphic
            save_results $STA $LAN "$keys" $routerConfig $chanspec $direction BeaconLossUp $val
        }

        # Massage into one composite result.
        regsub {^html:} $catch_msg1 "" catch_msg1
        regsub {^html:} $catch_msg2 "" catch_msg2
        set result "html: <b>BeaconLossDown</b> $catch_msg1 <br><b>BeaconLossUp</b> $catch_msg2"
        if {$catch_resp1 == 0 && $catch_resp2 == 0} {
            return $result
        } else {
            error $result
        }
    }
}

#============== proc check_ap_connect_time ==========================
# Checks for more than 1 drop in the AP connect time.
#====================================================================
proc check_ap_connect_time {csv_path ap_type attnstep routerConfig direction is_oem_ap} {
    UTF::Message LOG $::localhost "check_ap_connect_time csv_path=$csv_path ap_type=$ap_type\
        attnstep=$attnstep routerConfig=$routerConfig direction=$direction is_oem_ap=$is_oem_ap\
        ::rvr_connect_time_drop=$::rvr_connect_time_drop"

    # Some users may wish to turn off this test. Dont do test for OEM AP.
    if {$::rvr_connect_time_drop <= 0 || $is_oem_ap != "0"} {
        return
    }

    UTF::Try "$routerConfig $direction $ap_type Check Connect Time" {

        # Get list of loss & AP connect time.
        set ap_time_col [find_csv_column apConnectTime]
        set ap_time [UTF::read_csv_data $csv_path 0 $ap_time_col]

        # Look for drops in AP connect time. The connect time may have
        # dropped to 0 and then started to rise again. Due to the
        # discrete sampling done by the scripts, we may see a large drop
        # in the connect time, but it wont necessarily hit zero. So we 
        # look for drops that exceed 30 seconds (ref ::rvr_connect_time_drop),
        # as well as 0.
        set issue_list ""
        set prev_loss "" ;# last loss we examined
        set prev_time "" ;# last time we examined
        set prev_issue_loss -1 ;# loss for last issue that occurred
        set ramp "" ;# tracks place on graph: down bottom up flat
        foreach pair $ap_time {

            # Get current pair of loss & time, ignore blanks.
            set loss [lindex $pair 0]
            set loss [string trim $loss]
            set time [lindex $pair 1]
            set time [string trim $time]
            set extra [lindex $pair 2] ;# boobytrap, should always be null
            set extra [string trim $extra]
            # puts "loss=$loss time=$time extra=$extra"
            if {$loss == "" || $time == "" || $extra != ""} {
                UTF::Message WARN $::localhost "check_ap_connect_time\
                    missing or extra data: loss=$loss time=$time extra=$extra"
                continue
            }

            # First pair are used to initialize the checks.
            if {$prev_loss == "" || $prev_time == ""} {
                set prev_loss $loss
                set prev_time $time
                continue
            }

            # Keep track of ramp status.
            if {$loss > $prev_loss} {
                # Curve is ramping down
                set ramp down
            } elseif {$loss == $prev_loss && ($ramp == "" || $ramp == "down")} {
                # This is the bottom of the curve
                set ramp bottom
            } elseif {$loss < $prev_loss} {
                # Curve is ramping up
                set ramp up
            } elseif {$loss == $prev_loss && $ramp == "up"} {
                # This is the right flat side of the curve
                set ramp flat
            }
            # puts "prev_loss=$prev_loss loss=$loss ramp=$ramp"

            # Did we get a significant drop or hit 0? Curve may start at 0,
            # stay there for a while and then rampup, which we allow for.
            set drop [expr $prev_time - $time]
            # puts "prev_time=$prev_time time=$time drop=$drop loss=$loss ramp=$ramp"
            if {$drop >= $::rvr_connect_time_drop ||\
                ($time == 0 && $prev_time >= $::rvr_connect_time_drop)} {

                # We dont want to record errors that are adjacent, but
                # we can get adjacent errors on fastrampup flat part of curve.
                # NB: for ramp=bottom, step can be 0.
                # NB: for fastramp flat right side of curve, step can be 0.
                set step [expr abs($loss - $prev_issue_loss)]
                if {($ramp == "bottom" && $step == 0) || $step == $attnstep} {
                    UTF::Message LOG $::localhost "check_ap_connect_time step=$step\
                        ramp=$ramp ignoring adjacent issue: $loss"
                } else {
                    lappend issue_list $loss
                    UTF::Message LOG $::localhost "check_ap_connect_time step=$step\
                    ramp=$ramp new issue: $loss"
                }
                set prev_issue_loss $loss
            }

            # Update tracking state info
            set prev_loss $loss
            set prev_time $time
        }

        # Always allow 1 issue. If we did rampuponly, the AP connect
        # time starts off GT 0 because we always make a connection at
        # a low attenuation at the start of the test.
        UTF::Message LOG $::localhost "check_ap_connect_time issue_list=$issue_list"
        if {[llength $issue_list] <= 1} {
            UTF::Message LOG $::localhost "check_ap_connect_time 1 issue is always expected"
            return
        } else {
            error "check_ap_connect_time issues at loss: $issue_list"
        }
    }
}

#============== proc check_malloc_fail ==============================
# Returns the STA malloc fail count. Counts total errors so user
# gets only one composite error at the end of the test.
#====================================================================
proc check_malloc_fail {STA nomalloc routerConfig direction} {

    # User may choose to not look for malloc failures.
    if {$nomalloc} {
        return
    }

    # Here we test whether the STA device is a dongle device. 
    # If so, check the buffer alloc fail count.
    if {[$STA hostis DHD WinDHD]} {
        set catch_resp [catch {UTF::check_rte_mu_output $STA ".*malloc.*count:"} catch_msg]
        # UTF::Message LOG "$::localhost" "check_malloc_fail catch_resp=$catch_resp catch_msg=$catch_msg"
    } else {
        return
    }

    # If malloc fail count is 0 or no serial console is defined, we are done.
    # set catch_msg 44 ;# test code
    if {![info exists catch_msg]} {
        set catch_msg "???"
    }
    if {$catch_msg == "0" || $catch_msg == "no serial console"} {
        return $catch_msg 
    }

    # Return numeric value or a very short error msg. This data goes into the
    # .CSV file, and we dont need huge error messages in there. If the error
    # were to contain a comma, that would really mess up parsing of the .CSV
    # data file and subesequent plotting of the graphs.
    if {![regexp {^\d+$} $catch_msg]} {
        UTF::Message ERROR $STA "++++ serial console error: $catch_msg"
        set catch_msg "serial console error"
    }

    # Save the malloc fail count or other errors for a single composite error.
    set ::rvr_malloc_fail_errors $catch_msg
    return $catch_msg
}

#============== proc check_trend_errors =============================
# Checks for overall trend errors. 
#====================================================================
proc check_trend_errors {trend routerConfig direction} {

    # Many users will want the default PASS/FAIL mode.
    if {$trend == 0} {
        return
    }

    UTF::Try "$routerConfig $direction Check Trend Errors" {

        # Log the data and parameters.
        UTF::Message LOG $::localhost "check_trend_errors\
            process_cc_results_list=$::process_cc_results_list"
        UTF::Message LOG $::localhost "check_trend_errors\
            rvr_trend_error_length=$::rvr_trend_error_length\
            rvr_trend_error_max=$::rvr_trend_error_max"

        # Look for consecutive errors as well as total errors.
        set all_error_list "";# shows all error pairs
        set curr_trend_error_list "" ;# build up possible trend error
        set trend_error_cnt 0 ;# counter for trend errors found
        set trend_error_list "" ;# shows actual trend errors
        foreach pair $::process_cc_results_list {
            set loss [lindex $pair 0]
            set result [lindex $pair 1]
            set result [string toupper $result]
            if {$result == "LOW" || $result == "WIDE" || $result == "ZERO" || $result == "OTHER"} {
                # Save each error found.
                UTF::Message LOG $::localhost "check_trend_errors\
                    new ERROR: loss=$loss result=$result"
                lappend curr_trend_error_list $pair
                lappend all_error_list $pair

            } else {
                # Good result. Did we an existing possible error trend?
                set len [llength $curr_trend_error_list]
                # puts "len=$len curr_trend_error_list=$curr_trend_error_list"
                if {$len >= $::rvr_trend_error_length} {
                    incr trend_error_cnt 
                    UTF::Message LOG $::localhost "check_trend_errors\
                        new TRENDERROR: $trend_error_cnt: $curr_trend_error_list"
                    lappend trend_error_list "$trend_error_cnt: $curr_trend_error_list"
                }

                # Reset curr_trend_error_list
                set curr_trend_error_list ""
             }
        }

        # At the end of the data, did we have a possible error trend?
        set len [llength $curr_trend_error_list]
        # puts "len=$len curr_trend_error_list=$curr_trend_error_list"
        if {$len >= $::rvr_trend_error_length} {
            incr trend_error_cnt 
            UTF::Message LOG $::localhost "check_trend_errors\
                new TRENDERROR: $trend_error_cnt: $curr_trend_error_list"
            lappend trend_error_list "$trend_error_cnt: $curr_trend_error_list"
        }

        # Now we decide the overall PASS / FAIL status.
        set len [llength $all_error_list]
        if {$trend_error_cnt == 0 &&  $len <= $::rvr_trend_error_max} {
            # No trend errors & acceptable total errors => PASS
            if {$all_error_list == ""} {
                return
            } else {
                return "acceptable errors: $len $all_error_list"
            }

        } else {
            if {$trend_error_cnt == 0} {
                # Show all errors
                error "ALLERRORS: $len $all_error_list" 
            } else {
                # Just show trend errors. Dont show list of all errors, 
                # it really clutters the report on top of the trend errors.
                error "TRENDERRORS: $trend_error_cnt $trend_error_list ALLERRORS: $len" 
            }
        }
    }
}

#============== proc check_testmode =================================
# Complains is we are using test_mode != 0
#====================================================================
proc check_testmode {test_mode} {

    if {$::test_mode != 0} {
        UTF::Try "WARNING: ::test_mode is not 0" {
            error $::test_mode
        }
    }
}

#============== proc choose_attn_step ===============================
# Choose the next value the attenuator will use.
# Also implements the optional fastrampup test.
# Also implements the arbitrary steplist.
#
# Returns: step
#====================================================================
proc choose_attn_step {step attnstep attnDirection range2 fastrampup mean_tput steplist cc_samples} {

    # Keep track of when we rejoin / get traffic on the rampup.
    if {$attnDirection == "down" && $mean_tput >= $::rvr_rejoin_tput && $::rvr_rejoin_result == ""} {
        # Save attn & samples for separate controlchart usage.
        set ::rvr_rejoin_result "$step $cc_samples"
        UTF::Message LOG $::localhost "choose_attn_step rvr_rejoin_result=$::rvr_rejoin_result"
    }

    # If appropriate, pick the next totaly arbitrary step from the steplist.
    set steplist [string trim $steplist]
    if {$steplist != ""} {
        incr ::step_index
        set step [lindex $steplist $::step_index]
        UTF::Message LOG $::localhost "choose_attn_step step=$step step_index=$::step_index\
            steplist=$steplist"
        return $step
    }

    # Attenuator is adjusted at the top of the loop.
    if {$attnDirection == "up"} {
        # AKA rampdown test
        set step [expr $step + $attnstep]
    } else {
        # AKA rampup test
        set step [expr $step - $attnstep]
    }

    # For fastrampup test, we use a different step algorithm.
    if {$attnDirection != "up" && $fastrampup == 1} {
        UTF::Message LOG $::localhost "choose_attn_step attnDirection=$attnDirection\
            fastrampup=$fastrampup rvr_fastrampup_active=$::rvr_fastrampup_active\
            mean_tput=$mean_tput rvr_fastrampup_tput=$::rvr_fastrampup_tput"

        # First we wait for traffic to start, GE ::rvr_fastrampup_tput
        if {$mean_tput >= $::rvr_fastrampup_tput && $::rvr_fastrampup_active == 0} {
            set ::rvr_fastrampup_active 1
        }

        # If fastrampup is active, we jump the attenuator to the final
        # value of the rampup range and kick the duration counter.
        if {$::rvr_fastrampup_active > 0} {
            set step $range2
            incr ::rvr_fastrampup_duration
            # Update description to keep TC titles unique
            set ::aux_desc "FastRampUp${::rvr_fastrampup_duration}"
        }

        # When we have done the required number of tests at the 
        # attenuator final value, stop the fastrampup test.
        if {$::rvr_fastrampup_active > 0 && \
            $::rvr_fastrampup_duration > $::rvr_fastrampup_cnt} {
            set ::rvr_fastrampup_active 2
        }
        UTF::Message LOG $::localhost "choose_attn_step attnDirection=$attnDirection\
            fastrampup=$fastrampup step=$step\
            rvr_fastrampup_active=$::rvr_fastrampup_active\
            rvr_fastrampup_duration=$::rvr_fastrampup_duration\
            rvr_fastrampup_cnt=$::rvr_fastrampup_cnt\
            mean_tput=$mean_tput rvr_fastrampup_tput=$::rvr_fastrampup_tput"
    }
    return $step
}

#============== proc edit_hooks =====================================
# Edits the perf_hooks and related config items to remove redundant
# items that are explicitly done by RvR tests. This speeds up the
# tests by not doing selected actions twice times 100+ attenuator 
# steps.
#====================================================================
proc edit_hooks {AP LAN STA allhooks edithooks nohooks} {
    UTF::Message LOG "$::localhost" "edit_hooks AP=$AP LAN=$LAN STA=$STA\
        allhooks=$allhooks edithooks=$edithooks nohooks=$nohooks"

    # Log the existing hooks, if any.
    log_hooks $AP $LAN $STA

    # For allhooks=1, we are done. User said to use everything the way 
    # it is. For time being, if user specified none of the 3 options,
    # act as though allhooks was specified.
    if {$allhooks == "1" || ($allhooks == "0" && $edithooks == "0" && $nohooks == "0")} {
       UTF::Message LOG "$::localhost" "edit_hooks leaving your hooks as is, no changes"
       return
    }

    # For nohooks=1, set them all to null.
    if {$nohooks== "1"} {
        UTF::Message LOG "$::localhost" "edit_hooks removing all hooks"
        catch "unset UTF::controlchart_cmds"
        foreach item "$AP $LAN $STA" {
            foreach option "pre_perf_hook post_perf_hook" {
                $item configure -${option} ""
            }
        }
        log_hooks $AP $LAN $STA
        return
    }

    # Selectively edit the hooks. This will eventually become the default.
    UTF::Message LOG "$::localhost" "edit_hooks selectively editing hooks"
    # catch "unset UTF::controlchart_cmds"

    # We remove the items that the RvR script always does on the STA. 
    # With advent of SoftAP, we edit hooks on AP also to avoid duplication.
    # Leave the LAN alone, as the script doesnt query the LAN for info.
    foreach item "$AP $STA" {
        foreach option "pre_perf_hook post_perf_hook" {
            set value [$item cget -${option}]
            # puts "item=$item option=$option value=$value"
            # NB: Some users put specific STA names in the commands.
            # Other users use the UTF %S syntax.
            regsub -all -nocase {\{\s*\S+\s+wl\s+ampdu_clear_dump\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+assoc\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+dump\s+ampdu\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+nrate\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+rate\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+wl\s+rssi\s*\}} $value "" value
            regsub -all -nocase {\{\s*\S+\s+rte\s+mu\s*\}} $value "" value
            set value [string trim $value]
            # puts "after value=$value"
            $item configure -${option} $value
        }
    }

    # Do similar edits on UTF::controlchart_cmds.
    if {[info exists UTF::controlchart_cmds]} {
        set value $UTF::controlchart_cmds
        puts "UTF::controlchart_cmds value=$value"
        regsub -all -nocase {%S\s+wl\s+ampdu_clear_dump} $value "" value
        regsub -all -nocase {%S\s+wl\s+assoc} $value "" value
        regsub -all -nocase {%S\s+wl\s+dump\s+ampdu} $value "" value
        regsub -all -nocase {%S\s+wl\s+nrate} $value "" value
        regsub -all -nocase {%S\s+wl\s+rate} $value "" value
        regsub -all -nocase {%S\s+wl\s+rssi} $value "" value
        regsub -all -nocase {%S\s+rte\s+mu} $value "" value
        set value [string trim $value]
        puts "after value=$value"
        set UTF::controlchart_cmds $value
    }
    log_hooks $AP $LAN $STA
    return
}

#============== proc find_csv_column ================================
# Finds the column number in the CSV titles for the specified field.
#====================================================================
proc find_csv_column {field} {

    # Get column number for field. Titles are comma separated.
    regsub -all {\s} $::csv_titles "" titles ;# clean out whitespace
    set titles [split $titles ","]
    set i [lsearch -exact $titles $field]
    if {$i >= 0} {
        UTF::Message LOG "" "find_csv_column field=$field i=$i"
    } else {
        UTF::Message ERROR "" "find_csv_column field=$field i=$i\
            titles=$titles" ;# gives error trace
    }
    return $i
}

#============== proc get_user_parms =================================
# gets users parameters from config file, sets defaults as needed.
#====================================================================
proc get_user_parms {timeout softap AP STA intsta intwl} {

    # Command line timeout takes precedance.
    if {$timeout != ""} {
        set ::rvr_overall_timeout_min $timeout
    }

    # If variables are not defined, use specified defaults.
    set msg ""
    foreach {var def lowlim} "::recovery_max 3 -1 \
        ::rvr_attn_max_errors 3 -1\
        ::rvr_connect_time_drop 30 -1\
        ::rvr_fastrampup_cnt 10 -1 ::rvr_fastrampup_tput 1 -1\
        ::rvr_overall_timeout_min 90 -1\
        ::rvr_rampdown_nobeacons 3 -1 ::rvr_rate_cnt 3 1\
        ::rvr_rejoin_tries 1 1 ::rvr_rejoin_tput 1 0 ::rvr_rejoin_wait_sec 10 5\
        ::rvr_slowrampup_cnt 10 -1 ::rvr_slowrampup_tput 1 -1\
        ::rvr_trend_error_length 6 2 ::rvr_trend_error_max 18 2" {
        # puts "var=$var def=$def lowlim=$lowlim"
        if {![info exists $var]} {
            set $var $def
        }

        # Check variable value is numeric and not less than lowlim.
        set temp [set $var]
        if {![regexp {^[\-\d\.]+$} $temp] || $temp < $lowlim} {
            UTF::Message ERROR "$::localhost" "get_user_parms invalid\
                $var=$temp, using $def"
            set $var $def
        }

        # Build list of final values.
        set temp [set $var]
        append msg " $var=$temp"
    }

    # Log the final values used.
    UTF::Message LOG "$::localhost" "get_user_parms config file: $UTF::args(utfconf)"
    set msg [string trim $msg]
    UTF::Message LOG "$::localhost" "get_user_parms $msg"

    # Get rvr STA init string & log it. We have a hierarchy of possible customizations.
    # See what user has defined in their config file, if anything. 
    set sta_default ::rvr_sta_init
    if {$softap == 1} {
        set var_list "::rvr_sta_${STA}_to_softap_init ::rvr_sta_${STA}_init ::rvr_sta_to_softap_init"
    } else {
        set var_list "::rvr_sta_${STA}_to_ap_init ::rvr_sta_${STA}_init ::rvr_sta_to_ap_init" 
    }
    set var_list "$var_list $sta_default"
    set found ""
    foreach var $var_list {
        if {[info exists $var]} {
            set found $var
            break
        }
    }

    # Use first item in hierarchy found from config file.
    if {$found != ""} {
        set temp [set $found]
        set $sta_default $temp
    }

    # If no default value exists, use original defaults.
    if {![info exists $sta_default]} {
        set $sta_default {{%S wl down} {%S wl mimo_bw_cap 1} {%S wl up} {%S wl mpc 0}\
            {%S wl isup} {%S wl msglevel +error +assoc} {%S services stop}\
            {%S wl PM 0} {%S wl roam_trigger -100 all}}
    }
    set temp [set $sta_default]
    UTF::Message LOG "$::localhost" "get_user_parms STA $found: $temp"

    # Get rvr AP init string & log it. We have a hierarchy of possible customizations.
    # See what user has defined in their config file, if anything. 
    set ap_default ::rvr_ap_init
    if {$softap == 1} {
        # For softap, final value is STA defaults.
        set var_list "::rvr_sta_${AP}_am_softap_init ::rvr_sta_${AP}_init ::rvr_softap_init ::rvr_sta_init"
    } else {
        set var_list "::rvr_ap_${AP}_init $ap_default" 
    }
    set found ""
    foreach var $var_list {
        if {[info exists $var]} {
            set found $var
            break
        }
    }

    # Use first item in hierarchy found from config file.
    if {$found != ""} {
        set temp [set $found]
        set $ap_default $temp
    }

    # If no default value exists, use original defaults.
    if {![info exists $ap_default]} {

        # nphy_percal is an old default -- needs to be removed.
        set $ap_default {{%S wl nphy_percal 1}}
    }
    set temp [set $ap_default]
    UTF::Message LOG "$::localhost" "get_user_parms AP $found: $temp"

    # Add commands for interference tests.
    set intsta [string trim $intsta]
    if {$intsta != ""} {
        foreach var "$ap_default $sta_default" {
            # Remove interference_override setting from previous test, if any.
            set value [set $var]
            # puts "var=$var value=$value"
            regsub -all -nocase {\{%S\s+wl\s+interference_override\s+\d+\}} $value "" value
            lappend value "%S wl interference_override $intwl"
            set $var $value
            # puts "var=$var value=$value"
        }
        UTF::Message LOG "$::localhost" "get_user_parms added/replaced: %S wl interference_override $intwl"
    }
    return
}

#============== proc iperf_ramp =====================================
# Do this only if user explicitly specified the -warmup option.
#====================================================================
proc iperf_ramp {STA LAN direction attnDirection window tput_mean warmup} {

    # We do this for Upstream only, attnuation decreasing, which is the
    # rampup right side of a normal RvR curve, once we managed to get
    # some data thoughput going again. Do only if user explicitly asked
    # for -warmup.
    if {$warmup == 0} {
        return
    }

    UTF::Message LOG "$::localhost" "iperf_ramp STA=$STA LAN=$LAN\
        direction=$direction attnDirection=$attnDirection window=$window\
        ::iperfRamp=$::iperfRamp tput_mean=$tput_mean"

    # Do iperf ramp once, if necessary.
    if {$direction == "Upstream" && $attnDirection == "down" && $tput_mean > 0 &&\
        $::iperfRamp == ""} {
        set PAIRS [list $STA $LAN]
        UTF::Try "Doing iperf ramp" {
            set resp [UTF::Multiperf $PAIRS -w $window -N -t 120 -i 120]
            set resp [string trim $resp]
            if {$resp == ""} {
                set resp 0
            }
            return [format "%.2f Mb/s" $resp]
        }
        set ::iperfRamp done
    }
}


#============== proc log_hooks =====================================
# Logs the perf_hooks and related config items.
#====================================================================
proc log_hooks {args} {

    # Log the existing hooks, if any.
    if {[info exists UTF::controlchart_cmds]} {
        UTF::Message LOG "$::localhost" "log_hooks found\
            UTF::controlchart_cmds=$UTF::controlchart_cmds"
    }
    foreach item $args {
        foreach option "pre_perf_hook post_perf_hook" {
            set value [$item cget -${option}]
            set value [string trim $value]
            UTF::Message LOG "$::localhost" "log_hooks found $item $option=$value"
        }
    }
    return
}

#============== proc monitor_interference ===========================
# Monitor interference STA & DUTs settings, collect stats.
# Returns: CSV list of 10 interference counters, 5 for AP, 5 for STA.
#====================================================================
proc monitor_interference {int_sta int_graph int_type dut_ap dut_sta step int_quiet int_wl} {

    # Is there anything to do? We may need to collect stats even if there is 
    # no interference test running. This allows for comparison of stats with 
    # and without interference.
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    set msg ", , , , , , , , , ,"
    UTF::Message LOG "" "monitor_interference int_sta=$int_sta int_graph=$int_graph\
        int_type=$int_type dut_ap=$dut_ap dut_sta=$dut_sta step=$step\
        int_quiet=$int_quiet int_wl=$int_wl"
    if {$int_sta == "" && $int_graph == 0} {
        return $msg
    }

    # wl shmem 0xe0 indicates if pkteng is running or not.
    # NB: counter wraps to 0 very quickly.
    if {$int_sta != "" && $int_type == "pkteng"} {
        if {$int_quiet} {
            # If requested, suppress messages from interference STA.
            set opt "-noinit"
        } else {
            set opt ""
        }
        set catch_resp [catch "eval $int_sta $opt wl shmem 0xe0" catch_msg]
        if {$catch_resp == 0} {
            lappend ::intsta_activity "$step $catch_msg"
            # UTF::Message LOG $int_sta "monitor_interference intsta_activity=$::intsta_activity"
        } else {
            UTF::Message WARN $int_sta "monitor_interference got: $catch_msg"
            lappend ::intsta_activity "$step WARN"
        }
    }

    # wl counters is supported on more builds than wl dump stats command.
    set result ""
    foreach item "$dut_ap $dut_sta" {

        # If DUT is known to be in trouble, leave it alone.
        set var "::${item}_state"
        if {[set $var] != "OK"} {
            append result " , , , , ,"
            continue
        }

        # Get counters delta from DUT. Getting all the counters every time
        # simplifies parsing delta values later on.
        set catch_resp [catch "UTF::access_counters $item getupdate showall silent" catch_msg]
        # UTF::Message LOG $item  "item=$item catch_msg=$catch_msg"
        UTF::save_device_state $item $catch_msg
        if {$catch_resp != 0} {
            # NB: These counters may not be supported on all chips
            UTF::Message WARN $item "monitor_interference got: $catch_msg"
            append result " , , , , ,"
            continue
        }

        # Parse out 5 stats delta. Data is formatted: countername=value=delta
        # NB: We want the delta from last iperf test, not the running total!
        if {![regexp -nocase {rxbadfcs=\d*=(\d*).*rxbadplcp=\d*=(\d*).*rxcrsglitch=\d*=(\d*).*rxdfrmucastmbss=\d*=(\d*).*rxstrt=\d*=(\d*)} $catch_msg - s0 s1 s2 s3 s4]} {
            UTF::Message ERROR $item "monitor_int_sta parsing error for: $catch_msg"
            append result " , , , , ,"
            continue
        }
        append result " $s0, $s1, $s2, $s3, $s4,"

        # Check interference settings have not changed.
        if {$int_sta == ""} {
            # NB: For regular tests, interference_override will be disabled.
            set cmd_list "interference"
        } else {
            set cmd_list "interference_override interference"
        }
	UTF::Message LOG "" "monitor_interference item=$item"
	foreach cmd $cmd_list {
	    set cur_str [$item wl $cmd]
	    if {$cur_str == ""} {
	        # Older chips may not return anything 
		set cur_val $int_wl
            } elseif {![regexp -nocase {mode\s+=?\s*(\d+)} $cur_str - cur_val]} {
                # Parse out N from 'mode N' or 'mode = N' in response $cur_str
                set cur_val "-"
                UTF::Message ERROR $item "monitor_interference could not parse: $cur_str"
            }
            # UTF::Message LOG $item "monitor_interference cur_str=$cur_str cur_val=$cur_val"

            # If appropriate, collect any errors as one list for use later
            if {$int_sta != "" && $cur_val != $int_wl} {
                # Allow AP to have interference mode 3 for 2G band as default for regular tests.
                if {$cur_val == 3 && $int_wl == 4 && $int_sta == "" && [UTF::is_ap $item]} {
                    UTF::Message WARN $item "monitor_interference allowing AP wl $cmd value $cur_val"
                } else {
                    UTF::Message ERROR $item "monitor_interference wl $cmd is $cur_val, should be $int_wl"
                    lappend ::intwl_errors "$item attn=$step $cmd=$cur_val" 
                    # For interference tests, set it back to desired value  
                    if {$int_sta != ""} {
                        $item wl $cmd $int_wl
                    }
                }
            }
        }
    }
    # UTF::Message ERROR $item "monitor_interference intwl_errors=$::intwl_errors"

    # Return CSV formatted stats
    UTF::Message LOG "" "monitor_interference result=$result"
    return $result
}

#============== proc monitor_beacons ================================
# Keeps track of when we have N consecutive no-beacon steps in a row
# for the rampdown / attenuator up test. Keeps track of when beacons
# have returned in the rampup / attenuator down test.
#
# Returns "yes" to stop the test if we had N consecutive no-beacon
# steps in a row on the rampdown / attenuator up test. 
# Returns "no" to keep tests going if user specified fullrange
# option or ::rvr_rampdown_nobeacons LE 0.
#====================================================================
proc monitor_beacons {step attnstep attnDirection fullrange} {
    UTF::Message LOG "$::localhost" "monitor_beacons step=$step attnstep=$attnstep\
        attnDirection=$attnDirection fullrange=$fullrange\
        rvr_rampdown_nobeacons=$::rvr_rampdown_nobeacons"

    # Rampdown / attenuator up case
    if {$attnDirection == "up"} {

        # Update the rampdown no beacon list. List will be integers GE 0.
        if {![regexp -nocase {BEACONS} $::rejoin_old_state]} {
            lappend ::rvr_rampdown_no_beacons_list $step
        }

        # In some cases, we always keep testing.
        if {$fullrange == "1" || $::rvr_rampdown_nobeacons <= 0} {
            return no
        }

        # Should we stop the rampdown test?
        set val [UTF::find_consecutive_values "$::rvr_rampdown_no_beacons_list"\
            $::rvr_rampdown_nobeacons forward end $attnstep]
        if {$val != ""} {
            UTF::Message LOG "$::localhost" "monitor_beacons\
                stopping the rampdown test, found $::rvr_rampdown_nobeacons no beacon steps,\
                attnstep=$attnstep rvr_rampdown_no_beacons_list=$::rvr_rampdown_no_beacons_list\
                val=$val"
            UTF::Try "monitor_beacons stopping rampdown test" {
                return "$::rvr_rampdown_nobeacons no beacons at attenuator: $::rvr_rampdown_no_beacons_list"
            }
            return yes
        } else {
            return no
        }

    } else {
        # Rampup / attenuator down case
        # Update the rampup no beacon list. List will be integers GE 0.
        if {![regexp -nocase {BEACONS} $::rejoin_old_state]} {
            lappend ::rvr_rampup_no_beacons_list $step
        }
        return no
    }
}

#============== proc monitor_rampup_issues ==========================
# Returns yes if there is a severe rejoin / rampup issue and the
# user requested we stop on this condition.
#====================================================================
proc monitor_rampup_issues {tput_mean step attnDirection\
    fullrampup stopslowrampup} {

    UTF::Message LOG "$::localhost" "monitor_rampup_issues tput_mean=$tput_mean\
        step=$step attnDirection=$attnDirection fullrampup=$fullrampup\
        stopslowrampup=$stopslowrampup"

    # If user wanted fullrampup, regardless of issues, we are done. For the short
    # term, if user did not specify either option, the default is fullrampup.
    if {$fullrampup == "1" || ($fullrampup == "0" && $stopslowrampup == "0")} {
        return no
    }

    # If either control parameter is LE 0, we are done.
    if {$::rvr_slowrampup_cnt <= 0 || $::rvr_slowrampup_tput <= 0} {
        return no
    }

    # For the rampdown / attenuator up portion of the test, we save the 
    # last N attenuator steps where the thruput is GT >= ::rvr_slowrampup_tput
    if {$attnDirection == "up"} {
        if {$tput_mean >= $::rvr_slowrampup_tput} {
            lappend ::monitor_rampdown_steps $step
            # Save the most recent N=::rvr_slowrampup_cnt steps
            set len [llength $::monitor_rampdown_steps]
            set end [expr $len - 1]
            set start [expr $end - $::rvr_slowrampup_cnt + 1] 
            set ::monitor_rampdown_steps [lrange $::monitor_rampdown_steps $start $end]
        }
        UTF::Message LOG "$::localhost" "monitor_rampup_issues\
            ::monitor_rampdown_steps=$::monitor_rampdown_steps"
        return no
    }
    
    # For rampup / attenuator down portion of the test, we count the steps
    # where the thruput is GE the threshold value.
    if {$tput_mean >= $::rvr_slowrampup_tput} {
        incr ::monitor_rampup_good_tput_cnt
    }

    # The stop step for the slow rejoin / rampup test is the first attenuator
    # step in the ::monitor_rampdown_steps list. This is smallest of the last N
    # attenuation steps where the tput was GT 0 on the rampdown.
    set stop_step [lindex $::monitor_rampdown_steps 0]

    # On the rampup test, when we get to the stop_step, we had better have
    # at least one good thruput result, or we shut down the rampup test.
    if {$step <= $stop_step && $::monitor_rampup_good_tput_cnt == "0"} {
        UTF::Try "monitor_rampup_issues stopping rampup test" {
            error "no tput GE $::rvr_slowrampup_tput at Attn: $stop_step"
        } 
        return yes
    } else {
        UTF::Message LOG "$::localhost" "monitor_rampup_issues\
            stop_step=$stop_step ::monitor_rampup_good_tput_cnt=$::monitor_rampup_good_tput_cnt"
        return no
    }
}

#============== proc monitor_rates ==================================
# Keeps track of MCS / Legacy rates in global variables.
#
# Returns: nothing
#====================================================================
proc monitor_rates {STA step attnDirection} {

    # Get data left for us by UTF::sta_stats routine.
    set temp "::${STA}_rate"
    if {![info exists $temp]} {
        UTF::Message WARN "$STA" "monitor_rates no info for: $temp"
        return
    }
    set val [set $temp]
    UTF::Message LOG "$STA" "monitor_rates step=$step\
        attnDirection=$attnDirection val=$val"
    set $temp "" ;# wipe the current value

    # Keep separate rate lists for rampdown vs rampup.
    if {$attnDirection == "up"} {
        # Rampdown / Attn up 
        lappend ::rvr_rampdown_rates_list "$step $val"
    } else {
        # Rampup / Attn down
        lappend ::rvr_rampup_rates_list "$step $val"
    }
    return ""
}

#============== proc overall_timeout ================================
# Returns yes if we have exceeded overall test time allocated.
#====================================================================
proc overall_timeout {keepgoing routerConfig direction} {

    # User may override timer with -keepgoing option.
    if {$keepgoing} {
        return no
    }

    # NB: Dont force framework to halt tests here. We still need to
    # plot graphs for the incomplete data that we did collect.
    if {$::rvr_overall_timeout_min > 0} {
        set overall_min [expr (double([clock seconds] - $::rvr_overall_start_sec)) / 60]
        set overall_min [format "%.1f" $overall_min]
        UTF::Message LOG "$::localhost" "overall_timeout overall_min=$overall_min"
        if {$overall_min > $::rvr_overall_timeout_min} {
            UTF::Try "$routerConfig $direction RvR test overall timeout after $overall_min min" {
                error "halting tests after $overall_min min!" 
            }
            return yes
        }
    }
    return no
}

#============== proc plot_graphs ====================================
# Plots the RvR graphs
#====================================================================
proc plot_graphs {file name legend focus AP STA routerConfig direction type arrow plot_graph_ctl\
    nohistograms rampdownonly sta_mfc nomalloc chanint fastrampup nosymmetry udp is_oem_ap\
    nographs mingraphs intsta intgraph chanspec} {

    UTF::Message LOG "$::localhost" "plot_graphs file=$file name=$name legend=$legend\
        focus=$focus AP=$AP STA=$STA direction=$direction type=$type arrow=$arrow\
        plot_graph_ctl=$plot_graph_ctl nohistograms=$nohistograms rampdownonly=$rampdownonly\
        sta_mfc=$sta_mfc nomalloc=$nomalloc chanint=$chanint fastrampup=$fastrampup\
        nosymmetry=$nosymmetry udp=$udp is_oem_ap=$is_oem_ap\
        nographs=$nographs mingraphs=$mingraphs intsta=$intsta intgraph=$intgraph chanspec=$chanspec"

    # Sometimes graphs are not needed.
    if {$nographs} {
        return
    }

    # Define gnuplopt style values to use. See gnuplot manual for more
    # details of parameters.
    set lt0 0 ;# line type 0 - dashed grey
    set lt1 1 ;# line type 1 - solid light red
    set lt2 2 ;# line type 2 - solid light green
    set lt3 3 ;# line type 3 - solid light blue
    set lt4 4 ;# line type 4 - solid light purple
    set lt5 5 ;# line type 5 - solid aqua
    set lt6 6 ;# line type 6 - solid brown
    set lt7 7 ;# line type 7 - solid yellow
    set lt8 8 ;# line type 8 - solid dark blue
    set lt9 9 ;# line type 9 - solid gold
    set lt10 10 ;# line type 10 - solid dark green
    set lt11 11 ;# line type 11 - solid dark purple
    set lt12 12 ;# line type 12 - solid dark brown
    set lt13 13 ;# line type 13 - solid light pink
    set lt14 14 ;# line type 14 - solid lime green
    set lt15 15 ;# line type 15 - solid grey blue
    set lt154 154 ;# line type 154 - solid orange

    set lw1 1 ;# line width 1 point
    set lw2 2 ;# line width 2 points
    set pt0 0 ;# point type 0 - none
    set pt1 1 ;# point type 1 - horizontal bar
    set pt7 7 ;# point type 7 - open box 
    set ps0 0 ;# point size 0 - none
    set ps1 1 ;# point size 1 - smallest

    # Common Thruput CSV fields
    set tput_mean [find_csv_column TputMean]
    set tput_min [find_csv_column TputMin]
    set tput_max [find_csv_column TputMax]
    set lower_ctl [find_csv_column LowerControlLimit] 
    set upper_ctl [find_csv_column UpperControlLimit]
    set ap_assoc_authen [find_csv_column ApAssocAuthen]
    set sta_assoc_beacon [find_csv_column StaBeaconAssoc]

    # Ylabels for 11AC VHT rate histograms
    set vht_ylabel "'1x0' 0, '1x5' 5, '1x9' 9, '2x0' 10, '2x5' 15, '2x9' 19, '3x0' 20, '3x5' 25, '3x9' 29"

    # Palette for CCDF histograms
    set ccdf_palette "\( 0 \"black\", 0.00001 \"purple\", 0.2 \"blue\", 0.4 \"green\", 0.6 \"red\", 0.8 \"yellow\", 1 \"white\"\)"

    # Add test numbers to graphic names, so they are sorted properly
    # in the summary directory. This also ensures uniqueness when multiple
    # STA are tested in the same testrun. Each STA will have graphs with
    # numbers unique to that test section.
    set name "[UTF::get_testnum]_${name}"

    # Set Y-Axis transport type.
    if {$udp > 0} {
        set transport UDP
    } else {
        set transport TCP
    }

    # Only do the rampdown graph once, includes control limits.
    if {$plot_graph_ctl == "0" || $rampdownonly == "1"} {
        UTF::Try "$routerConfig $direction Performance Test Rampdown Throughput Graph $arrow" {
            set graph [UTF::gnuplot_rvr_lines "$file"\
                "${name}RampdownThroughput" "$::testrig $AP<=>$STA Ch=$chanspec" $direction\
                "Throughput $transport (Mbit/sec)" $type\
                [list linespoints "" $upper_ctl $lt2 $lw1 $pt0 $ps0\
                      errorlines  "" $tput_mean $lt1 $lw1 $pt1 $ps1\
                      linespoints "" $lower_ctl $lt2 $lw1 $pt0 $ps0\
                      linespoints StaBeaconAssoc $sta_assoc_beacon $lt3 $lw1 $pt0 $ps0\
                      linespoints ApAssocAuthen  $ap_assoc_authen  $lt8 $lw1 $pt0 $ps0] rampdown]
            set ::rvr0 $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }

        # Dont do any other graphs for plot_graph_ctl=0. They will be done
        # after the rampup data is available, plot_graph_ctl>0.
        if {$plot_graph_ctl == "0"} {
            return 
        }
    }

    # Show full throughput rampdown/rampup graph, includes control limits.
    if {$fastrampup == 0 } {
        set fr ""
    } else {
        set fr fastrampup
    }
    if {$rampdownonly == "0"} {
        UTF::Try "$routerConfig $direction Performance Test RampdownRampup Throughput Graph $arrow" {
            set graph [UTF::gnuplot_rvr_lines "$file"\
            "${name}RampdownRampupThroughput" "$::testrig $AP<=>$STA Ch=$chanspec" $direction\
                "Throughput $transport (Mbit/sec)" $type\
                [list linespoints "" $upper_ctl $lt2 $lw1 $pt0 $ps0\
                      errorlines  "" $tput_mean $lt1 $lw1 $pt1 $ps1\
                      linespoints "" $lower_ctl $lt2 $lw1 $pt0 $ps0\
                      linespoints StaBeaconAssoc $sta_assoc_beacon $lt3 $lw1 $pt0 $ps0\
                      linespoints ApAssocAuthen  $ap_assoc_authen  $lt8 $lw1 $pt0 $ps0] $fr]
            set ::aci1fidha $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }
    }

    if {$mingraphs} {
        return
    }

    # Show symmetry throughput graph.
    if {$rampdownonly == "0" && $fastrampup == "0" && $nosymmetry == 0} {
        UTF::Try "$routerConfig $direction Performance Test Symmetry Throughput Graph $arrow" {
            #set temp "Rampup $legend $focus"
            set file_sym [UTF::rvr_symmetry_test $file $tput_mean $tput_min $tput_max\
                $lower_ctl $upper_ctl]
            set graph [UTF::gnuplot_rvr_lines "$file_sym"\
                "${name}SymmetryThroughput" "$::testrig Symmetry $AP<=>$STA Ch=$chanspec" $direction\
                "Throughput $transport (Mbit/sec)" $type\
                [list linespoints "" 5 $lt2 $lw1 $pt0 $ps0\
                      errorlines  "" 6 $lt1 $lw1 $pt1 $ps1\
                      linespoints "" 4 $lt2 $lw1 $pt0 $ps0\
                      linespoints SymmetryErrors 11 $lt13 $lw2 $pt0 $ps0] $fr]
            set ::rvr2 $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }
    }

    # These graphs apply only to BRCM AP, not to OEM AP.
    if {$is_oem_ap == "0"} {
        # Show common AP graphs.
        set graph_data [list ::RVR3 ApMcs "MCS Rate (Index #)"\
            ::RVR4 ApTxRate "Rate (Mbit/sec)" ::RVR5 ApConnectTime "Connection time (sec)"\
	    ::RVR50 ApPktRetried "Packets (#)" ::RVR50A ApPktRetryRatio "Percent (%)"\
	    ::RVR51 ApPktRetryDropped  "Packets (#)" ::RVR51A ApPktRetryDropRatio "Percent (%)"\
	    ::RVR52 ApTxbfm "Steered Frames (#)" ::RVR53 ApTxndp "Sounding Frames (#)" ::RVR54 ApSfRatio "Percent (%)"]
        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {
                set col [find_csv_column $field]
		if {$field == "ApTxndp"} {
		    set col2 [find_csv_column ApRxsf]
                    set graph [UTF::gnuplot_rvr_lines "$file"\
                    	"${name}${field}" "$::testrig $field+ApRxsf $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
                    	[list linespoints ApTxndp $col  $lt1 $lw1 $pt7 $ps1\
			      linespoints ApRxsf  $col2 $lt3 $lw1 $pt7 $ps1] $fr]
		} elseif {$field == "ApMcs"} {
		    # Add ApNss and ApBw to ApMcs to create combo graph.
		    set col2 [find_csv_column ApNss]
		    set col3 [find_csv_column ApBw]
		    set graph [UTF::gnuplot_rvr_lines "$file"\
			"${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
			[list linespoints Mcs $col  $lt1 $lw1 $pt7 $ps1\
			      linespoints Bw  $col3 $lt5 $lw1 $pt7 $ps1\
			      linespoints Nss $col2 $lt8 $lw1 $pt7 $ps1] $fr]
		} else {
                    set graph [UTF::gnuplot_rvr_lines "$file"\
                    	"${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
                    	[list linespoints "" $col $lt1 $lw1 $pt7 $ps1] $fr]
		}
                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                return "html:<img src=\"$graph\">"
            }
        }
    }
    
    # Show common STA Graphs
    set graph_data [list ::RVR55 StaMcs "MCS Rate (Index #)" ::RVR6 StaRssi "RSSI (dB)" ::RVR7 StaTxRate "Rate (Mbit/sec)" ::RVR39 TputMean "Rate (Mbit/sec)"]
    if {!$nomalloc} {
        lappend graph_data ::RVR8 StaMallocFail "Malloc Fail (count)"
    }
    if {$chanint} {
        lappend graph_data ::RVR9 StaChanInt "STA Channel (number)"
    }
    foreach {handle field ytitle} $graph_data {
        UTF::Try "$routerConfig $direction $field $arrow" {
            set col [find_csv_column $field]
            set option ""
            if {$field == "StaRssi"} {
                set option zerosuppress
            }
            # set is_oem_ap 1 ;# test code
            if {$is_oem_ap == "0" && $field == "StaRssi"} {
                # Add the AP RSSI info to STA RSSI info for a combo graph.
                set col2 [find_csv_column ApRssi]
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field+ApRssi $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
                    [list linespoints $STA $col  $lt1 $lw1 $pt7 $ps1\
                     	  linespoints $AP  $col2 $lt3 $lw1 $pt7 $ps1] zerosuppress $fr]
	    } elseif {$is_oem_ap == "0" && $field == "StaMcs"} {
		# Add StaNss and StaBw to StaMcs to create combo graph.
		set col2 [find_csv_column StaNss]
		set col3 [find_csv_column StaBw]
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
                    [list linespoints Mcs $col  $lt1 $lw1 $pt7 $ps1\
		    	  linespoints Bw  $col3 $lt5 $lw1 $pt7 $ps1\
                    	  linespoints Nss $col2 $lt8 $lw1 $pt7 $ps1] zerosuppress $fr]
            } else {
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction "$ytitle" $type\
                    [list linespoints "" $col $lt1 $lw1 $pt7 $ps1] $option $fr]
            }
            set var [string tolower $handle]
            set $var $graph ;# for calling routine
            return "html:<img src=\"$graph\">"
        }
    }

    # For BRCM AP show histograms
    if {!$nohistograms && $is_oem_ap == "0"} {
        set graph_data [list ::RVR10 ApRxMcs "MCS Rate (Index #)"\
            ::RVR11 ApTxMcs "MCS Rate (Index #)" ::RVR12 ApMpdu "MPDU Density"\
            ::RVR13 ApRxMcsSgi "MCS Rate (Index #)" ::RVR14 ApTxMcsSgi "MCS Rate (Index #)"\
            ::RVR15 ApDelay "Delay (milli-seconds)" ::RVR16 ApCcdf "Delay (milli-seconds)"\
            ::RVR17 ApPer PER ::RVR30 ApRxVht "VHT Rate" ::RVR31 ApTxVht "VHT Rate"\
            ::RVR32 ApRxVhtSgi "VHT Rate" ::RVR33 ApTxVhtSgi "VHT Rate" ::RVR33A ApVhtPer PER]
        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {
                set col [find_csv_column $field]
                if {$field == "ApCcdf"} {
                    # ApCcdf uses special palette & scale 
                    set ::gnuplot_rvr_palette $ccdf_palette
                    set option logscale
                } else {
                    set option normalize
                }
                if {[regexp -nocase {Vht} $field]} {
                    # Vht uses special list of y-axis labels
                    set ::gnuplot_rvr_ylabel $vht_ylabel
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction\
                    "$ytitle" $type\
                    [list image "" $col $lt1 $lw1 $pt0 $ps0] $option $fr]
                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                catch "unset ::gnuplot_rvr_palette"
                catch "unset ::gnuplot_rvr_ylabel"
                return "html:<img src=\"$graph\">"
            }
        }
    }
    
    # Show STA histograms.
    if {!$nohistograms} {
        set graph_data [list ::RVR20 StaRxMcs "MCS Rate (Index #)"\
            ::RVR21 StaTxMcs "MCS Rate (Index #)" ::RVR22 StaMpdu "MPDU Density"\
            ::RVR23 StaRxMcsSgi "MCS Rate (Index #)" ::RVR24 StaTxMcsSgi "MCS Rate (Index #)"\
            ::RVR25 StaDelay "Delay (milli-seconds)" ::RVR26 StaCcdf "Delay (milli-seconds)"\
            ::RVR27 StaPer PER ::RVR34 StaRxVht "VHT Rate" ::RVR35 StaTxVht "VHT Rate"\
            ::RVR36 StaRxVhtSgi "VHT Rate" ::RVR37 StaTxVhtSgi "VHT Rate" ::RVR38 StaVhtPer PER]
        foreach {handle field ytitle} $graph_data {
            UTF::Try "$routerConfig $direction $field $arrow" {
                set col [find_csv_column $field]
                if {$field == "StaCcdf"} {
                    # StaCcdf uses special palette & scale
                    set ::gnuplot_rvr_palette $ccdf_palette
                    set option logscale
                } else {
                    set option normalize
                }
                if {[regexp -nocase {Vht} $field]} {
                    # Vht uses special list of y-axis labels
                    set ::gnuplot_rvr_ylabel $vht_ylabel
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction\
                    "$ytitle" $type\
                    [list image "" $col $lt1 $lw1 $pt0 $ps0] $option $fr]
                set var [string tolower $handle]
                set $var $graph ;# for calling routine
                catch "unset ::gnuplot_rvr_palette"
                catch "unset ::gnuplot_rvr_ylabel"
                return "html:<img src=\"$graph\">"
            }
        }
    }   

    # Do we want the interference count graphs?
    if {$intsta != "" || $intgraph == 1} {
        # set is_oem_ap 1 ;# test code
        if {$is_oem_ap == "0"} {
            set graph_data [list ::RVR40 ApRxBadFcs ::RVR41 ApRxBadPlcp ::RVR42 ApRxCrsGlitch\
            ::RVR43 ApRxdFrmUcastMbss ::RVR44 ApRxStrt\
            ::RVR45 StaRxBadFcs ::RVR46 StaRxBadPlcp ::RVR47 StaRxCrsGlitch\
            ::RVR48 StaRxdFrmUcastMbss ::RVR49 StaRxStrt]
        } else {
            set graph_data [list ::RVR45 StaRxBadFcs ::RVR46 StaRxBadPlcp ::RVR47 StaRxCrsGlitch\
            ::RVR48 StaRxdFrmUcastMbss ::RVR49 StaRxStrt]
        }
        foreach {handle field} $graph_data {
            UTF::Try "$routerConfig $direction Performance Test $field $arrow" {
                set col [find_csv_column $field]
                if {[regexp -nocase {^Ap} $field]} {
                    set dev $AP
                } else {
                    set dev $STA
                }
                set graph [UTF::gnuplot_rvr_lines "$file"\
                    "${name}${field}" "$::testrig $field $AP<=>$STA Ch=$chanspec" $direction\
                    "Delta Count / Step" $type\
                    [list linespoints $dev $col $lt1 $lw1 $pt7 $ps1] $fr]
                set var [string tolower $handle] ;# global variable corresponding to the handle
                set $var $graph ;# for calling routine
                return "html:<img src=\"$graph\">"
            }
        }
    }
    return 
}

#============== proc rate_adapt_cc ==================================
# Produces separate control charts for MCS/Legacy rates.
#
# Puts 4 control charts on the summary web page.
#====================================================================
proc rate_adapt_cc {STA LAN routerConfig direction history key_template readonly\
    udp focus chanspec attnstep fastrampup} {

    # Do 2 rate adaptation control charts as one result. Repeat for Hi & Low values.
    # We have separate lists of attn/rate pairs for rampdown & rampup.
    # For Hi, we want the last hi rates from either end of the RvR curve
    # For Lo, we want the first lo rates from the centre of the RvR curve
    # For Hi & fastrampup, need inc2=0, not attnstep.
    if {$fastrampup} {
        set inc2_hi 0
    } else {
        set inc2_hi $attnstep
    }
    foreach {handle desc dir1 ind1 inc1 dir2 ind2 inc2} \
        "::rvrb StaMcsHi forward end $attnstep reverse end $inc2_hi\
        ::rvrc StaMcsLo reverse end -$attnstep forward end -$attnstep" {
        UTF::Try "$STA $routerConfig $direction $desc" {

            # Initialization
            UTF::Message LOG "$::localhost" "handle=$handle desc=$desc dir1=$dir1 ind1=$ind1\
                inc1=$inc1 dir2=$dir2 ind2=$ind2 inc2=$inc2"
            set $handle "" ;# variable to pass controlchart pathnames back
            # Set Y-Axis title
            if {$udp > 0} {
                set xport UDP
            } else {
                set xport TCP
            }
            set title1 "$::testrig $::int_desc ${desc}Down $xport $routerConfig Ch=$chanspec $focus $direction"
            set title2 "$::testrig $::int_desc ${desc}Up $xport $routerConfig Ch=$chanspec $focus $direction"

            # Rampdown rate adapation CC. dir1 & ind1 are used to choose value.
            regsub -nocase "AttnUp" $key_template "" key_template
            regsub -nocase "\{step\}" $key_template "${desc}Down" keys
            set val [UTF::find_consecutive_values "$::rvr_rampdown_rates_list"\
                $::rvr_rate_cnt $dir1 $ind1 $inc1]
            set catch_resp1 0
            set catch_msg1 ""
            if {$val != ""} {
                puts "keys=$keys val=$val"
                set catch_resp1 [catch "UTF::update_control_chart_data \"$keys\" \"$val\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction 1 $history \"$title1\" \"dB\" \"Attenuation\"" catch_msg1]
                lappend $handle $::uccd_png_path ;# save first CC graphic
                save_results $STA $LAN "$keys" $routerConfig $chanspec $direction "${desc}Down" $val
            }

            # Rampup rate adaptation CC. dir2 & ind2 are used to choose value.
            regsub -nocase "\{step\}" $key_template "${desc}Up" keys
            set val [UTF::find_consecutive_values "$::rvr_rampup_rates_list"\
                $::rvr_rate_cnt $dir2 $ind2 $inc2]
            set catch_resp2 0
            set catch_msg2 ""
            if {$val != ""} {
                puts "keys=$keys val=$val"
                set catch_resp2 [catch "UTF::update_control_chart_data \"$keys\" \"$val\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction 1 $history \"$title2\" \"dB\" \"Attenuation\"" catch_msg2]
                lappend $handle $::uccd_png_path ;# save second CC graphic
                save_results $STA $LAN "$keys" $routerConfig $chanspec $direction "${desc}Up" $val
            }

            # Massage into one composite result.
            regsub {^html:} $catch_msg1 "" catch_msg1
            regsub {^html:} $catch_msg2 "" catch_msg2
            set result "html: <b>${desc}Down</b> $catch_msg1 <br><b>${desc}Up</b> $catch_msg2"
            if {$catch_resp1 == 0 && $catch_resp2 == 0} {
                return $result
            } else {
                error $result
            }
        }
    }
}

#============== proc refresh_addr ===================================
# After reassociation, refreshes STA ip address.
#
# returns null
#====================================================================
proc refresh_addr {STA reassoc refreshaddralways refreshaddrasneeded i routerConfig direction loss} {

    # Some devices may need IP address refreshed at this point.
    set sta_name [UTF::get_name $STA]
    UTF::Message LOG "$sta_name" "refresh_addr loss=$loss reassoc=$reassoc \
        refreshaddralways=$refreshaddralways\
        refreshaddrasneeded=$refreshaddrasneeded i=$i\
        ::refresh_addr=$::refresh_addr"
    if {$refreshaddralways == 0 && $refreshaddrasneeded == 0} {
        return
    }

    # Change state as appropriate.
    if {($reassoc == 1 && $refreshaddrasneeded == 1) ||\
        $refreshaddralways == 1} {
        set ::refresh_addr "NEEDED"
    }
    if {$::refresh_addr != "NEEDED"} {
        return
    }

    # Some devices may need IP address refreshed at this point.
    UTF::Try "$routerConfig $direction Loss: $loss $STA refresh IP address after rejoin ($i)" {
        set ip [$STA cget -ipaddr]
        UTF::Message LOG "$sta_name" "refresh_addr reassoc=$reassoc \
            refreshaddralways=$refreshaddralways\
            refreshaddrasneeded=$refreshaddrasneeded i=$i\
            ::refresh_addr=$::refresh_addr"
        set new_addr [$STA ifconfig $ip]
        set ::refresh_addr "DONE"
        UTF::Message LOG "$sta_name" "refresh_addr ::refresh_addr=$::refresh_addr new_addr=$new_addr"
        return $new_addr
    }
}

#============== proc rejoin =========================================
# Rejoins connection as needed. Add web page entries when we lose
# beacons and/or association and when we regain beacons and/or 
# association.
#
# returns 1 when STA is re-associated.
#====================================================================
proc rejoin {apSsid STA step pathloss noredundant refreshaddralways refreshaddrasneeded\
    routerConfig direction is_oem_ap chanspec} {

    # If STA is known to be in trouble, return.
    set var "::${STA}_state"
    if {[set $var] != "OK"} {
        #UTF::Message LOG "$::localhost" "rejoin sta_state=[set $var]"
        return
    }

    # Some people really want to have this redundant call made to preserve timing.
    set sta_name [UTF::get_name $STA]
    if {$noredundant == "0"} {
        # Get beacon & association state info. Uses same logic as
        # proc UTF::sta_stats
        set catch_msg ""
        set catch_resp [catch "$STA wl assoc" catch_msg]
        UTF::save_device_state $STA $catch_msg
        set curr_state "NULL"
        if {[regexp -nocase {not.*associated} $catch_msg]} {
            set curr_state ROAMING
        } elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $catch_msg]} {
            set curr_state ASSOCIATED ;# but no beacons
        } elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $catch_msg]} {
            set curr_state "ASSOCIATED BEACONS"
        }

    } else {
        # UTF::sta_stats leaves the STA assoc info for us.
        set temp "::${STA}_assoc"
        if {![info exists $temp]} {
            set $temp "NULL"
        }
        set curr_state [set $temp]
        set temp "::${STA}_msg"
        if {![info exists $temp]} {
            set $temp ""
        }
        set catch_msg [set $temp]
        UTF::Message LOG "$sta_name" "duplicated msg from sta_stats: $catch_msg"
    }
    set loss [expr $step + $pathloss]
    UTF::Message LOG "$::localhost" "rejoin step=$step loss=$loss\
        ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid\
        noredundant=$noredundant refreshaddralways=$refreshaddralways\
        refreshaddrasneeded=$refreshaddrasneeded routerConfig=$routerConfig\
        direction=$direction is_oem_ap=$is_oem_ap chanspec=$chanspec"

    # Push the state change onto the main web page.
    set reassoc ""
    if {$curr_state != $::rejoin_old_state} {
        UTF::Try "$routerConfig $direction $::aux_desc STA state change: $::rejoin_old_state --> $curr_state" {
            UTF::Message LOG "$::localhost" "rejoin step=$step loss=$loss\
                ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid\
                noredundant=$noredundant"
            UTF::Message LOG "$sta_name" "duplicated msg: $catch_msg"
            set chan [$STA wl chanspec]  
            return $chan
        }

        # Did we reassociate?
        if {$::rejoin_old_state == "ROAMING" && [regexp {ASSOCIATED} $curr_state]} {
            set reassoc 1
        }
    }

    # Refresh addr as needed
    refresh_addr $STA $reassoc $refreshaddralways $refreshaddrasneeded 1 $routerConfig $direction $loss 

    # If STA is associated, with/without beacons, then we are done.
    set ::rejoin_old_state $curr_state
    if {[regexp {ASSOCIATED} $curr_state]} {
        return $reassoc
    }

    # STA is NOT associated, so try to join. 
    for {set i 1} {$i <= $::rvr_rejoin_tries} {incr i} {
        # Join if STA is OK.
        if {[set $var] != "OK"} {
            return
        }
        UTF::Message LOG "$::localhost" "rejoin Try#$i"
        set catch_msg ""
        if {$is_oem_ap == 0} {
            set catch_resp [catch "$STA wl join $apSsid" catch_msg]
        } else {
            # Some OEM AP will broadcast the same SSID on both bands simultaneously.
            # So we need to specify which channel / band to use.
            set catch_resp [catch "$STA wl join $apSsid --chanspec=$chanspec" catch_msg]
        }
        UTF::save_device_state $STA $catch_msg
        UTF::Sleep $::rvr_rejoin_wait_sec
        if {[set $var] != "OK"} {
            return
        }

        # Parse for association & beacon state. Uses same logic as
        # proc UTF::sta_stats
        set catch_msg ""
        set catch_resp [catch "$STA wl assoc" catch_msg]
        UTF::save_device_state $STA $catch_msg
        set curr_state "NULL"
        if {[regexp -nocase {not.*associated} $catch_msg]} {
            set curr_state ROAMING
        } elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $catch_msg]} {
            set curr_state ASSOCIATED ;# but no beacons
        } elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $catch_msg]} {
            set curr_state "ASSOCIATED BEACONS"
        }

        # If assocated, with/without beacons, push the state change onto the main web page.
        # set curr_state "ASSOCIATED BEACONS";# test code
        if {[regexp {ASSOCIATED} $curr_state]} {
            UTF::Try "$routerConfig $direction $::aux_desc STA state change: $::rejoin_old_state --> $curr_state Try#$i" {
                UTF::Message LOG "$::localhost" "rejoin step=$step loss=$loss\
                    ::rejoin_old_state=$::rejoin_old_state curr_state=$curr_state apSsid=$apSsid"
                UTF::Message LOG "$sta_name" "duplicated msg $catch_msg"
                set chan [$STA wl chanspec]  
                return $chan
            }
            set ::rejoin_old_state $curr_state

            # Support for -post_assoc_hook
            if {[$STA cget -post_assoc_hook] ne ""} {
                UTF::Message LOG "$STA" "running -post_assoc_hook"
                eval [string map [list %S $STA] [$STA cget -post_assoc_hook]]
            }

            # Some devices may need IP address refreshed at this point.
            refresh_addr $STA 1 $refreshaddralways $refreshaddrasneeded 2 $routerConfig $direction $loss
            return 1 ;# let calling routine know we have now successfully reassociated.
        }
    }

    # One (or more) join attempts failed. That happens all the time with 
    # high attenuation. Nothing more to do here.
    return
}

#============== proc rejoin_cc ======================================
# Produces separate control charts for rejoin attn & tput values.
#
# Puts 2 control chart on the summary web page.
#====================================================================
proc rejoin_cc {STA LAN routerConfig direction history key_template readonly\
    udp focus chanspec} {

    # For rampdownonly, there wont be any result data.
    set ::rejoin_cc_result ""
    set ::rvra "" ;# variable to pass controlchart pathnames back
    if {$::rvr_rejoin_result == ""} {
        return
    }

    # Parse rejoin results
    set attn [lindex $::rvr_rejoin_result 0]
    set size1 1 ;# make sure we always use MemChart, not ControlChart
    set tput [lrange $::rvr_rejoin_result 1 end]
    set size2 [llength $tput]
    if {$size2 < 2} {
        set size2 2 ;# make sure we always use ControlChart, not MemChart
    }
     puts "attn=$attn size1=$size1 tput=$tput size2=$size2"

    # Do 2 control charts as one result.
    UTF::Try "$STA $routerConfig $direction Rejoin" {

        # Set Y-Axis title
        if {$udp > 0} {
            set xport UDP
        } else {
            set xport TCP
        }
        set title1 "$::testrig $::int_desc Rejoin Attn $xport $routerConfig Ch=$chanspec $focus $direction"
        set title2 "$::testrig $::int_desc Rejoin Tput $xport $routerConfig Ch=$chanspec $focus $direction"

        # Attn CC
        regsub -nocase "AttnUp" $key_template "AttnDown" key_template
        regsub -nocase "\{step\}" $key_template "RejoinAttn" keys
        # puts "keys=$keys"
        set catch_resp1 [catch "UTF::update_control_chart_data \"$keys\" \"$attn\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction $size1 $history \"$title1\" \"dB\" \"Attenuation\"   " catch_msg1]
        lappend ::rvra $::uccd_png_path ;# save first CC graphic

        # Tput CC
        regsub -nocase "\{step\}" $key_template "RejoinTput" keys
        # puts "keys=$keys"
        set catch_resp2 [catch "UTF::update_control_chart_data \"$keys\" \"$tput\" $readonly CC \"ZERO|LOW|WIDE|HIGH\" $STA $LAN $direction $size2 $history \"$title2\" \"Mbit/sec\" \"Throughput $xport\"" catch_msg2]
        lappend ::rvra $::uccd_png_path ;# save second CC graphic

        # Massage into one composite result.
        regsub {^html:} $catch_msg1 "" catch_msg1
        regsub {^html:} $catch_msg2 "" catch_msg2
        set ::rejoin_cc_result "html: <b>RejoinAttn</b> $catch_msg1 <br><b>RejoinTput</b> $catch_msg2"
        if {$catch_resp1 == 0 && $catch_resp2 == 0} {
            return $::rejoin_cc_result
        } else {
            error $::rejoin_cc_result
        }
    }
}

#============== proc rename_perfcache_file ==========================
# Transition aid to rename old format perfcache data files.
#
# Not used anymore.
#====================================================================
proc rename_perfcache_file {old_keys new_keys STA LAN direction stream} {
    UTF::Message LOG "$::localhost" "rename_perfcache_file old_keys=$old_keys\
        new_keys=$new_keys STA=$STA LAN=$LAN direction=$direction stream=$stream"
    return ;# not used anymore

    # Define file names of perfcache files.
    set perfcache [file dirname "$UTF::Logfile"]
    set perfcache [file dirname "$perfcache"]
    set perfcache "$perfcache/perfcache"
    if {$direction == "Upstream"} {
        set old_file "$old_keys \{$STA $LAN\}.data"
        set new_file "$new_keys \{$STA $LAN\}.data"
    } else {
        set old_file "$old_keys \{$LAN $STA\}.data"
        set new_file "$new_keys \{$LAN $STA\}.data"
    }
    # puts "rename_perfcache_file \nold_file=$old_file \nnew_file=$new_file"

    # Try to locate new perfcache data file. If new one exists 
    # already, we leave any old one alone.
    if {[file exists "$perfcache/$new_file"]} {
        UTF::Message LOG "$::localhost" "rename_perfcache_file found new: $new_file"
    } else {
        UTF::Message LOG "$::localhost" "rename_perfcache_file NOT found new: $new_file"

        # If old perfcache data file exists, rename it to new format.
        if {[file exists "$perfcache/$old_file"]} {
            UTF::Message LOG "$::localhost" "rename_perfcache_file found old: $old_file\
                renaming to new: $new_file"
            set catch_resp [catch "file rename -force \"$perfcache/$old_file\" \
                \"$perfcache/$new_file\"" catch_msg]
            if {$catch_resp != 0} {
                UTF::Message ERROR "$::localhost" "rename_perfcache_file\
                    catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        } else {
            UTF::Message LOG "$::localhost" "rename_perfcache_file NOT found old: $old_file"
        }
    }

    # Now we deal with the issue of stream being "---"
    if {$stream == "---"} {
        return
    }

    # If we have an existing data file with stream "---", we rename it.
    regsub $stream $new_keys "---" temp_keys
    if {$direction == "Upstream"} {
        set old_file "$temp_keys \{$STA $LAN\}.data"
    } else {
        set old_file "$temp_keys \{$LAN $STA\}.data"
    }
    if {[file exists "$perfcache/$new_file"]} {
        UTF::Message LOG "$::localhost" "rename_perfcache_file found new: $new_file"
    } else {
        UTF::Message LOG "$::localhost" "rename_perfcache_file NOT found new: $new_file"

        # If old perfcache data file exists, rename it to new format.
        if {[file exists "$perfcache/$old_file"]} {
            UTF::Message LOG "$::localhost" "rename_perfcache_file found old: $old_file\
                renaming to new: $new_file"
            set catch_resp [catch "file rename -force \"$perfcache/$old_file\" \
                \"$perfcache/$new_file\"" catch_msg]
            if {$catch_resp != 0} {
                UTF::Message ERROR "$::localhost" "rename_perfcache_file\
                    catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        } else {
            UTF::Message LOG "$::localhost" "rename_perfcache_file NOT found old: $old_file"
        }
    }
    return
}

#============== proc rvr_symmetry_control_charts ====================
# Does control chart tests of rampup data against the rampdown 
# perfcache data.
#====================================================================
proc rvr_symmetry_control_charts {attnDirection key_template STA LAN direction\
    arrow pathloss csv_file rampdown_attn_range start_rampup_step attnstep\
    iperf_sample_size zero_samples history fastrampup routerConfig} {

    # Nothing to do for attn direction up / rampdown part of tests.
    # Not relevant for fastrampup
    if {$attnDirection eq "up" || $fastrampup == 1} {
        return
    }

    # On occasion, a rampup test may get cut short, and not generate a full 
    # set of data. For the symmetry tests, we want to test all the points that 
    # were generated on the rampdown test. So we use the rampdown range of
    # attenuator values to generate the list of points we will verify here. 
    set steps ""
    set range1 [lindex $rampdown_attn_range 0]
    set range2 [lindex $rampdown_attn_range 1]
    if {$range1 == "" || $range2 == ""} {
        return
    }
    if {$start_rampup_step == ""} {
        set maxstep $range2
    } else {
        set maxstep $start_rampup_step ;# rampdown was stopped due to no beacons.
    }

    # When adding support to use -attnstep=0.5, has to replace 'for' loop with 'while' loop
    # because 'incr' command only supports integer increment. 02/04/2014
    #for {set i $range1} {$i <= $maxstep} {incr i $attnstep} {
    #    lappend steps $i
    #}
    set i $range1
    while {$i <= $maxstep} {
	lappend steps $i
	set i [expr $i + $attnstep]
    }    

    # Put all symmetry control charts under a single heading.
    UTF::Try "$routerConfig $direction RvR Symmetry Control Chart Tests $arrow" {
        UTF::Message LOG "$::localhost" "rvr_symmetry_control_charts\
            attnDirection=$attnDirection key_template=$key_template STA=$STA\
            LAN=$LAN direction=$direction arrow=$arrow pathloss=$pathloss\
            csv_file=$csv_file rampdown_attn_range=$rampdown_attn_range\
            start_rampup_step=$start_rampup_step attnstep=$attnstep\
            iperf_sample_size=$iperf_sample_size zero_samples=$zero_samples\
            history=$history fastrampup=$fastrampup"
        UTF::Message LOG "$::localhost" "rvr_symmetry_control_charts range1=$range1 range2=$range2\
            start_rampup_step=$start_rampup_step steps=$steps"

        # If perfcache file is not found by update_control_chart_data, issues
        # will be save here.
        catch "unset ::perfcache_not_found"

        foreach step $steps {
            if {[info exists ::rvr_rampup_data($step)]} {
                set samples $::rvr_rampup_data($step)
            } else {
                set samples $zero_samples
            }
            set loss [expr $step + $pathloss] ;# total pathloss for this test
            UTF::Message LOG "$::localhost" "rvr_symmetry_control_charts step=$step\
                loss=$loss samples=$samples"

            # Check the specific attenuation point rampup samples against the
            # control chart rampdown data. Do not update the perfcache data.
            UTF::Try "Rvr Symmetry Attn: $step Loss: $loss $arrow" {
                set keys ""
                regsub "\{step\}" $key_template $step keys ;# replace {step} with attenuator step value
                UTF::Message LOG "$::localhost" "rvr_symmetry_control_charts step=$step\
                    loss=$loss samples=$samples keys=$keys"
                set catch_resp ""
                set catch_msg ""
                set catch_resp [catch {UTF::update_control_chart_data $keys $samples 1 CC "LOW|WIDE|HIGH" $STA $LAN $direction $iperf_sample_size $history} catch_msg]
                if {$catch_resp != 0} {
                    # Collect list of all non-symmetric loss points.
                    append ::rvr_symmetry_errors " $loss,"
                    set catch_msg "$catch_msg symmetry error" ;# discretely flag error
                }

                # We always return the individual control chart comparison as a PASS.
                # We dont want to generate 50 or more errors from one symmetry test.
                return $catch_msg
            }
        }

        # Log the symmetry errors, if any, in the CSV file.
        set resultsfileId [open "$csv_file" a]
        puts $resultsfileId "rvr symmetry errors at loss: $::rvr_symmetry_errors"
        close $resultsfileId

        # Check for any percache files not found.
        if {[info exists ::perfcache_not_found]} {
            UTF::Message LOG "$::localhost" "rvr_symmetry_control_charts\
                perfcache_not_found=$::perfcache_not_found"
        }

        # Overall symmetry test result is based on ::rvr_symmetry_errors
        set ::rvr_symmetry_errors [string trim $::rvr_symmetry_errors]
        if {$::rvr_symmetry_errors == ""} {
            return 
        } else {
            error "symmetry issues at loss: $::rvr_symmetry_errors dB"
        }
    }
    return
}

#============== proc save_results ===================================
# Adds an entry to running rvr results file for this testrig.
# Data is used by other scripts, such as RvRFastSweep.
#====================================================================
proc save_results {STA LAN keys routerConfig chan direction desc val} {

    # Open running results file for this specific testrig
    set SummaryLoc [file dirname "$UTF::Logfile"]
    set results_path "$SummaryLoc/../${::testrig}_rvr_results.data"
    set fd [open "$results_path" a]
    # UTF::Message LOG $::localhost "save_results results_path=$results_path fd=$fd"

    # Use keyword=value syntax, with commas to separate strings.
    # The keys often have spaces embedded, so comma delimiter helps
    # the other scripts parsing routines.
    puts $fd "STA=$STA, LAN=$LAN, keys=$keys, routerConfig=$routerConfig, chan=$chan,\
        direction=$direction, desc=$desc, val=$val, report=$SummaryLoc/summary.html,"
    close $fd
    return
}

#============== proc set_arrow_label ================================
# Returns a text label string
#====================================================================
proc set_arrow_label {STA LAN direction} {

    # Set direction label for web page headers.
    set arrow "$STA --> $LAN"
    if {$direction == "Downstream"} {
        set arrow "$STA <-- $LAN"
    }
    return $arrow
}

#============== proc setup_ap_sta_sniffer ===========================
# Does setup for AP, STA & optional sniffer.
#====================================================================
proc setup_ap_sta_sniffer {AP STA sniffer chanspec fb0 fb1 nobtreset softap is_oem_ap wet} { 

    if {[info exists ::test_mode] && $::test_mode == 1} {
        return
    }

    # ap_type is used for titles, etc
    if {$softap} {
        set ap_type "SoftAP"
    } else {
        set ap_type "AP"
    }

    set ap_chan_resp -1 ;# -1 used to detect failures
    UTF::Try "Setup $ap_type, STA" {
        if {$softap == 0} {
            if {!$is_oem_ap} {
                # Do this setup only for Real BRCM AP
                # Restore AP nvram is done by the higher level ACInightly1.test
                # AP setup - turn on the radio!!!
                UTF::Message LOG "$::localhost" "\n\n\nTurn on $ap_type radio\n\n\n"
                set catch_resp [catch "UTF::set_ap_nvram $AP wlN_radio=1" catch_msg]
                if {$catch_resp != 0} {
                    error "Could not turn on radio: $catch_msg"
                }

                # User may have specified additional AP nvram settings to be used
                # only for a specific STA.
                # EG: set ::mc356_43236USB_rtr_nvram {antswitch=0 a=b c=d}
                set var "::${STA}_rtr_nvram"
                if {[info exists $var]} {
                    set value [set $var]
                    UTF::Message LOG "$::localhost" "\n\n\nsetup_ap_sta_sniffer found: $var=$value\n\n\n"
                    $AP restart $value
                    $AP reboot
                }
            }

        } else {
            # Turn on SoftAP radio
            catch "$AP wl down"
            catch "$AP wl radio on"
            catch "$AP wl up"
        }

        # Dont set channel for OEM AP.
        if {!$is_oem_ap} {
            UTF::Message LOG "$::localhost" "\n\n\n$ap_type chanspec=$chanspec\n\n\n"
            set ap_chan_resp [catch {UTF::Test::APChanspec $AP $chanspec} catch_msg]
            if {$ap_chan_resp != 0} {
                error "setup_ap_sta_sniffer ERROR: invalid Ch $chanspec, $catch_msg"
            }
        }

        # AP/SoftAP setup
        catch "$AP wl interference" ;# log current setting
        UTF::init_device $AP $::rvr_ap_init

        # Reset all BT devices in testrig, if any. If you dont do this,
        # your WLAN throughput can be only 50% of what you expect.
        if {$nobtreset == 0} {
            UTF::reset_all_bt_devices
        }

        # STA setup
        catch "$STA wl interference" ;# log current setting
        if {$wet} {
            UTF::Message LOG "$::localhost" "\n\n\nSTA chanspec=$chanspec\n\n\n"
            UTF::Test::APChanspec $STA $chanspec
            UTF::init_device $STA $::rvr_ap_init
        } else {
            UTF::init_device $STA $::rvr_sta_init
        }

        # If user didnt specify either frameburst option, the default
        # is currently frameburst=off. Eventually the default will be
        # frameburst on.
        UTF::Message LOG "$::localhost" "\n\n\nFrameburst setup\n\n\n"
        if {($fb0 == 0 && $fb1 == 0) || $fb0 == 1} {
            set catch_resp1 [catch {$STA wl frameburst 0} catch_msg1]
            set catch_resp2 [catch {$AP wl frameburst 0} catch_msg2]
            set ::rvr_fb 0
        } elseif {$fb1 == 1} {
            set catch_resp1 [catch {$STA wl frameburst 1} catch_msg1]
            set catch_resp2 [catch {$AP wl frameburst 1} catch_msg2]
            set ::rvr_fb 1
        }
        if {$catch_resp1 != 0 || $catch_resp2 != 0} {
            UTF::Message ERROR "$::localhost" "setup_ap_sta_sniffer\
				setting frameburst got: $catch_msg1, $catch_msg2"
        }

        # Diagnostic scan
        # UTF::Message LOG "$::localhost" "\n\n\nDiganostic scan\n\n\n"
        # $STA wl scan
        # UTF::Sleep 5
        # $STA wl scanresults

        # Log version info
        UTF::Message LOG "$::localhost" "\n\n\nGet driver versions & hardware\n\n\n"
        if {$is_oem_ap} {
            set ap_ver OEM
        } elseif {$softap} {
            set ap_ver [$AP wl ver]
        } else {
            set ap_ver [$AP nvram get os_version]
        }
        if {$is_oem_ap} {
            set ap_hw OEM
        } else {
            set ap_hw [$AP whatami]
        }
        regsub -all { } $ap_hw "_" ap_hw ;# Rawleys spec
        if {$wet} {
            set sta_ver [$STA nvram get os_version]
        } else {
            set sta_ver [$STA wl ver]
        }
        set sta_hw [$STA whatami]
        regsub -all { } $sta_hw "_" sta_hw ;# Rawleys spec
        set msg "html: $ap_type: $ap_ver $ap_hw<br>STA: $sta_ver $sta_hw"
        regsub -all {\n} $msg " " msg
        return "$msg"
    }

    # If AP general setup failed, halt the tests.
    if {$ap_chan_resp == "-1" && $is_oem_ap == 0} {
        error "setup_ap_sta_sniffer ERROR: halting tests, $ap_type $AP setup failed"
    }

    # If AP could not set the chanspec, halt the tests. We dont
    # want to proceed using the  previous channel, whatever that may
    # be. The graphs and perfcache data would all show the wrong
    # channel, which would be very bad!
    if {$ap_chan_resp != 0 && $is_oem_ap == 0} {
        error "setup_ap_sta_sniffer ERROR: halting tests, invalid Ch $chanspec"
    }

    # Setup the optional sniffer.
    UTF::setup_sniffer $sniffer $chanspec
}

#============== proc setup_int_sta ==================================
# Does optional setup interference STA 
#====================================================================
proc setup_int_sta {int_sta band int_attn int_chan int_type rate nrate pkt_gap pkt_size int_quiet} { 

    # Interference test is optional
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    if {$int_sta == ""} {
        UTF::Message LOG "" "setup_int_sta int_sta is null"
        return
    }

    # Used by other routines & controlchart keys.
    set ::int_chan $int_chan
    
    # Save rate / nrate for other routines & controlchart keys.
   if {$nrate !=""} {
       set nrate [lindex $nrate $::loop1_counter] 
       set ::intNrate "MCS=$nrate"
	     
            }
   if {$rate !=""} {
    set rate [lindex $rate $::loop1_counter] 
             set ::intNrate "R=$rate"
			   
			   
              } 

    # Description string for graphs
    set ::int_desc "Interf: CH=$::int_chan $int_type $::intNrate"

    set setup_OK no ;# detect setup error
    UTF::Try "Setup interference STA=$int_sta CH=$::int_chan int_type=$int_type $::intNrate" {
        UTF::Message LOG "" "setup_int_sta int_sta=$int_sta band=$band\
            int_attn=$int_attn int_chan=$int_chan int_type=$int_type\
            rate=$rate nrate=$nrate pkt_gap=$pkt_gap pkt_size=$pkt_size\
            int_quiet=$int_quiet"

        # ACInightly1.test checks that we have a valid STA and loads it.
        set var "::${int_sta}_state"
        set $var Check
        UTF::progressive_recovery $int_sta 0 - 1 0

        # Setup optional attenuator for interference STA.
        if {$int_attn != ""} {
	    # Variable int_attn is expected to be: attn_grp attn_val [attn_val1, attn_val2...].
	    # If more than 1 attn values are present (eg: int_attn=G2 0 30), we are expecting
	    # a same-numbered loop test (i.e loop=2) where each loop will use a different attn value.
	    # Otherwise, it's just a regular loop test where each loop uses the same attn value.
            set grp [lindex $int_attn 0]
            set val [lindex $int_attn 1]
	    if {[llength $int_attn] > 2} {
		# More than 1 attn value exist and we're going to use them for loop test.
		set val [lindex $int_attn $::loop_counter]
		UTF::Message LOG $int_sta "setup_int_sta: loop_counter=$::loop_counter"
	    }
            UTF::Message LOG $int_sta "setup_int_sta: $grp attn $val"
            $grp attn $val
        }

        # Set interference channel
        set is_ap [UTF::is_ap $int_sta]
        catch "$int_sta wl disassoc"
        catch "$int_sta wl down"
        catch "$int_sta wl mimo_bw_cap 1"
        # Need to band lock STA so shmem command will work
        if {$band == "5" || $band == "a"} {
            catch "$int_sta wl band a"
        } else {
            catch "$int_sta wl band b"
        }
        catch "$int_sta wl up"
        catch "$int_sta wl mpc 0"
        if {$is_ap} {
            # AP setup
            UTF::set_ap_nvram $int_sta wl0_radio=1 wl1_radio=1
            UTF::Test::APChanspec $int_sta $::int_chan
        } else {
            # STA setup
            $int_sta wl radio on
            $int_sta wl chanspec $::int_chan 
        }
        $int_sta wl chanspec ;# query the chanspec

        # Turn on the interference.
        if {$int_type == "tone"} {
            # Play a 4 MHz tone. DOESNT WORK!!
            error "setup_int_sta int_type=$int_type doesnt work!"
            # $int_sta wl out
            # $int_sta wl phy_tx_tone 4000  

        } elseif {$int_type == "pkteng"} {
            # Now start packet engine.
            # NB: pkteng does NOT work with rate AUTO
            # You MUST use a fixed rate!
            if {$rate != ""} {
                set catch_resp [catch "$int_sta wl nrate -r $rate" catch_msg]
            } else {
                set catch_resp [catch "$int_sta wl nrate -m $nrate" catch_msg]
            }
            $int_sta wl nrate ;# query the rate / nrate

            # Sometimes nrate (eg 43237sdio) doesnt work, but a_rate or bg_rate does work.
            # set catch_resp 1 ;# test code
            if {$catch_resp != 0} {
                if {$band == 5 || $band == "a"} {
                   set cmd a_rate ;# A band
                } else {
                    set cmd bg_rate ;# B band
                }
                if {$rate != ""} {
                    $int_sta wl $cmd -r $rate
                } else {
                    $int_sta wl $cmd -m $nrate
                }
                $int_sta wl $cmd ;# query the rate/nrate
            }
            set dest_mac "00:aa:00:aa:00:aa"
            set frame_cnt 0 ;# 0 means continuous test
            set src_mac "00:99:00:99:00:99"
            $int_sta wl pkteng_start $dest_mac tx $pkt_gap $pkt_size $frame_cnt $src_mac
        } else {
            error "setup_int_sta int_type=$int_type not supported!"
        }

        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch "$int_sta deinit"
        }

        # Set the success flag
        set setup_OK yes
        return ""
    }

    # If setup failed, stop RvR tests.
    if {$setup_OK == "no"} {
         error "setup_int_sta $int_sta failed, halting tests!"
    } else {
       UTF::Message LOG $int_sta "setup_int_sta setup_OK=$setup_OK"
       return ""
    }
}

#============== proc setup_rvr_symmetry =============================
# Does setup for rvr symmetry tests.
#====================================================================
proc setup_rvr_symmetry { } {

    # Initialize globals used.
    set ::rvr_symmetry_errors ""

    # Take out the trash from previous run.
    set ::rvr_rampup_data(0) "-"
    set names [array names ::rvr_rampup_data]
    puts "setup_rvr_symmetry names=$names"
    foreach item $names {
        unset ::rvr_rampup_data($item)
    }
}

#============== proc stop_int_sta ===================================
# Stops optional interference STA 
#====================================================================
proc stop_int_sta {int_sta int_graph int_type int_quiet routerConfig direction} { 

    # Interference test is optional
    set int_sta [string trim $int_sta]
    set int_type [string trim $int_type]
    UTF::Message LOG "" "stop_int_sta int_sta=$int_sta int_graph=$int_graph\
        int_type=$int_type int_quiet=$int_quiet routerConfig=$routerConfig\
        direction=$direction"
    if {$int_sta == ""} {
        return
    }

    # Check for unexpected interference values found
    UTF::Try "$routerConfig $direction Interference setting errors" {
        set cnt [llength $::intwl_errors]
        if {$cnt == 0} {
            return $cnt
        } else {
            error "$cnt $::intwl_errors"
        }
    }

    UTF::Try "$routerConfig $direction Stop interference STA=$int_sta" {
        set is_ap [UTF::is_ap $int_sta]
        set radio_off 0
        # Turn off the interference.
        if {$int_type == "tone"} {
            error "setup_int_sta int_type=$int_type not supported!"
            # Stop the tone
            $int_sta wl phy_tx_tone 0
            $int_sta wl in

        } elseif {$int_type == "pkteng"} {
            # Stop packet engine
            $int_sta wl pkteng_stop tx

        } else {
            error "setup_int_sta int_type=$int_type not supported!"
        }

        # Turn off the radio
        if {$is_ap} {
            UTF::set_ap_nvram $int_sta wl0_radio=0 wl1_radio=0
        } else {
            $int_sta wl radio off
        }

        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch "$int_sta deinit"
        }
        set radio_off 1
        return
    }

    # Make sure radio was turned off.
    if {$radio_off == 0} {
        UTF::Message LOG $int_sta "stop_int_sta make sure radio is off"
        if {$is_ap} {
            catch "UTF::set_ap_nvram $int_sta wl0_radio=0 wl1_radio=0"
        } else {
            catch "$int_sta wl radio off"
        }
        # If requested, suppress messages from interference STA.
        if {$int_quiet} {
            catch "$int_sta deinit"
        }
    }

    # Sanity check on pkteng - if we got multiple identical activity counts in a row, this
    # usually means pkteng died partway thru the test, maybe never started. In which case
    # the interference test results are probably meaningless.
    # NB: The activity is a 2 byte counter, so it wraps to 0 quite often.
    if {$int_type == "pkteng"} {
        UTF::Try "$routerConfig $direction Check pkteng activity on $int_sta" {
            UTF::Message LOG $int_sta "stop_int_sta intsta_activity=$::intsta_activity"
            set max 2 ;# allowable consecutive identical counts
            set same_val ""
            foreach pair $::intsta_activity {
                # Initialization
                set step [lindex $pair 0]
                set val [lindex $pair 1]
                set last [lindex $same_val 0]
                if {$last == ""} {
                    puts "stop_int_sta startup step=$step val=$val same_val=$same_val"
                    lappend same_val $val
                    continue
                }
    
                # Collect consecutive identical values
                if {$val == $last} {
                    # Another consecutive identical values
                    puts "stop_int_sta identical step=$step val=$val same_val=$same_val"
                    lappend same_val $val
                } else {
                    # Different value, reset list.
                    puts "stop_int_sta reset step=$step val=$val same_val=$same_val"
                    set same_val $val
                }
    
                # Have we hit the error threshold?
                set cnt [llength $same_val]
                if {$cnt > $max} {
                    error "stop_int_sta ERROR: too many pkteng consecutive identical activity values cnt=$cnt same_val=$same_val step=$step"
                }
            }
        }
    }
}

#============== proc track_ap_state =================================
# Tracks the AP state view of STA, logs state transitions.
#====================================================================
proc track_ap_state {AP StaMac step pathloss noredundant sta_reassoc\
    routerConfig direction is_oem_ap} {

    # If AP is known to be in trouble, or OEM AP return.
    set var "::${AP}_state"
    if {[set $var] != "OK" || $is_oem_ap != "0"} {
        return
    }
    # Some people really want this redundant call to preserve timing.
    set ap_name [UTF::get_name $AP]
    if {$noredundant == "0" || $sta_reassoc == "1"} {
        # Get latest AP association state info.
        set catch_resp [catch {$AP wl sta_info $StaMac} catch_msg]
        UTF::save_device_state $AP $catch_msg
        # puts "catch_msg=$catch_msg"
        set curr_state "NULL"
        if {[regexp {state:\s*(.*)flags} $catch_msg - state]} {
            set curr_state [string trim $state]
        }
        set curr_state [string trim $curr_state]
        set curr_state [string toupper $curr_state]

    } else {
        # UTF::ap_stats leaves association state info for us.
        set temp "::${AP}_assoc"
        if {![info exists $temp]} {
            set $temp "NULL"
        }
        set curr_state [set $temp]
        set temp "::${AP}_msg"
        if {![info exists $temp]} {
            set $temp ""
        }
        set catch_msg [set $temp]
        UTF::Message LOG "$ap_name" "duplicated msg from ap_stats: $catch_msg"
    }
    UTF::Message LOG "$::localhost" "track_ap_state step=$step loss=[expr $step + $pathloss]\
        ::ap_old_state=$::ap_old_state curr_state=$curr_state noredundant=$noredundant\
        sta_reassoc=$sta_reassoc"

    # Push the state change onto the main web page.
    if {$curr_state != $::ap_old_state} {
        UTF::Try "$routerConfig $direction $::aux_desc AP state change: $::ap_old_state --> $curr_state" {
            UTF::Message LOG "$::localhost" "track_ap_state step=$step loss=[expr $step + $pathloss]\
                ::ap_old_state=$::ap_old_state curr_state=$curr_state noredundant=$noredundant"
            UTF::Message LOG "$ap_name" "duplicated msg: $catch_msg"
            return
        }
    }
    set ::ap_old_state $curr_state
    return
}

#============== proc warmup_test ===================================
# Run iperf for 60 secs to stabilize rate.
#====================================================================
proc warmup_test {LAN STA direction window va warmup} {

    # If requested, run iperf for 60 secs to stabilize rate.
    if {$warmup == 0} {
        return
    }

    # Check ::rvr_warmup for minimum thruput.
    if {[info exists ::rvr_warmup]} {
        set tput_min $::rvr_warmup
    } else {
        set tput_min 5
    }

    UTF::Try "60 sec warmup test, pass criteria: $tput_min Mb/s or more" {
        if {$direction == "Upstream"} {
            set PAIRS [list $STA $LAN]
        } else {
            set PAIRS [list $LAN $STA]
        }
        # Do test as one long burst, so we get only one number as a result.
        # We dont use controlchart here as we arent trying to control this
        # test, and we dont want failures showing up in the logs & email.
        # But we DO want to show the user that something useful happened,
        # or if we are totally dead.
        # catch "$::rvr_attn_grp attn 103" ;# test code
        set catch_resp [catch {UTF::Multiperf $PAIRS -w $window -N -i 60 -t 60} catch_msg]
        if {$catch_resp == 0} {
            set catch_msg [string trim $catch_msg]
            if {$catch_msg == ""} {
                set catch_msg 0
            }
            return [format "%.2f Mb/s" $catch_msg] ;# show user the single result!!!
        } else {
            error $catch_msg  ;# show user the error!!!
        }
    }

    # Check if warmup test met spec or not.
    # set catch_msg 2 ;# test code
    if {$tput_min > 0} {
        if {$catch_resp != 0 || $catch_msg < $tput_min} {
            error "ERROR: warmup test did not meet pass criteria $tput_min Mb/s\
              or more. Halting tests!"
        }
    }
}

#============== Main RvR test =======================================
UTF::Test aci1fidha {AP STA args} {
    UTF::Getopts {
        {allhooks              "Use all the perf_hooks, etc as is - currently the default"}
        {attngrp.arg ""        "Attenuator group to use for test"}
        {attnlist.arg ""       "list of attenuation values"}
        {attnstart.arg 0       "does nothing!"}
        {attnstep.arg "1"      "Step value that attenuator is changed by"}
        {attnstop.arg 35       "does nothing!"}
        {branch.arg "auto"     "Branch override"}
        {chanint               "Collect chanspec info and graph as integer"}
        {chanspec.arg 36l      "AP channel"}
	{comparesta            "Run STA comparison test upon 2 STAs. Require 2 and only 2 STAs."}
	{compareoneloop        "Run STA comparison test upon 2 STAs in multiple loops, but only 1 loop for first STA. Require -comparesta option."}
	{compareap             "Run AP comparison test upon 2 APs. Require 2 and only 2 APs."}
    	{direction.arg "Up"    "Traffic Direction - Up or Down"}
        {edithooks             "Selectively edit the perf_hooks, etc for some test speedup"}
    	{email.arg ""          "Email Address"}
        {fastrampup            "Do fast rampup only, saves test time"}
        {fb0                   "Use frameburst=0, currently the default"}
        {fb1                   "Use frameburst=1 for maximum throughput"}
        {forcesniffercapture   "Always save the sniffer capture .pcap file, consumes lots of disk space"}
        {fullrange             "Test full attenuator range specified, default is to rampup after 3 steps of no beacons"}
        {fullrampup            "Do not stop the rampup test, regardless of slow rejoin issues"}
        {history.arg 30        "History size for control charts"}
        {iperfnobeacons        "Run iperf tests even if STA has no beacons"}
        {intattn.arg ""        "secondary attn_grp & attn_val for interference, eg: G3 7"}
        {intchan.arg "44l"     "channel setting for interference source"}
        {intgap.arg "50"       "pkteng interference time between frames, in usec"}
        {intgraph              "Monitor / create interference data graphs even if interference test not active"}
        {intnrate.arg "7"      "MCS rate to test pkteng interference with"}
        {intquiet              "Suppress interference STA error messages, which can flood the error report."}
        {intrate.arg ""        "Legacy rate test pkteng interference with, if specified, rate will override intnrate"}
        {intsize.arg "1400"    "pkteng interference frame size, in bytes"}
        {intsta.arg ""         "STA to be used as the interference source, this is not the DUT STA"}
        {inttype.arg "pkteng"  "pkteng can be used to generate interference, tone not supported"}
        {intwl.arg "0"         "For interference tests, AP/STA wl interference setting to use"}
        {keepgoing             "No time limit for test, keep going no matter what"}
        {max.arg 700           "Expected maximum througput, -1 means no checks done"}
        {min.arg 0             "Expected minimum througput, -1 means no checks done"}
        {mingraphs             "Produce minimum quantity of graphs"}
	{musta.arg ""          "Multi user mode. It loads up to 4 additional STAs"}
        {nobtreset             "Don't reset BlueTooth devices. WARNING: can lead to low WLAN thruput!"}
        {nocache               "Don't update performance cache"}
        {nographs              "Dont produce any graphs"}
        {nohistograms          "Do not produce histograms"}
        {nohooks               "Dont use any perf_hooks, etc for maximum test speedup"}
        {noinit                "Use the testbed as is, no initialization"}
        {nomalloc              "Dont check the serial console for malloc failures"}
        {nopretest             "Dont do short warmup test for each controlchart test, defaults on for udp"}
        {noredundant           "Dont execute redundant wl calls, test runs a bit faster"}
        {nosetuptestbed        "Don't run Setup Testbed hooks"}
        {nosniffer             "Do not use Sniffer"}
        {nosymmetry            "Dont run symmetry tests for rampdown / rampup tests"}
        {oemband.arg ""        "When OEM AP broadcasts on both bands, used to choose the desired band: 2.4 or 5"}
        {pathloss.arg ""       "Known testbed path loss, in db, from AP to STA when variable attenuator is set to default"}
        {perfloop.arg 1        "Total performance test iterations for iperf controlchart tests"}
        {perfsize.arg 5        "Sample size for performance tests"}
        {perftime.arg 10       "Total time duration, in seconds, for performance tests"}
        {pingmax.arg ""        "Maximum times to try ping"}
        {rampdownonly          "Dont do rampup portion of RvR tests, test time is halved"}
        {rampuponly            "Dont do rampdown portion of RvR tests, test time is halved"}
        {refreshaddralways     "Always do dhcp before each attenuator step change & iperf test"}
        {refreshaddrasneeded   "Do dhcp after reassociation for each attenuator step until dhcp succeeds once, then stop"}
        {ringfilecnt.arg ""    "Specify sniffer ring buffer file count. Null means no ring buffer."}
        {ringfilesize.arg ""   "Specify sniffer ring buffer file size in MBytes. Null means no ring buffer."}
        {security.arg "open"   "Security used for tests"}
        {sniffer.arg ""        "Sniffer object name"}
        {sniffercapture.arg "" "Start/stop commands for when to capture continuous .pcap files. To collect rampdown steps 44-54, specify: d44 d54"}
        {softap                "AP is really a STA running softap code"}
        {steplist.arg ""       "List of specific attenuator steps to test, in whatever order"}
        {steploop.arg 1        "Number of times to repeat attenuator steplist"}
        {stoponerror           "Stops test on first error, no progressive recovery done. Useful when developer want to see testrig in failed state."}
        {stopslowrampup        "Stop the rampup test if severe slow rejoin issues are detected"}
        {test.arg "0"          "Test mode for script development, experts only, values: 0 1 2"}
        {timeout.arg ""        "Overall test timeout, in minutes, default is 90 min"}
        {title.arg "RvR test"  "Report title text"}
        {titleap               "Use AP name in report & graph titles, default is STA name"}
        {trenderrors           "Show only trend errors, not 1 error per controlchart"}
        {txbf                  "Run comparison test in this pattern: AP1<->STA1, AP2<->STA2 (useful for TxBF test)"}
        {udp.arg "0"           "udp test starting value in Mb/s, 0 means off, use tcp"}
        {udpopt.arg ""         "more options for iperf for udp tests"}
        {va.arg "Aflex"        "variable attenuator name"}
        {warmup                "Do 60 second iperf warmup tests"}
        {wet                   "Allow AP in the STA position, for WET test"}
        {window.arg 512k       "Window size for iperf tests, has major impact on throughput"}
    }

    # NB: attnstart & attnstop are not used for anything! 

    # Save start time
    set ::rvr_overall_start_sec [clock seconds]

    # Set globals for interference tests
    set ::int_desc ""
    set ::int_wl ""
    set ::int_chan ""
    set ::intNrate ""

    # ::test_mode=1 is used to turn off most of the data collection 
    # so tests run faster and you can debug the code being modified.
    # ::test_mode=2 turns off some data collection.
    set ::test_mode $(test)

    # In case of conflicting options, make nosniffer override sniffer.
    if {$(nosniffer)} {
        set (sniffer) ""
    }

    # Get MUSTA
    set MUSTA1 ""
    set MUSTA2 ""
    set MUSTA3 ""
    set MUSTA4 ""
    if {$(musta) != ""} {
        set MUSTA1 [lindex $(musta) 0]
        set MUSTA2 [lindex $(musta) 1]
        set MUSTA3 [lindex $(musta) 2]
        set MUSTA4 [lindex $(musta) 3]
    }
    UTF::Message LOG "" "ap=$AP sta=$STA musta=$MUSTA1 $MUSTA2 $MUSTA3 $MUSTA4"

    # Sanity checks
    set AP [string trim $AP]
    if {$AP == ""} {
        error "ERROR: Must specify AP"
    }

    # AP could be a STA running softap code.
    if {$(softap)} {
        # Dynamically set -ap flag so Router will be allowed to act as SoftAP.
        $AP configure -ap 1
    }
    set (softap) [UTF::is_softap $AP] ;# Is this a SoftAP?
    if {$(softap)} {
        set ap_type "SoftAP"
    } else {
        set ap_type "AP"
    }
    set ::is_oem_ap [UTF::is_oem_ap $AP] ;# Is this an OEM AP?
    # puts "(softap)=$(softap) ap_type=$ap_type is_oem_ap=$::is_oem_ap"

    # Check STA type.
    set STA [string trim $STA]
    if {$STA == ""} {
        error "ERROR: Must specify STA"
    }

    # For WET test, STA must be an AP.
    if {$(wet)} {
        if {![UTF::is_ap $STA]} {
            error "ERROR: For WET test, need an AP in STA postion, $STA is NOT an AP!"
        }
    } else {
        UTF::check_sta_type $STA $::sta_type_list
    }
    # Ensure security is specified.
    set (security) [string trim $(security)]
    if {$(security) == ""} {
        set (security) open
    }

    # Set controlchart data cache option.
    if {$(nocache)} {
        set ::UTF::ControlChart::readonly 1
    }

    # Checks on direction
    set (direction) [string tolower $(direction)]
    if {$(direction) == "up"} {
        set (direction) "Upstream"
    } elseif {$(direction) == "down"} {
        set (direction) "Downstream"
    } else {
        error "ERROR: -direction must be Up or Down"
    }

    # Checks on attnlist.
    set (attnlist) [string trim $(attnlist)]
    if {$(attnlist) == ""} {
        error "ERROR: Must specify -attnlist"
    }
    if {[llength $(attnlist)] == 1} {
        set (nosymmetry) 1
    } 

    # Checks on attnstep
    set (attnstep) [string trim $(attnstep)]
    # Comment out when adding -attnstep=0.5 support. 02/04/2014
    #if {![regexp {^\d+$} $(attnstep)] || $(attnstep) < 1} {
    #    error "ERROR:  -attnstep must be integer, 1 or more"
    #}

    # For OEM AP, we need to scan the airwaves to see what AP are
    # available and what channel is in use. Any chanspec user passed
    # to us from the command line is ignored.
    set oem_band [string tolower [string trim $(oemband)]] ;# need oem_band defined no matter what!
    if {$::is_oem_ap == 1} {
        # Check desired oem band. Some OEM AP broadcast on both bands simultaneously.
        # So we need to be able to specify the preferred band.
        if {$oem_band == "a"} {
            set oem_band "5"
        }
        if {$oem_band == "b"} {
            set oem_band "2.4"
        }
        if {$oem_band != "2.4" && $oem_band != "5" && $oem_band != ""} {
            UTF::Message WARN "" "Invalid oem_band=$oem_band, should be 2.4 or 5, set to null."
            set oem_band ""
        }

        # Get SSID that OEM AP is expected to be broadcasting.
        set oem_ssid [UTF::get_oem_ap_ssid $AP]

        # Get chanspec of OEM AP on preferred oem_band.
        set resp [UTF::find_oem_ap_chanspec $oem_ssid $oem_band $STA]
        set (chanspec) [lindex $resp 0]
        set oem_ssid [lrange $resp 1 end] ;# may have multiple tokens
        puts "(chanspec)=$(chanspec) oem_ssid=$oem_ssid" 
    }

    # Parse out channel, band, bw from chanspec.
    # Check for 11AC format first. Otherwise it is mistaken for BW=20MHz.
    set bw ""
    set cap ""
    if {[regexp {(\d+)(/\d+)} $(chanspec) - channel bw]} {
        # 11AC format channel spec
        # NB: Keep "/" as part of bw, so it shows up nicely on the graphs
        regsub -all {/} $bw "" cap ;# remove "/"
        if {$channel >= 36} {
            set band "5"
        } else {
            set band "2.4"
        }

    } elseif {[regexp {(\d+)([ab]?)([ul])?} $(chanspec) - channel band bw]} {
        # 11N format channel spec
        if {$band eq ""} {
            if {$channel >= 36} {
                set band "5"
            } else {
                set band "2.4"
            }
        }
        if {$bw eq "l" || $bw eq "u"} {
            set cap "40"
        } else {
            set cap "20"
        }

    } else {
        error "ERROR: Bad chanspec: $(chanspec)"
    }

    # Set band without a "."
    if {$band == "5"} {
        set noDotBand "5"
    } else {
        set noDotBand "24"
    }

    # Command line pathloss will override testrig config file values, if any.
    set (pathloss) [UTF::get_pathloss $(pathloss) $STA $band $(chanspec)]

    # Setup labels, output filename
    set routerConfig "rvr${noDotBand}G${cap}"
    set TestAPBand "${band}Ghz"
    set TestAPCapacity "${cap}Mhz"
    set TestAPChannel "Channel $channel"
    set description "$(direction) $TestAPChannel $TestAPBand $TestAPCapacity"
    set GPFFileName "aci1fidha$(direction)Cycle${noDotBand}G${cap}Ch${channel}"

    # aci1fidha.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }

    # Parse out intwl values.
    set intwlval $(intwl)
    if {$(intsta) != "" && [llength $(intwl)] > 1} {
    	# This is interference loop test because more than 1 intwl values are specified,
    	# and we are going to use a different intwl value for each loop. Note that the loop number
   	# should match with the number of intwl values.
    	set intwlval [lindex $(intwl) $::loop_counter-1] ;# because ::loop_counter is initialized to 1
	UTF::Message LOG $::localhost "intwl=$(intwl), loop_counter=$::loop_counter, intwlval=$intwlval"
    }

    # Start web summary report page
    set TITLE $(title)
    set summaryinfo ""
    UTF::WrapSummary $UTF::SummaryDir $TITLE $summaryinfo $(email) {

        UTF::Try "$routerConfig $(direction) CH=$(chanspec) $ap_type=$AP STA=$STA" {
            # NB: The entire RvR test is reported under this single UTF::Try
            # entry on the web summary page!

            # Test code
            # set ::stop_tests yes
            # error "stop tests"
            # return

            # Get testrig name
            UTF::setup_config_testrig

            # Add a web link to the test.log file
            UTF::Try "Link to test.log" {
                return "html: <a href=\"./test.log\">test.log</a>"
            }

            # Check start/stop steps for continuous sniffer capture.
            UTF::check_sniffer_capture_steps $(sniffer) $(sniffercapture)

            UTF::Message LOG "$::localhost" "routerConfig=$routerConfig\
                TestAPBand=$TestAPBand TestAPCapacity=$TestAPCapacity\
                TestAPChannel=$TestAPChannel description=$description\
                GPFFileName=$GPFFileName pid=[pid]"

            # For udp, load the standalone Multiperf package
            if {$(udp) > 0} {
                set ver [package require UTF::Multiperf]
                UTF::Message LOG "" "UDP loading Multiperf ver=$ver"
            }

            # Check test_mode setting.
            check_testmode $::test_mode

            # Setup testbed. Some users may turn off AP radios!!!
            if {!$(noinit) && !$(nosetuptestbed)} {
                UTF::setup_testbed
            }

            # Get other RvR parameters from user config file
            set (intsta) [string trim $(intsta)]
            get_user_parms $(timeout) $(softap) $AP $STA $(intsta) $intwlval

            # Inititialize device states.
            set ::recovery_cnt 0
            set var1 "::${AP}_state"
            set $var1 Check
            set var2 "::${STA}_state"
            set $var2 Check

	    set var3 "" ;# for MUSTA1
	    set var4 "" ;# for MUSTA2
	    set var5 "" ;# for MUSTA3
	    set var6 "" ;# for MUSTA4
	    if {$(musta) != ""} {
	    	set var3 "::${MUSTA1}_state"
	     	set $var3 Check
		if {$MUSTA2 != ""} {
	    	    set var4 "::${MUSTA2}_state"
	     	    set $var4 Check
		}
		if {$MUSTA3 != ""} {
	    	    set var5 "::${MUSTA3}_state"
	     	    set $var5 Check
		}
		if {$MUSTA4 != ""} {
	    	    set var6 "::${MUSTA4}_state"
	     	    set $var6 Check
		}
	    }

            # Setup for frameburst, in case of -noinit
            set ::rvr_fb 0
            if {$(fb1)} {
                set ::rvr_fb 1
            }

            # Check AP & STA drivers are responding, reload if necessary.
            # State variables will be updated.
            set start_up 1
            if {$(softap)} {
                set softap_sta $AP
            } else {
                set softap_sta ""
            }
	    if {$(musta) != ""} {
            	UTF::progressive_recovery "$AP $STA $MUSTA1" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band
		if {$MUSTA2 != ""} {
            	    UTF::progressive_recovery "$AP $STA $MUSTA1 $MUSTA2" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band
		} elseif {$MUSTA3 != ""} {
            	    UTF::progressive_recovery "$AP $STA $MUSTA1 $MUSTA2 $MUSTA3" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band
		} elseif {$MUSTA4 != ""} {
            	    UTF::progressive_recovery "$AP $STA $MUSTA1 $MUSTA2 $MUSTA3 $MUSTA4" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band
		}
	    } else {
            	UTF::progressive_recovery "$AP $STA" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band
	    }

            # We need all devices to work, otherwise halt the tests.
            if {$(musta) != ""} {
            	if {[set $var1] != "OK" || [set $var2] != "OK" || [set $var3] != "OK"} {
                    error "ERROR: progressive_recovery halting tests!"
		} elseif {$MUSTA2 != "" && [set $var4] != "OK"} {
                    error "ERROR: progressive_recovery halting tests!"
		} elseif {$MUSTA3 != "" && [set $var5] != "OK"} {
                    error "ERROR: progressive_recovery halting tests!"
		} elseif {$MUSTA4 != "" && [set $var6] != "OK"} {
                    error "ERROR: progressive_recovery halting tests!"
		}
	    } else {
            	if {[set $var1] != "OK" || [set $var2] != "OK"} {
                    error "ERROR: progressive_recovery halting tests!"
            	}
	    }

            # Log users nvram settings.
            if {!$(softap) && !$::is_oem_ap} {
                set temp [$AP cget -nvram]
                UTF::Message LOG "" "$ap_type nvram $temp"
            }

            # Get mac addr of STA. Push error to main web page,
            # stop tests on error.
            set catch_resp [catch "set testStaMac \[$STA macaddr\]" catch_msg]
            if {$catch_resp != 0} {
                UTF::Try "Could not get mac addr for $STA" {
                    error "$catch_msg"
                }
                # Force script to halt.
                error "Halting tests!"
            }

	    set testMuStaMac1 ""
	    set testMuStaMac2 ""
	    set testMuStaMac3 ""
	    set testMuStaMac4 ""
	    if {$(musta) != ""} {
		set catch_resp [catch "set testMuStaMac1 \[$MUSTA1 macaddr\]" catch_msg]
		if {$catch_resp != 0} {
		    UTF::Try "Could not get mac addr for $MUSTA1" {
			error "$catch_msg"
		    }
		    # Force script to halt.
		    error "Halting tests!"
		} 
		if {$MUSTA2 != ""} {
		    set catch_resp [catch "set testMuStaMac2 \[$MUSTA2 macaddr\]" catch_msg]
                    if {$catch_resp != 0} {
                    	UTF::Try "Could not get mac addr for $MUSTA2" {
                            error "$catch_msg"
			}
                    	error "Halting tests!"
                    }
		}
                if {$MUSTA3 != ""} {
                    set catch_resp [catch "set testMuStaMac3 \[$MUSTA3 macaddr\]" catch_msg]
                    if {$catch_resp != 0} {
                        UTF::Try "Could not get mac addr for $MUSTA3" {
                            error "$catch_msg"
			}
                    	error "Halting tests!"
                    }
                }
                if {$MUSTA4 != ""} {
                    set catch_resp [catch "set testMuStaMac4 \[$MUSTA4 macaddr\]" catch_msg]
                    if {$catch_resp != 0} {
                        UTF::Try "Could not get mac addr for $MUSTA4" {
                            error "$catch_msg"
			}
                    	error "Halting tests!"
                    }
                }
	    } 	

            # If user is trying to use a channel for a band that is not
            # supported, stop the tests. First we check the STA bands.
            set sta_bands [$STA wl bands]
            UTF::Message LOG "$::localhost" "testStaMac=$testStaMac chanspec=$(chanspec) band=$band sta_bands=$sta_bands"
            if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $sta_bands]) ||\
                (($band == "b" || $band == "2.4") && ![string match -nocase *b* $sta_bands])} {
                error "Requested chanspec $(chanspec) band $band not in sta_bands=$sta_bands"
            }

	    if {$(musta) != ""} {
            	set musta_bands [$MUSTA1 wl bands]
            	UTF::Message LOG "$::localhost" "testMuStaMac1=$testMuStaMac1 chanspec=$(chanspec) band=$band musta1_bands=$musta_bands"
            	if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $musta_bands]) ||\
                    (($band == "b" || $band == "2.4") && ![string match -nocase *b* $musta_bands])} {
                    error "Requested chanspec $(chanspec) band $band not in musta1_bands=$musta_bands"
            	}
		if {$MUSTA2 != ""} {
                    set musta_bands [$MUSTA2 wl bands]
                    UTF::Message LOG "$::localhost" "testMuStaMac2=$testMuStaMac2 chanspec=$(chanspec) band=$band musta2_bands=$musta_bands"
                    if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $musta_bands]) ||\
                    	(($band == "b" || $band == "2.4") && ![string match -nocase *b* $musta_bands])} {
                    	error "Requested chanspec $(chanspec) band $band not in musta2_bands=$musta_bands"
                    }
		}
                if {$MUSTA3 != ""} {
                    set musta_bands [$MUSTA3 wl bands]
                    UTF::Message LOG "$::localhost" "testMuStaMac3=$testMuStaMac3 chanspec=$(chanspec) band=$band musta3_bands=$musta_bands"
                    if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $musta_bands]) ||\
                        (($band == "b" || $band == "2.4") && ![string match -nocase *b* $musta_bands])} {
                        error "Requested chanspec $(chanspec) band $band not in musta3_bands=$musta_bands"
                    }
		}
                if {$MUSTA4 != ""} {
                    set musta_bands [$MUSTA4 wl bands]
                    UTF::Message LOG "$::localhost" "testMuStaMac4=$testMuStaMac4 chanspec=$(chanspec) band=$band musta4_bands=$musta_bands"
                    if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $musta_bands]) ||\
                        (($band == "b" || $band == "2.4") && ![string match -nocase *b* $musta_bands])} {
                        error "Requested chanspec $(chanspec) band $band not in musta4_bands=$musta_bands"
                    }
		}
	    }

            # Now we check the AP bands.
            if {$::is_oem_ap == 0} {
                set ap_bands [$AP wl bands]
                UTF::Message LOG "$::localhost" "ap_bands=$ap_bands"
                if {(($band == "a" || $band == "5")   && ![string match -nocase *a* $ap_bands]) ||\
                    (($band == "b" || $band == "2.4") && ![string match -nocase *b* $ap_bands])} {
                    error "Requested chanspec $(chanspec) band $band not in ap_bands=$ap_bands"
                }
            }

            # Choose the attenuator group to use.
            UTF::choose_attn_grp $(va) $(attngrp) $AP $STA

            # Set Attenuator in case users testbed setup didnt.
            set user_attn_start_value [UTF::get_attn_start_value]
            set ::attn_error_cnt 0;# keep track of attenuator errors
            UTF::set_attn_grp $user_attn_start_value

            # AP, STA, sniffer setup. Includes turning on AP radio!!!
            # This is optimized to run only once foreach STA being tested.
            if {$(noinit) || ([info exists ::rvr_init_done] && $::rvr_init_done == 1)} {
                # While user wants no initialation done, we can get really 
                # misleading results and garbage data in the perfcache if
                # we are on the wrong channel. So we always set the AP channel.
                if {!$::is_oem_ap} {
                    UTF::Try "Set $AP CH=$(chanspec)" {
                        UTF::Test::APChanspec $AP $(chanspec)
                        if {$(wet)} {
                            UTF::Test::APChanspec $STA $(chanspec)
                        }
                    }
                }

                # Also set the interference mode for each different band.
                # [cchai, 7/30/2014] This is where interference mode gets set
                # if it is NOT the very first sub-test (e.g. second loop in looped test).
                # For the very first test, interference mode gets set in UTF::init_device{}. 
                if {$(intsta) != ""} {
                    UTF::Try "Set AP/STA interference mode" {
                        if {!$::is_oem_ap} {
                            $AP wl interference_override $intwlval
                        }
                        $STA wl interference_override $intwlval
                    }
                }

                # Make sure sniffer is on correct channel. We wont get much
                # data in the .pcap if we are on the wrong channel.
                UTF::setup_sniffer $(sniffer) $(chanspec)

            } else {
                # Do the full AP/STA initialization once for this AP/STA pair.
                # ACInightly1.test resets flag below when tests for new AP/STA start.
                setup_ap_sta_sniffer $AP $STA $(sniffer) $(chanspec) $(fb0) $(fb1) $(nobtreset) $(softap) $::is_oem_ap $(wet)

		if {$(musta) != ""} {
		    foreach MUSTA $(musta) {
			setup_ap_sta_sniffer $AP $MUSTA $(sniffer) $(chanspec) $(fb0) $(fb1) $(nobtreset) $(softap) $::is_oem_ap $(wet)
		    }
		}
                set ::rvr_init_done 1
            }

            # Setup parameters for controlchart / iperf
            set iperf_sample_size [expr int($(perfsize))]
            if {$iperf_sample_size < 2 || $iperf_sample_size > 25} {
                # This is a limitation inside ControlChart.tcl
                error "ERROR: Number of samples must be from 2 to 25"
            }
            set iperf_total_sec $(perftime) ;# can be fraction of a second 
            if {$iperf_total_sec <= 0} {
                error "ERROR: perftime must be GT 0"
            }

            # Iperf will work with interval=0.5 seconds.
            # Havent had any success for less than 0.5 seconds.
            set iperf_interval_sec [expr (double($iperf_total_sec)) / $iperf_sample_size]
            if {$iperf_interval_sec < 0.1} {
                set iperf_interval_sec 0.1
            }

            # Setup zero samples for case when iperf is not run.
            set zero_samples ""
            for {set i 1} {$i <= $iperf_sample_size} {incr i} {
                lappend zero_samples 0
            }
            UTF::Message LOG "$::localhost" "iperf_interval_sec=$iperf_interval_sec\
                iperf_sample_size=$iperf_sample_size zero_samples=$zero_samples"

            # Setup stream needed for control chart keys
            # set ::branch_list XyZyX ;# test code
            set stream [UTF::get_stream_name end]

            # A number of routines need to know what directory
            # to put things in.    
            set SummaryLoc [file dirname "$UTF::Logfile"]

            # Set create the csv file. The filename is based on testnum, timestamp, 
            # routerconfig, and Test direction (upstream, downstream).
            set testnum [UTF::get_testnum]
            set timestamp [clock format [clock seconds] -format {%Y_%m_%d_%H_%M}]
            set ResultsFilename "${testnum}_${STA}_${routerConfig}_cycle_$(direction)_${timestamp}.csv"
            set resultsfileId [open "$SummaryLoc/$ResultsFilename" a]
            if {$(pathloss) == 0} {
                set type "Relative"
            } else {
                set type "Estimated"
            }
            puts $resultsfileId "$::testrig $description AP $AP STA $STA ${type}PathLoss $(pathloss)"
            # Columns are organized to avoid reparsing of results from the
            # common test procs. AP stats are created in a block. AP mcs/mpdu
            # distributions are created in a block. Same for STA.
            # NB: When you add a new title here, you need to make sure the
            # actual data is added in the correct place later on!
            set ::csv_titles "$type Path Loss, ApAssocAuthen, ApConnectTime,\
                ApIdleTime, ApMcs, ApNss, ApBw, ApRssi, ApRxRate, ApState, ApTxFailures,\
                ApTxPkts, ApTxRate, ApRxMcs, ApTxMcs, ApMpdu, ApRxMcsSgi, ApTxMcsSgi,\
                ApPer, ApRxVht, ApTxVht, ApRxVhtSgi, ApTxVhtSgi, ApVhtPer, ApDelay, ApCcdf,\
                StaBeaconAssoc, StaMcs, StaNss, StaBw, StaRssi, StaRxRate, StaState, StaTxRate,\
                StaRxMcs, StaTxMcs, StaMpdu, StaRxMcsSgi, StaTxMcsSgi, StaPer,\
                StaRxVht, StaTxVht, StaRxVhtSgi, StaTxVhtSgi, StaVhtPer, StaDelay, StaCcdf,\
                StaMallocFail, TputMean, TputMin, TputMax, LowerControlLimit,\
                UpperControlLimit, StaChanSpec, StaChanInt,\
                ApRxBadFcs, ApRxBadPlcp, ApRxCrsGlitch, ApRxdFrmUcastMbss, ApRxStrt,\
                StaRxBadFcs, StaRxBadPlcp, StaRxCrsGlitch, StaRxdFrmUcastMbss, StaRxStrt,\
		ApPktRequested, ApPktStored, ApPktDropped, ApPktRetried, ApPktRtsFailed, ApPktRetryDropped,\
		ApPktAcked, ApPktRetryRatio, ApPktRetryDropRatio, ApTxbfm, ApTxndp, ApRxsf, ApSfRatio,"
            puts $resultsfileId $::csv_titles
            close $resultsfileId

            # On web summary page, add hyperlink to .csv file for easy access.
            UTF::Try "CSV results file" {
                return "html: <a href=\"$ResultsFilename\">$ResultsFilename</a>"
            }
	
	    # This is 2nd AP or STA, and we firstly append the .csv files from 1st AP or STA, 
	    # so we can make composite graph later.
	    if {($(comparesta) && $::sta_counter == 1 && $::file_appended == 0) || (($(compareap) || $(txbf)) && $::ap_counter == 1 && $::file_appended == 0)} {
		#lappend ::rvr_composite_input "$::saved_ResultsFilenames"
		set ::rvr_composite_input [concat $::rvr_composite_input $::saved_ResultsFilenames]
		# So we only append it once.
		incr ::file_appended
 	    }

            # Higher level scripts need .CSV path and title info to create 
            # composite graphs of all runs.
            if {$(compareap) || $(txbf)} {
		set focus "$AP->$STA"
	    } elseif {$(intsta) != "" && [llength $(intattn)] > 2} {
		# We are doing interference loop test with different attenuations
		set val [lindex $(intattn) $::loop_counter] 
		set focus "${STA}_(int_attn_${val})"
	    } elseif {$(intsta) != "" && [llength $(intwl)] > 1} {
		# We are doing interference loop test with different modes
		set val [lindex $(intwl) $::loop_counter-1] ;# because ::loop_counter is initialized to 1 
		set focus "${STA}_(int_mode_${val})"
	    } elseif {$(titleap)} {
		set focus "$AP->$STA"
            } else {
		set focus "$AP->$STA"
            }
 
	    if {$(comparesta) || $(compareap) || $(txbf)} {
            	lappend ::rvr_composite_input "$SummaryLoc/$ResultsFilename" "CH$(chanspec)_$(direction)_${focus}"
	    } else {
            	lappend ::rvr_composite_input "$SummaryLoc/$ResultsFilename" "Ch=$(chanspec)_$(direction)"
	    }

	    # This is 1st AP or STA, and we save up .csv file.
	    if {($(comparesta) && $::sta_counter == 0) || (($(compareap) || $(txbf)) && $::ap_counter == 0)} {
		set ::saved_ResultsFilenames [concat $::saved_ResultsFilenames "$SummaryLoc/$ResultsFilename Ch=$(chanspec)_$(direction)_${focus}"]
	    }

            # Halt tests if we find duplicate MAC addresses.
            # Duplicate MAC addresses really mess up WET tests, including initial connection.
            UTF::check_mac_addr "$AP $STA"

            # Open connection. Stop tests if this fails.
            # catch "$::rvr_attn_grp attn 103" ;# test code
            if {$::test_mode != 1} {
                UTF::Try "Setup $(security) security connection" {

                    # This is a performance optimization. If pings work in both directions, we are done.
                    # $STA wl disassoc ;# test code
                    set catch_resp [catch "$STA ping $AP -c 2" catch_msg]
                    if {$catch_resp == 0} {
                        # F15 43362SDIO had issues here.
                        set catch_resp [catch "$AP ping $STA -c 2" catch_msg]
                        if {$catch_resp == 0} {
                            return "(skipped)"
                        } else {
                            UTF::Message WARN "" $catch_msg
                        }
                    } else {
                        UTF::Message WARN "" $catch_msg
                    }

                    # Allow 3 tries to open connection
                    set tries 3

                    # WET test is handled differently
                    if {$(wet)} {
                        return [UTF::open_wet_retry $AP $STA $tries $(security)]
                    }

                    # Regular association STA to AP, 
                    if {$::is_oem_ap} {
                         set catch_resp [catch "UTF::join_oem_ap_retry \"$oem_ssid\" $STA $(chanspec) $tries $(security)" catch_msg]
                    } else {
                        set catch_resp [catch "UTF::open_connection_retry $AP $STA $tries $(security)" catch_msg]
                    }

                    if {$catch_resp == 0} {
                        return $catch_msg
                    } else {
                        error $catch_msg
                    }

		    # Allow for error when connection opens OK on the retry.
                    if {$catch_resp != 0 && ![regexp {succeeded\s+on\s+try:} $catch_msg]} {
                    	error "Halting tests, could not open connection!"
                    }
                }
		
		# Tell AP to start collecting rssi info
		catch "$AP wl rssi $testStaMac"

		# Check chanspec. Stop tests if this fails.
            	UTF::check_chanspec "$AP $STA" $(chanspec)		

		if {$(musta) != ""} {
		    foreach MUSTA $(musta) {
		    	UTF::Try "Setup $(security) security connection for $MUSTA" {
                            set catch_resp [catch "$MUSTA ping $AP -c 2" catch_msg]
                            if {$catch_resp == 0} {
                            	set catch_resp [catch "$AP ping $MUSTA -c 2" catch_msg]
                            	if {$catch_resp == 0} {
                                    return "(skipped)"
                            	} else {
                                    UTF::Message WARN "" $catch_msg
                            	}
                            } else {
                            	UTF::Message WARN "" $catch_msg
                            }

			    # Allow 3 tries to open connection
			    set tries 3

			    # Make association MUSTA to AP
                            set catch_resp [catch "UTF::open_connection_retry $AP $MUSTA $tries $(security)" catch_msg]
                            if {$catch_resp == 0} {
                            	return $catch_msg
                            } else {
                            	error $catch_msg
                            }

                            if {$catch_resp != 0 && ![regexp {succeeded\s+on\s+try:} $catch_msg]} {
                            	error "Halting tests, could not open connection for $MUSTA!"
                            }

			    # Allow for error when connection opens OK on the retry.
                    	    if {$catch_resp != 0 && ![regexp {succeeded\s+on\s+try:} $catch_msg]} {
                            	error "Halting tests, could not open connection for $MUSTA!"
                    	    }
		    	}

		    	# Tell AP to start collecting rssi info
		    	#catch "$AP wl rssi $testMuStaMac"

		    	# Check chanspec. Stop tests if this fails
		    	UTF::check_chanspec "$AP $MUSTA" $(chanspec)
		    }
		}
            }

            # Use of interference STA is optional
            setup_int_sta $(intsta) $band $(intattn) $(intchan) $(inttype) $(intrate) $(intnrate) $(intgap) $(intsize) $(intquiet)

            # Get current ssid from actual AP device, not what the config file
            # object thinks it might be. Same command works for SoftAP.
            # NB: Do this after connection has been opened, to ensure SoftAP ssid is set!
            if {$::is_oem_ap} {
                set apSsid "$oem_ssid"
            } else {
                set apSsid [$AP wl ssid]
            }
            UTF::Message LOG "" "$ap_type ssid: $apSsid"

            # Router is required to have a LAN traffic generator.
            if {$(softap)} {
                # For softap, iperf traffic generator is on the softap host PC.
                set LAN $AP
            } else {
                # For real AP & OEM AP, -lanpeer option points to traffic generator.
                set LAN [$AP lan]
                # set LAN  " " ;# test code
                set LAN [string trim $LAN]
                if {$LAN == ""} {
                    error "Halting tests, no LAN traffic generator found!"
                }
            }

            # Edit the optional perf_hooks, etc to reduce test time.
            edit_hooks $AP $LAN $STA $(allhooks) $(edithooks) $(nohooks) 

            # Optionally run iperf for 60 secs to stabilize rate.
            warmup_test $LAN $STA $(direction) $(window) $(va) $(warmup)

            # Initialization for ******** main data collection loop ********
            if {$::test_mode == 1 || $::test_mode == 2} {
                set (attnlist) "0-1 1-0" ;# test code for shorter tests
            }
            set attn_element_cnt 0 ;# counter for main foreach loop.
            set attn_element_total [llength $(attnlist)]
            if {$(rampdownonly) || $(rampuponly) || $attn_element_total == 1} {
                set plot_graph_ctl 1 ;# do all graphs
            } else {
                set plot_graph_ctl 0 ;# start with just the rampdown graph
            }
            UTF::Message LOG "$::localhost" "(attnlist)=$(attnlist)\
                attn_element_total=$attn_element_total\
                plot_graph_ctl=$plot_graph_ctl"
            set ::aux_desc ""
            set ::intsta_activity "" ;# used by monitor_interference
            set ::intwl_errors "" 
            set ::iperfRamp "" ;# needed by proc iperf_ramp
            set ::monitor_rampdown_steps "" ;# needed by proc monitor_rampup issues
            set ::monitor_rampup_good_tput_cnt 0
            set ::process_cc_results_list "" ;# used for trend error analysis
            set ::rejoin_old_state "ASSOCIATED BEACONS" ;# needed by proc rejoin
            set ::ap_old_state "AUTHENTICATED ASSOCIATED" ;# needed by proc track_ap_state
            set ::sta_scale_factor 0 ;# used to scale beacon/assoc state data
            set rampdown_attn_range "" ;# save rampdown attenuator range
            set ::refresh_addr "" ;# tracks when to do dhcp
            set ::rvr_rampdown_no_beacons_list "" ;# tracks consecutive no beacon states
            set ::rvr_rampup_no_beacons_list ""
            set ::rvr_rampdown_rates_list "" ;# tracks MCS/Legacy rates
            set ::rvr_rampup_rates_list ""
            set ::rvr_fastrampup_active 0;# indicates fastrampup in progress
            set ::rvr_fastrampup_duration 0;# duration counter for fastrampup test
            set ::rvr_malloc_fail_errors 0;# malloc fail errors
            set ::rvr_rejoin_result "" ;# attn & iperf samples for controlchart use
            set ::sniffer_capture_active "" ;# on/off sniffer state for large .pcap file
            set ::sniffer_capture_index "" ;# current index into list of sniffer commands for large .pcap file(s)
            set cc_samples "" ;# needed by choose_attn_step.
            set pretest_cnt 0 ;# keep track of controlchart warmup pretests
            set start_rampup_step ""
            set tput_mean 0 ;# needed by warmup tests.
            setup_rvr_symmetry
            # set (chanint) 1 ;# test code

            # We may need the wl counter data saved.
            if {$(intsta) != "" || $(intgraph)} {
                UTF::access_counters $AP savecurrent silent
                UTF::access_counters $STA savecurrent silent
            }

            # If necessary, repeat the step pattern for a longer test.
            set (steplist) [string trim $(steplist)]
            if {$(steplist) != "" && $(steploop) > 1} {
                set (nosymmetry) 1
                set temp $(steplist)
                for {set i 2} {$i <= $(steploop)} {incr i} {
                    append (steplist) " $temp"
                }
            }

            # Step list is just an arbitrary series of steps for the attenuator.
            set ::step_total [llength $(steplist)]
            set ::step_index 0
            if {$::step_total > 0} {
                # Pretend there is only 1 element to process
                set (attnlist) [lindex $(steplist) $::step_index]

                # Do all graphs. If we do only the rampdown graph, what happens
                # is that only the first few steps get show, as the graph routine
                # stops when it sees the attenuator going back to 0, which is
                # normally the rampup data.
                set plot_graph_ctl 1 
            }

            # Main RvR test data collection loop starts here.
            # Process each element in attnlist, eg: 0-50
            foreach attnelement $(attnlist) {
                if {[regexp {^(\d+)\-(\d+)$} $attnelement - range1 range2]} {
                    # element is of form "x-y"
                    # For x LE y, attnDirection up == rampdown test
                    if {$range1 <= $range2} {
                        set step $range1
                        set attnDirection up ;# rampdown test
                        set rampdown_attn_range "$range1 $range2"
                        set ::aux_desc "RampDown"

                    } else {
                        # attnDirection down == rampup test
                        set step $range1
                        set attnDirection down ;# rampup test
                        set ::aux_desc "RampUp"
                        # If we stopped the rampdown test due to no beacons, then
                        # we adjust the rampup test to the same starting step.
                        if {$start_rampup_step != ""} {
                            set step $start_rampup_step
                        }
                    }

                } elseif {[regexp {^\d+$} $attnelement]} {
                    # element is one integer
                    set step   $attnelement
                    set range1 $attnelement
                    set range2 $attnelement
                    set attnDirection up
                    set ::aux_desc "RampDown"

                } else {
                    error "ERROR: Invalid attnlist element: $attnelement"
                }

                # If rampdownonly option was specified, we exit after
                # processing one attn_element
                incr attn_element_cnt
                if {$attn_element_cnt > 1 && $(rampdownonly)} {
                    UTF::Try "User requested rampdownonly!" {
                        return
                    }
                    break
                }

                # If rampuponly option was specified, we skip the first
                # attn_element and move on to the second attn_element.
                if {$attn_element_cnt == 1 && $(rampuponly)} {
                    UTF::Try "User requested rampuponly!" {
                        return
                    }
                    continue
                }

                # Loop to collect data for the current attnelement.
                while {($step >= $range1 && $step <= $range2) ||\
                    ($step >= $range2 && $step <= $range1) ||
                    $::step_index < $::step_total} {

                    # NB: Changing variable step is done at the end of the loop.
                    # If we do a continue here, we get into infinite loop.
                    # NB: These items are done here so they can selectively
                    # add an entry on the main web page as needed.
                    UTF::set_attn_grp $step
                    set sta_malloc_fail [check_malloc_fail $STA $(nomalloc) $routerConfig $(direction)]
                    iperf_ramp $STA $LAN $(direction) $attnDirection $(window) $tput_mean $(warmup)

                    # Do control chart & data collection inside the same utf_try
                    # so that all related data is in the same logfile.
                    set arrow [set_arrow_label $STA $LAN $(direction)]
                    set loss [expr $step + $(pathloss)]
                    UTF::Try "$routerConfig $(direction) Attn: $step Loss: $loss $arrow $::aux_desc" {

                        # NB: We separate the rampdown perfcache data from the rampup data.
                        # NB: We also separate perfcache data by chanspec.
                        set keys "$stream $AP ${routerConfig}$(direction)${step}Ch$(chanspec)Attn${attnDirection}"

                        # For rvr symmetry control charts, set key_template to find the
                        # rampdown / attenuation up data files. {step} is a placeholder.
                        # While this variable is needed only much later on, it is set here
                        # to keep it in sync with other updates done for variable keys.
                        set key_template "$stream $AP ${routerConfig}$(direction)\{step\}Ch$(chanspec)Attnup"

                        # Update keys & key_template for security, fb1, fastrampup, udp, interference & steplist
                        if {$(security) != "open"} {
                            append keys " $(security)"
                            append key_template " $(security)"
                        }
                        if {$::rvr_fb == 1} {
                            append keys " fb1"
                            append key_template " fb1"
                        }
                        if {$::rvr_fastrampup_active > 0} {
                            append keys " fr$::rvr_fastrampup_duration"
                            append key_template " fr$::rvr_fastrampup_duration"
                        }
                        if {$(udp) > 0} {
                            append keys " udp"
                            append key_template " udp"
                        }
                        if {$(intsta) != ""} {
                            # Including attn grp name & inteference setting allows tracking of
                            # history for all sorts of different tests.
                            append keys " intCh=${::int_chan} $::intNrate attn=$::rvr_attn_grp int=$intwlval"
                            append key_template " intCh=${::int_chan} $::intNrate attn=$::rvr_attn_grp int=$intwlval"
                        }

                        if {$(steplist) != ""} {
                            append keys " sl${::step_index}"
                            append key_template " sl${::step_index}"
                        }

                        UTF::Message INFO "" "step=$step loss=$loss\
                            keys=$keys iperf_interval_sec=$iperf_interval_sec\
                            iperf_sample_size=$iperf_sample_size"
                        UTF::ampdu_clear $AP $STA 0 $::is_oem_ap

                        # Make sure we dont pick up data from previous test.
                        set catch_msg_cc ""
                        set catch_resp_cc 0
                        set CC(Lx) 0
                        set CC(mmm) "0 0 0"
                        set CC(samples) ""
                        set CC(Ux) 0
                        set mmm "0 0 0"
                        set tput_mean 0

                        # Setup ylabel, units & title for this specific controlchart graph
                        set transport TCP
                        if {$(udp) > 0} {
                            set transport UDP
                        }
                        set cc_ylabel "Throughput $transport"
                        set cc_unit "Mbit/sec"
                        set temp [UTF::get_testnum] ;# need current value, not value used in csv filename
                        set cc_title "$::testrig ${temp}.log $routerConfig $(direction) Attn $step $arrow $::aux_desc"

                        # If STA has no beacons, iperf will get 0 throughput,
                        # so skip tests, unless user specified -iperfnobeacons.
                        # Get controlchart results. Use sniffer if requested.
                        UTF::start_sniffer $(sniffer) $(ringfilecnt) $(ringfilesize) $(sniffercapture) $::aux_desc $step
                        # set ::rejoin_old_state ROAMING ;# test code
                        set skipped_iperf 0 ;# another optimization
                        if {![regexp -nocase {BEACONS} $::rejoin_old_state] && $(iperfnobeacons) == 0} {
                            # Add samples of all zeros to the control chart.
                            set skipped_iperf 1
                            set catch_resp_cc [catch {UTF::update_control_chart_data $keys $zero_samples 0 CC "LOW|WIDE" $STA $LAN $(direction) $iperf_sample_size $(history) "$cc_title" "$cc_unit" "$cc_ylabel"} catch_msg_cc]
                            append catch_msg_cc " NULL BSSID, skipped iperf" ;# so user will know
                        } else {
			    # test_mde=1 means to skip the actual test for debugging purpose.
                            if {$::test_mode != 1} {
				# Assemble device list for passing to Multiperf and controlchart.
				set device_list {}	
				if {$(direction) == "Upstream"} {
				    if {$(musta) != "" && $MUSTA4 != ""} {
					set device_list [list $STA $AP $MUSTA1 $AP $MUSTA2 $AP $MUSTA3 $AP $MUSTA4 $AP]
				    } elseif {$(musta) != "" && $MUSTA3 != ""} {
					set device_list [list $STA $AP $MUSTA1 $AP $MUSTA2 $AP $MUSTA3 $AP]
				    } elseif {$(musta) != "" && $MUSTA2 != ""} {
					set device_list [list $STA $AP $MUSTA1 $AP $MUSTA2 $AP]
				    } elseif {$(musta) != "" && $MUSTA1 != ""} {
					set device_list [list $STA $AP $MUSTA1 $AP]
				    } else {
					set device_list [list $STA $AP]
				    }
				} else {
                                    if {$(musta) != "" && $MUSTA4 != ""} {
                                        set device_list [list $AP $STA $AP $MUSTA1 $AP $MUSTA2 $AP $MUSTA3 $AP $MUSTA4]
                                    } elseif {$(musta) != "" && $MUSTA3 != ""} {
                                        set device_list [list $AP $STA $AP $MUSTA1 $AP $MUSTA2 $AP $MUSTA3]
                                    } elseif {$(musta) != "" && $MUSTA2 != ""} {
                                        set device_list [list $AP $STA $AP $MUSTA1 $AP $MUSTA2]
                                    } elseif {$(musta) != "" && $MUSTA1 != ""} {
                                        set device_list [list $AP $STA $AP $MUSTA1]
                                    } else {
                                        set device_list [list $AP $STA]
                                    }
				}

                                # For TCP, always do the warmup pretest on the first test.
                                # After the first TCP test, user may choose to skip the pretests.
                                # For UDP, skip all pretests.
				if {($(nopretest) == 1 && $pretest_cnt > 0) || $(udp) > 0} {
				    UTF::Message LOG "" "No warm-up test requested"
				} else {
				    UTF::Message LOG "" "Multiperf test to stabilize rate"
				    UTF::Message LOG "" "device_list: $device_list"
				    eval set catch_resp_mp [catch {UTF::Multiperf $device_list -t 0.5 -b 0} catch_msg_mp]
				    UTF::Message LOG "" "catch_resp_mp=$catch_resp_mp, catch_msg_mp=$catch_msg_mp"

				    # Call wl pktq_stats here to clear the data from pretest.
				    UTF::Message LOG "" "Calling pktq_stats to clear pretest data:"
				    UTF::ap_pktq_stats $AP 0 0
				}

				# Assemble commands for passing to controlchart.
				set cc_cmd "controlchart \"$device_list\" -nopretest"
                                append cc_cmd " -key \"$keys\" -i $iperf_interval_sec -s $iperf_sample_size -min $(min) -max $(max) -loop $(perfloop) -history $(history) -window $(window) -stats CC"
                                if {[regexp {^\d+$} $(pingmax)] && $(pingmax) > 0} {
                                    append cc_cmd " -pingmax \"$(pingmax)\""
                                }

                                # For UDP, specify adapted offer rate & extra options.
                                if {$(udp) > 0} {
                                    if {$(udpopt) == ""} {
                                        append cc_cmd " -iperf \"-b $(udp)M\""
                                    } else {
                                        append cc_cmd " -iperf \"-b $(udp)M $(udpopt)\""
                                    }
                                }

                                # Add ylabel & title for this specific controlchart graph
                                append cc_cmd " -ylabel \"$cc_ylabel\" -title \"$cc_title\""

                                # Run the control chart command.
                                # puts "\n\n cc_cmd=$cc_cmd"
                                eval set catch_resp_cc [catch $cc_cmd catch_msg_cc]
                                # puts "\n\ncatch_resp_cc=$catch_resp_cc catch_msg_cc=$catch_msg_cc\n\n"
                                incr pretest_cnt
                            }
                        }

                        # controlchart.test now provide results in variables in
                        # user specified array CC.
                        set mmm $CC(mmm) ;# mean min max
                        set tput_mean [lindex $mmm 0] ;# used by several routines
                        set cc_samples $CC(samples)
                        # parray CC

                        # Setup scale factors for beacon / assoc state data
                        UTF::setup_scale_factors $tput_mean

                        # Get stats.
                        set ap_ampdu        [UTF::ap_ampdu $AP 0 $::is_oem_ap]
                        set ap_stats        [UTF::ap_stats $AP $STA $testStaMac $::is_oem_ap]
                        set sta_ampdu       [UTF::sta_ampdu $STA]
                        set sta_stats       [UTF::sta_stats $STA]
                        set sta_chaninfo    [UTF::sta_chan_info $STA $(chanint)]
                        set ap_delay_stats  [UTF::delay_stats $AP $::is_oem_ap]
                        set sta_delay_stats [UTF::delay_stats $STA 0]
                        set ap_pktq_stats   [UTF::ap_pktq_stats $AP 0 $::is_oem_ap]
                        set ap_txbf_stats   [UTF::ap_txbf_stats $AP 0 $::is_oem_ap]

                        # Check on interference source, if any.
                        set int_stats [monitor_interference $(intsta) $(intgraph) $(inttype) $AP $STA $step $(intquiet) $intwlval]

                        # Add data for this path loss to the .csv results file.
                        # Individual stats/ampdu strings have commas embedded.
                        # NB: The order of the data added here absolutely must
                        # match the order of the titles specified in ::csv_titles!
                        set resultsfileId [open "$SummaryLoc/$ResultsFilename" a]
                        puts $resultsfileId "$loss, $ap_stats\
                            $ap_ampdu $ap_delay_stats $sta_stats $sta_ampdu $sta_delay_stats $sta_malloc_fail,\
                            $tput_mean, [lindex $mmm 1], [lindex $mmm 2], $CC(Lx), $CC(Ux), $sta_chaninfo\
                            $int_stats $ap_pktq_stats $ap_txbf_stats"
                        close $resultsfileId

                        # Save attnDown / rampup samples for symmetry test.
                        if {$attnDirection == "down"} {
                            set ::rvr_rampup_data($step) $CC(samples)
                            UTF::Message LOG "" "CC(samples)=$CC(samples)"
                        }

                        # If we ran iperf, for 0 thruput, restart iperf to cleanup any zombie
                        # processes that may be left. No need to do this if we skipped iperf.
                        if {!$skipped_iperf} {
                            UTF::restart_iperf $tput_mean $LAN $STA
                        } else {
                            # iPerf is skipped, give some time say -perftime <arg> seconds for driver to re-connect
                            # When mpc is enabled, Linux STA should behave similar to Windows STA, should disconnect
                            # and should do roam scan. Currently mpc is not working as expected, so wait few seconds 
                            UTF::Sleep $iperf_total_sec
                        }

                        # Sample custom stoponerror condition. This will tell progressive_recovery
                        # that we are in trouble, which in turn signals the higher level script to
                        # stop immediately.
                        # if {$(stoponerror) && $tput_mean <= 20 && $step <= 40} {
                        #     set var2 "::${STA}_state"
                        #     set $var2 CustomError
                        #     UTF::Message ERROR $STA "CustomError tput_mean=$tput_mean step=$step"
                        # }

                        # Process the results of controlchart.
                        UTF::process_cc_results $catch_resp_cc $catch_msg_cc $(trenderrors) $loss
                    } ;# End UTF::Try block

                    # Rejoin as needed. Rejoin is done here so result will 
                    # appear on web page at same level as control chart results.
                    set sta_reassoc [rejoin $apSsid $STA $step $(pathloss) $(noredundant) $(refreshaddralways) $(refreshaddrasneeded) $routerConfig $(direction) $::is_oem_ap $(chanspec)]
                    track_ap_state $AP $testStaMac $step $(pathloss) $(noredundant) $sta_reassoc $routerConfig $(direction) $::is_oem_ap

                    # Stop sniffer is done here so result will appear on web 
                    # page at same level as control chart results.
                    set capt 0
                    if {$catch_resp_cc || $(forcesniffercapture)} {
                        set capt 1
                    }
                    UTF::stop_sniffer $(sniffer) $capt $SummaryLoc $(ringfilecnt) $(sniffercapture) $::aux_desc $step

                    # Have we exceeded our allocated overall test time?
                    # On timeout, we need to gracefully exit the loop so
                    # that we will plot the graphs of the incomplete data.
                    set test_timeout [overall_timeout $(keepgoing) $routerConfig $(direction)]
                    if {$test_timeout == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Take recovery action as needed. If we exceeded our recovery
                    # maximum, we gracefully exit the loop and do graphs.
                    set start_up 0
                    set ::stop_tests [UTF::progressive_recovery "$AP $STA" $(keepgoing) $(security) $start_up $::rvr_fb $(chanspec) $oem_band $(stoponerror)] 
                    if {$::stop_tests == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Monitor MCS / Legacy rates.
                    monitor_rates $STA $step $attnDirection

                    # Monitor beacon activity. Stop the rampdown test after N consecutive no-beacons
                    # unless user specified the fullrange option.
                    set stop_rampdown [monitor_beacons $step $(attnstep) $attnDirection $(fullrange)]
                    if {$stop_rampdown == "yes"} {
                        # NB: We are just cutting the rampdown test short here.
                        # Dont change plot_graph_ctl. Keep going with the main
                        # outer loop.
                        set start_rampup_step $step ;# save for rampup test
                        break
                    }

                    # Check for severe rejoin / no rampup issue
                    set stop_rampup [monitor_rampup_issues $tput_mean $step $attnDirection\
                        $(fullrampup) $(stopslowrampup)]
                    if {$stop_rampup == "yes"} {
                        incr plot_graph_ctl ;# ensure we do all graphs
                        break ;# stop inner while test loop
                    }

                    # Choose the next value the attenuator will use.
                    # Attenuator itself is adjusted at the top of the loop.
                    set step [choose_attn_step $step $(attnstep) $attnDirection $range2 $(fastrampup) $tput_mean $(steplist) $cc_samples]
                    if {$::rvr_fastrampup_active >= 2} {
                        break ;# stop inner while test loop
                    }

                } ;# End while attnelement

                # Run rvr symmetry control charts.
                rvr_symmetry_control_charts $attnDirection $key_template $STA $LAN\
                    $(direction) $arrow $(pathloss) "$SummaryLoc/$ResultsFilename"\
                    $rampdown_attn_range $start_rampup_step $(attnstep)\
                    $iperf_sample_size $zero_samples $(history) $(fastrampup)\
                    $routerConfig

                # We have completed data collection for an attnelement.
                # For the first attnelement, we can now create just the rampdown
                # throughput graph, as we have the required data. For the 
                # second attnelement, we create the other graphs, but not the
                # rampdown throughput graph. Use common graph routine.
                set legend "$TestAPBand, $TestAPCapacity, ${TestAPChannel}${bw},"
                plot_graphs "$SummaryLoc/$ResultsFilename" "$GPFFileName" $legend $focus $AP $STA\
                    $routerConfig $(direction) $type $arrow $plot_graph_ctl $(nohistograms)\
                    $(rampdownonly) $sta_malloc_fail $(nomalloc) $(chanint) $(fastrampup)\
                    $(nosymmetry) $(udp) $::is_oem_ap $(nographs) $(mingraphs) $(intsta) $(intgraph) $(chanspec)
                incr plot_graph_ctl

                # Stop outer foreach test loop on timeout, excess recovery or
                # severe rejoin rampup issue.
                if {$test_timeout == "yes" || $::stop_tests == "yes"||\
                   $stop_rampup == "yes"} {
                     break 
                }

            } ;# End foreach element in attnlist

            # Turn off optional interference STA
            stop_int_sta $(intsta) $(intgraph) $(inttype) $(intquiet) $routerConfig $(direction)

            # Its possible the sniffer was left on due to some weird combination of
            # sniffer start/stop steps, so use the force option to ensure sniffer is off.
            set result 0
            set force 1
            UTF::stop_sniffer $(sniffer) $result $SummaryLoc $(ringfilecnt) $(sniffercapture) $::aux_desc $step $force

            # Check AP connect time for more than one drop to zero
            check_ap_connect_time "$SummaryLoc/$ResultsFilename" $ap_type $(attnstep) $routerConfig $(direction) $::is_oem_ap

            # Check for optional trend errors.
            check_trend_errors $(trenderrors) $routerConfig $(direction)

            # Did we get any malloc fail errors?
            # set ::rvr_malloc_fail_errors "dummy error" ;# test code 
            if {$::rvr_malloc_fail_errors != "0"} {
                # Push the malloc fail total errors to the main web page.
                UTF::Try "$routerConfig $(direction) $STA malloc fail errors" {
                    error "$::rvr_malloc_fail_errors, see malloc fail graph for details"
                }           
            }

            # End of of all data collection tests. Reset attenuator to default.
            UTF::set_attn_grp $user_attn_start_value

            # Do control charts for beacons, MCS/Legacy rate adaptations.
            beacon_cc     $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec) $(attnstep)
            rate_adapt_cc $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec) $(attnstep) $(fastrampup)

            # Do 2 separate control charts for rejoin results. Push result to main web page
            rejoin_cc $STA $LAN $routerConfig $(direction) $(history) $key_template $(nocache) $(udp) $focus $(chanspec)
            return $::rejoin_cc_result

        } ;# End UTF::Try for complete script
    } ;# End WebSummary
} ;# End UTF::Test
