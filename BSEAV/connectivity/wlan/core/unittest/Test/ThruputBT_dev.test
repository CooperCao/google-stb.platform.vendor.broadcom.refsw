#!/bin/env utf
# -*-tcl-*-

# To get online help, type: Test/ThruputBT.test -h

# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::ThruputBT_help "\n\nBasic usage: Test/ThruputBT.test bt_dut bt_ref <options>\
    \n\nThis script does a thruput test on 2 BlueTooth devices. Optionally, iperf\
    \ntraffic can be run concurrently between 2 WLAN devices. bt_dut & bt_ref\
    \nare the BT object STA names defined in your config file.\
    \n\nprofile 0: runs only BT traffic on the existing connection\
    \nprofile 1: runs only WLAN iperf traffic on the existing connection\
    \nprofile 2: runs both BT & WLAN traffic on the existing connections\
    \n
    \nFor isochronous/A2DP tests, provide the following options:\
    \n -iso_interval        Isochronous traffic interval, typical value: 20\
    \n -iso_delay_tolerance Isochronous traffic delay tolerance, typical value: 100\
    \n -block_size          Write block size for isochronous traffice, typical value: 840\
    \n\nvalid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
# changed perftime to 10 from 30; perfsize to 5 from 15 as of 6/4/15
set ::ThruputBT_getopts {
    {bt_dir.arg "bidirectional"    "BT test direction: bidirectional dut2ref ref2dut"}
    {bt_pkt.arg auto               "BT packet type for connection"}
    {bt_test.arg "acl"             "BT test type: acl, sco (n/a is allowed for profile 1)"}
    {bt_slave_test.arg "0"         "BT master or slave test"}
    {handle_acl_master.arg ""      "ACL handle for existing bt_master connection, default is to use handle stored in object"}
    {handle_acl_slave.arg ""       "ACL handle for existing bt_slave connection, default is to use handle stored in object"}
    {handle_sco_master.arg ""      "SCO/ESCO handle for existing bt_dut connection, default is to use handle stored in object"}
    {handle_sco_slave.arg ""       "SCO/ESCO handle for existing bt_ref connection, default is to use handle stored in object"}
    {key.arg ""                    "Keys to keep perfcache data separated by test, sta, etc"}
    {history.arg 30                "Performance history samples to keep in perfcache data"}
    {perfint.arg 2                 "Test interval in seconds for each test sample"}
    {perfloop.arg 1                "Total performance test iterations"}
    {perfsize.arg 5               "Number of samples stored in each entry of controlchart & perfcache file"}
    {perftime.arg 10               "Total time duration, in seconds, for each performance tests"}
    {profile.arg 2                 "See above descriptions"}
    {title.arg ""                  "Title text for time plot graph"}
    {window.arg 512k               "Tcp Window for iperf tests"}
    {wlan_dir.arg "bidirectional"  "WLAN test direction: bidirectional dut2tg tg2dut"}
    {wlan_dut.arg ""               "optional STA object name for WLAN DUT"}
    {wlan_tg.arg ""                "optional STA object name for WLAN traffic generator"}
    {wlan_relay.arg ""             "optional STA object name for WLAN DUT relay"}
    {tx_sound_file.arg "or105-25sec.wav"    "BT SCO/ESCO transmit sound file"}
    {attn_type.arg 0  "Types of RvR attenuation: 0=None, 1=WLAN, 2=BT, 3=Coex. Default is 0 (none)"}    
    {iso_interval.arg ""           "Interval in ms for isochronous traffic, typical value: 20"}
    {iso_delay_tolerance.arg ""    "Delay tolerance in ms for isochronous traffic, typical value: 100"}
    {block_size.arg ""             "Traffic block size in bytes for isochronous traffic, typical value: 840"}
}

# Setup online help info.
UTF::setup_help $::ThruputBT_help $::ThruputBT_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any
# additional code in this script.

# Load packages
package require UTF
package require UTF::ControlChart
package require UTF::utils
package require UTF::WinBT
package require UTF::Test::ConnectBTdevices

namespace eval ThruputBT {}
package provide UTF::Test::ThruputBT_dev 2.0

#======================= Common procs for this test suite =====================

#======================= setup ================================================
# Setup routine for throughput tests.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# array1 is normally set to "" to access the unamed array of calling
# options parsed by the calling routine.
# Returns nothing, throws errors as needed.
#==============================================================================

proc ThruputBT::setup {bt_dut bt_ref array1} {
    upvar $array1 array2 ;# gives R/W access to array1

    # Check both BT STA's exist and are correct type
    UTF::check_sta_type $bt_dut WinBT
    UTF::check_sta_type $bt_ref WinBT
    
    # Check BT STAs are different
    if {$bt_dut == $bt_ref} {
       error "ThruputBT setup ERROR: bt_dut=$bt_dut MUST NOT be same as\
           bt_ref=$bt_ref!"
    }

    # If either WLAN STA is specified, then they must both exist,
    # be the correct type and be different.
    set ::ThruputBT::wlan_dut $array2(wlan_dut)
    set ::ThruputBT::wlan_dut [string trim $::ThruputBT::wlan_dut]
   
    # HSIC case: when wlan_relay present in conf file
    set ::ThruputBT::wlan_relay $array2(wlan_relay)
    set ::ThruputBT::wlan_relay [string trim $::ThruputBT::wlan_relay]
    if { $::ThruputBT::wlan_relay != "" } {
       UTF::Message DEBUG "" "::ThruputBT::wlan_relay present: $::ThruputBT::wlan_relay"
    } else {
	   UTF::Message DEBUG "" "::ThruputBT::wlan_relay not present."
    }

    set ::ThruputBT::wlan_tg $array2(wlan_tg)
    set ::ThruputBT::wlan_tg [string trim $::ThruputBT::wlan_tg]
    if {$::ThruputBT::wlan_dut != "" || $::ThruputBT::wlan_tg != ""} {
        if {$::ThruputBT::wlan_dut == "" || $::ThruputBT::wlan_tg == ""} {
            error "ThruputBT setup ERROR: When one WLAN device is specified,\
                they both must be specified, wlan_dut=$::ThruputBT::wlan_dut\
                wlan_tg=$::ThruputBT::wlan_tg"
        }
        UTF::check_sta_type $::ThruputBT::wlan_dut "$::coex_sta_type_list"
        UTF::check_sta_type $::ThruputBT::wlan_tg Linux
        if {$::ThruputBT::wlan_dut == $::ThruputBT::wlan_tg} {
            error "ThruputBT setup ERROR: wlan_dut=$::ThruputBT::wlan_dut MUST\
                NOT be same as wlan_tg=$::ThruputBT::wlan_tg!"
        }
    }

    # Validate the BT test direction.
    set ::ThruputBT::bt_dir $array2(bt_dir)
    set ::ThruputBT::bt_dir [string trim $::ThruputBT::bt_dir]
    set ::ThruputBT::bt_dir [string tolower $::ThruputBT::bt_dir]
    set bt_dir_list "bidirectional dut2ref ref2dut"
    set i [lsearch -exact $bt_dir_list $::ThruputBT::bt_dir]
    if {$i < 0} {
        error "ThruputBT setup ERROR: Invalid bt_dir=$::ThruputBT::bt_dir,\
            must be one of: $bt_dir_list"
    }

    # Validate the WLAN test direction.
    set ::ThruputBT::wlan_dir $array2(wlan_dir)
    set ::ThruputBT::wlan_dir [string trim $::ThruputBT::wlan_dir]
    set ::ThruputBT::wlan_dir [string tolower $::ThruputBT::wlan_dir]
    set wlan_dir_list "bidirectional dut2tg tg2dut"
    set i [lsearch -exact $wlan_dir_list $::ThruputBT::wlan_dir]
    if {$i < 0} {
        error "ThruputBT setup ERROR: Invalid wlan_dir=$::ThruputBT::wlan_dir,\
            must be one of: $wlan_dir_list"
    }

    # Set traffic script names based on test type.
    set ::ThruputBT::bt_test $array2(bt_test)
    set ::ThruputBT::bt_test [string trim $::ThruputBT::bt_test]
    set ::ThruputBT::bt_test [string tolower $::ThruputBT::bt_test]
    set ::ThruputBT::bt_slave_test $array2(bt_slave_test)

    set ::ThruputBT::handle_dut ""
    set ::ThruputBT::handle_ref ""

    if {$::ThruputBT::bt_test == "acl" || $::ThruputBT::bt_test == "sco"} {
        # we do not need to do the following portion since bt_master bt_slave 
        # is passed to ThruputBT.test instead of bt_ref & bt_dut
        #if {$::ThruputBT::bt_slave_test == 0} {
        #   # master test
        #   set ::ThruputBT::handle_acl_dut $array2(handle_acl_master)
        #   set ::ThruputBT::handle_dut $::ThruputBT::handle_acl_dut
        #   set ::ThruputBT::handle_acl_ref $array2(handle_acl_slave)
        #   set ::ThruputBT::handle_ref $::ThruputBT::handle_acl_ref
        #} else {
        #   # slave test
        #   set ::ThruputBT::handle_acl_dut $array2(handle_acl_slave)
        #   set ::ThruputBT::handle_dut $::ThruputBT::handle_acl_dut
        #   set ::ThruputBT::handle_acl_ref $array2(handle_acl_master)
        #   set ::ThruputBT::handle_ref $::ThruputBT::handle_acl_ref
        #}
        set ::ThruputBT::handle_acl_dut $array2(handle_acl_master)
        set ::ThruputBT::handle_dut $::ThruputBT::handle_acl_dut
        set ::ThruputBT::handle_acl_ref $array2(handle_acl_slave)
        set ::ThruputBT::handle_ref $::ThruputBT::handle_acl_ref
        
        set ::ThruputBT::tx_script common/ThroughputTxTest.pl
        set ::ThruputBT::rx_script common/ThroughputRxTest.pl

        if {$::ThruputBT::bt_test == "sco"} {
            # we do not need to do the following portion since bt_master bt_slave
            # is passed to ThruputBT.test instead of bt_ref & bt_dut
            #if {$::ThruputBT::bt_slave_test == 0} {
            #  # master test
            #   set ::ThruputBT::handle_sco_dut $array2(handle_sco_master)
            #   set ::ThruputBT::handle_dut $::ThruputBT::handle_sco_dut
            #   set ::ThruputBT::handle_sco_ref $array2(handle_sco_slave)
            #   set ::ThruputBT::handle_ref $::ThruputBT::handle_sco_ref
            #} else {
            #   # slave test
            #   set ::ThruputBT::handle_sco_dut $array2(handle_sco_slave)
            #   set ::ThruputBT::handle_dut $::ThruputBT::handle_sco_dut
            #   set ::ThruputBT::handle_sco_ref $array2(handle_sco_master)
            #   set ::ThruputBT::handle_ref $::ThruputBT::handle_sco_ref
            #}
            set ::ThruputBT::handle_sco_dut $array2(handle_sco_master)
            set ::ThruputBT::handle_dut $::ThruputBT::handle_sco_dut
            set ::ThruputBT::handle_sco_ref $array2(handle_sco_slave)
            set ::ThruputBT::handle_ref $::ThruputBT::handle_sco_ref

            set ::ThruputBT::tx_script common/SCOTxTest.pl
            set ::ThruputBT::rx_script common/SCORxTest.pl
            set ::ThruputBT::tx_sound_filename c:/perl_scripts/$array2(tx_sound_file)
            set ::ThruputBT::rx_sound_filename c:/perl_scripts/rx_$array2(tx_sound_file)

            # remove the old rx wav files
            catch {$::ThruputBT::bt_dut rm -f $::ThruputBT::rx_sound_filename}
            catch {$::ThruputBT::bt_ref rm -f $::ThruputBT::rx_sound_filename}
        }

        if {$::ThruputBT::handle_dut == "" || $::ThruputBT::handle_ref == ""} {
            error "ThruputBT setup ERROR: handles must not be null,\
              handle_dut=$::ThruputBT::handle_dut handle_ref=$::ThruputBT::handle_ref"
        }
    } elseif {$::ThruputBT::bt_test == "n/a"} {
        # Sanity check on profile # done later

    } else {
        # Invalid bt_test ==> error!
        error "ThruputBT setup ERROR: Invalid test bt_test=$::ThruputBT::bt_test,\
            must be one of: acl sco"
    }
            
    # More initialization & sanity checks on parameters.
    # Checks for \d+ ensure positive integers, so no need to convert to integer.
    set ::ThruputBT::acl_test_count 20000 ;# ACL test count is based on 20000/sec
    set ::ThruputBT::bt_comm_dut [$bt_dut cget -bt_comm]
    set ::ThruputBT::bt_comm_ref [$bt_ref cget -bt_comm]
    set ::ThruputBT::bt_pkt $array2(bt_pkt)
    set ::ThruputBT::current_error_list "" ;# error list for current interation
    if {![info exists ::ThruputBT::erp_cnt]} {
        # Counter is maintained over many test runs.
        set ::ThruputBT::erp_cnt 0
    }
    set ::ThruputBT::fatal_error "" ;# save first fatal error that occurs
    set ::ThruputBT::history $array2(history)
    if {![regexp {^\d+$} $::ThruputBT::history] || $::ThruputBT::history < 1} {
        set ::ThruputBT::history 30
        UTF::Message WARN "$::localhost" "setup history set to $::ThruputBT::history"
    }
    set ::ThruputBT::key $array2(key)
    set ::ThruputBT::need_erp no ;# request for error recovery procedure 
    set ::ThruputBT::perf_int $array2(perfint)
    if {![regexp {^\d+$} $::ThruputBT::perf_int] || $::ThruputBT::perf_int < 1} {
        set ::ThruputBT::perf_int 1 ;# avoids divide by 0 later on.
        UTF::Message WARN "$::localhost" "setup perf_int set to $::ThruputBT::perf_int"
    }
    set ::ThruputBT::perf_loop $array2(perfloop)
    if {![regexp {^\d+$} $::ThruputBT::perf_loop] || $::ThruputBT::perf_loop < 1} {
        set ::ThruputBT::perf_loop 1
        UTF::Message WARN "$::localhost" "setup perf_loop set to $::ThruputBT::perf_loop"
    }
    set ::ThruputBT::perf_size $array2(perfsize)
    if {![regexp {^\d+$} $::ThruputBT::perf_size]} {
        set ::ThruputBT::perf_size 5
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT::perf_size"
    }
    if {$::ThruputBT::perf_size > 25} {
        set ::ThruputBT::perf_size 25 ;# ControlChart object limits size
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT::perf_size"
    }
    if {$::ThruputBT::perf_size < 2} {
        set ::ThruputBT::perf_size 2 ;# avoids divide by 0 later on.
        UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT::perf_size"
    }
    set ::ThruputBT::perf_time $array2(perftime)
    if {![regexp {^\d+$} $::ThruputBT::perf_time]} { 
        set ::ThruputBT::perf_time 30
        UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT::perf_time"
    }
    if {$::ThruputBT::perf_time > 100000} { 
        set ::ThruputBT::perf_time 100000 ;# prevent integer overflow later on
        UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT::perf_time"
    }
    if {$::ThruputBT::perf_time < 10} { 
        set ::ThruputBT::perf_time 10
        UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT::perf_time"
    }
    set ::ThruputBT::profile $array2(profile)
    set ::ThruputBT::running_error_list "" ;# error list for test with many iterations
    # Keep track of overall running worst time delay introduced by sockets.
    if {![info exists ::ThruputBT::running_max_socket_delay]} {
        set ::ThruputBT::running_max_socket_delay 0
        set ::ThruputBT::running_max_socket_timestamp ""
    }
    set ::ThruputBT::timer_cmds ""
    set ::ThruputBT::title $array2(title)
    set ::ThruputBT::window $array2(window)
    set ::ThruputBT::attn_type $array2(attn_type)

    # Set history based on actual groups of samples that will
    # be generated across multiple iterations.
    set predicted_history [expr ($::ThruputBT::perf_time * $::ThruputBT::perf_loop)\
        /($::ThruputBT::perf_int * $::ThruputBT::perf_size)]
    # puts "predicted_history=$predicted_history"
    if {$predicted_history > $::ThruputBT::history} {
        set ::ThruputBT::history $predicted_history
        UTF::Message WARN "$::localhost" "setup for longer test run, history\
            set to $::ThruputBT::history"
    }

     # isochoronous tests only
     # unset any iso element from array2 when no value is given
     if { ![info exists ::ThruputBT::iso_interval] } {
          set ::ThruputBT::iso_interval $array2(iso_interval)
         # puts "\n::ThruputBT::iso_interval value: $::ThruputBT::iso_interval\n"
         # UTF::Message INFO "" "::ThruputBT::iso_interval value: $::ThruputBT::iso_interval"
     } 

     if { ![info exists ::ThruputBT::iso_delay_tolerance] } {
         set ::ThruputBT::iso_delay_tolerance $array2(iso_delay_tolerance)
         # puts "\n::ThruputBT::iso_delay_tolerance value: $::ThruputBT::iso_delay_tolerance\n"
         # UTF::Message INFO "" "::ThruputBT::iso_delay_tolerance value: $::ThruputBT::iso_delay_tolerance"
     }

     if { ![info exists ::ThruputBT::block_size] } {
         set ::ThruputBT::block_size $array2(block_size)
         # puts "\n::ThruputBT::block_size value: $::ThruputBT::block_size\n"
         # UTF::Message INFO "" "::ThruputBT::block_size value: $::ThruputBT::block_size"
     }
     
     if { $::ThruputBT::iso_interval == "" || $::ThruputBT::iso_delay_tolerance == "" || $::ThruputBT::block_size == "" } {
         puts "iso parameters not set\n"
         set a2dpFlg 0
         array unset array2 iso_interval
         array unset array2 iso_delay_tolerance
         array unset array2 block_size
         unset ::ThruputBT::iso_interval ::ThruputBT::iso_delay_tolerance ::ThruputBT::block_size
         # unset ::ThruputBT::iso_delay_tolerance
         # unset ::ThruputBT::block_size
         UTF::Message INFO "" "No iso parameters set."
     } else {
         puts "iso parameters set\n"
         set a2dpFlg 1
         UTF::Message INFO "" "iso parameters set."
         UTF::Message INFO "" "::ThruputBT::iso_interval value: $::ThruputBT::iso_interval"
         UTF::Message INFO "" "::ThruputBT::iso_delay_tolerance value: $::ThruputBT::iso_delay_tolerance"
         UTF::Message INFO "" "::ThruputBT::block_size value: $::ThruputBT::block_size"
     }
     
     if { $::ThruputBT::wlan_relay == "" } {
	     UTF::Message INFO "" "DUT relay not defined."
	     array unset array2 wlan_relay
	     unset ::ThruputBT::wlan_relay
     }
	     
# debug: check iso variables
# #   if { [info exists ::ThruputBT::iso_interval] } {
# #      error "iso set checks: iso_interval, delay_tolerance, block_size: \n
# #      [array get array2]\n
# #      a2dpFlg: $a2dpFlg\n
# #      $::ThruputBT::iso_interval, $::ThruputBT::iso_delay_tolerance, $::ThruputBT::block_size\n
# #      $array2(iso_interval), $array2(iso_delay_tolerance), $array2(block_size)\n"
# #  } else {
# #      error "iso not set checks: iso_interval, delay_tolerance, block_size: \n
# #      a2dpFlg: $a2dpFlg\n
# #      [array get array2]\n"
# # #    $::ThruputBT::iso_interval, $::ThruputBT::iso_delay_tolerance, $::ThruputBT::block_size\n"
# # #    $array2(iso_interval), $array2(iso_delay_tolerance), $array2(block_size)\n"
# # }
# end of debug
 
    # For bt_test = n/a, profile must be 1, wlan only tests.
    if {$::ThruputBT::bt_test == "n/a" && $::ThruputBT::profile != 1} { 
        error "ThruputBT setup ERROR: for bt_test=n/a, profile must be 1"
    }

    # Set sample threshold for declaring a fatal error and invoking
    # error recovery procedure.
    set ::ThruputBT::sample_threshold [expr int(0.7 * $::ThruputBT::perf_size\
         * $::ThruputBT::perf_loop)]
    if {$::ThruputBT::sample_threshold < 1} {
       set ::ThruputBT::sample_threshold 1
    }
    # puts "::ThruputBT::sample_threshold=$::ThruputBT::sample_threshold"

    # Clean out any time plot data from a previous run.
    set names [array names ::ThruputBT::time_plot_array]
    set names [lsort $names]
    # UTF::Message LOG "$::localhost" "time_plot_array names=$names"
    foreach name $names {
       unset ::ThruputBT::time_plot_array($name)
    }

    # Log the setup data.
    UTF::Message LOG "$::localhost" "ThruputBT bt_dut=$bt_dut\
        bt_ref=$bt_ref handle_dut=$::ThruputBT::handle_dut\
        handle_ref=$::ThruputBT::handle_ref bt_dir=$::ThruputBT::bt_dir\
        bt_test=$::ThruputBT::bt_test bt_pkt=$::ThruputBT::bt_pkt\
        profile=$::ThruputBT::profile perfint=$::ThruputBT::perf_int\
        perfloop=$::ThruputBT::perf_loop perfsize=$::ThruputBT::perf_size\
        perftime=$::ThruputBT::perf_time history=$::ThruputBT::history"
    if {$::ThruputBT::wlan_dut != ""} {
	    set devList "ThruputBT wlan_dut=$::ThruputBT::wlan_dut\
            wlan_tg=$::ThruputBT::wlan_tg"
        set wDir "wlan_dir=$::ThruputBT::wlan_dir"
        # UTF::Message LOG "$::localhost" "ThruputBT wlan_dut=$::ThruputBT::wlan_dut\
        #    wlan_tg=$::ThruputBT::wlan_tg wlan_dir=$::ThruputBT::wlan_dir"
        if { [info exists ::ThruputBT::wlan_relay] } {
	        append devList " wlan_relay=$::ThruputBT::wlan_relay"
        }
        UTF::Message LOG "$::localhost" "$devList $wDir"
    }

    # For all test profiles except 1, change the BT packet type on both BT devices.
    # Test profile 1 is for WLAN only tests, and there is no guarantee that a BT
    # connection is available to manipulate.
    
    # turn ChangeConnectionPacketType off for A2DP: no need to set inside A2DP test loop
    if { $a2dpFlg eq 0 } {
        if {$::ThruputBT::profile != "1"} {
            if {$::ThruputBT::bt_pkt != "SCO" && $::ThruputBT::bt_pkt != "ESCO"} {
                UTF::Message LOG "$::localhost" "Change packet type to $::ThruputBT::bt_pkt"
                $bt_dut change_bt_packet_type $::ThruputBT::handle_dut $::ThruputBT::bt_pkt
                $bt_ref change_bt_packet_type $::ThruputBT::handle_ref $::ThruputBT::bt_pkt
            }
        }
    }
}

#======================= thruput_bt_traffic ===================================
# Routine starts up BT traffic between BT dut & BT ref.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Optional arg direction can be used to override the global direction setting.
# Returns hosts & file handles for parallel process started.
# Updates global variable timer_cmds
#==============================================================================
proc ThruputBT::thruput_bt_traffic {bt_dut bt_ref {direction ""}} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_int]} {
        set ::ThruputBT::perf_int 2
    }
    if {![info exists ::ThruputBT::perf_time]} {
        set ::ThruputBT::perf_time 30
    }
    if {![info exists ::ThruputBT::acl_test_count]} {
        set ::ThruputBT::acl_test_count 1000
    }
    if {![info exists ::ThruputBT::tx_script]} {
        set ::ThruputBT::tx_script common/ThroughputTxTest.pl
    }
    if {![info exists ::ThruputBT::rx_script]} {
        set ::ThruputBT::rx_script common/ThroughputRxTest.pl
    }
    if {![info exists ::ThruputBT::bt_comm_ref]} {
        set ::ThruputBT::bt_comm_ref "usb0"
    }
    if {![info exists ::ThruputBT::bt_comm_dut]} {
        set ::ThruputBT::bt_comm_dut "com3@3000000"
    }
    if {![info exists ::ThruputBT::handle_ref]} {
        set ::ThruputBT::handle_ref 12
    }
    if {![info exists ::ThruputBT::handle_dut]} {
        set ::ThruputBT::handle_dut 12
    }

    # On occasion, calling routine may wish to use a different
    # traffic direction than the default value. Most of the time
    # the default value is appropriate.
    set direction [string trim $direction]
    set direction [string tolower $direction]
    if {$direction == ""} {
        if {[info exists ::ThruputBT::bt_dir]} {
            set direction $::ThruputBT::bt_dir
        } else {
            set direction bidirectional
        }
    }
    UTF::Message LOG "$::localhost" "ThruputBT::thruput_bt_traffic\
        bt_dut=$bt_dut bt_ref=$bt_ref direction=$direction"

    # Test count controls how long ACL tests run
    set count [expr int($::ThruputBT::perf_time * $::ThruputBT::acl_test_count)]
    set interval [expr int($::ThruputBT::perf_int * 1000)] ;# time in milliseconds

    # Start traffic for dut2ref or bidirectional.
    set results ""
    if {$direction == "dut2ref" || $direction == "bidirectional"} {
        UTF::Message LOG "$::localhost" "ThruputBT::thruput_bt_traffic dut2ref"

        # Start up thruput scripts in parallel for test direction dut2ref
        # For each test started up, add another test to stop it in the list
        # of timer_cmds. Otherwise tests try to run for a default of 12.5 minutes.
        # When stopping the tests, it is crucial to stop the TX side first.
        # The semaphores are text strings used by the PERL routines on the
        # target PCs. There is no need to store them in TCL global variables.

        # Start the RX script first on ref.
        if {$::ThruputBT::bt_test == "acl"} {

            # iso tests when parameters are given
            if { [info exists ::ThruputBT::iso_interval] &&\
                 [info exists ::ThruputBT::iso_delay_tolerance] &&\
                 [info exists ::ThruputBT::block_size] } {

                # rx test            
                set fd_ref1 [$bt_ref run_perl_script $::ThruputBT::rx_script\
                    $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                    RefThroughputRxSemaphore $count $interval\
                    $::ThruputBT::iso_interval\
                    $::ThruputBT::iso_delay_tolerance \
                    $::ThruputBT::block_size -rpopen]
            
                UTF::Sleep 1

                # tx test
                set fd_dut1 [$bt_dut run_perl_script $::ThruputBT::tx_script\
                    $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                    DutThroughputTxSemaphore $count $interval\
                    $::ThruputBT::iso_interval\
                    $::ThruputBT::block_size -rpopen]
                        
                } else {
            
            # non iso tests
            set fd_ref1 [$bt_ref run_perl_script $::ThruputBT::rx_script\
                $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                RefThroughputRxSemaphore $count $interval -rpopen]
            # some delay is needed here
            UTF::Sleep 1
            set fd_dut1 [$bt_dut run_perl_script $::ThruputBT::tx_script\
                $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                DutThroughputTxSemaphore $count $interval -rpopen]
            UTF::Sleep 1
            }
            
        } else {
            set fd_ref1 [$bt_ref run_perl_script $::ThruputBT::rx_script\
                $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                $::ThruputBT::rx_sound_filename RefThroughputRxSemaphore $interval -rpopen]
            # some delay is needed here
            UTF::Sleep 1
            set fd_dut1 [$bt_dut run_perl_script $::ThruputBT::tx_script\
                $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                $::ThruputBT::tx_sound_filename DutThroughputTxSemaphore $interval -rpopen]
            UTF::Sleep 1
        }

        # For the timer commands, stop TX first
        append ::ThruputBT::timer_cmds " $bt_dut run_perl_script\
            common/ReleaseSemaphore.pl DutThroughputTxSemaphore ; after 1000 ;"
        append ::ThruputBT::timer_cmds " $bt_ref run_perl_script\
            common/ReleaseSemaphore.pl RefThroughputRxSemaphore ;"

        # Add hosts & file handles to results
        append results " $bt_dut $fd_dut1 $bt_ref $fd_ref1"
    }

    # Start traffic for ref2dut or bidirectional.
    if {$direction == "ref2dut" || $direction == "bidirectional"} {
        UTF::Message LOG "$::localhost" "ThruputBT::thruput_bt_traffic ref2dut"

        # Start up thruput scripts in parallel for test direction dut2ref
        # For each test started up, add another test to stop it in the list
        # of timer_cmds. Otherwise tests try to run for a default of 12.5 minutes.
        # When stopping the tests, it is crucial to stop the TX side first.
        # The semaphores are text strings used by the PERL routines on the 
        # target PCs. There is no need to store them in TCL global variables.

        # For the timer commands, start the RX first on dut.
        if {$::ThruputBT::bt_test == "acl"} {

            # iso tests when iso parameters are given
            if { [info exists ::ThruputBT::iso_interval] &&\
                 [info exists ::ThruputBT::iso_delay_tolerance] &&\
                 [info exists ::ThruputBT::block_size] } {
                        
                # rx test
                set fd_dut2 [$bt_dut run_perl_script $::ThruputBT::rx_script\
                    $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                    DutThroughputRxSemaphore $count $interval\
                    $::ThruputBT::iso_interval\
                    $::ThruputBT::iso_delay_tolerance\
                    $::ThruputBT::block_size -rpopen]

                UTF::Sleep 1
                        
                # tx test    
                set fd_ref2 [$bt_ref run_perl_script $::ThruputBT::tx_script\
                    $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                    RefThroughputTxSemaphore $count $interval\
                    $::ThruputBT::iso_interval\
                    $::ThruputBT::block_size -rpopen]
            
                } else {

            # non-iso tests
            set fd_dut2 [$bt_dut run_perl_script $::ThruputBT::rx_script\
                $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                DutThroughputRxSemaphore $count $interval -rpopen]
            # some delay is needed here
            UTF::Sleep 1
            set fd_ref2 [$bt_ref run_perl_script $::ThruputBT::tx_script\
                $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                RefThroughputTxSemaphore $count $interval -rpopen]
            UTF::Sleep 1
            }
            
        } else {
            set fd_dut2 [$bt_dut run_perl_script $::ThruputBT::rx_script\
                $::ThruputBT::bt_comm_dut $::ThruputBT::handle_dut\
                $::ThruputBT::rx_sound_filename DutThroughputRxSemaphore $interval -rpopen]
            # some delay is needed here
            UTF::Sleep 1
            set fd_ref2 [$bt_ref run_perl_script $::ThruputBT::tx_script\
                $::ThruputBT::bt_comm_ref $::ThruputBT::handle_ref\
                $::ThruputBT::tx_sound_filename RefThroughputTxSemaphore $interval -rpopen]
            UTF::Sleep 1
        }

        # For the timer commands, stop TX first
        append ::ThruputBT::timer_cmds " $bt_ref run_perl_script common/ReleaseSemaphore.pl\
            RefThroughputTxSemaphore ; after 1000 ;" 
        append ::ThruputBT::timer_cmds " $bt_dut run_perl_script common/ReleaseSemaphore.pl\
            DutThroughputRxSemaphore ;"

        # Add the hosts & file handles to results
        append results " $bt_dut $fd_dut2 $bt_ref $fd_ref2"
    }

    # Thats it.
    return "$results"
}

#======================= thruput_test_stop_timer ==============================
# Routine sets timer to stop BT thruput tests.
# Calling arg delay_sec specifies how long to let the tests run, in seconds.
# Returns timer_id
#==============================================================================
proc ThruputBT::thruput_test_stop_timer {delay_sec} {

    set delay_ms [expr int($delay_sec * 1000)]
    UTF::Message LOG "$::localhost" "ThruputBT::thruput_test_stop_timer\
         delay_sec=$delay_sec delay_ms=$delay_ms\
         ::ThruputBT::timer_cmds=$::ThruputBT::timer_cmds"

    # Start timer which will stop the running tests. The timer MUST expire 
    # in order to stop the tests.
    set timer_id [after $delay_ms $::ThruputBT::timer_cmds]
    UTF::Message LOG "$::localhost" "ThruputBT::thruput_test_stop_timer\
        created timer_id=$timer_id"
    return "$timer_id"
}

#======================= thruput_wlan_traffic =================================
# Routine starts up WLAN traffic between WLAN dut & WLAN tg.
# Optional arg direction can be used to override the global direction setting.
# Returns hosts & file handles for parallel process started.
#==============================================================================
proc ThruputBT::thruput_wlan_traffic {{direction ""}} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::wlan_dut]} {
        set ::ThruputBT::wlan_dut cx020_4329SDIO
    }
    if {![info exists ::ThruputBT::wlan_tg]} {
        set ::ThruputBT::wlan_tg lan
    }
    if {![info exists ::ThruputBT::window]} {
        set ::ThruputBT::window 512k
    }
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_int]} {
        set ::ThruputBT::perf_int 2
    }
    if {![info exists ::ThruputBT::perf_time]} {
        set ::ThruputBT::perf_time 30
    }
    if {![info exists ::ThruputBT::wlan_dir]} {
        set ::ThruputBT::wlan_dir bidirectional
    }

    # Check wlan devices are defined.
    if {$::ThruputBT::wlan_dut == "" || $::ThruputBT::wlan_tg == ""} {
        error "ThruputBT thruput_wlan_dut2tg ERROR: WLAN device may not,\
            be null, wlan_dut=$::ThruputBT::wlan_dut wlan_tg=$::ThruputBT::wlan_tg"
    }

    # On occasion, calling routine may wish to use a different
    # traffic direction than the default value. Most of the time
    # the default value is appropriate.
    set direction [string trim $direction]
    set direction [string tolower $direction]
    if {$direction == ""} {
        if {[info exists ::ThruputBT::wlan_dir]} {
            set direction $::ThruputBT::wlan_dir
        } else {
            set direction bidirectional
        }
    }

    UTF::Message LOG "$::localhost" "ThruputBT::thruput_wlan_traffic\
        wlan_dut=$::ThruputBT::wlan_dut wlan_tg=$::ThruputBT::wlan_tg\
        direction=$direction"        

    # Tune the TCP windows on both machines. When the test has multiple
    # iterations, only do the tuning for the first iteration. Get & cache
    # the IP address of both devices.
    if {$::ThruputBT::perf_cnt == 1} {
	    set itemList "$::ThruputBT::wlan_dut $::ThruputBT::wlan_tg"
	    if { [info exists ::ThruputBT::wlan_relay] } {
		    append itemList " $::ThruputBT::wlan_relay"
	    }
        foreach item $itemList {
            set logname [UTF::get_name $item]
            UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic\
                Tuning TCP"

            # Try to tune the device
            set resp [$item tcptune $::ThruputBT::window]

            # If the OS doesnt allow the TCP stack to be tuned, then we
            # apply the -w option to iperf. This typically only gets used
            # on Windows machines. Supposedly if we apply the -w option to
            # iperf on a Linux machine, the thruput will suffer greatly.
            if {$resp == 1 && $::ThruputBT::window ne 0} {
                set ::ThruputBT::wlan($item,opt) "-w $::ThruputBT::window"
            } else {
                set ::ThruputBT::wlan($item,opt) ""
            }

            # Get the device IP address.
            UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic\
                Getting IP"    
            set ::ThruputBT::wlan($item,ip) [$item ipaddr]
            # puts "item=$item logname=$logname wlan($item,opt)=$::ThruputBT::wlan($item,opt)\
            #      wlan($item,ip)=$::ThruputBT::wlan($item,ip)"
            ## ? UTF::Message DEBUG "" "item=$item logname=$logname wlan($item,opt)=$::ThruputBT::wlan($item,opt)\
            ## ?   wlan($item,ip)=$::ThruputBT::wlan($item,ip)\n"
        }
    }

    # iperf is normally running as a service on all UTF machines, and is
    # supposed to be ready to accept in incoming iperf TCP connections at
    # all times.

    # Start wlan iperf traffic for dut2tg or bidirectional.
    # To get the data with a timestamp from the remote host, we use a
    # wrapper script, iperf_timestamps.tcl. 
    set results ""
    
    ## ? UTF::Message DEBUG "" "\n$::ThruputBT::wlan_dut is type: [$::ThruputBT::wlan_dut hostis]\n"
	set wdut_type [$::ThruputBT::wlan_dut hostis]
	       
    if {$direction == "dut2tg" || $direction == "bidirectional"} {
	    
	  if { $wdut_type != "HSIC" } {
		    
	    UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic non HSIC branch.\n"	    
        # Start iperf as parallel task via rpopen.
        set logname [UTF::get_name $::ThruputBT::wlan_dut]
        UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic dut2tg"
        set fd_dut [$::ThruputBT::wlan_dut rpopen iperf_timestamps.tcl\
            -c $::ThruputBT::wlan($::ThruputBT::wlan_tg,ip)\
            -i $::ThruputBT::perf_int -t $::ThruputBT::perf_time -fb\
            $::ThruputBT::wlan($::ThruputBT::wlan_dut,opt)]
         
#         set rsltSrc $::ThruputBT::wlan_dut
            
        } else {
	        
	    ## ? UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic HSIC branch. Using relay for iperf_timestamps.tcl\n"
        # Start iperf as parallel task via rpopen.
        set logname [UTF::get_name $::ThruputBT::wlan_dut]
        UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic dut2tg"        
        set fd_dut [$::ThruputBT::wlan_relay rpopen iperf_timestamps.tcl\
            -c $::ThruputBT::wlan($::ThruputBT::wlan_tg,ip)\
            -i $::ThruputBT::perf_int -t $::ThruputBT::perf_time -fb\
            $::ThruputBT::wlan($::ThruputBT::wlan_dut,opt)]
                                   
        }    
        UTF::Sleep 1
        fconfigure $fd_dut -blocking 0
        fileevent $fd_dut readable {set ::utils_reading READY}

        # Add the host & file handle to results
        UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic created fd=$fd_dut"
        append results " $::ThruputBT::wlan_dut $fd_dut"
        
        # # ? UTF::Message DEBUG "$logname" "ThruputBT::thruput_wlan_traffic dut2tg results: $results\n"
        
    }

    # Start wlan iperf traffic for tg2dut or bidirectional.
    if {$direction == "tg2dut" || $direction == "bidirectional"} {
	    
	  if { $wdut_type != "HSIC" } {
		    
        # Start iperf as parallel task via rpopen.
        set logname [UTF::get_name $::ThruputBT::wlan_tg]
        UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic tg2dut"
        set fd_tg [$::ThruputBT::wlan_tg rpopen iperf_timestamps.tcl\
            -c $::ThruputBT::wlan($::ThruputBT::wlan_dut,ip)\
            -i $::ThruputBT::perf_int -t $::ThruputBT::perf_time -fb\
            $::ThruputBT::wlan($::ThruputBT::wlan_tg,opt)]
            
        } else {
	        
        UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic HSIC branch.\n"
	      
	    set logname [UTF::get_name $::ThruputBT::wlan_tg]
        UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic tg2dut HSIC branch"
        set fd_tg [$::ThruputBT::wlan_tg rpopen iperf_timestamps.tcl\
            -c $::ThruputBT::wlan($::ThruputBT::wlan_dut,ip)\
            -i $::ThruputBT::perf_int -t $::ThruputBT::perf_time -fb\
            $::ThruputBT::wlan($::ThruputBT::wlan_tg,opt)]

        #? Code that used to work till 6/14/12                
        #? UTF::Message LOG "$logname" "ThruputBT::thruput_wlan_traffic tg2dut HSIC branch"
        #? set fd_tg [$::ThruputBT::wlan_tg rpopen iperf_timestamps.tcl\
        #?     -c $::ThruputBT::wlan($::ThruputBT::wlan_relay,ip)\
        #?     -i $::ThruputBT::perf_int -t $::ThruputBT::perf_time -fb\
        #?     $::ThruputBT::wlan($::ThruputBT::wlan_tg,opt)]
        }
        UTF::Sleep 1
        fconfigure $fd_tg -blocking 0
        fileevent $fd_tg readable {set ::utils_reading READY}

        # Add the host & file handle to results
        UTF::Message LOG "$logname" "ThruputBT::thruput_bt_traffic created fd=$fd_tg"
        append results " $::ThruputBT::wlan_tg $fd_tg"
                     
        UTF::Message DEBUG "$logname" "ThruputBT::thruput_wlan_traffic tg2dut results: $results"
    }

    # Thats it.
    return "$results"
}

#======================= test_profile0 ========================================
# Test profile 0: BT traffic only on an existing connection.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
proc ThruputBT::test_profile0 {bt_dut bt_ref} {

    # Start BT tests.
    set fd_list [ThruputBT::thruput_bt_traffic $bt_dut $bt_ref]

    # Start timer to stop the tests.
    set timer_id [ThruputBT::thruput_test_stop_timer $::ThruputBT::perf_time]

    # Collect data from parallel processes.
    set resp1 ""
    set resp2 ""
    set timeout_sec [expr $::ThruputBT::perf_time + 20]
    UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
    # UTF::Message LOG "" "\n\n\nThruputBT::test_profile0 resp1=$resp1\n\n\n"
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile0 resp1=$resp1 resp2=$resp2\n\n\n"

    # If timer is still running, cancel it. Otherwise it may disrupt the
    # next test.
    after cancel $timer_id

    # Process results
    set results [ThruputBT::process_results [list bt $::ThruputBT::bt_dir $bt_dut $bt_ref $resp1]]
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile0 results=$results\n\n\n"
    
    return "$results"
}

#======================= test_profile1 ========================================
# Test profile 1: WLAN iperf traffic only on an existing connection.
# Dummy calling args are ignored but are present to keep API consistent.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
proc ThruputBT::test_profile1 {args} {

    # Start WLAN iperf tests.
    set fd_list [ThruputBT::thruput_wlan_traffic]

    # WLAN doesnt need any extra timer to stop iperf tests.

    # Collect data from parallel processes.
    set resp1 ""
    set resp2 ""
    set timeout_sec [expr $::ThruputBT::perf_time + 20]
    UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
    # UTF::Message LOG "" "\n\n\nThruputBT::test_profile1 resp1=$resp1\n\n\n"
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile1 resp1=$resp1 resp2=$resp2\n\n\n"

    # Process results
    set results [ThruputBT::process_results [list wlan $::ThruputBT::wlan_dir $::ThruputBT::wlan_dut $::ThruputBT::wlan_tg $resp1]]
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile1 results=$results\n\n\n"
    
    return "$results"
}

#======================= test_profile2 ========================================
# Test profile 0: BT traffic only on an existing connection
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
# Test profile 2: WLAN iperf traffic & BT traffic concurrently on existing connections
proc ThruputBT::test_profile2 {bt_dut bt_ref} {

    # Start BT tests first as they have a few seconds delay while
    # getting going.
    set fd_list [ThruputBT::thruput_bt_traffic $bt_dut $bt_ref]
    UTF::Sleep 1

    # Start WLAN iperf tests.
    append fd_list " [ThruputBT::thruput_wlan_traffic]"
    UTF::Sleep 1

    # Start timer to stop the BT tests. WLAN doesnt need any extra timer to
    # stop iperf tests.
     set timer_id [ThruputBT::thruput_test_stop_timer $::ThruputBT::perf_time]

    # Collect data from parallel processes.
    set resp1 ""
    set resp2 ""
    set timeout_sec [expr $::ThruputBT::perf_time + 20]
    UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
    # UTF::Message LOG "" "\n\n\nThruputBT::test_profile2 resp1=$resp1\n\n\n"
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile2 resp1=$resp1 resp2=$resp2\n\n\n"

    # If timer is still running, cancel it. Otherwise it may disrupt the
    # next test.
    after cancel $timer_id

    # Process results
    set results [ThruputBT::process_results\
        [list wlan $::ThruputBT::wlan_dir $::ThruputBT::wlan_dut $::ThruputBT::wlan_tg $resp1]\
        [list bt $::ThruputBT::bt_dir $bt_dut $bt_ref $resp1]]
        
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::test_profile2 results=$results\n\n\n" 
       
    return "$results"
}

#==============================================================================
# Test data for routine below.
set ::test_data "\
{17:02:59 host1 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: 300}\
{17:03:01 host1 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 301}\
{17:03:02 host1 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 302}
{17:03:03 host1 com33000000: Fri May  1 17:01:33 2009  RX current_Speed_KBit_Per_Second: 303}\
{17:03:05 host1 com33000000: Fri May  1 17:01:24 2009  RX current_Speed_KBit_Per_Second: 304}\
{17:03:07 host1 com33000000: Fri May  1 17:01:35 2009  RX current_Speed_KBit_Per_Second: 305}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:08 host1 com33000000: Fri May  1 17:01:37 2009  RX current_Speed_KBit_Per_Second: 0.0}\
{17:03:09 host1 com33000000: Fri May  1 17:01:38 2009  RX current_Speed_KBit_Per_Second: -66}\
{17:02:59 host2 usb0: Fri May  1 17:01:30 2009 TX current_Speed_KBit_Per_Second: -1}\
{17:02:59 host2 usb0: Fri May  1 17:01:31 2009 TX current_Speed_KBit_Per_Second: 600}\
{17:02:59 host2 com33000000: Fri May  1 17:01:33 2009  TX current_Speed_KBit_Per_Second: 601}\
{17:03:01 host2 usb0: Fri May  1 17:01:32 2009 TX current_Speed_KBit_Per_Second: 602}\
{17:03:03 host2 com33000000: Fri May  1 17:01:34 2009  TX current_Speed_KBit_Per_Second: 603}\
{17:03:05 host2 com33000000: Fri May  1 17:01:35 2009  TX current_Speed_KBit_Per_Second: 604}\
{17:03:07 host2 com33000000: Fri May  1 17:01:36 2009  TX current_Speed_KBit_Per_Second: 605}\
{17:03:09 host2 com33000000: Fri May  1 17:01:37 2009  TX current_Speed_KBit_Per_Second: 606}\
{17:03:11 host2 com33000000: Fri May  1 17:01:38 2009  TX average_Speed_KBit_Per_Second: 607}\
{17:03:20 host1 RX Bit_Errors_Low => 123}\
{17:03:20 host1 RX Bit_Errors_High => 0}\
{17:03:20 host1 RX Dropped_Bytes_Low => 456}\
{17:03:20 host1 RX Dropped_Bytes_High => 0}\
{17:02:59 host2 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: -1}\
{17:02:59 host2 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 400}\
{17:03:01 host2 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 401}\
{17:03:02 host2 usb0: Fri May  1 17:01:33 2009 RX current_Speed_KBit_Per_Second: 402}\
{17:03:03 host2 usb0: Fri May  1 17:01:34 2009 RX current_Speed_KBit_Per_Second: 403}\
{17:03:04 host2 com33000000: Fri May  1 17:01:35 2009 RX current_Speed_KBit_Per_Second: 404}\
{sfsdfsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
{sfsbtsp: failed: event server 12345 ...}\
{222222fsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
{ fsdf sf BTSP: failed: aaaa bbbb cccc ddd w rwrwrw er w wer }"


# Test sequences for routine below.
# ThruputBT::get_BT_results host1 [list $::test_data] 0 rx
# ThruputBT::get_BT_results host2 [list $::test_data] 0 tx

#======================= get_BT_results =======================================
# Extracts thruput test results from collect_rpopen_data.
# Calling parms:
# host: name of host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)
#==============================================================================
proc ThruputBT::get_BT_results {host data_list samples type} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_loop]} {
        set ::ThruputBT::perf_loop 1
    }
    if {![info exists ::ThruputBT::sample_threshold]} {
        set ::ThruputBT::sample_threshold 3
    }

    # # new code ==> not relevant for BT tests
    # case of HSIC: use local clock
    
# #     set hType [$host hostis]
# #     # UTF::Message ERROR "" "get_BT_results host is $host; host type: $hType\n"
# #     
# #     if { $hType == "HSIC" } {
# # 	    # set host $::ThruputBT::wlan_tg
# # 	    set host $::ThruputBT::wlan_relay
# # 	    UTF::Message ERROR "" "get_BT_results HSIC branch. Host defined as $host.\n"
# # 	    }

    # end of new code
    
    
    # Get time correction delta for the target host
    set time_delta_sec [ThruputBT::get_remote_clock_delta $host]
    set logname [UTF::get_name $host]

    # Variables to track socket delays
    set ::ThruputBT::max_socket_delay 0
    set ::ThruputBT::max_socket_timestamp ""

    # The data_list is usually a nested list of data, which is
    # best processed by the double foreach loop below. This
    # avoids issues of processing strings with unmatched braces
    # or brackets.

    # Initially the perl scripts would send back text strings that
    # werent unique. You had to match a header line with the data 
    # result. This was very error prone. The perl scripts have now
    # been modified to send unique strings. So everything you need
    # is now contained within the line of text.
    # UTF::Message LOG "$logname" "\n\n\nThruputBT::get_BT_results host=$host\
    #    samples=$samples type=$type data_list=$data_list\n\n\n"
    set sample_list ""
    set host [string trim $host]
    set type [string trim $type]
    set type [string tolower $type]
    foreach item $data_list {
        # UTF::Message LOG "$logname" "ThruputBT::get_BT_results search for: $host $type ======================================================================"
        # UTF::Message LOG "$logname" "ThruputBT::get_BT_results\n\n\n\item=$item\n\n\n"
        foreach subitem $item {
            # UTF::Message LOG "$logname" "ThruputBT::get_BT_results subitem=$subitem"
            # Skip data not matching host & type. The data often has tabs,
            # which we convert to spaces.
            regsub -all {\011} $subitem " " subitem

            # There are some fatal errors that need to be flagged.
            # When a fatal error is found, we need to request the error
            # recovery procedure in order to continue testing. These errors 
            # usually dont have type RX/TX included. We save only the first
            # fatal error that we find, so as not to clutter up the web summary
            # page with repeated copies of a similar message. But we log all
            # fatal errors.
            if {[regexp -nocase {connection.*lost} $subitem] &&\
                ![regexp -nocase {fsh} $subitem]} {
                set ::ThruputBT::need_erp yes
                set msg "connection lost (set $::ThruputBT::perf_cnt of $::ThruputBT::perf_loop)"
                UTF::Message ERROR "$logname" "ThruputBT::get_BT_results fatal error: $msg $subitem"
                if {![info exists ::ThruputBT::fatal_error] ||\
                    $::ThruputBT::fatal_error == ""} {
                    set ::ThruputBT::fatal_error "$msg"
                }
                continue
            }

            # There are other routine errors to watch for. Keep only the first
            # 3 words of failure string to minimize how much data gets shown
            # on the web page.
            if {[regexp -nocase {(BTSP:.*failed:\s+\S+\s+\S+\s+\S+)} $subitem - msg]} {
                UTF::Message ERROR "$logname" "ThruputBT::get_BT_results found: $subitem"
                lappend ::ThruputBT::current_error_list "$msg"
                lappend ::ThruputBT::running_error_list "$msg"
                continue
            }

            # Match the host name at start of the list pair, then match
            # on type rx or tx.
            # NB: Some strings, in particular the final error statistics, have
            # only a single space be the host and RX/TX, so you cant have regexp
            # asking for spaces around each parameter!
            if {![regexp -nocase " $host .*$type " $subitem]} {
                continue
            }
            # UTF::Message LOG "$logname" "ThruputBT::get_BT_results matched host $host $type: $subitem"

            # Get local & remote timestamps & current (not average!) thruput
            # data from results line. The regexp filters out the negative values.
            # NB: 0 or 0.0 is a legitimate value!
            if {[regexp -nocase {^([\d:]{8}).*\s([\d:]{8})\s.*current.*kbit_per_second:\s*([\.\d]+)}\
                $subitem - time1 time2 tput]} {
                set corrected_timestamp [ThruputBT::timestamp_correction BT $time1\
                    $time2 $time_delta_sec]
                # NB: BlueTool reports thruput in Kb/s!
                set tput [expr double($tput) / 1000] ;# UTF likes numbers in Mb/s
                set tput [format "%6.6f" $tput]
                lappend sample_list $corrected_timestamp $tput
                
                ## ? UTF::Message DEBUG "$logname" "ThruputBT::get_BT_results found\
                ## ?     $type sample: time1=$time1 time2=$time2\
                ## ?     corrected=$corrected_timestamp tput=$tput subitem: $subitem"
                    
                continue
            }

            # Look for other statistics at the end of the test run.
            # Show only the statistic type that failed, in order to minimize
            # the data shown on the web page.
            # added check for Delay Packets statistics check, if present
            if {[regexp -nocase {(bit_errors|dropped_bytes|delayed_packets).*\s(\d+)$} $subitem - msg stat]} {
                # UTF::Message LOG "$host" "ThruputBT::get_BT_results found stat:\
                #      msg=$msg stat=$stat subitem: $subitem"
                # set stat 1 ;# test code
                if {$stat > 0} {
                    lappend ::ThruputBT::current_error_list "$msg"
                    lappend ::ThruputBT::running_error_list "$msg"
                    UTF::Message ERROR "$logname" "ThruputBT::get_BT_results\
                        found msg=$msg stat=$stat subitem=$subitem"
                }
                continue
            }
        }
    }

    # Log UTF delays
    UTF::Message LOG "$logname" "ThruputBT::get_BT_results $type\
        max_socket_delay=$::ThruputBT::max_socket_delay seconds occured at:\
        $::ThruputBT::max_socket_timestamp"

    # Need to toss last sample which is delayed repeat of final sample?


    # Discard duplicate time samples. We seem to get duplicate messages
    # as the BlueTool tests shut down, so we toss them.
    # Burst of zero's does not happen any more, but we could get 0 throughput
    # which is valid and we should not remove them as duplicates
    #set sample_list [ThruputBT::remove_duplicate_samples $host BT $type $sample_list]

    # If necessary, drop some of the earlier samples.
    set sample_cnt [llength $sample_list]
    set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
    if {$samples > 0} {
        if {$sample_cnt < $samples} {
            UTF::Message WARN "$logname" "ThruputBT::get_BT_results Only\
                found $sample_cnt samples!"
        } else {
            set i [expr ($sample_cnt - $samples) * 2]
            set sample_list [lrange $sample_list $i end]
            set sample_cnt $samples
        }
    }

    UTF::Message LOG "$logname" "Full samples=$sample_list"

    # in coex testing sometimes after the test is stopped, the reciever still will
    # continue recieving messages that were backed up and this will cause 
    # "::ThruputBT::current_error_list=Bit_Errors Dropped_Bytes" because the extra rx
    # messages do not have a tx message, therefore we need to trim those first
    # by removing any samples above 35 
    if {$sample_cnt > $::ThruputBT::perf_size && $sample_cnt > 50} {
        # too many samples exist
        UTF::Message LOG "$logname" "Burst of RX messages - BT sample_cnt $sample_cnt is reduced to 35"
        set sample_list [lrange $sample_list 0 70]
        set sample_cnt 35
        UTF::Message LOG "$logname" "samples=$sample_list"
    }
    
    # we want 1 entry in the control chart per run
    # Since it is possible at the beginning and at the end of coex test, the wlan and bt are not running 
    # simultaneously, therefore strip the extra values from both begining and the end.
    if {$sample_cnt > $::ThruputBT::perf_size} {
        UTF::Message LOG "$logname" "BT sample_cnt $sample_cnt is reduced to perf_size $::ThruputBT::perf_size"
        set i [expr $sample_cnt - $::ThruputBT::perf_size]
        if {[expr ($i % 2)] == 1} {
            # odd number
            set i [expr ($i - 1)]
        }
        set sample_list [lrange $sample_list $i end]
        set sample_list [lrange $sample_list 0 [expr ($::ThruputBT::perf_size * 2) - 1]]
        set sample_cnt [llength $sample_list]
        set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
        UTF::Message LOG "$logname" "samples=$sample_list"
    }

    # Log the results
    UTF::Message LOG "$logname" "ThruputBT::get_BT_results $type\
        cnt=$sample_cnt samples=$sample_list"

    # Too few RX samples is a good indicator of serious problems. Request 
    # the error recovery procedure in order to keep testing. We save only
    # the first fatal error. But we log all fatal errors.
    if {$sample_cnt < $::ThruputBT::sample_threshold && $type == "rx"} {
        set ::ThruputBT::need_erp yes
        set msg "$logname Only $sample_cnt $type samples, required\
            $::ThruputBT::sample_threshold (set $::ThruputBT::perf_cnt\
            of $::ThruputBT::perf_loop)"
        UTF::Message ERROR "$logname" "ThruputBT::get_BT_results fatal error: $msg"
        if {![info exists ::ThruputBT::fatal_error] ||\
            $::ThruputBT::fatal_error == ""} {
            set ::ThruputBT::fatal_error "$msg"
        }
    }

    # Return the results
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::get_bt_results sample_list=$sample_list\n\n\n"
    
    return $sample_list
}

#==============================================================================
# Test data for routine below.
set ::test_data2 "\
{17:01:30 host1   3 ] local 192.168.1.101 port 35001 connected with 192.168.1.102 port 5001}\
{17:01:31 host2   3 ] local 192.168.1.102 port 51756 connected with 192.168.1.101 port 5001}\
{17:01:30 host1  ID Interval       Transfer     Bandwidth}\
{17:01:31 host2  ID] Interval       Transfer     Bandwidth}\
{17:01:30 host1 17:01:33 sec Bytes  13271040 bits/sec}\
{17:01:31 host1 17:01:34 sec Bytes  12713984 bits/sec}
{17:01:32 host1 17:01:35 sec Bytes  17793024 bits/sec}\
{17:01:33 host1 17:01:36 sec Bytes  26900128 bits/sec}\
{17:01:34 host1 17:01:37 sec Bytes  30081024 bits/sec}\
{17:01:35 host1 17:01:38 sec Bytes  32866304 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31850496 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31850000 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31860000 bits/sec}\
{17:01:37 host1 17:01:40 sec Bytes  50496 bits/sec}\
{17:01:30 host2 17:01:30 sec Bytes  23494656 bits/sec}\
{17:01:31 host2 17:01:31 sec Bytes  17039360 bits/sec}\
{17:01:32 host2 17:01:32 sec Bytes  18417616 bits/sec}\
{17:01:33 host2 17:01:33 sec Bytes  11436032 bits/sec}\
{17:01:34 host2 17:01:34 sec Bytes  7307264 bits/sec}\
{17:01:35 host2 17:01:35 sec Bytes  0.0 bits/sec}\
{17:01:36 host2 17:01:36 sec Bytes  -33 bits/sec}\
{17:01:37 host2 17:01:37 sec Bytes  6258688 bits/sec}\
{sfsdfsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}"

# Test sequences for routine below.
# ThruputBT::get_WLAN_results host1 [list $::test_data2] 0 rx
# ThruputBT::get_WLAN_results host2 [list $::test_data2] 0 tx

# Extracts thruput test results from the collect_rpopen data.
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)

#======================= get_WLAN_results =====================================
# Extracts thruput test results from collect_rpopen_data.
# Calling parms:
# host: name of host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)
#==============================================================================
proc ThruputBT::get_WLAN_results {host data_list samples type} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_loop]} {
        set ::ThruputBT::perf_loop 1
    }
    if {![info exists ::ThruputBT::sample_threshold]} {
        set ::ThruputBT::sample_threshold 3
    }
    if {![info exists ::ThruputBT::wlan_tg]} {
        set ::ThruputBT::wlan_tg host1
    }
    if {![info exists ::ThruputBT::wlan_dut]} {
        set ::ThruputBT::wlan_dut host2
    }

    # For iperf TCP traffic, the UTF way is to not monitor the receiving
    # end. Experience has shown that for TCP you can trust the transmitting
    # side numbers. For this script, the upper level routines process recieved
    # data. So we send back nothing for type=tx and send the transmitted data
    # back for type=rx. If we ever support iperf UDP traffic, then we will have
    # to be careful in here.
    set type [string trim $type]
    set type [string tolower $type]
    if {$type == "tx"} {
        return
    }

    # When collecting the transmitted data, we have to look at the opposite
    # wlan device than what we were called with. For example when sending
    # traffic for tg2dut, we will collect the transmitted data from the tg,
    # but report it back as the recieved data for the dut.

# #     original code
# #     
    if {$host == $::ThruputBT::wlan_tg} { 
	        set host $::ThruputBT::wlan_dut
	    } else {
	        set host $::ThruputBT::wlan_tg
	    }
# # 
# # 	end of original code

    
# # new code
    # case of HSIC: use local clock
    
# # comment out for now to check behavior from thruput_wlan_traffic  -- no change needed from original code

# #     set hType [$host hostis]
# #     ## ? UTF::Message DEBUG "" "get_WLAN_results host: $host; host type: $hType\n"
# #     
# # 	    if {$host == $::ThruputBT::wlan_tg} {
# # 	        if { $hType != "HSIC" } {
# # 		       set host $::ThruputBT::wlan_dut
# #             } else {
# # 	        # UTF::Message ERROR "" "HSIC branch. Host defined as $host; host type $hType.\n"
# # 	        # case of HSIC: use relay
# # 	           # if { [info exists ::ThruputBT::wlan_relay] } {
# # 	             set host $::ThruputBT::wlan_relay
# # 		         UTF::Message DEBUG "" "get_WLAN_results HSIC branch. Host defined as $host; host type $hType.\n"
# #                  # }
# #             }
# # 	    } else {
# # 	        set host $::ThruputBT::wlan_tg
# # 	    }
# # #     UTF::Message ERROR "" "get_WLAN_results host: $host; host type: $hType\n"

# # end of new code
    
    # Get time correction delta for the target host
    set time_delta_sec [ThruputBT::get_remote_clock_delta $host]
    set logname [UTF::get_name $host]

    # Variables to track socket delays
    set ::ThruputBT::max_socket_delay 0
    set ::ThruputBT::max_socket_timestamp ""

    # The data_list is usually a nested list of data, which is
    # best processed by the double foreach loop below. This
    # avoids issues of processing strings with unmatched braces
    # or brackets.

    # Match the host name at start of the list pair.
    # UTF::Message LOG "$logname" "\n\n\nThruputBT::get_WLAN_results host=$host\
    #    samples=$samples type=$type data_list=$data_list\n\n\n"
    set sample_list ""
    set host [string trim $host]
    foreach item $data_list {
        ## ? UTF::Message LOG "$logname" "ThruputBT::get_WLAN_results search for: $host $type ======================================================================"
        
        ## ? UTF::Message DEBUG "$logname" "ThruputBT::get_WLAN_results\n\n\n\item=$item\n\n\n"
        
        foreach subitem $item {
            # UTF::Message LOG "$logname" "ThruputBT::get_WLAN_results subitem=$subitem"
            # Skip data not matching host & type. The data often has tabs,
            # which we convert to spaces.
            regsub -all {\011} $subitem " " subitem

            # There are some fatal errors that need to be flagged.
            # When a fatal error is found, we request the error recovery 
            # procedures in order to continue testing. We save only the
            # first fatal error that we find, so as not to clutter up the
            # web summary page with repeated copies of a similar message.
            # But we log all fatal errors.
            if {[regexp -nocase {(connection.*lost)} $subitem] &&\
                ![regexp -nocase {fsh} $subitem]} {
                set ::ThruputBT::need_erp yes
                set msg "connection lost (set $::ThruputBT::perf_cnt of $::ThruputBT::perf_loop)"
                UTF::Message ERROR "$logname" "ThruputBT::get_WLAN_results fatal error:\
                   $msg $subitem"
                if {![info exists ::ThruputBT::fatal_error] ||\
                    $::ThruputBT::fatal_error == ""} {
                    set ::ThruputBT::fatal_error "$msg"
                }
                continue
            }

            # Match on host.
            if {![regexp -nocase " $host " $subitem]} {
                continue
            }
            # UTF::Message LOG "$logname" "ThruputBT::get_WLAN_results matched host $host: $subitem"

            # Get local & remote timestamps & current thruput data from results.
            # The regexp filters out the negative values.
            # NB: 0 or 0.0 is a legitimate value!
            if {[regexp -nocase {^([\d:]{8})\s.*\s([\d:]{8})\s.*\sBytes\s+([\.\d]+) bits/sec$}\
                $subitem - time1 time2 tput]} {
                set corrected_timestamp [ThruputBT::timestamp_correction WLAN $time1\
                    $time2 $time_delta_sec]
                # NB: iperf reports thruput in bits/s!
                set tput [expr double($tput) / 1000000] ;# UTF likes numbers in Mb/s
                set tput [format "%6.6f" $tput]
                lappend sample_list $corrected_timestamp $tput
                
                ## ? UTF::Message DEBUG "$logname" "ThruputBT::get_WLAN_results found\
                ## ?     $type sample: time1=$time1 time2=$time2\
                ## ?     corrected=$corrected_timestamp tput=$tput subitem: $subitem"
                    
                continue
            }

            # Currently there are no stats or other events related to iperf to look for.
        }
    }

    # Log UTF delays
    UTF::Message LOG "$logname" "ThruputBT::get_WLAN_results $type\
        max_socket_delay=$::ThruputBT::max_socket_delay seconds occured at:\
        $::ThruputBT::max_socket_timestamp"

    # Always discard the last iperf sample (time+tput), as it is the overall average.
    # We do this before the duplicate check, so we know we are discarding just the
    # last sample.
    set sample_list [lrange $sample_list 0 end-2]

    # Discard duplicate time samples. Usually doesnt occur with iperf, but
    # there is no harm checking anyway.
    # Burst of zero's does not happen any more, but we could get 0 throughput
    # which is valid and we should not remove them as duplicates
    #set sample_list [ThruputBT::remove_duplicate_samples $host WLAN $type $sample_list]

    # If necessary, drop some of the earlier samples.
    set sample_cnt [llength $sample_list]
    set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
    if {$samples > 0} {
        if {$sample_cnt < $samples} {
            UTF::Message WARN "$logname" "ThruputBT::get_WLAN_results Only\
                found $sample_cnt samples!"
        } else {
            set i [expr ($sample_cnt - $samples) * 2]
            set sample_list [lrange $sample_list $i end]
            set sample_cnt $samples
        }
    }

    # we want 1 entry in the control chart per run
    # Since it is possible at the beginning and at the end of coex test, the wlan and bt are not running 
    # simultaneously, therefore strip the extra values from both begining and the end.
    if {$sample_cnt > $::ThruputBT::perf_size} {
        UTF::Message LOG "$logname" "samples=$sample_list"
        UTF::Message LOG "$logname" "WLAN sample_cnt $sample_cnt is reduced to perf_size $::ThruputBT::perf_size"
        set i [expr $sample_cnt - $::ThruputBT::perf_size]
        if {[expr ($i % 2)] == 1} {
            # odd number
            set i [expr ($i - 1)]
        }
        set sample_list [lrange $sample_list $i end]
        set sample_list [lrange $sample_list 0 [expr ($::ThruputBT::perf_size * 2) - 1]]
        set sample_cnt [llength $sample_list]
        set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
    }

    # Log the results
    UTF::Message LOG "$logname" "ThruputBT::get_WLAN_results $type\
        cnt=$sample_cnt samples=$sample_list"

    # Too few samples is a good indicator of serious problems. Request
    # the error recovery procedures. We save only the first fatal error.
    # But we log all fatal errors.
    if {$sample_cnt < $::ThruputBT::sample_threshold} {
        set ::ThruputBT::need_erp yes
        set msg "$logname Only $sample_cnt $type samples, required\
            $::ThruputBT::sample_threshold (set $::ThruputBT::perf_cnt\
            of $::ThruputBT::perf_loop)"
        UTF::Message ERROR "$logname" "ThruputBT::get_WLAN_results fatal error: $msg"
        if {![info exists ::ThruputBT::fatal_error] ||\
            $::ThruputBT::fatal_error == ""} {
            set ::ThruputBT::fatal_error "$msg"
        }
    }

    # Return the results
    
    ## ? UTF::Message DEBUG "" "\n\n\nThruputBT::get_WLAN_results sample_list=$sample_list\n\n\n"
    
    return $sample_list
}

#======================= get_remote_clock_delta ===============================
# Routine use to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# host: host object to get clock delta for
# tries: optional number of iterations for computing clock delta
# Returns: clock delta, in seconds
# A positive delta means the remote host clock is faster than the local clock
# A negative delta means the remote host clock is slower than the local clock
#==============================================================================
proc ThruputBT::get_remote_clock_delta {host {tries 10} {debug 0}} {
	
	## ? UTF::Message DEBUG "" "get_remote_clock_delta: host given: $host\n"

    # If we have cached value that has not been used too often,
    # then use the cached value.
    set logname [UTF::get_name $host]
	# UTF::Message ERROR "" "get_remote_clock_delta: logname given: $logname\n"
	set hType [$host hostis]
    
    if {[info exists ::clock_delta($logname,uses)]} {
        if {$::clock_delta($logname,uses) < 10} {
            incr ::clock_delta($logname,uses)
            set result $::clock_delta($logname,value)
            UTF::Message LOG "$logname" "ThruputBT::get_remote_clock_delta use\
                #$::clock_delta($logname,uses) of cached result=$result"
            return $result
        }
    }

    # Get N clock time samples from the remote host. Need 3 samples
    # minimum so that later we can delete high/low values and still
    # have something left to use.
    if {$tries == "" || $tries < 3} {
        set tries 10
    }
    set clock_delta_list ""
    for {set i 0} {$i < $tries} {incr i} {

        # Get remote date/time stamp and timing info for how
        # long that took.
        set start_sec [clock seconds]
        if { $hType == "HSIC" } {
	       set host $::wlan_relay
       }
       set catch_resp [catch "set remote_date \[$host rexec -quiet\
            -silent date\]" catch_msg]
        
        set stop_sec [clock seconds]
        if {$catch_resp != 0} {
            UTF::Message ERROR "$logname" "get_remote_clock_delta $catch_msg"
            return 0
        }

        # Compute clock delta
        set round_trip_sec [expr $stop_sec - $start_sec] ;# total transaction time
        regexp {\s([\d:]{8})\s} $remote_date remote_time ;# extract remote hh:mm:ss
        set remote_sec [clock scan $remote_time] ;# convert to unix seconds
        set start_time [clock format $start_sec]
        set clock_delta [expr $remote_sec - $start_sec - ($round_trip_sec/2)]
        if {$debug == 1} {
            UTF::Message LOG "$::localhost" "ThruputBT::get_remote_clock_delta\
                 start_time=$start_time start_sec=$start_sec stop_sec=$stop_sec\
                 round_trip_sec=$round_trip_sec"
            UTF::Message LOG "$logname" "ThruputBT::get_remote_clock_delta\
                 remote_date=$remote_date remote_time=$remote_time\
                 remote_sec=$remote_sec clock_delta=$clock_delta"
        }
        lappend clock_delta_list $clock_delta
    }
    # puts "clock_delta_list=$clock_delta_list"

    # Locate the lowest clock deltas and delete it.
    # NB: If you try to locate highest & lowest in same loop,
    # you may get indexing error when you delete items that
    # arent there as the list has shifted positions.
    set i 0
    set min_delta ""
    set min_i ""
    foreach delta $clock_delta_list {
        if {$min_delta == ""} {
            set min_delta $delta
            set min_i $i
        } elseif {$delta < $min_delta} {
            set min_delta $delta
            set min_i $i
        }
        # puts "i=$i delta=$delta min_delta=$min_delta min_i=$min_i"
        incr i
    }
    set clock_delta_list [lreplace $clock_delta_list $min_i $min_i]
    # puts "clock_delta_list=$clock_delta_list"
 
    # Locate the highest clock delta and delete it.
    set i 0
    set max_delta ""
    set max_i ""
    foreach delta $clock_delta_list {
        if {$max_delta == ""} {
            set max_delta $delta
            set max_i $i
        } elseif {$delta >= $max_delta} {
            set max_delta $delta
            set max_i $i
        }
        # puts "i=$i delta=$delta max_delta=$max_delta max_i=$max_i"
        incr i
    }
    set clock_delta_list [lreplace $clock_delta_list $max_i $max_i]
    # puts "clock_delta_list=$clock_delta_list"

    # Average the remaining clock deltas
    set cnt 0
    set total 0
    foreach delta $clock_delta_list {
        set total [expr $total + $delta]
        incr cnt
    } 
    if {$cnt != 0} {
        # puts "total=$total cnt=$cnt"
        set result [expr int($total / $cnt)]
    } else {
        set result 0
    }
    
    # Log results, update cache & return result.
    UTF::Message LOG "$logname" "ThruputBT::get_remote_clock_delta\
        high=$max_delta low=$min_delta clock_delta_list=$clock_delta_list\
        result=$result"
    set ::clock_delta($logname,value) $result
    set ::clock_delta($logname,uses) 0
    return $result
}

# Test code for routine below
# ThruputBT::timestamp_correction BT 01:02:13 01:02:03 2

#======================= timestamp_correction =================================
# Routine used to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# id: bt|wlan
# time1 is localhost / UTF timestamp
# time2 is remote host timestamp
# time_delta_sec is the known time difference, in seconds, between the localhost
# and the remotehost
# Returns corrected time
# times are all in format: hh:mm:ss
#==============================================================================
proc ThruputBT::timestamp_correction {id time1 time2 time_delta_sec} {
    # puts "ThruputBT::timestamp_correction time1=$time1 time2=$time2\
    #    time_delta_sec=$time_delta_sec"

    # Convert time2 to seconds, adjust time2 and reformat
    set catch_resp [catch "set time2_sec \[clock scan $time2\]" catch_msg]
    if {$catch_resp !=0} {
        UTF::Message ERROR "$::localhost" "ThruputBT::timestamp_correction\
            ERROR: invalid time2=$time2 $catch_msg"
        return "$time2" 
    }
    set corrected_time_sec [expr $time2_sec - $time_delta_sec] ;# adjust to localhost timebase
    set corrected_timestamp [clock format $corrected_time_sec -format %H:%M:%S]

    # Keep track of worst time delay introduced by sockets
    set catch_resp [catch "set time1_sec \[clock scan $time1\]" catch_msg]
    if {$catch_resp !=0} {
        UTF::Message ERROR "$::localhost" "ThruputBT::timestamp_correction\
            ERROR: invalid time1=$time1 $catch_msg"
        return "$corrected_timestamp" 
    }
    set socket_delay_sec [expr abs($time1_sec - $corrected_time_sec)]
    if {![info exists ::ThruputBT::max_socket_delay]} {
        set ::ThruputBT::max_socket_delay 0
        set ::ThruputBT::max_socket_timestamp ""
    }
    if {$socket_delay_sec > $::ThruputBT::max_socket_delay} {
        set ::ThruputBT::max_socket_delay $socket_delay_sec
        set ::ThruputBT::max_socket_timestamp "$id time1=$time1\
            time2=$time2 corrected=$corrected_timestamp"
    }

    # Keep track of overall running worst time delay introduced by sockets.
    if {![info exists ::ThruputBT::running_max_socket_delay]} {
        set ::ThruputBT::running_max_socket_delay 0
        set ::ThruputBT::running_max_socket_timestamp ""
    }
    if {$socket_delay_sec > $::ThruputBT::running_max_socket_delay} {
        set ::ThruputBT::running_max_socket_delay $socket_delay_sec
        set ::ThruputBT::running_max_socket_timestamp "$id time1=$time1\
            time2=$time2 corrected=$corrected_timestamp"
    }

    # Return corrected_timestamp
    # puts "time1_sec=$time1_sec time2_sec=$time2_sec\
    #    corrected_time_sec=$corrected_time_sec"
    # puts "corrected_timestamp=$corrected_timestamp\
    #    socket_delay_sec=$socket_delay_sec"
    return "$corrected_timestamp"
}

# Test sequence for routine below.
# ThruputBT::remove_duplicate_samples host1 bt rx "17:01:00 3.3 17:01:00 4.3 17:01:00 5.3 17:01:00 5.4 17:00:00 2.3 17:01:01 3.3 17:01:02 3.6 17:01:02 3.7 17:01:02 3.8 17:01:03 4.0 17:01:03 4.1 17:01:03 4.2 17:01:03 4.3 17:01:04 4.4"

#======================= remove_duplicate_samples =============================
# Removes duplicate samples based on time stamps. Due slightly fuzzy timing of
# various datastreams, two samples in the same second are allowed, but no more.
# The timestamps are expected to be in ascending sequence.
# Sample_list & returned data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value
# calling args host, id & type are strings shown in the log messages
#==============================================================================
proc ThruputBT::remove_duplicate_samples {host id type sample_list} {

    # Discard duplicate time samples. We seem to get duplicate messages
    # as the BlueTool tests shut down, so we toss them. Due slightly fuzzy
    # timing of various datastreams, two samples in the same second are
    # allowed, but no more. Check for timestamps not in ascending sequence.
    set discard_list "" ;# discarded samples
    set last_time "" ;# timestamp of previous sample
    set logname [UTF::get_name $host]
    set results "" ;# list of unique samples
    set same_time_cnt 0 ;# count of consecutive samples with same timestamp
    set warn_list "" ;# out of sequence samples
    foreach {time tput} $sample_list {
        if {$time > $last_time} {
            # Sample is in ascending order, as expected.
            lappend results $time $tput
            # puts "$time $tput ascending, keep"

        } elseif {$time == $last_time} {
            # Sample is in same second as previous sample.
            incr same_time_cnt
            if {$same_time_cnt == "1"} {
                # Allow 2 samples in same second
                lappend results $time $tput
                # puts "$time $tput duplicate, keep"

            } else {
                # After two samples in same second, samples are
                # discarded
                lappend discard_list $time $tput
                # puts "$time $tput duplicate, discard"
            }

        } else {
            # Sample is out of the expected ascending sequence.
            # Gnuplot will handle them, so we keep them as well
            # as warning the user.
            lappend results $time $tput
            lappend warn_list $time $tput
            # puts "$time $tput out of sequence, keep, warn"
        }

        # Update state variables
        if {$time != $last_time} {
            set last_time $time
            set same_time_cnt 0
        }
    }

    # Warn user if samples discarded or out of sequence, return results
    if {$discard_list != ""} {
        UTF::Message WARN "$logname" "ThruputBT::remove_duplicate_samples $id $type\
            dropped [expr [llength $discard_list] / 2] duplicate samples: $discard_list"
    }
    if {$warn_list != ""} {
        UTF::Message WARN "$logname" "ThruputBT::remove_duplicate_samples $id $type\
            [expr [llength $warn_list] / 2] out of sequence samples: $warn_list"
    }
    return $results
}

# Test sequences for routine below.
# ThruputBT::process_results [list bt bidirectional host1 host2 $::test_data]
# ThruputBT::process_results [list wlan bidirectional host1 host2 $::test_data2]
# ThruputBT::process_results [list bt bidirectional host1 host2 $::test_data] [list wlan bidirectional host2 host1 $::test_data2]

#======================= process_results ======================================
# Supervises the extraction of result data, creates one control chart for
# each data string in args and one overall time plot graph.
# Calling args: Each data string represents the test results of a test
# between a pair of STA, either unidirectional or bidirectional tests.
# Data strings are formated as: {id sta1 sta2 direction text_results}
# where:
# id: bt|wlan
# direction: bidirection|dut2ref|ref2dut|...
# sta1: object STA name
# sta2: object STA name
# text_results: data list returned by collect_rpopen_data
# Returns: html formated string with links to graphs.
#==============================================================================
proc ThruputBT::process_results {args} {

    # This code helps with unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_loop]} {
        set ::ThruputBT::perf_loop 1
    }
    if {![info exists ::ThruputBT::running_error_list]} {
        set ::ThruputBT::running_error_list ""
    }

    # Process each data item in args.
    set ::ThruputBT::current_error_list ""
    set html_results ""
    set time_plot_data ""
    foreach data $args {

        # Get id, direction, sta, etc from data. The data often has
        # unmatched brackets or braces, so we must use regexp to process.
        # lindex & lrange choke on unmatched brackets or braces.
        # NB: If we ever support id besides bt & wlan, we need to have
        # a proc called ThruputBT::get_$id_results to support it.
        # puts "\n\n\ndata=$data\n\n\n"
        if {![regexp {\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)} $data \
            - id direction sta1 sta2 text_results]} {
           error "ThruputBT::process_results ERROR could not parse data=$data"
        }
        set id [string trim $id]
        set id [string toupper $id]
        # puts "\n\n\nid=$id direction=$direction sta1=$sta1 sta2=$sta2 \
        #     text_results=$text_results\n\n\n"

        ## to catch cases where low mos score flag not raised in bidirectional tests
        ## added mos_failed_flag_dut2ref and mos_failed_flag_ref2dut checks on 4/13/12
        if {$id == "BT" && $::ThruputBT::bt_test == "sco"} {
            set cc_data ""
            set mos_failed_flag 0
            set mos_failed_flag_dut2ref 0
            set mos_failed_flag_ref2dut 0

            UTF::Message LOG "$::localhost" "perf_size is set to 2 for SCO"
            set ::ThruputBT::perf_size 2

            if {$direction == "dut2ref" || $direction == "bidirectional"} {

                set mos1 0
                ## new check
                ## set mos_failed_flag_dut2ref 0

                catch {set result1 [$sta2 run_perl_script common/pesqScore.pl\
                    $::ThruputBT::tx_sound_filename $::ThruputBT::rx_sound_filename]}

                # PESQ_MOS = x
                set result2 [regexp {PESQ_MOS = (\d+\.\d+)} $result1 match mos1]

                if {$result2 != 1} {
                    UTF::Message WARN "$::localhost" "ThruputBT::process_results - $direction PESQ MOS data='$result1'"
                } else {
                    UTF::Message LOG "$::localhost" "$direction PESQ_MOS = '$mos1'"
                }

                # use catch becasue the mos could be non integer
                catch {
                    set mos_failed_flag 1

                    if {[expr double($mos1)] >= 0} {
                        set mos_failed_flag 0
                    }
                }

                if {$mos_failed_flag == 1} {
                    # catch happened due to non integer mos. Force it to a value
                    # so the graph looks right
                    set mos1 0.001
                } else {
                    if {[expr double($mos1)] < [expr double(3.5)]} {
                        set mos_failed_flag 1
                        ## new check
                        set mos_failed_flag_dut2ref 1
                    }
                }

                if {$direction == "dut2ref"} {
                    set cc_data "$mos1 $mos1"
                }
            }

            if {$direction == "ref2dut" || $direction == "bidirectional"} {

                set mos2 0
                ## new check
                ## set mos_failed_flag_ref2dut 0

                catch {set result1 [$sta1 run_perl_script common/pesqScore.pl\
                    $::ThruputBT::tx_sound_filename $::ThruputBT::rx_sound_filename]}

                # PESQ_MOS = x
                set result2 [regexp {PESQ_MOS = (\d+\.\d+)} $result1 match mos2]

                if {$result2 != 1} {
                    UTF::Message WARN "$::localhost" "ThruputBT::process_results - $direction PESQ MOS data='$result1'"
                } else {
                    UTF::Message LOG "$::localhost" "$direction PESQ_MOS = '$mos2'"
                }

                # use catch becasue the mos could be non integer
                catch {
                    set mos_failed_flag 1

                    if {[expr double($mos2)] >= 0} {
                        set mos_failed_flag 0
                    }
                }

                if {$mos_failed_flag == 1} {
                    # catch happened due to non integer mos. Force it to a value
                    # so the graph looks right
                    set mos2 0.001
                } else {
                    if {[expr double($mos2)] < [expr double(3.5)]} {
                        set mos_failed_flag 1
                        ## new check
                        set mos_failed_flag_ref2dut 1
                    }
                }

                if {$direction == "ref2dut"} {
                    set cc_data "$mos2 $mos2"
                }
            }

            if {$direction == "bidirectional"} {
                set cc_data "$mos1 $mos2"
            }

            # if mos score is less than 3.5, then the test failed
            ## new checks added: mos_failed_flag_dut2ref and mos_failed_flag_ref2dut
            if {$mos_failed_flag == 1 || $mos_failed_flag_dut2ref == 1 || $mos_failed_flag_ref2dut == 1} {
                set ::ThruputBT::running_error_list "LOW MOS SCORE"
            }
        } else {
            # Extract data, store in results array. Only the RX data is used in
            # control charts & time plots.
            # Data format: time1 value 1 ... timeN valueN
            set cc_data ""
            if {[string match "dut2*" $direction] || $direction == "bidirectional"} {
                # Log TX data, but store the RX data.
                ThruputBT::get_${id}_results $sta1 "$text_results" 0 tx
                set rx_data1 [ThruputBT::get_${id}_results $sta2 "$text_results" 0 rx]
                if {$rx_data1 !=""} {
                    append ::ThruputBT::time_plot_array(${id}_${sta1}_-->_${sta2}) " $rx_data1"
                }
                set cc_data [ThruputBT::remove_timestamps $rx_data1]
            }
            if {[string match "*2dut" $direction] || $direction == "bidirectional"} {
                # Log TX data, but store the RX data.
                ThruputBT::get_${id}_results $sta2 "$text_results" 0 tx
                set rx_data2 [ThruputBT::get_${id}_results $sta1 "$text_results" 0 rx]
                if {$rx_data2 != ""} {
                    append ::ThruputBT::time_plot_array(${id}_${sta1}_<--_${sta2}) " $rx_data2"
                }
                set cc_data [ThruputBT::remove_timestamps $rx_data2]
            }

            # For bidirectional test, merge the two sets of samples for the
            # control chart
            if {$direction == "bidirectional"} {
                set cc_data [ThruputBT::merge_samples $id [ThruputBT::remove_timestamps\
                    $rx_data1] [ThruputBT::remove_timestamps $rx_data2]]
            }
        }

        # Create new ControlChart object & graphics file
        append html_results " [ThruputBT::control_chart $id $direction $sta1 $sta2 $cc_data]"
    }

    # no time graph for sco baseline
    if {$::ThruputBT::bt_test != "sco" || $::ThruputBT::profile == 2} {

        # Create composite time plot graph 
        append html_results " [ThruputBT::timeplot]"
    }

    # On last iteration, add fatal error, if any.
    if {$::ThruputBT::perf_cnt == $::ThruputBT::perf_loop && \
        $::ThruputBT::fatal_error != ""} {
        append html_results " &nbsp;<font color=\"red\"><b>FATAL ERROR</b>&nbsp;$::ThruputBT::fatal_error </font>"
    }

    # On the last iteration add running error list, from parsing data streams.
    # Condense the error lists to the minimum sized list with just one unique
    # copy of each error type that occured. This minimizes how messy the web
    # summary page gets when there are many errors in one test.
    set ::ThruputBT::current_error_list [lsort -unique $::ThruputBT::current_error_list]
    set ::ThruputBT::running_error_list [lsort -unique $::ThruputBT::running_error_list]
    UTF::Message LOG "$::localhost" "::ThruputBT::current_error_list=$::ThruputBT::current_error_list"
    if {$::ThruputBT::perf_cnt == $::ThruputBT::perf_loop && \
        $::ThruputBT::running_error_list != ""} {
        append html_results " &nbsp;<font color=\"orange\"><b>ERRORS</b>&nbsp;$::ThruputBT::running_error_list </font>"
    }

    # Restore the "html:" header, or UTF wont process results correctly.
    # NB: MUST NOT have leading whitespace!
    set html_results [string trim $html_results]
    if {$html_results != ""} {
        set html_results "html: $html_results"
    }
    set html_results [string trim $html_results]
    UTF::Message LOG "$::localhost" "process_results iteration\
        $::ThruputBT::perf_cnt of $::ThruputBT::perf_loop:\
        html_results=$html_results"

    # How we return html_results depends on error lists & iteration counter.
    # For intermediate iterations, we dont throw errors. This allows all the
    # interations to be completed.
    if {$::ThruputBT::perf_cnt == $::ThruputBT::perf_loop &&\
       ($::ThruputBT::running_error_list != "") ||\
       $::ThruputBT::fatal_error != ""} {
        error "$html_results"
    } else {
        return "$html_results"
    }
}

# Test sequence for routine below.
# ThruputBT::remove_timestamps {a 1 b 2 c 3 d 4 e 5}

#======================= remove_timestamps ====================================
# Routine removes the timestamps from a series of samples.
# Calling arg: space separated string in format:
# time1 tput1 ... timeN tputN
# Returns data in space separated string in format:
# tput1 ... tputN
#==============================================================================
proc ThruputBT::remove_timestamps {series} {

     # Remove the time stamps from the series.
     set results ""
     foreach {time tput} $series {
         lappend results $tput
     }

     # Return results
     return $results
}

# Test sequence for routine below
# ThruputBT::merge_samples bt {1 2 3 4 5} {6 7 8 9}

#======================= merge_samples ========================================
# Merges two unidirectional series of thruput values to give a composite
# bidirectional data series for use in a control chart.
# Calling args: space separated series of decimal thruput values
# Returns:space separated series of decimal thruput values 
#==============================================================================
proc ThruputBT::merge_samples {id series1 series2} {

     # Check series sizes. If different, drop earlier samples 
     # from the longer series.
     set cnt1 [llength $series1]
     set cnt2 [llength $series2]
     if {$cnt1 > $cnt2} {
         set i [expr $cnt1 - $cnt2]
         set series1 [lrange $series1 $i end]
         UTF::Message WARN "$::localhost" "ThruputBT::merge_samples\
             dropping $i samples during merge"
     } elseif {$cnt1 < $cnt2} {
         set i [expr $cnt2 - $cnt1]
         set series2 [lrange $series2 $i end]
         UTF::Message WARN "$::localhost" "ThruputBT::merge_samples\
             dropping $i samples during merge"
     }
     # UTF::Message LOG "$::localhost" "ThruputBT::merge_samples series1=$series1"
     # UTF::Message LOG "$::localhost" "ThruputBT::merge_samples series2=$series2"

     # Add the 2 series together value by value to get bidirectional
     # series of values.
     set cnt [llength $series1]
     set series3 ""
     for {set i 0} {$i < $cnt} {incr i} {
         set value [expr [lindex $series1 $i] + [lindex $series2 $i]]
         lappend series3 $value
     }

    # Log & return the results
    UTF::Message LOG "$::localhost" "ThruputBT::merge_samples $id bidirectional\
        cnt=$cnt series=$series3"
    return "$series3"
}

# Test sequence for routine below.
# ThruputBT::control_chart id dut2ref host1 host2 "3 4 5 6 7"

#======================= control_chart ========================================
# Feeds thruput samples to control chart in set sizes that the control
# chart can handle (2 - 25).
# Calling args: 
# The first four args are text strings used to help create unique keys
# for the perfcache data.
# sample_list is a space separated list of decimal thruput values.
# Returns: html string with control chart png file & thumbnail data
#==============================================================================
proc ThruputBT::control_chart {id direction sta1 sta2 sample_list} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_loop]} {
        set ::ThruputBT::perf_loop 1
    }
    if {![info exists ::ThruputBT::perf_size]} {
        set ::ThruputBT::perf_size 5
    }
    if {![info exists ::ThruputBT::bt_test]} {
        set ::ThruputBT::bt_test "-1"
    }
    if {![info exists ::ThruputBT::bt_pkt]} {
        set ::ThruputBT::bt_pkt "-1"
    }
    if {![info exists ::ThruputBT::bt_dir]} {
        set ::ThruputBT::bt_dir bidirectional
    }
    if {![info exists ::ThruputBT::wlan_dir]} {
        set ::ThruputBT::wlan_dir bidirectional
    }
    if {![info exists ::ThruputBT::history]} {
        set ::ThruputBT::history 30
    }
    if {![info exists ::ThruputBT::key]} {
        set ::ThruputBT::key "-1"
    }
    if {![info exists ::ThruputBT::profile]} {
        set ::ThruputBT::profile "-1"
    }

    # Create ControlChart object regardless of samples being
    # available or not. We may need to generate control chart
    # graphics from previous iteration data.
    set sample_cnt [llength $sample_list]
    set id [string toupper $id]
    set profile $::ThruputBT::profile
    if {$id == "BT"} {
        set direction2 $::ThruputBT::wlan_dir
    } else {
        set direction2 $::ThruputBT::bt_dir
    }
    if {$profile >= 2} {
        # For two traffic flows, add second direction key to ensure uniqness.
        set cc_keys "$::ThruputBT::key P=$profile $id\
            $::ThruputBT::bt_test $::ThruputBT::bt_pkt $direction\
            $direction2 $sta1 $sta2"

    } elseif {$profile == 1} {
        # profile=1 WLAN only traffic
        set cc_keys "$::ThruputBT::key P=$profile $id $direction $sta1 $sta2"

    } else {
        # profile=0 BT only traffic
        set cc_keys "$::ThruputBT::key P=$profile $id\
            $::ThruputBT::bt_test $::ThruputBT::bt_pkt $direction\
            $sta1 $sta2"
    }
    set cc_keys [string trim $cc_keys]
    set logname [UTF::get_name $sta1]
    UTF::Message LOG "$logname" "ThruputBT::control_chart\
        history=$::ThruputBT::history cc_keys=$cc_keys\
        sample_size=$::ThruputBT::perf_size sample_cnt=$sample_cnt\
        sample_list=$sample_list"
    UTF::ControlChart CC -s $::ThruputBT::perf_size -key $cc_keys\
        -history $::ThruputBT::history

    # Do we have enough samples to process?
    set cc_errors "" ;# list of error from control chart
    set cc_others ""  ;# list of other results from control chart
    set cc_result "" ;# result string from control chart
    set sample_cnt [llength $sample_list]
    set min_samples [expr int(0.8 * $::ThruputBT::perf_size)]
    # puts "sample_cnt=$sample_cnt min_samples=$min_samples"
    if {$sample_cnt < $min_samples} {
        set msg "CC too few samples!"
        lappend ::ThruputBT::current_error_list "$msg"
        lappend ::ThruputBT::running_error_list "$msg"
        UTF::Message ERROR "$logname" "ThruputBT::control_chart $id\
           $direction $sta1 $sta2 $msg"
        # NB: We dont return here. We may still need to generate the 
        # overall CC for previous iterations.

    } else {
        # Process the samples.
        if {$sample_cnt < $::ThruputBT::perf_size} {
            UTF::Message WARN "$logname" "ThruputBT::control_chart\
                $id $direction $sta1 $sta2 only $sample_cnt samples!"
        }

        # Process samples in groups of perf_size. This allows hundreds
        # of samples from a large run to be fed into the controlchart
        # within the limits of the controlchart sample size restrictions.
        set i 0
        while { 1 } {

            # Get next perf_size group of samples.
            set j [expr $i + $::ThruputBT::perf_size - 1]
            set cc_samples [lrange $sample_list $i $j]
            UTF::Message LOG "$logname" "ThruputBT::control_chart\
                i=$i j=$j cc_samples=$cc_samples"

            # Are there enough samples in this group to work with?
            set cnt [llength $cc_samples]
            if {$cnt < $min_samples} {
                UTF::Message WARN "$logname" "ThruputBT::control_chart\
                    $id $direction $sta1 $sta2 dropping samples: $cc_samples"
                break
            }

            # Use the common UTF routine for mean, min, max
            set cc_mmm [UTF::MeanMinMax $cc_samples]
            # set cc_mmm "0.1 0.1 0.1" ;# test data

            # Add data sample, check for errors & other messages from
            # the ControlChart.
            set cc_result [CC addsample $cc_mmm]
            # puts "cc_result=$cc_result"
            if {[regexp -nocase {(LOW|WIDE|ZERO)} $cc_result - code]} {
                append cc_errors " $code"
            }
            if {[regexp -nocase {(HIGH)} $cc_result - code]} {
                append cc_others " $code"
            }

            # Exit loop when we hit end of sample list.
            incr i $::ThruputBT::perf_size
            if {$i >= $sample_cnt} {
                break
            }
        }

        # Make list of codes unique. Selectively add errors to error lists.
        set cc_errors [lsort -unique $cc_errors]
        set cc_errors [string trim $cc_errors]
        set cc_others [lsort -unique $cc_others]
        set cc_others [string trim $cc_others]
        # puts "cc_errors=$cc_errors cc_others=$cc_others"
        if {$cc_errors != ""} {
            set msg "$cc_errors"
            UTF::Message ERROR "$logname" "ThruputBT::control_chart $id\
                $direction $sta1 $sta2 CC $msg"
            lappend ::ThruputBT::current_error_list "$msg"

            # The running error list is shown on the web summary page.
            # To avoid redundant error messages, if there are already 
            # other errors, there is no need to add these errors.
            # However if there are no other errors, we do need to a token
            # error msg so that the higher level routines will correctly
            # throw an error as the overall result.
            if {$::ThruputBT::running_error_list == ""} {
                set ::ThruputBT::running_error_list "$cc_errors"
            }
        }
    }

    # If not the last iteration, return
    if {$::ThruputBT::perf_cnt != $::ThruputBT::perf_loop} {
        CC destroy
        return
    }

    # Update the last result with any error/other codes that occured.
    # puts "cc_result=$cc_result"
    if {$cc_errors != ""} {
        regsub -nocase -all " OK| LOW| WIDE| ZERO" $cc_result "" cc_result
        append cc_result " $cc_errors"
    }
    if {$cc_others != ""} {
        regsub -nocase -all " OK| HIGH" $cc_result "" cc_result
        append cc_result " $cc_others"
    }
    set cc_result [string trim $cc_result]
    if {$cc_result == ""} {
        set cc_result "---"
    }
    # puts "cc_result=$cc_result"

    # Get the control chart graphics
    set chart [CC plotcontrolchart $cc_result]
    CC destroy

    # Add formating to identify the control chart. When there
    # is more than one control chart on a single line on the web
    # summary page, you need some additional identifiers to tell 
    # whats what. 
    regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
    set chart " &nbsp;<b>$id</b>&nbsp;${chart}" ;# add bold id
    return "$chart"
}

# Test data for routine below.
# set ::ThruputBT::time_plot_array(wlan_host1_-->_host2) "17:05  33 17:06  34 17:07  35 17:08  36 17:09   37"
# set ::ThruputBT::time_plot_array(bt_host1_-->_host2)   "17:05 0.2 17:06 0.4 17:07 0.5 17:08 0.6 17:09 0.27"

#======================= timeplot =============================================
# Takes data from global array time_plot_array and creates a composite time
# plot graph.
# Calling args: none
# Returns: html string with control chart png file & thumbnail
#==============================================================================
proc ThruputBT::timeplot {} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::perf_cnt]} {
        set ::ThruputBT::perf_cnt 1
    }
    if {![info exists ::ThruputBT::perf_loop]} {
        set ::ThruputBT::perf_loop 1
    }
    if {![info exists ::ThruputBT::fatal_error]} {
        set ::ThruputBT::fatal_error ""
    }

    # Create composite time plot graph just on the last iteration.
    if {$::ThruputBT::perf_cnt != $::ThruputBT::perf_loop} {
        return
    }

    # Get list of data series from the time_plot_array.
    # Array is wiped clean in the process.
    set names [array names ::ThruputBT::time_plot_array]
    set names [lsort $names]
    set series ""
    foreach name $names {

        # Format name into series title.
        regsub -all "_" $name " " series_title 

        # Axes to use for plot is determined by ID, the first token in title
        set id [lindex $series_title 0]
        set id [string trim $id]
        set id [string toupper $id]
        if {$id == "BT"} {
            set axes x1y2 ;# plot BT data on right Y-axis
        } else {
            set axes x1y1 ;# plot WLAN data on left Y-axis
        }
        # puts "series_title=$series_title id=$id axes=$axes"

        # Add series data to list. Dont purge the time plot array!
        lappend series "\"$series_title\" $axes $::ThruputBT::time_plot_array($name)"
    }

    # If there are series, plot them.
    set series [string trim $series]
    # puts "series=$series"
    if {$series == ""} {
        return
    }
    if {![info exists ::ThruputBT::title]} {
        set ::ThruputBT::title ""
    }
    set chart [UTF::gnuplot_lines "$::ThruputBT::title" "Time HH:MM:SS" "time"\
        "WLAN Throughput (Mbit/sec)" "BT Throughput (Mbit/sec)" "Time Plot"\
        "$series"]

    # Add formatting to chart.
    regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
    append html_results " &nbsp;<b>DATA</b>&nbsp;${chart}"
}

#======================= error_recovery_procedure =============================
# When request, usually after a fatal error, reload both bluetooth devices and
# make a new BT connection. This ensures the next test or iteration will have
# a relatively clean starting point. Keep track of how often this happens.
# Calling args: none
# Returns: nothing, does NOT throw errors.
#==============================================================================
proc ThruputBT::error_recovery_procedure {bt_dut bt_ref} {

    # This code facilitates unit level interactive debugging.
    if {![info exists ::ThruputBT::bt_pkt]} {
        set ::ThruputBT::bt_pkt auto
    }

    # If necessary, initialize counter for error recovery procedures
    if {![info exists ::ThruputBT::erp_cnt]} {
        set ::ThruputBT::erp_cnt 0
    }
    incr ::ThruputBT::erp_cnt
    UTF::Message LOG "$::localhost" "ThruputBT::error_recovery_procedure\
       START erp_cnt=$::ThruputBT::erp_cnt bt_dut=$bt_dut bt_ref=$bt_ref"

    # Reload both BlueTooth devices.
    # set catch_resp 1 ;# test code
    set catch_resp [catch "$bt_dut reload" catch_msg]
    if {$catch_resp != 0} {
        set logname [UTF::get_name $bt_dut]
        UTF::Message ERROR "$logname" "could not reload bt_dut=$bt_dut!"
    }
    set catch_resp [catch "$bt_ref reload" catch_msg]
    if {$catch_resp != 0} {
        set logname [UTF::get_name $bt_ref]
        UTF::Message ERROR "$logname" "could not reload bt_ref=$bt_ref!"
    }

    # if this is a recovery during the WLAN only throughput test, then skip the BT recovery 
    if {$::ThruputBT::bt_test == "n\/a"} {
        UTF::Message LOG "$::localhost" "ThruputBT::error_recovery_procedure\
           END erp_cnt=$::ThruputBT::erp_cnt\
               ================================================================="
        return
    }

    # Forget the old BT connections.
    $bt_dut delete_acl_handles $::ThruputBT::handle_acl_dut
    $bt_ref delete_acl_handles $::ThruputBT::handle_acl_ref

    if {$::ThruputBT::bt_test == "sco"} {
        $bt_dut delete_sco_handles $::ThruputBT::handle_sco_dut
        $bt_ref delete_sco_handles $::ThruputBT::handle_sco_ref
    }

    # this recovery is not correct when we are in slave mode because
    # when ConnectBTdevices is called, the 1st paramter needs to be the 
    # master, but here bt_dut is passed which could be the slave
    # Make new BT connection.
    if {$::ThruputBT::bt_slave_test == 0} {
        # master connection
        set catch_resp [catch "UTF::Test::ConnectBTdevices \"$bt_dut\" \
            \"$bt_ref\" -type $::ThruputBT::bt_pkt" catch_msg]
    } else {
        # slave connection
        set catch_resp [catch "UTF::Test::ConnectBTdevices \"$bt_ref\" \
            \"$bt_dut\" -type $::ThruputBT::bt_pkt" catch_msg]
    }

    if {$catch_resp != 0} {
        set logname [UTF::get_name $bt_dut]
        UTF::Message ERROR "$logname" "could not establish new BT connection!"
    } else {
        # error_recovery_procedure was ok, set the need_erp to no in order
        # for error_recovery_procedure not to be called again due to retry
        set ::ThruputBT::need_erp no
    }

    # Update the handles that will be used in the next test or iteration.
    # If we didnt get a new connection, the handles are deliberately left
    # as -1, which will quickly trigger errors in the next test.
    set ::ThruputBT::handle_dut -1
    set ::ThruputBT::handle_ref -1
    set ::ThruputBT::handle_acl_dut -1
    set ::ThruputBT::handle_acl_ref -1
    set ::ThruputBT::handle_sco_dut -1
    set ::ThruputBT::handle_sco_ref -1

    set temp [$bt_dut show_acl_handles]
    if {$temp != ""} {
         set ::ThruputBT::handle_dut $temp
         set ::ThruputBT::handle_acl_dut $temp
    }
    set temp [$bt_ref show_acl_handles]
    if {$temp != ""} {
         set ::ThruputBT::handle_ref $temp
         set ::ThruputBT::handle_acl_ref $temp
    }

    if {$::ThruputBT::bt_test == "sco"} {
        set temp [$bt_dut show_sco_handles]
        if {$temp != ""} {
             set ::ThruputBT::handle_dut $temp
             set ::ThruputBT::handle_sco_dut $temp
        }
        set temp [$bt_ref show_sco_handles]
        if {$temp != ""} {
             set ::ThruputBT::handle_ref $temp
             set ::ThruputBT::handle_sco_ref $temp
        }
    }

    # Time will tell if we need to restart the WLAN devices.
    UTF::Message LOG "$::localhost" "ThruputBT::error_recovery_procedure\
       END erp_cnt=$::ThruputBT::erp_cnt bt_dut=$bt_dut bt_ref=$bt_ref\
       ================================================================="
    return
}


#======================= ThruputBT ============================================
# Main test program. Supervises the initialization, runs the desired test
# profile multiple times as needed.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
UTF::Test ThruputBT_dev {bt_dut bt_ref args} {

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts "$::ThruputBT_getopts" "$::ThruputBT_help"

    # Run setup routine. The "" passes the unnamed array to setup.
    ThruputBT::setup $bt_dut $bt_ref ""

    # Run the desired test profile perfloop times.
    # NB: process_results and other routines are watching ::ThruputBT::perf_cnt
    # and expects the final value to be ::ThruputBT::perf_loop, which is why
    # ::ThruputBT::perf_cnt needs to start at 1, not 0.
    set iteration_errors 0 ;# keep track of all errors across all iterations.
    for {set ::ThruputBT::perf_cnt 1} {$::ThruputBT::perf_cnt <=\
        $::ThruputBT::perf_loop} {incr ::ThruputBT::perf_cnt} {

        # When running multiple iterations, put a marker line in the log.
        if {$::ThruputBT::perf_loop > 1} {
            UTF::Message LOG "$::localhost" "ThruputBT getting sample\
                set $::ThruputBT::perf_cnt of $::ThruputBT::perf_loop\
                ============================================================="
    }

        # Run the desired test profile, count all errors.
        set results ""
        set catch_msg ""
        set catch_resp [catch "set results \[ThruputBT::test_profile$(profile)\
            $bt_dut $bt_ref\]" catch_msg]
        if {$catch_resp != 0} {
            incr iteration_errors ;# keep track of all errors across all iterations.
        }
        UTF::Message LOG "$::localhost" "ThruputBT main loop iteration:\
            $::ThruputBT::perf_cnt of $::ThruputBT::perf_loop \
            iteration_errors=$iteration_errors catch_resp=$catch_resp\
            catch_msg=$catch_msg\nresults=$results"

        # Reset the timer cmds, or they accumulate from one iteration to
        # the next.
        set ::ThruputBT::timer_cmds ""

        # NB: Never reset the fatal_error, or  it wont show up on the web
        # page summary.

        # do not do the recovery with RvR since the weak signal could cause
        # failure which is normal and we should not recover/reload

        # ----> take out recovery for code development

         if {$::ThruputBT::attn_type == 0} {
             # When requested, do the error recovery procedure. This ensures
             # that the next test or iteration will have a relatively clean
             # starting point.
             # Sometimes error_recovery_procedure fails and retry is needed
             for {set retry_cnt 1} {$retry_cnt <= 3} {incr retry_cnt} {
                 if {$::ThruputBT::need_erp == "yes"} {
                     UTF::Message LOG "$::localhost" "======================================================================================================="
                     UTF::Message LOG "$::localhost" "error_recovery_procedure try $retry_cnt"
                     ThruputBT::error_recovery_procedure $bt_dut $bt_ref
                 }
             }
         }

         # end of recovery code

    }

    # Return the results.
    UTF::Message LOG "$::localhost" "ThruputBT main loop completed\
        iteration_errors=$iteration_errors\
        erp_cnt=$::ThruputBT::erp_cnt"
    UTF::Message LOG "$::localhost" "max_socket_delay=$::ThruputBT::running_max_socket_delay\
        seconds occured at: $::ThruputBT::running_max_socket_timestamp"
    if {$iteration_errors == 0} {
        return "$results"
    } else {
        set error_result "$results $catch_msg"
        set error_result [string trim $error_result]
        error "$error_result"
    }

}
