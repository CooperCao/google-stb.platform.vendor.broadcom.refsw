#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script to test effects with a nearby or proximate BSS
#
# Written by: Robert J. McMahon April 2014
#
# $Copyright Broadcom Corporation$
#
# Expected RF diagram needed for the script
#
#       ProxAP
#  AP     /
#    \   / L1
#  K0 \ /
#      *
#     / \
# L2 /   \ L3
#   /     \
# Sta    ProxSta
#
# where * is a 3x3 mesh.  Ks are relative constants per fixed attenuation losses and L1-L3 are variable attenuator legs
#
#   L1 is ProxAP cget -attngrp
#   L2 is STA cget -attngrp
#   L3 is ProxSTA cget -attngrp
#
# Estimated signal losses are:
#
#   AP<->ProxAP = K0 + L1
#   AP<->Sta = K0 + K2 + L2
#   AP<->ProSta = K0 + K3 + L3
#   Sta<->ProxAP = L1 + L2 + K2 + K1
#   Sta<->ProxSta = L2 + L3 + K2 + K3
#   ProxSta<->ProxAP = L1 + L3 + K3 + K1
#
package require UTF
package require UTF::Streams
package require UTF::ControlChart
package require UTF::MemChart
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::BridgeCheck
package require UTF::Test::ConfigBridge
package require UTF::wlstats
package require UTF::Test::ACSD

# Use Tclx if available:
catch {
    package require Tclx
    # Prevent sigint from killing our shell:
    signal trap SIGINT {::UTF::stream allstreams exit; error "SIGINT"}
}
namespace eval UTF::Test {
    variable doloop
    proc dut_poll {args} {
	upvar {} testopts
    }
}

UTF::Test ProximateBSS {args} {
    UTF::Getopts {
	{nosetup ""}
	{email.arg ""}
	{noload ""}
	{noconfig ""}
	{title.arg "" "Title"}
	{ap.arg "4708sf_bison" "AP under test"}
	{sta.arg "4360lx1" "STA under test"}
	{starssi.arg "-1" "RSSI desired for the BSS STA"}
	{staattn.arg "-1" "Attenuation desired for the BSS STA"}
	{proxstaattn.arg "-1" "Attenuation desired for the ProxBSS STA"}
	{proximateap.arg "4360br1_bison" "AP under test"}
	{proximatesta.arg "4360lx2" "STA under test"}
	{proximatestrength.arg "auto" "proximate signal strength reductions"}
	{chanspec.arg "161/80" "Chanspec to use for BSS"}
	{proximatechanspec.arg "140/20" "Chanspec(s) to use for proximate BSS"}
	{brand.arg "" "Brand override"}
	{apbrand.arg "" "AP brand override"}
	{stabrand.arg "" "STA brand override"}
	{date.arg "" "Image date"}
	{stadate.arg "" "STA Image date"}
	{rtrdate.arg "" "Router Image date"}
	{tag.arg "" "Image tag"}
	{rtrtag.arg "" "Router image tag"}
	{statag.arg "" "STA tag"}
	{bin.arg "" "STA dongle image"}
	{trx.arg "" "Router trx"}
	{branch.arg "" "Branch override"}
	{offered.arg "40M" "Traffic rate"}
	{pktsize.arg "1460" "UDP payload size"}
	{holdtime.arg "30"}
	{reportinterval.arg "0.5"}
	{disturbtime.arg "60"}
	{disturbrate.arg "-1"}
	{recovertime.arg "30"}
	{key.arg "" ""}
	{perfcache.arg "" "Performance Cache"}
	{history.arg 30 "Performance History"}
	{security.arg "open" "Default security"}
	{graphtype.arg "png" "Graph type"}
	{devicemode.arg "0" "Router device mode"}
	{graphsize.arg "640,480" "Graph size"}
	{noptp "Don't do PTP check"}
	{scale.arg "1" "Scale the times"}
	{nodisturb "Don't start the interference traffic"}
	{scansuppress "disable scanning"}
	{obss_prot.arg "-1" "obss protection feature"}
	{5g_rate.arg "auto 1x3 1x2" "Force 5g rates, takes list"}
	{obsstimer.arg "900" "Units of milliseconds"}
	{roamtrigger.arg "-100" "roamtrigger value"}
	{fttr "Run an FTTR/RvR"}
	{towards ""}
	{msglevel.arg "error" "Set the wl msglevel to be used during tests"}
	{debug "enable realtime wl polling per various DE requests"}
	{ucflags "set ucflags per DE's request"}
	{direction.arg "down" "UDP traffic direction"}
	{proximate_traffic.arg "tcp" "Traffic type between proximate AP and STA"}
	{mimotxbw.arg "0" "set mimo_tx_bw"}
	{acifcs  "test the acs/fcs feature"}
	{interference.arg "-1" "ACI mode"}
	{phytable "Dump phytable"}
	{K3.arg "30" "Signal strength constant"}
	{zplboundary.arg "-30" "Boundary of proximateap/proximatesta where zpl should be seen"}
    }
    # RJM need a way to calibrate this per rig, per DUTs and per band
    # Also set the default proximatestrength list from these calibrated values
    set K3 $(K3)
    set STARSSIOFFSET 25 ;# K0 + K1
    set STAMIDATTN [expr {65 - $STARSSIOFFSET}]
    if {$(proximatestrength) eq "auto"} {
	if {$(acifcs)} {
	    set (proximatestrength) "10"
	} else {
	    set (proximatestrength) "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 45 55"
	}
    }
    if {$(towards)} {
	set (proximatestrength) [lsort -integer -decreasing $(proximatestrength)]
    }
    set (holdtime) [expr {$(holdtime) * $(scale)}]
    set (disturbtime) [expr {$(disturbtime) * $(scale)}]
    set (recovertime) [expr {$(recovertime) * $(scale)}]
    set (obsstimer) [expr {$(obsstimer) * $(scale)}]
    #
    # Figure out what's being tested by parsing the sta list
    #
    # Note: $(sta) can contain a list inside the list, i.e.
    # for multicast testing it would look like
    # {43331Lx5 {iptv_br1 iptv_br2}}
    set BRS ""
    set STAS ""
    set ROUTERS ""
    foreach STA [concat $(sta) $(proximatesta)] {
	if {[$STA hostis Router] && [lsearch $ROUTERS $STA] == -1} {
	    lappend BRS $STA
	    lappend ROUTERS $STA
	} elseif {![$STA hostis Router] && [lsearch $STAS $STA] == -1} {
	    lappend STAS $STA
	}
    }
    if {![$(ap) hostis Router]} {
	lappend STAS $(ap)
    }
    foreach AP [concat $(ap) $(proximateap)] {
	if {[$AP hostis Router] && [lsearch $ROUTERS $AP] == -1} {
	    lappend ROUTERS $AP
	}
    }
    if {$(trx) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -image $(trx) -date {}
	    lappend cckey_common "${Router}=$(trx)"
	}
    } elseif {$(rtrtag) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -tag $(rtrtag) -date {}
	    lappend cckey_common "${Router}=$(rtrtag)"
	}
    } else {
	foreach Router $ROUTERS {
	    lappend cckey_common "${Router}=[$Router cget -tag]"
	}
    }
    # In the case of no STAS, use brand
    # to set both AP and bridges
    if {![llength $STAS] && $(brand) ne ""} {
	foreach Router $ROUTERS {
	    $Router configure -brand $(brand)
	}
    }
    if {$(apbrand) eq ""} {
	lappend cckey_common [$(ap) cget -brand]
    } else {
	$(ap) configure -brand $(apbrand)
	lappend cckey_common $(apbrand)
    }
    foreach BR $BRS {
	if {$(stabrand) ne ""} {
	    $BR configure -brand $(stabrand)
	} elseif {$(brand) ne ""} {
	    $BR configure -brand $(brand)
	}
	lappend cckey_common "${BR}=[$BR cget -brand]"
    }
    if {$(date) ne {}} {
	foreach dut [concat $(ap) $BRS $STAS] {
	    $dut configure -date $(date)
	}
    }
    if {$(rtrdate) ne {}} {
	foreach Router $ROUTERS {
	    $Router configure -date $(rtrdate)
	}
    }
    if {$(stadate) ne {}} {
	foreach STA $STAS {
	    $STA configure -date $(stadate)
	}
    }
    foreach STA $STAS {
	if {$(bin) ne ""} {
	    $STA configure -image $(bin) -date {}
	} elseif {$(statag) eq ""} {
	    lappend cckey_common "${STA}=[$STA cget -tag]"
	} else {
	    $STA configure -tag $(statag)
	    lappend cckey_common "${STA}=$(statag)"
	}
    }
    set (key) [concat $(key) [list [$(ap) cget -tag] [$(ap) cget -brand] [$(sta) cget -tag] [$(sta) cget -brand]]]
    if {$(trx) ne ""} {
	$(ap) configure -image $(trx) -date {}
	append (key) $(trx)
    }
    if {$(title) eq "" && $(sta) ne ""} {
	set sta [lindex $(sta) 0]
	if {[$sta hostis WinDHD Cygwin]} {
	    set (title) [$sta host whatami]
	} elseif {[$sta hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$sta hostis]
	}
	if {[regexp {(\d+sd)} $(ap) - c]} {
	    append (title) " with $c AP"
	}
    }
    # Compact build list for title
    # will be removed automatically.
    set build [UTF::BuildTitle [concat $ROUTERS $STAS ]]
    set TITLE "Proximate-BSS $(title) ($build) (ch=$(chanspec), $(proximatechanspec))"
    if {$(debug)} {
	set (phytable) 1
	append TITLE " Debug"
    } else {
	append TITLE " NoDebug"
    }
    if {[$(ap) cget -attngrp] eq ""} {
	append TITLE " Nearest=AP"
	set STAATTNGRP [$(sta) cget -attngrp]
    } elseif {[$(sta) cget -attngrp] eq "" } {
	append TITLE " Nearest=STA"
	set STAATTNGRP [$(ap) cget -attngrp]
    } else {
	set STAATTNGRP [$(sta) cget -attngrp]
	append TITLE " Nearest=Unknown"
    }

    if {$STAATTNGRP eq ""} {
	error "Either $(ap) or $(sta) must have a -attngrp configured"
    }
    array set aRSSI {}


    UTF::Message INFO "" $TITLE
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	UTF::Try "Validate" {
	    set errmsg {}
	    if {[[$(ap) cget -host] cget -console] eq [[$(proximateap) cget -host] cget -console]} {
		set errmsg "AP $(ap) must be different hw from proximateap, "
	    }
	    if {[[$(sta) cget -host] cget -console] eq [[$(proximatesta) cget -host] cget -console]} {
		append errmsg "STA $(sta) must differ from proximatesta"
	    }
	    if {$errmsg ne {}} {
		error $errmsg
		exit
	    }
	}
	if {!$(noptp) && [info command ::enable_ptp] eq "::enable_ptp"} {
	    UTF::Try "PTP Check/Setup" {
		
		foreach DUT "$(ap) $(sta) $(proximateap) $(proximatesta)" {
		    if {[catch {$DUT lan pidof ptpd2}]} {
			eval ::enable_ptp
			break
		    }
		}

	    }
	} 
	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	# Use SoftAP for case of STA/STA
	if {![$(ap) hostis Router]} {
	    $(ap) configure -ap 1
	    $(ap) configure -ipaddr 192.168.100.60
	    $(ap) configure -ssid "SoftAP"
	    $(sta) configure -ipaddr 192.168.100.61
	    $(ap) configure -wlinitcmds "ifconfig [$(ap) cget -device] 192.168.100.60; wl ssid SOFTAP"
	    $(sta) configure -wlinitcmds "ifconfig [$(sta) cget -device] 192.168.100.61"
	}
	if {!$(noload)} {
	    foreach Router $ROUTERS {
		UTF::Try "[$Router cget -name]: Find AP Image" {
		    set locdate [$Router cget -date]
		    if { ([string length $locdate] < 5) || ( $locdate == "%date%") } {
			set locdate ""
		    }
		    UTF::CheckImage $Router $locdate unknown
		}
		UTF::Try "[$Router cget -name]: Load Image" {
		    if {$Router eq $(ap) || $Router eq $(sta) } {
			if { [$Router cget -image] ne {} } {
			    $Router load -force
			}
		    } else {
			$Router load
		    }
		}
		if {[$Router hostis Router]} {
		    UTF::Try "[$Router cget -name]: Restore Defaults" {
			$Router restore_defaults
		    }
		    if {$(devicemode) && ($Router eq $(ap) || $Router eq $(sta))} {
			package require UTF::Test::DeviceMode
			UTF::Try "[$Router cget -name]: Device Mode 1" {
			    UTF::Test::DeviceMode -ap $Router -mode 1
			}
			UTF::Try "[$Router cget -name]: Chanspecs" {
			    $Router allchanspecs
			    $Router wl -u vht_features
			    $Router wl -u vhtmode
			}
		    }
		}
		UTF::Try "[$Router cget -name]: whatami" {
		    set what [$Router whatami]
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		    $Router dbrecord DUT
		}
	    }
	    foreach STA $STAS {
		UTF::Try "$STA Find STA Image" {
		    set locdate [$STA cget -date]
		    if { ([string length $locdate] < 5) || ( $locdate == "%date%") } {
			set locdate ""
		    }
		    UTF::CheckImage $STA $locdate unknown
		}
		UTF::Try "$STA load" {
		    $STA load
		}
		UTF::Try "[$STA cget -name]: defaults" {
		    $STA services stop
		    catch {$STA wl msglevel +error +assoc}
		    if {![$STA cget -nomimo_bw_cap]} {
			catch {$STA wl down}
			# Enable 40 in 2.4, if available.
			# Doesn't work for LMAC since LMAC is never "down"
			$STA wl -u mimo_bw_cap 1
			$STA wl up
			UTF::Sleep 1
		    }
		    $STA wl ver
		    set what [$STA whatami]
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		    $STA dbrecord DUT
		    set what
		}
	    }
	}
	if {!$(noconfig)} {
	    UTF::Try "BSS([$(ap) wlname]) Chanspec: $(chanspec)" {
		UTF::Test::APChanspec $(ap) $(chanspec)
	    }
	    UTF::Try "ProxBSS([$(proximateap) wlname]) Chanspec: $(proximatechanspec)" {
		UTF::Test::APChanspec $(proximateap) $(proximatechanspec)
	    }
	    UTF::Try "Security: $(security)" {
		UTF::Test::APConfigureSecurity $(ap) -security $(security)
		UTF::Test::APConfigureSecurity $(proximateap) -security $(security)
	    }
	    foreach {STA AP} "$(sta) $(ap) $(proximatesta) $(proximateap)" {
		if {$AP eq $(ap)} {
		    set CHSPEC $(chanspec)
		} else {
		    set CHSPEC [lindex $(proximatechanspec) 0]
		}
		if {[$STA hostis Router]} {
		    $STAATTNGRP attn $STAMIDATTN
		    UTF::Test::ConfigBridge -ap $AP -br $STA -chanspec $CHSPEC -security $(security) -linkcheck -proxysta
		} else {
		    UTF::Try "Assoc: [$STA cget -name] w/[$AP cget -name]" {
			UTF::Test::ConnectAPSTA $AP $STA
			$(sta) wl -u status
			return
		    }
		}
	    }
	    if {$(acifcs)} {
		catch {UTF::Test::PSPretend -ap $(ap) -sta $(sta) -pspretend "0 5" -serial}
		UTF::Test::ACSD -ap $(ap) -sta $(sta) -configonly
		UTF::Test::PSPretend -ap $(ap) -sta $(sta) -pspretend "5" -serial
	    }
	}
	if {$(direction) eq "up"} {
	    UTF::stream udp -rx $(ap) -tx $(sta) -pktsize 1470 -rate $(offered) -w 1M -reportinterval $(reportinterval)
	    UTF::stream udp_reverse -tx $(ap) -rx $(sta) -pktsize 1470 -rate $(offered) -w 1M -reportinterval $(reportinterval)
	} else {
	    UTF::stream udp -tx $(ap) -rx $(sta) -pktsize 1470 -rate $(offered) -w 1M -reportinterval $(reportinterval)
	    UTF::stream udp_reverse -rx $(ap) -tx $(sta) -pktsize 1470 -rate $(offered) -w 1M -reportinterval $(reportinterval)
	}
	if {$(proximate_traffic) eq "tcp"} {
	    set PROXTXT "ProxTCP"
	    if {$(disturbrate) eq -1} {
		set prox_traffic [UTF::stream %AUTO% -tx $(proximateap) -rx $(proximatesta) -protocol tcp -w 1M -name "prox_tcp"]
	    } else {
		set prox_traffic [UTF::stream %AUTO% -tx $(proximateap) -rx $(proximatesta) -protocol tcp -w 1M -name "prox_tcp" -rate $(disturbrate)]
	    }
	} else {
	    set PROXTXT "ProxUDP"
	    set prox_traffic [UTF::stream %AUTO% -tx $(proximateap) -rx $(proximatesta) -protocol udp -w 1M -name "prox_udp" -rate 100M -pktsize 1470]
	}
	if {[$(sta) hostis Router]} {
	    set mac [[$(sta) lan] macaddr]
	} else {
	    set mac [$(sta) macaddr]
	}
	$(ap) wl -u msglevel +time
	set pktqstats($(sta)) [UTF::wlstats::pktqstat %AUTO% -key "$mac [udp id ]" -wlcmd "$(ap) wl pktq_stats a:+$mac" -name $(ap)]
	set pktqstats(common) [UTF::wlstats::pktqstat %AUTO% -key "common $mac [udp id ]" -wlcmd "$(ap) wl pktq_stats c:+" -name $(ap)]
	if {$(staattn) ne "-1"} {
	    set HUNTTXT "NoHunt/$(staattn)"
	} else {
	    set HUNTTXT "Hunt"
	}
	foreach PCHSPEC $(proximatechanspec) {
	    if {$(fttr)} {
		set TRYTEXT "$HUNTTXT [udp cget -rate] lossless, Symmetry, RvR, roam=$(roamtrigger) Proximate-BSS: $PCHSPEC"
	    } else {
		set TRYTEXT "$HUNTTXT [udp cget -rate] lossless, Symmetry, roam=$(roamtrigger) Proximate-BSS: $PCHSPEC"
	    }
	    UTF::Try "$TRYTEXT" {
		[$(proximatesta) cget -attngrp] attn $K3
		if {$PCHSPEC ne [lindex $(proximatechanspec) 0]} {
		    UTF::Test::APChanspec $(proximateap) $PCHSPEC
		    if {[$(proximatesta) hostis Router]} {
			$STAATTNGRP attn $STAMIDATTN
			UTF::Test::ConfigBridge -ap $(proximateap) -br $(proximatesta) -chanspec $PCHSPEC -security $(security) -linkcheck -proxysta
		    } else {
			UTF::Test::ConnectAPSTA $(proximateap) $(proximatesta)
		    }
		}
		foreach STA "$(sta) $(proximatesta)" {
		    $STA wl roam_trigger $(roamtrigger) all
		}
		UTF::Try "Scans/msglevel=$(msglevel)" {
		    $(sta) wl scansuppress 0
		    $(proximatesta) wl scansuppress 0
		    $STAATTNGRP attn $STAMIDATTN
		    foreach DUT "$(ap) $(proximateap) $(sta) $(proximatesta)" {
			UTF::Try "$DUT Scan/msglevel" {
			    catch {$DUT wl msglevel $(msglevel)}
			    # Do three scans
			    catch {$DUT wl_escanresults}
			    catch {$DUT wl_escanresults}
			    if {![catch {$DUT wl_escanresults} output]} {
				if {$DUT ne $(ap)} {
				    set apssid [$(ap) wl ssid]
				    set apchannel [lindex [$(ap) wl chanspec] 0]
				} else {
				    set apssid [$(proximateap) wl ssid]
				    set apchannel [lindex [$(proximateap) wl chanspec] 0]
				}
				if {[regexp "SSID:\\\s+\\\"$apssid\\\".+?Mode:.+?RSSI:\\\s*(-\[0-9\]+)\\\s+dBm.+?Channel:\\\s+$apchannel" $output - peerrssi]} {
				    UTF::Message INFO $DUT "$peerrssi"
				    set rssi($DUT) "$apchannel ${peerrssi} dBm"
				} else {
				    set rssi($DUT) "$apchannel NotFound"
				    set peerrsi "Unknown"
				}
			    }
			    return "$apssid $apchannel ${peerrssi} dBm"
			}
		    }
		}
		if {$(starssi) ne "-1"} {
		    set STAEDGEATTN [expr {$(starssi) - $STARSSIOFFSET}]
		    if {$STAEDGEATTN < 0} {
			set STAEDGEATTN 0
		    }
		} elseif {$(staattn) ne "-1"} {
		    set STAEDGEATTN $(staattn)
		} else {
		    UTF::Try "$(sta) hunt [udp cget -rate] lossless boundary" {
			$STAATTNGRP attn $STAMIDATTN
			$(sta) wl scansuppress 1
			udp configure -reportinterval 2
			udp start;
			udp linkcheck -now
			while {![catch {udp linkcheck -txstrict -now}]} {
			    $STAATTNGRP incr +1
			}
			$STAATTNGRP incr -2
			udp stop
			$(sta) wl scansuppress 0
			while {[lindex [$STAATTNGRP attn?] 0] >= 0} {
			    # Force a new socket
			    udp incr_dstport
			    udp start
			    if {![catch {udp linkcheck -now} err]} {
				set aid [after [expr {4 * $(holdtime) * 1000}] {}]
				while {![catch {after info $aid}] && ![catch {udp linkcheck -strict -now}]} {
				    UTF::Sleep 0 quiet
				}
				# If aid expired this is a lossless UDP stream
				if {[catch {after info $aid}]} {

				    udp stop
				    break
				}
			    } else {
				UTF::Message ERROR "" $err
			    }
			    catch {after cancel $aid}
			    $STAATTNGRP incr -1
			    udp stop
			    UTF::Sleep 2
			}

			udp configure -reportinterval $(reportinterval)
			set STAEDGEATTN [lindex [$STAATTNGRP attn?] 0]
			return  "STA EDGE=$STAEDGEATTN"
		    }
		}
		if {$(proxstaattn) ne "-1"} {
		    set PROXSTAEDGEATTN $(proxstaattn)
		} else {
		    UTF::stream udp-prox -tx $(proximateap) -rx $(proximatesta) -pktsize 1470 -rate $(offered) -w 1M -reportinterval $(reportinterval)
		    UTF::Try "$(proximatesta) hunt [udp-prox cget -rate] lossless boundary" {
			[$(proximateap) cget -attngrp] attn 0
			[$(proximatesta) cget -attngrp] attn 0
			set ATTNGRP [$(proximatesta) cget -attngrp]
			$(proximatesta) wl scansuppress 1
			udp-prox configure -reportinterval 2
			udp-prox start;
			udp-prox linkcheck -now
			while {![catch {udp-prox linkcheck -txstrict -now}]} {
			    $ATTNGRP incr +1
			}
			if {[catch {$ATTNGRP incr -5}]} {
			    UTF::Message WARN $ATTNGRP "Couldn't move 5 DB closer, $ATNNGRP at [$ATTNGRP attn?]"
			}
			udp-prox stop
			$(proximatesta) wl scansuppress 0
			while {[lindex [$ATTNGRP attn?] 0] >= 0} {
			    # Force a new socket
			    udp-prox incr_dstport
			    udp-prox start
			    if {![catch {udp-prox linkcheck -now} err]} {
				set aid [after [expr {4 * $(holdtime) * 1000}] {}]
				while {![catch {after info $aid}] && ![catch {udp-prox linkcheck -strict -now}]} {
				    UTF::Sleep 0 quiet
				}
				# If aid expired this is a lossless UDP stream
				if {[catch {after info $aid}]} {
				    break
				}
			    } else {
				UTF::Message ERROR "" $err
			    }
			    catch {after cancel $aid}
			    $ATTNGRP incr -1
			    udp-prox stop
			    UTF::Sleep 2
			}
			udp-prox stop
			udp-prox configure -reportinterval $(reportinterval)
			set PROXSTAEDGEATTN [lindex [$ATTNGRP attn?] 0]
			return  "PROXSTA EDGE=$PROXSTAEDGEATTN"
		    }
		    catch {udp-prox destroy}
		}
		UTF::Try "Symmetry Check" {
		    UTF::stream allstreams stop
		    $(ap) uname -r
		    $(sta) uname -r
		    $(proximateap) uname -r
		    $(proximatesta) uname -r
		    udp start
		    catch {udp_reverse start}
		    UTF::Sleep 2
		    UTF::Message INFO $(ap) "*** AP RSSI BELOW ***"
		    $(ap) wl -u dump rssi
		    UTF::Message INFO $(ap) "*** STA RSSI BELOW ***"
		    $(sta) wl -u dump rssi
		    UTF::Message INFO $(ap) "*** AP CURPOWER BELOW ***"
		    $(ap) wl -u curpower
		    UTF::Message INFO $(ap) "*** STA CURPOWER BELOW ***"
		    $(sta) wl -u curpower
		    udp_reverse stop
		    udp stop
		}
		UTF::Try "Traffic Proximate BSS" {
		    UTF::stream allstreams stop
		    catch {[$(proximateap) lan] ping [$(proximatesta) lan]}
		    $prox_traffic start
		    $prox_traffic stop
		}
		if {$(fttr)} {
		    UTF::Try "RvR" {
			package require UTF::Test::FTTRBasic
			$STAATTNGRP attn 0
			UTF::Test::FTTRBasic -ap $(ap) -sta $(sta) -count 2 -tos "0x0" -nosetuptestbed -protocol udp -direction down -dwell 2
		    }
		}
		UTF::stream allstreams stop
		$STAATTNGRP attn $STAEDGEATTN
		return [lindex [$STAATTNGRP attn?] 0]
	    }
	    set TIMETXT "$(holdtime)s/$(disturbtime)s/$(recovertime)s"
	    if {$(obss_prot) ne "-1"} {
		append TIMETXT  " obss_prot=$(obss_prot)"
	    }
	    if {$(nodisturb)} {
		append TIMETXT  " nodisturb=$(nodisturb)"
	    }
	    UTF::stream allstreams stop
	    foreach STRENGTH $(proximatestrength) {
		foreach nrate $(5g_rate) {
		    UTF::Try "Traffic $TIMETXT Attn=$STRENGTH $nrate" {
			if {$(acifcs)} {
			    $(ap) reboot
			    UTF::Sleep 70
			    UTF::Test::ACSD -ap $(ap) -sta $(sta) -configonly
			    $(ap) wl status
			    set originalchanspec [$(ap) wl chanspec]
			    set CHSPEC [lindex [$(ap) wl chanspec] 0]
			}
			catch {array unset txlost *}
			catch {array unset rssi *}
			set totaltxlost 0
			UTF::Try "Attenuations/ucflags/mimotxbw" {
			    set ATTNGRP [$(proximateap) cget -attngrp]
			    UTF::Message INFO  ATTN-$ATTNGRP "Set $(proximateap)(ProxAP) attn $STRENGTH (K3=$K3)"
			    $ATTNGRP attn $STRENGTH
			    set PSTAATTN [expr {$PROXSTAEDGEATTN - $STRENGTH}]
			    if {$PSTAATTN < 0} {
				set PSTAATTN 0
			    }
			    set ATTNGRP [$(proximatesta) cget -attngrp]
			    UTF::Message INFO ATTN-$ATTNGRP "Set $(proximatesta)(ProxSTA) attn $PSTAATTN (K3=$K3)"
			    $ATTNGRP attn $PSTAATTN
			    set ATTNGRP $STAATTNGRP
			    UTF::Message INFO ATTN-$ATTNGRP "Set $(sta) (STA) attn $STAEDGEATTN (K3=$K3)"
			    $ATTNGRP attn $STAEDGEATTN
			    # Special flags set below
			    if {$(ucflags)} {
				$(sta) wl ucflags 1 0x20
				$(ap) wl revinfo
			    }
			    switch -exact $(mimotxbw) {
				"10" {
				    $(ap) wl mimo_txbw 12
				}
				"10" {
				    $(ap) wl mimo_txbw 12
				    $(proximateap) wl mimo_txbw 12
				}
				default {
				    UTF::Message INFO "" "no chnage to mimo_tx_bw"
				}
			    }
			}
			UTF::Try "Interference=$(interference)" {
			    if {$(interference) ne "-1"} {
				$(ap) wl interference $(interference)
			    }
			    set a [$(ap) wl interference]
			    if {[regexp {Mode\s=\s([0-9])} $a - mode]} {
				return "Mode=$mode"
			    } else {
				return $a
			    }
			}
			if {$(scansuppress)} {
			    set TRYTEXT "Scans/Scansuppress"
			    set ss 1
			} else {
			    set TRYTEXT "Scans/NoScansuppress"
			    set ss 0
			}
			UTF::Try "$TRYTEXT" {
			    UTF::stream allstreams stop
			    $(sta) wl scansuppress 0
			    $(proximatesta) wl scansuppress 0
			    foreach DUT "$(ap) $(proximateap) $(sta) $(proximatesta)" {
				if {$DUT eq $(ap)} {
				    set DUTTXT "AP=$DUT"
				} elseif {$DUT eq $(proximateap)} {
				    set DUTTXT "ProxAP=$DUT"
				} else {
				    set DUTTXT "$DUT"
				}
				UTF::Try "$DUTTXT Scan" {
				    catch {$DUT wl status}
				    # Do three scans
				    catch {$DUT wl_escanresults}
				    catch {$DUT wl_escanresults}
				    set output {}
				    if {![catch {$DUT wl_escanresults} output]} {
					if {$DUT ne $(ap)} {
					    set apssid [$(ap) wl ssid]
					    set apchannel [lindex [$(ap) wl chanspec] 0]
					} else {
					    set apssid [$(proximateap) wl ssid]
					    set apchannel [lindex [$(proximateap) wl chanspec] 0]
					}
					if {[regexp "SSID:\\\s+\\\"$apssid\\\".+?Mode:.+?RSSI:\\\s*(-\[0-9\]+)\\\s+dBm.+?Channel:\\\s+$apchannel" $output - peerrssi]} {
					    UTF::Message INFO $DUT "$peerrssi"
					    set rssi($DUT) "$apchannel ${peerrssi} dBm"
					} else {
					    set rssi($DUT) "$apchannel NotFound"
					    set peerrsi "Unknown"
					}
				    } else {
					set rssi($DUT) "$apchannel ScanErr"
					set peerrsi "Unknown"
				    }
				    if {$DUT eq $(sta) || $DUT eq $(proximatesta)} {
					$DUT wl scansuppress $ss
				    }
				    set aRSSI($DUT) ${peerrssi}
				    return "$apssid $apchannel ${peerrssi} dBm"
				}
			    }
			}
			if {$(obss_prot) ne "-1"} {
			    $(ap) wl obss_prot $(obss_prot)
			}
			if {$nrate ne "auto"} {
			    $(ap) wl 5g_rate -v $nrate -l
			} else {
			    $(ap) wl 5g_rate auto
			}
			UTF::Try "ProxTraffic test" {
			    $prox_traffic start
			    $prox_traffic linkcheck -now
			}
			catch {$prox_traffic stop}
			UTF::stream allstreams stats -clear
			set events {}
			if {$(debug)} {
			    $(ap) wl -u ampdu_clear_dump
			    if {[catch {$(ap) wl -u dump phynoise}]} {
				catch {$(ap) wl -u dump phyaci}
			    }
			    $(ap) wl -u counters
			    set prevtxlost 0
			}
			foreach STAT [array names pktqstats] {
			    $pktqstats($STAT) sample
			}
			if {$(debug)  || $(phytable)} {
			    $(ap) wl -u phytable 68 offset 8
			    $(ap) wl -u phytable 69 offset 8
			    $(ap) wl -u phyreg 0x6dc
			    $(ap) wl -u phyreg 0x6dd
			}
			udp start;
			if {$(phytable)} {
			    if {[catch {$(ap) wl -u dump phynoise} err]} {
				catch {$(ap) wl -u dump phyaci} err
			    }
			}
			set starttime [UTF::stream clock]
			set t1 [clock clicks -milliseconds]
			for {set ix 0} {$ix < $(holdtime)} {incr ix}  {
			    set t2 [clock clicks -milliseconds]
			    UTF::Sleep [expr {(1000 - ($t2 - $t1))/1000.0}]
			    set t1 [clock clicks -milliseconds]
			    if {$(debug) || $(phytable)} {
				$(ap) wl -u phytable 68 offset 8
				$(ap) wl -u phytable 69 offset 8
				$(ap) wl -u phyreg 0x6dc
				$(ap) wl -u phyreg 0x6dd
			    }
			    if {$(debug)} {
				foreach DUT "$(ap) $(sta)" {
				    $DUT wl -u dump obss; $DUT wl -u dump_obss -d $(obsstimer)
				}
				foreach STAT [array names pktqstats] {
				    $pktqstats($STAT) sample
				}
				if {![catch {$(ap) wl -u dump ampdu} output] && [regexp {txlost ([0-9]+)} $output - lost]} {
				    set tlost [expr {$lost - $prevtxlost}]; set prevtxlost $lost
				    set txlost([expr {[UTF::stream clock] - $starttime}]) $tlost
				    if {$tlost < 0 && $lost==0} {
					set prevtxlost 0
					UTF::Message WARN "" "AMPDU txlost reset to zero unexpectedly"
				    } else {
					set totaltxlost +$tlost
				    }
				} else {
				    set txlost([expr {[UTF::stream clock] - $starttime}]) -1
				}
				if {$(phytable)} {
				    if {[catch {$(ap) wl -u dump phynoise}]} {
					catch {$(ap) wl -u dump phyaci}
				    }
				    $(ap) wl -u counters
				}
			    }
			}
			set t1 [clock clicks -milliseconds]
			lappend events [list "i" [expr {[UTF::stream clock] - $starttime}]]
			foreach STAT [array names pktqstats] {
			    $pktqstats($STAT) sample
			}
			if {$(debug) || $(phytable)} {
			    if {[catch {$(ap) wl -u dump phynoise} err]} {
				UTF::Message WARNING "$(ap)" $err
				if {[catch {$(ap) wl -u dump phyaci} err]} {
				    UTF::Message WARNING "$(ap)" $err
				}
			    }
			    $(ap) wl -u phytable 68 offset 8
			    $(ap) wl -u phytable 69 offset 8
			    $(ap) wl -u phyreg 0x6dc
			    $(ap) wl -u phyreg 0x6dd
			}
			# TCP starts are failing
			if {!$(nodisturb) && [catch {$prox_traffic start} err]} {
			    error "Proximate: $err"
			}
			if {$(debug)} {
			    if {[catch {$(ap) wl -u dump phynoise} err]} {
				UTF::Message WARNING "$(ap)" $err
				if {[catch {$(ap) wl -u dump phyaci} err]} {
				    UTF::Message WARNING "$(ap)" $err
				}
			    }
			    $(ap) wl -u counters
			}
			set ::UTF::Test::doloop 1
			after [expr {round($(disturbtime) * 1000)}] [list set ::UTF::Test::doloop 0]
			while {$::UTF::Test::doloop} {
			    if {$(debug)  || $(phytable)} {
				$(ap) wl -u phytable 68 offset 8
				$(ap) wl -u phytable 69 offset 8
				$(ap) wl -u phyreg 0x6dc
				$(ap) wl -u phyreg 0x6
			    }
			    if {$(debug)} {
				foreach DUT "$(ap) $(sta)" {
				    $DUT wl -u dump obss; $DUT wl -u dump_obss -d $(obsstimer)
				}
				foreach STAT [array names pktqstats] {
				    $pktqstats($STAT) sample
				}
				if {![catch {$(ap) wl -u dump ampdu} output] && [regexp {txlost ([0-9]+)} $output - lost]} {
				    set tlost [expr {$lost - $prevtxlost}]; set prevtxlost $lost
				    set txlost([expr {[UTF::stream clock] - $starttime}]) $tlost
				    incr totaltxlost +$tlost
				} else {
				    set txlost([expr {[UTF::stream clock] - $starttime}]) -1
				}
				if {$(phytable)} {
				    if {[catch {$(ap) wl -u dump phynoise} err]} {
					UTF::Message WARNING "$(ap)" $err
					if {[catch {$(ap) wl -u dump phyaci} err]} {
					    UTF::Message WARNING "$(ap)" $err
					}
				    }				    
				    $(ap) wl -u counters
				}
			    }
			    vwait ::UTF::Test::doloop
			}
			$prox_traffic stop
			if {$(acifcs)} {
			    $(ap) wl chanspec
			    $(sta) wl status
			}
			lappend events [list "r" [expr {[UTF::stream clock] - $starttime}]]
			foreach STAT [array names pktqstats] {
			    $pktqstats($STAT) sample
			}
			if {$(debug)  || $(phytable)} {
			    if {[catch {$(ap) wl -u dump phynoise} err]} {
				UTF::Message WARNING "$(ap)" $err
				if {[catch {$(ap) wl -u dump phyaci} err]} {
				    UTF::Message WARNING "$(ap)" $err
				}
			    }
			    $(ap) wl -u phytable 68 offset 8
			    $(ap) wl -u phytable 69 offset 8
			    $(ap) wl -u phyreg 0x6dc
			    $(ap) wl -u phyreg 0x6dd
			}
			if {$(acifcs)} {
			    UTF::Try "Verify CSA occurred" {
				UTF::Sleep 1.0
				$(ap) wl status
				$(sta) wl status
				set errtxt {}
				if {$originalchanspec == [$(ap) wl chanspec]} {
				    append errtxt "AP didn't change chspec "
				}
				if {$originalchanspec == [$(sta) wl chanspec]} {
				    append errtxt "STA didn't change chspec"
				}
				if {$errtxt ne {}} {
				    error $errtxt
				} else {
				    return "$originalchanspec to [$(ap) wl chanspec]"
				}
			    }
			}
			for {set ix 0} {$ix < $(recovertime)} {incr ix}  {
			    set t2 [clock clicks -milliseconds]
			    UTF::Sleep [expr {(1000 - ($t2 - $t1))/1000.0}]
			    set t1 [clock clicks -milliseconds]
			    if {$(debug)} {
				foreach DUT "$(ap) $(sta)" {
				    $DUT wl -u dump obss; $DUT wl -u dump_obss -d $(obsstimer)
				}
				foreach STAT [array names pktqstats] {
				    $pktqstats($STAT) sample
				}
				if {![catch {$(ap) wl -u dump ampdu} output] && [regexp {txlost ([0-9]+)} $output - lost]} {
				    set tlost [expr {$lost - $prevtxlost}]; set prevtxlost $lost
				    set txlost([expr {[UTF::stream clock] - $starttime}]) $tlost
				    incr totaltxlost +$tlost
				} else {
				    set txlost([expr {[UTF::stream clock] - $starttime}]) -1
				}
				if {$(phytable)} {
				    if {[catch {$(ap) wl -u dump phynoise} err]} {
					UTF::Message WARNING "$(ap)" $err
					if {[catch {$(ap) wl -u dump phyaci} err]} {
					    UTF::Message WARNING "$(ap)" $err
					}
				    }				 
				    $(ap) wl -u counters
				}
			    }
			}
			udp samplers -disable
			udp stop
			foreach STAT [array names pktqstats] {
			    $pktqstats($STAT) sample
			}
			if {$(debug)  || $(phytable)} {
			    $(ap) wl -u phytable 68 offset 8
			    $(ap) wl -u phytable 69 offset 8
			    $(ap) wl -u phyreg 0x6dc
			    $(ap) wl -u phyreg 0x6dd
			}
			set PER "(nan)"
			if {[set lostcnt [udp stats -lost -sum]] eq ""} {
			    set lostcnt "nan"
			} else {
			    if {[set totaltxcnt [udp stats -txpktcount -sum]] ne ""} {
				set PER "([format %2.1f [expr {100.0 * $lostcnt / $totaltxcnt}]]%)"
			    }
			    set totallost $lostcnt
			    set lostcnt [UTF::stream hformat [expr {int($lostcnt)}]]
			}
			catch {set totaltxlost [UTF::stream hformat $totaltxlost]}
			catch {rate destroy}
			catch {lost destroy}
			catch {latency destroy}
			catch {interferer destroy}
			set RSSITXT "$nrate AP/ProximateAP=$(chanspec),$PCHSPEC dBm=$rssi($(ap))/$rssi($(proximateap))"
			set ymax [expr 2 * [UTF::stream hexpand $(offered)]]
			UTF::streamgraph rate -streams udp -stat rate -title "Thruput Offered = $(offered) $TIMETXT\\n$RSSITXT" -outputtype $(graphtype) -graphsize $(graphsize) -yrange "0:$ymax" -reporttext "AP,STA=$rssi($(ap)),$rssi($(sta))" -linetype 3 -xtics $events
			UTF::streamgraph interferer -streams $prox_traffic -stat rate -title "Interferer Thruput\\n$RSSITXT" -outputtype $(graphtype) -graphsize $(graphsize) -yrange "0:*" -reporttext $PROXTXT -linetype 2
			UTF::streamgraph lost -stat lost -title "Lost=$lostcnt $PER Offered=$(offered) $TIMETXT\\n$RSSITXT" -outputtype $(graphtype) -graphsize $(graphsize) -with "impulses" -streams udp -linetype 1 -xtics $events -reporttext  "Lost=$lostcnt $PER"
			UTF::streamgraph latency -stat pktlatency -title "Latency Offered = $(offered) $TIMETXT\\n$RSSITXT" -outputtype $(graphtype) -graphsize $(graphsize) -streams udp -xtics $events -reporttext "Latencies"
			if {!$(nodisturb)} {
			    if {$(debug)} {
				set res "[rate plot -composite] [lost plot -append] [::UTF::Streamslib::grapharray txlost -title {AMPDU TXLOST} -style impulses -htmltxt txlost=$totaltxlost -append] [interferer plot -append] [latency plot -append]"
			    } else {
				set res "[rate plot -composite] [lost plot -append] [interferer plot -append] [latency plot -append]"
			    }
			} else {
			    if {$(debug)} {
				set res "[rate plot -composite] [lost plot -append] [::UTF::Streamslib::grapharray txlost -title {AMPDU TXLOST} -style impulses -htmltxt txlost=$totaltxlost -append] [latency plot -append]"
			    } else {
				set res "[rate plot -composite] [lost plot -append] [latency plot -append]"
			    }
			}
			if {$aRSSI($(proximateap)) < $(zplboundary) && $aRSSI($(proximatesta)) < $(zplboundary)} {
			    if {$totaltxlost != 0 || $totallost !=0} {
				if {$(debug)} {
				    $(ap) wl -u nrate 
				    $(ap) wl -u ratedump
				    $(proximateap) wl -u nrate
				    $(proximateap) wl -u ratedump
				}
				if {$totaltxlost != 0 && $totallost ==0} {
				    set res "$res: ZPL=0, check phy."
				}
				throw FAIL $res
			    }
			}
			return $res
		    }
		}
	    }
	}
	UTF::Try "Exit" {
	    UTF::stream exitstreams
	}
    }
}