#!/bin/env utf
# -*-tcl-*-

#
# UTF test script to test PPS
# $Id: 4b7574ce3700801d65fa1b0c2dadb749d66c2f4e $
#

package require UTF
package require UTF::MpduStats
package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart

package provide UTF::Test::KPPSSweep 2.0

namespace eval UTF::Test::KPPSSweep {

    proc sweep {SRC SNK key} {

	upvar {} {}

	lappend key $SRC $SNK

	# Sanitize for use as a filename
	regsub -all {[/<>]} $key "." plotkey

	set title "$SRC->$SNK KPPS Chanspec $(chanspec)"

	set t [format {%g} [expr {$(s) * $(i)}]]

	set file [file nativename \
	       [file join [file dir $UTF::Logfile] \
		    [file rootname $UTF::Logfile].$plotkey]]

	set tputfile "${file}.csv"
	set ctrlfile "${file}.gpc"
	set plotfile_sm "${file}_sm.png"
	set plotfile "${file}.png"

	set collector [UTF::MpduStats init $SRC $SNK $file 1]

	set ix 0
	set tputs {}
	set xlist {}
	set tputfd [open $tputfile w]
	set mpargs [list -b $(b) -i $(i) -t $t -w $(window) -noping]
	if {$(S) ne ""} {
	    lappend mpargs -S $(S)
	}

	foreach l $(l) {

	    set xlist [lreplace $xlist 0 -1 $l]

	    # Clear stats
	    $collector clear

	    set cmd [list UTF::Multiperf [list $SRC $SNK] {*}$mpargs -l $l]

	    foreach ret [eval $cmd] {
		set pps [expr {125.0 * $ret / $l}]
		puts $tputfd "[expr {[llength $(l)] - 1 - $ix}], $ret, $pps"
	    }

	    flush $tputfd

	    $collector collect $l

	    incr ix

	}
	close $tputfd

	set xtics ""
	set i 0
	set interval [expr {[llength $xlist] / 20}]
	foreach a $xlist {
	    if {$interval == 0 || $i % $interval == 0} {
		lappend xtics "'$a' $i"
	    }
	    incr i
	}
	lappend xtics "'$a' [expr {$i-1}]"

	# Plot
	set G [open $ctrlfile w]
	puts $G {set datafile separator ","}

	# thumbnails
	if {[UTF::GnuplotVersion] >= 5.0} {
	    puts $G {set colors classic}
	}
	if {[UTF::GnuplotVersion] > 4.0} {
	    puts $G {set terminal png transparent size 62,13 medium}
	    puts $G {set tmargin 0.1; set bmargin 0}
	    puts $G {set lmargin 0; set rmargin 0.1}
	} else {
	    puts $G {set terminal png transparent; set size 0.15,0.08}
	    # Gnuplot 4.0 loops if margins are zero - use mogrify below
	}
	puts $G {unset y2tics}
	puts $G {unset ytics}
	puts $G {unset xtics}
	puts $G {unset key}
	puts $G {unset border}
	puts $G "set output '$plotfile_sm'"
	puts $G {set yrange [0:*]}
	puts $G {set y2range [0:*]}
	puts $G "\
plot '$tputfile' using 1:2 axes x1y2 smooth unique notitle ls 1, \
'' using 1:3 axes x1y1 smooth unique notitle ls 2"

	puts $G {reset}
	puts $G {set terminal png notransparent size 1280,1280 truecolor}
	puts $G "set output '$plotfile'"

	puts $G {set key above}
	puts $G "set multiplot title \"$title\""
	puts $G "set origin 0,0.59; set size 1.0,0.4"
	puts $G "set xtics ([join $xtics ,])"
	puts $G {set y2tics}
	puts $G {set ytics nomirror}

	# Tput
	puts $G {set yrange [0:*]}
	puts $G {set y2range [0:*]}
	puts $G "\
plot '$tputfile' using 1:2 axes x1y2 title 'Tput' ls 1, \
'' using 1:2 axes x1y2 smooth unique notitle ls 1, \
'' using 1:3 axes x1y1 title 'PPS' ls 2, \
'' using 1:3 axes x1y1 smooth unique notitle ls 2"
	puts $G {set yrange [*:*]}
	puts $G {set y2range [*:*]}

	puts $G [$collector plotscripts]

	puts $G {unset multiplot}
	puts $G {quit}
	close $G

        # Run gnuplot on plot file.  Catch is needed because gnuplot
        # often writes to stderr.  Report any output even if we think
        # it was ok.
	catch {exec $::UTF::Gnuplot "$ctrlfile"} ret
	UTF::Message WARN "gnuplot" $ret

	$collector destroy

	set ret "html:<a href=\"[UTF::URI $plotfile]\">[UTF::ThumbData $plotfile_sm]</a>"
	if {[set END [lindex $UTF::TryStack end]] ne "NONE"} {
	    # Include plot along with any cascading fails.
	    regsub {^html:} $END { } END
	    throw FAIL "$ret $END"
	} else {
	    return $ret
	}
    }
}

UTF::Test KPPSSweep {AP STA args}  {

    # Pull out dut option since we need it before we can fetch the
    # rest of the arguments.
    if {[set dix [lsearch -exact $args -dut]] >= 0} {
	set vix [expr {$dix + 1}]
	set (dut) [lindex $args $vix]
    } else {
	set (dut) $STA
    }

    # If FBDefault is set, and devices support it, enable fb
    if {[info exists ::UTF::FBDefault] &&
	![$STA cget -noframeburst] && ![$AP cget -noframeburst]} {
	set fbdefault 1
    } else {
	set fbdefault 0
    }

    UTF::Getopts [subst {
	{dut.arg "$(dut)" "dut"}
	{i.arg 0.3 "Interval"}
	{s.arg 3 "Samples"}
	{l.arg "1470-12+64" "packet size"}
	{S.arg "" "IP type-of-service"}
	{chanspec.arg "36/80" "Chanspec"}
	{security.arg "open" "Security"}
	{key.arg "" "Key"}
	{loop.arg 1 "Loop"}
	{msg.arg "" "Message"}
	{perfcache.arg "" "Performance Cache"}
	{history.arg 30 "Performance History"}
	{nocache "Don't update performance cache"}
	{b.arg "[$(dut) cget -udp]" "UDP data rate. (0 for TCP)"}
	{frameburst.arg "$fbdefault" "Use frameburst"}
	{symmetric.arg 0 "Symmetric - only test one way"}
    }]

    if {$(b) eq "0"} {
	UTF::Message WARN $(dut) "Skipping PPS test - UDP not configured"
	return
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }
    set (l) [UTF::Numexpand $(l)]

    if {$(msg) eq ""} {
	set (msg) $(dut)
    }

    set branch [$(dut) branchname]
    set key [concat $branch kppssweep "ch=$(chanspec)" $(key)]

    append (msg) ": $(chanspec)"

    if {$(frameburst)} {
	lappend key "fb"
	append (msg) ": FB"
    }

    set setup 0

    UTF::Try "$(msg): KPPSsweep: WLAN<-LAN" {
	ConnectAPSTA $AP $STA -security $(security) -chanspec $(chanspec)

	$AP wl frameburst $(frameburst)
	$STA wl frameburst $(frameburst)

	set (window) [$STA tcpautowindow]

	set setup 1

	sweep $AP $STA $key
    }

    if {!$setup || $(symmetric)} {
	return
    }
    UTF::Try "$(msg): KPPSsweep: WLAN->LAN" {
	sweep $STA $AP $key
    }

}

