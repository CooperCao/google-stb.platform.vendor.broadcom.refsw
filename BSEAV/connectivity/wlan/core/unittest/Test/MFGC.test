#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for nightly run
# $Id: bfb6df484cb2735d88736dd749cd68f2a187c9c5 $
# $Copyright Broadcom Corporation$
#

package require UTF
package require UTF::Test::memchart

#package provide UTF::Test::MFGC 2.0

UTF::Test MFGC {args} {
    UTF::Getopts [subst {
	{email.arg "" "Email Address"}
	{title.arg "" "Title"}
	{noloaddut "Don't Load DUT"}
	{loadref "Load REF"}
	{dut.arg "DUT" "Device to test"}
	{ref.arg "" "Override REF"}
	{date.arg "" "Build date"}
	{loop.arg "1" "Loop MFG Test after loading each driver"}
	{scriptdir.arg "" "Override DVTc Script Dir"}
	{script.arg "" "Override DVTc Script"}
	{nocache "Don't update performance cache"}
	{bin.arg "" "Private STA driver"}
	{tag.arg "" "Override STA tag"}
    }]

    if {$(nocache)} {
	set ::UTF::MemChart::readonly 1
    }

    # Option translation from script to objects
    array set opts {
	bin       image
	tag       tag
	date      date
	scriptdir mfgcscriptdir
	script    mfgcscript
	ref       mfgcref
    }

    # Propagate override options
    foreach o [array names opts] {
	if {$($o) ne ""} {
	    lappend clist -$opts($o) $($o)
	}
    }
    if {[info exists clist]} {
	foreach STA $(dut) {
	    $STA configurelist $clist
	}
    }

    # Compact build list for title
    set build [UTF::BuildTitle $(dut)]

    set TITLE "MFGC $(title) ($build)"

    UTF::Message INFO "" $TITLE

    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}

	proc loader {STA {date ""}} {
	    UTF::Try "$STA: find image" {
		UTF::CheckImage $STA $date \
		    [list unknown [file tail [$STA cget -mfgcpath]]]
	    }
	    UTF::Try "$STA: load" {
		$STA load
	    }
	}

	proc reloader {STA} {
	    UTF::Try "$STA: reload" {
		$STA reload
		set ret [$STA wl ver]
		regexp {version (.*)} $ret - ret
		return $ret
	    }
	}

	proc timedvwait {var {timeout 30000}} {
	    set t [after $timeout [list set $var "Timeout"]]
	    vwait $var
	    after cancel $t
	}

	proc abbreviate {name} {
	    # Convert channels into chanspecs
	    if {[regexp {sideband[\s=]+([uln])\S+} $name - s]} {
		regsub {sideband[\s=]+\S+\s*} $name {} name
		if {$s eq "n"} {
		    set s ""
		}
	    } else {
		set s ""
	    }
	    # Strip out BW - implied by sideband for now (revisit when
	    # we have to test 80MHz)
	    regsub {bandwidth[\s=]+[24]0\s*} $name {} name

	    if {[regexp {channel[\s=]+(\S+)} $name - c]} {
		regsub {channel([\s=]+)\S+} $name "ch\\1$c$s" name
	    }
	    return $name
	}

	proc process_results {mfgcusecc key results} {
	    set csv [split $results ,]
	    set min [lindex $csv end-3]
	    set val [lindex $csv end-2]
	    set max [lindex $csv end-1]
	    set pass [lindex $csv end]
	    set quant [lindex [split [lindex $csv 0]] 0]

	    set code [expr {$pass ne "Pass"}]

	    if {$val eq "" ||
		($min == 0 && $max == 0 && $val == 0)} {
		# Nothing to report
		set results ""
	    } else {
		set results "$val \[$min - $max\]"

		# Process results as n=2 moving
		# range control chart.
		set utfcode [catch {
		    memchart $val -key $key \
			-format "%.2f" -cachemin -500 -cachemax 900 \
			-units "" -title $quant -failonboth
		} results]

		# If mfgcusecc is set, use ControlChart for pass/fail
		if {$mfgcusecc} {
		    set code $utfcode
		}
	    }

	    # Add MFGC's interpretation
	    if {$results ne ""} {
		append results ": $pass"
	    }

	    if {$code} {
		throw FAIL $results
	    } else {
		return $results
	    }
	}

	proc main {DUT} {
	    upvar {} {}
	    upvar logfile logfile

	    set REF [$DUT cget -mfgcref]

	    set branch [$DUT branchname]

	    UTF::Try "$DUT: configure MFGC" {
		# Find log file and other settings
		set logfile [$DUT mfgc findlogfile]
		# Make sure REF and DUT have the same IP addresses as are
		# configured in the settings file.
		$REF ifconfig \
		    [$DUT mfgc getsetting \
			 /mfgc_settings/ref/0/wireless_hostname]
		$DUT ifconfig \
		    [$DUT mfgc getsetting \
			 /mfgc_settings/dut/0/wireless_hostname]
		# Check Test script
		set script [$DUT mfgc getsetting \
				/mfgc_settings/general/script_file]
		set newscript [$DUT mfgc script]
		$DUT rexec -n "ls -l \"$newscript\""
		if {$script ne $newscript} {
		    $DUT mfgc changesetting \
			/mfgc_settings/general/script_file $newscript
		}
		regexp {\\([^\\]*?)\.txt} $newscript - newscript
		return $newscript
	    }

	    if {$(loadref)} {
		loader $REF
	    } else {
		reloader $REF
	    }
	    UTF::Try "$REF: setup" {
		$REF startmfgc mfcremote
		set what [$REF whatami]
		if {$(loadref)} {
		    # Pull out chip info and replace whitespace to make it
		    # easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $REF $ret
		    }
		}
		set what
	    }

	    if {$(noloaddut)} {
		reloader $DUT
	    } else {
		if {$(date) ne ""} {
		    set date $(date)
		    $DUT configure -date $(date)
		} else {
		    set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		}
		loader $DUT $date
	    }
	    UTF::Try "$DUT: setup" {
		$DUT open_messages "\"$logfile\""
		$DUT startmfgc mfcmfgc
		# Wait for mfcmfgc to start up
		UTF::Sleep 3

		set inittime 0
		while {[regexp {Initializing} \
			    [set status [$DUT mfgcshell getstatus]]]} {
		    if {[incr inittime 2] > 60} {
			error "Initialization Timed out"
		    }
		    UTF::Sleep 2
		}
		if {![regexp {Ready} $status]} {
		    error $status
		}
		set what [$DUT whatami]
		if {!$(noloaddut)} {
		    # Pull out chip info and replace whitespace to make it
		    # easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $DUT $ret
		    }
		}
		set what
	    }

	    for {set i 0} {$i < $(loop)} {incr i} {
		UTF::Try "$DUT: start mfgc test" {
		    set status "Start failed"
		    $DUT mfgcshell starttest
		    set ::UTF::Test::MFGCcurrenttest "start up"
		    set ::UTF::Test::MFGCresults [list ",Pass"]
		    set ::UTF::Test::Tick [clock seconds]
		    set status "Test In Progress"
		    return
		}

		while {[regexp {Test In Progress} $status]} {

		    set currenttest [abbreviate $::UTF::Test::MFGCcurrenttest]

		    UTF::Try "$DUT: $currenttest" {
			set key [regsub -all {\s+} \
				     "$branch $DUT $currenttest" { }]
			# If MFGC reports the test is still running, but we
			# are not getting any results then something is wrong.
			set retries 5
			while {$retries > 0 &&
			       [regexp {Test In Progress} $status]} {
			    incr retries -1

			    # Wait for the MFGC report parser to indicate
			    # the next test is starting
			    timedvwait ::UTF::Test::MFGCcurrenttest

			    # capture results before the next test can
			    # update them
			    set results $::UTF::Test::MFGCresults
			    set ::UTF::Test::MFGCresults {}

			    if {[regexp {Timeout} \
				     $::UTF::Test::MFGCcurrenttest]} {
				if {[clock seconds] - $::UTF::Test::Tick > 60} {
				    # If we got a timeout and data has
				    # stopped check to see if test is
				    # still running.
				    set status "Timeout"
				    set status [$DUT mfgcshell getstatus]
				}
				# Else try again
			    } else {
				switch -ex [llength $results] {
				    0 {
					error "No results"
				    }
				    1 {
					return [process_results \
						    [$DUT cget -mfgcusecc] \
						    $key \
						    [lindex $results 0]]
				    }
				    default {
					foreach res $results {
					    regexp {[^,]*} $res subtest
					    UTF::Try $subtest {
						process_results \
						    [$DUT cget -mfgcusecc] \
						    [concat $key $subtest] \
						    $res
					    }
					}
					return
				    }
				}
			    }
			}
			if {[regexp {Total Test } \
				 $::UTF::Test::MFGCcurrenttest]} {
			    set status "Timeout"
			    set status [$DUT mfgcshell getstatus]
			}

			if {$retries > 0} {
			    return "end test"
			} else {
			    $DUT mfgcshell canceltest
			    error "Timeout"
			}
		    }
		}
	    }
	    $DUT close_messages "\"$logfile\""

	    UTF::Try "$DUT: cleanup" {
		$DUT deinit
		for {set i 0} {[catch {$DUT -n :}] && $i < 10} {incr i} {}
		$DUT :
	    }
	    UTF::Try "$REF: cleanup" {
		$REF deinit
		for {set i 0} {[catch {$REF -n :}] && $i < 10} {incr i} {}
		$REF :
	    }
	}

	foreach DUT $(dut) {
	    main $DUT
	}

	PreservedReport
    }
}
