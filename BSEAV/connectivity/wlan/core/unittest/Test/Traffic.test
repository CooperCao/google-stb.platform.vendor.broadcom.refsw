#!/bin/env utf
# -*-tcl-*-

# UTF script to test ZPL and other customer scenarios
# zhuj
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::ConfigBridge
package require UTF::Test::Mbss::APAddInterface
package require UTF::Test::Mbss::Connectivity
package require UTF::Streams
package require UTF::Streamslib
package require UTF::wlstats
package require UTF::ControlChart

package provide UTF::Test::Traffic 2.0

namespace eval UTF::Test::Traffic {
    proc LoadRig {DUTS {norestore 0}} {
	upvar 1 date date
	set MSG [namespace tail [lindex [info level 0] 0]]

	#for MBSSes etc, only need to load once as they share the same host
	set tobeloaded {}
	set tobeloaded_hosts {}
	foreach DUT $DUTS {
	    UTF::Message DEBUG "" "$MSG: tobeloaded=$tobeloaded"
	    set h [$DUT cget -host]
	    if { ![llength $tobeloaded_hosts] || [set match [lsearch $tobeloaded_hosts $h]] == -1} {
		lappend tobeloaded $DUT
		lappend tobeloaded_hosts $h
	    } else {
		UTF::Message WARNING "" \
		    "MSG: Skipping image loading on $DUT which has same host with DUT [lindex $tobeloaded $match]."
		if {[$DUT hostis Router]} {
		    UTF::ReportWhatami $DUT -role DUT -noload 1
		}
		continue
	    }
	}
	foreach DUT $tobeloaded {
	    UTF::Try "[$DUT cget -name]: Find $DUT Image" {
		UTF::CheckImage $DUT $date unknown
	    }
	    UTF::Try "[$DUT cget -name]: Load Image" {
		if {[$DUT hostis Router]} {
		    $DUT load
		    UTF::ReportDriver $DUT $date
		    if {!$norestore} {
			$DUT restore_defaults
		    }
		    # Bail out rather than continue with whatever happens to
		    # be on the router.
		    if {[$DUT cget -_path] eq ""} {
			error "None Found."
		    }
		} else {
		    if {[catch {$DUT load} ret]} {
			error "LoadRig failed."
		    }
		    UTF::ReportDriver $DUT $date
		}

		UTF::ReportWhatami $DUT -role DUT -noload 0

#		#set what [$DUT whatami]
#		# Pull out chip info and replace whitespace to make it
#		# easier for external parsers.
#		regsub -all {\s+} [lreplace $what 0 0] {_} w
#		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
#		    UTF::Message WARN $DUT $ret
#		}
#		$DUT dbrecord DUT
#		set what
	    }
	}
    }

    proc Reconnect {AP STAS} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	set bssid [$AP wl -u bssid]
	foreach STA $STAS {
	    set res 0
	    $STA wl join [$AP wl -u ssid]
	    set slowassoc [$STA cget -slowassoc]
	    set timer [after [expr {$slowassoc * 1000}] {}]

	    set BSSID [$STA wl -u bssid]
	    while {![catch {after info $timer}]} {
		UTF::Sleep 1
		set BSSID [$STA wl -u bssid]
		if {$BSSID eq $bssid} {
		    set res 1
		    catch {after cancel $timer}
		    break
		}
	    }
	    if {$res} {
		continue
	    }
	    if {$BSSID eq "00:00:00:00:00:00"} {
		UTF::Message DEBUG "" "$MSG: $AP bssid=$bssid; $STA bssid=$BSSID"
		UTF::Message FAIL "" "$MSG: $STA failed to associate with $AP."
		#throw FAIL "STA $STA failed to associate with AP $AP"
		error "Reconnect failed."
	    }
	}
    }

    #To configure AP/STA features which can be only done with wl down
    #STAS option for reconnecting associated STAS.
    proc ConfigureDevFeature {DUT FVpairs {STAS {}} {AP ""}} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	if {![llength $FVpairs]} {
	    error "Feature not specified."
	}
	UTF::Message DEBUG "" "$MSG DUT=$DUT FVpairs=$FVpairs"
	foreach {f v} $FVpairs {
	    set f [string tolower $f]
	    if {$f eq "taf"} {
		set f "$f enable"
	    }
	    UTF::Message DEBUG "" "$MSG $f=$v"
	    if {![catch {$DUT wl -u $f} old]} {
		UTF::Message DEBUG "" "$MSG old $f=$old"
		if {$old ne $v} {
		    if {[$DUT wl -u isup]} {
			UTF::Message INFO "" "$MSG shutting down $DUT wl interface to configure $f"
			$DUT wl -u down
		    }
		    $DUT wl -u $f $v
		}
	    } else {
		#if some feature not recognized, print a warning in the log."
		UTF::Message WARNING "" "$MSG $old"
		unset old
	    }
	}
	if {![$DUT wl -u isup]} {
	    $DUT wl -u up
	}
	if {[info exists STAS] && [llength $STAS]} {
	    if {[catch {Reconnect $DUT $STAS} ret]} {
		error "$MSG: $ret"
	    }
	} elseif {[info exists AP] && $AP ne ""} {
	    if {[catch {[Reconnect $AP $DUT] ret}]} {
		error "$MSG: $ret"
	    }
	}
	foreach {f v} $FVpairs {
	    set f [string tolower $f]
	    if {$f eq "taf"} {
		set f "$f enable"
	    }
	    if {![catch {$DUT wl -u $f} new] && $new ne $v} {
		error "$MSG: Failed to set $f to $v."
	    }
	    UTF::Message DEBUG "" "$MSG new $f=$new"
	}
    }

    #Configure traffic scheduler
    #TAFSchedulers is dictionary
    proc ConfigureTAF {TAFSchedulers} {
	set MSG [namespace tail [lindex [info level 0] 0]]
	UTF::Message DEBUG "" "$MSG: $TAFSchedulers"
	UTF::Try "Configuring $TAFSchedulers" {
	    dict for {AP Schedulers} $TAFSchedulers {
		UTF::Message DEBUG "" "$MSG: [$AP wl -u status]"
		if {![$AP wl -u isup]} {
		    UTF::Sleep 1
		}
		foreach {S STAS} [dict get $Schedulers] {
		    set S [string tolower $S]
		    UTF::Message DEBUG "" "$MSG: AP=$AP TS=$S STAS=$STAS"
		    if {$S ne "na"} {
			set i 0
			foreach STA $STAS {
			    set stamac [$STA macaddr]
			    UTF::Message DEBUG "" "$MSG: $STA macaddr = $stamac."
			    #ebos prio set based on the order of (stas) list
			    if {$S eq "ebos"} {
				incr i
				$AP wl -u taf $stamac $S $i
			    } else {
				$AP wl -u taf $stamac $S
			    }

			    $AP wl -u taf $S
			}
			catch {$AP wl -u taf $S dump}
		    }
		}
	    }
	}
    }
    proc tos2txt {tos} {
	switch -exact [string tolower $tos] {
	    "0x20" {
		return "BK"
	    }
	    "0x00" {
		return "BE"
	    }
	    "0x80" {
		return "VI"
	    }
	    "0xc0" {
		return "VO"
	    }
	    default {
		return "BE"
	    }
	}
    }
    proc txt2tos {txt} {
	switch -exact [string toupper $txt] {
	    "BK" {
		return "0x20"
	    }
	    "BE" {
		return "0x00"
	    }
	    "VI" {
		return "0x80"
	    }
	    "VO" {
		return "0xC0"
	    }
	    default {
		return "0x00"
	    }
	}
    }
    proc StartStreamExcludeInitLoss {S} {
	set ret 0
	$S start
	if {[catch {$S linkcheck} err]} {
	    UTF::Message ERROR "" "$err"
	    set ret 1
	}
	$S stats -clear
	return $ret
    }
    proc tc {ts protocol args} {
	#getting script input parameters 
	upvar 2 {} {}

	UTF::Getopts {
	    {mflow.arg "1" ""}
	    {rates.arg {} "array of offered rates for UDP streams"}
	    {tos.arg "" "array of tosbits. 0x00:best effort; 0x20:background; 0x80:voice; 0xC0:video"}
	    {delays.arg "" "Format: pair of STA object and time in seconds to delay the start of traffic"}
	    {modes.arg "" "STA Object mode (vhtmode | nmode) value"}
	    {g.arg "" "Attenuating group/sta while stream flowing"}
	    {warmup.arg "0"  "Send traffic before testing to warm up the chips"}
	    {attnstep.arg "1" "Attenuation step"}
	    {attninterval.arg "3" "Attenuating interval in seconds"}
	    {maxattn.arg "90" "Maximum attnuation allowed by attenuator"}
	    {roamtrigger.arg "-100" "roamtrigger value"}
	    {notaf "not to test TAF"}
	    {mykey.arg "" "The key for controlchart will include this user specified keyword."}
	    {callback.arg "" ""}
	}
	upvar $(rates) myrates
	upvar $(tos) mytos
	#upvar $(ch) chanspec
	set MSG [namespace tail [lindex [info level 0] 0]]

	set res 0
	array set traffic {}
	set total_stas {}
	set ckey [list $(key) $(security) $protocol]
	if {$(g) ne ""} {
	    set holdtime [expr {$(attninterval) * 50}]
	    set origattn [lindex [$(g) attn?] 0]
	} else {
	    set holdtime $(holdtime)
	}
	UTF::Try "$protocol: \{$ts\}" {
	    catch {UTF::stream allstreams destroy}
	    set lrssi {}
	    #if {$(g) ne ""} {
		#set origattn [$(g) attn?]
	    #}
	    UTF::Message DEBUG "" "ts=$ts"
	    dict for {AP Schedulers} $ts {
		UTF::Message DEBUG "" "AP=$AP; Schedulers=$Schedulers"
		set ckey [concat $ckey $AP [$AP branchname] [$AP cget -brand] [$AP cget -host]]
		set ap_features ""
		foreach {S STAS} [dict get $Schedulers] {
		    UTF::Message DEBUG "" "S=$S; STAS=$STAS"
		    set res 0

		    #configure AP features before test
		    if {[string tolower $S] ne "na"} {
			set ap_features "taf 1"
		    }
		    append ap_features " atf $(atf)"

		    if {$ap_features ne ""} {

			UTF::Try "Configuring \($ap_features\)" {
			    UTF::Message DEBUG "" "$MSG: $ap_features"
			    if {[catch {ConfigureDevFeature $AP $ap_features} err]} {
				set res 1
				error $err
			    }
			}
		    }
		    if {[llength $(modes)]} {
			foreach {STA m v} $(modes) {
			    lappend origmodelist "$STA $m [$STA wl -u $m]"
			    UTF::Try "Configuring $STA $m $v" {
				UTF::Message DEBUG "" "$MSG: $STA $m $v"
				if {[catch {ConfigureDevFeature $STA "$m $v" {}} err]} {
				    set res 1
				    error $err
				}
			    }
			}
			unset m v
		    }
		    if {$res} {
			UTF::Message ERROR "" "$MSG: $err."
			exit $res
		    }
		    foreach STA $STAS {
			set res 0
			set err ""
			UTF::Try "Configuring Streams" {
			    for {set j 1} {$j <= $(mflow)} {incr j} {
				if {[regexp -nocase "DOWN" $(direction)]} {
				    set cmd {UTF::stream %AUTO% -rx $STA -tx $AP -reportinterval $(reportinterval)}
				    set cmd [join [list $cmd -name $AP-${STA}-$(direction)-${j} -linkcheckfailcount 5]]
				}
				if {[regexp -nocase "UP" $(direction)]} {
				    set cmd {UTF::stream %AUTO% -rx $AP -tx $STA -reportinterval $(reportinterval)}
				    set cmd [join [list $cmd -name ${STA}-$AP-$(direction)-${j} -linkcheckfailcount 5]]
				}
				set r $(rate)
				UTF::Message INFO "" "$MSG: (rate)=$(rate); (rates)=[array get myrates]"
				if {[lsearch [array names myrates] $STA] ne "-1"} {
				    UTF::Message INFO "" "$MSG: \[$j\] myrates($STA)=$myrates($STA)"
				    set r [lindex $myrates($STA) [expr {$j -1}]]
				}
				if {[string toupper $S] eq "EBOS"} {
				    #set ebos as video traffic
				    set r $(vrate)
				    set cmd [join [list $cmd -tos "0x80"]]
				    #only use the second ebos stream as stresser if there are more than one ebos clients
				    if {$(vstresser)} {
					if {![info exists vstresser_enabled]} {
					    set vstresser_enabled 0
					} elseif {!$vstresser_enabled} {
					    set r $dr
					    set vstresser_enabled 1
					}
				    }
				}
				if {[string toupper $protocol] eq "TCP"} {
				    set cmd [join [list $cmd -protocol [string tolower $protocol]]]
				    set cmd [join [list $cmd -w $(tcpwsize)]]
				    if {[string toupper $S] eq "EBOS"} {
					set cmd [join [list $cmd -rate $r]]
				    } else {
					set r -1
				    }
				} else {
				    set cmd [join [list $cmd -w $(w)]]
				}
				set pktsize $(pktsize)
				if {[array size mytos]} {
				    if {[lsearch [array names mytos] $STA] ne "-1"} {
					UTF::Message INFO "" "mytos($STA)=$mytos($STA)"
					if {$j <= [llength $mytos($STA)]} {
					    set t [lindex $mytos($STA) [expr {$j - 1}]]
					} else {
					    set t [lindex $mytos($STA) 0]
					}
					if {[regexp {BE|BK|VI|VO} $t]} {
					    set cmd [join [list $cmd -tos [txt2tos $t]]]
					}
					if {[regexp {VO} $t]} {set pktsize $(vopktsize)}

				    }
				}

				if {[string toupper $protocol] eq "UDP"} {
				    set cmd [join [list $cmd -rate $r -pktsize $pktsize]]
				}
				UTF::Message INFO "" "traffic cmd=$cmd"
				UTF::Message INFO "" "rate = $r"
				set traffic($STA,$j) [eval $cmd]
				UTF::Message INFO "" "traffic($STA,$j)=$traffic($STA,$j)"
				append retstr "\[${j}\]:[$traffic($STA,$j) cget -tx]->[$traffic($STA,$j) cget -rx]: $S $r [$traffic($STA,$j) cget -tos] "
				$traffic($STA,$j) id
			    }
			    return $retstr
			}
			if {[lsearch $total_stas $STA] eq "-1"} {
			    lappend total_stas $STA
			}

			UTF::Message INFO "" "$MSG: total_stas=$total_stas"
			UTF::Try "$AP<->$STA FB=$(fb)" {
			    $STA wl -u roam_trigger $(roamtrigger) all
			    for {set n 1} {$n <= $(assocretries)} {incr n} {
				if {[catch {UTF::Test::ConnectAPSTA $AP $STA -security $(security)} err]} {
				    UTF::Message ERROR "" "$err after $n tries"
				    if {[catch {$STA wl_escanresults} ret_escanresults]} {
					UTF::Message ERROR "" "$ret_escanresults"
				    }
				    if {$n == $(assocretries)} {
					set res 1
				    } else {
					continue
				    }
				} else {
				    break
				}
			    }
#			    if {[$STA hostis Router]} {
#				package require UTF::Test::ConfigBridge
#				if {[catch {UTF::Test::ConfigBridge -ap $AP -br $STA -chanspec $chanspec($STA) \
#						-security $(security) -linkcheck -proxysta} err]} {
#				    set res 1
#				    UTF::Message INFO "" "$err"
#				}
#			    }
			    $STA wl -u status
			    $AP wl -u status
			    $AP wl -u assoclist
			    if {$res} {
				set connection_failure($STA) 1
				throw FAIL "STA $STA failed to connect to AP $AP after $(assocretries) attempts."
			    }
			    #set frameburst after any AP restarts
			    if {$(fb) ne [$AP wl -u frameburst]} {
				$AP wl -u frameburst $(fb)
			    }
			    if {$(fb) ne [$STA wl -u frameburst]} {
				$STA wl -u frameburst $(fb)
			    }
			    $STA wl -u dump rssi
			    set rssi [$STA wl -u rssi]
			    lappend lrssi "$STA $rssi"
			    return "$STA RSSI=$rssi $STA FB=[$STA wl -u frameburst] $AP FB=[$AP wl -u frameburst]"
			}
			if {$res} {
			    UTF::Message INFO "" "Exiting due to connection failure."
			    exit $res
			}
			if {!$(nopktqstats)} {
			    $STA wl msglevel +time
			    set pktqstats(${STA}) [UTF::wlstats::pktqstat %AUTO% -ap $AP -sta $STA]
			    set pktqstats($AP) [UTF::wlstats::pktqstat %AUTO% -ap $AP -common 1]
			    $AP wl msglevel +time
			    foreach index [array names pktqstats] {
				$pktqstats($index) sample
			    }
			}
		    }
		    #eof loop foreach STA
		}
		#eof loop foreach {S STAS}
	    }
	    #eof loop foreach AP

	    if {!$(notaf)} {
		ConfigureTAF $ts
	    }
	    return "RSSI: $lrssi"
	}

	#send all traffic to warmup chips before testing
	if {$(warmup)} {
	    UTF::Message INFO "" "Start Warmup."
	    UTF::stream allstreams start
	    #UTF::Sleep [format "%.2f" [expr {$holdtime /5}]]
	    UTF::Sleep 1
	    UTF::stream allstreams stop
	    UTF::Message INFO "" "Warmup done."
	}
	for {set ix 1} {$ix <= $(loop)} {incr ix} {
	    set code 0
	    UTF::Try "TPUT $protocol $(direction)) $ix" {
		if {!$(nopktqstats)} {
		    foreach index [array names pktqstats] {
			$pktqstats($index) sample
		    }
		}
		UTF::stream allstreams stop
		UTF::stream allstreams stats -clear
		#UTF::StreamStatAggregate rate -range $(smoothing) -period $(aggregateinterval)
		#rate clear
		foreach dut [join [list $AP $total_stas] " "] {
		    #if dump ampdu supported, clear it first
		    if {![catch {$dut [$dut cget -wl] -silent dump ampdu} ret] && [regexp {AMPDU} $ret]} {
			#try old style clear
			if {[catch {$dut [$dut cget -wl] -u ampdu_clear_dump}]} {
			    #old style clear not supported, try new format
			    $dut [$dut cget -wl] dump_clear ampdu
			}
		    }
		}
		if {$(callback) ne ""} {
		    UTF::Message INFO "" "callback_dump before traffic start"
		    uplevel 1 $(callback)
		}

		if {$(delays) eq ""} {
		    UTF::Message INFO "" "$MSG: all streams start in parallel."
		    UTF::stream allstreams start
		    if {[catch {UTF::stream allstreams linkcheck} err]} {
			UTF::stream allstreams stop
			UTF::Message ERROR "" "$err"
			set code 1
			return $err
		    }
		} else {
		    #to allow streams start at different times specified in $(delays)

		    set delaystartstreams {}
		    set immediatestartstreams {}
		    foreach sta $total_stas {
			set id [lsearch $(delays) $sta]
			if {$id ne "-1"} {
			    incr id
			    set delay [lindex $(delays) $id]
			    UTF::Message INFO "" "$MSG: sta=$sta delay=$delay delays=$(delays)"
			    #if there are multiple flows for same dst, always delay the first flow
			    lappend delaystartstreams "$traffic($sta,1)"
			    lappend delaystartstreams "$delay"
			    #remove the entry after it is queued in delaystartstreams
			    set (delays) [lreplace $(delays) [expr {$id -1}] $id]
			    UTF::Message INFO "" "$MSG: delaystartstreams=$delaystartstreams"
			    set ims 2
			} else {
			    set ims 1
			}
			#the rest of streams are queued in immediatestart streams
			for {set j $ims} {$j <= $(mflow)} {incr j} {
			    lappend immediatestartstreams $traffic($sta,$j)
			    UTF::Message INFO "" "$MSG: adding traffic($sta,$j)=$traffic($sta,$j) to immediatestartstreams=$immediatestartstreams"
			}
			unset ims j
		    }

		    foreach s $immediatestartstreams {
			if {[catch {StartStreamExcludeInitLoss $s} err ]} {
			    set code 1
			}
		    }
		    set t0 [format "%.3f" [UTF::stream clock]]
		}

		set timer [after [expr {$holdtime * 1000}] [list set expired 1]]
		UTF::Message INFO "" "[after info $timer]"
		while {![catch {after info $timer}]}  {
		    if {[info exists delaystartstreams]} {
			set t1 [expr {1.000 * ([UTF::stream clock] - $t0)}]
			UTF::Message INFO "" "t1=$t1; t0=$t0"
			for {set i 0} {$i < [llength $delaystartstreams]} {incr i 2} {
			    set s [lindex $delaystartstreams $i]
			    set d [lindex $delaystartstreams [expr {$i + 1}]]
			    if {ceil($t1) >= $d} {
				catch {$AP [$AP cget -wl] dump ampdu}
				if {[catch {StartStreamExcludeInitLoss $s} err]} {
				    set code 1
				    catch [after cancel $timer]
				    break
				}
				set delaystartstreams [lreplace $delaystartstreams $i [expr {$i +1}]]
			    }
			}
		    }
		    UTF::Sleep $(attninterval)
		    #collecting bs_data while traffic on
		    $AP wl -u bs_data
		    $AP wl -u atf
		    if {$(debug)} {
			$AP wl -u bus:dumptxrings
		    }
		    foreach d $total_stas {
			$d wl -u phy_rssi_ant
			$d wl -u dump rssi
		    }
		    unset d
		    if {$(g) ne ""} {
			if {[set currentattn [$(g) attn?]] < $(maxattn)} {
			    $(g) incr $(attnstep)
			}
			UTF::Message INFO "" "origattn=$origattn, currentattn=$currentattn"
			$AP wl -u assoclist
		    }
		}

		#all streams stop at the same time after holdtimer expires
		UTF::stream allstreams stop
		#rate stop

		if {$(callback) ne ""} {
		    UTF::Message INFO "" "callback Dump after traffic stop"
		    if {[catch {uplevel 1 $(callback)} err]} {
			set code 1
			UTF::Message ERROR  "" "$err"
		    }
		}
		#if stream linkcheck failed, skip the rest of testing
		if {$code} {
		    if {$(g) ne "" && [info exists origattn]} {
			UTF::Message INFO "" "Reset $(g) to $origattn:"
			catch {$(g) attn $origattn} attn_err
			UTF::Message ERROR  "" "$attn_err. Current $(g)=[$(g) attn?]"
		    }
		    return $err
		}
		if {!$(nopktqstats)} {
		    foreach index [array names pktqstats] {
			$pktqstats($index) sample
		    }
		}
		foreach dut [join [list $AP $total_stas] " "] {
		    if {![catch {$dut [$dut cget -wl] dump ampdu} ret] && [regexp {AMPDU} $ret]} {
			package require UTF::Dump::AMPDU
			#package require UTF::HistMode
			UTF::Dump::AMPDU dutampdu -raw $ret
			foreach item {
			    MPDUdens MPDUdens%
			    TXVHT TXVHT% TXVHTs TXVHTs%
			    TXMCS TXMCS% TXMCSs TXMCSs%
			    MCSPER MCSPER%
			    RXVHT RXVHT% RXVHTs RXVHTs%
			    RXMCS RXMCS% RXMCSs RXMCSs%
			    VHTPER VHTPER%
			    Frameburst Frameburst%
			    TXMode
			} {
			    UTF::Message INFO "" "$dut $item = \n[dutampdu $item]"
			}
			#set ampduHistMode($dut) [UTF::HistMode [concat [$ret TXVHT] [$ret TXMCS]]]
			#UTF::Message INFO "" "ampduHistMode($dut) = $ampduHistMode($dut)"
		    }
		}

		set datasum($ix) 0
		foreach STA $total_stas {
		    #covert into Gbits to draw the controlchart easily
		    #set data($STA,$ix) [expr {[$traffic($STA) stats -rate -sum] / 1024 / 1024 / 1024}]
		    #set datasum($ix) [expr {$datasum($ix) + $data($STA,$ix)}]
		    #UTF::Message INFO "" "data($STA,$ix)=$data($STA,$ix)"
		    #UTF::Message INFO "" "datasum($ix)=$datasum($ix)"
		    for {set j 1} {$j <= $(mflow)} {incr j} {
			set name [$traffic($STA,$j) cget -name]
			if {[regexp -nocase "udp" $protocol]} {
			    set stats "rate lost"
			} else {
			    set stats "rate rtt cwnd"
			}
			foreach stat $stats {
			    dict set retdict $STA $stat $j [$traffic($STA,$j) stats -${stat} -meanminmax]

			    #lappend mean_meanminmax($STA,$stat) [$traffic($STA) stats -rate -meanminmax]
			    UTF::Try "$name $stat" {
				set exclude "rate transmitsta pps"
				UTF::Message INFO "" "key=$ckey"
				return "[$traffic($STA,$j) controlchart -history $(history) -shortkey -exclude $exclude -stat $stat -key [concat $ckey $(mykey)]]"
			    }
			}
		    }
		    unset j
		}
		#set gtitle " [string toupper $protocol] [string toupper $(direction)] CHAN \{$chanspecs\} \\n"
		set gtitle "[string toupper $protocol] [string toupper $(direction)] "
		#append gtitle $ts

		if {[string toupper $protocol] eq "TCP"} {
		    append gtitle "Throughput RTT CWND \\n"
		    UTF::streamgraph g -stat "rate rtt cwnd" -yrange "0:*" -title "$gtitle" \
			       -graphsize $(graphsize)
		} else {
		    #append gtitle " pktsize=$(pktsize) \\n"
		    append gtitle "Throughput PktLatency Lost"
		    UTF::streamgraph g -stat "rate pktlatency lost" -yrange "0:*" -title "$gtitle" \
			       -graphsize $(graphsize) -lmargin "0.11"
		}
		set plot [g plot -composite]

		set testresults  "[g plot -composite]"

#		if {[string toupper $protocol] eq "TCP"} {
#		    catch {UTF::streamgraph rtt -stat rtt -yrange "0:*" -reporttext "RTT" -title "RTT" \
#			       -graphsize $(graphsize); rtt plot -composite}
#		    catch {UTF::streamgraph cwnd -stat cwnd -yrange "0:*" -reporttext "CWND" -title "CWND" \
#			       -graphsize $(graphsize); cwnd plot -composite}
#		    set plot "$testresults [rtt plot -composite -append] [cwnd plot -composite -append]"
#		}
#		if {[string toupper $protocol] eq "UDP"} {
#		    catch {UTF::streamgraph latency -stat pktlatency -title "UDP Latency" \
#			       -outputtype $(graphtype) -graphsize $(graphsize) \
#			       -reporttext "Latency"}
#		    catch {UTF::streamgraph pktlost -stat lost -title "UDP PKTLost" \
#			       -outputtype $(graphtype) -graphsize $(graphsize) \
#			       -reporttext "PKT Lost"}
#		    set plot "$testresults [latency plot -composite -append] [pktlost plot -composite -append]"
#		}
	    }
	    #objects are created and destroyed in each iteration
	    #outside of try block to gurantee cleanup will still happen
	    #if anything failed inside the try block
	    catch {g destroy; rtt destroy; cwnd destroy; latency destroy; pktlost destroy}
	    if {$(g) ne "" && [info exists origattn]} {
		UTF::Message INFO "" "Reset $(g) to $origattn:"
		catch {$(g) attn $origattn} a
		UTF::Message ERROR  "" "$a. Current $(g)=[$(g) attn?]"
	    }
	    if {$(modes) ne "" && [info exists origmodelist]} {
		foreach STA m v $origmodelist {
		    catch {ConfigureDevFeature $STA "$m $v" {}} err]
		}
	    }
	    #
	    if {$code} {
		continue
	    } else {
		break
	    }
	}
	#catch {UTF::stream exitstreams}
	catch {UTF::stream allstreams destroy}


	foreach STA $total_stas {
	    if {[info exists code]} {
		unset code
	    }
	    #$STA wl -u disassoc
	    UTF::Message INFO "" "[$STA wl down]"
	}
	if {[info exists retdict] && [info exists plot]} {
	    return [list $retdict $plot]
	} else {
	    error "Failed to get traffic stats/plots"
	}
    }
    proc dump_callback {} {
	uplevel {
	    foreach s $stas {
		if {[$s wl -u isup]} {
		    $s wl -u status
		    $s wl -u dump rssi
		    $s wl -u dump murx
		}
	    }
	    unset s
	    $AP wl -u chanspec
	    $AP wl -u dump rssi
	    $AP wl -u authe_sta_list
	    set assoclist [$AP wl -u assoclist]
	    regsub -all -nocase "assoclist " $assoclist "" assoclist
	    foreach mac $assoclist {
		$AP wl -u rssi $mac
	    }
	    $AP wl -u dump scb
	    $AP wl -u dump txbf
	    $AP wl -u dump mutx
	    $AP wl -u mu_rate
	    $AP wl -u mu_group
            $AP wl -u dump vasip_counters
	    #catch {$AP wl -u dump mutx} ret
	    $AP wl -u phy_tempsense

	}
    }

    proc _BaseTest {AP stas ts prot args} {
	UTF::Getopts {
	    {txt.arg "" "UTF try block title"}
 	    {tos.arg {} "array of tosbits"}
	    {warmup.arg "0" ""}
	    {modes.arg "" ""}
	    {mflow.arg "1" "number of flows for each dst"}
 	}
	upvar 1 $(tos) mytos
	set MSG [namespace tail [lindex [info level 0] 0]]
	set code 0
	foreach sta $stas {
	    dict set TS $AP $ts $sta
	    UTF::Try "$(txt) $sta " {
		if {[catch {tc $TS $prot -tos mytos -warmup $(warmup) \
			      -modes $(modes) -mflow $(mflow) \
			      -callback dump_callback} lret]} {
		    set code 1
		    throw FAIL $lret
		}
		set dictret [lindex $lret 0]
		UTF::Message INFO "" "$MSG: dictret=$dictret"
		for {set j 1} {$j <= $(mflow)} {incr j} {
		    if {[catch {dict get $dictret $sta rate $j} meanminmax($sta,$j)]} {
			UTF::Message ERROR "" "$MSG: $meanminmax($sta,$j)"
			set code 1
		    }
		    UTF::Message INFO "" "$MSG: $meanminmax($sta,$j)"
		    dict unset dictret $sta rate $j
		}
		return [lindex $lret 1]
	    }
	    dict unset TS $AP $ts
	    if {$code} {
		UTF::Message ERROR "" "$MSG: Failed to get baseline info for $sta."
		break
	    }
	}
	if {$code} {
	    array set meanminmax {}
	}
	return -code $code [array get meanminmax]
    }

    proc _SimultaneousTrafficTest {AP stas ts prot args} {
	UTF::Getopts {
	    {txt.arg "" "UTF try block title"}
	    {rates.arg {} "array of rates"}
 	    {tos.arg {} "array of tosbits"}
	    {g.arg "" "attengrp or sta obj to attenuate"}
	    {attnstep.arg "1" ""}
	    {attninterval.arg "3" ""}
	    {modes.arg "" ""}
 	    {mflow.arg "1" "number of flows for each dst"}
	    {warmup.arg "1" "by default to warmup before collecting data"}
	}
	set MSG [namespace tail [lindex [info level 0] 0]]
	upvar $(rates) myrates
	upvar $(tos) mytos
	dict set TS $AP $ts $stas
	if {$(txt) eq ""} {
	    set txt "$prot PL Simutaneous Traffic [array get tos]"
	} else {
	    set txt $(txt)
	}
	set g $(g)
	if {$(g) ne ""} {
	    append txt "\nAttenuating $(g)"
	    if {[$(g) info type] eq "::UTF::STA"} {
		set g [$(g) cget -attngrp]
	    }
	}
	UTF::Try $txt {
	    if {[catch {tc $TS $prot -rates myrates -g $g -attnstep $(attnstep) \
			    -attninterval $(attninterval) \
			    -tos mytos -modes $(modes) -mflow $(mflow) \
			    -warmup $(warmup) \
			    -callback dump_callback} lret]} {
		    throw FAIL $lret
	    }

	    set dictret [lindex $lret 0]

	    UTF::Message INFO "" "$MSG: dictret=$dictret"
	    dict for {sta stats} $dictret {
		if {[string toupper $prot] eq "UDP"} {
		    if {[catch {dict get $stats lost} lostcount($sta)] || [lindex $lostcount($sta) 0] } {
			UTF::Message INFO "" "$MSG: lostcount($sta)=$lostcount($sta)"
			set f 1
		    }
		}
		for {set j 1} {$j <= $(mflow)} {incr j} {
		    if {[catch {dict get $stats rate $j} meanminmax($sta,$j)] || $meanminmax($sta,$j) ne ""} {
			UTF::Message INFO "" "$MSG: meanminmax($sta,$j)=$meanminmax($sta,$j)"
			set f 1
		    }
		}
	    }
	    if {[info exists f] && $(g) eq ""} {
		throw FAIL [lindex $lret 1]
	    } else {
		return [lindex $lret 1]
	    }
	}
	dict unset TS $AP $ts
	if {[array exists meanminmax]} {
	    UTF::Message INFO "" "$MSG: meanminmax=[parray meanminmax]"
	    return [array get meanminmax]
	} else {
	    return error
	}
    }

    proc _SequentialTrafficTest {AP stas ts prot delay args} {
	UTF::Getopts {
	    {txt.arg "" "UTF try block title"}
	    {rates.arg {} "array of rates"}
 	    {tos.arg {} "array of tosbits"}
	    {modes.arg "" ""}
	    {mflow.arg "1" "number of flows for each dst"}
	    {warmup.arg "1" "by default to warmup before collecting data"}
 	}
	upvar $(tos) mytos
	upvar $(rates) myrates
	set MSG [namespace tail [lindex [info level 0] 0]]
	set uut [lindex $stas 0]
	set len [llength $stas]
	set seq $stas
	#set 1st [lindex $seq 0]
	#if {$len > 1} {
	    #set 2nd [lindex $seq 1]
	#}
	dict set TS $AP $ts $stas
	for {set i 1} {$i <= $len} {incr i} {
	    set delays ""
	    if {$(txt) eq ""} {
		set txt "UDP PL Sequential Traffic"
	    } else {
		set txt $(txt)
	    }
	    if {$len>1} {
		append txt " $seq"
		for {set j 1} { $j < [llength $seq]} {incr j} {
		    set delays [concat $delays [lindex $seq $j] [expr $j*$delay]]
		}
	    } else {
		append delays "$stas $delay"
	    }
	    UTF::Try $txt {
		if {[catch {tc $TS UDP -delays $delays  -rates myrates -mykey $i -tos mytos \
				-modes $(modes) -mflow $(mflow) \
			        -warmup $(warmup) \
				-callback dump_callback} lret]} {
		    throw FAIL $lret
		}
		set dictlost [lindex $lret 0]
		UTF::Message INFO "" "$MSG: dictlost=$dictlost"

		if {[catch {dict get $dictlost $uut lost} lostcount] || [lindex $lostcount 0]} {
		    UTF::Message INFO "" "$MSG: lostcount=$lostcount"
		    set f 1
		}
		if {[info exists f]} {
		    throw FAIL [lindex $lret 1]
		} else {
		    return [lindex $lret 1]
		}
	    }
	    if {$len>1} {
		set 1st [lindex $seq 0]
		set seq [lreplace $seq 0 0]
		lappend seq $1st
		#set 1st [lindex $stas 1]
		#set 2nd [lindex $stas 0]
	    }
	}
	dict unset TS $AP "na"
    }
}
UTF::Test Traffic { args } {

    UTF::Getopts {
	{aps.arg "" "APs under test"}
	{stas.arg "" "STAs under test"}
	{attn.arg "10" "Attenuation between AP and STAS"}
	{attnstep.arg "1" ""}
	{distances.arg "" "Pairs of attenuation group and value to set"}
	{trx.arg "" "Router private image"}
	{bin.arg "" "STA private image"}
	{date.arg "" "Image date"}
	{build.arg "" "build name"}
	{branch.arg "" "branch name"}
	{tag.arg "" "tag override"}
	{dhd_tag.arg "" "dhd tag override"}
	{title.arg "" "title of report"}
	{email.arg "" "email alias the report sent to"}
	{history.arg "30" "Control Chart history"}
	{nocache "Don't update control chart cache"}
	{loop.arg "5" "Number of measurements to take"}
	{key.arg "" "Control chart key"}
	{direction.arg "DOWN" "traffic direction: up or down"}
	{p.arg "UDP" "protocol to test"}
	{ltosbits.arg "BE VI" ""}
	{multipliers.arg {{1 .2} {.8 .2} {.6 .2} {.2 .6} {.2 .8} {.2 1} {.5 .5} {.4 .4} {.3 .3} {.25 .25}} "list of multipliers of actual tput for offered rate"}
	{flows.arg "2" "number of traffic flows per sta"}
	{pktsize.arg "1470" "Packet size"}
	{vopktsize.arg "200" "Packet size"}
	{tcpwsize.arg "4M" "TCP window size"}
	{w.arg "1M" "UDP buffer size"}
	{vrate.arg "15M" "EBOS traffic rate for stas not specified in rates"}
	{rate.arg "1G" "Traffic rate for non-ebos for stas not specified in rates"}
	{vstresser "add ebos stresser for multiple streams with ebos"}
	{holdtime.arg "20" "timer to check traffic"}
	{delay.arg "5" "time to wait to send next traffic stream"}
 	{reportinterval.arg "0.1" "Desired iperf reportinterval"}
	{aggregateinterval.arg "0.2" "Desired interval when plotting aggregate graph"}
	{tcptrace.arg "0" "disable/enable tcptrace in stream"}
	{security.arg "open" "Default security"}
	{chanspecs.arg {36/80} "List of chanspecs to test"}
	{graphtype.arg "png" "Graph type"}
	{graphsize.arg "1024,1536" "Graph size"}
	{smoothing.arg "3" ""}
	{debug ""}
	{noload "not to load test rig"}
	{nopktqstats "Disable pktstat sampling"}
	{norestore "not to call restore_defaults when loading"}
	{noptp "not to setup ptp"}
	{assocretries.arg "3" "number of tries if assoc fails"}
	{atf.arg "1" "enable/disable ATF. By default ATF is enabled in driver."}
	{fb.arg "1" "enable/disable frameburst"}
	{scb "enable host memory allocation for SCB"}
	{no1sta "don't run pl test with 1 sta"}
	{nomstas "don't run pl test on multiple stas"}
	{nomstasdifftos "don't run pl test on multiple stas with different tos"}
	{nomstassametos "don't run pl test on multiple stas with same tos"}
	{nosequential "don't run test to send traffic sequentially"}
	{nosimultaneous "don't run test to send traffic simultaneously"}
	{noattn "don't run test with attenuation"}
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }
    if {[llength $(aps)] > 2} {
	error "Expected 1 or 2 APs. "
    }
    if {![regexp -nocase "UP" $(direction)]  && ![regexp -nocase "DOWN" $(direction)] \
	    && ![regexp -nocase "BIDIR" $(direction)]} {
	error "Invalid traffic direction $(direction). Expecting UP, DOWN or BIDIR."
    }
    foreach t $(ltosbits) {
	if {![regexp -nocase (BE|BK|VI|VO) $t]} {
	    error "Invalid tosbits $t. Expecting list of BK,BE,VI and VO."
	}
    }
    #res used to decide whether to exit the script execution
    set res 0
    set (ap) [lindex $(aps) 0]
    set today [join [clock format [clock seconds] -format "%Y %N %e"] .]

    if {$(date) eq ""} {
	set date $today
    } else {
	set date $(date)
    }
    foreach AP "$(aps)" {
	if {$(trx) ne ""} {
	    $AP configure -image $(trx) -date {}
	}
	if {$(tag) ne ""} {
	    $AP configure -tag $(tag) -date {}
	}
	if {$(dhd_tag) ne ""} {
	    $AP configure -dhd_tag $(dhd_tag)
	}
	if {$(date) ne ""} {
	    $AP configure -date $(date)
	    if {[$AP hostis DHD]} {
		$AP configure -dhd_date $(date)
	    }
	}
    }
    foreach STA $(stas) {
	if {$(bin) ne ""} {
	    $STA configure -image $(bin) -date {}
	}
    }

    # Compact build list for title
    # Include the WDS list, in case the AP list is empty.  Duplicates
    # will be removed automatically.
    set build [UTF::BuildTitle [concat $(aps) $(stas)]]
    set TITLE "$(title) ($build) (ch=${(chanspecs)},$(security))"
    UTF::Message INFO "" $TITLE
    unset build

    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]
	if {[llength $(aps)] > 1} {

	    UTF::Try "Validating Host and device of $(aps)" {
		#mbss (aps) will have same host
		#but different wl interface
		foreach AP $(aps) {
		    set h [$AP cget -host]
		    set d [$AP cget -device]
		    lappend l $d
		    if {![info exists host]} {
			set host $h
		    } elseif {$h ne $host} {
			set res 1
			error "Usage: All MBSS $(aps) must belong to the same host"
		    }
		    if {![info exists dev]} {
			set dev $d
		    } elseif {$d eq $dev} {
			error "Usage: All MBSS $(aps) must have different devices."
		    }
		}
		return "host=$host; devices=$l"
	    }
	    #exit script if anything failed in above Try block
	    if {$res} {
		UTF::Message INFO "" "Exiting due to host/device validation failed."
		exit $res
	    }
	} else {
	    set host [$(aps) cget -host]
	}

	if {!$(noload)} {
	    if {!$(norestore)} {
		if {[catch {LoadRig "$(aps) $(stas)"}]} {
		    exit 1
		}
	    } else {
		if {[catch {LoadRig "$(aps) $(stas)" $(norestore)}]} {
		    exit 1
		}
	    }
	}

	UTF::Try "Common Setup" {
	    UTF::Try "Initial Cleanup" {
		catch {$STA wl -u disassoc}
		UTF::Streamslib::force_cleanup [concat $(aps) $(stas)]
		UTF::stream allstreams destroy
	    }

	    #for Fedora19, need to setup ptpd2. The proc and array are in config file
	    #for Fedora22, ptpd2 should be included already
	    if {[info procs ::enable_ptp] ne "" && !$(noptp)} {
		UTF::Try "PTP setup" {
		    if {[array exists ::ptpinterfaces]} {
			UTF::Message INFO "" "[array get ::ptpinterfaces]"
			::enable_ptp
		    }
		}
	    }

	    #if ::UTF::SetupTestBed is defined in config file
	    #run the setup
	    if {[info exists ::UTF::SetupTestBed]} {
		UTF::Try "SetupTestBed" {
		    eval $::UTF::SetupTestBed
		}
	    }
	    foreach STA $(stas) {
		UTF::Try "$STA Disassoc" {
		    catch {$STA wl -u disassoc}
		}
	    }

	    set AP [lindex $(aps) 0]
	    if {[$AP hostis Router]} {
		UTF::Try "Turn on the radio on $AP" {
		    set wlname [$AP wlname]
		    regsub {\.\d+} $wlname {} wlbase
		    if {[$AP nvram get ${wlbase}_radio] ne "1"} {
			lappend nv ${wlbase}_radio=1
		    }

		    if {[info exists nv]} {
			UTF::Message INFO "" "nv: $nv"
			$AP restart $nv
			UTF::Sleep 1
			unset nv
		    }
		}
	    }

	    UTF::Try "Attenuation Setup" {
		#all STAs at about the same distance from AP
		#set AP attn to 0
		#MBSS has the same attngroup
		set AP $(ap)
		set lattn {}
		if {$(distances) eq ""} {
		    foreach STA $(stas) {
			set attngrp [$STA cget -attngrp]
			UTF::Message INFO "" "$STA attngrp=$attngrp"
			if {$attngrp eq ""} {
			    set attngrp [$AP cget -attngrp]
			} else {
			    set apattngrp [$AP cget -attngrp]
			    if {$apattngrp ne ""} {
				$apattngrp attn 0
			    }
			    UTF::Message INFO "" "$apattngrp attn?"
			}
			if {$attngrp eq ""} {
			    UTF::Message WARNING "" "Attenuation group not found for $AP and $STA"
			} else {
			    catch {$attngrp attn $(attn)}
			}
			lappend lattn "$STA [$attngrp attn?]"
		    }
		} else {
		    foreach {G V} $(distances) {
			if {[$G info type] eq "::UTF::STA"} {
			    set G [$G cget -attngrp]
			}
			catch {$G attn $V}
			lappend lattn "$G [$G attn?]"
		    }
		}
		return $lattn
	    }

#--------------------------------------------------------
    set comment {
	#temporally comment out. will re-visit for DHD scb related testing
	    #SCB test needs following nvram settings:
	    #http://hwnbu-twiki.sj.broadcom.com/bin/view/Mwgroup/PcieFullDongleScbExpand#4-1_Architecture_overview
	    #-nvram {
	    #    wl0_scb_alloc=1   <--- global nvram var to enable scb allocation in host memory for dongle routers
	    #    wl0_bsscfg_class=0 <--- wl0 bsscfg is for data service (private SCBs)
	    #    wl0.x_bsscfg_class=1 <--- wl0.x bsscfg is for public service (public SCBs)
	    #    wl0_scb_alloc_class=1 <--- public SCBs are allocated from host memory
	    #}
	    #if above not set in utfconf file, script will set them and apply nvram settings
	    UTF::Try "nvram Settings" {
		set addinf "UTF::Test::Mbss::APAddInterface"
		foreach AP $(aps) {
		    set res 0
		    set wlname [$AP wlname]
		    UTF::Message INFO "" "$AP wlname=$wlname"
		    if {![info exists w]} {
			set w $wlname
		    } else {
			if {$w eq $wlname} {
			    set res 1
			    error "Usage: All MBSS $(aps) must have different mbss interface."
			}
		    }

		    if {[regsub {\.\d+} $wlname {} wlbase]} {
			set addinf [join [list $addinf "-lan1" $AP]]
			if {$(scb)} {
			    if {[$AP nvram get ${wlname}_bsscfg_class] ne "1"} {
				lappend nv "${wlname}_bsscfg_class=1"
			    }
			}
		    } else {
			set addinf [join [list $addinf "-lan" $AP]]
		    }

		    if {$(scb)} {
			if {[$AP nvram get ${wlbase}_scb_alloc_class] ne "1"} {
			    lappend nv "${wlbase}_scb_alloc_class=1"
			}
			if {[$AP nvram get ${wlbase}_scb_alloc] ne "1"} {
			    lappend nv "${wlbase}_scb_alloc=1"
			}
			if {[$AP nvram get ${wlbase}_bsscfg_class] ne "0"} {
			    lappend nv "${wlbase}_bsscfg_class=0"
			}
		    }
		    #disable firewall
		    if {[$AP nvram get fw_disable] ne "1"} {
			lappend nv "fw_disable=1"
		    }
		    # Make sure base radio is on, otherwise nothing will
		    # happen
		    if {[$AP nvram get ${wlbase}_radio] ne "1"} {
			lappend nv ${wlbase}_radio=1
		    }


		    UTF::Message INFO "" "AP=$AP; res = $res"
		}
		if {[info exists nv]} {
		    UTF::Message INFO "" "nv: $nv"
		    #$host restart {*}$nv
		    $AP restart $nv
		    UTF::Sleep 1
		}
	    }
	    if {$res} {
		UTF::Message INFO "" "Exiting due to error $err"
		exit $res
	    }
	    UTF::Try "APAddInterface" {
		catch {$AP wl -i [$AP cget -device] up} status
		UTF::Message INFO "" "$status"
		UTF::Message INFO "" "APAddInterfaces cmd=$addinf"
		if {[catch {eval $addinf} err]} {
		    set res 1
		    return $err
		}
	    }
	    if {$res} {
		UTF::Message INFO "" "Exiting due to error $err"
		exit $res
	    }
	}
    }
#-----------------------------------
	set key $(key)

	set ptxt "Simultaneous"
	set stxt "Sequential"
	set (notaf) 1
	foreach AP $(aps) {
	    foreach ch $(chanspecs) {
		if {[$AP wl -u chanspec] ne $ch} {
		    package require UTF::Test::APChanspec
		    APChanspec $AP $ch
		}

		#get actual baseline rate for each sta with different tos
		array set base {}
		foreach t $(ltosbits) {
		    set m $(flows)
		    set txt " Baseline $(p) $ch \{$t\} $m flows/STA"
		    foreach sta $(stas) {
			set tos($sta) $t
		    }
		    set (key) "$key zpl baseline $(p) $ch $t $m flows $(stas)"
		    #array set meanminmax [_BaseTest $AP "$(stas)" "na" $(p) -tos tos -mflow $m -txt $txt]
		    if {[catch {array set meanminmax [_BaseTest $AP "$(stas)" "na" $(p) -tos tos -mflow $m -txt $txt]} msg] \
			    || [array get meanminmax] eq {}} {
			set BASELINE_FAILURE 1
			return "Failed to get baseline tput: $msg"
		    }

		    foreach sta $(stas) {
			set tput 0
			for {set j 1} {$j <= $m} {incr j} {
			    if {[llength $meanminmax($sta,$j)]} {
				set tput [expr {int($tput + [lindex $meanminmax($sta,$j) 0])}]
				UTF::Message INFO "" "meanminmax($sta,$j)=$meanminmax($sta,$j), tput=$tput"
			    } else {
				set BASELINE_FAILURE 1
				return "Failed to get baseline tput for $sta"
			    }
			}
			set base($sta,$t) $tput
			UTF::Message INFO "" "base($sta,$t)=$base($sta,$t)"
		    }
		    UTF::Message INFO "" "t=$t"
		    array unset meanminmax
		    array unset tos
		}

		#calculate offered rates based on $(multipliers)
		set testrates {}
		foreach entry $(multipliers) {
		    for {set i 0} {$i < [llength $entry]} {incr i} {
			#set t [lindex $(ltosbits) $i]
			foreach  sta $(stas) {
			    foreach t $(ltosbits) {
				if {![dict exists $testrates $sta $t [lindex $entry $i]]} {
				    dict set testrates $sta $t [lindex $entry $i] [expr {int([lindex $entry $i] * $base($sta,$t))}]
				}
			    }
			}
		    }
		}
		UTF::Message INFO "" "testrates= \n [dict get $testrates]"
		#only 1-sta cases
		if {!$(no1sta)} {

		    #set sta [lindex $(stas) 0]
		    foreach sta $(stas) {
			set tos($sta) $(ltosbits)
			set m [llength $(ltosbits)]
			if {!$(nosimultaneous)} {
			    foreach entry $(multipliers) {
				for {set i 0} {$i < [llength $entry]} {incr i} {
				    if {$m > $i} {
					set t [lindex $(ltosbits) $i]
				    } else {
					set t "BE"
				    }
				    #lappend rates($sta) [dict get $testrates $sta [lindex $(ltosbits) $i] [lindex $entry $i]]
				    lappend rates($sta) [dict get $testrates $sta $t [lindex $entry $i]]
				    UTF::Message INFO "" "\[$i\]:rates($sta) = $rates($sta)"
				}
				set ctxt "PL $(p) \{$ch\} \{[array get tos]\} \{$entry\}"
				set ck "$key $ctxt"
				set (key) "$ck $ptxt"
				if {[catch {_SimultaneousTrafficTest $AP "$sta" "na" $(p) -tos tos \
						-txt "$ctxt $ptxt" -rates rates -mflow $m} msg]} {
				    UTF::Message ERROR "" "$msg"
				}
				unset t
				array unset rates
			    }
			}
			if {!$(nosequential)} {
			    foreach entry $(multipliers) {
				for {set i 0} {$i < [llength $entry]} {incr i} {
				    if {$m > $i} {
					set t [lindex $(ltosbits) $i]
				    } else {
					set t "BE"
				    }
				    #lappend rates($sta) [dict get $testrates $sta [lindex $(ltosbits) $i] [lindex $entry $i]]
				    lappend rates($sta) [dict get $testrates $sta $t [lindex $entry $i]]
				    UTF::Message INFO "" "\[$i\]:rates($sta) = $rates($sta)"
				}
				set ctxt "PL $(p) \{$ch\} \{[array get tos]\} \{$entry\}"
				set ck "$key $ctxt"
				set (key) "$ck $stxt"
				#[expr {int($(holdtime)/2)}]
				_SequentialTrafficTest $AP "$sta" "na" $(p) $(delay)  \
				    -tos tos -txt "$ctxt $stxt"  -rates rates -mflow $m
				unset t
				array unset rates
			    }
			}
			array unset tos
		    }
		}
		#only m-sta cases
		if {!$(nomstas)} {
		    set ltosbits {}
		    if {!$(nomstasdifftos)} {
			lappend ltosbits $(ltosbits)
		    }
		    if {!$(nomstassametos)} {
			foreach t $(ltosbits) {
			    if {[lsearch $ltosbits $t] eq "-1"} {
			    	lappend ltosbits $t
			    }
			}
		    }
		    UTF::Message INFO "" "ltosbits=$ltosbits"
		    set n 0
		    foreach t $ltosbits {
			set tostxt ""
			set q [llength $t]

			if { $q eq 1} {
			    #all stas have same tos set
			    foreach sta $(stas) {
				set tos($sta) $t
			    }
			} else {
			    #stas have different tos set
			    #if not specified, by default use "BE"
			    foreach sta $(stas) {
				if {$n >= $q} {
				    set tos($sta) "BE"
				} else {
				    set tos($sta) [lindex $t $n]
				}
				incr n
			    }
			}
			#---------------------------------------------------
			#Note 1: using multiple seperate loops below in order to
			#group same scenarios together in summary report
			#
			#Note 2: [array get tos] returns a list in random order, so doesn't always
			# match multipliers properly in summary report, thus store the info in a list
			# for controlled display
			foreach sta $(stas) {
			    lappend tostxt "$sta $tos($sta)"
			}
			set ctxt "PL $(p) \{$ch\} \{$tostxt\}"
			set ck "$key $ctxt"
			if {!$(nosimultaneous)} {
			    foreach entry $(multipliers) {
				for {set i 0} {$i < [llength $entry]} {incr i} {
				    if {$i < [llength $(stas)]} {
					set sta [lindex $(stas) $i]
				    }
				    lappend rates($sta) [dict get $testrates $sta $tos($sta) [lindex $entry $i]]
				    UTF::Message INFO "" "\[$i\]:rates($sta) = $rates($sta)"
				}

				set (key) "$ck \{$entry\} $ptxt"
				if {[catch {_SimultaneousTrafficTest $AP $(stas) "na" $(p) -rates rates -tos tos \
						-txt "$ctxt \{$entry\} $ptxt"} msg]} {
				    UTF::Message ERROR "" "$msg"
				}
				array unset rates
			    }
			}
			if {!$(nosequential)} {
			    foreach entry $(multipliers) {
				for {set i 0} {$i < [llength $entry]} {incr i} {
				    if {$i < [llength $(stas)]} {
					set sta [lindex $(stas) $i]
				    }
				    lappend rates($sta) [dict get $testrates $sta $tos($sta) [lindex $entry $i]]
				    UTF::Message INFO "" "\[$i\]:rates($sta) = $rates($sta)"
				}

				set (key) "$ck \{$entry\} $stxt"
				#[expr {int($(holdtime)/2)}]
				_SequentialTrafficTest $AP $(stas) "na" $(p) $(delay) \
				    -rates rates -tos tos -txt "$ctxt \{$entry\} $stxt"
				array unset rates
			    }
			}
			if {!$(noattn)} {
			    foreach entry $(multipliers) {
				for {set i 0} {$i < [llength $entry]} {incr i} {
				    foreach sta $(stas) {
					if {$i < [llength $(stas)]} {
					    set sta [lindex $(stas) $i]
					}
				    }
				    lappend rates($sta) [dict get $testrates $sta $tos($sta) [lindex $entry $i]]
				    UTF::Message INFO "" "\[$i\]:rates($sta) = $rates($sta)"
				}
				foreach g "[lindex $(stas) 0] [lindex $(stas) 1]" {
				    #incr testno
				    set (key) "$ck \{$entry\} $ptxt"
				    if {[catch {_SimultaneousTrafficTest $AP $(stas) "na" $(p) -rates rates  \
						    -g $g  -tos tos  -attnstep $(attnstep) \
						    -txt "$ctxt \{$entry\} $ptxt"} msg]} {
					UTF::Message ERROR "" "$msg"
				    }
				}
				array unset rates
			    }
			}
			array unset tos
		    }
		}
	    }

	    set (notaf) 0
	}

    }
}
