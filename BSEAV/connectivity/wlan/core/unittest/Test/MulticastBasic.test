#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script for AP/STA reliable multicast (EMF) feature
#
# Written by: Robert J. McMahon June 2010
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Streams
package require UTF::Multicast
package require UTF::IGMPQuerier
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::ControlChart
package require UTF::MemChart
package require UTF::Test::PerfPPS
package require UTF::Test::Latency

namespace eval UTF::Test {
    variable tstlog_msgerror
}

#
#  Test the power throttling feature on apple airports
#
UTF::Test MulticastBasic {args} {
    UTF::Getopts {
	{ap.arg "" "AP under test"}
	{sta.arg "" "STA(s) under test"}
	{branch.arg "" "Branch override"}
 	{date.arg "" "Image date"}
	{rtrtag.arg "" "Router release tag"}
	{brand.arg "" "Brand override"}
	{email.arg "" "Email Address"}
	{title.arg "" "Title"}
	{shortholdtime.arg "8.0" "Quick hold time"}
	{longholdtime.arg "63.0" "Long hold time"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{trx.arg "" "Router trx"}
        {history.arg 30 "History size for control charts"}
	{perfloop.arg 1 "Performance test loops"}
	{security.arg "open" "Default security"}
	{chanspec.arg "157l" "Default chanspec"}
	{nosecurity  "Don't do security tests"}
	{nochannels  "Don't do all channels supported tests"}
	{noperf      "Don't run performance tests"}
	{numcycles.arg "100" "Number of stream cycles for EMF db insert/remove"}
	{5Gonly "Only test 5G band"}
	{debugging "Working in a debugging mode"}
	{nowettunnel "test with wet_tunnel feature enabled"}
    }

    #
    # Find the common channels supported by all devices
    #
    proc GetCommonChannels {args} {
	UTF::Try "Get common channels" {
	    foreach STA $args {
		lappend cmdlists [$STA allchanspecs]
	    }
	    set results [eval [concat UTF::Common $cmdlists]]
	    return [llength $results]
	}
	return $results
    }

    proc BasicTrafficTest {igmpq chanspecs stream {holdtime 2.0}} {
	upvar {} {}
	# allowable level in Mbs for multicast packets using multicast MAC DA
	set MCAST_DMAC_TOLERANCE 250000
	foreach chanspec $chanspecs {
	    UTF::Try "Chanspec setup ch=$chanspec" {
		set exceptionmsg {}
		UTF::Message INFO $(ap) "setting chanspec to $chanspec"
		if {[lindex [$(ap) wl chanspec] 0] != $chanspec} {
		    UTF::Test::APChanspec $(ap) $chanspec
		}
		UTF::Test::ConnectAPSTA $(ap) $(sta)
	    }

	    UTF::Try "IGMP Querier Test" {
		$igmpq stop
		set output [$(ap) emf list rtport [$(ap) brname]]
		set devs ""
		if {[regexp "RTPORT list of [$(ap) brname]:(.)*" $output - devs]} {
		    foreach dev $devs {
			$(ap) del rtport [$(ap) brname] $dev
		    }
		} else {
		    set msg "Could not parse RTPORT output"
		    UTF::Message ERROR $(ap) $msg
		    error $msg
		}
		if {[llength $devs] && ![UTF::Multicast::test_rtport_empty $(ap)]} {
		    set msg "Could not clear RTPORT for $(ap)"
		    UTF::Message ERROR $(ap) $msg
		    error $msg
		}
		$igmpq start
		set recoverytried 0
		while {1} {
		    set count 5
		    UTF::Message IGMP $(ap) "Sending $count allhosts queriers"
		    for {set ix 0} {$ix < $count} {incr ix} {
			$igmpq send
			UTF::Sleep 0.10
		    }
		    if {![UTF::Multicast::test_rtport_empty $(ap)]} {
			if {$recoverytried} {
			    return "RTPORT needed recovery"
			} else {
			    return
			}
		    }
		    set msg "Empty list for the RTPORT!"
		    # exit
		    UTF::Message ERROR $(ap) $msg
		    if {!$recoverytried} {
			$(ap) reboot
			# $ap rmmod wl
			# $ap rmmod igs
			# $ap rmmod emf
			# $ap insmod emf
			# $ap insmod igs
			# $ap insmod wl
			# $ap rc restart
			# exit
			set recoverytried 1
			UTF::Sleep 4.0
			set jx 6
			while {$jx} {
			    incr jx -1
			    if {[catch {$(ap) wl ssid} apssid]} {
				break
			    }
			    foreach STA $(sta) {
				$STA wl apsta
				$STA wl ap 0
				$STA wl up
				$STA wl wsec 0
				$STA wl wpa_auth 0
				$STA wl sup_wpa
				$STA wl join $apssid imode bss amode open
			    }
			    UTF::Sleep 10.0
			    foreach STA $(sta) {
				if {[catch {$STA wl ssid} ssid]} {
				    break
				} else {
				    if {$ssid eq $apssid} {
					set jx 0
				    }
				}
			    }
			}
		    } else {
			UTF::Message ERROR $(ap) "RTPORT recovery failed"
			error $msg
		    }
		}
	    }
	    UTF::Try "Mcast traffic [$stream cget -dstgrpip] ch=$chanspec (holdtime=[expr {int($holdtime)}]s)" {
		$stream configure -rate 5M
		$stream start
		$stream stats -clear
		foreach sta $(sta) {
		    set mcast_rxa($sta) [UTF::Multicast::rxcounter $sta]
		}
		set mcast_txa [UTF::Multicast::txcounter $(ap)]
		set timea [clock clicks -milliseconds]
		UTF::Sleep $holdtime
		foreach sta $(sta) {
		    set mcast_rxb($sta) [UTF::Multicast::rxcounter $sta]
		}
		set mcast_txb [UTF::Multicast::txcounter $(ap)]
		set timeb [clock clicks -milliseconds]
		set bitsps_scale [expr {int([$stream cget -pktsize] * 8 * 1000)}]
		set mcast_txbps [expr {(($mcast_txb - $mcast_txa) * $bitsps_scale) / ($timeb - $timea)}]
		UTF::Message INFO $(ap) "MCAST DMAC tx rate = $mcast_txbps"
		set errflag 0
		set errmsg ""
		if {$mcast_txbps > $MCAST_DMAC_TOLERANCE} {
		    set errflag
		    lappend errmsg "$(ap) = $mcast_txbps "
		}
		foreach sta $(sta) {
		    set mcast_rxbps [expr {(($mcast_rxb($sta) - $mcast_rxa($sta)) * $bitsps_scale) / ($timeb - $timea)}]
		    UTF::Message INFO $sta "MCAST DMAC rx rate = $mcast_rxbps"
		    if {$mcast_rxbps > $MCAST_DMAC_TOLERANCE} {
			set errflag 1
			lappend errmsg "$sta = $mcast_rxbps "
		    }
		}
		UTF::Message INFO [namespace tail $stream] "Rates Exp: 5M Actual: [$stream stats -rate -timestamps]"
		set mcastrxrates [$stream stats -rate -mma]
		set mcastrxbytes [$stream stats -bytes -sum]
		set txbytes [$stream stats -txbytes -sum]
		foreach rxrate $mcastrxrates mcastrxbyte $mcastrxbytes {
		    UTF::Message INFO [namespace tail $stream] "Rates Exp: 5M Actual(mma): $rxrate"
		    set ratevalue [lindex $rxrate 1]
		    set mmarate [expr {int([lindex $ratevalue 0])}]
		    if {$mmarate < 4200000 || $mmarate > 5600000} {
			lappend errmsg "Single stream rate error: expected=5M actual=$mmarate"
			set errflag 1
		    }
		    set rxbytes [lindex $mcastrxbyte 1]
		    set loss [expr {int(( 100.0 * ($txbytes - $rxbytes)) / $txbytes)}]
		    if {$txbytes > 0} {
			if {$loss > 10 || $loss < -10}  {
			    # lappend errmsg "Single stream xfer error: loss=${loss}%"
			    set errflag 1
			}
		    } elseif {$txbytes <= 0} {
			lappend errmsg "Single stream tx failed"
			set errflag 1
		    }
		    if {$errflag} {
			lappend errmsg "xfer ${loss}% loss"
			#
			# Do some isolation before calling error
			#
			UTF::Multicast::show_emfdb $(ap)
			$stream configurelist "-rxdisplay on -txdisplay on"
			UTF::Sleep 5.0
			UTF::Message INFO [namespace tail $stream] "TX rates Exp: 5M Actual: [$stream stats -txrate]"
			UTF::Multicast::show_emfdb $(ap)
			set ppsrate [$stream stats -pktcount]
			UTF::Message INFO [namespace tail $stream] "Stream pps rate = $ppsrate"
			$(ap) emf list rtport [$(ap) brname]
			$stream configurelist "-rxdisplay off -txdisplay off"
		    }
		}
		$stream stop
		if {$errflag} {
		    error "$errmsg"
		} else {
		    return "${loss}% loss"
		}
	    }
	}
    }

    set defsecurity $(security)
    set defchanspec $(chanspec)

    set Routers $(ap)
    lappend cckey_common [concat $(sta) $(ap)]
    if {$(date) eq {}} {
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
    } else {
	set date $(date)
    }
    set stadate $date
    set rtrdate $date

    if {$(trx) ne ""} {
	foreach Router $Routers {
	    $Router configure -image $(trx) -date $rtrdate
	    lappend cckey_common "${Router}=$(trx)"
	}
    } elseif {$(rtrtag) ne ""} {
	foreach Router $Routers {
	    $Router configure -tag $(rtrtag) -date $rtrdate
	    lappend cckey_common "${Router}=$(rtrtag)"
	}
    } else {
	foreach Router $Routers {
	    lappend cckey_common "${Router}=[$Router cget -tag]"
	}
    }
    if {$(brand) eq ""} {
	lappend cckey_common [$(ap) cget -brand]
    } else {
	$(ap) configure -brand $(brand)
	lappend cckey_common $(brand)
    }
    # Use first Upstream AP for title.
    set build [UTF::BuildTitle [concat $(ap) $(sta)]]
    set TITLE "UTF MulticastBasic $(title) ($build)"
    UTF::Message INFO "" $TITLE
    # $build is used in the title.  For private builds this will
    # indicate special images.
    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.
    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build
    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)
    UTF::stream logginglevel "DISPLAY"
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}
	UTF::Try "iptables flush" {
	    # Clean up any stale iptables entries
	    foreach STA [$(sta) lan] {
		if {[$STA hostis Linux]} {
		    $STA rexec iptables -F
		}
	    }
	}
	if {!$(noapload)} {
	    foreach Router $Routers {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    UTF::CheckImage $Router $date unknown
		}
		UTF::Try "[$Router cget -name]: Load Image" {
		    $Router load
		}
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
		    set what [$Router whatami]
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		}
	    }
	} elseif {!$(norestore)} {
	    foreach Router $Routers {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    UTF::CheckImage $Router $rtrdate unknown
		}
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
		    set what [$Router whatami]
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		}
	    }
	}
	# Load STA image(s)
	if {!$(nostaload)} {
	    foreach STA $(sta) {
		if {$(branch) eq "auto"} {
		    set branch [$STA branchname]
		} else {
		    set branch $(branch)
		}
		lappend cckey_common $(branch)
		UTF::Try "[$STA cget -name]: Find STA Image" {
		    UTF::CheckImage $STA $date unknown
		}
		UTF::Try "[$STA cget -name]: load" {
		    $STA load
		}
		UTF::Try "[$STA cget -name]: defaults" {
		    $STA services stop
		    catch {$STA wl msglevel +error +assoc}
		    if {![$STA cget -nomimo_bw_cap]} {
			catch {$STA wl down}
			# Enable 40 in 2.4, if available.
			# Doesn't work for LMAC since LMAC is never "down"
			$STA wl -u mimo_bw_cap 1
			$STA wl up
			UTF::Sleep 1
		    }
		    $STA wl ver
		    set what [$STA whatami]
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		    set what
		}
	    }
	}
	if {$(nowettunnel)} {
	    UTF::Try "$(ap) disable wet_tunnel, ctf_enable" {
		set wldev [$(ap) wlname]
		$(ap) reboot ${wldev}_wet_tunnel=0 ctf_disable=0
	    }
	} else {
	    UTF::Try "$(ap) enable wet_tunnel, ctf_enable" {
		set wldev [$(ap) wlname]
		$(ap) reboot ${wldev}_wet_tunnel=1 ctf_disable=1
	    }
	}
	UTF::Try "Stale IGMP querier cleanup for ([$(ap) cget -name]" {
	    # Make sure any stale queriers are removed
	    UTF::Multicast::force_igmpq_cleanup [$(ap) lan]
	}
	UTF::Try "EMF Setup ([$(ap) cget -name])" {
	    set wldev [$(ap) wlname]
	    if {[ catch {UTF::Multicast::enable_wmf $(ap)} err]} {
		if {$err != "wl: Unsupported"} {
		    UTF::Message WARN $(ap) "Unrecognized error $err from wmf cmd"
		}
		$(ap) reboot \
		    emf_enable=1 \
		    wl_lazywds=1
	    } else {
		$(ap) reboot \
		    emf_enable=1 \
		    wl_lazywds=0 \
		    aci_daemon=down \
		    ${wldev}_wmf_bss_enable=1 \
		    wl_wmf_bss_enable=1
	    }
	    $(ap) rexec "brctl stp [$(ap) brname] 1"
	    #
	    # Start the igmp querier
	    #
	    set transmitter [$(ap) lan]
	    set igmpq [UTF::IGMPQuerier create %AUTO% -ap $(ap)]
	    $igmpq start
	}

	# Create streams for test
	set numstreams 500
	set longholdtime $(longholdtime)
	set shortholdtime $(shortholdtime)
	for {set ix 1} {$ix <= $numstreams} {incr ix} {
	    set teststreams($ix) [UTF::stream create %AUTO% -traffictype BESTEFFORT -rx $(sta) -tx $(ap) -pktsize 1460 -multicast on -clearsynch on]
	}
	if {!$(5Gonly)} {
	    set chanspecs "6 157l"
	} else {
	    set chanspecs "36 157l"
	}
	UTF::Message INFO "" "BasicTrafficTest: $(ap) -> $(sta) $chanspecs holdtime=$longholdtime"
	BasicTrafficTest $igmpq $chanspecs $teststreams(1) $longholdtime 
	UTF::Message INFO "" "BasicTrafficTest: $(sta) -> $(ap) $chanspecs holdtime=$longholdtime"
	set cckeybase [list $(branch) $(brand) $(sta) $(ap) "MCAST" "UDP" "ch=[lindex $chanspecs end]"]
	UTF::Try "Max mcast UDP for STA -> AP ch=[lindex $chanspecs end]" {
	    set rate [$teststreams(1) calibrate_actualoffered]
	    if {[string is integer -strict $rate]} {
		set cckey [concat "TX" $cckeybase]
		set ccname "CC_thruput_"
		UTF::MemChart $ccname -s 5 -key $cckey -history $(history) -perfcache ""
		$ccname configure -title "Thruput" -units "Mbs"
		set boundsresults [$ccname addsample $rate]
		set plot [$ccname plotcontrolchart "$rate"]
		$ccname destroy
		return $plot
	    } else {
		error "invalid rate of $rate"
	    }
	}
	UTF::Try "Max mcast UDP for AP -> STA ch=[lindex $chanspecs end]" {
	    set rate [$teststreams(2) calibrate_actualoffered]
	    if {[string is integer -strict $rate]} {
		set cckey [concat "RX" $cckeybase]
		set ccname "CC_thruput_"
		UTF::MemChart $ccname -s 5 -key $cckey -history $(history) -perfcache ""
		$ccname configure -title "Thruput"
		$ccname configure -units "Mbs"
		set boundsresults [$ccname addsample $rate]
		set plot [$ccname plotcontrolchart "$rate"]
		$ccname destroy
		return $plot
	    } else {
		error "invalid rate of $rate"
	    }
	}

	foreach sta $(sta) {
	    $teststreams(2) configure -transmitsta $sta
	    $teststreams(2) configure -receivesta [$(ap) lan]
	    BasicTrafficTest $igmpq  $chanspecs $teststreams(2) $longholdtime 
	}
	if {!$(nochannels)} {
	    set channels [GetCommonChannels $(ap) $(sta)]
	    if $(5Gonly) {
		foreach CHAN $channels {
		    if {[regexp {(\d+)([ab]?)([ul])?} $CHAN - channel band bw]} {
			if {$channel < 36} {
			    set channels [lsearch -all -not -inline $channels $CHAN]
			}
		    }
		}
	    }
	    UTF::Message INFO ""  "BasicTrafficTest: $(ap) $(sta) $chanspecs holdtime=$shortholdtime"
	    BasicTrafficTest $igmpq $channels $teststreams(3) $shortholdtime
	}

	set numactivestreams 4
	# Set the rand seed for repeatability
	expr srand(100)
	set chlist ""
	UTF::Try "EMFDB add/delete for $(ap) activestreams=$numactivestreams" {
	    if {[UTF::Multicast::test_rtport_empty $(ap)]} {
		$igmpq send; UTF::Sleep 1.0; $igmpq send
		if {[UTF::Multicast::test_rtport_empty $(ap)]} {
		    error "$(ap) not learning RTPORT"
		}
	    }
	    set testerr 0
	    for {set ix 1} { $ix <= $numactivestreams} {incr ix} {
		set ch [expr int(rand() * $numstreams)+ 1]
		set expgrpip [$teststreams($ch) cget -dstgrpip]
		set hexaddr [UTF::Multicast::ip2x $expgrpip]
		if {![UTF::Multicast::test_emfdb_delete $(ap) $expgrpip]} {
		    UTF::Message ERROR $(ap) "EMFDB stale entry for $expgrpip (${hexaddr})"
		    UTF::Multicast::force_mcast_iperf_cleanup [$teststreams($ch) cget -transmitsta] $expgrpip
		    UTF::Multicast::test_emfdb_delete $(ap) $expgrpip
		    set testerr 1
		}
		$teststreams($ch) start
		lappend chlist $ch
	    }
	    $igmpq send; $igmpq send
	    UTF::Sleep 1.0
	    foreach ch $chlist {
		set expgrpip [$teststreams($ch) cget -dstgrpip]
		if {[UTF::Multicast::test_emfdb_add $(ap) $expgrpip] == ""} {
		    set hexaddr [UTF::Multicast::ip2x $expgrpip]
		    UTF::Message ERROR $(ap) "EMFDB missing entry for $expgrpip (${hexaddr})"
		    # Retry the IGMP send with sniffer on
		    $teststreams($ch) sniff on
		    $igmpq send; $igmpq send
		    $teststreams($ch) sniff off
		    set testerr 1
		}
	    }
	    #
	    # Stop the first channel and make sure the entry is deleted
	    #
	    set ch [lindex $chlist 0]
	    $teststreams($ch) stop
	    set expgrpip [$teststreams($ch) cget -dstgrpip]
	    if {![UTF::Multicast::test_emfdb_delete $(ap) $expgrpip]} {
		set hexaddr [UTF::Multicast::ip2x $expgrpip]
		UTF::Message ERROR $(ap) "EMFDB delete error for $expgrpip (${hexaddr})"
		set testerr 1
	    }
	    #
	    # Stop all streams
	    #
	    foreach ch $chlist {
		$teststreams($ch) stop
	    }
	    UTF::Sleep 1.0
	    foreach ch $chlist {
		set expgrpip [$teststreams($ch) cget -dstgrpip]
		if {![UTF::Multicast::test_emfdb_delete $(ap) $expgrpip]} {
		    set hexaddr [UTF::Multicast::ip2x $expgrpip]
		    UTF::Message ERROR $(ap) "EMFDB delete error for $expgrpip (${hexaddr})"
		    set testerr 1
		}
	    }
	    if {$testerr} {
		error "EMFDB add/delete failed"
	    }
	}

	UTF::Try "Multiple EMFDB adds/deletes for $(ap) count=$(numcycles)" {
	    set numcycles $(numcycles)
	    set testerr 0
	    set erraddrs {}
	    for {set jx 0} {$jx < $numcycles} {incr jx} {
		set ch [expr int(rand() * $numstreams)+ 1]
		set expgrpip [$teststreams($ch) cget -dstgrpip]
		set hexaddr [UTF::Multicast::ip2x $expgrpip]
		if {![UTF::Multicast::test_emfdb_delete $(ap) $expgrpip]} {
		    UTF::Message ERROR $(ap) "EMFDB stale entry for $expgrpip (${hexaddr}) , killing stale iperf clients"
		    UTF::Multicast::force_mcast_iperf_cleanup [$teststreams($ch) cget -transmitsta] $expgrpip
		    UTF::Multicast::test_emfdb_delete $(ap) $expgrpip
		    incr testerr +1
		}
		$(ap) igs show stats [$(ap) brname]
		$teststreams($ch) start
		UTF::Sleep 1.0
		set pps [$teststreams($ch) stats -pktcount]
		UTF::Message INFO $(ap) "PPS is $pps"
		if {[UTF::Multicast::test_emfdb_add $(ap) $expgrpip] == ""} {
		    UTF::Message ERROR $(ap) "EMFDB missing entry for $expgrpip (${hexaddr})"
		    # Retry the IGMP send with sniffer on
		    $teststreams($ch) sniff on
		    $igmpq send; $igmpq send
		    $teststreams($ch) sniff off
		    incr testerr +1
		}
		$(ap) igs show stats [$(ap) brname]
		$teststreams($ch) stop
		UTF::Sleep 1.0
		$(ap) igs show stats [$(ap) brname]
		if {![UTF::Multicast::test_emfdb_delete $(ap) $expgrpip]} {
		    UTF::Message ERROR $(ap) "EMFDB delete error for $expgrpip (${hexaddr})"
		    incr testerr +1
		}
	    }
	    if {$testerr} {
		error "EMFDB add/delete failed ($testerr)"
	    }
	}
	UTF::Try "Exit" {
	    if {[info exists igmpq]} {
		catch {$igmpq destroy}
	    }
	    ::UTF::stream allstreams destroy
	}
    }
}
