#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script for Apple Power and Thermal Throttling features
#
# Written by: Robert J. McMahon April 2010
#
# $Copyright Broadcom Corporation$
#
#
# Throttling 101 with Prof. Shih
#   Power throttling (system GPIO)
#   (update every 1 second)
#     * 3x3 (bcm4331)
#        * Tx goes from 3 chains to 2 chains
#        * Rx unchanged
#     * 2x2 (e.g., bcm43224)
#        * Tx goes from 2 chains to 1 chains,
#          duty cycle defaults to 20%, duty cycle is configurable
#        * Rx goes from 2 chains to 1 chains (via MIMO power save action frame)
#  * Thermal throttling (chip tempsense)
#    (update every 10 seconds hence delay can be 10 seconds)
#     * 3x3 (bcm4331)
#        * Tx goes from 3 chains to 2 chains,
#          duty cycle defaults to 50%, duty cycle is configurable
#        * Rx unchanged
#     * 2x2 (e.g., bcm43224)
#        * Tx goes from 2 chains to 1 chains,
#          duty cycle defaults to 50%, duty cycle is configurable
#        * Rx unchanged
#   * MIMO power save (802.11 protocol)
#     * 3x3 (bcm4331)
#        * Tx unchanged
#        * Rx goes from 3 chains to 1 chain
#     * 2x2 (e.g., bcm43224)
#        * Tx unchanged
#        * Rx goes from 2 chains to 1 chain

package require UTF
package require UTF::Streams
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::ControlChart
package require UTF::MemChart
package require UTF::Test::TemperatureConvergence

#
#  Test the power throttling feature on apple airports
#
UTF::Test PowerThrottle {args} {
    UTF::Getopts {
	{sta.arg "" "STA under test"}
	{ap.arg "" "AP under test"}
	{bin.arg "" "Path to STA driver (override)"}
	{chanspec.arg "36l"}
	{ssid.arg "PowerThrottle" "SSID to use for AP outside UTF control"}
	{wlstress "run wl cmds stress test"}
	{branch.arg "" "Branch override"}
 	{date.arg "" "Image date"}
	{rtrtag.arg "" "Router release tag"}
	{tag.arg "" "STA release tag"}
	{email.arg "" "Email Address"}
	{title.arg "" "Title"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{key.arg "" "Calibration key"}
	{disablefeature "Disable feature"}
	{history.arg 30 "Performance History"}
	{debugging "Working in a debugging mode"}
	{dwell.arg "10" "Dwell time"}
	{predwell.arg "5.0" "Time before enabling"}
	{tx_duties.arg "50 75 10 25 33 66"}
	{mcs.arg "auto"}
	{frameburst ""}
	{nostbc}
	{stbc}
	{swap}
	{nosetup}
	{roamtrigger.arg "-100" "Roaming RSSI for wet devices"}
	{scansuppress.arg "0" "Scan suppress setting during test run"}
	{thermaltimer.arg "11" "wl update timer for temp sense"}
	{powerthrottletimer.arg "1" "wl update timer for power throttle"}
	{cycles.arg "3" "number of thermal throttling cycles"}
    }

    proc setchanspec {ap sta {chanspec 6}} {
	UTF::Try "Chanspec setup for $ap $sta using ch=$chanspec" {
	    UTF::Message INFO $sta "setting chanspec to $chanspec"
	    if {[lindex [$ap wl chanspec] 0] != $chanspec} {
		UTF::Test::APChanspec $ap $chanspec
	    }
	}
	UTF::Try "Connect $ap $sta" {
	    UTF::Test::ConnectAPSTA $ap $sta
	    return
	}
    }

    proc toggle_wldriver {sta chanspec {ap ""} {ssid "PowerThrottle"}} {
	upvar {} {}
	if {$ap != ""} {
	    set ssid [$ap cget -ssid]
	}
	$sta wl down
	UTF::Sleep 3.0
	$sta wl up
	$sta wl scansuppress 0
	$sta wl roam_off 0
	# $sta wl roam_trigger $(roamtrigger)
	UTF::Sleep 5.0
	$sta wl chanspec $chanspec
	$sta wl join $ssid imode bss amode open
	set timeout 45
	while {[$sta wl ssid] != $ssid && $timeout} {
	    UTF::Sleep 1
	    incr timeout -1
	}
	if {!$timeout} {
	    UTF::Message WARN $sta "STA seems stuck, trying recovery"
	    RamseyAP_AirPort power off
	    UTF::Sleep 1.0
	    RamseyAP_AirPort power on
	    $sta load
	    wl join $ssid
	    # error "STA $sta couldn't reassociate with chanspec=$chanspec ssid=$ssid "
	}
	$sta wl scansuppress $(scansuppress)
	set timeout 0
	if {$ap != ""} {
	    after 30000 [list set timeout 1]
	    while {!$timeout} {
		if {[catch {$sta ping $ap} res]} {
		    UTF::Sleep 1
		} else {
		    break
		}
	    }
	    if {$timeout} {
		error "STA $sta couldn't ping AP $ap"
	    }
	}
    }

    proc powerthrottle {sta cmd {option ""}} {
	global rxchain_bitmask
	set cmd [string toupper $cmd]
	switch -exact $cmd {
	    "ENABLE" {
		eval $sta wl pwrthrottle 1
	    }
	    "DISABLE" {
		# eval $sta wl dutycycle_pwr 0
		# eval $sta wl pwrthrottle_test 0
		eval $sta wl pwrthrottle 0
	    }
	    "RXCHAIN" {
		if {$option == ""} {
		    set chain 7
		} else {
		    set chain $option
		}
		# if 3x3 use pwrthrottle_mask
		# if 2x2 use pwrthrottle_test
		if {$rxchain_bitmask eq 7} {
		    eval $sta wl pwrthrottle_mask $chain
		} else {
		    eval $sta wl pwrthrottle_test $chain
		}
		eval $sta wl pwrthrottle 1
	    }
	    "TXDUTY" {
		if {$option == ""} {
		    set txdutycycle 25
		} else {
		    set txdutycycle $option
		}
		eval $sta wl dutycycle_pwr $option
	    }
	    "TEMP" {
	    }
	    default {
		UTF::Message WARN "" "Unknobwn cmd $cmd  Valid values are: ENABLE, DISABLE, TXDUTY, RXCHAIN"
	    }
	}
	if {$::UTF::Test::wldelay} {
	    UTF::Sleep 1
	    set output [$sta wl -u dump wlc]
	    foreach line [split $output "\n"] {
		if {[regexp {duty cycle} $line]} {
		    UTF::Message INFO [$sta cget -host] "$line"
		}
	    }
	}
    }

    proc wlcmdstresstest {sta {count 1000}} {
	set ::UTF::Test::wldelay 0
	#
	# Make sure the out of range command errors
	#
	if {[catch {powerthrottle $sta TXDUTY 101} res]} {
	    UTF::Message INFO "$sta" "res: $res"
	} else {
	    error "wl out of range didn't error as expected"
	}
	#
	#  Now blast the wl driver with the command set, selected at random
	#
	set commands "ENABLE DISABLE TXDUTY RXCHAIN"
	UTF::Message INFO $sta "wl cmd stress test $count times"
	while {$count} {
	    set index [expr {int([llength $commands] * rand())}]
	    set command [lindex $commands $index]
	    if {$command == "RXCHAIN"} {
		set chain [expr {int(2 * rand()) + 1}]
		eval powerthrottle $sta $command $chain
	    } elseif {$command == "TXDUTY"} {
		set dutycycle [expr {int(10 * rand()) + 1}]
		eval powerthrottle $sta $command $dutycycle
	    } else {
		eval powerthrottle $sta $command
	    }
	    incr count -1
	}
	UTF::Message INFO $sta "wl cmd stress test done"
	set ::UTF::Test::wldelay 1
	return
    }

    #
    # Things to do if in interactive mode
    #
    if {[info exists ::tcl_interactive] && $::tcl_interactive} {
	#
	# Destroy any existing streams
	#
	::UTF::stream allstreams destroy
	set chanspecstotest "36l"
    } else {
	set chanspecstotest $(chanspec)
	if {$(debugging)} {
	    append UTF::SummaryDir "-debugging"
	}
    }

    if {$(bin) ne ""} {
	foreach STA $(sta) {
	    $STA configure -image $(bin) -date {}
	}
    }
    if {$(tag) ne ""} {
	foreach STA $(sta) {
	    $STA configure -tag $(tag) -date {}
	}
    }
    if {$(date) ne ""} {
	set date $(date)
	foreach S $(sta) {
	    $S configure -date $(date)
	}
	unset S
    } else {
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	# Clean up whitespace (RH9 compat)
	regsub -all {\s+} $date {} date
    }

    set build [UTF::BuildTitle [concat $(sta) $(ap)]]
    set TITLE "UTF MAC Throttle $(title) ($build)"
    UTF::Message INFO "" $TITLE
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Test::wldelay 1
	#
	# Create the streams
	#
	set streams ""
	lappend streams [::UTF::stream create "$(sta)->AP(udp)" -protocol udp -rx $(ap) -tx $(sta) -pktsize 1460 -udptx_winpktcnt 100000 -udprx_winpktcnt 100000]
	lappend streams [::UTF::stream create "AP->${(sta)}(udp)" -protocol udp -rx $(sta) -tx $(ap) -pktsize 1460 -udptx_winpktcnt 100000 -udprx_winpktcnt 100000]
	lappend streams [::UTF::stream create "$(sta)->AP(tcp)" -protocol tcp -rx $(ap) -tx $(sta)]
	lappend streams [::UTF::stream create "AP->${(sta)}(tcp)" -protocol tcp -rx $(sta) -tx $(ap)]

	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}
	if {![$(ap) hostis Router]} {
	    set STALOADS [concat $(ap) $(sta)]
	    set APLOADS {}
	} else {
	    set STALOADS $(sta)
	    set APLOADS $(ap)
	}
	if {$(nosetup)} {
	    ALL attn 0
	}
	if {!$(nostaload)} {
	    foreach STA $STALOADS {
		UTF::Try "[$STA cget -name]: Find STA Image" {
		    set date [$STA cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $STA $date unknown
		}
		UTF::Try "$STA load" {
		    $STA load
		    set what [$STA whatami]
		    if {!$(nostaload)} {
			# Pull out chip info and replace whitespace to
			# make it easier for external parsers.
			regsub -all {\s+} [lreplace $what 0 0] {_} w
			if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			    UTF::Message WARN $STA $ret
			}
		    }
		    set what
		}
	    }
	}
	if {!$(noapload)} {
	    foreach Router $APLOADS {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    set date [$Router cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $Router $date unknown
		}
		UTF::Try "[$Router cget -name]: Load Image" {
		    $Router load
		}
		if {!$(norestore)} {
		    foreach Router $(ap) {
			UTF::Try "$Router: Restore Defaults" {
			    set logdir [file dirname $UTF::Logfile]
			    $Router restore_defaults
			    set what [$Router whatami]
			    # Pull out chip info and replace whitespace to make it
			    # easier for external parsers.
			    regsub -all {\s+} [lreplace $what 0 0] {_} w
			    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
				UTF::Message WARN $Router $ret
			    }
			}
		    }
		}
	    }
	}
	UTF::Try "Board Rev(s)" {
	    set output [$(sta) wl revinfo]
	    if {[regexp {boardrev[ \t]+([A-Za-z0-9]+)} $output - value]} {
		return $value
	    } else {
		error "unknown boardrev"
	    }
	}
	if {$(ap) == ""} {
	    set chanspecstotest [$(sta) wl chanspec]
	    set (ssid) [$(sta) wl ssid]
	}
	UTF::Try "MCS=$(mcs)" {
	    if {$(mcs) eq "auto"} {
		set chanspec [$(sta) wl chanspec]
		# Figure out what band we're using so that we know how to set rate
		# to "auto".  Can't just use "rate" since we may not be bandlocked.
		if {[regexp {^\d+} $chanspec c] && $c > 15} {
		    set lrate a_rate
		} else {
		    set lrate bg_rate
		}
		$(sta) wl $lrate auto
	    } else {
		$(sta) wl nrate -m $(mcs)
	    }
	}
	foreach chanspec $chanspecstotest {
	    UTF::Try "Set chanspec $chanspec" {
		if {$(ap) != ""} {
		    setchanspec $(ap) $(sta) $chanspec
		} else {
		    # Assume an AP outside of UTF control, so just
		    # setup the STA
		    toggle_wldriver $(sta) $chanspec
		}
	    }
	    set cckey [list $(sta) $(ap) $chanspec]
	    set tag [$(sta) cget -tag]
	    if {[regexp {([A-Z]+_REL_[0-9]+_[0-9]+)} $tag - match]} {
		lappend cckey $match
	    } else {
		lappend cckey $tag
	    }
	    if {$(key) ne ""} {
		lappend cckey $(key)
	    }
	    if {$(debugging)} {
		lappend cckey "debugging"
	    }
	    UTF::Try "Read rxchain" {
		global rxchain_bitmask
		set rxchain_bitmask [$(sta) wl rxchain]
		return $rxchain_bitmask
	    }
	    UTF::Try "Duty cycle default" {
		return [$(sta) wl dutycycle_pwr]
	    }
	    UTF::Try "Setup FB=$(frameburst) Roam=$(roamtrigger) SS=$(scansuppress)" {
		set failtry 0
		set fail 0
		set failmsg ""
		foreach STA $(sta) {
		    if {[catch {$STA wl scansuppress $(scansuppress)} err]} {
			UTF::Message ERROR $STA "wl scansuppress: $err"
			set failtry 1
			set fail 1
		    }
		}
		if {!$fail} {
		    lappend cckey_common "SS=$(scansuppress)"
		} else {
		    lappend cckey_common "SS=unsupported"
		    lappend failmsg "SS=unsupported"
		}
		# roaming
		set fail 0
		foreach STA $(sta) {
		    if {[catch {$STA wl roam_trigger $(roamtrigger) all} err]} {
			UTF::Message ERROR $STA "wl roamtrigger: $err"
			set failtry 1
			set fail 1
		    }
		}
		if {!$fail} {
		    lappend cckey_common "RT=$(roamtrigger)"
		} else {
		    lappend cckey_common "RT=error"
		    lappend failmsg "RT=error"
		}
		set fail 0
		foreach STA [concat $(ap) $(sta)] {
		    if {[catch {$STA wl frameburst $(frameburst)} err]} {
			UTF::Message ERROR $STA "wl frameburst: $err"
			set failtry 1
			set fail 1
		    }
		}
		set cckey [concat $cckey $cckey_common]
		if {!$fail} {
		    lappend cckey_common "FB=$(frameburst)"
		} else {
		    lappend cckey_common "FB=error"
		    lappend failmsg "FB=error"
		}
		if {$failtry} {
		    error $failmsg
		}
	    }
	    set ::UTF::Test::wldelay 0
	    UTF::Try "Find oversubscribe UDP up $(sta)->AP" {
		powerthrottle $(sta) disable
		$(sta) wl status
		if {[catch {"$(sta)->AP(udp)" calibrate_actualoffered} udpuprate]} {
		    error "$udpuprate"
		}
		if {$udpuprate <= 0 } {
		    error "Calibration for $(sta)->AP(udp) stream not greater than zero"
		}
		UTF::Message INFO+cyan "calibrated!" "UDP offered rate will be ${udpuprate}Mbs"
		set rxrate [lindex ["$(sta)->AP(udp)" stats -rate -mma] 0]
		UTF::MemChart udptxcc -key [concat $cckey [$(sta)->AP(udp) id]] -history $(history) -perfcache "" -title "UDP Offered Rate" -units "Mbs"
		set boundsresults [udptxcc addsample $udpuprate]
		if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
		    UTF::Message ERROR+Red "" $match
		    set calerr 1
		} else {
		    UTF::Message PASS "" "OK"
		    set calerr 0
		}
		if {!$calerr} {
		    return [udptxcc plotcontrolchart "TX ${udpuprate}Mbs"]
		} else {
		    error [udptxcc plotcontrolchart "TX ${udpuprate}Mbs $match"]
		}
	    }
	    UTF::Try "Find oversubscribe UDP down AP->$(sta)" {
		powerthrottle $(sta) disable
		if {[catch {"AP->${(sta)}(udp)" calibrate_actualoffered} udpdownrate]} {
		    error "$udpdownrate"
		}
		if {$udpdownrate <= 0 } {
		    error "Calibration for $(sta)->AP(udp) stream not greater than zero"
		}
		UTF::Message INFO+cyan "calibrated!" "UDP offered rate will be ${udpdownrate}Mbs"
		set rxrate [lindex ["$(sta)->AP(udp)" stats -rate -mma] 0]
		UTF::MemChart udptxcc -key [concat $cckey [$(sta)->AP(udp) id]] -history $(history) -perfcache "" -title "UDP Offered Rate" -units "Mbs"
		set boundsresults [udptxcc addsample $udpdownrate]
		if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
		    UTF::Message ERROR+Red "" $match
		    set calerr 1
		} else {
		    UTF::Message PASS "" "OK"
		    set calerr 0
		}
		if {!$calerr} {
		    return [udptxcc plotcontrolchart "TX ${udpdownrate}Mbs"]
		} else {
		    error [udptxcc plotcontrolchart "TX ${udpdownrate}Mbs $match"]
		}
	    }
	    #
	    # Now start the test loop
	    #
	    # RJM   See wlc_stf.c
	    if {$rxchain_bitmask eq "7"} {
		set chaintoswitch "1"
		set chaintotest "7"
	    } else {
		if {!$(swap)} {
		    set chaintoswitch "1"
		    set chaintotest "2"
		} else {
		    set chaintoswitch "2"
		    set chaintotest "1"
		}
	    }
	    if {$rxchain_bitmask eq "7"} {
		UTF::Try "Temperature(high)" {
		    #		    AP->${(sta)}(udp) configure -rate ${udpdownrate}M
		    $(sta)->AP(udp) configure -rate ${udpuprate}M
		    $(sta) wl phy_tempsense_override 0
		    #		    AP->${(sta)}(udp) start
		    $(sta)->AP(udp) start
		    set results [UTF::Test::TemperatureConvergence -sta $(sta)]
		    set hightemp [lindex $results 1]
		    return "[lindex $results 0] $hightemp"
		}
		UTF::Try "Temperature(throttle)" {
		    set thresh [lindex [$(sta) wl phy_tempthresh] 0]
		    $(sta) wl phy_tempsense_override [expr {int($thresh + 200)}]
		    set results [UTF::Test::TemperatureConvergence -sta $(sta) -interval 10]
		    set throttletemp [lindex $results 1]
		    AP->${(sta)}(udp) stop
		    $(sta)->AP(udp) stop
		    $(sta) wl phy_tempsense_override 0
		    UTF::Sleep $(thermaltimer)
		    return "[lindex $results 0] $throttletemp"
		}
		UTF::Try "Temperature(decrease%)" {
		    set cc [UTF::MemChart %AUTO% -key [concat $cckey perc_temp] -history $(history) -perfcache "" -title "% Temperature Delta" -units "Degrees C"]
		    UTF::Message DEBUG "hi" $hightemp
		    UTF::Message DEBUG "th" $throttletemp
		    set delta [expr {int(($hightemp  - $throttletemp) * -100 / $hightemp)}]
		    set boundsresults [$cc addsample $delta]
		    if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
			UTF::Message ERROR "" $match
			error [$cc plotcontrolchart " ${delta}% $match"]
		    } else {
			UTF::Message PASS "" "OK"
			return [$cc plotcontrolchart "${delta}%"]
		    }
		}
	    }
	    foreach stream $streams {
		if {[$stream cget -protocol] == "UDP"} {
		    if {[$stream cget -rx] eq $(ap)} {
			$stream configure -rate ${udpuprate}M
		    } else {
			$stream configure -rate ${udpdownrate}M
		    }
		}
		$stream start
		UTF::Message INFO+cyan $stream "Test cycle start"
		#
		# Test: Disable the feature
		#
		UTF::Try "Feature(s) disable [namespace tail $stream]" {
		    set ::UTF::Test::wldelay 1
		    powerthrottle $(sta) disable
		    $stream stop
		    toggle_wldriver $(sta) $chanspec $(ap)
		    $(sta) wl phy_tempsense_override 0
		    $(sta) wl dutycycle_pwr
		    UTF::Sleep [expr {$(thermaltimer) + 1}]
		    $stream start
		    set sg [UTF::streamgraph %AUTO% -stat rate -streams $stream -title "$chanspec PT=disable"]
		    $stream stats -clear
		    UTF::Message INFO $stream "Power throttling: GPIO=force-off"
		    set rate [$stream measurerate $(dwell)]
		    set rates [$stream stats -rate -meanminmax]
		    set graph [$sg plot]
		    $sg destroy
		    set boundsresults [udptxcc boundcheck $rates]
		    UTF::Message INFO $stream "boundcheck $boundsresults"
		    set maxrate "${rate}.0"
		    if {$maxrate > 0} {
			return "$graph $rate Mbs"
		    } else {
			error "Invalid rate - not greater than zero"
		    }
		}
		# Only 3x3 supports temp throttling
		if {$rxchain_bitmask eq "7"} {
		    UTF::Try "Thermal throttling [namespace tail $stream]" {
			set sg [UTF::streamgraph %AUTO% -stat rate -streams $stream -title "$chanspec  Thermal tempsense=300"]
			$(sta) wl -u dump wlc
			$stream start
			UTF::Sleep 1.0
			$stream stats -clear
			set starttime [clock seconds]
			UTF::Sleep $(predwell)
			set timea [expr {[clock seconds] - $starttime}]
			$(sta) wl phy_tempsense_override [expr {int($thresh + 200)}]
			set curr_rate [$stream measurerate [expr {$(dwell) + $(thermaltimer)}]]
			set timeb [expr {[clock seconds] - $starttime}]
			$(sta) wl phy_tempsense_override 0
			UTF::Sleep [expr {$(dwell) + $(thermaltimer)}]
			$sg configure -title "[$sg cget -title] on=$timea off=$timeb"
			set graph [$sg plot]
			$sg destroy
			set cc_percent [expr {int($curr_rate/$maxrate * 100.0)}]
			set feature_rate "${curr_rate}.0"
			set msg "$curr_rate Mbs, ${cc_percent}%"
			set cc [UTF::MemChart %AUTO% -key [concat $cckey tx=0 [namespace tail $stream]] -history $(history) -perfcache "" -title "TX Duty 0" -units "Mbs"]
			set boundsresults [$cc addsample $curr_rate]
			if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
			    UTF::Message ERROR+Red "" $match
			    set err 1
			} else {
			    UTF::Message PASS "" "OK"
			    set err 0
			}
			if {!$err} {
			    return "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
			} else {
			    error "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
			}
		    }
		    UTF::Try "Thermal cycling [namespace tail $stream]" {
			set sg [UTF::streamgraph %AUTO% -stat rate -streams $stream -title "$chanspec Thermal tempsense=300"]
			$(sta) wl -u dump wlc
			$(sta) wl phy_tempsense_override 0
			$stream stats -clear
			set starttime [clock seconds]
			UTF::Sleep $(thermaltimer)
			set titlemsg ""
			for {set ix 0} {$ix < $(cycles)} {incr ix} {
			    set timea [expr {[clock seconds] - $starttime}]
			    $(sta) wl phy_tempsense_override 300
			    UTF::Sleep $(thermaltimer)
			    $(sta) wl phy_tempsense_override 0
			    set timeb [expr {[clock seconds] - $starttime}]
			    UTF::Sleep $(thermaltimer)
			    append titlemsg "on=${timea} off=${timeb} "
			}
			set totalbytes [$stream stats -bytes -sum]
			$sg configure -title "[$sg cget -title]\\n$titlemsg"
			set graph [$sg plot]
			set cc [UTF::MemChart %AUTO% -key [concat $cckey thermalcycling $(cycles) [namespace tail $stream] bytes $(thermaltimer)] -history $(history) -perfcache "" -title "Thermal Cycling (timer=$(thermaltimer))" -units "Bytes"]
			$sg destroy
			set boundsresults [$cc addsample $totalbytes]
			set msg "[expr {int($totalbytes / 1000000)}] Mbytes"
			if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
			    UTF::Message ERROR+Red "" $match
			    error "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
			} else {
			    UTF::Message PASS "" "OK"
			    return "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
			}
		    }
		}
		if {$(nostbc)} {
		    set stbcmsg "stbc_tx=disable"
		} else {
		    if {$(stbc)} {
			set stbcmsg "stbc_tx=enable"
		    } else {
			set stbcmsg "stbc_tx=default"
		    }
		}
		UTF::Try "Powerthrottle enable [namespace tail $stream] TX duty=0 $stbcmsg" {
		    set sg [UTF::streamgraph %AUTO% -stat rate -streams $stream -title "$chanspec PT=enable TX duty=0"]
		    if {$(nostbc)} {
			catch {$(ap) wl stbc_tx 0}
		    } elseif {$(stbc)} {
			catch {$(ap) wl stbc_tx 1}
		    }
		    $stream stats -clear
		    set starttime [clock seconds]
		    if {![catch {$(sta) wl ampdu_clear_dump}]} {
			$(sta) wl -u dump amdpu
			set checkampdu 1
		    } else {
			set checkampdu 0
		    }
		    UTF::Sleep [expr {$(predwell) * 2}]
		    set ::UTF::Test::wldelay 1
		    powerthrottle $(sta) enable
		    set timea [expr {[clock seconds] - $starttime}]
		    set ::UTF::Test::wldelay 0
		    powerthrottle $(sta) txduty 100
		    set ::UTF::Test::wldelay 1
		    powerthrottle $(sta) rxchain $chaintotest
		    if {$checkampdu} {
			UTF::Sleep 2.0
			$(sta) wl -u dump amdpu
		    }
		    set curr_rate [$stream measurerate [expr {$(dwell) * 2}]]
		    set timeb [expr {[clock seconds] - $starttime}]
		    powerthrottle $(sta) disable
		    UTF::Sleep 5.0
		    $sg configure -title "[$sg cget -title] on=$timea off=$timeb"
		    set totalbytes [$stream stats -bytes -sum]
		    set graph [$sg plot]
		    powerthrottle $(sta) enable
		    UTF::Sleep 1.0
		    $sg destroy
		    set cc_percent [expr {int($curr_rate/$maxrate * 100.0)}]
		    set feature_rate "${curr_rate}.0"
		    set msg "$curr_rate Mbs, ${cc_percent}%"
		    set cc [UTF::MemChart %AUTO% -key [concat $cckey tx=0 [namespace tail $stream] bytes] -history $(history) -perfcache "" -title "TX Duty 0" -units "Bytes"]
		    set boundsresults [$cc addsample $totalbytes]
		    if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
			UTF::Message ERROR+Red "" $match
			set err 1
		    } else {
			UTF::Message PASS "" "OK"
			set err 0
		    }
		    if {!$err} {
			return "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
		    } else {
			error "$graph [string range [$cc plotcontrolchart $msg] 5 end]"
		    }
		}
		UTF::Try "[namespace tail $stream] TX duty 100% (chain-switch ${chaintotest}->${chaintoswitch})" {
		    UTF::Sleep $(predwell)
		    set ::UTF::Test::wldelay 0
		    powerthrottle $(sta) txduty 100
		    set ::UTF::Test::wldelay 1
		    powerthrottle $(sta) rxchain $chaintoswitch
		    UTF::Message INFO $stream "Power throttling: GPIO=force-on (chain ${chaintoswitch}) "
		    UTF::Sleep 60
		    set rate [$stream measurerate]
		    if {$rate > 1} {
			return "$rate Mbs"
		    } else {
			error "$rate Mbs"
		    }
		}
		#
		# Test: Enable feature, 100% dutycycle, switch back
		#
		UTF::Try "[namespace tail $stream] TX duty 100% (chain-switch ${chaintoswitch}->${chaintotest})" {
		    UTF::Sleep $(predwell)
		    powerthrottle $(sta) rxchain $chaintotest
		    UTF::Message INFO $stream "Power throttling: GPIO=force-on Trigger=on (chain $chaintotest) TX duty=100%"
		    UTF::Sleep 60
		    return "[$stream measurerate] Mbs"
		}
		foreach txduty $(tx_duties) {
		    #
		    # Test tx duty cycles
		    #
		    UTF::Try "[namespace tail $stream] TX duty ${txduty}% (chainmask=$chaintotest)" {
			set sg [UTF::streamgraph %AUTO% -stat rate -streams $stream -title "$chanspec PT=enable TX duty=$txduty"]
			set starttime [clock seconds]
			$stream stats -clear
			UTF::Sleep $(predwell)
			set ::UTF::Test::wldelay 0
			powerthrottle $(sta) txduty $txduty
			set timea [expr {[clock seconds] - $starttime}]
			set ::UTF::Test::wldelay 1
			powerthrottle $(sta) rxchain $chaintotest
			UTF::Message INFO $stream "Power throttling: GPIO=force-on TX duty=${txduty}% chain $chaintotest"
			set curr_rate [$stream measurerate $(dwell)]
			set totalbytes [$stream stats -bytes -sum]
			$sg configure -title "[$sg cget -title] Time=${timea}s"
			set graph [$sg plot]
			$sg destroy
			set cc_percent [expr {int($curr_rate/$maxrate * 100.0)}]
			if {![info exists feature_rate]} {
			    set feature_rate "${curr_rate}.0"
			    set msg "$curr_rate Mbs, ${cc_percent}%"
			} else {
			    set value [expr {int($curr_rate/$feature_rate * 100.0)}]
			    set msg "$curr_rate Mbs, ${value}%, ${cc_percent}%"
			}
			set cc [UTF::MemChart %AUTO% -key [concat $cckey $txduty[namespace tail $stream] bytes] -history $(history) -perfcache "" -title "TX Duty $txduty %" -units "Bytes"]
			set boundsresults [$cc addsample $totalbytes]
			if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - match]} {
			    UTF::Message ERROR+Red "" $match
			    set err 1
			} else {
			    UTF::Message PASS "" "OK"
			    set err 0
			}
			if {!$err} {
			    return "$graph [string range [$cc plotcontrolchart $msg] 5 en]"
			} else {
			    error "$graph [string range [$cc plotcontrolchart $msg] 5 en]"
			}
		    }
		}
		#
		# Done with this stream
		#
		$stream stop
		UTF::Message INFO $stream "Test cycle end"
	    }
	    $stream stop
	}
	if {$(wlstress)} {
	    UTF::Try "Running wl cmd stress test" {
		wlcmdstresstest $(sta)
	    }
	}
    }
    if {![info exists ::tcl_interactive] || !$::tcl_interactive} {
	::UTF::stream allstreams destroy
    }
}
