#!/bin/env utf
# -*-tcl-*-

# Test the pkt_filter feature on the 4325 SDIO dongle with an AP and LAN
# traffic generator.
#
# To get online help, type: Test/DonglePktFilter.test -h
#
# $Id$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set DonglePktFilter_help "\n\nBasic usage: DonglePktFilter.test -sta <4325 STA name>\
    \n-ap <AP STA name> -lan <LAN STA name> <more options>\
    \n\nThis script runs a variety of tests for the pkt_filter feature on the\
    \n4325 SDIO dongle. This script will load the latest TOT images if you\
    \nneed it to. For more flexible loading options, use Sanity.test.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

set DonglePktFilter_getopts {
    {ap.arg "" "AP STA name to use in tests"}
    {email.arg "" "Email address list, format: userid1,userid2,... default is your userid"}
    {lan.arg "" "LAN STA name to use in tests, must be wired device, no wireless cards"}
    {logdir.arg "" "Log directory override"}
    {noload "" "Dont load TOT images for AP or STA devices, default is to load images"}
    {nomaxfilter "Dont run tests to find max filters allowed by memory, default is to run these tests"}
    {nominfilter "Dont run minimum filter tests, default is to run these tests"}
    {nomisc "Dont run miscellaneous tests, default is to run these tests"}
    {nopolarity "Dont run the polarity filter tests, default is to run these tests"}
    {nosetup "No setup for the radios / connections, default is setup the radios & connections"}
    {nosip "Dont run the SIP filter tests, default is to run these tests"}
    {no4filter "Dont run the ARP/ICMP/TCP/UDP filter tests, default is to run these tests"}
    {sta.arg "" "4325 STA name for 4325 SDIO device to test"}
    {title.arg "" "Title for web report & email"}
}

# Setup online help info.
UTF::setup_help $DonglePktFilter_help $DonglePktFilter_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}


# NB: The UTF package seems to recognize -utfconf option without any 
# additional code in this script.

# Load packages
package require UTF
package require UTF::utils
package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart

# Namespace & package provide
namespace eval UTF::Test::DonglePktFilter {}
package provide UTF::Test::DonglePktFilter 2.0

# Common procs for this test suite.

# Gets the list of filters on dongle, parses out the actual filter 
# count and checks this against the expect count.
# flag=0 gets disabled filters
# flag=1 gets enabled filters
proc UTF::Test::DonglePktFilter::check_filter_list {STA flag expected_count} {

    # Get list of filters from STA
    UTF::Message INFO "$::localhost" "check_filter_list STA=$STA flag=$flag\
        expected_count=$expected_count"
    UTF::Message INFO "$::localhost" "Start all filters ================================="
    set filter_list [$STA wl pkt_filter_list $flag]
    UTF::Message INFO "$::localhost" "End all filters ==================================="

    # Parse out actual filter count from the first line of the response.
    set line1 [lindex [split $filter_list "\n"] 0]
    set actual_count [lindex [split $line1 ":"] 1]
    set actual_count [string trim $actual_count]
    # puts "line1=$line1 actual_count=$actual_count"

    # Check actual_count == expected_count.
    if {$actual_count != $expected_count} { 
        error "check_filter_list ERROR: actual_count=$actual_count !=\
           expected_count=$expected_count"
    }
}

# Gets the STA current stats for a specific filter_id, stores data
# in array filter_stats, computes delta from last run and optionally compares
# expected delta to actual delta, using the specified operator.
proc UTF::Test::DonglePktFilter::check_filter_stats {STA filter_id {match ""}\
     {op_match ""} {discard ""} {op_discard ""} {forward ""} {op_forward ""}} {

    # Clean up and log calling parameters
    set match [string trim $match]
    set op_match [string trim $op_match]
    set op_match [string toupper $op_match]
    if {$op_match == ""} {
       set op_match EQ
    }
    set discard [string trim $discard]
    set op_discard [string trim $op_discard]
    set op_discard [string toupper $op_discard]
    if {$op_discard == ""} {
       set op_discard EQ
    }
    set forward [string trim $forward]
    set op_forward [string trim $op_forward]
    set op_forward [string toupper $op_forward]
    if {$op_forward == ""} {
       set op_forward EQ
    }
    UTF::Message INFO "$::localhost" "check_filter_stats STA=$STA\
        filter_id=$filter_id match=$match op_match=$op_match\
        discard=$discard op_discard=$op_discard\
        forward=$forward op_forward=$op_forward"

    # Ensure global forward & discard counters are initialized.
    if {![info exists ::filter_stats(discard)]} {
        set ::filter_stats(discard) 0
        set ::filter_stats(forward) 0
    }

    # Dynamically add match array element for each filter_id as needed.
    set filter_id [string trim $filter_id]
    if {![info exists ::filter_stats($filter_id,match)]} {
        # puts "adding elements for filter_id=$filter_id namespace=[namespace current]"
        set ::filter_stats($filter_id,match) 0
    }

    # Get current filter stats
    set catch_resp [catch "set stats_data \[$STA rexec wl pkt_filter_stats\
        $filter_id\]" catch_msg]
    if {$catch_resp != 0} {
        error "check_filter_stats ERROR: wl pkt_filter_stats $filter_id got catch_msg=$catch_msg"
    } 

    # Parse out filter stats
    if {![regexp -nocase {^.*matched.*:\s+(\d+).*discarded.*:\s+(\d+).*forwarded.*:\s+(\d+).*$}\
        $stats_data x0 x1 x2 x3]} {
        error "check_filter_stats ERROR: failed to parse data!"
    }

    # Compute deltas against last run. 
    # Currently the pkt_filter feature uses 32-bit unsigned integer counters. 
    # Use 64-bit math to avoid overflows inside TCL. If we get a negative delta,
    # we warn the user that the counter has wrapped around and adjust the result
    # accordingly.
    set wrap_adjustment [expr wide(pow(2,32))] ;# 4 Billion
    # puts "wrap_adjustment=$wrap_adjustment"
    set delta_match [expr $x1 - $::filter_stats($filter_id,match)]
    # set delta_match -33 ;# test code
    if {$delta_match < 0} {
        UTF::Message WARN "$::localhost" "Counter match wrapped, adjusting delta."
        set delta_match [expr wide($delta_match + $wrap_adjustment)]
    }
    set delta_discard [expr $x2 - $::filter_stats(discard)]
    # set delta_discard -9 ;# test code
    if {$delta_discard < 0} {
        UTF::Message WARN "$::localhost" "Counter discard wrapped, adjusting delta."
        set delta_discard [expr wide($delta_discard + $wrap_adjustment)]
    }
    set delta_forward [expr $x3 - $::filter_stats(forward)]
    # set delta_forward -12 ;# test code
    if {$delta_forward < 0} {
        UTF::Message WARN "$::localhost" "Counter forward wrapped, adjusting delta."
        set delta_forward [expr wide($delta_forward + $wrap_adjustment)]
    }
    UTF::Message INFO "$::localhost" "check_filter_stats delta_match=$delta_match\
        delta_discard=$delta_discard delta_forward=$delta_forward"

    # Save current values in array filter_stats
    set ::filter_stats($filter_id,match) $x1
    set ::filter_stats(discard) $x2
    set ::filter_stats(forward) $x3

    # If expected delta parameters were specified, check that they occured.
    # The op parameter controls the logic used to check the deltas.
    foreach {name expected op actual} [list match $match $op_match $delta_match\
        discard $discard $op_discard $delta_discard\
        forward $forward $op_forward $delta_forward] {
        # puts "name=$name expected=$expected op=$op actual=$actual"
        if {$expected == ""} {
            continue
        }
        if {$op == "GE"} {
            if {$actual < $expected} {
                error "check_filter_stats ERROR: delta mismatch\
                    expected delta_$name=$expected op=$op actual delta_$name=$actual"
            }
        } elseif {$op == "LE"} {
            if {$actual > $expected} {
                error "check_filter_stats ERROR: delta mismatch\
                    expected delta_$name=$expected op=$op actual delta_$name=$actual"
            }
        } elseif {$op == "EQ"} {
           if {$actual != $expected} {
                error "check_filter_stats ERROR: delta mismatch\
                    expected delta_$name=$expected op=$op actual delta_$name=$actual"
            }
        } else {
            # All other op values are invalid.
             error "check_filter_stats ERROR: invalid op=$op, should be EQ|GE|LE"
        }
    }
}

# Delete existing filters. Useful for cleanup at start/end of a test.
# NB: If you have more than 90+ filters, you will need find another
# way to deal with them. Currently, the pkt_filter_list command only
# shows about 96 filters maximum.

# When there are more than 90+ filters in existance, you are not shown
# any of the filters. This routine will think there is nothing to do,
# so that the filters are left in place. This will likely cause
# subsequent tests to fail when they hit filters they werent expecting.
proc UTF::Test::DonglePktFilter::delete_existing_filters { STA } {

    # Get list of filters from STA and delete all existing filters.
    # NB: Need to look for enabled filters and disabled filters.
    UTF::Message INFO "$::localhost" "delete_existing_filters STA=$STA"
    set result ""
    for {set i 0} {$i <= 1} {incr i} {
        set  filter_list ""
        set catch_resp [catch "set filter_list \[$STA wl pkt_filter_list $i\]" catch_msg]
        set filter_list [split $filter_list "\n"]
        foreach line $filter_list {
            # Look for filter id, syntax: Id     :nn
            if {[regexp -nocase {^\s*Id\s*:(\d+)} $line - x1]} {
                # Delete this filter, save on result.
                catch "$STA wl pkt_filter_delete $x1"
                lappend result $x1
            }
        }
    }

    # Log results
    UTF::Message INFO "$::localhost" "delete_existing_filters STA=$STA\
        deleted filters: $result"
}

# Resets the array filter_stats.
proc UTF::Test::DonglePktFilter::reset_filter_stats { } {

    # Unset all filter_stats variables
    set names [array names ::filter_stats]
    UTF::Message INFO "$::localhost"  "reset_filter_stats array filter_stats\
        names=$names"
    foreach item $names { 
        unset ::filter_stats($item)
    }
}


# The filter tests can take 8 or 10 seconds, depending on how many 
# packets are sent. The arp caches can age out entries, making the
# the tests that run later in the cycle fail. This function will 
# refresh the arp cache by doing pings between the STA & LAN .
proc UTF::Test::DonglePktFilter::refresh_arp_cache { STA LAN } {
    UTF::Message INFO "$::localhost" "UTF::Test::DonglePktFilter::refresh_arp_cache\
        STA=$STA LAN=$LAN"

    # Set filters to forward on NOT match. Then send pings between
    # LAN & STA. This is done to ensure that the ARP caches are up
    # to date.
    $STA wl pkt_filter_mode 0
    $STA ping $LAN
    $LAN ping $STA

    # Now set filters to forward only on MATCH.
    $STA wl pkt_filter_mode 1
}

# This routine verifies that a filter is correctly installed. The
# values are read back and compared to the expeced values.
proc UTF::Test::DonglePktFilter::verify_filter { STA id polarity type\
    offset bitmask pattern enable } {

    # Log calling data
    UTF::Message INFO "$::localhost" "verify_filter\
        STA=$STA id=$id polarity=$polarity type=$type offset=$offset\
        \nbitmask=$bitmask \npattern=$pattern enable=$enable"

    # Get list of filters from STA for the specific fileter enable value.
    UTF::Message INFO "$::localhost" "Start all filters ================================="
    set filter_list [$STA wl pkt_filter_list $enable]
    UTF::Message INFO "$::localhost" "End all filters ==================================="

    # Initialize parsing variables
    set found_filter no
    set found_Mask ""
    set found_Negate "" ;# AKA polarity
    set found_Offset ""
    set found_Pattern ""
    set found_Type ""

    # Parse out actual filter count from the first line of the response.
    set filter_list [split $filter_list "\n"]
    foreach line $filter_list {

        # Skip blank lines
        if {$line == ""} {
            continue
        }

        # Each line of data is formated as: keyword    :value
        set line [split $line ":"]
        set keyword [lindex $line 0]
        set keyword [string trim $keyword]
        set value [lindex $line 1]
        set value [string trim $value]
        # puts "line=$line keyword=$keyword value=$value"

        # Look for keyword=id and the desired filter id value.
        if {$found_filter == "no" && $keyword == "Id" && $value == $id} {
            puts "Found filter $id"
            set found_filter yes
            continue
        }

        # If we find another id, then we hit the end of the desired filter
        # and are starting to process the next filter, so get out of loop.
        if {$found_filter == "yes" && $keyword == "Id"} {
            # puts "found next filter, break"
            break
        }

        # Skip lines not associated with the desired filter id.
        if {$found_filter == "no"} {
            continue
        }

        # Save values for the desired filter.
        if {$keyword == "Mask" || $keyword == "Negate" ||\
            $keyword == "Offset" || $keyword == "Pattern" ||\
            $keyword == "Type"} {
            set found_${keyword} $value
        } elseif {$keyword == "Pattern len"} {
            # ignore pattern length.
        } else {
            error "verify_filter ERROR: Unknown keyword=$keyword, value=$value"
        }
    }
    UTF::Message INFO "$::localhost" "verify_filter Filter id=$id\
        found_Negate=$found_Negate found_Type=$found_Type\
        found_Offset=$found_Offset \n   found_Mask=$found_Mask\
        \nfound_Pattern=$found_Pattern"

    # Did we find the desired filter id?
    if {$found_filter == "no"} {
        error "verify_filter ERROR: Filter id=$id not found!"
    }

    # Check the values found match the expected values.
    set error_msg ""
    foreach {k1 k2} [list found_Mask bitmask found_Offset offset\
        found_Pattern pattern found_Negate polarity found_Type type] {

        # Get corresponding value for each variable name.
        set v1 [set $k1]
        set v2 [set $k2]
        # puts "k1=$k1 v1=$v1 k2=$k2 v2=$v2"

        # Collect all errors into one message.
        if {$v1 != $v2} {
            lappend error_msg "$k1=$v1 NE $k2=$v2"
        }
    }
    if {$error_msg != ""} {
        error "verify_filter ERROR: $error_msg"
    }
}

# Test suite.
UTF::Test DonglePktFilter {args} {

    # Parse command line options.
    UTF::Getopts "$::DonglePktFilter_getopts" "$::DonglePktFilter_help"

    # Check sta & ap names were specified
    set STA $(sta)
    set STA [string trim $STA]
    set AP $(ap)
    set AP [string trim $AP]
    set LAN $(lan)
    set LAN [string trim $LAN]
    if {$STA == "" || $AP == "" || $LAN == ""} { 
        error "DonglePktFilter ERROR: You must specify the -sta, -ap & -lan options!"
    }

    # Only Linux DHD is currently supported for 4325 SDIO dongle.
    UTF::check_sta_type $STA DHD

    # Check AP is one of types: Router|BSDAP|Vx
    UTF::check_sta_type $AP "Router BSDAP Vx"

    # Check LAN is type Linux.
    UTF::check_sta_type $LAN Linux

    # Get testbed info and log it. Although the trailer / testbed info is
    # added to the end of the summary web page, for development, a lot of
    # the time the script is deliberately aborted before this occurs. Logging
    # the data now ensures you can go see the data on your screen or the
    # general log file.
    # set ::UTF::trailer_info "abcdefgh" ;# test code
    if {![info exists ::UTF::trailer_info] || $::UTF::trailer_info == ""} {
        set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]
        UTF::Message INFO "" "$::UTF::trailer_info"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list unknown
    }
    set summaryinfo ""

    # Set email subject & report title.
    set email_subject [UTF::setup_email_subject $(title)]

    # Main code body that starts html summary report and runs tests.
    # puts "UTF::SummaryDir=$UTF::SummaryDir summaryinfo=$summaryinfo\
    #    email_subject=$email_subject"
    UTF::WrapSummary $UTF::SummaryDir "$email_subject" "$summaryinfo" "$(email)" {

        # Setup hosts for log messages
        set sta_host [$STA cget -host]
        regsub -all {::} $sta_host "" sta_host
        set ap_host [$AP cget -host]
        regsub -all {::} $ap_host "" ap_host
        set lan_host [$LAN cget -host]
        regsub -all {::} $lan_host "" lan_host
        # puts "sta_host=$sta_host ap_host=$ap_host lan_host=$lan_host"

        # Setup stream & script name needed for control chart keys
        set stream [UTF::get_stream_name end]
        set self DonglePktFilter.test ;# hardcode as argv0 depends on loading order

        # Load the latest AP and STA images from TOT if required.
        # NB: LAN is expected to be Linux server, no wireless cards,
        # so it doesnt need loading.
        if {!$(noload)} {
            UTF::Try "Load devices" {

                # Update lanpeer DHCP, load AP & restore defaults.
                UTF::Try "Load Router $AP " {
                    UTF::load_rtr_retry $AP
                }

                # Load the STA
                UTF::Try "Load STA $STA " {
                    $STA load
                }
            }
        }

        # Associate devices and do connectivity checks if required. 
        if {!$(nosetup)} {

            UTF::Try "Testbed setup" {

                # Reboot Router
                UTF::Try "Reboot $AP" {
                    # Make sure router is powered on!
                    catch "$AP power on"
                    UTF::Sleep 5

                    # Reboot the router
                    $AP reboot
                }

                # Reload the existing STA driver.
                UTF::Try "Reload $STA" {
                    $STA reload
                }

                # Associate AP & STA devices. Try multiple times as needed.
                # NB: LAN is expected to be Linux server, no wireless cards,
                # so it doesnt need associating.
                UTF::Try "Open Connection $AP $STA" {
                    # There have been times when tests would have
                    # passed if we had tried to open the connection
                    # after the first failure. So we try multiple times.
                    set max_association_tries 3
                    for {set j 1} {$j <= $max_association_tries} {incr j} {
                        UTF::Message INFO "" "Open Connection $AP\
                            $STA Try: $j"  
                        set catch_resp [catch "ConnectAPSTA \"$AP\" \
                            \"$STA\" -security open" catch_msg]
                        # set catch_resp 1 ;# test code
                        if {$catch_resp == 0} { 
                            break
                        }
                    }

                    # Return status depends on which attempt
                    # succeeded or not.
                    if {$j == 1 && $catch_resp == 0} {
                        # Succeeded the first time.
                        return
                    } elseif {$catch_resp == 0} {
                        # Succeeded on retry, shows as an error to get
                        # peoples attention to potential unreliablity.
                        error "Open connection succeeded on try: $j"
                    } else {
                        # Tried N times, still failed.
                        error "Open connection failed, tried\
                            $max_association_tries times!"
                    }
                }

                # Quick ping connectivity test.
                UTF::Try "Ping $AP <--> $STA" {
                    $AP ping $STA
                    $STA ping $AP
                }
                UTF::Try "Ping $STA <--> $LAN" {
                    $STA ping $LAN
                   $LAN ping $STA
                }
            }

            # If we couldnt associate, abort the script here. 95% of
            # the remaining tests will not work without a valid association
            # being present. Outside the UTF::Try block, an error becomes a
            # UTF Framework error and halts the remaining tests.
            if {$catch_resp != 0} {
                error "Halting remaining tests."
            }
        }

        # Miscellaneous tests. Normally these would be the last tests to run.
        # However checking the default filter mode is something we need to
        # do after the STA is loaded and before we do any other tests that
        # manipulate the filter mode. So we do all the miscellaneous tests 
        # up front. 
        if {!$(nomisc)} {
            UTF::Try "Miscellaneous filter tests" {

                # Check the default filter mode value
                UTF::Try "Check filter mode default" {
                    set default_filter_mode [$STA wl pkt_filter_mode]
                    if {$default_filter_mode != 1} {
                        error "ERROR: pkt_filter_mode default_filter_mode=$default_filter_mode, should be 1!"
                    }
                }

                # Add 2 filters with the same ID number, second one should
                # get an error. 
                UTF::Try "Verify pkt_filter_add with duplicate ID is rejected" {

                    # Initialization
                    UTF::Test::DonglePktFilter::delete_existing_filters $STA

                    # Add first filter with id=23
                    $STA wl pkt_filter_add 23 0 0 12 0xffff 0x0800

                    # Get filter lists & check quantities are correct.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 1 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters

                    # Attempt to add 2nd filter with id=23, verify error occurs.
                    UTF::Message INFO $::localhost "The pkt_filter_add below is\
                        expected to fail"
                    set catch_resp [catch {$STA wl pkt_filter_add 23 0 0 12 0x5555 0xaaaa} catch_msg]
                    if {$catch_resp != 1} {
                        error "ERROR: Should not have been allowed to add 2nd\
                            filter with id already in use, catch_msg=$catch_msg"
                    }

                    # Get filter lists & check quantities are still correct.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 1 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters

                    # Cleanup
                    UTF::Test::DonglePktFilter::delete_existing_filters $STA
                }
                
                # This is an exercise in convoluted logic. It is extremely 
                # unlikely that customers will actually ever try anything 
                # like this. It is possible to define 3 short filters that 
                # look at parts of a SIP packet with polarity=1 and 
                # filter_mode=0 in order to allow it to pass thru
                # while rejecting most other packets. The limitation of
                # this approach is that you cant extend the approach to
                # look for say, SIP packets as well as something else.
                # This is why customers will need to use longer filters
                # in order to do multiple protocol packet filtering.

                # Recently, test fails on first try, but passes on retry.
                for {set z 1} {$z <= 5} {incr z} {
                    UTF::Try "Convoluted 3 filter test Try: $z" {

                        # Initialization
                        UTF::Test::DonglePktFilter::delete_existing_filters $STA
    
                        # Change filter_mode, refresh the arp cache by doing pings
                        # & change filter_mode back. This keeps the tests from failing.
                        UTF::Test::DonglePktFilter::refresh_arp_cache $STA $LAN
    
                        # Add first filter, looks for Ethernet, IPV4
                        $STA wl pkt_filter_add 1 1 0 12 0xffffff 0x080045
    
                        # Add 2nd filter, looks for protocols 6=TCP or 11=UDP
                        # NB: This filter actually accepts more than just these
                        # 2 protocol numbers, but in practice this is academic.
                        $STA wl pkt_filter_add 2 1 0 23 0xe8 0x00

                        # Add 3rd filter, looks for port 5060
                        $STA wl pkt_filter_add 3 1 0 36 0xffff 0x13c4
    
                        # Enable 3 filters, set filter_mode=0
                        $STA wl pkt_filter_enable 1 1
                        $STA wl pkt_filter_enable 2 1
                        $STA wl pkt_filter_enable 3 1
                        $STA wl pkt_filter_mode 0 ;# forward on NOT match
    
                        # Get filter lists & check quantities are correct.
                        UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                        UTF::Test::DonglePktFilter::check_filter_list $STA 1 3 ;# enabled filters
    
                        # Get current TX/RX stats on STA
                        $STA if_txrx
    
                        # Send simple SIP packets via hping, should be recieved.
                        set sta_ip [$STA ipaddr]
                        UTF::hping_send lan 7000 $sta_ip 5060 tcp 5 1 300 "" 0
                        $STA if_txrx 5 "GE" 5 "EQ"

                        # Send ICMP pings via hping, should be dropped.
                        UTF::hping_send lan 7000 $sta_ip 5070 icmp 5 1 300 "" 1
                        $STA if_txrx 0 "GE" 0 "EQ"

                        # Cleanup
                        UTF::Test::DonglePktFilter::delete_existing_filters $STA
                    }
                }
            }
        }

        # Setup common parameter for minfilter & maxfilter tests.
        # Define base values for filter number, type, offset, bitmask, pattern.
        # Filter pattern is not expected to match anything useful.
        set filter_id -1 ;# next filter id to be added in linear sequence
        set filter_min 3 ;# minimum number of filters that must work
        set filter_polarity 0 ;# normal filter match
        set filter_type 0 ;# pattern matching filter
        set filter_offset 12 ;# ethernet type data offset
        set filter_bitmask "0xffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000"
        set filter_pattern "0x88880000aaaa0000cccc0000eeee000011110000333300005555000077770000"

        # If appropriate, run the minimum filter tests.
        if {!$(nominfilter)} {
            UTF::Try "Minimum filter tests" {

                # Initialization
                UTF::Test::DonglePktFilter::delete_existing_filters $STA
                $STA wl pkt_filter_mode 0 ;# forward on NOT match

                # Run initial performance tests with no filters defined.
                # NB: AP doesnt run iperf tool
                set keys "$stream $AP $self min1"
                UTF::Try "Initial no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Initial no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Add minimum filters
                UTF::Try "Add minimum $filter_min packet filters" {
                    for {set i 0} {$i < $filter_min} {incr i} {
 
                        # If a specific filter_id exists from previous tests, you must
                        # delete it before you can add a filter with the same filter_id.
                        # If the filter_id currently does not exist, we ignore the error.
                        incr filter_id
                        catch {$STA wl pkt_filter_delete $i}

                        # Add a new filter and enable it.
                        $STA wl pkt_filter_add $i $filter_polarity $filter_type\
                            $filter_offset $filter_bitmask $filter_pattern
                        $STA wl pkt_filter_enable $i 1 ;# enable the filter

                        # Verify the filter contents
                        UTF::Test::DonglePktFilter::verify_filter $STA $i\
                            $filter_polarity $filter_type $filter_offset\
                            $filter_bitmask $filter_pattern 1
                    }
   
                    # Get filter lists & check quantities are correct.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 $filter_min ;# enabled filters
                }

                # Check performance with minimum filters defined.
                set keys "$stream $AP $self min2"
                UTF::Try "$filter_min filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "$filter_min filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Delete existing filters & verify no filters left
                UTF::Try "Delete existing $filter_min filters" {
                    # Delete existing filters
                    for {set i 0} {$i < $filter_min} {incr i} {
                        $STA wl pkt_filter_delete $i
                    }

                    # Get filter lists & check quantities are 0.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters
                }

                # Run final performance tests with no filters defined.
                set keys "$stream $AP $self min3"
                UTF::Try "Final no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Final no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }
            }
            # puts "filter_id=$filter_id"
        }

        # If appropriate, run the maximum filter add test.
        if {!$(nomaxfilter)} {
            UTF::Try "Maximum filter tests" {

                # Initialization
                UTF::Test::DonglePktFilter::delete_existing_filters $STA
                $STA wl pkt_filter_mode 0 ;# forward on NOT match

                # Run initial performance tests with no filters defined.
                # NB: AP doesnt run iperf tool
                set keys "$stream $AP $self max1"
                UTF::Try "Initial no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Initial no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                UTF::Try "Add maximum packet filters allowed by available memory" {
                    set enable_errors 0
                    set filter_id -1
                    set max_filter_displayable 0
                    while { 1 } {

                        # If a specific filter_id exists from previous tests, you must
                        # delete it before you can add a filter with the same filter_id.
                        # If the filter_id currently does not exist, we ignore the error.
                        incr filter_id
                        catch {$STA wl pkt_filter_delete $filter_id}

                        # Try to to add a new filter. Dont verify contents, due
                        # to limit of 90+ displayable filters.
                        set catch_resp [catch {$STA wl pkt_filter_add $filter_id\
                            $filter_polarity $filter_type $filter_offset $filter_bitmask\
                            $filter_pattern} catch_msg]
                        if {$catch_resp == 0} {

                            # Enable new filter. 
                            set catch_resp [catch {$STA wl pkt_filter_enable $filter_id 1} catch_msg] ;# enable the filter
                            if {$catch_resp != 0} {
                                UTF::Message ERROR $sta_host "Enable filter $filter_id failed!"
                                incr enable_errors
                            }

                            # Try to display all existing filters.
                            set catch_resp [catch "UTF::Test::DonglePktFilter::check_filter_list $STA 1 [expr $filter_id +1]" catch_msg]
                            if {$catch_resp == 0} {
                                # Save maximum # filters that were successfully displayed
                                set max_filter_displayable $filter_id
                            } else {
                                UTF::Message INFO $sta_host "check_filter_list catch_msg=$catch_msg"
                            }

                        } else {
                            break
                        }
                    }

                    # Sanity check on results
                    set msg "max_filter_id=[expr $filter_id -1] max_filter_displayable=$max_filter_displayable\
                        enable_errors=$enable_errors"
                    # PR67245 was fixed by adding a default max filter limit = 8 (0 - 7)
                    if {$filter_id < 7 || $max_filter_displayable < 7 || $enable_errors > 0} {
                        error "Unexpected values: $msg"
                    } else {
                        return "$msg"
                    }
                }

                # NB: At this point, the test has loaded in so many filters
                # that the delete_existing_filters routine can not deal with
                # them. The issue being that the filter list shows no filters
                # when there are more than 90+ filters. So the code that
                # delete filters here must continue on no matter what and 
                # actually delete all the installed filters. If not, this 
                # group of tests will leave a real mess that subsequent tests
                # currently can not clean up leading to a cascade of failures.

                # The dongle doesnt pass any traffic with the maximum filters
                # defined. So we delete 25% of the filters and see what the
                # performance is like. Catch any filter delete errors and 
                # report the total number of errors. 
                set quarter_filters [expr int($filter_id / 4)]
                set delete_errors 0
                UTF::Try "Delete 25% of existing filters 0 - $quarter_filters" {
                    for {set i 0} {$i <= $quarter_filters} {incr i} {
                        set catch_resp [catch {$STA wl pkt_filter_delete $i} catch_msg]
                        if {$catch_resp != 0} {
                            incr delete_errors
                        }
                    }

                    # Now that we have deleted the target set of filters, throw
                    # an error if appropriate.
                    if {$delete_errors > 0} {
                        error "Got $delete_errors errors while deleting 25% of\
                            existing filters"
                    }
                }

                # Check performance with maximum filters defined.
                set keys "$stream $AP $self max2"
                UTF::Try "75% of maximum filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "75% of maximum  filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }
                # puts "filter_id=$filter_id"

                # Delete next 25% of the filters.
                set half_filters [expr int($filter_id / 2)]
                incr quarter_filters
                set delete_errors 0
                UTF::Try "Delete another 25% of existing filters $quarter_filters - $half_filters" {
                    for {set i $quarter_filters} {$i <= $half_filters} {incr i} {
                        set catch_resp [catch {$STA wl pkt_filter_delete $i} catch_msg]
                        if {$catch_resp != 0} {
                            incr delete_errors
                        }
                    }

                    # Now that we have deleted the target set of filters, throw
                    # an error if appropriate.
                    if {$delete_errors > 0} {
                        error "Got $delete_errors errors while deleting next 25%\
                            of existing filters"
                    }
                }

                # Run performance tests again on half the filters
                set keys "$stream $AP $self max3"
                UTF::Try "50% of maximum filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "50% of maximum filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Delete all remaining filters & verify no filters left
                incr half_filters
                set delete_errors 0
                UTF::Try "Delete all remaining existing filters $half_filters - $filter_id" {
                    # Delete existing filters
                    for {set i $half_filters} {$i < $filter_id} {incr i} {
                        set catch_resp [catch {$STA wl pkt_filter_delete $i} catch_msg]
                        if {$catch_resp != 0} {
                            incr delete_errors
                        }
                    }

                    # Now that we have deleted the target set of filters, throw
                    # an error if appropriate.
                    if {$delete_errors > 0} {
                        error "Got $delete_errors errors while deleting all\
                            remaining existing filters"
                    }

                    # Delete the last filter where we ran out of memory.
                    # Sometimes this filter is really still in memory, and
                    # should be cleaned out. Workaround for PR58456.
                    set catch_resp [catch {$STA wl pkt_filter_delete $filter_id} catch_msg]

                    # Get filter lists & check quantities are 0.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters
                }

                # Retest performance. Hopefully the performance will be the 
                # same as when we started off.
                set keys "$stream $AP $self max4"
                UTF::Try "Final no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Final no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Show results on top level web page entry
                return "max_filter_id=[expr $filter_id -1] max_filter_displayable=$max_filter_displayable"
            }
        }

        # If appropriate, test SIP filters
        if {!$(nosip)} {
            UTF::Try "SIP INVITE filter hping,i/f counter & filter counter tests $STA <--> $LAN" {

                # Create SIP INVITE packet payload. RFC3261 P12 shows a similar example.
                # P26 says each message portion delimited by CRLF.
                UTF::Try "Setup SIP INVITE packet content file on $STA, $LAN" {
                    append sip_data "INVITE sip:john@broadcom.com SIP/2.0\r\n"
                    append sip_data "Via: SIP/2.0/UDP pc33.broadcom.com;branch=z9hG4bK776asdhds\r\n"
                    append sip_data "Max-Forwards: 70\r\n"
                    append sip_data "To: John <sip:john@broadcom.com>\r\n"
                    append sip_data "From: Tim <sip:tim@broadcom.com>;tag=1928301774\r\n"
                    append sip_data "Call-ID: a84b4c76e66710@pc33.broadcom.com\r\n"
                    append sip_data "CSeq: 314159 INVITE\r\n"
                    append sip_data "Contact: <sip:tim@pc33.broadcom.com>\r\n"
                    append sip_data "Content-Type: application/sdp\r\n"
                    append sip_data "Content-Length: 142\r\n"
                    # puts "sip_data=$sip_data"

                    # Write sip_data to local tmp file.
                    set sip_invite_file /tmp/sip_invite.txt
                    set catch_resp [catch "set out \[open \"$sip_invite_file\" w\]" catch_msg]
                    if {$catch_resp != 0} {
                       error "Could not open $sip_invite_file catch_msg=$catch_msg"
                    }
                    # puts "sip_invite_file=$sip_invite_file out=$out"
                    puts -nonewline $out $sip_data ;# trailing newline messes up pkt_data_length
                    catch "close $out"
  
                    # Copy tmp file to both STA & LAN machines
                    foreach item "$STA $LAN" {
                        if {[catch {$item copyto $sip_invite_file $sip_invite_file} ret]} {
                            error "ERROR: $item copy $sip_invite_file failed: $ret"
                        }
                    }
                }

                # Add filters for SIP INVITE packets for combinations of IPv4 TCP & UDP.
                # RFC3261 P142 says elements must support both UDP & TCP.
                # P143 says to used port 5060.
                UTF::Try "Add 2 SIP INVITE filters for IPv4 UDP/TCP on $STA" {

                    # Initialization
                    UTF::Test::DonglePktFilter::delete_existing_filters $STA

                    # Set common filter parameters
                    set filter_polarity 0
                    set filter_type 0
                    set filter_offset 12 ;# skip dest/src MAC addresses, start at ethertype
   
                    # NB: The masks & patterns have underscores embedded to make them easier
                    # for the human to work with. The underscores are removed automatically
                    # by the TCL code that adds the filters.

                    # NB: The UDP & TCP filters set up below are dependant on the IP header
                    # length being 5 (* 32bit words). If someone starts sending optional IP 
                    # header items, such as source routing, these filters will reject
                    # those packets. Additional filters would be needed to handle the new
                    # relative offsets of the desired fields due to the longer IP header.
                    # The TCP filter also expect TCP header length of 5 (* 32bit words).

                    # Filter #1 checks: ethertype=0x800, IP ver=4, IP header length=5
                    # IP protocol=11(UDP), UDP dest_port=5060(SIP), payload starts with: INVITE
                    set filter1_id 1
                    set    filter1_mask 0xffffff00_00000000_000000ff_00000000_00000000_00000000_ffff0000_0000ffff_ffffffff
                    set filter1_pattern 0x08004500_00000000_00000011_00000000_00000000_00000000_13c40000_0000494e_56495445
                    # Byte:               0        4        8        12       16       20       24       28       32
                    # Field:           Ether  IP ver &            Protocol                      UDP Dest     Payload
                    #                  Type   Hdr len             UDP                           Port         INVITE

                    # Filter #2 checks: ethertype=0x800, IP ver=4, IP header length=5
                    # IP protocol=06(TCP), TCP dest_port=5060(SIP), TCP header length=5
                    # payload starts with: INVITE
                    set filter2_id 3 ;# tests gap in filter_id numbers
                    set    filter2_mask 0xffffff00_00000000_000000ff_00000000_00000000_00000000_ffff0000_00000000_0000f000_00000000_0000ffff_ffffffff
                    set filter2_pattern 0x08004500_00000000_00000006_00000000_00000000_00000000_13c40000_00000000_00005000_00000000_0000494e_56495445
                    # Byte:               0        4        8        12       16       20       24       28       32       36       40       44
                    # Field:           Ether  IP ver &            Protocol                      TCP Dest              TCP               Payload
                    #                  Type   Hdr len             TCP                           Port                  Hdr len           INVITE

                    # Add filters using above strings.
                    foreach "id mask pattern" "$filter1_id $filter1_mask $filter1_pattern\
                        $filter2_id $filter2_mask $filter2_pattern" {
                        catch {$STA wl pkt_filter_delete $id}
                        regsub -all "_" $mask "" mask
                        regsub -all "_" $pattern "" pattern
                        # puts "id=$id mask=$mask pattern=$pattern"
                        $STA wl pkt_filter_add $id $filter_polarity $filter_type $filter_offset $mask $pattern
                        $STA wl pkt_filter_enable $id 1
                        $STA wl pkt_filter_clear_stats $id

                        # Verify the filter contents
                        UTF::Test::DonglePktFilter::verify_filter $STA $id\
                            $filter_polarity $filter_type $filter_offset\
                            $mask $pattern 1
                    }
                    $STA wl pkt_filter_mode 1;# ensure forward on match

                    # Reset filter_stats array data.
                    UTF::Test::DonglePktFilter::reset_filter_stats
 
                    # Display filters.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 2 ;# enabled filters
                }

                # Use hping to test the filters
                # Get IP addresses of STA & LAN devices
                set sta_ip [$STA ipaddr]
                set lan_ip [$LAN ipaddr]
                UTF::Message INFO "$::localhost" "sta_ip=$sta_ip lan_ip=$lan_ip"

                # Use hping to send SIP INVITE packets in both directions on 
                # different protocols & port numbers. NB: hping doesnt do IPv6!
                set pkt_count 5
                set pkt_interval 0.25
                set pkt_data_length [string length $sip_data]

                # It helps in the packet traces if the LAN & STA each use
                # a different range of src_port numbers.
                set src_port_lan 11000
                set src_port_sta 12000
 
                foreach "protocol dest_port expected_result" "UDP 5060 forward\
                    UDP 5050 drop TCP 5060 forward TCP 5050 drop" {

                    # Send packets from LAN to STA.
                    UTF::Try "$STA <-- $LAN protocol=$protocol dest_port=$dest_port expected_result=$expected_result" {
                        UTF::Message INFO "$::localhost" "$STA <-- $LAN sta_ip=$sta_ip protocol=$protocol dest_port=$dest_port expected_result=$expected_result"

                        # Change filter_mode, refresh the arp cache by doing pings
                        # & change filter_mode back. This keeps the tests from failing.
                        UTF::Test::DonglePktFilter::refresh_arp_cache $STA $LAN

                        # Get current TX/RX stats on STA & filter stats.
                        $STA if_txrx
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter1_id
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter2_id

                        # Map expected_result to value hping_send will accept.
                        # Also setup expected stats deltas.
                        set expected_result [string tolower $expected_result]
                        set expected_result [string trim $expected_result]
                        if {$expected_result == "forward"} {
                            set expected_hping_result 0
                            set if_pkt_delta $pkt_count ;# if_txrx counters
                            set filter_forward $pkt_count ;# global filter forward counter
                            set filter_discard 0 ;# global filter discard counter
                            if {$protocol == "UDP"} {
                                set filter1_match $pkt_count ;# UDP match filter
                                set filter2_match 0 ;# TCP match filter
                            } else {
                                set filter1_match 0
                                set filter2_match $pkt_count
                            }

                        } else {
                            set expected_hping_result 1
                            set if_pkt_delta 0
                            set filter_forward 0
                            set filter_discard $pkt_count
                            set filter1_match 0
                            set filter2_match 0
                        }

                        # Send packets from LAN to STA. Use unique src_port for each
                        # packet sent, so they look like separate socket requests.
                        incr src_port_lan $pkt_count
                        UTF::hping_send $LAN $src_port_lan $sta_ip $dest_port $protocol $pkt_count\
                            $pkt_interval $pkt_data_length $sip_invite_file $expected_hping_result

                        # Check updated RX stats on STA match expected delta.
                        # Testing has show that the STA occasionally sends an
                        # ARP out to the AP, which messes up the TX stats and
                        # filter discard stats on the STA. So we dont check
                        # the STA TX stats, and allow for extra filter discards.
                        $STA if_txrx $if_pkt_delta "GE" $if_pkt_delta "EQ"

                        # Check all filter stats. We need to make sure the correct
                        # filter counters increment and the other filter counters
                        # remain unchanged.
                        # NB: Only the match counter is filter specific. The discard
                        # and forward are global counters.
                        UTF::Test::DonglePktFilter::check_filter_stats $STA\
                            $filter1_id $filter1_match "EQ" $filter_discard "GE"\
                            $filter_forward "EQ"
                        # The second time we check filter statistics, the global
                        # forward counter should not have changed again.
                        UTF::Test::DonglePktFilter::check_filter_stats $STA\
                            $filter2_id $filter2_match "EQ" "" "" 0 "EQ"
                    }

                    # Send packets from STA to LAN. These packets should always
                    # arrive, as the STA only filters RX packets, not TX packets.
                    set expected_result forward
                    UTF::Try "$STA --> $LAN protocol=$protocol dest_port=$dest_port expected_result=$expected_result" {
                        UTF::Message INFO "$::localhost" "$STA --> $LAN lan_ip=$lan_ip protocol=$protocol dest_port=$dest_port expected_result=$expected_result"

                        # Get current TX/RX stats on LAN & packet filters.
                        $LAN if_txrx
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter1_id
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter2_id

                        # Send packets from STA to LAN.Use unique src_port for each
                        # packet sent, so they look like separate socket requests.
                        # NB: The STA filters drop ALL packets coming back from the LAN
                        # to the STA, because the port numbers dont match or the UDP/TCP
                        # data isnt present or ARP/ICMP are always dropped.
                        incr src_port_sta $pkt_count
                        UTF::hping_send $STA $src_port_sta $lan_ip $dest_port $protocol $pkt_count\
                            $pkt_interval $pkt_data_length $sip_invite_file 1

                        # Get current RX stats on LAN. NB: The LAN is normally 
                        # directly connected to the AP. The AP can & does send ARPs
                        # and other packets directly to the LAN. Consequently, the
                        # LAN interface counters may be more than we expect. This is
                        # why we use the GE operator for checking the deltas.
                        $LAN if_txrx $pkt_count "GE" $pkt_count "GE"

                        # Check both the filter stats. We need to make sure the
                        # correct filter counters increment and the other filter
                        # counters remain unchanged.
                        set filter_forward 0
                        set filter_discard $pkt_count
                        set filter1_match 0
                        set filter2_match 0
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter1_id $filter1_match "EQ" $filter_discard "GE" $filter_forward "EQ"
                        UTF::Test::DonglePktFilter::check_filter_stats $STA $filter2_id $filter2_match "EQ" "" "" 0 "EQ"
                    }
                }

                # Cleanup by deleting filters
                UTF::Try "Delete SIP filters" {
                    $STA wl pkt_filter_delete $filter1_id
                    $STA wl pkt_filter_delete $filter2_id

                    # Get filter lists & check quantities are 0.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters
                    UTF::Test::DonglePktFilter::reset_filter_stats
                }
            }
        }

        # If appropriate, run filter polarity tests
        if {!$(nopolarity)} {
            UTF::Try "Filter polarity hping tests $STA <-- $LAN" {

                # Initialization
                UTF::Test::DonglePktFilter::delete_existing_filters $STA

                # Set common filter parameters
                set filter_polarity 1 ;# inverts filter match result
                set filter_type 0
                set filter_offset 12 ;# skip dest/src MAC addresses, start at ethertype
  
                # NB: The masks & patterns have underscores embedded to make them easier
                # for the human to work with. The underscores are removed automatically
                # by the TCL code that adds the filters.

                # Filter checks: ethertype=0x800, IP ver=4, IP header length=5
                # IP protocol=01(ICMP)
                set filter_id 1
                set    filter_mask 0xffffff00_00000000_000000ff
                set filter_pattern 0x08004500_00000000_00000001
                # Byte:              0        4        8
                # Field:          Ether  IP ver &            Protocol
                #                 Type   Hdr len             ICMP

                # Get IP addresses of STA & LAN devices
                set sta_ip [$STA ipaddr]
                set lan_ip [$LAN ipaddr]
                UTF::Message INFO "$::localhost" "sta_ip=$sta_ip lan_ip=$lan_ip"

                # Setup common hping parameters
                set protocol ICMP
                set src_port 0
                set dest_port 0
                set pkt_count 5
                set pkt_interval 0.25 ;# seconds
                set pkt_data_length 100
                set data_file ""

                # Run hping with no filters present.
                UTF::Try "No filters defined, $STA <-- $LAN protocol=$protocol expected_result=forward" {
                    $STA wl pkt_filter_mode 1 ;# ensure forward on match
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0
                    $STA if_txrx ;# update stats
                    UTF::hping_send $LAN $src_port $sta_ip $dest_port $protocol\
                        $pkt_count $pkt_interval $pkt_data_length $data_file 0
                    # There may be ARPs sent, so we use GE criteria below.
                    $STA if_txrx $pkt_count "GE" $pkt_count "GE"
                }

                # Add the ICMP filter
                UTF::Try "Add/enable ICMP filter with filter_polarity=$filter_polarity on $STA" {
                    regsub -all "_" $filter_mask "" filter_mask
                    regsub -all "_" $filter_pattern "" filter_pattern
                    $STA wl pkt_filter_add $filter_id $filter_polarity $filter_type $filter_offset $filter_mask $filter_pattern
                    $STA wl pkt_filter_enable $filter_id 1
                    $STA wl pkt_filter_clear_stats $filter_id
                    # Verify the filter contents
                    UTF::Test::DonglePktFilter::verify_filter $STA $filter_id\
                        $filter_polarity $filter_type $filter_offset\
                        $filter_mask $filter_pattern 1
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 1
                }

                # Run hping, expect ICMP packets to be dropped.
                UTF::Try "ICMP filter enabled, $STA <-- $LAN protocol=$protocol expected_result=drop" {
                    $STA if_txrx ;# update stats
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id
                    UTF::hping_send $LAN $src_port $sta_ip $dest_port $protocol\
                        $pkt_count $pkt_interval $pkt_data_length $data_file 1
                    # There may be ARPs sent by STA or AP, so we use GE criteria
                    # below.
                    $STA if_txrx 0 "GE" 0 "GE"
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id 0 "GE" $pkt_count "GE" 0 "GE"
                }

                # Run hping, expect UDP packets to be forwarded.
                set protocol UDP
                set src_port 11000
                set dest_port 12000
                UTF::Try "ICMP filter enabled, $STA <-- $LAN protocol=$protocol expected_result=forward" {
                    $STA if_txrx ;# update stats
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id
                    UTF::hping_send $LAN $src_port $sta_ip $dest_port $protocol\
                        $pkt_count $pkt_interval $pkt_data_length $data_file 0
                    # There may be ARPs sent by STA, so we use GE criteria below.
                    $STA if_txrx $pkt_count "GE" $pkt_count "GE"
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id $pkt_count "GE" 0 "GE" $pkt_count "GE"
                }
             
                # Disable the filter, run hping, expect ICMP packets to be forwarded.
                set protocol ICMP
                set src_port 0
                set dest_port 0
                UTF::Try "ICMP filter disabled, $STA <-- $LAN protocol=$protocol expected_result=forward" {
                    $STA wl pkt_filter_enable $filter_id 0 ;# disables filter
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 1
                    $STA if_txrx ;# update stats
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id
                    UTF::hping_send $LAN $src_port $sta_ip $dest_port $protocol\
                        $pkt_count $pkt_interval $pkt_data_length $data_file 0
                    # There may be ARPs sent by STA, so we use GE criteria below.
                    $STA if_txrx $pkt_count "GE" $pkt_count "GE"
                    UTF::Test::DonglePktFilter::check_filter_stats $STA $filter_id 0 "EQ" 0 "EQ" 0 "EQ"
                }

                # Delete the filter, run hping, expect ICMP packets to be forwarded.
                UTF::Try "ICMP filter deleted, $STA <-- $LAN protocol=$protocol expected_result=forward" {
                    $STA wl pkt_filter_delete $filter_id
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0
                    $STA if_txrx ;# update stats
                    # Verify you get error when you check filter that has been deleted
                    set catch_resp [catch "UTF::Test::DonglePktFilter::check_filter_stats\
                        $STA $filter_id" catch_msg]
                    if {$catch_resp != 1} {
                        error "Was expecting error when checking stats on filter\
                            that had been deleted"
                    }
                    UTF::hping_send $LAN $src_port $sta_ip $dest_port $protocol\
                        $pkt_count $pkt_interval $pkt_data_length $data_file 0
                    # There may be ARPs sent by STA, so we use GE criteria below.
                    $STA if_txrx $pkt_count "GE" $pkt_count "GE"
                }
            }
        }

        # Standard ARP/ICMP/UDP/TCP filter tests
        if {!$(no4filter)} {
            UTF::Try "ARP/ICMP/TCP/UDP filter tests" {

                # Initialization
                UTF::Test::DonglePktFilter::delete_existing_filters $STA
                $STA wl pkt_filter_mode 1 ;# forward on match

                # Run initial performance tests with no filters defined.
                # NB: AP doesnt run iperf tool
                set keys "$stream $AP $self 4f1"
                UTF::Try "Initial no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Initial no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Add filters for ARP/ICMP/TCP/UDP.
                UTF::Try "Add ARP/ICMP/UDP/TCP filters on $STA" {

                    # Set common filter parameters
                    set filter_polarity 0
                    set filter_type 0
                    set filter_offset 12 ;# skip dest/src MAC addresses, start at ethertype
   
                    # NB: The masks & patterns have underscores embedded to make them easier
                    # for the human to work with. The underscores are removed automatically
                    # by the TCL code that adds the filters.

                    # NB: The UDP & TCP filters set up below are dependant on the IP header
                    # length being 5 (* 32bit words). If someone starts sending optional IP 
                    # header items, such as source routing, these filters will reject
                    # those packets. Additional filters would be needed to handle the new
                    # relative offsets of the desired fields due to the longer IP header.
                 
                    # Filter #1 checks: ethertype=0x800, IP ver=4, IP header length=5
                    # IP protocol=11(UDP)
                    set filter1_id 1
                    set    filter1_mask 0xffffff00_00000000_000000ff
                    set filter1_pattern 0x08004500_00000000_00000011
                    # Byte:               0        4        8 
                    # Field:           Ether  IP ver &            Protocol 
                    #                  Type   Hdr len             UDP

                    # Filter #2 checks: ethertype=0x800, IP ver=4, IP header length=5
                    # IP protocol=06(TCP)
                    set filter2_id 3 ;# tests gap in filter_id numbers
                    set    filter2_mask 0xffffff00_00000000_000000ff
                    set filter2_pattern 0x08004500_00000000_00000006
                    # Byte:               0        4        8    
                    # Field:           Ether  IP ver &            Protocol
                    #                  Type   Hdr len             TCP 

                    # Filter #3 checks: ethertype=0x800, IP ver=4, IP header length=5
                    # IP protocol=01(ICMP)
                    set filter3_id 5
                    set    filter3_mask 0xffffff00_00000000_000000ff
                    set filter3_pattern 0x08004500_00000000_00000001
                    # Byte:               0        4        8    
                    # Field:           Ether  IP ver &            Protocol
                    #                  Type   Hdr len             ICMP

                    # Filter #4 checks: ethertype=0x806 (ARP)
                    set filter4_id 7
                    set    filter4_mask 0xffff
                    set filter4_pattern 0x0806
                    # Byte:               0
                    # Field:           Ether
                    #                  Type
 
                    # Add filters using above strings.
                    foreach "id mask pattern" "$filter1_id $filter1_mask $filter1_pattern\
                        $filter2_id $filter2_mask $filter2_pattern \
                        $filter3_id $filter3_mask $filter3_pattern \
                        $filter4_id $filter4_mask $filter4_pattern" {
                        catch {$STA wl pkt_filter_delete $id}
                        regsub -all "_" $mask "" mask
                        regsub -all "_" $pattern "" pattern
                        puts "id=$id mask=$mask pattern=$pattern"
                        $STA wl pkt_filter_add $id $filter_polarity $filter_type $filter_offset $mask $pattern
                        $STA wl pkt_filter_enable $id 1
                        $STA wl pkt_filter_clear_stats $id

                        # Verify the filter contents
                        UTF::Test::DonglePktFilter::verify_filter $STA $id\
                            $filter_polarity $filter_type $filter_offset\
                            $mask $pattern 1
                    }
                    $STA wl pkt_filter_mode 1;# ensure forward on match

                    # Reset filter_stats array data.
                    UTF::Test::DonglePktFilter::reset_filter_stats
 
                    # Display filters.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 4 ;# enabled filters
                }

                # Run performance tests with 4 filters active. All traffic
                # ping/iperf traffic should pass through OK. 
                set keys "$stream $AP $self 4f2"
                UTF::Try "ARP/ICMP/UDP/TCP filters enabled performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "ARP/ICMP/UDP/TCP filters enabled performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Now disable the 4 filters.
                UTF::Try "Disabling ARP/ICMP/UDP/TCP filters" {
                    foreach id "$filter1_id $filter2_id $filter3_id $filter4_id" {
                        $STA wl pkt_filter_enable $id 0
                    }

                    # Display filters.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 4 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters
                }

                # Run performance tests with 4 filters disabled.
                set keys "$stream $AP $self 4f3"
                UTF::Try "ARP/ICMP/UDP/TCP filters disabled performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "ARP/ICMP/UDP/TCP filters disabled performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }

                # Now delete the 4 filters.
                UTF::Try "Delete ARP/ICMP/UDP/TCP filters" {
                    foreach id "$filter1_id $filter2_id $filter3_id $filter4_id" {
                        $STA wl pkt_filter_delete $id 0
                    }

                    # Display filters.
                    UTF::Test::DonglePktFilter::check_filter_list $STA 0 0 ;# disabled filters
                    UTF::Test::DonglePktFilter::check_filter_list $STA 1 0 ;# enabled filters

                }

                # Run final performance tests with no filters defined.
                set keys "$stream $AP $self 4f4"
                UTF::Try "Final no filter performance test $STA --> $LAN" {
                    controlchart [list $STA $LAN] -key $keys -i 2 -s 5
                }
                UTF::Try "Final no filter performance test $STA <-- $LAN" {
                    controlchart [list $LAN $STA] -key $keys -i 2 -s 5
                }
            }
        }

    # End code for WrapSummary
    }
}

