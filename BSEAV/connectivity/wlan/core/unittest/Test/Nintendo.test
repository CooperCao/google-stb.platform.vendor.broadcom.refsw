#!/bin/env utf
# -*-tcl-*-

# UTF Nintendo emulation
#
# Usage: Nintendo <args>
#

package require UTF
package provide UTF::Test::Nintendo 2.0

UTF::Test Nintendo {args} {

   ## Reading command line arguments.
   UTF::Getopts {

      {email.arg "" "Email Address"}
      {stas.arg "WS18 WS19" "parent child"}
      {ssid.arg "CBT_NINTENDO" "parent SSID"}
      {noload "" "Don't load the stas"}
      {nonitro "" "Don't run nitro test"}
      {tag.arg "NIGHTLY" "STA Tag"}
      {title.arg "Nintendo" "Title"}
   }
   
   ## Setting the title.
   regsub "NIGHTLY" $(tag) "TOT" tag
   set TITLE "UTF CBT $(title) ($tag)"  
   UTF::Message INFO "" "$TITLE" 

   ## Setting parent and child.
   set parent [lindex $(stas) 0]
   set child [lindex $(stas) 1]
   UTF::Message INFO "" "Parent: $parent"  
   ## Change to multiple children if needed
   UTF::Message INFO "" "Child: $child"

   UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {

      if {!($(noload))} {
         UTF::Try "Load the parent and the child" {

            foreach sta $(stas) {
               UTF::Message INFO "" "Loading $sta" 
               $sta load
            }
         }
      }
  
      set ssid $(ssid)
   
      UTF::Try "Configure the parent: $parent" {

         $parent wl down
         $parent wl nitro 1
         $parent wl channel 1
         $parent wl up
         $parent wl ssid $ssid
         $parent ifconfig up
      }
    
      UTF::Try "Configure the child: $child" {

         $child wl down
         $child wl nitro 2
         $child wl up
         $child wl join [$parent wl ssid]
         $child ifconfig up
      }
   
      UTF::Sleep 2 "" "Wait for Connection"

      UTF::Try "Check association" {

         ## Check SSID and BSSID
         set cssid [$child wl ssid]
         set pssid [$parent wl ssid]
         if {($cssid == $pssid) && ($cssid == $ssid)} {
            UTF::Message INFO "" "SSID: $ssid"
         } else {
            UTF::Message ERROR "" "Child: $cssid Parent:$pssid SSID: $ssid"
            error "Wrong SSID"
         }

         set cbssid [$child wl bssid]
         set pbssid [$parent wl bssid]
         if {($cbssid == $pbssid)} {
            UTF::Message INFO "" "BSSID: $cbssid"
         } else {
            UTF::Message ERROR "" "BSSID Child: $cbssid Parent:$pbssid"
            error "Wrong BSSID"
         }
      }
   
      if {!$(nonitro)} {
         UTF::Try "Run Nitro" {
         
            set pnum 100
            set hnum 50
            set tnum 100
 
            UTF::Try "AID/polbitmap" {
            ## set data [$parent wl dump scb]
            ##set dd [split $data \n]
               if {[regexp {AID:(0xc[[:xdigit:]]+) PS}  [$parent wl dump scb]  -  aid]} {
                  set polbitmap [expr {1<< ($aid & ~0xc000)}]
                  UTF::Message INFO "" "AID:$aid   polbitmap:$polbitmap"
               } else {
                  error "AID not found"
               }
            }

	    # Run the test 10 times while we explore the consistency of
	    # the test results.

	    for {set i 0} {$i < $tnum} {incr i} {

               UTF::Try "Test $i of $tnum" {
	          # The nitro tool doesn't generate much output so we use
	          # a simplistic approach to backgrounding - we only read
	          # the child messages after the parent has finished.
	          # For more verbose tools we would add event handlers or
	          # use an event loop.

	          # Start child in the background
	          set cfd [$child rpopen /home/qvt/nitro -m child -n $pnum]
	          # Pause to let Child initialize"
	          #UTF::Sleep 1

	          # Run parent
	          catch {$parent /home/qvt/nitro -m parent -p $polbitmap -n $pnum} pret

	          # If all is well child will exit shortly after the
	          # parent.  If a packet was dropped, child will wait one
	          # second per packet.  Use SIGALRM to trigger the
	          # timeout early.

	          catch {$child rexec -q pkill -ALRM nitro}

	          # Read any output from the child
	          set cret [read $cfd]
	          UTF::Message LOG $child $cret

	          # Close the child's file handle, catching any errors
	          # from the kill, or otherwise.
	          if {[catch {close $cfd} cerr]} {
		     UTF::Message FAIL $child "child error: $cerr"
	          }
	          # Add result parsing here.
	          # Parent's messages are in $pret
	          # Child's messages are in $cret
                  if {![regexp {MP sequences: success (\d+), failures} $pret - snum]} {
                     UTF::Message ERROR "" "Success numbers missing"
                     error "Data Missing"
                   } elseif { $snum < $hnum } {
                     UTF::Message ERROR "" "parent: $pret"
                     error "parent: $pret"
                  }
                  return "parent: $pret child: $cret"
               }
	    }

	    UTF::Sleep 40 "" "Wait for possible crash"
         }
      }
   }
}
