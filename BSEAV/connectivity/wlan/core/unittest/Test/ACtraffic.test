#!/bin/env utf
# -*-tcl-*-

# UTF test script for testing AC traffic to MU-MIMO STAs
# Designed & written by: Kelvin Shum 
# $Id: 2db5a932aee3c760f7145df51b86445c9b7493c8 $
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Streams
package require UTF::Streamslib
package require UTF::Test::rssinoise

package provide UTF::Test::ACtraffic 1.0

proc getDumps {dut} {
    $dut [$dut cget -wl] -u svmp_mem 0x20300 32
    $dut [$dut cget -wl] -u svmp_mem 0x20700 32
    $dut [$dut cget -wl] -u svmp_mem 0x20b00 32
    foreach dump "wlc txbf mutx vasip_counters ampdu amsdu" {
        $dut [$dut cget -wl] -u dump $dump
    }
    set cnt [$dut wl_counter reinit]
    $dut et counters
    $dut dhd -i eth1 cons mu
    $dut dhd -i eth1 dump
    foreach cmd "ampdu_clear_dump assoclist counters nrate\
    rate ratedump pktq_stats mu_features txbf_mutimer mu_rate\
    mu_group reset_cnts" {
        $dut [$dut cget -wl] -u $cmd
    }
    $dut [$dut cget -wl] -u pmac shmx 0x80 -n 32
    catch {
        lan ifconfig
        lan iperf -v
    }

    return $cnt
}

proc getSTAdumps {dut} {
    $dut ping [lan ipaddr] -c 5
    foreach dump "ampdu murx" {
        catch {$dut wl dump $dump}
    }
    foreach cmd "status rssi nrate rate reset_cnts" {
        catch {$dut wl $cmd}
    }
}

proc getSmallDumps {dut} {
    foreach dump "vasip_counters" {
        $dut [$dut cget -wl] -u dump $dump
    }
    foreach cmd "mu_rate mu_group" {
        $dut [$dut cget -wl] -u $cmd
    }
}

proc unitscalefactor {units} {
	switch -exact $units {
	    "M" {
		return 1000000.0
	    }
	    "K" {
		return 1000.0
	    }
	    "" {
		return 1
	    }
	    "G" {
		return 1000000000.0
	    }
	    default {
		error "Unknown units $units"
	    }
	}
}

proc rate2numeric {value} {
	if {$value eq "-1"} {
	    return 1000000
	}
	if {[string is double $value]} {
	    return [format %0.0f $value]
	}
	set scale [unitscalefactor [string index $value end]]
	set numeric [string range $value 0 end-1]
	return [expr {$scale * $numeric}]
}

UTF::Test ACtraffic { args } {
    UTF::Getopts {
	{branch.arg "" "branch name"}
	{title.arg "" "title of report"}
	{email.arg "" "email alias the report sent to"}
	{ap.arg "" "AP"}
	{stalist.arg "" "STAs"}
	{dirlist.arg "DN UP" "traffic directions: up or down"}
	{protolist.arg "TCP UDP" "traffic stream type can be UDP or TCP"}
	{ttypelist.arg "VI VO BE BK" "type of traffic"}
	{attnlist.arg "" "attenuation between AP and each STA"}
	{duration.arg "" "traffic transmission duration"}
	{pktsize.arg "1470" "Packet size"}
	{rate.arg "1.5G" "Traffic rate"}
	{notcprate "Don't specify tcp stream rate"}
	{fb.arg "1" "enable/disable frameburst"}
	{chanspeclists.arg "1 1l 36 36l 36/80" "List of chanspecs to test"}
	{scaninterval.arg "" "STA scanning interval"}
 	{reportinterval.arg "5" "Desired reportinterval"}
	{stats.arg "rate" "List of stream stat types to be gathered"}
	{graphtype.arg "png" "Graph type"}
	{graphsize.arg "640,480" "Graph size"}
	{smoothing.arg "3" ""}
	{nocleanup "Don't cleanup testbed after test complete"}
	{norestore "Don't call restore_defaults for router" }
	{noload "Don't load test rig."}
	{nosetuptestbed "Don't run Setup Testbed hooks"}
    {security.arg "open" "security"}
	{history.arg "30" "Control chart history"}
    }

    if {$(graphsize) eq ""} {
        set (graphsize) "768,640"
    }
    if {$(history) eq ""} {
        set (history) 30 
    }
    if {$(ttypelist) eq ""} {
        error "Please specify TOS(s)"
    }
    if {$(protolist) eq ""} {
        error "Please specify the protocol (UDP/TCP) for each TOS(s)"
    }
    if {$(dirlist) eq ""} {
        error "Please specify the traffic direction (UP/DN) for each TOS(s)"
    }
    if {$(chanspeclists) eq ""} {
        error "Please specify the list of chanspecs"
    }
    if {$(notcprate) eq ""} {
        set (notcprate) 1
    }
    foreach stas $(stalist) {
    if {[llength $stas] < 2} {
        error "Two or more STAs are required in each list for this test." 
    }
    }
    if {[llength $(stalist)] != [llength $(attnlist)]} {
        error "STAs: $(stalist), ATTNs: $(attnlist)\nThe number of STA\
        lists does not match the number of attn lists."
    }
    foreach stas $(stalist) attns $(attnlist) {
    if {[llength $stas] != [llength $attns]} {
        error "STAs: $stas, ATTNs: $attns\nThe number of STAs\
        does not match the number of STA attenuations."
    }
    }
    if {[llength $(stalist)] != [llength $(protolist)]} {
        error "protolist: $(protolist), stalist: $(stalist)\nThe number of protocol\
        lists does not match the number of STA lists."
    }
    foreach stas $(stalist) protos $(protolist) {
    if {[llength $stas] != [llength $protos]} {
        error "STAs: $stas, Protocols: $protos\nThe number of STAs\
        does not match the number of protocols."
    }
    }
    if {[llength $(protolist)] != [llength $(dirlist)]} {
        error "protolist: $(protolist), dirlist: $(dirlist)\nThe number of protocol\
        lists does not match the number of traffic direction lists."
    }
    foreach directions $(dirlist) protos $(protolist) {
    if {[llength $directions] != [llength $protos]} {
        error "Protocols: $protos, Directions: $directions\nThe number of protocols\
        does not match the number of traffic directions."
    }
    }
    if {[llength $(protolist)] != [llength $(ttypelist)]} {
        error "protolist: $(protolist), ttypelist: $(ttypelist)\nThe number of protocol\
        lists does not match the number of traffic type lists."
    }
    foreach ttypes $(ttypelist) protos $(protolist) {
    if {[llength $ttypes] != [llength $protos]} {
        error "Protocols: $protos, Traffic types: $ttypes\nThe number of protocols\
        does not match the number of traffic types."
    }
    }
    
    set build [UTF::BuildTitle $(ap)]

    set TITLE "UTF $(title) - $(branch) $build"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

    set today [join [clock format [clock seconds] -format "%Y %N %e"] .]

    # Create empty summary table. If there is a higher level calling script,
    # UTF will keep the existing summary table & related object and ignore this script.
    set ::summaryinfo [UTF::setup_report_table]
    append ::summaryinfo "</table>"

    UTF::WrapSummary $UTF::SummaryDir $TITLE $::summaryinfo $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
    }

	UTF::Try "Image loading on AP" {
        set imageLoaded 0
        #only do reload and restore_defaults once 
        if {!$(noload)} {
            UTF::Try "$(ap) Find AP Image" {
                #UTF::CheckImage $(ap) unknown
                set resp [catch {$(ap) findimages} msg]
                if {$resp} {
                    error $msg
                } else {
                    $(ap) configure -image $msg
                    return $msg
                }
            }
            # Add report summary table row for AP.
            set id [UTF::get_build_id $msg]
            set notes [UTF::get_build_notes $msg]
            set status [UTF::get_build_status $msg $resp]
            set ::summaryinfo [UTF::update_report_add $::summaryinfo $(ap) ""\
            "" "" $id $notes $status]
            UTF::Try "Image loading on $(ap)" {
                $(ap) load
                set imageLoaded 1
            }
        };# if !noload
        # Update report header table with actual OS and HW versions.
        set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]
        # Update report title with actual TAG numbers.
        UTF::update_report_title $(ap)

        if {[$(ap) hostis Router] && !$(norestore)} {
        UTF::Try "restore_defaults on $(ap)" {
            $(ap) restore_defaults
        }
        }
        set what [$(ap) whatami]
        # Pull out chip info and replace whitespace to
        # make it easier for external parsers.
        regsub -all {\s+} [lreplace $what 0 0] {_} w
        if {[catch {$UTF::Summary header_update 1 $w} ret]} {
        UTF::Message WARN $(ap) $ret
        }
        $(ap) dbrecord DUT
	};#Image loading on AP

    if {$imageLoaded || $(noload)} {
    foreach STAs $(stalist) ttypes $(ttypelist) protocols $(protolist)\
    directions $(dirlist) chanspec $(chanspeclists) {

	UTF::Try "Image loading on STAs" {
	    foreach STA $STAs {

		if {!$(noload)} {
            UTF::Try "$STA Find STA Image" {
                #UTF::CheckImage $STA unknown
                set resp [catch {$STA findimages} msg]
                if {$resp} {                                                              
                    error $msg
                } else {
                    $STA configure -image $msg
                    return $msg
                }
            }
            # Add report summary table row for STA.
            set id [UTF::get_build_id $msg]
            set notes [UTF::get_build_notes $msg]
            set status [UTF::get_build_status $msg $resp]
            set ::summaryinfo [UTF::update_report_add $::summaryinfo $STA ""\
            "" "" $id $notes $status]

            UTF::Try "Image loading on $STA" {
                $STA load
            }
            # Update report header table with actual OS and HW versions.
            set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]
            # Update report title with actual TAG numbers.
            UTF::update_report_title $STA
		};# if !noload
        };# foreach STA
    };# Try Image loading on STAs 

	UTF::Try "+" {
        set assocSTAs {}
		# Associate all STAs
		foreach STA $STAs attn $attns {
		UTF::Try "$(ap) $STA Connection Over $chanspec" {

            UTF::Message INFO "$STA" "Set $STA attenuation to $attn"
			set attngrp [$STA cget -attngrp]
			if {$attngrp eq ""} {
			    UTF::Message WARNING "" "Attenuation group not found for $STA"
			} else {
			    catch {$attngrp attn $attn}
            }
			catch {$STA wl -u disassoc}

			#STA can be PSTA as well
			if {[$STA hostis Router]} {
			    package require UTF::Test::ConfigBridge
			    UTF::Test::ConfigBridge -ap $(ap) -br $STA -chanspec $chanspec -linkcheck -proxysta
			} else {
			    for {set i 1} {$i < 4} {incr i} {
			        UTF::Message INFO "$STA" "Association Try: $i" 
                    if {![catch {UTF::Test::ConnectAPSTA $(ap) $STA -chanspec $chanspec}]} {
                        break
                    }
                }
			}
            if {$i == 4} {
                error "$STA could not associate to $(ap)"
            }
			catch {$(ap) cget -device}
		    $(ap) wl -u status
		    $(ap) wl -u assoclist 
            lappend assocSTAs $STA
			$STA wl -u status
            set rn [UTF::Test::rssinoise $(ap) $STA -chanspec $chanspec -security $(security)]
            if {[regexp -line {RSSI:\s+(-?[\d]+)\s+dBm} [$STA wl_escanresults] - rssi]} {
                set lrssi "$STA: AP<->STA RSSI=$rn, STA Scan RSSI=$rssi, ch${chanspec}"
            } else {
                set lrssi "$STA: AP<->STA RSSI=$rn, STA Scan RSSI=N/A, ch${chanspec}"
            }              
            };# UTF::Try Connection
        };#foreach STA

        if {[llength $assocSTAs]} {
		set graphtitle "Add Title" 

        #divide up the rate between the streams
        set sRate [expr [rate2numeric $(rate)]/[llength $assocSTAs]]

        foreach STA $assocSTAs ttype $ttypes protocol $protocols direction $directions {
		UTF::Try "$STA $protocol $ttype $direction stream generation" {

		    set msg " [string toupper $protocol] [string toupper $direction] CHAN $chanspec \\n"

		    if {[regexp -nocase "udp" $protocol]} {
			append msg " (per stream tx=$sRate)"
			append msg " pktsize=$(pktsize) \\n"
		    }
		    set graphtitle $msg

			$STA wl status
			$STA wl -u rssi
			$STA wl -u dump rssi

			if {[regexp -nocase "UP" $direction]} {
			    set src $STA
			    set dst $(ap)
			} else {
			    set src $(ap)
			    set dst $STA
			}

			append msg "$src -> $dst \\n"

			#get tcp window size
			set tcpwindow [$STA cget -tcpwindow]
			if {$tcpwindow eq ""} {
			    set tcpwindow 2M
			}

			if {$(fb)} {$src wl frameburst 1}
			# UTF::stream will auto increment the destination
			# port amongst other things.
            UTF::stream logginglevel ANALYZE; # Not interested in data

            switch -exact -- $ttype {
                VIDEO -
                VI {set tt 0x80}
                VOICE -
                VO {set tt 0xC0}
                BACKGROUND -
                BK {set tt 0x20} 
                BESTEFFORT -
                BE {set tt 0x00} 
                default {
                    error "Unsupported traffic type: '$ttype'"
                }
            }

			if {[regexp -nocase "tcp" $protocol] && $(notcprate)} {
			    set traffic(${STA}$ttype) [UTF::stream %AUTO% -rx $dst -tx $src -pktsize $(pktsize) \
					 -w $tcpwindow -protocol [string tolower $protocol] \
					 -reportinterval $(reportinterval) -txnulldetect 1 -tos $tt \
					 -name ${src}-${dst}-$protocol-$direction -txstart_timeout 5000]
			    set sid [$traffic(${STA}$ttype) id]
			} else {
			    set traffic(${STA}$ttype) [UTF::stream %AUTO% -rx $dst -tx $src -pktsize $(pktsize) \
					 -rate $sRate -protocol [string tolower $protocol] \
					 -reportinterval $(reportinterval) -txnulldetect 1 -tos $tt \
					 -name ${src}-${dst}-$protocol-$direction -txstart_timeout 5000]
			    set sid [$traffic(${STA}$ttype) id]
			}
            return "Stream id: $sid" 
        };# Try stream generation

        if {[catch {\
	    set params [$(ap) cget -rvrnightly]
	    UTF::Getopts {
		{mumode.arg "su" "mu mode, su/mu (default su)"}
	    } "AP options:" params 
	    set mumode $(mumode)
	    UTF::Message INFO "" "ap=$(ap) mumode=$mumode"

        UTF::Record "Verify $(ap) is in $mumode mode" {
            set dump [$(ap) [$(ap) cget -wl] dump mutx] 
            if {[string trim $dump] eq "N/A"} {
                return "Build is external.  Skipping MU feature status check."
            } elseif {![regexp -line -- {MU feature is ([a-zA-Z]+), mutx is ON} $dump - state]} {
                throw FAIL "Could not get MU feature status"
            }
            switch -nocase -- $mumode {
                SU {
                    if {![string match "off" [string tolower $state]]} {
                        
                        throw FAIL "Expected MU feature is OFF, but it is $state"
                    }
                }
                MU {
                    if {![string match "on" [string tolower $state]]} {
                        throw FAIL "Expected MU feature is ON, but it is $state"
                    }
                }
                default {
                    throw FAIL "Unsupported AP mode: $mumode"
                }
            };# switch
            return "MU feature is $state as expected"
        }
        } errMsg]} {
            UTF::Message ABORT $(ap) $errMsg 
            exit
        }

		UTF::Try "Iperf cleans" {
		    UTF::Streamslib::force_cleanup "$(ap) $STA" 
		}
        };# foreach STA

        set testplots ""
		UTF::Try "AC Test for $ttypes" {
            if 1 {
		    foreach dut "$(ap) $assocSTAs" {
                foreach cmd [$dut cget -pre_perf_hook] {
                    if {[catch [string map [list %S $dut] $cmd] ret]} {
                        UTF::Message WARN $dut $ret
                    }
                }
            }
            };#if 0

            set reinitCnt 0
            catch {incr reinitCnt [getDumps $(ap)]}
            foreach STA $assocSTAs {
                catch {getSTAdumps $STA}
            }
		    UTF::stream allstreams start
		    if {[catch {UTF::stream allstreams start}]} {
                UTF::Break "stream start"
            }
            catch {rate destroy}
		    UTF::StreamStatAggregate rate 
		    UTF::stream allstreams stats -rate -clear 
		    UTF::stream allstreams start
		    rate clear
            
            # Do scan if requested
            if {[llength $(scaninterval)]} {
            UTF::Message INFO lan "Start broadcast ping"
            set lanHdl [lan rexec -async -T 245 -t 245 ping -c 245 -b 192.168.1.255]
            UTF::Message INFO lan "ping pid: [$lanHdl pid]" 
            set i 0
            set loopCnt 0
            set duration 0
            foreach STA $assocSTAs{
                incr loopCnt 10
                incr duration 60
                UTF::Message INFO "$STA" "Start scanning on $STA"
                set staHdl$i [$STA rexec -async -t $duration "i=0; while \[ \$i -lt $loopCnt \];do\
                wl scan;echo $STA scan \$i;sleep $(scaninterval); let i++; done"]
                UTF::Sleep 60
                incr i
            }
            };# scaninterval
            set tstop [expr $(duration)+[clock seconds]]
            while {[clock seconds] <= $tstop} {
                catch {incr reinitCnt [getSmallDumps $(ap)]}
                UTF::Sleep 9 
            } 

		    UTF::stream allstreams stop
		    rate stop

            catch {incr reinitCnt [getDumps $(ap)]}
            foreach STA $assocSTAs {
                catch {getSTAdumps $STA}
            }
            
            set testplots [rate plot -title "Aggregate $msg" -graphsize $(graphsize)]

            set mmm [rate stats -meanminmax]
		    catch {CC destroy}
            set mykey "ACtraffic $(ap) [$(ap) branchname] [$(ap) cget -brand] $chanspec\
            $protocol $direction $ttypes" 
		    UTF::ControlChart CC -key $mykey -history $(history) -allowzero true\
            -norangecheck true -title "$(ap) Aggregate Throughput" -units "bs"
    		set ccVal [CC addsample $mmm]
		    set ccplot [CC plotcontrolchart $ccVal]
            set testresults $ccplot
            set aggMean [lindex $mmm 0] 
            set mmmHuman [UTF::stream hformat $aggMean] 
            UTF::Message INFO "" "Aggregate Tput=$mmmHuman, reinit Cnt=$reinitCnt"
            append testresults ", Aggregate Tput=$mmmHuman, reinit Cnt=$reinitCnt"

		    foreach dut "$(ap) $assocSTAs" {
                foreach cmd [$dut cget -post_perf_hook] {
                    if {[catch [string map [list %S $dut] $cmd] ret]} {
                        UTF::Message WARN $dut $ret
                    }
                }
		    }

            catch {rate destroy}
            
            if {[llength $(scaninterval)]} {
                set i 0
                foreach STA $assocSTAs {
                    [set staHdl$i] kill
                    catch {[set staHdl$i] close}
                    incr i
                }
                $lanHdl kill
                catch {$lanHdl close}
            }

		    if {[regexp {(HIGH|LOW|WIDE|ZERO)} $ccVal]} {
		        throw FAIL $testresults
		    } else {
                return $testresults
            }

		};# Try AC  

        UTF::Try "+Throughput report for $ttypes" {
            foreach STAT $(stats) {
                set sg($STAT) [UTF::streamgraph %AUTO% -title $graphtitle -stat $STAT\
                -graphsize $(graphsize)]
            }

            foreach STAT $(stats) {
                append testplots [$sg($STAT) plot -append]
            }
            return $testplots
        };# Try Throughput 

        foreach STA $assocSTAs ttype $ttypes protocol $protocols direction $directions {
            set results {}
            set ccres {}
            UTF::Try "+$STA Control Chart" {
                set mykey "ACtraffic $ttype $STA $(ap) [$(ap) branchname] [$(ap) cget -brand] $chanspec \
                $protocol $direction [concat {*}$(ttypelist)] [concat {*}$(protolist)]" 
                append results "[$traffic(${STA}$ttype) controlchart -stat rate -history $(history) -key $mykey] "
                append ccres [$traffic(${STA}$ttype) getcctests rate]
                if {[regexp {(PASS|PASSPASS)} $ccres]} {
                    return $results
                } else {
                    throw FAIL $results
                }
            }
        };# foreach STA

        catch {UTF::stream allstreams destroy}
        };# assoc STAs 
	} finally {
	    catch {UTF::stream exitstreams}

	    if {!$(nocleanup)} {
		foreach STA [join $(stalist)] {
		    catch {$STA wl disassoc}
		    catch {$STA unload}
        }
	    }
    }
    };#foreach stalist
    };#imageLoaded
    };#WrapSummary
}
