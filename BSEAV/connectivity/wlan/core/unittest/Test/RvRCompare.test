#!/bin/env utf
# -*-tcl-*-

# Generic RvR Compare
#
# Written by: Robert J. McMahon Feb 2013
#
# $Id$
#

package require UTF
package require UTF::FTTR
package require UTF::ControlChart

UTF::Test RvRCompare {args} {
    UTF::Getopts {
	{ap.arg "" "AP"}
        {sta.arg "" "STA"}
	{refsta.arg "" "Reference STA"}
	{loop.arg "5" "Number of runs"}
	{ramp.arg "down/up" "ramp type"}
	{chanspec.arg "36/80" "Chanspec to test"}
	{security.arg "open" "Security to configure"}
	{protocol.arg "tcp" "IP protocol(s) to use (tcp udp)"}
	{roamtrigger.arg "-100" "Roam trigger (default set to -100 for no roaming)"}
	{key.arg "" "User provided portion of key for control charts"}
	{noframeburst "" "Disable frameburst"}
	{scansuppress "Scan suppress setting during test run"}
	{nophycal "" "Disable phycal watchdog"}
	{nosetup "Don't call SetupTestBed"}
	{startattn.arg "" "Initial value for attenuator"}
	{title.arg "" "Report title"}
	{email.arg "" "Email Address"}
	{pktsize.arg "1460" "UDP packet size"}
	{w.arg "4M" "Socket window size"}
	{history.arg "30" "CC history"}
	{direction.arg "up down" "Traffic direction"}
    }
    proc load_wheader_update {args} {
	UTF::Getopts {
	    {dut.arg "" "Device under test to load"}
	    {norestoredefaults ""}
	}
	if {[$(dut) hostis Router]} {
	    set Router $(dut)
	    UTF::Try "[$Router cget -name]: Find Router Image" {
		set date [$Router cget -date]
		if {$date eq ""} {
		    set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		}
		UTF::CheckImage $Router $date unknown
	    }
	    UTF::Try "[$Router cget -name]: Load Image" {
		$Router load
	    }
	    if {!$(norestoredefaults)} {
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
	       }
	    }
	    UTF::Try "Router version" {
		set what [$Router whatami]
		# Pull out chip info and replace whitespace to
		# make it easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $Router $ret
		}
		set what
	    }
	} else {
	    set STA $(dut)
	    UTF::Try "[$STA cget -name]: Find STA Image" {
		set date [$STA cget -date]
		if {$date eq ""} {
		    set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		}
		UTF::CheckImage $STA $date unknown
	    }
	    UTF::Try "[$STA cget -name]: load" {
		$STA load
	    }
	    UTF::Try "[$STA cget -name]: defaults" {
		$STA wl ver
		set what [$STA whatami]
		# Pull out chip info and replace whitespace to
		# make it easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $STA $ret
		}
		set what
	    }
	}
    }
    proc configure_test_parms {} {
	upvar {} {}
	if {$(noframeburst)} {
	    set fb 0
	} else {
	    set fb 1
	}
	if {$(scansuppress)} {
	    set ss 1
	} else {
	    set ss 0
	}
	if {$(roamtrigger) eq ""} {
	    set rt "default"
	} else {
	    set rt $(roamtrigger)
	}
	UTF::Try "Config (wl) FB=$fb Roam=$rt SS=$ss" {
	    set failmsg {}
	    foreach dut [concat $(ap) $(sta)] {
		if {[catch {$dut wl frameburst $fb} err]} {
		    UTF::Message ERROR $dut "wl frameburst: $err"
		    lappend failmsg "FB${dut}=$err"
		}
		if {$(nophycal)} {
		    catch {$dut wl phy_watchdog 0}
		}
	    }
	    if {[catch {$(sta) wl scansuppress $ss} err]} {
		UTF::Message ERROR $(sta) "wl scansuppress: $err"
		lappend failmsg "SS($(sta))=$err"
	    }
	    if {[catch {$(sta) wl roam_trigger $rt all} err]} {
		UTF::Message ERROR $(sta) "wl roamtrigger: $err"
		lappend failmsg "RT($(sta))=$err"
	    }
	    if {$failmsg ne ""} {
		error $failmsg
	    } else {
		return
	    }
	}
    }
    set (protocol) [string toupper $(protocol)]
    set (direction) [string toupper $(direction)]
    set ref $(refsta)
    set cand $(sta)
    if {[$(sta) hostis Router]} {
	set Routers [concat $(ap) $(sta)]
	set STAS {}
    } else {
	set Routers $(ap)
	set STAS $(sta)
    }
    if {$(title) eq "" && $(sta) ne ""} {
	set sta [lindex $(sta) 0]
	if {[$sta hostis WinDHD Cygwin]} {
	    set (title) [$sta host whatami]
	} elseif {[$sta hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$sta hostis]
	}
	if {[regexp {(\d+sd)} $(ap) - c]} {
	    append (title) " with $c AP"
	}
    }
    set a [$(sta) cget -tag]
    if {$a eq "NIGHTLY"} {
	set a "TOT"
    } else {
	regsub {^[^_]+_(?:{?(?:REL|BRANCH|TWIG)(?:,(?:REL|BRANCH|TWIG))?}?)_} \
	    $a {} b
	regsub {{,_\*}|{_\*,}} $b {} a
    }
    set b [$(refsta) cget -tag]
    if {$b eq "NIGHTLY"} {
	set b "TOT"
    } else {
	regsub {^[^_]+_(?:{?(?:REL|BRANCH|TWIG)(?:,(?:REL|BRANCH|TWIG))?}?)_} \
	    $b {} b
	regsub {{,_\*}|{_\*,}} $b {} b
    }
    set TITLE "UTF RvRCompare $(chanspec) $(title) ($a, w/${b})"
    UTF::Message INFO "" $TITLE
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	if {[info exists ::UTF::SetupTestBed]  && !$(nosetup)} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
		foreach dut [concat $(ap) $(sta)] {
		    if {[catch {$dut wl ver}]} {
			$dut load
		    } else {
			catch {$dut wl up}
		    }
		}
	    }
	}
	UTF::Try "Discover Attn" {
	    if {[catch {[$(sta) cget -attngrp] attn?} res]} {
		if {[catch {[$(ap) cget -attngrp] attn?} res]} {
		    error "must configure attngrp for either $(sta) or $(ap)"
		} else {
		    set attngrp [$(ap) cget -attngrp]
		}
	    } else {
		set attngrp [$(sta) cget -attngrp]
	    }
	    if {$(startattn) ne ""} {
		set startattn $(startattn)
	    } else {
		set startattn [expr {int([lindex $res 0])}]
	    }
	}
	foreach DUT [concat $Routers $(refsta)] {
	    load_wheader_update -dut $DUT -norestoredefaults
	}
	#
	# Instantiate all of the fttr objects
	#
	foreach protocol $(protocol) {
	    foreach d $(direction) {
		set pabbrev [string tolower [string index $protocol 0]]
		for {set ix 0} {$ix < $(loop)} {incr ix} {
		    UTF::FTTR  ${(refsta)}_${pabbrev}_${d}_$ix -ap $(ap) -sta $(refsta) -protocol $protocol -ramp $(ramp) -startattn $startattn -security $(security) -chanspec $(chanspec) -pktsize $(pktsize) -name $(refsta) -w $(w) -direction $d -attngrp $attngrp
		    UTF::FTTR ${(sta)}_${pabbrev}_${d}_$ix -ap $(ap) -sta $(sta) -protocol $protocol -ramp $(ramp)  -startattn $startattn -security $(security) -chanspec $(chanspec) -pktsize $(pktsize) -name $(sta) -w $(w) -direction $d -attngrp $attngrp
		}
	    }
	}
	#
	# Load the reference image
	#
	configure_test_parms
	if {![info exists attnsteps]} {
	    #
	    # Auto discover the attenuator range
	    # o  Start is the current attenuator value
	    # o  End is the attenuation that causes no beacons
	    #
	    UTF::Try "Discover beacon loss" {
		UTF::FTTR rxb -ap $(ap) -sta $(refsta) -protocol TCP -startattn $startattn -security $(security) -chanspec $(chanspec) -attngrp $attngrp
		set attnsteps [rxb discover_norxbeacon]
		rxb destroy
		return "$attnsteps"
	    }
	}
	set GTITLE "Ch=$(chanspec) Attn:${startattn}-[expr {$startattn+$attnsteps}] dwell=[${ref}_${pabbrev}_${d}_0 cget -holdtime]s"
	foreach protocol $(protocol) {
	    foreach d $(direction) {
		set pabbrev [string tolower [string index $protocol 0]]
		for {set ix 0} {$ix < $(loop)} {incr ix} {
		    ${ref}_${pabbrev}_${d}_$ix configure -title "${ref}_${pabbrev} ($ix) ${protocol}($d) $GTITLE" -steps $attnsteps
		    ${cand}_${pabbrev}_${d}_$ix configure -title "${cand}_${pabbrev} ($ix) ${protocol}($d) $GTITLE" -steps $attnsteps
		}
	    }
	}
	#
	# Run the fttrs on the reference
	#
	foreach protocol $(protocol) {
	    set pabbrev [string tolower [string index $protocol 0]]
	    foreach d $(direction) {
		set good_fttrs {}
		UTF::Try "REF: ${ref} ${protocol}($d) Attn:${startattn}-[expr {$startattn+$attnsteps}]" {
		    for {set ix 0} {$ix < $(loop)} {incr ix} {
			UTF::Try "run = $ix" {
			    set REFRESULTS(${ix},${d},$protocol) [${ref}_${pabbrev}_${d}_$ix run]
			    lappend good_fttrs "${ref}_${pabbrev}_${d}_$ix"
			    return $REFRESULTS(${ix},${d},$protocol)
			}
		    }
		    set fexpected($protocol,$d) [UTF::FTTR compute_fexpected -fttrs $good_fttrs]
		    return [${ref}_${pabbrev}_${d}_0 plot -expected]
		}
	    }
	}
	#
	# Load the image to be compared against the reference
	#
	load_wheader_update -dut $(sta) -norestoredefaults
	configure_test_parms
	#
	# Run the fttrs on the candidate
	#
	foreach protocol $(protocol) {
	    set pabbrev [string tolower [string index $protocol 0]]
	    foreach d $(direction) {
		set res {}
		UTF::Try "${cand} ${protocol}($d) Attn:${startattn}-[expr {$startattn+$attnsteps}]" {
		    for {set ix 0} {$ix < $(loop)} {incr ix} {
			UTF::Try "run = $ix" {
			    #
			    # Set the expected FTTR function to be used during
			    # any numerical analysis such as MISE calculations
			    #
			    if {[info exists fexpected($protocol,$d)]} {
				${cand}_${pabbrev}_${d}_$ix setfexpected $fexpected($protocol,$d)
			    }
			    set CANDRESULTS(${ix},${d},$protocol) [${cand}_${pabbrev}_${d}_$ix run]
			    return $CANDRESULTS(${ix},${d},$protocol)
			}
			if {[info exists CANDRESULTS(${ix},${d},$protocol)]} {
			    if {$res eq {}} {
				set res $CANDRESULTS(${ix},${d},$protocol)
			    } else {
				append res " [string range $CANDRESULTS(${ix},${d},$protocol) 5 end]"
			    }
			}
		    }
		    return $res
		}
	    }
	}
	foreach protocol $(protocol) {
	    foreach d $(direction) {
		set mise {}
		set pabbrev [string tolower [string index $protocol 0]]
		UTF::Try "MISE ${protocol}($d) " {
		    for {set ix 1} {$ix < $(loop)} {incr ix} {
			lappend mise [${cand}_${pabbrev}_${d}_$ix mise]
		    }
		    set cc [UTF::ControlChart %AUTO% -s 5 -key "mise $protocol [${cand}_${pabbrev}_${d}_0 id]" -history  $(history) -perfcache "" -norangecheck 1 -title "MISE" -units ""]
		    set boundsresults [$cc addsample [UTF::MeanMinMax $mise]]
		    set plots($protocol) [$cc plotcontrolchart "$boundsresults"]
		    $cc destroy
		    return $plots($protocol)
		}
	    }
	}
	UTF::Try "Exit" {
	    foreach FTTR [UTF::FTTR info instances] {
		$FTTR destroy
	    }
	}
    }
}
