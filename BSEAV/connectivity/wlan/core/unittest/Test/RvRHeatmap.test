#!/bin/env utf
# -*-tcl-*-

# UTF test script for testing multista
#
#
# $Id$
# $Copyright Broadcom Corporation$
#

package require UTF
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::Test::Join
package require UTF::Multiperf
package require UTF::Heatmap

UTF::Test RvRHeatmap {AP STA args} {

    # No point unless we have a log file.
    if {$UTF::Logfile eq ""} {
	regsub {/} "test_$STA.log" {.} UTF::Logfile
    }

    regsub {/} $STA {.} file

    # Pick defaults based on STA capabilities
    UTF::Getopts [subst {
	{i.arg 0.3 "Iperf Interval"}
	{t.arg 0.9 "Iperf test time"}
	{samples.arg 1 "dump samples"}
	{group.arg "[lindex [concat \
				[$STA cget -attngrp] [$AP cget -attngrp]] 0]" \
	     "Attenuator group"}
	{attn.arg "0-103" "Attenuator values"}
	{chanspec.arg "36/80" "Chanspec"}
	{frameburst.arg [expr {![$STA cget -noframeburst]}] "Frameburst"}
	{window.arg [$STA cget -tcpwindow] "TCP Window size"}
	{title.arg "" "Report title"}
	{scansuppress "Suppress scans during test run"}
	{b.arg "[$STA cget -udp]"
	    "UDP data rate (0 for TCP) defaults to -udp option of dut"}
	{roam_trigger.arg "-100" "Override roam_trigger"}
    }]

    set (attn) [UTF::Numexpand $(attn)]

    set title "$STA RvR Chanspec $(chanspec)"
    if {$(title) ne ""} {
	append title " $(title)"
    }

    if {$(group) eq ""} {
	error "Attenuation group not specified in config or commandline"
    }
    set aoff [lindex $(attn) 0]
    $(group) attn $aoff

    set tputfile [open "${file}_tput.csv" w]
    set rateheatmap [UTF::Heatmap %AUTO% -file ${file}_rate.csv -title "Rate"]
    set perheatmap [UTF::Heatmap %AUTO% -file ${file}_per.csv -title "PER" \
			-pad -1 \
			-palette {-1 "black", 0 "white", 50 "yellow", 100 "red"}]
    set denheatmap [UTF::Heatmap %AUTO% -file ${file}_den.csv -title "AMPDUdens"]
    set fbheatmap [UTF::Heatmap %AUTO% -file ${file}_fb.csv -title "Frameburst"]
    set sduheatmap \
	[UTF::Heatmap %AUTO% -file ${file}_amsdu.csv -title "AMSDUdens"]

    $AP wl frameburst $(frameburst)
    $STA wl frameburst $(frameburst)
    $STA wl roam_trigger $(roam_trigger) [$AP band $(chanspec)]
    ConnectAPSTA $AP $STA -chanspec $(chanspec) -security open

    set parm(window) $(window)
    set parm(chanspec) $(chanspec)
    set parm(fb) $(frameburst)
    set parm(title) $title
    if {$(b) ne "0"} {
	set parm(udp) 1
    }

    if {$parm(window) eq "auto"} {
	set parm(window) [$STA tcpautowindow]
    }

    # Give the first test more time to settle since we may have just
    # changed the attenuation a long way.
    set settletime 6

    set ix 0

    foreach parm(attn) $(attn) {
	$(group) attn $parm(attn)

	# pretest to settle rates, etc
	UTF::Multiperf [list $STA $AP] -b $(b) -i 2 \
	    -t $settletime -w $parm(window) -noping
	set settletime 2

	# No point trying performance test if we're already roaming
	if {[$STA wl bssid] eq "00:00:00:00:00:00"} {
	    continue
	}
	for {set j 0} {$j < $(samples)} {incr j} {
	    lappend xlist $parm(attn)

	    # Clear stats
	    $STA wl ampdu_clear_dump
	    $STA wl amsdu_clear_counters

	    set cmd [list UTF::Multiperf [list $STA $AP] \
			 -b $(b) -i $(i) -t $(t) \
			 -w $parm(window) -noping]

	    foreach ret [eval $cmd] {
		UTF::XPASS $AP $ret [UTF::ParmStrip parm]
		puts $tputfile "$ix, $ret"
	    }

	    set pdump [$STA wl_dump_ampdu]

	    set ratehist [$pdump TXVHTs%]
	    set den [$pdump MPDUdens%]
	    set per [$pdump VHTPER%]
	    set fb [$pdump Frameburst%]
	    $pdump destroy

	    set sdump [$STA wl_dump_amsdu]
	    set sdu [$sdump TxMSDUdens%]
	    $sdump destroy


	    $rateheatmap add $parm(attn) $ratehist
	    $perheatmap add $parm(attn) $per
	    $denheatmap add $parm(attn) $den
	    $fbheatmap add $parm(attn) $fb
	    $sduheatmap add $parm(attn) $sdu

	    incr ix
	}

	flush $tputfile

	set xtics ""
	set i 0
	set interval [expr {[llength $xlist] / 10}]
	foreach a $xlist {
	    if {$interval == 0 || $i % $interval == 0} {
		lappend xtics "'$a' $i"
	    }
	    incr i
	}

	set srytic ""
	set names [$rateheatmap names]
	foreach i [dict keys $names] {
	    if {$i % 4 == 2} {
		lappend srytic "'[dict get $names $i]' $i"
	    }
	}

	set rytic ""
	set names [$perheatmap names]
	foreach i [dict keys $names] {
	    if {$i % 2 == 1} {
		lappend rytic "'[dict get $names $i]' $i"
	    }
	}

	# Plot
	set G [open "$file.plot" w]
	puts $G {set terminal png size 1280,1280 truecolor}
	puts $G "set output \"$file.png\""

	puts $G {set key above}
	puts $G {set datafile separator ","}
	puts $G "set multiplot layout 3,2 title \"$parm(title)\""
	puts $G "set xtics ([join $xtics ,])"
	puts $G {set ytics nomirror}

	# Tput
	puts $G "plot '${file}_tput.csv' axes x1y2 title 'Tput' ls 1, '' axes x1y2 smooth unique notitle ls 1"

	# Prep for heatmaps
	puts $G {unset ylabel}
	puts $G {set autoscale fix}

	# AMPDU
	puts $G {set rmargin 0}
	puts $G [$denheatmap plotscript 8]

	# Rate
	puts $G [$rateheatmap plotscript "([join $srytic ,])"]

	# PER
	puts $G [$perheatmap plotscript "([join $rytic ,])"]

	# Frameburst
	puts $G [$fbheatmap plotscript]

	# AMSDU
	puts $G [$sduheatmap plotscript 1]

	puts $G {unset multiplot}
	puts $G {quit}
	close $G

        # Run gnuplot on plot file.  Catch is needed because gnuplot
        # often writes to stderr.  Report any output even if we think
        # it was ok.
	catch {exec $::UTF::Gnuplot "$file.plot"} ret
	UTF::Message WARN "gnuplot" $ret
    }

    close $tputfile

}

