#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for aci nightly run
# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set wl_commands_help "\n\nBasic usage: Test/wl_commands.test <options>\
    \n\nThis Rate vs Range script will setup your testrig by loading the desired\
    \nbuilds, produce high level summary web pages and calls the script that does\
    \nthe lower level work, aci.test. The script aci.test is called for up to 4\
    \ndifferent channels. Each channel is tested for the upstream and downstream\
    \ntraffic directions.\

    \n\nYou can take complete control of the AP & STA initialization sequence by\
    \nspecifying the variables ::rvr_ap_init and ::rvr_sta_init in your config\
    \nfile. The defaults are defined in aci.test proc get_user_parms. Alternately,\
    \nlook in the RvR logfiles in the Setup AP & STA section to see the defaults.\
    \nFor SoftAP, you can specify the initialization in ::rvr_softap_init. SoftAP\
    \ndefaults to the values from ::rvr_sta_init.\
    \n\nSome people may have more complex initialization needs which depend on the\
    \nSTA talking to a real AP versus a SoftAP, and other variations. So this\
    \ninitialization variable heirarchy is available to allow customization\
    \nfor all devices in the testrig, as well as STA specific customizations:\
    \nFor STA to SoftAP ::rvr_sta_{STA}_to_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_softap_init ::rvr_sta_init\
    \nFor STA to AP     ::rvr_sta_{STA}_to_ap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_ap_init ::rvr_sta_init\
    \nFor SoftAP        ::rvr_sta_{STA}_am_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_softap_init ::rvr_sta_init\
    \nFor AP            ::rvr_ap_{AP}_init ::rvr_ap_init\
    \nIn the above variables, {STA} & {AP} mean the UTF STA name.\
    \nWhen the script looks for the initialization, the list is searched from left\
    \nto right, with the STA specific variable having the highest priority.\
    \nBecause the script knows which AP & STA you are using, and if you specified\
    \nthe -softap option or not, the script can locate and use the appropriate\
    \ninitialization variables without any additional user intervention.\
    \n\nIf you want to use the -warmup option, you can override the default 5Mb/s pass\
    \ncriteria by specifying:\
    \n    set ::rvr_warmup nn\
    \n    Set this parameter to 0 or -1 if you dont want a pass criteria.\
    \n\nTo keep tests from running away for hours at a time, the aci.test script has a\
    \ntime limit of 90 minutes for each rampdown/rampup test. If you want to override\
    \nthe default 90 minute per test timeout value, then specify:\
    \n    set ::rvr_overall_timeout_min mm\
    \n    Set this parameter to 0 or -1 for no timeout, unlimited test run time.\
    \n\nBy default the script will try 1 time to rejoin the AP and STA. This default\
    \ncan be changed in your config file:\
    \n    set ::rvr_rejoin_tries ii\
    \n    The minimum value for this parameter is 1.\
    \n\nBy default, the script will wait 10 seconds after a rejoin attempt. This\
    \ndefault can be changed in your config file:\
    \n    set ::rvr_rejoin_wait_sec jj\
    \n    The minimum value for this parameter is 5.\
    \n\nBy default, the script will perform 3 progressive recovery attempts during the\
    \ntests if things go wrong. This default can be changed in your config file:\
    \n    set ::recovery_max kk\
    \n    Set this parameter to 0 or -1 for no recovery actions.\
    \n\nBy default, the script will stop the rampdown portion of the test after 3\
    \nconsecutive attenuator steps with no beacons. This default can be changed in\
    \nyour config file:\
    \n    set ::rvr_rampdown_nobeacons bb\
    \n    Set this parameter to 0 or -1 to disable this feature.\
    \n\nThe optional -stopslowrampup algorithm is controlled by two parameters, whose\
    \ndefaults are 10 & 1 respectively. These defaults can be changed in your config file:\
    \n    set ::rvr_slowrampup_cnt cc\
    \n    set ::rvr_slowrampup_tput tt\
    \n\nThere may be times that a specific STA needs the router to do something\
    \nspecifically for that STA. You can add STA specific variables to set the\
    \nrouter nvram accordingly in your config file. Dont forget to turn these\
    \nsettings back for theSTAs.\
    \n    set ::mc351_4319USB_rtr_nvram {antswitch=3}\
    \n    set ::mc356_43326USB_rtr_nvram {antswitch=0}\
    \n\nAfter each occasional repeated error attenuator occurs, the attenuator\
    \nrecovery is attempted. If you choose to specify the variable shown below in\
    \nyour config file, your attenuator will be power cycled for you, and the\
    \ncommand retried after the power cycle:\
    \n    set ::rvr_attn_power \"mcxxwsy 1\"\
    \nAfter 3 repeated attenuator errors, the aci.test is halted. Should you\
    \nwish to alter the default 3 attenuator error limit, you may specify the\
    \nvariable shown below in your config file:\
    \n    set ::rvr_attn_max_errors N\
    \n    Set this parameter to 0 or -1 to allow unlimited errors to occur.\
    \n\nThe optional fastrampup test will test 10 samples at the final attenuator\
    \nvalue. You can alter this value by specifying ::rvr_fastrampup_cnt in your\
    \nconfig file. Variable ::rvr_fastrampup_tput controls the thruput at which\
    \nthe fastrampup is made, default is 1 Mb/s.\
    \n\nFor SoftAP tests, the RF wiring on the attenuator needs to be set up to\
    \nattenuate the RF path between the SoftAP and the STA being tested. Most\
    \ntestrigs need to be modified for this to work, as they tend to have a real\
    \nAP connected to the attenuator, not a SoftAP.\
    \n\nFor SoftAP tests, you need to ensure the SoftAP and STAs will get IP\
    \naddresses. A real AP has a built-in DHCP server. If the SoftAP is running\
    \non Linux, you can run dhcpd on the Linux host. You will still need to\
    \nconfigure a static IP address for the SoftAP itself. If the SoftAP does\
    \nnot provide dhcpd, then you must configure static IP addresses for the\
    \nSTA that will be tested. See examples in utfconf/pb4a.tcl & mc49.tcl.\
    \n\nThe AP connect time check looks for drops of 30 seconds or more as\
    \nan indicator of issues. The variable ::rvr_connect_time_drop can be used\
    \nto alter this threshold. Set to -1 to turn off this test.\
    \n\nTrenderrors looks at how many consecutive errors occur as well as total\
    \nerrors in the test. Initially most controlchart tests are shown as PASS,\
    \nexcept for major errors like assert or ping fail. Then, at the end of the\
    \ntests, the trend errors analysis is done and the overall PASS/FAIL criteria\
    \nis determined. Config file variable ::rvr_trend_error_length defaults to 6,\
    \nand is the minimum number of consecutive errors needed to trigger a trend\
    \nerror FAIL. Variable ::rvr_trend_error_max defaults to 18, and is the total\
    \nnumber of errors that can occur, consecutive or not, without causing a FAIL.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set wl_commands_getopts {
	{sta.arg "4325sdio" "sta name"}
	{ap.arg "4704/4318"
	    "AP name.  For simultaneous dualband routers, use a pair '2g 5g'"}
	{trx.arg "" "Router trx"}
	{ap2.arg "" "2nd AP.  May be used for MultiSTA tests, etc"}
	{trx2.arg "" "2nd AP image"}
	{tag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{bin.arg "" "STA dongle image"}
	{email.arg "" "Email Address"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{nostareload "Don't even reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{nojoin "(obsolete)"}
	{nopm1 "No Slow Power Management tests"}
	{nopm2 "No Fast Power Management"}
	{noframeburst "No Framebursting"}
        {nofb0 "No non-frameburst open tests"}
	{noperf20 "Don't do 20MHz performance tests"}
	{noperf40 "Don't do 40MHz performance tests"}
	{noperf80 "Don't do 80MHz performance tests"}
	{nochannels "DEPRECATED: use -nochan"}
	{nosetup "No Setup"}
	{nobtests "Disable Bangalore tests"}
	{nopingtimes "Disable PingTimes test"}
	{norts "Disable RTS tests"}
	{nobeaconratio "Disable BeaconRatio test"}
	{date.arg "" "Image date"}
	{apdate.arg "" "AP Image date"}
	{ap2date.arg "" "AP2 Image date"}
        {history.arg 30 "History size for control charts"}
	{perfloop.arg 1 "Performance test loops"}
	{loop.arg 1 "Main test loops"}
	{nounload "Don't unload driver after test"}
	{nocache "Don't update performance cache"}
	{nowep "No WEP security"}
	{noshared "No shared security"}
	{notkip "No TKIP security"}
	{noaes "No AES security"}
	{noopen "No Open security TCP perf tests"}
	{nobx "No Bidirectional Performance tests"}
	{symmetric "Don't need to test both directions"}
	{notdls "No TDLS tests"}
	{nointerrupts "No Interrupt tests"}
	{title.arg "" "Title"}
	{branch.arg "auto" "Branch override"}
        {logdir.arg "" "Log directory override"}
	{chanspec.arg "" "Override perfchans"}
	{nosetuptestbed "Don't run Setup Testbed hooks"}
	{noposttesthook "Don't run Post Test hooks"}
	{nocpu "No CPU tests"}
	{nochanswitch "No Chan Switch Times test"}
	{paironly "Only run tests involving two STAs"}
	{dual.nonly "Symmetric Dualband tests"}
	{chan.nonly "Channelsweep tests"}
	{custom.nonly "custom tests"}
	{perf.nonly "Performance tests"}
	{rate.nonly "Fixed Rate tests"}
	{rvr.nonly "RvR tests"}
	{pm.nonly "Power Management tests"}
	{ibss.nonly "IBSS tests"}
	{bighammer.nonly "BigHammer tests"}
	{scan.nonly "scan tests"}
	{frag.nonly "fragmentation tests"}
	{cal.nonly "calibration tests"}
	{udp.nonly "UDP performance tests (UDP may still be used for rates/rvr if configured)"}
	{kpps.nonly "KPPS tests"}
	{titleap    "Use AP name in report & graph titles, default is STA name"}
	
}

# Setup online help info.
UTF::setup_help $wl_commands_help $wl_commands_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

package require UTF
package require UTF::Test::APConfigureSecurity
package require UTF::Test::ChannelSweep
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec



package provide UTF::Test::wl_commands 2.0


#============== proc main_wl_commands ==============================
# Proc main_wl_commands does all the STA loading, setup and then
# calls aci1fidha.test foreach STA. Router is loaded elsewhere.
#
# NB: proc is uniquely named to avoid conflict with other scripts
# that have a proc main.
#====================================================================
proc main_wl_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts


	

    # Ensure each STA gets full initialization the first time thru aci1fidha.test
    set ::rvr_init_done 0

    # Find STA image if necessary.
    set id ""
 if {!$(nostaload)} {
	    UTF::Try "$STA Find STA Image" {
		UTF::CheckImage $STA  unknown
	    }
	}

    # Load/reload/setup STA if necessary

    	if {!$(nosetup)} {
	    if {$(nostaload)} {
		if {!$(nostareload)} {
		    UTF::Try "$STA reload" {
			$STA reload
		    }
		}
	    } else {
		
		UTF::Try "$STA load" {
		    $STA load
		    }
		
					
			
		
	    }

	    UTF::Try "$STA defaults" {

		$STA services stop
		catch {$STA wl msglevel +error +assoc +regulatory}
		if {![$STA cget -nomimo_bw_cap]} {
		    catch {$STA wl down}
		    # Enable 40 in 2.4, if available.
		    if {[catch {$STA wl bw_cap 2 -1}]} {
			$STA wl -u mimo_bw_cap 1
		    }
		    $STA wl up
		    UTF::Sleep 1
		}

		$STA wl ver
		set what [$STA whatami]
		# Pull out chip info and replace whitespace to make it
		# easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {$(nostaload)} {
		    $UTF::Summary header $STA $w
		} else {
		    $UTF::Summary header_update 1 $w
		}
		$STA dbrecord DUT
		set what
	    }

	}	


    
	
	

    # Determine which bands are supported by the STA.
    set catch_resp [catch "set sta_bands \[$STA wl bands\]" catch_msg]
    # set catch_resp 1 ;# test code
    if {$catch_resp != 0} {
        UTF::Try "could not get $STA bands" {
            error "halting $STA test: $catch_msg"
        }
        return
    }


    
    

    # aci1fidha.test needs branch name when it calls get_stream.
    lappend ::branch_list [$STA branchname]
    UTF::Message LOG $STA "updated branch_list=$::branch_list"

    
    

    # proc main_wl_commands test loop starts here.
    if {$(titleap)} {
        set focus $Router
    } else {
        set focus $STA
    }
  
	
	
	
UTF::Try "2g_rate" {

UTF::Try "2g" {
	$STA wl 2g_rate
	$STA wl 2g_rate 6
    $STA wl 2g_rate
}
UTF::Try "auto" {
	$STA wl 2g_rate auto
	$STA wl 2g_rate
}
}


UTF::Try "a_rate" {

UTF::Try "arate" {
	$STA wl a_rate 9
	$STA wl a_rate
}


UTF::Try "auto" {
	$STA wl a_rate auto
	$STA wl a_rate
}
}

UTF::Try "5g_rate" {

UTF::Try "5g" {
	$STA wl 5g_rate auto 
	$STA wl 5g_rate
}	

UTF::Try "VHT" {
	$STA wl 5g_rate  -l -v 0x1
	$STA wl 5g_rate 
	$STA wl 5g_rate -l -v 9x2
	$STA wl 5g_rate	
	$STA wl 5g_rate -l -v 9
	$STA wl 5g_rate
}

UTF::Try "Bandwidth" {	
	$STA wl 5g_rate -v 9 -l -b 20
	$STA wl 5g_rate 
	$STA wl 5g_rate -v 9 -l -b 40
	$STA wl 5g_rate 
	$STA wl 5g_rate -v 9 -l -b 80
	$STA wl 5g_rate
}

UTF::Try "stbc" {
	$STA wl 5g_rate -v 9 -l -b 80 --stbc
	$STA wl 5g_rate
}

UTF::Try "sgi" {
	$STA wl 5g_rate -v 9 -l -b 80 --stbc -g
	$STA wl 5g_rate
}

}

UTF::Try "ack_ratio" {
	$STA wl ack_ratio
}

UTF::Try "addwep" {
	$STA wl addwep 0 fidha
	$STA wl keys
}

UTF::Try "remwep" {
	$STA wl rmwep 0 
	$STA wl keys
}

UTF::Try "ampdu" {
	$STA wl down
	$STA wl  ampdu
}

UTF::Try "ampdu_clear_dump" {
	$STA wl  ampdu_clear_dump
}


UTF::Try "ampdu_mpdu" {
	$STA wl ampdu_mpdu 
}


UTF::Try "protocol data unit" {
	$STA wl dump ampdu
}

UTF::Try "amsdu" {
	$STA wl  amsdu
}

UTF::Try "service data unit" {
	$STA wl dump amsdu
}

UTF::Try "antdiv" {
	$STA wl antdiv 3
	$STA wl antdiv
}


UTF::Try "antgain" {
	$STA  wl antgain ag0=7 ag1=5
	$STA  wl antgain
}

UTF::Try "accesspoint" {
 $STA  wl ap 1
 $STA  wl ap
}

UTF::Try "apsta" {
$STA wl down
$STA wl apsta 1 
$STA  wl apsta
}

UTF::Try "active state power management" {
 $STA  wl aspm
}

UTF::Try "assoc_retry_max" {
 $STA  wl assoc_retry_max 1
 $STA  wl assoc_retry_max
}

UTF::Try "band" {
	$STA wl down	
	$STA wl band
}

UTF::Try "band_range" {
	$STA wl band_range
}

UTF::Try "bands" {
	$STA wl bands
}

UTF::Try "bcnlenhist" {
 $STA wl bcnlenhist 0 
 $STA  wl bcnlenhist  
}

UTF::Try "Beacon Interval" {
$STA wl down 
 $STA wl bi 50
 $STA wl bi 
}

UTF::Try "boardflags" {
  $STA wl boardflags
}

UTF::Try "boardflags2" {
  $STA wl boardflags2	
}

UTF::Try "btc_mode" {
	$STA  wl btc_mode
}

UTF::Try "btc_params" {
	$STA wl mpc 0
	$STA wl up
	$STA  wl btc_params 1
}

UTF::Try "bus" {
 $STA  wl bus 0 
 $STA wl bus
}

UTF::Try "bw_cap" {
	$STA  wl band auto  
	$STA  wl bw_cap 2g 
	$STA  wl bw_cap  5g
}


UTF::Try "cap" {
 $STA  wl cap  
}

UTF::Try "channel" {
$STA  wl channel
}

UTF::Try "channels" {
 $STA  wl channels
}

UTF::Try "chanspec" {
   $STA wl chanspec
}

UTF::Try "chanspecs" {
	$STA wl chanspecs
}

UTF::Try "cisdump" {
	$STA wl mpc 0
	$STA wl up
	$STA wl cisdump
}

UTF::Try "ciswrite" {
	$STA wl mpc 0
	$STA wl up
	$STA wl ciswrite
}


UTF::Try "$STA clock" {
  $STA  wl clk 
}

UTF::Try "counters" {
  $STA  wl counters
}

UTF::Try "interference_override" {
 $STA  wl interference_override  
}

UTF::Try "interference" {
 $STA  wl interference  
}

UTF::Try "Join" {
UTF::Test::ConnectAPSTA $Router $STA -security open
}



UTF::Try "Country" {
$STA wl country
}


UTF::Try "Country List" {
$STA wl country list
}

UTF::Try "crsuprs" {
$STA wl down
$STA wl clk 1
$STA wl band b
$STA wl crsuprs 1
}



UTF::Try "current ethernet address" {
	$STA wl cur_etheraddr
}

UTF::Try "current power" {
		catch {$STA wl mpc 0}
		catch {$STA wl up}
		catch {$STA wl isup}
		catch $STA {wl clk}
		catch {$STA wl curpower}
	}

UTF::Try "curppr" {
	$STA wl curppr
}


UTF::Try "device path" {
		$STA wl devpath
}

UTF::Try "disable_percal" {
		$STA wl disable_percal 0
		$STA wl disable_percal
}

UTF::Try "disassoc" {
		$STA wl disassoc
}

UTF::Try "down" {
		$STA wl down
}


UTF::Try "dtim" {
		$STA wl dtim 3
		$STA wl dtim 
}

UTF::Try "pcieinfo" {
	$STA wl dump pcieinfo 
}

UTF::Try "phyaci" {
	$STA wl dump phyaci 
}

UTF::Try "phycal" {
	$STA wl up
	$STA wl dump phycal  
}  	

UTF::Try "phych4rpcal" {
	$STA wl mpc 0
	$STA wl up
	$STA wl dump phych4rpcal    
}

UTF::Try "rsdb" {
    $STA wl dump rsdb 
}

UTF::Try "rssi" {
	$STA wl dump rssi       
}

UTF::Try "txbf" {
	$STA wl dump txbf 
}


UTF::Try "evm" {
	$STA wl down
	$STA wl clk 1
	$STA wl band b
	$STA wl evm 1 5.5
}
	 
UTF::Try "fast_timer" {
	$STA wl fast_timer 
}


UTF::Try "fem" {
	$STA wl fem 
}

UTF::Try "fqacurcy" {
	$STA wl down
	$STA wl clk 1
	$STA wl band b
	$STA wl fqacurcy 1
}


UTF::Try "frameburst" {
	$STA wl frameburst 1	
	$STA wl frameburst
}

UTF::Try "getPaParamNameIdPair" {
	$STA wl getPaParamNameIdPair
}

UTF::Try "glacial_timer" {
	$STA wl glacial_timer
	catch {$STA wl glacial_timer=15000}
}

UTF::Try "gmode" {
	$STA wl gmode
}

UTF::Try "gmodeauto" {
	$STA wl gmode auto
}

UTF::Try "hw_rxchain " {
	$STA wl hw_rxchain 
}

UTF::Try "hw_txchain " {
	$STA wl hw_txchain 
}

UTF::Try "ibss_gmode" {
	$STA wl ibss_gmode -1
	$STA wl ibss_gmode  
}

UTF::Try "iscan_s " {
	$STA wl mpc 0
	$STA wl up 
	$STA wl isup 
	$STA wl iscan_s 
}

UTF::Try "iscanresults" {
	$STA wl iscanresults 
}

UTF::Try "isup" {
	$STA wl isup 
}

UTF::Try "ldpc_cap" {
	$STA wl ldpc_cap 1
	$STA wl ldpc_cap
}

UTF::Try "legacylink" {
	$STA wl legacylink 1
	$STA wl legacylink
}


UTF::Try "list" {
	$STA wl list
}

UTF::Try "longpkt" {
	$STA wl mpc 0
	$STA wl up
	$STA wl longpkt
}

UTF::Try "longtrain" {
	$STA wl down
	$STA wl clk 1
	$STA wl band b
	$STA wl longtrain 1
}

UTF::Try "lrl" {
	$STA wl lrl 6
	$STA wl lrl
}

UTF::Try "manfinfo" {
	$STA wl manfinfo
}

UTF::Try "maxpower" {
	$STA wl maxpower
}

UTF::Try "mbss" {

	$STA wl down 
	$STA wl mbss 0
	$STA wl mbss 

}
 
UTF::Try "mimo_bw_cap" {
	$STA wl mimo_bw_cap 
}

UTF::Try "mimo_preamble" {
	$STA wl down
	$STA wl mimo_preamble  
}


UTF::Try "mimo_ss_stf" {
	$STA wl mimo_ss_stf 1
	$STA wl mimo_ss_stf  
}

UTF::Try "mimo_txbw" {
	$STA wl mimo_txbw -1
	$STA wl mimo_txbw 
}

UTF::Try "monitor" {
	$STA wl monitor
}

UTF::Try "mpc" {
	$STA wl mpc
}

UTF::Try "napping_mode" {
	$STA wl napping_mode
}

UTF::Try "nmode" {
	$STA wl down
	$STA wl nmode
}

UTF::Try "noise" {
	$STA wl noise
}

UTF::Try "nrate" {
	$STA wl nrate
}

UTF::Try "nvram_dump" {
	$STA wl nvram_dump
}

UTF::Try "nvram_source" {
	$STA wl nvram_source
} 

UTF::Try "obss_coex " {
	$STA wl obss_coex 
}

UTF::Try "otpdump " {
	$STA wl otpdump 
}

UTF::Try "otplock " {
	$STA wl otplock 
}

UTF::Try "otpw" {
$STA wl otpw 
}

UTF::Try "out" {
	$STA wl down
	$STA wl out
}

UTF::Try "patrim" {
	$STA wl mpc 0
	$STA wl up
	$STA wl patrim 
}

UTF::Try "pavars" {
	$STA wl pavars
}

UTF::Try "phy_activecal" {
	$STA wl mpc 0 
	$STA wl up
	$STA wl phy_activecal
}

UTF::Try "phy_antsel" {
	$STA wl phy_antsel 
}

UTF::Try "phy_bphy_evm " {
	$STA wl phy_bphy_evm 1
	$STA wl phy_bphy_evm
}

UTF::Try "phy_bphy_rfcs " {
	$STA wl phy_bphy_rfcs 1
	$STA wl phy_bphy_rfcs 
}

UTF::Try "phy_est_power" {
	$STA wl phy_est_power
}

UTF::Try "phy_fixed_noise" {
	$STA wl phy_fixed_noise
}

UTF::Try "phy_forcecal" {
    $STA wl mpc 0
	$STA wl up
	$STA wl phy_forcecal 1
	$STA wl phy_forcecal
}

UTF::Try "phy_forceimpbf" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_forceimpbf 1
	$STA wl phy_forceimpbf
}

UTF::Try "phy_forcesteer" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_forcesteer 1
}

UTF::Try "phy_idletssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_idletssi 
}
	
UTF::Try "phy_percal" {
	$STA wl phy_percal 3  
} 


UTF::Try "phy_rssi_ant" {
	$STA wl phy_rssi_ant
}

UTF::Try "phy_rxant_config" {
	$STA wl phy_rxant_config
}


UTF::Try "phy_rxgainerr" {
	$STA wl phy_rxgainerr
}

UTF::Try "phy_rxiqest" {
	$STA wl phy_rxiqest
}

UTF::Try "phy_scraminit" {
	$STA wl phy_scraminit
}

UTF::Try "phy_setrptbl" {
	$STA wl phy_setrptbl 1
	$STA wl phy_setrptbl 
}


UTF::Try "phy_sromtempsense" {
	$STA wl phy_sromtempsense   
}

UTF::Try "phy_tempsense" {
	$STA wl phy_tempsense
}

UTF::Try "phy_test_idletssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_test_idletssi 0
}


UTF::Try "phy_test_tssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_test_tssi 45
}

UTF::Try "phy_txant_config" {
	$STA wl phy_txant_config
}


UTF::Try "phy_txpwrctrl" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_txpwrctrl 1
	$STA wl phy_txpwrctrl 
}

UTF::Try "phy_txpwrindex" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_txpwrindex 
}


UTF::Try "phy_txrx_chain" {
	$STA wl phy_txrx_chain 
}

UTF::Try "phy_watchdog" {
	$STA wl phy_watchdog
}


UTF::Try "phyreg for band a" {
    $STA wl mpc 0
	$STA wl up
	$STA wl isup
    $STA wl phyreg 1 a
}
UTF::Try "phyreg for band b" {
    $STA wl mpc 0
	$STA wl up
	$STA wl isup
    $STA wl phyreg 1 b
}
 
UTF::Try "phytype" {
	$STA wl phytype
}


UTF::Try "pkteng_start" {
    $STA wl mpc 0
    $STA wl up
    $STA wl scansuppress 1
    $STA wl phy_watchdog 0
    $STA wl interference 0
    $STA wl interference_override 0
    $STA wl nrate -m 7 -s 1 
    $STA wl ssid "" 
    $STA wl disassoc
    $STA wl pkteng_start 10:20:30:40:50:60 tx 100 1000 0
    
}

UTF::Try "pkteng_stats" {
	$STA wl pkteng_stats
}

UTF::Try "pktcnt" {
	$STA wl pktcnt
}


UTF::Try "pkteng_maxlen" {
	$STA wl pkteng_maxlen
}

UTF::Try "pkteng_stop" {
	$STA wl up
	$STA wl pkteng_stop tx
}


UTF::Try "plltest" {
       $STA wl down
	$STA wl plltest 1
	$STA wl plltest
}


UTF::Try "pll_config" {
	$STA wl down
	$STA wl plltest_config
}


UTF::Try "plltest_delay" {
	$STA wl down
	$STA wl plltest_delay 1 
	$STA wl plltest_delay
}

UTF::Try "PM" {
	$STA wl PM
} 

UTF::Try "povars" {
    $STA wl povars
} 

UTF::Try "primary_key" {
	$STA wl primary_key 1
	$STA wl primary_key 
}




UTF::Try "promisc" {
	$STA wl promisc 1
	$STA wl promisc
}
 
UTF::Try "radioreg for band a" {
    $STA wl mpc 0
	$STA wl up
	$STA wl isup
    $STA wl radioreg 1 a
}

UTF::Try "radioreg for band b" {
    $STA wl mpc 0
	$STA wl up
	$STA wl isup
    $STA wl radioreg 1 b
}


 

UTF::Try "rate" {
	$STA wl rate
}

UTF::Try "rateset" {
	$STA wl down
	$STA wl rateset
}

UTF::Try "rdvar" {
	$STA wl rdvar 1
	$STA wl rdvar 
}

UTF::Try "restart" {
	$STA wl down
	$STA wl restart
}

UTF::Try "revinfo" {
	$STA wl revinfo
}


UTF::Try "rpcalvars" {
	$STA wl rpcalvars
}

UTF::Try "rsdb_corempc" {
	$STA wl rsdb_corempc 
}


UTF::Try "rsdb_mode" {
	$STA wl rsdb_mode 
}

UTF::Try "rssi" {
	$STA wl rssi 
}

UTF::Try "rtsthresh" {
	$STA wl rtsthresh 
}


UTF::Try "rxchain" {
	$STA wl down
	$STA wl rxchain 
}

UTF::Try "rxstreams" {
	$STA wl rxstreams	
}

UTF::Try "scan" {
	$STA  wl mpc 0
	$STA  wl up
	$STA  wl isup
	$STA wl scan
}

UTF::Try "scanresults" {
	$STA  wl mpc 0
	$STA  wl up
	$STA  wl isup
	$STA wl scanresults
	$STA wl ssid	
	
}

UTF::Try "scansuppress" {
	$STA wl scansuppress	
}


UTF::Try "seq_delay " {
	$STA wl seq_delay
}

UTF::Try "seq_start" {
	$STA wl seq_start
}

UTF::Try "seq_stop" {
	$STA wl seq_stop
}

UTF::Try "set_pmk" {
	$STA wl set_pmk abcdefghij
	$STA wl set_pmk
}

UTF::Try "sgi_rx" {
	$STA wl sgi_rx
}

UTF::Try "sgi_tx" {
	$STA wl sgi_tx
}

UTF::Try "shortslot_override" {
	$STA wl shortslot_override
}

UTF::Try "slow_timer" {
	$STA wl slow_timer
}


UTF::Try "snr" {
	$STA wl snr
}

UTF::Try "spatial_policy" {
	$STA wl down
	$STA wl spatial_policy
}

UTF::Try "spect" {
	$STA wl down	
	$STA wl spect
}

UTF::Try "srcrc" {
	$STA wl srcrc
}


UTF::Try "srdump" {
	$STA wl srdump
}

UTF::Try "srl" {
	$STA wl srl
}

UTF::Try "srwrite" {
	$STA wl srwrite 432 0x1234
}

UTF::Try "ssid" {
	$STA wl ssid
}

UTF::Try "status" {
	$STA wl status
}

UTF::Try "stbc_rx" {
	$STA wl stbc_rx
}

UTF::Try "stbc_tx" {
	$STA wl stbc_tx
}

UTF::Try "stf_ss_auto" {
	$STA wl stf_ss_auto
}

UTF::Try "subband_idx" {
	$STA wl subband_idx
}

UTF::Try "subband5Gver" {
	$STA wl subband5Gver
}

UTF::Try "sup_wpa" {
	$STA wl sup_wpa 1
	$STA wl sup_wpa 
}

UTF::Try "tempsense_disable" {
	$STA wl tempsense_disable
}

UTF::Try "tssi for 5g" {
	$STA wl mpc 0
	$STA wl up	
	$STA wl isup
	$STA wl band a	
	$STA wl tssi
}

UTF::Try "tssi for 2g" {
	$STA wl mpc 0
	$STA wl up	
	$STA wl isup
	$STA wl band b	
	$STA wl tssi
}

UTF::Try "txant" {
	$STA wl mpc 0
	$STA wl up
	$STA wl txant
}

UTF::Try "txbf" {
	$STA wl txbf
}

UTF::Try "txbf_bfe_cap" {
	$STA wl txbf_bfe_cap 1
	$STA wl txbf_bfe_cap
}

UTF::Try "txbf_bfr_cap" {
	$STA wl txbf_bfr_cap 1
	$STA wl txbf_bfr_cap
}

UTF::Try "txbf_imp" {
	$STA wl txbf_imp
}

UTF::Try "txbf_timer" {
	$STA wl txbf_timer
}

UTF::Try "txchain" {
	$STA wl down
	$STA wl txchain
}

UTF::Try "txcore" {
	$STA wl txcore  
}

UTF::Try "txinstpwr" {
	$STA wl down 
	$STA wl band b
	$STA wl clk 1
	$STA wl txinstpwr  
}


UTF::Try "txpwr1" {
	$STA wl up
	$STA wl txpwr1
}

UTF::Try "txstreams" {
	$STA wl txstreams
}

UTF::Try "ulb_mode" {
	$STA wl ulb_mode
}

UTF::Try "up" {
	$STA wl up
}



UTF::Try "ver" {
	$STA wl up
}

UTF::Try "vht_features" {
	$STA wl vht_features
}

UTF::Try "vhtmode" {
	$STA wl vhtmode
}

UTF::Try "wd_disable" {
	$STA wl wd_disable
}

UTF::Try "wowl" {
	$STA wl wowl 1
	$STA wl wowl
}

UTF::Try "wowl_activate" {
	$STA wl wowl_activate
}

UTF::Try "wowl_clear" {
	$STA wl wowl_clear
}

UTF::Try "wowl_dngldown" {
	$STA wl wowl_dngldown 0
	$STA wl wowl_dngldown
}

UTF::Try "wpa_auth" {
	$STA wl wpa_auth
}

UTF::Try "wpa_cap" {
	$STA wl  wpa_cap
}


UTF::Try "wsec" {
	$STA wl  wsec
}

UTF::Try "wsec_test" {
	$STA wl up
	$STA wl wsec_test mic_error 0x0001 replay 0x0002 icv_error 0x0004 act_error 0x0008 disassoc_error 0x0010 deauth_error 0x0020
}




UTF::Try "$STA Channel Test 2g" {

	UTF::Try "$STA Channel 1" {
	$STA wl chanspec 1
	}
	UTF::Try "$STA Channel 2" {
	$STA wl chanspec 2
     }
	UTF::Try "$STA Channel 3" {
	$STA wl chanspec 3
	}
	UTF::Try "$STA Channel 4" {
	$STA wl chanspec 4
	}
	UTF::Try "$STA Channel 5" {
	$STA wl chanspec 5
	}
	UTF::Try "$STA Channel 6" {
	$STA wl chanspec 6
	}
	UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
	UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
	UTF::Try "$STA Channel 10" {
	$STA wl chanspec 10
	}
	UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}
	
}
	
	

	
  
   
UTF::Try "$STA Channel Test 5g" {

	$STA wl band a

UTF::Try "$STA Channel 36" {
	$STA wl chanspec 36
	}
UTF::Try "$STA Channel 40" {
	$STA wl chanspec 40
	}
UTF::Try "$STA Channel 44" {
	$STA wl chanspec 44
	}
UTF::Try "$STA Channel 48" {
	$STA wl chanspec 48
	}
UTF::Try "$STA Channel 52" {
	$STA wl chanspec 52
	}
UTF::Try "$STA Channel 56" {
	$STA wl chanspec 56
	}
UTF::Try "$STA Channel 60" {
	$STA wl chanspec 60
	}
UTF::Try "$STA Channel 64" {
	$STA wl chanspec 64
	}
UTF::Try "$STA Channel 100" {
	$STA wl chanspec 100
	}
UTF::Try "$STA Channel 104" {
	$STA wl chanspec 104
	}
UTF::Try "$STA Channel 108" {
	$STA wl chanspec 108
	}
UTF::Try "$STA Channel 112" {
	$STA wl chanspec 112
	}
UTF::Try "$STA Channel 116" {
	$STA wl chanspec 116
	}
UTF::Try "$STA Channel 132" {
	$STA wl chanspec 132
	}
UTF::Try "$STA Channel 136" {
	$STA wl chanspec 136
	}
UTF::Try "$STA Channel 140" {
	$STA wl chanspec 140
	}
UTF::Try "$STA Channel 149" {
	$STA wl chanspec 149
	}
UTF::Try "$STA Channel 153" {
	$STA wl chanspec 153
	}
UTF::Try "$STA Channel 157" {
	$STA wl chanspec 157
	}
UTF::Try "$STA Channel 161" {
	$STA wl chanspec 161
	}
UTF::Try "$STA Channel 165" {
	$STA wl chanspec 165
	}

}

}









#============== proc setup_summaries ================================
# Proc setup_summaries initialize summary web pages and related 
# global variables.
#====================================================================
proc setup_summaries {AP STA titleap } {

    # Get testrig name
    


}

#============== proc update_summaries ===============================
# # Proc for updating summary web pages
#====================================================================

#============== Main wl_commands test ===============================
UTF::Test wl_commands {args} {
      UTF::Getopts "$::wl_commands_getopts" "$::wl_commands_help"
	set ::loop1_counter 0

	



    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }


    # noinit implies nosetup. nosetup is for this script only.
    # noinit is passed to aci1fidha.test & has broader impact than nosetup.
    
   
    set (sta) [string trim $(sta)]
    if {$(sta) == ""} {
        error "ERROR: Must specify at least one sta"
    }



    
    # Get build name for use in report email subject.
    # When multiple STA are tested, they USUALLY use the same build.
    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(sta) 0]
    }   
    if {[set build [$item cget -image]] eq ""} {
        set build [$item cget -tag]
    }
    if {$build eq "NIGHTLY"} {
        set build "TOT"
    }

    # (branch) is used for comparison over time. For private builds
    # this should be specified explicitly so the tests know which
    # branch to test. (branch) defaults to auto.
    if {$(branch) eq ""} {
        if {[regexp {/} $build]} {
            error "Unable to determine branch name from build.  Please specify -branch"
        }
        set (branch) $build
    }

    # Truncate branch name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # aci1fidha.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list $build
    }

   
   
   set Router [lindex $(ap) 0]
    set STA [lindex $(sta) 0]
	
	
   
    # Compact build list for title
    set build [UTF::BuildTitle $(sta)]

     if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}

	if {[regexp {(\d+sd)} $Router - c]} {
	    append (title) " with $c AP"
	}
    }

	
    
	
	
    set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

   

   
       UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}

	foreach AP [concat $Router $(ap2)] {
	    if {!$(noapload)} {
		UTF::Try "$AP: Find AP Image" {
		    UTF::CheckImage $AP  unknown
		}

		UTF::Try "$AP: Load Image" {
		    if {[$AP hostis Router Vx BSDAP DSL Airport]} {
			if {[catch {$AP lan ifconfig [$AP lan cget -ipaddr]}]} {
			    $AP lan ifconfig 192.168.1.50
			}
		    }
		    $AP load
		}
		UTF::ReportDriver $AP 
	    } elseif {[$AP hostis Linux]} {
		UTF::Try "$AP: reload" {
		    $AP reload
		}
	    }
	    if {!$(norestore)} {
		UTF::Try "$AP: Restore Defaults" {
		    if {[$AP hostis Router Vx BSDAP DSL Airport]} {
			$AP restore_defaults
		    } else {
			$AP services stop
			if {[info exists ::UTF::Use11h]} {
			    catch {$AP wl msglevel +error +assoc +regulatory}
			} else {
			    catch {$AP wl msglevel +error +assoc}
			}
			if {![$AP cget -nomimo_bw_cap]} {
			    catch {$AP wl down}
			    # Enable 40 in 2.4, if available.
			    if {[catch {$AP wl bw_cap 2 -1}]} {
				$AP wl -u mimo_bw_cap 1
			    }
			    $AP wl up
			    UTF::Sleep 1
			}
		    }
		    set what [$AP whatami]
		    # Pull out chip info and replace whitespace to make it
		    # easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {$(noapload)} {
			$UTF::Summary header $AP $w
		    } else {
			$UTF::Summary header_update 1 $w
		    }
		    $AP dbrecord REF
		    set what
		}
	    }
		# This is regular test and we loop through each STA.
            	foreach STA $(sta) {
            	    setup_summaries $Router $STA $(titleap) \
                    	
            	    # Call proc main_wl_commands for each STA
     	    	    main_wl_commands $Router $STA

	    	    incr ::sta_counter
            	}	
		
	}
	foreach STA $(sta) {
	    if {!$(nounload)} {
		UTF::Try "$STA: unload driver" {
		    $STA unload
		}
	    }
	    catch {$STA deinit}
	}

	foreach AP [concat $Router $(ap2)] {
	    if {!$(nounload) && ![$AP hostis Router Vx BSDAP DSL Airport]} {
		UTF::Try "$AP: unload driver" {
		    $AP unload
		}
	    }

	    $AP deinit
	}

	PreservedReport

	if {!$(noposttesthook) && [info exists ::UTF::PostTestHook]} {
	    UTF::Try "Post Test" {
		eval $::UTF::PostTestHook
	    }
	}
    }
   
   
   


# Do optional post test analysis. The "" passes the unnamed options array.
UTF::do_post_test_analysis wl_commands.test ""
}

