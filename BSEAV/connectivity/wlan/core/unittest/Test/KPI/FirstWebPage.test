#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script to measure the time required for a first wget
#
# Written by: Robert J. McMahon May 2015
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::ControlChart
package require UTF::KPI::OSEvents
package require UTF::Test::AutoJoinSetup
package require UTF::Test::ConnectAPSTA
package require UTF::KPI::KeyValue

package provide UTF::Test::FirstWebPage 2.0

UTF::Test FirstWebPage {args} {
    UTF::Getopts {
	{ap.arg "4708ap" "APs under test"}
	{sta.arg "43602lx2" "STA under test"}
	{pktsize.arg "1470" "UDP payload size"}
	{s.arg "10" "Number of times to loop"}
	{history.arg "30" "Control Chart history"}
	{watchdog.arg "60" "Time in seconds to wait for web page"}
	{key.arg "" "Control Chart Key"}
	{kpidb.arg "" "Parent KPI db"}
	{url.arg "http://www.google.com/" "Web URL"}
	{stressor.arg "" "Stressor STA"}
	{msglevel.arg "-scan" "wl msglevel to apply"}
	{wgetoptions.arg "-4  -S --tries=inf -e use_proxy=yes --delete-after -nd --page-requisites -U 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194'" "Wget options"}
	{security.arg "open" "Default security"}
	{staticip "Use static ip, no dhcp"}
	{connect.arg "join" "type of connect to use"}
    }

    set procmsgtag [namespace tail [lindex [info level 0] 0]]
    #Watchdog for wget set to 60 / 2 = 30 seconds
    set watchdog [expr {$(watchdog) / 2}]
    append (wgetoptions) " -T $watchdog -e http_proxy=[$(ap) lan ipaddr]:3128"
    if {$(stressor) ne {}} {
	set stressor_stream [UTF::stream %AUTO% -name "stressor" -rx $(ap) -tx $(stressor) -protocol "TCP" -reportinterval 0.1]
	set stressortxt (stressor)
    } else {
 	set stressortxt {}
    }
    set site [lindex [split $(url) .] 1]
    if {$(kpidb) ne ""} {
	set test_db [UTF::KPI::KeyValue %AUTO% -name FirstWebPage -units "milliseconds" -parent $(kpidb)]
    } else {
	set test_db [UTF::KPI::KeyValue %AUTO% -name FirstWebPage -units "milliseconds"]
    }
    $test_db set reqgroupsize $(s) stressor $(stressor) fetchurl $(url)
    if {$(stressor) ne {}} {
	package require UTF::Stressors
	set stressor [UTF::Stressor::Traffic %AUTO% -name "stressor" -ap $(ap) -sta $(sta)]
	set stressortxt (stressor)
    } else {
	set stressortxt {}
    }

    set cacheopts "nocache cache"
    foreach cacheopt $cacheopts {
	$test_db clear samples
	if {$cacheopt eq "nocache"} {
	    set WGETOPTS "$(wgetoptions) --no-cache"
	    set cachetxt (nocache)
	    $test_db set cache 0
	} else {
	    set WGETOPTS "$(wgetoptions)"
	    set cachetxt (cache)
	    $test_db set cache 1
	}
	if {[$(sta) hostis MacOS]} {
	    set BTSTATE 1
	    $test_db set bluetooth 1
	} else {
	    set BTSTATE "N/A"
	    $test_db set bluetooth {}
	}
	set TRYMSG "First Web Page (${site}) ${cachetxt} ${stressortxt}(BT=$BTSTATE)"
	UTF::Try $TRYMSG {
	    set failtry 0
	    set failcount 0
	    set successcount 0
	    $(sta) wl msglevel $(msglevel)
	    if {$(stressor) ne {}} {
		$stressor start
		$stressor linkcheck -now
	    }
	    set times {}
	    foreach e [UTF::KPI::OSEvents info instances] {
		$e destroy
	    }
	    if {[$(sta) hostis MacOS]} {
		set 80211events [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type apple80211_events -tcpdump wget -oldwl 1]
		set btevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type bluetooth]
		if {$BTSTATE ne "N/A"} {
		    $(sta) rexec "/usr/local/bin/applebt  --setPowerState $BTSTATE"
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach power state $BTSTATE}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --getPowerState"]
			if {([regexp {Bluetooth is turned on} $currstate] && $BTSTATE) || ([regexp {Bluetooth is turned off} $currstate] && !$BTSTATE)} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Power State"
		    } else {
			after cancel $watchdog
		    }
		    catch {$(sta) rexec "/usr/local/bin/applebt  --disconnectAll"}
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach no active connections}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --listConnectedDevices"]
			if {[regexp {No Active connections} $currstate]} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Active Connections"
		    } else {
			after cancel $watchdog
		    }
		}
	    }
	    for {set ix 1} {$ix <= $(s)} {incr ix} {
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e stop
		}
		UTF::Try "Setup" {
		    foreach e [UTF::KPI::OSEvents info instances] {
			$e start
		    }
		    if {[$(sta) hostis MacOS]} {
			set rexecid [AutoJoinSetup -ap $(ap) -sta $(sta) -security $(security) -v -radio off]
			$80211events waitfor linkdown -timeout 60
		    } else {
			$(sta) wl radio off
		    }
		    if {![$(sta) hostis MacOS]} {
			catch {$(sta) lan ip route replace unicast [$(ap) lan ipaddr]/32 dev [$(sta) cget -device]}
		    }
		    if {[info exists rexecid] && $rexecid ne ""} {
			$rexecid close; unset rexecid
		    }
		    return
		}
		set ::UTF::__tryid "auto"
		set TRYMSG "Measure Ro2FWebPage"
		UTF::Try $TRYMSG {
		    set TRYID $::UTF::__tryid
		    $test_db set  -exclude "trytext" "$TRYMSG" "logfile" "$UTF::Logfile"
		    $test_db set "tryID" $TRYID
		    UTF::Message INFO "$procmsgtag" "UTF::Try ID = $TRYID "
		    set time1 [clock clicks -milliseconds]
		    if {[$(sta) hostis MacOS]} {
			$(sta) networksetup -setairportpower [$(sta) cget -device] on
		    } else {
			$(sta) wl radio on
		    }
		    if {$(connect) ne "auto"} {
			UTF::Try "Reconnect via $(connect)" {
			    switch $(connect) {
				"join" {
				    $(sta) wl join [$(ap) wl ssid]
				}
				"utf" -
				"connect" {
				    ConnectAPSTA $(ap) $(sta) -nochecks
				}
				default {
				    error "invalid connect type $(connect)"
				}
			    }
			}
		    }
		    UTF::Message EVENT "$procmsgtag" "Web fetch start"
		    #Watchdog set to 60 / 4 = 15 seconds for auto-join
		    set watchdog [after [expr {$(watchdog)  * 1000 / 4}] "::UTF::Message ERROR $(sta) {IP ADDR TIMEOUT}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			if {![catch {$(sta) ipaddr}]} {
			    break
			}
			UTF::Sleep 0 quiet
		    }
		    if {$timeout} {
			error "No IP Address"
		    } else {
			after cancel $watchdog
		    }
		    #Watchdog set to 60 / 2 = 30 seconds for overall timeout
		    set watchdog [expr {$(watchdog) * 1000 / 2}]
		    if {[catch {$(sta) rexec -timeout $watchdog -Timeout $watchdog wget -P /tmp {*}$WGETOPTS $(url)} output] || \
			    ![regexp {FINISHED\s+--} $output]} {
			::UTF::Message ERROR $(sta) $output
			if {[catch {$(sta) ping [$(ap) lan ipaddr]}]} {
			    $(sta) ifconfig
			}
			error "wget failed"
		    }
		    set delta [expr {[clock clicks -milliseconds] - $time1}]
		    $test_db addsample $delta
		    foreach e [UTF::KPI::OSEvents info instances] {
			$e stop
		    }
		    lappend times $delta
		    UTF::Message STAT "Time" "Sample [llength $times]=$delta milliseconds"
		    incr successcount
		    catch {$(ap) lan rexec tail -n 25 /var/log/squid/access.log}
		    return $delta
		}
	    }
	    set failcount [expr {$(s) - $successcount}]
	    UTF::Try "Final success ratio" {
		set final "[expr {(1.0 * $successcount / ($failcount + $successcount)) * 100 }]%"
		UTF::Message STAT $procmsgtag "Total successes = $successcount"
		UTF::Message STAT $procmsgtag "Total fails = $failcount"
		UTF::Message STAT $procmsgtag "Final success ratio =  $final"
		return $final
	    }
	    if {[llength $times] > 4} {
		UTF::Message STATS "" "First web page $(url) times= $times"
		set mykey [concat "wget" $(ap) $(sta) $(url) [$(sta) wl msglevel] $WGETOPTS]
		if {$(stressor) ne {}} {
		    lappend mykey [$stressor id]
		}
		UTF::ControlChart CC -s $(s) -key [concat $(key) $mykey]  -history $(history) -title "First Web Page ($site)" -units "ms" -norangecheck 1  -format "%.0f"
		set boundsresults [CC addsample [UTF::MeanMinMax $times]]
		UTF::_Message RESULT KPI "\{$(key) $mykey\} $boundsresults $times"
		if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults]} {
		    incr failtry 1
		}
		set cc [CC plotcontrolchart $boundsresults]
		CC destroy
	    } else {
		error "Insufficient samples"
	    }
	    if {$failtry || ([llength $times] < $(s))} {
		$test_db set -exclude "TryResult" "FAIL"
		$test_db write
		error $cc
	    } else {
		$test_db set -exclude "TryResult" "PASS"
		$test_db write
		return $cc
	    }
	}
    }
    foreach e [UTF::KPI::OSEvents info instances] {
	$e destroy
    }
    catch {$stressor destroy}
}
