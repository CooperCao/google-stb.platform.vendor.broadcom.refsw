#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script to measure the time required for a first packet
#
# Written by: Robebrt J. McMahon April 2015
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Streams
package require UTF::ControlChart
package require UTF::Test::ConnectAPSTA
package require UTF::KPI::OSEvents
package require UTF::Test::AutoJoinSetup
package require UTF::KPI::KeyValue
package require UTF::math

package provide UTF::Test::FirstPacket 2.0

UTF::Test FirstPacket {args} {
    UTF::Getopts {
	{ap.arg "4708ap" "APs under test"}
	{sta.arg "43602lx2" "STA under test"}
	{pktsize.arg "1470" "UDP payload size"}
	{s.arg "10" "Number of times to loop"}
	{history.arg "30" "Control Chart history"}
	{watchdog.arg "30" "Time in seconds to wait for first packet"}
	{staticarp.arg "0" "Use a static ARP"}
	{bidir "Require first packet in each direction"}
	{key.arg "" "Control Chart Key"}
	{kpidb.arg "" "Parent KPI db"}
	{stressor.arg "" "Stressor STA"}
	{msglevel.arg "-scan" "wl msglevel to apply"}
	{connect.arg "join" "type of connect to use"}
	{security.arg "open" "Default security"}
	{suiteid.arg "meta" "Metacript ID used for data store"}
	{chanspec.arg "161/80" "Default chanspec to use"}
	{noasync "Don't use aysnchronous call for radio on"}
	{RadioOffSlop.arg "1" "Radio off takes extra time, add a sleep to give it that time"}
	{linkactiontype.arg "radio" "Set the link action type of either [radio | range]"}
	{v "verbose logging"}
	{vv "very verbose logging"}
	{btstate.arg "set the bt state for complete test"}
    }

    set procmsgtag [namespace tail [lindex [info level 0] 0]]
    set ::UTF::__tryid "auto"
    set trytxt {}
    set test_db [UTF::KPI::KeyValue %AUTO% -name FirstPacket -parent $(kpidb) -units "milliseconds"]
    $test_db set "linkactiontype" "$(linkactiontype)" "staticarp" "$(staticarp)" "biddir" "$(bidir)" "wl_msglevel" "[$(sta) wl msglevel]" "netload" "N/A"

    if {$(staticarp)} {
	append trytxt " (arp=static)"
    }
    if {[$(sta) hostis MacOS]} {
			if {$(btstate) ne ""} {
			set BTSTATES $(btstate)
			} else {
			set BTSTATES "1 0"
		    }
			} else {
			set BTSTATES "N/A"
		    }
    set trytxtbase "$trytxt ($(linkactiontype))"
    foreach BTSTATE $BTSTATES {
	$test_db set "bluetooth" $BTSTATE
	set trytxt "${trytxtbase}(BT=$BTSTATE)"
	if {$(bidir)} {
	    set TRYMSG "First Packet ($(sta)<->$(ap))${trytxt}"
	} elseif {$(stressor) ne {}} {
	    set trytxt "(netload-TCP)${trytxtbase}(BT=$BTSTATE)"
	    set TRYMSG "First Packet ($(sta)<->$(ap))${trytxt}"
	} else {
	    set TRYMSG "First Packet ($(sta)-->$(ap))${trytxt}"
	}

	UTF::Try $TRYMSG {
	    set failtry 0
	    $(sta) wl msglevel $(msglevel)
	    if {$(stressor) ne {}} {
		UTF::Try "Netload start" {
		    catch {$stressor_stream destroy}
		    set protocol "TCP"
		    set stressor_stream [UTF::stream %AUTO% -name "stressor" -rx $(ap) -tx $(stressor) -protocol $protocol -reportinterval 0.1]
		    append trytxt "(netload-${protocol})"
		    $test_db set "netload" "$protocol" "stressorID" "[$stressor_stream id]"
		    if {[catch {$(ap) wl bssid} apbssid] || ([$(stressor) wl bssid] ne $apbssid)} {
			UTF::Test::ConnectAPSTA $(ap) $(stressor)
		    }
		    $stressor_stream id
		    if {![$stressor_stream status]} {
			$stressor_stream start
		    }
		    $stressor_stream linkcheck -now
		}
	    }
	    set SSID [$(ap) wl ssid]
	    if {![regexp {Channel: (\d+)} [$(ap) wl status] - CHANSPEC]} {
		error "$(ap) Bad status"
		if {![regexp {\d+} [$(ap) wl chanspec] CHANSPEC]} {
		    error "$(ap) Null chanspec"
		}
	    }
	    set streams(up) [UTF::stream %AUTO% -tx $(sta) -rx $(ap) -pktsize $(pktsize) -reportinterval 0.01 -name udp-up -txdisplay 0 -rxdisplay 0 -api_msgs 0 -debug_msgs 0 -noblock 1]
	    if {$(bidir)} {
		set streams(down) [UTF::stream %AUTO% -rx $(sta) -tx $(ap) -pktsize $(pktsize) -reportinterval 0.01 -name udp-down -txdisplay 0 -rxdisplay 0 -api_msgs 0 -debug_msgs 0 -txstart_timeout 30000]
	    }
	    if {$(v)} {
		foreach index [array names streams] {
		    $streams($index) configurelist -txdisplay 0 -rxdisplay 1 -api_msgs 1 -debug_msgs 0
		}
	    }
	    if {$(vv)} {
		foreach index [array names streams] {
		    $streams($index) configurelist -txdisplay 1 -rxdisplay 1 -api_msgs 1 -debug_msgs 1
		}
	    }
	    set failcount 0
	    set successcount 0
	    foreach e [UTF::KPI::OSEvents info instances] {
		$e destroy
	    }
	    if {[$(sta) hostis MacOS]} {
		set netevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type apple80211_events -oldwl 1]
		set btevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type bluetooth]
		set KPIExpectedEvents [list SCAN_DONE LINKCHANGE_UP LINKCHANGE_DOWN]
	        if {$(linkactiontype) eq "radio"} {
		    lappend KPIExpectedEvents POWER_CHANGED
		}
		if {$BTSTATE ne "N/A"} {
		    $(sta) rexec "/usr/local/bin/applebt  --setPowerState $BTSTATE"
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach power state $BTSTATE}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --getPowerState"]
			if {([regexp {Bluetooth is turned on} $currstate] && $BTSTATE) || ([regexp {Bluetooth is turned off} $currstate] && !$BTSTATE)} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Power State"
		    } else {
			after cancel $watchdog
		    }
		    catch {$(sta) rexec "/usr/local/bin/applebt  --disconnectAll"}
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach no active connections}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --listConnectedDevices"]
			if {[regexp {No Active connections} $currstate]} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Active Connections"
		    } else {
			after cancel $watchdog
		    }
		}
	    } elseif {[$(sta) hostis Linux DHD]} {
		#		set oldnetevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type netevents]
		set netevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type dhdevents]
		set KPIExpectedEvents {SCAN_DONE LINKCHANGE_UP LINKCHANGE_DOWN}
	    }
	    array unset KPISamples *
	    set KPIMetricNames [list LinkDown ScanDone LinkUp LinkUp2Packet FirstPacket]
	    if {[$(sta) hostis MacOS] && $(linkactiontype) eq "radio"} {
		lappend KPIMetricNames "PowerChanged"
	    }
	    for {set ix 1} {$ix <= $(s)} {incr ix} {
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e stop
		}
		set kpireporttext {}
		if {[$(sta) hostis MacOS] && $(linkactiontype) eq "radio"} {
		    set TRYMSG "Sample $ix FP : PWR*,SCAN,LNKUP,PKT"
		} else {
		    set TRYMSG "Sample $ix FP : SCAN,LNKUP,PKT"
		}
		UTF::Try $TRYMSG {
		    UTF::Try "Setup : LinkDown" {
			UTF::stream allstreams stop
			foreach e [UTF::KPI::OSEvents info instances] {
			    $e start
			}
			if {[$(sta) hostis DHD]} {
			    # $(sta) wl msglevel +scan
			    set SSID [$(ap) wl ssid]
			}
			# clear any existing ARP entry
			foreach index [array names streams] {
			    catch {$streams($index) arp delete}
			}
			$netevents clear
			array unset KPIEvent *
			array unset KPIMetric *

			if {$(linkactiontype) eq "range"} {
			    set rexecid [AutoJoinSetup -ap $(ap) -sta $(sta) -security $(security) -v -radio on -noblacklist]
			    set currentattn [lindex [$(sta) attngrp attn?] 0]
			    $(sta) attngrp attn 95
			} else {
			    if {[$(sta) hostis MacOS]} {
				set rexecid [AutoJoinSetup -ap $(ap) -sta $(sta) -security $(security) -v -radio off]
			    } else {
				$(sta) wl radio off
			    }
			}
			set KPIEvent(LinkDownEvent) [clock clicks -milliseconds]
			UTF::Message EVENT $procmsgtag "LinkDown ($(linkactiontype)): $KPIEvent(LinkDownEvent)"
			# Wait for link down and process timestamps
			$netevents waitfor linkdown -timeout 60
			if {[info exists rexecid] && $rexecid ne ""} {
			    $rexecid close; unset rexecid
			}
			if {$(linkactiontype) eq "radio"} {
			    $test_db set "RadioOffSlop" "$(RadioOffSlop)"
			    UTF::Sleep $(RadioOffSlop)
			}
			set KPIEvent(LinkDown) [$netevents gettime LINKCHANGE_DOWN]
			UTF::Message EVENT $procmsgtag "LinkDown: $KPIEvent(LinkDown)"
			if {$KPIEvent(LinkDown) ne -1} {
			    set KPIMetric(LinkDown) [expr {$KPIEvent(LinkDown) - $KPIEvent(LinkDownEvent)}]
			} else {
			    set KPIMetric(LinkDown) -0
			}
			lappend KPISamples(LinkDown) $KPIMetric(LinkDown)
			return $KPIMetric(LinkDown)
		    }
		    if {$(linkactiontype) eq "radio"} {
			set TRYMSG "Measure Ro2FP"
		    } else {
			set TRYMSG "Measure InRange2FP"
		    }
		    UTF::Try $TRYMSG {
			set SAMPLEID $::UTF::__tryid
			$test_db set  -exclude "trytext" "$TRYMSG"
			$test_db set "tryID" $SAMPLEID
			$test_db set  -exclude "logfile" "$UTF::Logfile"
			$test_db clear samples
			UTF::Message INFO "$procmsgtag" "UTF::Try ID = $SAMPLEID"
			if {$(linkactiontype) eq "range"} {
			    $(sta) attngrp attn $currentattn
			} else {
			    if {[$(sta) hostis MacOS]} {
				if {!$(noasync)} {
				    set rexecid [$(sta) rexec -async networksetup -setairportpower [$(sta) cget -device] on]
				    $test_db set "async" "1"
				} else {
				    $(sta) networksetup -setairportpower [$(sta) cget -device] on
				    $test_db set "async" "0"
				}
			    } else {
				$(sta) wl radio on
			    }
			}
			set KPIEvent(LinkUpAction) [clock clicks -milliseconds]
			UTF::Message EVENT "$(sta)" "Link up action = $(linkactiontype)"
			$(sta) ipaddr_cache_invalidate
			set apbssid [$(ap) wl bssid]
			set watchdog [after [expr {$(watchdog)  * 1000 / 3}]  "::UTF::Message ERROR $(sta) {ASSOC TIMEOUT}"]
			while {![set timeout [catch {after info $watchdog}]]} {
			    if {![catch {$(sta) wl bssid} bssid] &&  ($bssid eq $apbssid)} {
				set KPIEvent(ASSOC_SUCCESS) [clock clicks -milliseconds]
				UTF::Message INFO $(sta) "Assoc time was [format %0.3f [expr {($KPIEvent(ASSOC_SUCCESS) - $KPIEvent(LinkUpAction)) / 1000.0}]]"
				break
			    }
			    UTF::Sleep 0.1 quiet
			}
			if {$timeout} {
			    error "ASSOC FAILED"
			} else {
			    after cancel $watchdog
			}

			set watchdog [after [expr {$(watchdog)  * 1000 / 3}]  "::UTF::Message ERROR $(sta) {IP ADDR TIMEOUT}"]
			while {![set timeout [catch {after info $watchdog}]]} {
			    if {![catch {$(sta) ipaddr}]} {
				break
			    }
			    UTF::Sleep 0 quiet
			}
			if {$timeout} {
			    error "No IP Address"
			} else {
			    after cancel $watchdog
			}
			if {$(staticarp)} {
			    foreach index [array names streams] {
				$streams($index) arp install
			    }
			}
			foreach index [array names streams] {
			    # Restart the streams
			    $streams($index) incr_dstport
			    $streams($index) start
			}
			#  $streams(up) sniff on -mac -promiscuous
			$streams(up) sniff on -mac
			if {$(connect) ne "auto"} {
			    if {[info exists rexecid] && $rexecid ne ""} {
				$rexecid close; unset rexecid
			    }
			    UTF::Message INFO $procmsgtag "Reconnect via $(connect)"
			    switch $(connect) {
				"join" {
				    # $(sta) wl scan -c $CHANSPEC -s $SSID
				    # $(sta) wl scan -s $SSID
				    $(sta) wl join [$(ap) wl ssid]
				}
				"utf" {
				    ConnectAPSTA $(ap) $(sta) -nochecks
				}
				"connect" {
				    ConnectAPSTA $(ap) $(sta)
				}
				default {
				    error "invalid connect type $(connect)"
				}
			    }
			}
			set aid [after [expr {$(watchdog) * 1000}] {}]
			set checklist [array names streams]
			set done 0
			while {!$done} {
			    foreach index $checklist {
				UTF::Sleep 0 quiet
				if {[catch {after info $aid}]} {
				    UTF::Message ERROR [$streams($index) cget -name] "Timeout waiting on first packet"
				    incr failtry
				    incr failcount
				    set failtxt {}
				    foreach f $checklist {
					lappend failtxt [$streams($f) cget -name]
				    }
				    if {!$successcount && $failcount >= 3} {
					set ix [expr {$(s) + 1}]
				    }
				    if {[info exists rexecid] && $rexecid ne ""} {
					$rexecid close; unset rexecid
				    }
				    $test_db set  -exclude "TryIteration" "$ix" "TryResult" "FAIL"
				    $test_db write
				    UTF::Try "Fault Isolate, Force Join" {
					foreach f $checklist {
					    $streams($f) introspect
					}
					catch {$(sta) wl msglevel}
					catch {$(sta) wl_escanresults}
					catch {$(sta) wl bssid}
					catch {$(sta) wl join [$(ap) wl ssid]}
					UTF::Sleep 4
					catch {$(sta) wl bssid} res
					foreach index $checklist {
					    if {[catch {$streams($index) linkcheck -now}]} {
						UTF::Message FAULT [$streams($index) cget -name] "Failed again"
					    } else {
						UTF::Message FAULT [$streams($index) cget -name] "Now OK"
					    }
					}
					return
				    }
				    error "First packet timeout of $(watchdog) sec triggered: failed=$failtxt"
				}
				if {![catch {$streams($index) linkcheck -now}]} {
				    set checklist [lsearch -all -not -inline $checklist $index]
				    if {![llength $checklist]} {
					set KPIEvent(FirstPacket) [clock clicks -milliseconds]
					catch {after cancel $aid}
					UTF::Message EVENT [$(sta) cget -name] "***First packet occurred***"
					$test_db set  -exclude "TryIteration" "$ix" "TryResult" "PASS"
					set KPIMetric(FirstPacket) [expr {$KPIEvent(FirstPacket) - $KPIEvent(LinkUpAction)}]
					set kpireporttext "$KPIMetric(FirstPacket) : "
					if {$(vv)} {
					    if {[$(sta) hostis MacOS]} {
						$netevents configure -debug 1
					    }
					}
					foreach event $KPIExpectedEvents {
					    set milliseconds [$netevents gettime $event]
					    if {$milliseconds eq "UNK"} {
						UTF::Message ERROR $procmsgtag "Event $event not seen ($milliseconds)"
						incr failtry
					    } else {
						if {$(vv)} {
						    UTF::Message DEBUG $procmsgtag "$event seen at $milliseconds"
						}
						set KPIEvent($event) $milliseconds
					    }
					}
					# Calculate the contributing times
					if {[$(sta) hostis MacOS] && $(linkactiontype) eq "radio"} {
					    $netevents configure -debug 0
					    if {[catch {expr {$KPIEvent(POWER_CHANGED) - $KPIEvent(LinkUpAction)}} KPIMetric(PowerChanged)]} {
						UTF::Message ERROR $procmsgtag $KPIMetric(PowerChanged)
						set KPIMetric(PowerChanged) -0
					    }
					    append kpireporttext " $KPIMetric(PowerChanged), "
					}
					if {[catch {expr {$KPIEvent(SCAN_DONE) - $KPIEvent(LinkUpAction)}} KPIMetric(ScanDone)]} {
					    UTF::Message ERROR $procmsgtag $KPIMetric(ScanDone)
					    set KPIMetric(ScanDone) -0
					}
					append kpireporttext "$KPIMetric(ScanDone)"
					if {[catch {expr {$KPIEvent(LINKCHANGE_UP) - $KPIEvent(SCAN_DONE)}} KPIMetric(LinkUp)]} {
					    UTF::Message ERROR $procmsgtag $KPIMetric(LinkUp)
					    set KPIMetric(LinkUp) -0
					}
					append kpireporttext ", $KPIMetric(LinkUp)"
					if {[catch {expr {$KPIEvent(FirstPacket) - $KPIEvent(LINKCHANGE_UP)}} KPIMetric(LinkUp2Packet)]} {
					    UTF::Message ERROR $procmsgtag $KPIMetric(LinkUp2Packet)
					    set KPIMetric(LinkUp2Packet) -0
					}
					append kpireporttext ", $KPIMetric(LinkUp2Packet)"
					foreach metric $KPIMetricNames {
					    if {![info exists KPIMetric($metric)]} {
						UTF::Message ERROR "$metric" "Not found"
						continue
					    }
					    if {$KPIMetric($metric) < 0} {
						UTF::Message WARN "$metric" "Less than zero"
					    }
					    lappend KPISamples($metric) $KPIMetric($metric)
					    UTF::Message STAT "$metric" "Sample = $KPIMetric($metric) millseconds"
					}
					incr successcount
					$test_db setarray KPIMetric
					$test_db write
					set done 1
				    }
				}
			    }
			}
			if {[info exists rexecid] && $rexecid ne ""} {
			    $rexecid close; unset rexecid
			}
			return $kpireporttext
		    }
		    if {$done} {
			set TRYSTATUS "PASS"
		    } else {
			set TRYSTATUS "FAIL"
		    }
		    return $kpireporttext
		}
		$streams(up) sniff off
		foreach index [array names streams] {
		    $streams($index) stop
		}
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e stop
		}
	    }
	    set ratiokey {}
	    UTF::Try "Final success ratio (outliers)" {
		set outliercnt "0"
		if {[info exists KPISamples(FirstPacket)] && [llength $KPISamples(FirstPacket)] >= 4} {
		    set outliers [::UTF::math::outliers $KPISamples(FirstPacket)]
		    if {$outliers ne ""} {
			set outliercnt [llength $outliers]
			incr failtry
			UTF::Message STAT $procmsgtag "Outliers : $outliers"
		    }
		}
		set total [expr {$failcount + $successcount}]
		set final "[expr {(1.0 * $successcount / $total) * 100 }]%"
		UTF::Message STAT $procmsgtag "Total successes = $successcount"
		UTF::Message STAT $procmsgtag "Total fails = $failcount"
		UTF::Message STAT $procmsgtag "Total outliers = $outliercnt"
		UTF::Message STAT $procmsgtag "Final success ratio =  $final"
		set results "$final ($outliercnt)"
		if {$failcount > 0 || $outliercnt > 0} {
		    error $results
		} else {
		    return $results
		}
	    }
	    if {[info exists KPISamples(FirstPacket)] && [llength $KPISamples(FirstPacket)] > 6} {
		foreach metric [array names KPISamples] {
		    set TRYSTATUS "FAIL"
		    UTF::Try "Metric=$metric" {
			set METRICTRYID $::UTF::__tryid
			catch {unset ccplot}
			UTF::Message STAT "$metric" "Samples = $KPISamples($metric) milliseconds"
			set CC($metric) [UTF::ControlChart %AUTO% -s $(s) -key "$metric [$test_db id]" -history $(history) -title "$metric" -units "ms" -norangecheck 1 -format "%.0f"]
			set boundsresults [$CC($metric) addsample [UTF::MeanMinMax $KPISamples($metric)]]
			if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - ccresult]} {
			    incr failtry
			} else {
			    set TRYSTATUS "PASS"
			    set ccresult "OK"
			}
			if {$metric ne "FirstPacket"} {
			    set ccplot [$CC($metric) plotcontrolchart $boundsresults]
			} else {
			    if {$outliercnt} {
				set boundsresults [regsub {OK} $boundsresults "3IQR"]
			    }
			    set ccplot [$CC($metric) plotcontrolchart $boundsresults]
			    set ccprimary $ccplot
			}
			$CC($metric) destroy
			return $ccplot
		    }
		}
	    } else {
		foreach index [array names streams] {
		    catch {$streams($index) destroy}
		}
		catch {$stressor_stream destroy}
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e destroy
		}
		error "Insufficient samples"
	    }
	    if {[info exists ccprimary]} {
		if {$failtry || ([llength $KPISamples(FirstPacket)] < $(s))} {
		    error $ccprimary
		} else {
		    return $ccprimary
		}
	    } else {
		error "Primary KPI measurement failed"
	    }
	}
    }
}

