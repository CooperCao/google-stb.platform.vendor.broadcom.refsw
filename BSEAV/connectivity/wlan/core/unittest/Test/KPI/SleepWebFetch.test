#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script to measure the time required to get a web page after a sleep / wake cycle
#
# Written by: Robert J. McMahon August 2015
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::ControlChart
package require UTF::KPI::OSEvents
package require UTF::Test::AutoJoinSetup
package require UTF::Test::ConnectAPSTA
package require UTF::KPI::KeyValue

package provide UTF::Test::SleepWebFetch 2.0

UTF::Test SleepWebFetch {args} {
    UTF::Getopts {
	{ap.arg "NetG7K" "APs under test"}
	{sta.arg "MacX-DOME" "STA under test"}
	{pktsize.arg "1470" "UDP payload size"}
	{s.arg "5" "Number of times to loop"}
	{history.arg "30" "Control Chart history"}
	{watchdog.arg "90" "Time in seconds to wait for web page"}
	{kpidb.arg "" "Parent KPI db"}
	{url.arg "http://www.google.com/" "Web URL"}
	{stressor.arg "" "Stressor STA"}
	{msglevel.arg "-scan" "wl msglevel to apply"}
	{wgetoptions.arg "-4 -T 60 -S --tries=inf -e use_proxy=yes --delete-after -nd --page-requisites -U 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194'" "Wget options"}
	{security.arg "open" "Default security"}
	{staticip "Use static ip, no dhcp"}
	{wakedelay.arg "45" "Seconds from sleep time to wake from sleep"}
	{webfetchdelay.arg "60" "Seconds from wake to start web fetch"}
	{ACSTATES.arg "1 0" "Setting for the AC vs Battery power"}
	{v6 "use v6 addressing"}
    }

    proc sleepwakecycle {} {
	# access option array
	upvar {} upopts
	# Copy option array and apply per-device overrides
	array set {} [array get upopts]

	set now [$(sta) date +\"%s\"]
	set waketime [expr {$now + $(wakedelay)}]
	# Format time for Mac OS pmset schedule
	set waketime [clock format $waketime -format "%m/%d/%Y %H:%M:%S"]
	if {[catch {$(sta) rexec "pmset schedule cancelall"}]} {
	    set output [$(sta) rexec "pmset -g sched"]
	    foreach line [split $output "\n"] {
		if {[regexp {(sleep|wake) at (.+)} $line - type datetime]} {
		    $(sta) pmset schedule cancel $type \"[string trim ${datetime}]\"
		}
	    }
	}
	$(sta) rexec "pmset schedule wake '${waketime}'"
	$(sta) rexec "pmset -g sched"
	$(sta) rexec "pmset -g assertions"
	$(sta) rexec "pmset -g disk"
	if {[catch {$(sta) macaddr} mac]} {
	    unset mac
	} else {
	    set mac [string toupper $mac]
	}
	set disassoctime "-1"
	$(sta) rexec "pmset sleepnow"
	set ::_sleepwebfetch(wakeup) 0
	set ::_sleepwebfetch(poll) 0
	set timer [expr {1000 * ($(webfetchdelay) + $(wakedelay))}]
	after [expr {1000 * $(wakedelay)}] [list ::UTF::_Message INFO "$(sta)" "OS wake expected now"]
	set wakeaid [after $timer [list set ::_sleepwebfetch(wakeup) 1]]
	after 250 [list set ::_sleepwebfetch(poll) 1]
	UTF::Message VWAIT "[expr {$timer / 1000}]" "wake: $waketime fetch delay: $(webfetchdelay) (s)"
	set t1 [clock milliseconds]
	while {![catch {after info $wakeaid} res]} {
	    if {[info exists mac] && $::_sleepwebfetch(poll)} {
		if {[regexp "$mac" [$(ap) wl assoclist]]} {
		    set ::_sleepwebfetch(poll) 0
		    UTF::Message INFO "$(ap)" "STA $(sta)(${mac}) found in assoc list"
		    after 250 [list set ::_sleepwebfetch(poll) 1]
		} else {
		    set t2 [clock milliseconds]
		    set disassoctime [expr {$t2 - $t1}]
		    UTF::Message EVENT "$(sta)" "STA (${mac}) not found in AP $(ap) assoc list : $disassoctime ms"
		    unset mac
		    continue
		}
	    }
	    vwait ::_sleepwebfetch
	}
	catch {after cancel $wakeaid}
	if {![info exists t2]} {
	    UTF::Message WARN "" "STA $(sta) (mac=${mac}) never disassociated from AP"
	}
	set output [$(sta) rexec "pmset -g sched"]
	if {$output ne ""} {
	    if {[catch {$(sta) rexec "pmset schedule cancelall"}]} {
		foreach line [split $output "\n"] {
		    if {[regexp {(sleep|wake) at (.+)} $line - type datetime]} {
			$(sta) pmset schedule cancel $type \"[string trim ${datetime}]\"
		    }
		}
	    }
	    error "pmset sleep/wake didn't occur as expected"
	} else {
	    return "$disassoctime"
	}
    }

    set procmsgtag [namespace tail [lindex [info level 0] 0]]
    set ::UTF::__tryid "auto"

    append (wgetoptions) " -e http_proxy=[$(ap) lan ipaddr]:3128"

    if {$(kpidb) ne ""} {
	set test_db [UTF::KPI::KeyValue %AUTO% -name SleepWakeWebFetch -units "milliseconds" -parent $(kpidb)]
    } else {
	set test_db [UTF::KPI::KeyValue %AUTO% -name SleepWakeWebFetch -units "milliseconds"]
    }
    $test_db set "wakedelay -attribute units=seconds" $(wakedelay) "webfetchdelay -attribute units=seconds" $(webfetchdelay) reqgroupsize $(s) stressor $(stressor)
    if {$(stressor) ne {}} {
	set stressor_stream [UTF::stream %AUTO% -name "stressor" -rx $(ap) -tx $(stressor) -protocol "TCP" -reportinterval 0.1]
	set stressortxt (stressor)
    } else {
	set stressortxt {}
    }
    $test_db set fetchurl $(url)
    set site [lindex [split $(url) .] 1]
    set cacheopts "cache"
    foreach ACSTATE $(ACSTATES) {
	$test_db clear samples
	$test_db set ACSTATE $ACSTATE
	foreach cacheopt $cacheopts {
	    $test_db set webcache $cacheopt
	    if {$cacheopt eq "nocache"} {
		set WGETOPTS "$(wgetoptions) --no-cache"
		set cachetxt (nocache)
	    } else {
		set WGETOPTS "$(wgetoptions)"
		set cachetxt (cache)
	    }
	    if {[$(sta) hostis MacOS]} {
		set BTSTATE 1
	    } else {
		set BTSTATE "N/A"
	    }
	    $test_db set bluetooth $BTSTATE
	    set TRYMSG "Sleep/Wake WebFetch (${site}) ${cachetxt} ${stressortxt}(BT=$BTSTATE)(AC=${ACSTATE})"
	    UTF::Try $TRYMSG {
		set failtry 0
		set failcount 0
		set successcount 0
		$(sta) wl msglevel $(msglevel)
		if {$(stressor) ne {}} {
		    $stressor start
		    $stressor linkcheck -now
		}
		set times {}
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e destroy
		}
		set 80211events [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type apple80211_events]
		set btevents [UTF::KPI::OSEvents %AUTO% -sta $(sta) -name $(sta) -type bluetooth]
		if {$BTSTATE ne "N/A"} {
		    $(sta) rexec "/usr/local/bin/applebt  --setPowerState $BTSTATE"
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach power state $BTSTATE}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --getPowerState"]
			if {([regexp {Bluetooth is turned on} $currstate] && $BTSTATE) || ([regexp {Bluetooth is turned off} $currstate] && !$BTSTATE)} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Power State"
		    } else {
			after cancel $watchdog
		    }
		    catch {$(sta) rexec "/usr/local/bin/applebt  --disconnectAll"}
		    set watchdog [after [expr {5 * 1000}] "::UTF::Message ERROR $(sta) {applebt couldn't reach no active connections}"]
		    while {![set timeout [catch {after info $watchdog}]]} {
			set currstate [$(sta) rexec "/usr/local/bin/applebt  --listConnectedDevices"]
			if {[regexp {No Active connections} $currstate]} {
			    break
			}
		    }
		    if {$timeout} {
			error "Bluetooth Active Connections"
		    } else {
			after cancel $watchdog
		    }
		}
		for {set ix 1} {$ix <= $(s)} {incr ix} {
		    foreach e [UTF::KPI::OSEvents info instances] {
			$e stop
		    }
		    if {[$(sta) hostis MacOS]} {
			set TRYMSG "Setup (autojoin)"
		    } else {
			set TRYMSG "Setup (radio off)"
		    }
		    UTF::Try "Setup (autojoin) (ac=$ACSTATE)" {
			if {[$(sta) hostis MacOS]} {
			    AutoJoinSetup -ap $(ap) -sta $(sta) -security $(security) -v -radio on
			} else {
			    $(sta) wl radio on
			}
			if {![$(sta) hostis MacOS]} {
			    catch {$(sta) ip route replace unicast [$(ap) lan ipaddr]/32 dev [$(sta) cget -device]}
			}
			if {$ACSTATE} {
			    $(sta) power on
			} else {
			    $(sta) power off
			}
			return
		    }
		    set TRYMSG "Measure Sleep/Wake WebFetch"
		    $test_db set  -exclude "trytext" "$TRYMSG"
		    append TRYMSG " (${ix})"
		    UTF::Try $TRYMSG {
			set TRYID $::UTF::__tryid
			$test_db set "tryID" $TRYID
			$test_db set  -exclude "logfile" "$UTF::Logfile"
			UTF::Message INFO "$procmsgtag" "UTF::Try ID = $TRYID"
			UTF::Message EVENT "$procmsgtag" "Sleep/Wake cycle"
			foreach e [UTF::KPI::OSEvents info instances] {
			    $e stop
			}
			set disassoctime [sleepwakecycle]
			foreach e [UTF::KPI::OSEvents info instances] {
			    $e start
			}
			UTF::Message EVENT "$procmsgtag" "Web fetch start"
			set time1 [clock clicks -milliseconds]
			set aid [after [expr {$(watchdog) * 1000}] {}]
			while {![catch {after info $aid}]} {
			    catch {$(sta) rexec -Timeout $(watchdog) -timeout $(watchdog) wget -P /tmp {*}$WGETOPTS $(url)} output
			    if {[regexp {FINISHED\s+--} $output]} {
				break
			    }
			}
			if {[catch {after info $aid}]} {
			    error "wget failed"
			}
			set delta [expr {[clock clicks -milliseconds] - $time1}]
			catch {after cancel $aid}
			catch {unset aid}
			$test_db addsample $delta
			lappend times $delta
			UTF::Message STAT "Time" "Sample [llength $times]=$delta milliseconds"
			incr successcount
			catch {$(ap) lan tail -n 25 /var/log/squid/access.log}
			return "Fetch: $delta Disassoc: $disassoctime"
		    }
		}
		foreach e [UTF::KPI::OSEvents info instances] {
		    $e stop
		}
		if {[llength $times] < $(s)} {
		    $test_db set -exclude "TryResult" "PARTIAL"
		    set failtry 1
		}
		if {[llength $times] < 4} {
		    $test_db set -exclude "TryResult" "EXCEPTION"
		    $test_db set -exclude "ControlChartResult" {}
		    set cc "Insufficient samples"
		    set failtry 1
		} else {
		    UTF::Message STATS "" "First web page $(url) times= $times"
		    UTF::ControlChart CC -s $(s) -key [$test_db id]  -history $(history) -title "Sleep/Wake WebFetch ($site)" -units "ms" -norangecheck 1  -format "%.0f"
		    set boundsresults [CC addsample [UTF::MeanMinMax $times]]
		    set ccboundsresult "OK"
		    if {[regexp {(HIGH|LOW|WIDE|ZERO)} $boundsresults - ccboundsresult]} {
			set failtry 1
		    }
		    $test_db set -exclude "ControlChartResult" $ccboundsresult
		    set cc [CC plotcontrolchart $boundsresults]
		    CC destroy
		}
		set failcount [expr {$(s) - $successcount}]
		UTF::Try "Final success ratio" {
		    set final "[expr {(1.0 * $successcount / ($failcount + $successcount)) * 100 }]%"
		    UTF::Message STAT $procmsgtag "Total successes = $successcount"
		    UTF::Message STAT $procmsgtag "Total fails = $failcount"
		    UTF::Message STAT $procmsgtag "Final success ratio =  $final"
		    $test_db set -exclude successratio $final
		    return $final
		}
		if {$failtry} {
		    $test_db write
		    error $cc
		} else {
		    $test_db set -exclude "TryResult" "PASS"
		    $test_db write
		    return $cc
		}
	    }
	}
	foreach e [UTF::KPI::OSEvents info instances] {
	    $e destroy
	}
	catch {$stressor destroy}
	$(sta) power on
    }
}
