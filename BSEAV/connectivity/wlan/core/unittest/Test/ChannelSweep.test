#!/bin/env utf
# -*-tcl-*-

# UTF test script for running packet error rate tests between a 4321
# AP and STA for all channel and rates.
# $Id: 70ed8f5c9903003037f23d34c9104b20db05fbff $
#
package require UTF
package require UTF::MpduStats
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::Test::controlchart
package require UTF::Test::memchart

package provide UTF::Test::ChannelSweep 2.0

UTF::Test ChannelSweep {AP STA args} {

    # Change default gnuplot terminal type to prevent complaints
    # about being run without an X11 display
    set ::env(GNUTERM) png

    # Pull out dut option since we need it before we can fetch the
    # rest of the arguments.
    if {[set dix [lsearch -exact $args -dut]] >= 0} {
	set vix [expr {$dix + 1}]
	set (dut) [lindex $args $vix]
    } else {
	set (dut) $AP
    }

    # If FBDefault is set, and devices support it, enable fb
    if {[info exists ::UTF::FBDefault] &&
	![$STA cget -noframeburst] && ![$AP cget -noframeburst]} {
	set fbdefault 1
    } else {
	set fbdefault 0
    }

    # User can specify per device defaults in config.
    set args [concat [$AP cget -channelsweep] [$STA cget -channelsweep] $args]
    # Switch to just DUT when callers have been updated
    #set args [concat [$(dut) cget -channelsweep] $args]


    UTF::Getopts [subst {
	{dut.arg "$(dut)" "dut"}
	{band.arg "" "Band"}
	{bw.arg "" "BandWidth"}
	{no2g40 "" "Skip 2g40 tests"}
	{initc.arg "" "initial channel"}
	{chanspec.arg "" "Chanspec list"}
	{skip.arg "" "Chanspec skip list"}
	{min.arg "" "Lowest channel to test"}
	{max.arg "" "Highest channel to test"}
	{count.arg "30" "Retry count"}
	{msg.arg "" "Message"}
	{usewl "Force use of wl commands, even if nvram is available"}
	{i.arg 0.5 "Interval"}
	{s.arg 4 "Samples"}
	{b.arg "[$(dut) cget -udp]" "UDP data rate (0 for TCP) defaults to -udp option of dut"}
	{key.arg "" "Key"}
	{loop.arg "" "deprecated"}
	{perfcache.parg "" "Performance Cache"}
	{perfloop.parg "1" "Performance loop"}
	{history.parg 30 "Performance History"}
	{nocache "Don't update performance cache"}
	{loop.arg "" "Performance loop"}
	{frameburst.arg "$fbdefault" "Use frameburst"}
	{symmetric.arg 0 "Symmetric - skip downstream tests"}
	{usecsa.arg "[$(dut) cget -usecsa]" "Use Channel Switch Announcements"}
	{sort.arg "1" "Sort channel list"}
	{PM.arg "" "Specify PM mode"}
	{pretest.arg "0" "Enable short warm-up test before the main perf tests"}
    }]

    if {$(loop) ne  ""} {
	set (perfloop) $(loop)
    }

    if {$(msg) eq ""} {
	set (msg) $(dut)
    }

    set apcargs ""
    if {$(usewl)} {
	lappend apcargs -usewl
    }
    lappend apcargs -usecsa $(usecsa)

    # Check which end is really taking the STA role
    if {[$STA cget -apmode]} {
	UTF::Message INFO $AP "apmode: Reversing $AP and $STA"
	set _STA $AP; set AP $STA; set STA $_STA; unset _STA
    }

    if {![$STA cget -use11h]} {
	# Normally AP determines use11h, but allow the STA to refuse also
	lappend apcargs -use11h 0
    }

    UTF::decomment (chanspec)

    set SSID [$AP wl ssid]

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    if {$(chanspec) eq ""} {
	# default to finding chanspecs AP and STA have in common
	set (chanspec) [UTF::Common [$AP allchanspecs] [$STA allchanspecs]]

	UTF::Message INFO [$AP cget -name] "Available channels: $(chanspec)"

	# Partition into bands and bandwidths for convenient reporting
	foreach chanspec $(chanspec) {
	    if {[lsearch -exact $(skip) $chanspec] >= 0} {
		UTF::Message INFO  [$AP cget -name] "Skipping $chanspec"
		continue
	    }
	    if {[regexp {^(\d+)(/?\w*)} $chanspec - c sb]} {
		if {($(min) ne "" && $c < $(min)) ||
		    ($(max) ne "" && $c > $(max))} {
		    UTF::Message INFO  [$AP cget -name] \
			"Skipping $chanspec (out of range)"
		    continue
		}
		if {$c > 15} {
		    if {[lsearch {"" "5" "a"} $(band)] < 0} {
			UTF::Message INFO  [$AP cget -name] \
			    "Skipping $chanspec (wrong band)"
			continue
		    } else {
			set band "5g"
		    }
		} else {
		    if {[lsearch {"" "2.4" "b" "g"} $(band)] < 0} {
			UTF::Message INFO  [$AP cget -name] \
			    "Skipping $chanspec (wrong band)"
			continue
		    } else {
			set band "2g"
		    }
		}
		if {[regexp {/160} $sb]} {
		    set bw "160"
		} elseif {[regexp {/80} $sb]} {
		    set bw "80"
		} elseif {$sb eq ""} {
		    set bw "20"
		} else {
		    set bw "40"
		}
		if {[llength $(bw)] && [lsearch $(bw) $bw] < 0} {
		    UTF::Message INFO  [$AP cget -name] \
			"Skipping $chanspec (wrong bw)"
		    continue
		}
		if {$(no2g40) && $band eq "2g" && $bw eq "40"} {
		    UTF::Message INFO  [$AP cget -name] \
			"Skipping $chanspec (no2g40)"
		    continue
		}
		lappend clist($band) [list $bw/$chanspec $chanspec]
	    } else {
		error "bad chanspec $chanspec"
	    }
	}
    } else {
	set (sort) 0
	foreach chanspec $(chanspec) {
	    lappend clist() [list $chanspec $chanspec]
	}
    }

    foreach k [lsort [array names clist]] {
	set chanfail {}
	UTF::Try "$(msg): Channel Sweep $k" {
	    if {$(sort)} {
		set clki [lsort -dictionary -index 0 $clist($k)]
	    } else {
		set clki $clist($k)
	    }
	    set clk ""
	    foreach c $clki {
		lappend clk [lindex $c 1]
	    }
	    UTF::Message INFO [$AP cget -name] "Testing $clk"

	    # Make sure devices are associated.  NULL ssid check is in
	    # case the AP was last used in STA mode.
	    if {$SSID eq "" || [$STA wl ssid] ne $SSID} {
		# Disassoc before switching radio to avoid
		# roam/join race on the STA
		catch {$STA wl disassoc}
		if {$(PM) ne  ""} {
		    set oldPM [$STA wl PM]
		    $STA wl PM $(PM)
		}
		if {$(initc) eq ""} {
		    set (initc) [lindex $clk 0]
		}
		ConnectAPSTA $AP $STA -chanspec $(initc)
	    }

	    set apip [$AP ipaddr]

	    if {$(frameburst)} {
		$STA wl frameburst 1
	    } else {
		$STA wl -u frameburst 0
	    }

	    set window [$STA tcpautowindow]

	    set branch [$(dut) branchname]
	    set key [concat $branch channelsweep $k $(key)]

	    set plotkey [concat $key $AP $STA]
	    # Sanitize key for use as a filename
	    # / cannot be used in a filename is it is a directory seperator <>
	    # are legal in filenames (but very confusing), but they will mess
	    # up any URL's that point to them.
	    regsub -all {[/<>]} $plotkey "." plotkey

	    if {$(b) ne "0"} {
		set proto "UDP"
		lappend key "udp"
		lappend plotkey "udp"
	    } else {
		set proto "TCP"
	    }
	    set oldkey $key
	    if {$(frameburst)} {
		lappend key "fb"
		lappend plotkey "fb"
	    }

	    # nativename is needed to avoid confusing gnuplot with ~ and
	    # other special path components.
	    set file [file nativename \
			  [file join [file dir $UTF::Logfile] \
			       [file rootname $UTF::Logfile].$plotkey]]

	    set rxfile "${file}_rx.gpf"
	    set rxctrlfile "${file}_rx.gpc"
	    set rxplotfile_sm "${file}_rx_sm.png"
	    set rxplotfile "${file}_rx.png"

	    set txfile "${file}_tx.gpf"
	    set txctrlfile "${file}_tx.gpc"
	    set txplotfile_sm "${file}_tx_sm.png"
	    set txplotfile "${file}_tx.png"

	    set rxfilefd [open $rxfile w]
	    set txfilefd [open $txfile w]

	    set xtics ""
	    set i -1
	    set xlist {}

	    set txcollector [UTF::MpduStats init $STA $AP ${file}_tx]
	    set rxcollector [UTF::MpduStats init $AP $STA ${file}_rx]

	    if {![$(dut) cget -nomaxmem] && [$(dut) rte_available]} {
		set memfile "${file}_mem.gpf"
		set memctrlfile "${file}_mem.gpc"
		set memplotfile_sm "${file}_mem_sm.png"
		set memplotfile "${file}_mem.png"
		set memfilefd [open $memfile w]
	    }

	    # Scale so Area is comparible with individual mean throughput
	    set w [expr {1.0 / [llength $clk]}]
	    foreach c $clk {
		$STA wl bssid
		# Abort quickly if the association is lost.  We could
		# try reassociating, but if there is something seriously
		# wrong, we could waste a long time here.
		UTF::Try "$(msg): Chanspec $c up" {
		    set success 0
#		    $AP wl msglevel +info
#		    $STA wl msglevel +info
		    set roamp [APChanspec $AP $c {*}$apcargs]
#		    $AP wl msglevel -info
#		    $STA wl msglevel -info

		    try {
			incr i
			lappend xlist $c

			$STA ping $apip -c $(count)

			# CSA should switch channel in-network
			if {!$roamp && [$STA innetworktime $AP] < 2} {
			    $STA warn "Unexpected Roam"
			}

			set stachan [lindex [$STA wl chanspec] 0]
			if {$stachan ne $c} {
			    $STA warn "Chan $stachan"
			}

			set success 1

			if {[info exists memfilefd]} {
			    catch {
				set freekb [$(dut) freekb]
				UTF::XPASS $(dut) $freekb \
				    [concat [UTF::ParmStrip parm] data free]
				puts $memfilefd "$i $freekb"
				if {![info exists initialfreekb]} {
				    set initialfreekb $freekb
				}
			    }
			}

			# Frameburst must be set on the AP after rc
			# restart.
			if {$(frameburst)} {
			    $AP wl frameburst 1
			} else {
			    $AP wl -u frameburst 0
			}

			set bw [$AP bw $c]
			set sbw [$STA bw $stachan]

			if {$(pretest)} {
			    UTF::Multiperf [list $STA $AP] -t $(pretest) \
				-w $window -b $(b) -pingmax 0
			} else {
			    UTF::Sleep 1
			}

			set parm(chanspec) $c
			# Upstream throughput

			# Clear stats
			$txcollector clear

			array unset CC
			set code [catch {
			    controlchart [list $STA $AP] -stats CC \
				-perfcache $(perfcache) \
				-history $(history) -min 0 \
				-key [concat $key up $c] -i $(i) -s $(s) \
				-oldkey [concat $oldkey up $c] -i $(i) -s $(s) \
				-window $window \
				-nopretest -pingmax 0 -loop $(perfloop) -N 0 -b $(b)
			} results]

			$txcollector collect $c

			if {![catch {$STA wl nrate} nr] &&
			    [regexp {\sbw(\S+)\s} $nr - nbw] &&
			    $sbw != $nbw} {
			    $STA warn "unexpected bw$nbw"
			}
			UTF::XPASS $STA [lindex [$STA wl rate] 0] \
			    [concat [UTF::ParmStrip parm] data rate]
			if {[info exists CC(mmm)]} {
			    puts $txfilefd "$i $CC(mmm) $CC(Ux) $CC(Lx)"
			    foreach m $CC(mmm) {
				UTF::XPASS $STA $m [UTF::ParmStrip parm]
			    }
			    UTF::XPASS $STA $CC(Ux) \
				[concat [UTF::ParmStrip parm] data Ux]
			    UTF::XPASS $STA $CC(Lx) \
				[concat [UTF::ParmStrip parm] data Lx]
			}
			#if {[info exists freekb]} {
			#    set results "$results ($freekb)"
			#}
			if {$code} {
			    lappend chanfail $c
			    throw FAIL $results
			} else {
			    return $results
			}
		    } finally {
			if {!$success} {
			    puts $txfilefd ""
			    puts $rxfilefd ""
			    if {[$STA wl bssid] eq "00:00:00:00:00:00"} {
				throw FAIL "Roam failed"
			    }
			    lappend chanfail $c
			}
		    }
		}
		if {!$(symmetric) && $success} {
		    UTF::Try "$(msg): Chanspec $c dn" {
			# Downstream throughput

			$rxcollector clear

			array unset CC
			set code [catch {
			    controlchart [list $AP $STA] -stats CC \
				-perfcache $(perfcache) \
				-history $(history) -min 0 \
				-key [concat $key down $c] -i $(i) -s $(s) \
				-oldkey [concat $oldkey down $c] -i $(i) -s $(s) \
				-window $window \
				-nopretest -pingmax 0 -loop $(perfloop) -N 0 -b $(b)
			} results]

			$rxcollector collect $c

			if {![catch {$AP wl nrate} nr] &&
			    [regexp {\sbw(\S+)\s} $nr - nbw] &&
			    $sbw != $nbw} {
			    $AP warn "unexpected bw$nbw"
			}
			UTF::XPASS $AP [lindex [$AP wl rate] 0] \
			    [concat [UTF::ParmStrip parm] data rate]
			if {[info exists CC(mmm)]} {
			    puts $rxfilefd "$i $CC(mmm) $CC(Ux) $CC(Lx)"
			    foreach m $CC(mmm) {
				UTF::XPASS $AP $m [UTF::ParmStrip parm]
			    }
			    UTF::XPASS $AP $CC(Ux) \
				[concat [UTF::ParmStrip parm] data Ux]
			    UTF::XPASS $AP $CC(Lx) \
				[concat [UTF::ParmStrip parm] data Lx]
			}
			if {$code} {
			    if {[lindex $chanfail end] ne $c} {
				lappend chanfail $c
			    }
			    throw FAIL $results
			} else {
			    return $results
			}
		    }
		}
	    }

	    close $txfilefd
	    close $rxfilefd
	    if {[info exists memfilefd]} {
		close $memfilefd
	    }

	    set xtics ""
	    set i 0

	    set interval [expr {[llength $xlist] / 20}]
	    foreach a $xlist {
		if {$interval == 0 || $i % $interval == 0} {
		    lappend xtics "'$a' $i"
		}
		incr i
	    }
	    lappend xtics "'$a' [expr {$i-1}]"

	    # Plot
	    set G [open $txctrlfile w]
	    if {[UTF::GnuplotVersion] >= 5.0} {
		puts $G {set colors classic}
	    }
	    if {[UTF::GnuplotVersion] > 4.0} {
		puts $G {set terminal png transparent size 62,13}
		puts $G {set tmargin 0; set bmargin 0}
		puts $G {set lmargin 0; set rmargin 0.1}
	    } else {
		puts $G {set terminal png transparent; set size 0.15,0.08}
		# Gnuplot 4.0 loops if margins are zero - use mogrify below
	    }
	    puts $G {unset y2tics}
	    puts $G {unset ytics}
	    puts $G {unset xtics}
	    puts $G {unset key}
	    puts $G {unset border}
	    puts $G "set output '$txplotfile_sm'"
	    puts $G "plot '$txfile' using 1:5 notitle with lines lt 2, \
		 '' using 1:6 notitle with lines lt 2, \
		 '' using 1:2 notitle with lines lt 1"

	    puts $G {reset}
	    puts $G {set terminal png notransparent size 1280,1280 truecolor}

	    puts $G "set output '$txplotfile'"
	    puts $G "set multiplot title '$(msg) Upstream $proto ChannelSweep'"
	    if {[UTF::GnuplotVersion] > 4.2} {
		puts $G "set xtics rotate by -20"
	    } else {
		puts $G "set xtics rotate"
	    }
	    puts $G "set origin 0,0.59; set size 1.0,0.4"
	    puts $G "set title 'Tput'"
	    puts $G "set xtics ([join $xtics ,])"
	    puts $G "plot '$txfile' using 1:5 notitle with lines lt 2, \
		 '' using 1:6 notitle with lines lt 2, \
		 '' using 1:2:3:4 notitle with errorlines lt 1"
	    puts $G [$txcollector plotscripts]
	    puts $G {unset multiplot}
	    puts $G {quit}
	    close $G

	    # Run gnuplot on plot file.  Catch is needed because gnuplot
	    # often writes to stderr.  Report any output even if we think
	    # it was ok.
	    catch {exec $::UTF::Gnuplot $txctrlfile} txret
	    UTF::Message WARN "gnuplot" $txret

	    set ret "html:<a href=\"[UTF::URI $txplotfile]\">[UTF::ThumbData $txplotfile_sm]</a>"

	    if {[file size $rxfile] > 0} {
		# Plot
		set G [open $rxctrlfile w]
		if {[UTF::GnuplotVersion] >= 5.0} {
		    puts $G {set colors classic}
		}
		if {[UTF::GnuplotVersion] > 4.0} {
		    puts $G {set terminal png transparent size 62,13}
		    puts $G {set tmargin 0; set bmargin 0}
		    puts $G {set lmargin 0; set rmargin 0.1}
		} else {
		    puts $G {set terminal png transparent; set size 0.15,0.08}
		    # Gnuplot 4.0 loops if margins are zero - use mogrify below
		}
		puts $G {unset y2tics}
		puts $G {unset ytics}
		puts $G {unset xtics}
		puts $G {unset key}
		puts $G {unset border}
		puts $G "set output \"$rxplotfile_sm\""
		puts $G "plot \"$rxfile\" using 1:5 notitle with lines lt 2, \
		 \"\" using 1:6 notitle with lines lt 2, \
		 \"\" using 1:2 notitle with lines lt 1"

		puts $G {reset}
		puts $G {set terminal png notransparent size 1280,1280 truecolor}
		puts $G "set output '$rxplotfile'"
		puts $G "set multiplot title '$(msg) Downstream $proto ChannelSweep'"
		if {[UTF::GnuplotVersion] > 4.2} {
		    puts $G "set xtics rotate by -20"
		}
		puts $G "set origin 0,0.59; set size 1.0,0.4"
		puts $G "set xtics ([join $xtics ,])"

		puts $G "set title 'Tput'"
		puts $G "plot '$rxfile' using 1:5 notitle with lines lt 2, \
		 '' using 1:6 notitle with lines lt 2, \
		 '' using 1:2:3:4 notitle with errorlines lt 1"
		puts $G [$rxcollector plotscripts]
		puts $G {unset multiplot}
		puts $G {quit}
		close $G

		# Run gnuplot on plot file.  Catch is needed because gnuplot
		# often writes to stderr.  Report any output even if we think
		# it was ok.
		catch {exec $::UTF::Gnuplot $rxctrlfile} rxret
		UTF::Message WARN "gnuplot" $rxret

		$txcollector destroy
		$rxcollector destroy

		append ret " <a href=\"[UTF::URI $rxplotfile]\">[UTF::ThumbData $rxplotfile_sm]</a>"
	    }

	    if {[info exists memfile] && [file size $memfile] > 0} {
		# Plot
		set G [open $memctrlfile w]
		if {[UTF::GnuplotVersion] >= 5.0} {
		    puts $G {set colors classic}
		}
		if {[UTF::GnuplotVersion] > 4.0} {
		    puts $G {set terminal png transparent size 62,13}
		    puts $G {set tmargin 0; set bmargin 0}
		    puts $G {set lmargin 0; set rmargin 0.1}
		} else {
		    puts $G {set terminal png transparent; set size 0.15,0.08}
		    # Gnuplot 4.0 loops if margins are zero - use mogrify below
		}
		puts $G {unset y2tics}
		puts $G {unset ytics}
		puts $G {unset xtics}
		puts $G {unset key}
		puts $G {unset border}
		puts $G "set output '$memplotfile_sm'"
		puts $G "plot '$memfile' using 1:2 notitle with lines lt 3"

		puts $G {reset}
		puts $G {set terminal png notransparent size 1280,480 truecolor}

		puts $G "set output '$memplotfile'"
		puts $G "set title '$(msg) ChannelSweep Free Memory'"
		puts $G "set xlabel 'Chanspec'"
		puts $G "set ylabel 'Free (kb)'"
		if {[UTF::GnuplotVersion] > 4.2} {
		    puts $G "set xtics rotate by -20"
		} else {
		    puts $G "set xtics rotate"
		}
		puts $G "set xtics ([join $xtics ,])"
		puts $G "plot '$memfile' using 1:2 notitle with lines lt 3"

		puts $G {quit}
		close $G

		# Run gnuplot on plot file.  Catch is needed because gnuplot
		# often writes to stderr.  Report any output even if we think
		# it was ok.
		catch {exec $::UTF::Gnuplot $memctrlfile} memret
		UTF::Message WARN "gnuplot" $memret

		append ret " <a href=\"[UTF::URI $memplotfile]\">[UTF::ThumbData $memplotfile_sm]</a>"
	    }

	    if {[info exists initialfreekb] &&
		![catch {$(dut) freekb} freekb]} {
		set memoryleak [format {%.1f} [expr {$initialfreekb - $freekb}]]
		UTF::Message INFO $(dut) "memory change: ${memoryleak}Kb"
		if {$memoryleak > 15} {
		    throw FAIL "$ret Memory Leak: ${memoryleak}Kb"
		}
		unset initialfreekb
	    }
	    if {[llength $chanfail] > 0} {
		throw FAIL "$ret FAIL: $chanfail"
	    } else {
		return $ret
	    }
	}
    }


    # explicit disassoc to reduce coverage loss if the device is stuck
    # in a "roaming" state.
    catch {$STA wl disassoc}
    if {[info exists oldPM]} {
	catch {$STA wl PM $oldPM}
    }
}
