#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for aci nightly run
# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set wl_check_help "\n\nBasic usage: Test/wl_check.test <options>\
    \n\nThis Rate vs Range script will setup your testrig by loading the desired\
    \nbuilds, produce high level summary web pages and calls the script that does\
    \nthe lower level work, aci.test. The script aci.test is called for up to 4\
    \ndifferent channels. Each channel is tested for the upstream and downstream\
    \ntraffic directions.\
    \n\nThese scripts have many default values, not all of which will work optimally\
    \non your testrig. Consequently, there are a number of environment variables that\
    \nyou can set in your config file to customize the behavior to better suit your\
    \ntestrig:\
    \n\nYou can customize the attenuation ranges to be tested for each channel:\
    \n    set ::cycle5G40AttnRange \"0-50 50-0\"\
    \n    set ::cycle5G20AttnRange \"0-50 50-0\"\
    \n    set ::cycle2G40AttnRange \"10-60 60-10\"\
    \n    set ::cycle2G20AttnRange \"10-60 60-10\"\
    \n\nIf the pathloss is the same for all devices in the testrig, specify:\
    \n    set ::testbed_pathloss ll\
    \n    where ll is a positive integer\
    \n\nYou can specify pathloss for each specific band:\
    \n    set ::testbed_pathloss_2G 52\
    \n    set ::testbed_pathloss_5G 63\
    \n\nIf each device has a different pathloss, you can specify the pathloss for each\
    \nSTA as shown below:\
    \n    set ::mc351_4319USB_pathloss 40\
    \n    set ::mc356_43236USB_pathloss 34\
    \n    set ::mc355_4336SDIO_pathloss 38\
    \n\nYou can specify pathloss per band or per channel per STA:\
    \n    set ::mc356_43236USB_pathloss_2G 34\
    \n    set ::mc356_43236USB_pathloss_5G 44\
    \n    set ::mc358_4312NIC_pathloss_36l 55\
    \n\nYou can take complete control of the AP & STA initialization sequence by\
    \nspecifying the variables ::rvr_ap_init and ::rvr_sta_init in your config\
    \nfile. The defaults are defined in aci.test proc get_user_parms. Alternately,\
    \nlook in the RvR logfiles in the Setup AP & STA section to see the defaults.\
    \nFor SoftAP, you can specify the initialization in ::rvr_softap_init. SoftAP\
    \ndefaults to the values from ::rvr_sta_init.\
    \n\nSome people may have more complex initialization needs which depend on the\
    \nSTA talking to a real AP versus a SoftAP, and other variations. So this\
    \ninitialization variable heirarchy is available to allow customization\
    \nfor all devices in the testrig, as well as STA specific customizations:\
    \nFor STA to SoftAP ::rvr_sta_{STA}_to_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_softap_init ::rvr_sta_init\
    \nFor STA to AP     ::rvr_sta_{STA}_to_ap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_ap_init ::rvr_sta_init\
    \nFor SoftAP        ::rvr_sta_{STA}_am_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_softap_init ::rvr_sta_init\
    \nFor AP            ::rvr_ap_{AP}_init ::rvr_ap_init\
    \nIn the above variables, {STA} & {AP} mean the UTF STA name.\
    \nWhen the script looks for the initialization, the list is searched from left\
    \nto right, with the STA specific variable having the highest priority.\
    \nBecause the script knows which AP & STA you are using, and if you specified\
    \nthe -softap option or not, the script can locate and use the appropriate\
    \ninitialization variables without any additional user intervention.\
    \n\nIf you want to use the -warmup option, you can override the default 5Mb/s pass\
    \ncriteria by specifying:\
    \n    set ::rvr_warmup nn\
    \n    Set this parameter to 0 or -1 if you dont want a pass criteria.\
    \n\nTo keep tests from running away for hours at a time, the aci.test script has a\
    \ntime limit of 90 minutes for each rampdown/rampup test. If you want to override\
    \nthe default 90 minute per test timeout value, then specify:\
    \n    set ::rvr_overall_timeout_min mm\
    \n    Set this parameter to 0 or -1 for no timeout, unlimited test run time.\
    \n\nBy default the script will try 1 time to rejoin the AP and STA. This default\
    \ncan be changed in your config file:\
    \n    set ::rvr_rejoin_tries ii\
    \n    The minimum value for this parameter is 1.\
    \n\nBy default, the script will wait 10 seconds after a rejoin attempt. This\
    \ndefault can be changed in your config file:\
    \n    set ::rvr_rejoin_wait_sec jj\
    \n    The minimum value for this parameter is 5.\
    \n\nBy default, the script will perform 3 progressive recovery attempts during the\
    \ntests if things go wrong. This default can be changed in your config file:\
    \n    set ::recovery_max kk\
    \n    Set this parameter to 0 or -1 for no recovery actions.\
    \n\nBy default, the script will stop the rampdown portion of the test after 3\
    \nconsecutive attenuator steps with no beacons. This default can be changed in\
    \nyour config file:\
    \n    set ::rvr_rampdown_nobeacons bb\
    \n    Set this parameter to 0 or -1 to disable this feature.\
    \n\nThe optional -stopslowrampup algorithm is controlled by two parameters, whose\
    \ndefaults are 10 & 1 respectively. These defaults can be changed in your config file:\
    \n    set ::rvr_slowrampup_cnt cc\
    \n    set ::rvr_slowrampup_tput tt\
    \n\nThere may be times that a specific STA needs the router to do something\
    \nspecifically for that STA. You can add STA specific variables to set the\
    \nrouter nvram accordingly in your config file. Dont forget to turn these\
    \nsettings back for theSTAs.\
    \n    set ::mc351_4319USB_rtr_nvram {antswitch=3}\
    \n    set ::mc356_43326USB_rtr_nvram {antswitch=0}\
    \n\nAfter each occasional repeated error attenuator occurs, the attenuator\
    \nrecovery is attempted. If you choose to specify the variable shown below in\
    \nyour config file, your attenuator will be power cycled for you, and the\
    \ncommand retried after the power cycle:\
    \n    set ::rvr_attn_power \"mcxxwsy 1\"\
    \nAfter 3 repeated attenuator errors, the aci.test is halted. Should you\
    \nwish to alter the default 3 attenuator error limit, you may specify the\
    \nvariable shown below in your config file:\
    \n    set ::rvr_attn_max_errors N\
    \n    Set this parameter to 0 or -1 to allow unlimited errors to occur.\
    \n\nThe optional fastrampup test will test 10 samples at the final attenuator\
    \nvalue. You can alter this value by specifying ::rvr_fastrampup_cnt in your\
    \nconfig file. Variable ::rvr_fastrampup_tput controls the thruput at which\
    \nthe fastrampup is made, default is 1 Mb/s.\
    \n\nFor SoftAP tests, the RF wiring on the attenuator needs to be set up to\
    \nattenuate the RF path between the SoftAP and the STA being tested. Most\
    \ntestrigs need to be modified for this to work, as they tend to have a real\
    \nAP connected to the attenuator, not a SoftAP.\
    \n\nFor SoftAP tests, you need to ensure the SoftAP and STAs will get IP\
    \naddresses. A real AP has a built-in DHCP server. If the SoftAP is running\
    \non Linux, you can run dhcpd on the Linux host. You will still need to\
    \nconfigure a static IP address for the SoftAP itself. If the SoftAP does\
    \nnot provide dhcpd, then you must configure static IP addresses for the\
    \nSTA that will be tested. See examples in utfconf/pb4a.tcl & mc49.tcl.\
    \n\nThe AP connect time check looks for drops of 30 seconds or more as\
    \nan indicator of issues. The variable ::rvr_connect_time_drop can be used\
    \nto alter this threshold. Set to -1 to turn off this test.\
    \n\nTrenderrors looks at how many consecutive errors occur as well as total\
    \nerrors in the test. Initially most controlchart tests are shown as PASS,\
    \nexcept for major errors like assert or ping fail. Then, at the end of the\
    \ntests, the trend errors analysis is done and the overall PASS/FAIL criteria\
    \nis determined. Config file variable ::rvr_trend_error_length defaults to 6,\
    \nand is the minimum number of consecutive errors needed to trigger a trend\
    \nerror FAIL. Variable ::rvr_trend_error_max defaults to 18, and is the total\
    \nnumber of errors that can occur, consecutive or not, without causing a FAIL.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set wl_check_getopts {
    {allhooks                  "Use all the perf_hooks, etc as is - currently the default"}
    {ap.arg "4717"             "AP name"}
    {bin.arg ""                "STA image, usefull for private build testing"}
    {branch.arg "auto"         "Branch override"}
    {date.arg ""               "depracated, please use rtrdate & stadate"}
    {downstreamonly            "RvR downstream only tests are done, dont do upstream tests"}
    {edithooks                 "Selectively edit the perf_hooks, etc for some test speedup"}
    {email.arg ""              "Email Address, defaults to your email address"}
    {fastrampup                "Do fast rampup only, saves test time"}
    {fb0                       "Use frameburst=0, currently the default"}
    {fb1                       "Use frameburst=1 for maximum throughput"}
    {keepgoing                 "No time limit for test, keep going no matter what"}
    {logdir.arg ""             "Log directory override"}
    {max.arg 1700              "Expected maximum througput, -1 means no checks done"}
    {min.arg 0                 "Expected minimum througput, -1 means no checks done"}
    {mingraphs                 "Produce minimum quantity of graphs"}
    {musta.arg ""              "Multi user mode. It loads up to 4 additional STAs"}
    {noapload                  "Don't load images"}
    {nobtreset                 "Don't reset BlueTooth devices. WARNING: can lead to low WLAN thruput!"}
    {nocache                   "Don't update performance cache"}
    {nochannels                "Does nothing, depracated"}
    {nocomposite               "Don't generate composite RvR graphs for each STA"}
    {nocompositemainpage       "Generate composite RvR graphs for each STA, but dont show them on the main web page"}
    {nocontrvr                 "Depracated"}
    {nocyclervr                "No cycle-based rvr tests, default is run the cycle-based rvr tests"}
    {nodbuxpost                "Dont post test info to dbux"}
    {nographs                  "Dont produce any graphs"}
    {nohistograms              "Do not produce histograms"}
    {nohooks                   "Dont use any perf_hooks, etc for maximum test speedup"}
    {noinit                    "Use the testbed as is, no initialization"}
    {nomalloc                  "Dont check the serial console for malloc failures"}
    {nopretest                 "Dont do short warmup test for each controlchart test, defaults on for udp"}
    {noredundant               "Dont execute redundant wl calls, test runs a bit faster"}
    {norestore                 "Don't reset AP to defaults"}
    {norvr                     "No rvr tests, default is run the rvr tests"}
    {nosetup                   "No loading of AP or STAs, no testbed setup"}
    {nosetuptestbed            "Don't run Setup Testbed hooks"}
     {nostaload                 "Don't load STA drivers"}
    {nostareload               "Don't even reload STA drivers (need -nostaload)"}
    {nostahighlevelsetup       "Let aci.test do all the STA setup."}
    {nosymmetry                "Dont run symmetry tests for rampdown / rampup tests"}
    {nounload                  "Don't unload driver after test"}
    {oemAttnRange.arg ""       "Cycle-based aci attenuation range for OEM AP, default: 20-75 75-20"}
    {oemband.arg ""            "When OEM AP broadcasts on both bands, used to choose the desired band: 2.4 or 5"}
    {pathloss.arg ""           "Known testbed path loss, in db, from AP to STA when variable attenuator is set to default"}
    {perfloop.arg 1            "Total performance test iterations for iperf controlchart tests"}
    {perfsize.arg 5            "Sample size for performance tests"}
    {perftime.arg 10           "Total time duration, in seconds, for performance tests"}
    {pingmax.arg ""            "Maximum times to try ping in RvR, default is 10"}
    {rampdownonly              "Dont do rampup portion of RvR tests, test time is halved"}
    {rampuponly                "Dont do rampdown portion of RvR tests, test time is halved"}
    {refreshaddralways         "Always do dhcp before each attenuator step change & iperf test"}
    {refreshaddrasneeded       "Do dhcp after reassociation for each attenuator step until dhcp succeeds once, then stop"}
    {restoreaponly             "Do not load or reload AP, just restore the AP NVRAM"}
    {rtrdate.arg ""            "Desired Router build date, format: yyyy.mm.dd"}
    {rtrtag.arg ""             "Router release tag"}
    {security.arg "open"       "Security used for tests"}
    {softap                    "AP is really a STA running softap code"}
    {sta.arg "Sta4321"         "sta name(s)"}
    {stadate.arg ""            "Desired STA build date, format: yyyy.mm.dd"}
    {stadhd.arg ""             "STA .ko linux DHD file, usefull for testing private builds"}
    {statag.arg ""             "STA release tag"}
    {stoponerror               "Stops test on first error, no progressive recovery done. Useful when developer want to see testrig in failed state."}
    {stopslowrampup            "Stop the rampup test if severe slow rejoin issues are detected"}
    {tag.arg ""                "depracated, please use rtrtag"}
    {test.arg "0"              "Test mode for script development, experts only, values: 0 1 2"}
    {timeout.arg ""            "Overall test timeout, in minutes, default is 90 min"}
    {title.arg "Rate vs Range Test" "Report title text"}
    {titleap                   "Use AP name in report & graph titles, default is STA name"}
    {trenderrors               "Show only trend errors, not 1 error per controlchart"}
    {trx.arg ""                "Router trx image, usefull for private build testing"}
    {udp.arg "0"               "udp test starting value in Mb/s, 0 means off, use tcp"}
    {udpopt.arg ""             "more options for iperf for udp tests"}
    {windhdbin.arg ""          "WinDHD dongle image file, usefull for testing private builds, in particular for BTAMP"}
    {window.arg 512k           "Window size for iperf tests, has major impact on throughput"}
}

# Setup online help info.
UTF::setup_help $wl_check_help $wl_check_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

package require UTF
package require UTF::utils1
package require UTF::Test::APConfigureSecurity
package require UTF::Test::ChannelSweep
package require UTF::Test::aci

package provide UTF::Test::wl_check 2.0

#============== proc main_rvr_nightly1 ==============================
# Proc main_rvr_nightly1 does all the STA loading, setup and then
# calls aci1fidha.test foreach STA. Router is loaded elsewhere.
#
# NB: proc is uniquely named to avoid conflict with other scripts
# that have a proc main.
#====================================================================
proc main_rvr_nightly1 {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts


	

    # Ensure each STA gets full initialization the first time thru aci1fidha.test
    set ::rvr_init_done 0

    # Find STA image if necessary.
    set id ""
    if {!$(nostaload) && !$(nosetup) && !$(noinit)} {
        UTF::Try "$STA Find STA Image" {
            set catch_resp [catch {$STA findimages} catch_msg]
            $STA configure -image $catch_msg ;# needed to update title tag numbers
            if {$catch_resp == 0} {
                return $catch_msg
            } else {
                error $catch_msg
            }
        }

        # Add report summary table row for STA.
        set id [UTF::get_build_id $catch_msg]
        set notes [UTF::get_build_notes $catch_msg]
        set status [UTF::get_build_status $catch_msg $catch_resp]
        set ::summaryinfo [UTF::update_report_add $::summaryinfo $STA $(bin) $(statag) $(stadate) $id $notes $status]

        # Halt tests if STA image not found.
        if {$catch_resp != 0} {
            UTF::Try "could not find $STA image" {
                error "halting $STA test"
            }
            return
        }
    }

    # Load/reload/setup STA if necessary
    if {!$(nosetup) && !$(noinit)} {
        if {$(nostaload)} {
            if {!$(nostareload)} {
                UTF::Try "$STA Reload" {
                 
                        # For WET test, this is an AP.
                        UTF::reload_rtr $STA
                    
                        UTF::reload_sta $STA
                    
                }
            }
        } else {
            UTF::Try "$STA Load" {
            
                  
             
                    UTF::load_sta_retry $STA
                
            }

            # Update the report header table with actual OS & hw versions.
            set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

            # Update report title with actual TAG numbers
            UTF::update_report_title $STA
        }

        # User may want to let the lower level aci1fidha.test do all the STA setup.
        if {!$(nostahighlevelsetup)} {
            UTF::Try "$STA Defaults" {
                
                    $STA services stop
                    catch {$STA wl msglevel +error +assoc}
                    catch {$STA wl down}
                    # Enable 40 in 2.4, if available.
                    catch {$STA wl mimo_bw_cap 1}
                    $STA wl up
                    UTF::Sleep 1
                    $STA wl ver
           
                set hw_ver [$STA chipname]
                regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
                return $hw_ver
            }
        }
    }

    # Determine which bands are supported by the STA.
    set catch_resp [catch "set sta_bands \[$STA wl bands\]" catch_msg]
    # set catch_resp 1 ;# test code
    if {$catch_resp != 0} {
        UTF::Try "could not get $STA bands" {
            error "halting $STA test: $catch_msg"
        }
        return
    }


    # Now get AP bands.
    if {$::is_oem_ap == 0} {
        set ap_bands [$Router wl bands]
    } else {
        set ap_bands ""
    }
    UTF::Message LOG $STA "sta_bands=$sta_bands ap_bands=$ap_bands"

    # aci1fidha.test needs branch name when it calls get_stream.
    lappend ::branch_list [$STA branchname]
    UTF::Message LOG $STA "updated branch_list=$::branch_list"

    # Check disk utilization of all STA to be tested.
    UTF::check_disk_usage "$Router $STA "

    # proc main_rvr_nightly1 test loop starts here.
    if {$(titleap)} {
        set focus $Router
    } else {
        set focus $STA
    }
    update_summaries ver $focus $(softap) $(titleap)
	UTF::Try "$STA channel selection" {
	     UTF::Try "channel 36" {
	        $STA wl chanspec 
                             }	
                                     }

UTF::Try "active state power management" {
 $STA  wl aspm
}

#UTF::Try "encryption key" {
#$STA wl addwep 
#}

UTF::Try "channel" {
$STA  wl channel
}

UTF::Try "channels" {
 $STA  wl channels
}

UTF::Try "$STA clock" {
  $STA  wl clk
	 
	 }


UTF::Try "Country" {
$STA wl country
}


UTF::Try "Country List" {
$STA wl country list
}


UTF::Try "Beacon Interval" {
  $STA wl bi
   
}
UTF::Try "chanspec" {
   $STA wl chanspec
}

UTF::Try "chanspecs" {
	$STA wl chanspecs
}

UTF::Try "current ethernet address" {
	$STA wl cur_etheraddr
}

#UTF::Try "current power" {
#	if{wl mpc=="1"} {
#		wl mpc 0
#		wl up
#		if{wl isup==1&&wl clk==1}
#			wl curpower
#	}
#	}
	
UTF::Try "device path" {
		$STA wl devpath
}

UTF::Try "service data unit" {
	$STA wl dump amsdu
}

UTF::Try "protocol data unit" {
	$STA wl dump ampdu
}

	
UTF::Try "$STA Channel Test 2g" {

	UTF::Try "$STA Channel 1" {
	$STA wl chanspec 1
	}
	UTF::Try "$STA Channel 2" {
	$STA wl chanspec 2
	}
	UTF::Try "$STA Channel 3" {
	$STA wl chanspec 3
	}
	UTF::Try "$STA Channel 4" {
	$STA wl chanspec 4
	}
	UTF::Try "$STA Channel 5" {
	$STA wl chanspec 5
	}
	UTF::Try "$STA Channel 6" {
	$STA wl chanspec 6
	}
	UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
	UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
	UTF::Try "$STA Channel 10" {
	$STA wl chanspec 10
	}
	UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}
	
	
	
	}
	
	
#if {[set perfchans $(chanspec)] eq "" &&
#	    [set perfchans [$STA cget -perfchans]] eq ""} {
#	    UTF::Try "$STA: Channel Selection" {
#		set perfchans [UTF::PerfChans $APS $STA]
#	    }
#	}
	
	
  
   
UTF::Try "$STA Channel Test 5g" {

 
 UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}

UTF::Try "$STA Channel 36" {
	$STA wl chanspec 36
	}
UTF::Try "$STA Channel 40" {
	$STA wl chanspec 40
	}
UTF::Try "$STA Channel 44" {
	$STA wl chanspec 44
	}
UTF::Try "$STA Channel 48" {
	$STA wl chanspec 48
	}
UTF::Try "$STA Channel 52" {
	$STA wl chanspec 52
	}
UTF::Try "$STA Channel 56" {
	$STA wl chanspec 56
	}
UTF::Try "$STA Channel 60" {
	$STA wl chanspec 60
	}
UTF::Try "$STA Channel 64" {
	$STA wl chanspec 64
	}
UTF::Try "$STA Channel 100" {
	$STA wl chanspec 100
	}
UTF::Try "$STA Channel 104" {
	$STA wl chanspec 104
	}
UTF::Try "$STA Channel 108" {
	$STA wl chanspec 108
	}
UTF::Try "$STA Channel 112" {
	$STA wl chanspec 112
	}
UTF::Try "$STA Channel 116" {
	$STA wl chanspec 116
	}
UTF::Try "$STA Channel 120" {
	$STA wl chanspec 120
	}
UTF::Try "$STA Channel 124" {
	$STA wl chanspec 124
	}
UTF::Try "$STA Channel 128" {
	$STA wl chanspec 128
	}
UTF::Try "$STA Channel 132" {
	$STA wl chanspec 132
	}
UTF::Try "$STA Channel 136" {
	$STA wl chanspec 136
	}
UTF::Try "$STA Channel 140" {
	$STA wl chanspec 140
	}
UTF::Try "$STA Channel 149" {
	$STA wl chanspec 149
	}
UTF::Try "$STA Channel 153" {
	$STA wl chanspec 153
	}
UTF::Try "$STA Channel 157" {
	$STA wl chanspec 157
	}
UTF::Try "$STA Channel 161" {
	$STA wl chanspec 161
	}
UTF::Try "$STA Channel 165" {
	$STA wl chanspec 165
	}

}
      UTF::Try "$STA BANDS" {
	      UTF::Try "$STA BANDS" {
	         $STA 	wl bands }
	           UTF::Try "$STA BAND RANGE" {
	              $STA wl band_range
	            }
			UTF::Try "$STA BANDS" {
			$STA wl isup
	         $STA 	wl band }
	    }
	UTF::Try "$STA ASSOC_RETRY_MAX" {
			$STA wl assoc_retry_max
	} 
     UTF::Try "$STA CISDUMP" {
            $STA wl cisdump
}			
	
	UTF::Try "$STA channel selection" {
	     UTF::Try "channel 36" {
	        $STA wl chanspec 
                             }	
                                     }

UTF::Try "active state power management" {
 $STA  wl aspm
}

#UTF::Try "encryption key" {
#$STA wl addwep 
#}

UTF::Try "channel" {
$STA  wl channel
}

UTF::Try "channels" {
 $STA  wl channels
}

UTF::Try "$STA clock" {
  $STA  wl clk
	 
	 }


UTF::Try "Country" {
$STA wl country
}


UTF::Try "Country List" {
$STA wl country list
}


UTF::Try "Beacon Interval" {
  $STA wl bi
   
}
UTF::Try "chanspec" {
   $STA wl chanspec
}

UTF::Try "chanspecs" {
	$STA wl chanspecs
}

UTF::Try "current ethernet address" {
	$STA wl cur_etheraddr
}

#UTF::Try "current power" {
#	if{wl mpc=="1"} {
#		wl mpc 0
#		wl up
#		if{wl isup==1&&wl clk==1}
#			wl curpower
#	}
#	}
	
UTF::Try "device path" {
		$STA wl devpath
}

UTF::Try "service data unit" {
	$STA wl dump amsdu
}

UTF::Try "protocol data unit" {
	$STA wl dump ampdu
}

	
UTF::Try "$STA Channel Test 2g" {

	UTF::Try "$STA Channel 1" {
	$STA wl chanspec 1
	}
	UTF::Try "$STA Channel 2" {
	$STA wl chanspec 2
	}
	UTF::Try "$STA Channel 3" {
	$STA wl chanspec 3
	}
	UTF::Try "$STA Channel 4" {
	$STA wl chanspec 4
	}
	UTF::Try "$STA Channel 5" {
	$STA wl chanspec 5
	}
	UTF::Try "$STA Channel 6" {
	$STA wl chanspec 6
	}
	UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
	UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
	UTF::Try "$STA Channel 10" {
	$STA wl chanspec 10
	}
	UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}
	
	
	
	}
	
	
#if {[set perfchans $(chanspec)] eq "" &&
#	    [set perfchans [$STA cget -perfchans]] eq ""} {
#	    UTF::Try "$STA: Channel Selection" {
#		set perfchans [UTF::PerfChans $APS $STA]
#	    }
#	}
	
	
  
   
UTF::Try "$STA Channel Test 5g" {

 
 UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}

UTF::Try "$STA Channel 36" {
	$STA wl chanspec 36
	}
UTF::Try "$STA Channel 40" {
	$STA wl chanspec 40
	}
UTF::Try "$STA Channel 44" {
	$STA wl chanspec 44
	}
UTF::Try "$STA Channel 48" {
	$STA wl chanspec 48
	}
UTF::Try "$STA Channel 52" {
	$STA wl chanspec 52
	}
UTF::Try "$STA Channel 56" {
	$STA wl chanspec 56
	}
UTF::Try "$STA Channel 60" {
	$STA wl chanspec 60
	}
UTF::Try "$STA Channel 64" {
	$STA wl chanspec 64
	}
UTF::Try "$STA Channel 100" {
	$STA wl chanspec 100
	}
UTF::Try "$STA Channel 104" {
	$STA wl chanspec 104
	}
UTF::Try "$STA Channel 108" {
	$STA wl chanspec 108
	}
UTF::Try "$STA Channel 112" {
	$STA wl chanspec 112
	}
UTF::Try "$STA Channel 116" {
	$STA wl chanspec 116
	}
UTF::Try "$STA Channel 120" {
	$STA wl chanspec 120
	}
UTF::Try "$STA Channel 124" {
	$STA wl chanspec 124
	}
UTF::Try "$STA Channel 128" {
	$STA wl chanspec 128
	}
UTF::Try "$STA Channel 132" {
	$STA wl chanspec 132
	}
UTF::Try "$STA Channel 136" {
	$STA wl chanspec 136
	}
UTF::Try "$STA Channel 140" {
	$STA wl chanspec 140
	}
UTF::Try "$STA Channel 149" {
	$STA wl chanspec 149
	}
UTF::Try "$STA Channel 153" {
	$STA wl chanspec 153
	}
UTF::Try "$STA Channel 157" {
	$STA wl chanspec 157
	}
UTF::Try "$STA Channel 161" {
	$STA wl chanspec 161
	}
UTF::Try "$STA Channel 165" {
	$STA wl chanspec 165
	}

}
   


    update_summaries close

    
    # If requested, unload the driver.
    if {!$(nounload) && !$(noinit)} {
        UTF::Try "$STA: unload driver" {
            $STA unload
        }

	if {$(musta) != ""} {
	    foreach MUSTA $(musta) {
	    	UTF::Try "$MUSTA: unload driver" {
		    $MUSTA unload
		}
	    }
	}
    }
    catch {$STA deinit}

    if {$(musta) != ""} {
	foreach MUSTA $(musta) {
	    catch {$MUSTA deinit}
	}
    }
 }
#============== proc setup_summaries ================================
# Proc setup_summaries initialize summary web pages and related 
# global variables.
#====================================================================
proc setup_summaries {AP STA titleap } {

    # Get testrig name
    UTF::setup_config_testrig


}

#============== proc update_summaries ===============================
# # Proc for updating summary web pages
#====================================================================
proc update_summaries {cmd args} {
    UTF::Message LOG $::localhost "update_summaries cmd=$cmd args=$args"
        
    # If necessary, log the device info on all summary files.
    # For cmd=ver, args are: device name, softap flag, titleap flag
    if {$cmd == "ver"} {
        set device [lindex $args 0]
        set softap [lindex $args 1]
        set titleap [lindex $args 2]

        # Get hardware info & clean it up.
        set hw_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set hw_ver "OEM"
        } else {
            set catch_resp [catch "set hw_ver \[$device whatami\]" catch_msg]
            if {[llength $hw_ver] > 1} {
                set hw_ver [lrange $hw_ver 1 end] ;# drop UTF object name
            }
        }
        regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification

        # Get host OS version
        set os_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set os_ver "OEM"
        } else {
            set catch_resp [catch "set os_ver \[UTF::check_host_os $device\]" catch_msg]
        }

        # Get driver software version
        set wl_ver ""
        if {$titleap} {
            if {$::is_oem_ap == 1} {
               set wl_ver "OEM"
            } else {
                if {$softap} {
                    # Soft AP
                    set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
                } else {
                    # Real AP
                    set catch_resp [catch "set wl_ver \[$device nvram get os_version\]" catch_msg]
                }
            }
        } else {
            # STA
            set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
        }

        # Add device info to each summary page
        UTF::Message LOG $::localhost  "hw_ver=$hw_ver os_ver=$os_ver wl_ver=$wl_ver"
       
        return
    }

    # If necessary, close all the summary files

    # Code for cmd=start|end

}

#============== Main wl_check test ===============================
UTF::Test wl_check {args} {
      UTF::Getopts "$::wl_check_getopts" "$::wl_check_help"
	set ::loop1_counter 0

	



    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }


    # noinit implies nosetup. nosetup is for this script only.
    # noinit is passed to aci1fidha.test & has broader impact than nosetup.
    if {$(noinit)} {
        set (nosetup) 1
    }

    # Router could be a STA running softap code.
    set Router [lindex $(ap) 0]
    if {$(softap)} {
        # Dynamically set -ap flag so Router will be allowed to act as SoftAP.
        $Router configure -ap 1
    }
    set (softap) [UTF::is_softap $Router] ;# Is this a SoftAP?
    set ::is_oem_ap [UTF::is_oem_ap $Router] ;# Is this an OEM AP?
    # puts "(softap)=$(softap) ::is_oem_ap=$::is_oem_ap"

    set (sta) [string trim $(sta)]
    if {$(sta) == ""} {
        error "ERROR: Must specify at least one sta"
    }


	



    foreach STA $(sta) {
        # puts "STA=$STA"
    
            UTF::check_sta_type $STA $::sta_type_list

        if {$STA == $Router} {
            error "ERROR: Router=$Router EQ STA=$STA, need to use 2 different devices!"
        }
    }

    # If developer images were specified, they take precedance over tag & date.
    # Router options.
    foreach Router $(ap) {
    	if {$::is_oem_ap == 0} {
            if {$(trx) ne ""} {
            	$Router configure -image $(trx) -date {}
            } elseif {$(tag) != ""} {
            	# tag is depracated, prefer rtrtag.
             	$Router configure -tag $(tag) -date {}
            } elseif {$(rtrtag) != ""} {
            	$Router configure -tag $(rtrtag) -date {}
            }
    	}
    }

    # STA options
    foreach STA $(sta) {
        if {$(bin) != ""} {
            $STA configure -image $(bin) -date {}
        } elseif {$(statag) != ""} {
            $STA configure -tag $(statag) -date {}
        }

        # dhd_image option applies only to the DHD objects.
        if {$(stadhd) ne ""} {
            if {[UTF::check_host_type $STA DHD]} {
                $STA configure -dhd_image $(stadhd)
            }
        }
    
        # dongleimage option applies only to the WinDHD object.
        if {$(windhdbin) ne ""} {
            if {[UTF::check_host_type $STA WinDHD]} {
                $STA configure -dongleimage $(windhdbin)
            }
        }
    }

    # Depracated date will override newer rtrdate & stadate options.
    # Done for backwards comptibility.
    if {$(date) != ""} {
        set (rtrdate) $(date)
        set (stadate) $(date)
    }

    # Add optional dates.
    if {$(rtrdate) != "" && $::is_oem_ap == 0} {
	foreach Router $(ap) {
            $Router configure -date $(rtrdate)
    	}
    }
    if {$(stadate) != ""} {
        foreach item $(sta) {
            $item configure -date $(stadate)
        }
    }

    # Get build name for use in report email subject.
    # When multiple STA are tested, they USUALLY use the same build.
    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(sta) 0]
    }   
    if {[set build [$item cget -image]] eq ""} {
        set build [$item cget -tag]
    }
    if {$build eq "NIGHTLY"} {
        set build "TOT"
    }

    # (branch) is used for comparison over time. For private builds
    # this should be specified explicitly so the tests know which
    # branch to test. (branch) defaults to auto.
    if {$(branch) eq ""} {
        if {[regexp {/} $build]} {
            error "Unable to determine branch name from build.  Please specify -branch"
        }
        set (branch) $build
    }

    # Truncate branch name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # aci1fidha.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list $build
    }

    # This script may be nested inside another higher level script. In this
    # case, setup_testbed_info may have already been run. It is also possible
    # that the lists of devices has been pared down to reduce the items being
    # tested. So we need to be careful and not modify the preparations made
    # by the higher level script.
    if {[info exists ::endpoint_device_list] &&\
        [info exists ::lan_peer_sta_list] &&\
        [info exists ::wan_peer_sta_list]} {
        UTF::Message INFO "" "using existing setup_testbed_info"
        if {![info exists ::UTF::trailer_info]} {
            set ::UTF::trailer_info "<br>Missing testbed info!<br>"
        }
    } else {
        UTF::Message INFO "" "running setup_testbed_info"
        set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]
    }

    # Create empty summary table. If there is a higher level calling script,
    # UTF will keep the existing summary table & related object and ignore
    # this script.
    set ::summaryinfo [UTF::setup_report_table]
    append ::summaryinfo "</table>"

    set email_subject [UTF::setup_email_subject $(title)]
    UTF::Message INFO "$::localhost" "email_subject=$email_subject"

    # Main test report web page starts here.
    UTF::WrapSummary $UTF::SummaryDir $email_subject $::summaryinfo $(email) {

        set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

        # Add a web link to the test.log file
        UTF::Try "Link to test.log" {
            return "html: <a href=\"./test.log\">test.log</a>"
        }

	# For comparison test, add additional web link to composite graph page for quick access purpose
	# The empty .htm file will be symlinked to the real file later 



        # Setup testbed. Some users may turn off AP radios!!!
        if {!$(noinit) && !$(nosetup)} {
            UTF::setup_testbed
        }

        # UTF::Message LOG "" "pid=[pid]"

        # Set router text msg.
        if {$(softap)} {
            set msg "SoftAP"
        } else {
            set msg "Router"
        }

        # restoreaponly implies noapload
        if {$(restoreaponly)} {
            set (noapload) 1
        }

        # For AP and STA comparison tests 
        set ::saved_ResultsFilenames ""
        set ::file_appended 0
        set ::sta_counter 0
	set ::ap_counter 0

	


        foreach AP $(ap) {
	    UTF::Message LOG $::localhost "ap=$AP"
	    set Router $AP
	    # User may want testbed used as is.
            if {!$(noinit) && !$(nosetup) && $::is_oem_ap == 0} {
            	catch "$Router power on"
            	if {!$(noapload)} {
                    set catch_msg ""

                    UTF::Try "$Router Find $msg Image" {
                    	set catch_resp [catch {$Router findimages} catch_msg]
                    	$Router configure -image $catch_msg ;# needed for updating title
                    	if {$catch_resp == 0} {
                            return $catch_msg
                    	} else {
                            error $catch_msg
                    	}
                    }

                    # Add report summary table row for Router.
                    set id [UTF::get_build_id $catch_msg]
                    set notes [UTF::get_build_notes $catch_msg]
                    set status [UTF::get_build_status $catch_msg $catch_resp]
                    set ::summaryinfo [UTF::update_report_add $::summaryinfo $Router $(trx) $(rtrtag) $(rtrdate) $id $notes $status]

                    # Halt tests if AP image not found.
                    # Throwing error outside UTF::Try causes framework error.
                    if {$catch_resp != 0} {
                    	UTF::Try "Could not find $msg Image" {
                            error "Halting tests"
                    	}
                    	error "Halting tests"
                    }

                    UTF::Try "$Router Load $msg Image" {
                    	if {$(softap)} {
                            # SoftAP
                            set catch_resp [catch {UTF::load_sta_retry $Router} catch_msg]
                    	} else {
                            # RealAP, may skip restoring AP defaults.
                            if {$(norestore)} {
                            	set catch_resp [catch {UTF::load_rtr_retry $Router -norestore} catch_msg]
                            } else {
                            	set catch_resp [catch {UTF::load_rtr_retry $Router} catch_msg]
                            }
                        }
                        if {$catch_resp != 0} {
                            error $catch_msg
                    	}
                    	return "[$Router whatami] $catch_msg"
                    }

                    # Halt tests if AP not loaded. AP may have recovered or loaded OK on the retry.
                    # Throwing error outside UTF::Try causes framework error.
                    # set catch_resp 1 ;# test code
                    if {$catch_resp != 0 && ![string match -nocase "*try*pass:*" $catch_msg] &&\
                    	![regexp -nocase "removed.*rebooting" $catch_msg] &&\
                    	![regexp -nocase "devcon.*completed" $catch_msg] && \
                    	![regexp -nocase "recovered" $catch_msg]} {
                    	UTF::Try "Could not load $msg Image" {
                            UTF::Message LOG "$Router" "catch_resp=$catch_resp catch_msg=$catch_msg"
                            error "Halting tests"
                    	}
                        error "Halting tests"
                    }

                    # Update the report header table with actual OS & hw versions.
                    set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

                    # Update report title with actual TAG numbers
                    UTF::update_report_title $Router

            	} elseif {!$(restoreaponly)} {
                    # Reload the AP
                    UTF::Try "$Router Reload $msg" {
                    	if {$(softap)} {
                            UTF::reload_sta $Router
                    	} else {
                            UTF::reload_rtr $Router
                    	}
                    }
                } 

                # If router is not responding, halt the tests.
                # This command works for RealAP & SoftAP.
                set catch_resp [catch "set resp \[$Router wl ver\]" catch_msg]
                if {$catch_resp != 0} {
                    error "$Router not responding, Halting tests! $catch_msg"
            	}
            }

            # Show AP hardware, same as we do for STA.
            UTF::Try "$Router $msg Hardware" {
            	if {$::is_oem_ap == 0} {
                    set hw_ver [$Router chipname]
            	} else {
                    set hw_ver OEM
            	}
            	regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
            	return $hw_ver
            }


            # Test each STA in list.
       
		# This is regular test and we loop through each STA.
            	foreach STA $(sta) {
            	    setup_summaries $Router $STA $(titleap) \
                    	
            	    # Call proc main_rvr_nightly1 for each STA
     	    	    main_rvr_nightly1 $Router $STA

	    	    incr ::sta_counter
            	}
	

	    incr ::ap_counter

            # Unload softap driver if necessary.
            if {$(softap) && !$(nounload) && !$(noinit)} {
            	UTF::Try "$Router: unload driver" {
                    $Router unload
                }
            }
	} ;# end of foreach AP
	#for the rate loop
	   incr ::loop1_counter
	}
	

set ::summaryinfo [UTF::update_report_testtime $::summaryinfo]
	# Posting to dbux
    	if {!$(nodbuxpost)} {
            UTF::Try "Post test info to dbux" {
            	if {$(bin) != ""} {
                    UTF::post_to_dbux $STA 1
            	} else {
                    UTF::post_to_dbux $STA 0
            	}
            }
        }

# Do optional post test analysis. The "" passes the unnamed options array.
UTF::do_post_test_analysis wl_check.test ""
}
 
}
