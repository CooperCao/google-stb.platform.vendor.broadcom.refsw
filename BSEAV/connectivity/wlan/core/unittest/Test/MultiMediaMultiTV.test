#!/bin/env utf
# -*-tcl-*-
#

#
# UTF test script for Multicast/Multimedia Functionality and performance
# testing
#
# Written by: Robert J. McMahon March 2010
#
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Multicast
package require UTF::Streams
package require UTF::ControlChart
package require UTF::IGMPQuerier
package require UTF::Test::WET
package require UTF::Test::controlchart
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::McastJoinLeave
package require UTF::Test::ConfigBridge
package require UTF::Test::BridgeCheck
package require UTF::Test::MulticastLinkcheck
package require UTF::MemChart
package require UTF::Test::DeviceMode

namespace eval UTF::Test {
    variable snifferror
}
proc ::UTF::Test::sniffer_check {stream sta line} {
    if {[$stream cget -transmitsta] ne "$sta" && [regexp {([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) > 224.0.0.2:\s+igmp leave} $line - srcip]} {
	if {[eval $sta ipaddr] ne $srcip} {
	    UTF::Message ERROR "" "IGMP LEAVE from $srcip seen on unexpected interface $sta"
	    set ::UTF::Test::snifferror 1
	}
    }
}

#    {security.arg "open tkippsk2 aespsk2 aespsk2+tkippsk2" "Securities to test"}
UTF::Test MultiMediaMultiTV {args} {
    UTF::Getopts {
	{ap.arg "" "Upstream AP under test"}
	{date.arg "" "Image date"}
	{brand.arg "" "Brand override"}
	{wetbrand.arg "" "Brand override"}
	{trx.arg "" "Router trx"}
	{tag.arg "" "Router release tag"}
	{email.arg "" "Email Address"}
	{title.arg "" "Title"}
	{noload "Don't load images"}
	{wetaps.arg "" "Downstream AP(s) in WET mode under test"}
	{nocache "Don't update performance cache"}
	{branch.arg "" "Branch override"}
        {history.arg 30 "History size for control charts"}
	{perfloop.arg 1 "Performance test loops"}
	{security.arg "open aespsk2" "Securities to test"}
	{chanspec.arg "36/80 157l" "Chanspecs to test"}
	{udprate.arg "25M" "UDP rate of stream"}
	{pspretendrate.arg "20M" "UDP rate of of pspretend stream"}
	{holdtime.arg "10" "time between attenuation steps"}
	{recovermultiple.arg "2" "holdtime multiple for recover state"}
	{stepcount.arg "15" "number of attenuation steps"}
	{togglecount.arg "3" "number of toggles"}
	{debugging "Working in a debugging mode"}
	{stop "stop at error for manual debugging"}
	{baserssi.arg "43" "Set the baseline rssi"}
	{disabletrafficshape ""}
	{numactivestreams.arg "4" "The number of simultaneous streams to test"}
	{shortholdtime.arg "5.0" "Quick hold time"}
	{longholdtime.arg "90.0" "Long hold time"}
	{nowettunnel "test with wet_tunnel feature enabled"}
	{noctf "test with ctf feature disabled"}
	{nopspretend "Disable pspretend"}
	{pstamedia "set PSTA to media defaults"}
	{tos.arg "" "override tos"}
    }

    variable snifferror

    if {$(debugging)} {
	set debug_notice_color "Blue"
	set debug_warn_color "Red"
	append UTF::SummaryDir "-debugging"
    }

    proc set_rssi {device value} {
	set attnchannel [$device cget -attngrp]
	$attnchannel attn 0
	UTF::Sleep 1.0
	set rssi [expr {abs([$device wl rssi])}]
	if {$rssi == 0} {
	    UTF::Message WARN $device "Unexpected RSSI of zero - adjusting to -20 dB"
	    set rssi 20
	}
	set attn [expr {$value - $rssi}]
	if {$attn < 0} {
	    set attn 0
	}
	if {$attn > 103} {
	    set attn 103
	}
	if {[info exist ::afmaxattn] && $attn > $::afmaxattn} {
	    set attn $::afmaxattn
	}
	$attnchannel attn $attn
	UTF::Sleep 1.0
	set rssi [$device wl rssi]
	UTF::Message INFO $device "Adding $attn dB path loss, rssi = $rssi"
	return [list $attn $rssi]
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    set AP $(ap)
    set BRIDGES $(wetaps)

    set defchanspec [lindex $(chanspec) 0]

    set Routers [concat $(ap) $(wetaps)]

    # Override default tags
    if {$(trx) ne ""} {
	foreach Router $Routers {
	    $Router configure -image $(trx) -date {}
	}
    } elseif {$(tag) ne ""} {
	foreach Router $Routers {
	    $Router configure -tag $(tag) -date {}
	}
    }

    foreach wet $(wetaps) {
	if {$(wetbrand) ne ""} {
	    $wet configure -brand $(wetbrand)
	} elseif {$(brand) ne ""} {
	    $wet configure -brand $(brand)
	}
	lappend cckey_common "${wet}=[$wet cget -brand]"
    }
    if {$(brand) eq ""} {
	lappend cckey_common [$(ap) cget -brand]
    } else {
	$(ap) configure -brand $(brand)
	lappend cckey_common $(brand)
    }

    if {$(date) ne ""} {
	set date $(date)
	foreach router $Routers {
	    $router configure -date $(date)
	}
    } else {
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
    }

    foreach wet $(wetaps) {
	set brand [$wet cget -brand]
	if {![regexp {media} $brand] && [regexp {external} $brand]} {
	    # append brand "-combo"
	}
	$wet configure -brand $brand
    }

    # Compact build list for title
    # Include the WDS list, in case the AP list is empty.  Duplicates
    # will be removed automatically.
    set build [UTF::BuildTitle $Routers]
    if {!$(nowettunnel)} {
	set TITLE "UTF MultiMediaMultiTV $(title) ($build) bridge"
    } else {
	set TITLE "UTF MultiMediaMultiTV $(title) ($build) no wet_tunnel"
    }
    UTF::Message INFO "" $TITLE
    # $build is used in the title.  For private builds this will
    # indicate special images.
    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.
    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # Set attenuator bounds
    if {[info exists ::afmaxattn]} {
	set AFMAXATTN $::afmaxattn
    } else {
	set AFMAXATTN 103
    }
    set AFMINATTN 0
    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]
	if {[info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		catch {unset ::ramseyreboot}
		eval $::UTF::SetupTestBed
	    }
	}
	UTF::Try "IGMP setup" {
	    foreach dut [concat $AP $BRIDGES] {
		UTF::Multicast::force_igmp_version [$dut lan] 2
	    }
	    UTF::Multicast::force_igmpq_cleanup [$(ap) lan]
	}
	UTF::Try "Read attns" {
	    set rc ""
	    foreach device $BRIDGES {
		set ch [$device cget -attngrp]
		set x [lindex [$ch attn?] 0]
		set restoreattn($device) $x
		lappend rc "${ch}=$x"
	    }
	    return $rc
	}
	if {!$(noload)} {
	    foreach Router $Routers {
		UTF::Try "[$Router cget -name]: Find Router Image" {
		    set date [$Router cget -date]
		    if {$date eq ""} {
			set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
		    }
		    UTF::CheckImage $Router $date unknown
		}
		UTF::Try "[$Router cget -name]: Load Image" {
		    $Router load
		}
		UTF::Try "[$Router cget -name]: Restore Defaults" {
		    $Router restore_defaults
		    UTF::Try "[$Router cget -name]: Device Mode 1" {
			UTF::Test::DeviceMode -ap $Router -mode 1
		    }
		    set what [$Router whatami]
		    $Router dbrecord DUT
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $Router $ret
		    }
		    set what
		}
	    }
	}
	UTF::Try "Enable IGMP Querier (streams)" {
	    #
	    #  Setup the multicast video stream and start the igmp querier
	    #
	    set videostream [::UTF::stream create hdvideo -traffictype HDVIDEO -tx $(ap) -rx $(wetaps) -multicast 1]
	    # Override default HDVIDEO UDP rate with script rate
	    $videostream configure -rate $(udprate)
	    if {$(tos) ne {} } {
		$videostream configure -tos $(tos)
	    }
	    $(ap) igmp_querier enable
	    if {$(disabletrafficshape)} {
		catch {$(ap) wl scb_videotag_auto 0}
		UTF::Message INFO $(ap) "Disabling media traffic shaping"
	    } else {
		catch {$(ap) wl scb_videotag_auto 0}
		UTF::Message INFO $(ap) "Enabling media traffic shaping"
	    }
	}
	set currentsecurity ""
	if {$(pstamedia)} {
	    set WEMFTXT "(1/0)"
	} else {
	    set WEMFTXT "(1/1)"
	}
	foreach chanspec $(chanspec) {
	    foreach security $(security) {
		UTF::Try "BR WMF/EMF ${WEMFTXT} CH=$chanspec SECURITY=$security" {
		    UTF::stream allstreams stop
		    UTF::Test::ConfigBridge -ap $AP -br $BRIDGES -security $security -chanspec $chanspec -linkcheck -proxysta
		    UTF::Try "Config WMF/EMF ${WEMFTXT}" {
			foreach dut [concat $AP $BRIDGES] {
			    set needreboot($dut) 0
			    if {$dut ne $AP && $(pstamedia)} {
				set setting 0
			    } else {
				set setting 1
			    }
			    if {[UTF::Multicast::test_emf $dut] ne "$setting"} {
				append testnvram($dut) "emf_enable=$setting "
				set needreboot($dut) 1
			    }
			    # Multicast traffic needs to be tunneled over unicast
			    # Use wmf if supported else use the WDS tunnel
			    # (via lazywds, which is a BRCM only feature)
			    if {[catch {$dut wl wmf_bss_enable} res]} {
				if {![$dut nvram get wl_lazywds]} {
				    append testnvram($dut) "wl_lazywds=1 [$dut wlname]_lazywds=1"
				}
			    } else {
				if {[$dut nvram get wl_wmf_bss_enable] ne "$setting"} {
				    append testnvram($dut) "wl_wmf_bss_enable=$setting "
				}
				if {[$dut nvram get "[$dut wlname]_wmf_bss_enable"] ne "$setting"} {
				    append testnvram($dut) "[$dut wlname]_wmf_bss_enable=$setting "
				}
			    }
			}
			if {[array exists testnvram]} {
			    foreach dut [array names testnvram] {
				if {$needreboot($dut)} {
				    eval [concat $dut reboot $testnvram($dut)]
				} else {
				    eval [concat $dut restart $testnvram($dut)]
				}
			    }
			    UTF::Test::BridgeCheck -ap $AP -br $BRIDGES
			}
		    }
		    # RJM fix this and find out why needed
		    foreach BRIDGE $BRIDGES  {
			$BRIDGE reboot
		    }
		    UTF::Test::MulticastLinkcheck -ap $AP -sta $BRIDGES -wlpktdebug
		    return "${chanspec}, $security"
		}
		UTF::Try "PM mode 0" {
		    foreach dut [concat $(ap) $(wetaps)] {
			$dut wl -u PM 0
		    }
		}
		if {$security eq [lindex $(security) 0]} {
		    #
		    # Invoke Join/Leave test
		    #
		    foreach rx $BRIDGES {
			set cckey [list $cckey_common $security $(branch) [$rx cget -lanpeer] "wet"]
			UTF::Test::McastJoinLeave -ap $AP -sta $rx -key $cckey
		    }
		}
		UTF::Try "Dissimiliar Attenuator/RSSI setup" {
		    $videostream configure -rate $(udprate)
		    $videostream start
		    $videostream stats -clear
		    $(ap) igmp_querier enable
		    $(ap) igmp_querier send
		    L1 attn?; L2 attn?; L3 attn?; L4 attn?
		    UTF::Sleep 10
		    set rc ""
		    catch {unset x}
		    foreach device [lrange $BRIDGES 0 end-2] {
			set x [set_rssi $device $(baserssi)]
			set baseattn [lindex $x 0]
		    }
		    if {[info exists x]} {
			lappend rc "[join $x /]"
		    }
		    set attndevice [lindex $BRIDGES end-1]
		    set x [set_rssi $attndevice [expr {$(baserssi) + 18}]]
		    set startattn [lindex $x 0]
		    lappend rc "[join $x /]"
		    set attndevice [lindex $BRIDGES end]
		    set x [set_rssi $attndevice [expr {$(baserssi) + 28}]]
		    $videostream user_event "a"
		    lappend rc "[join $x /]"
		    set startattn [lindex $x 0]
		    set endattn [expr {$startattn + $(stepcount)}]
		    if {[info exists ::afmaxattn] && $endattn > $::afmaxattn} {
			set endattn $::afmaxattn
		    }
		    UTF::Sleep 10
		    # return $rc
		    return [$videostream plot]
		}
		UTF::Test::BridgeCheck -ap $AP -br $BRIDGES
		UTF::Test::MulticastLinkcheck -stream $videostream -wlpktdebug
		if {!$(nopspretend)} {
		    set pspretends "0 5"
		} else {
		    set pspretends "default"
		}
		foreach pspretend $pspretends {
		    UTF::Try "PSPretend=$pspretend MCAST=$(pspretendrate)" {
			UTF::stream allstreams stop
			if {[string is integer $pspretend]} {
			    $(ap) wl pspretend_retry_limit $pspretend
			    foreach rxdut [$videostream cget -rx] {
				$(ap) wl pktq_stats a:[$rxdut macaddr]
			    }
			}
			$videostream configure -rate $(pspretendrate)
			$videostream start
			$videostream linkcheck -now
			$videostream stats -clear
			if {[string is integer $pspretend]} {
			    set ix 0
			    foreach rxdut [$videostream cget -rx] {
				incr ix
				after [expr {$ix * 5000}] "$rxdut wl -u suspend_mac 150; $(ap) wl pktq_stats a:[$rxdut macaddr]"
				after [expr {30000 + ($ix * 5000)}] "$rxdut wl -u suspend_mac 150"
			    }
			}
			UTF::Sleep 60
			$videostream samplers -disable
			if {[string is integer $pspretend]} {
			    foreach rxdut [$videostream cget -rx] {
				$(ap) wl pktq_stats a:[$rxdut macaddr]
			    }
			}
			set rssistring ""
			foreach down $BRIDGES {
			    lappend rssistring "$down/[$down wl rssi]dB"
			}
			set sg [[UTF::streamgraph %AUTO% -streams $videostream -stat rate -title "Rate = $(udprate) $chanspec Security=$security $rssistring" -yticsynch 1 -graphsize "1024,768"] plot]
			set lg [[UTF::streamgraph %AUTO% -stat lost -streams $videostream -title "Lost Rate = $(pspretendrate) Security=$security $rssistring" -yticsynch 1 -graphsize "1024,768" -with "impulses"] plot]
			set results "$sg [string range $lg 5 end]"
			if {$pspretend && [$videostream stats -lost -sum] > 0} {
			    error $results
			} else {
			    return $results
			}
		    }
		    # Create the control charts (bytes)
		    set bytestats [$videostream stats -bytes -sum]
		    foreach bytestat $bytestats {
			set rx [lindex $bytestat 0]
			set bytes [lindex $bytestat 1]
			UTF::Try "MCAST Video RxBytes ($rx time=$(holdtime)s)" {
			    set cckey [list $cckey_common $(branch) $rx "WET" $(holdtime) "mcast_3str" "$rx" $security $(udprate) rxbytes]
			    set cc [UTF::MemChart %AUTO% -s 5 -key $cckey -history $(history) -perfcache "" -title "Bytes Xfer $rx $(holdtime)s" -units "Bytes"]
			    set boundsresults [$cc addsample $bytes]
			    set chart [$cc plotcontrolchart $boundsresults]
			    if {![regexp {(LOW|WIDE|ZERO)} $boundsresults]} {
				return "$chart"
			    } else {
				error "$chart"
			    }
			}
		    }
		}
	    }
	    $videostream configure -rate $(udprate)
	    UTF::Try "Simultaneous mcast (activestreams=$(numactivestreams))" {
		$videostream stop
		# Create streams for testing
		set numstreams 100
		if {$(numactivestreams) > $numstreams} {
		    set numstreams [expr {$(numactivestreams) + 10}]
		}
		for {set ix 0} { $ix < $numstreams} {incr ix} {
		    set teststreams($ix) [UTF::stream %AUTO% -traffictype HDVIDEO -rx $(wetaps) -tx $(ap) -multicast on -clearsynch on]
		}
		if {[UTF::Multicast::test_rtport_empty $(ap)]} {
		    $(ap) igmp_querier send
		    UTF::Sleep 1.0
		    $(ap) igmp_querier send
		    if {[UTF::Multicast::test_rtport_empty $(ap)]} {
			error "$(ap) not learning RTPORT"
		    }
		}
		set testerr 0
		set chlist ""
	        set streamlist {}
		for {set ix 0} { $ix < $(numactivestreams)} {incr ix} {
		    while {1} {
			set ch [expr int(rand() * $numstreams) + 1]
			if {[lsearch $chlist $ch] eq "-1"} {
			    break
			}
		    }
		    set expgrpip [$teststreams($ch) cget -dstgrpip]
		    set hexaddr [UTF::Multicast::ip2x $expgrpip]
		    foreach rx $BRIDGES {
			UTF::Multicast::force_mcast_iperf_cleanup [$rx lan] $expgrpip
		    }
		    if {![catch {UTF::Multicast::test_emfdb_add $(ap) $expgrpip} err]} {
			UTF::Message ERROR $(ap) "EMFDB stale entry for $expgrpip (${hexaddr}) $err"
			set testerr 1
		    }
		    $teststreams($ch) start
		    lappend chlist $ch
		    lappend streamlist $teststreams($ch)
		}
		UTF::Sleep 1.0
		foreach stream $streamlist {
		    set expgrpip [$stream cget -dstgrpip]
		    if {[catch {UTF::Multicast::test_emfdb_add $(ap) $expgrpip}]} {
			set hexaddr [UTF::Multicast::ip2x $expgrpip]
			UTF::Message ERROR $(ap) "EMFDB missing entry for $expgrpip (${hexaddr})"
			set testerr 1
		    }
		}
		# get the multicast rx counters on the WET bridges
		foreach sta $BRIDGES {
		    set mcast_rxa($sta) [UTF::Multicast::rxcounter $sta]
		}
		set timea [clock clicks -milliseconds]
		UTF::stream allstreams stats -clear
		UTF::Sleep $(longholdtime)
		foreach stream $streamlist {
		    set mcastrxbytes [$stream stats -bytes -sum]
		    set txbytes [$stream  stats -txbytes -sum]
		    set tstmsg ""
		    foreach mcastrxbyte $mcastrxbytes {
			UTF::Message INFO [namespace tail $stream] $mcastrxbytes
			set rxbytes [lindex $mcastrxbyte 1]
			set loss [expr {int(( 100.0 * ($txbytes - $rxbytes)) / $txbytes)}]
			if {$txbytes > 0} {
			    if {$loss > 10 || $loss < -10}  {
				lappend errmsg "Single stream xfer error: loss=${loss}%"
				set testerr 1
			    } else {
				append tstmsg "loss = ${loss}% "
			    }
			}
		    }
		}
		# Get the counters again
		foreach sta $BRIDGES {
		    set mcast_rxb($sta) [UTF::Multicast::rxcounter $sta]
		}
		set timeb [clock clicks -milliseconds]
		# Use the last stream to get the pktsize
		set bitsps_scale [expr {int([$stream cget -pktsize] * 8 * 1000)}]
		# Some multicast traffic is expected
		set MCAST_DMAC_TOLERANCE 250000
		foreach sta $BRIDGES {
		    set mcast_rxbps [expr {(($mcast_rxb($sta) - $mcast_rxa($sta)) * $bitsps_scale) / ($timeb - $timea)}]
		    UTF::Message INFO $sta "MCAST DMAC rx rate = $mcast_rxbps"
		    if {$mcast_rxbps > $MCAST_DMAC_TOLERANCE} {
			set testerr 1
			UTF::Message ERROR $sta "MCAST DMAC rx rate = $mcast_rxbps too high"
			lappend errmsg "$sta = $mcast_rxbps "
		    }
		}
		set txload [lindex [$teststreams($ix) stats -txrate -meanminmax] 0]
		UTF::stream allstreams samplers -disable
		set rg [[UTF::streamgraph %AUTO% -stat rate -yticsynch 1 -graphsize "1024,768" -streams $streamlist -title "$(numactivestreams) active mcast (each $txload)"] plot]
		set lg [[UTF::streamgraph %AUTO% -stat lost -yticsynch 1 -graphsize "1024,768" -streams $streamlist -title "LOST $(numactivestreams) active mcast (each $txload)" -reporttext $tstmsg -with "impulses"] plot -append]
		set res "${rg}$lg"
		if {!$testerr} {
		    return $res
		} else {
		    error $res
		}
	    }
	    UTF::Try "EMFDB Deletes" {
		UTF::stream allstreams samplers -enable
		foreach stream $streamlist {
		    $stream configure -rxdisplay off -txdisplay off
		    $stream configure -sniff_callback "::UTF::Test::sniffer_check"
		}
		set snifferror 0
		set testerr 0
		set errmsg "EMFDB add/delete: "
		#
		# Stop the first  channel and make sure the entry is deleted
		#
		set stream [lindex $streamlist 0]
		$stream sniff on
		set expgrpip [$stream cget -dstgrpip]
		set hexaddr [UTF::Multicast::ip2x $expgrpip]
		if {[catch {UTF::Multicast::test_emfdb_add $(ap) $expgrpip}]} {
		    UTF::Message ERROR $(ap) "EMFDB missing entry for $expgrpip (${hexaddr})"
		    set testerr 1
		} else {
		    UTF::Message INFO $(ap) "EMFDB entry for $expgrpip (${hexaddr}) will be tested for delete"
		}
		$stream stop
		if {[catch {UTF::Multicast::test_emfdb_delete $(ap) $expgrpip}]} {
		    UTF::Message ERROR $(ap) "EMFDB delete error for $expgrpip (${hexaddr})"
		    foreach sta [$stream cget -receivesta] {
			catch {$sta rexec netstat --groups -n}
			set bridge [$sta cget -lanpeer]
			catch {UTF::Multicast::test_emfdb_delete $bridge $expgrpip}
		    }
		    set testerr 1
		    append errmsg "err del:$expgrpip ($hexaddr)"
		} else {
		    UTF::Message INFO $(ap) "EMFDB delete for $expgrpip (${hexaddr}) succeeded"
		}
		$stream sniff off
		# Make sure other entries remain
		foreach stream [lrange $streamlist 1 end] {
		    set expgrpip [$stream cget -dstgrpip]
		    set hexaddr [UTF::Multicast::ip2x $expgrpip]
		    if {[catch {UTF::Multicast::test_emfdb_add $(ap) $expgrpip}]} {
			UTF::Message ERROR $(ap) "EMFDB unexpected delete error for $expgrpip (${hexaddr})"
			set testerr 1
			append errmsg " unexepected delete"
			foreach sta [$stream cget -receivesta] {
			    catch {$sta rexec netstat --groups -n}
			    set bridge [$sta cget -lanpeer]
			    catch {UTF::Multicast::test_emfdb_delete $bridge $expgrpip}
			}
		    } else {
			UTF::Message INFO $(ap) "EMFDB no delete for $expgrpip (${hexaddr}) succeeded"
		    }
		}
		#
		# Stop the rest of the streams
		#
		foreach stream [lrange $streamlist 1 end] {
		    set expgrpip [$stream cget -dstgrpip]
		    set hexaddr [UTF::Multicast::ip2x $expgrpip]
		    if {[catch {UTF::Multicast::test_emfdb_add $(ap) $expgrpip}]} {
			UTF::Message ERROR $(ap) "EMFDB missing entry for $expgrpip (${hexaddr})"
			set testerr 1
			$stream stop
			continue
		    } else {
			UTF::Message INFO $(ap) "EMFDB entry for $expgrpip (${hexaddr}) will be tested"
			$stream sniff on
			$stream stop
		    }
		    UTF::Sleep 0.2
		    $stream sniff on
		    if {[catch {UTF::Multicast::test_emfdb_delete $(ap) $expgrpip}]} {
			UTF::Message ERROR $(ap) "EMFDB delete error for $expgrpip (${hexaddr})"
			set testerr 1
			foreach sta [$stream cget -receivesta] {
			    catch {$sta rexec netstat --groups -n}
			    set bridge [$sta cget -lanpeer]
			    catch {UTF::Multicast::test_emfdb_delete $bridge $expgrpip}
			}
		    } else {
			UTF::Message INFO $(ap) "EMFDB delete for $expgrpip (${hexaddr}) succeeded"
		    }
		}
		foreach stream $streamlist {
		    $stream configure -sniff_callback ""
		}
		if {$testerr || $snifferror} {
		    if {$snifferror} {
			append errmsg " unexpected leave"
		    }
		    error $errmsg
		}
	    }
	    UTF::Try "Multicast Video Link Toggling $(togglecount) times (rate=$(udprate))" {
		set rssivalues ""
		foreach down $BRIDGES {
		    set devrssi [$down wl rssi]
		    set attnchannel [$down cget -attngrp]
		    set attnvalue [lindex [$attnchannel attn?] 0]
		    set devattn [expr {int($attnvalue)}]
		    append rssivalues "$down (rssi=$devrssi attn=$devattn) "
		}
		set gtitle "Attenuating Toggles Holdtime = ${(holdtime)}s RecoverMultiple = $(recovermultiple) tshape: $(disabletrafficshape)"
		set gtitle "${rssivalues}\\n$gtitle"
		set rg [UTF::streamgraph %AUTO% -streams $videostream -stat rate -title "Multicast Thruput (TX rate = $(udprate))\\n$gtitle" -yticsynch 1 -graphsize "1024,768"]
		set lg [UTF::streamgraph %AUTO% -streams $videostream -stat lost -title "Multicast Lost (TX rate = $(udprate))\\n$gtitle" -graphsize "1024,768" -with "impulses"]
		set jg [UTF::streamgraph %AUTO% -streams $videostream -stat jitter -title "Multicast Jitter (TX rate = $(udprate))\\n$gtitle" -graphsize "1024,768" -yticsynch 1]
		expr srand(100)
		$videostream start
		$videostream stats -clear
		set starttime [UTF::stream clock]
		set events {}
		for {set ix 0} {$ix < $(togglecount)} {incr ix} {
		    set devselect [expr {int(rand() * [llength $BRIDGES])}]
		    set attndevice [lindex $BRIDGES $devselect]
		    set attnchannel [$attndevice cget -attngrp]
		    set defattn [expr {int([lindex [$attnchannel attn?] 0])}]
		    set highattn [expr {int($defattn + 45)}]
		    if {$highattn > $AFMAXATTN} {
			set highattn $AFMAXATTN
		    }
		    UTF::Message INFO $attndevice "Toggling attenuation $defattn $highattn"
		    $attnchannel attn $defattn
		    UTF::Sleep $(holdtime)
		    lappend events [list "a" [expr {[UTF::stream clock] - $starttime}]]
		    $attnchannel attn $highattn
		    UTF::Sleep $(holdtime)
		    lappend events [list "o" [expr {[UTF::stream clock] - $starttime}]]
		    $attnchannel attn $defattn
		}
		UTF::Sleep [expr {$(recovermultiple) * $(holdtime)}]
		$videostream stop
		UTF::Sleep $(holdtime)
		$videostream start
		UTF::Sleep $(holdtime)
		$videostream stop
		set tmp [$videostream stats -outoforder -meanminmax]
		$rg configure -title "[$rg cget -title] OutOrder=$tmp"
		$rg configure -xtics $events
		$lg configure -xtics $events
		$jg configure -xtics $events
		UTF::Message INFO $videostream [$videostream stats -rate]
		UTF::Message INFO $videostream [$videostream stats -lost]
		UTF::Message INFO $videostream [$videostream stats -jitter]
		UTF::Message INFO $videostream $tmp
		set resultlink "[$rg plot][$lg plot -append][$jg plot -append]"
		$videostream stats -clear
		$rg destroy; $lg destroy ; $jg destroy
		return $resultlink
	    }
	    UTF::Try "Multicast Video Weak Link RvR (rate=$(udprate))" {
		set rssivalues ""
		foreach down $BRIDGES {
		    set devrssi [$down wl rssi]
		    set attnchannel [$down cget -attngrp]
		    set attnvalue [lindex [$attnchannel attn?] 0]
		    set devattn [expr {int($attnvalue)}]
		    append rssivalues "$down (rssi=$devrssi attn=$devattn) "
		}
		set attndevice [lindex $BRIDGES end]
		set attnchannel [$attndevice cget -attngrp]
		set gtitle "Attenuating $attndevice (AttnRange = $startattn - $endattn) Holdtime = ${(holdtime)}s RecoverMultiple = $(recovermultiple)  tshape: $(disabletrafficshape)"
		set gtitle "${rssivalues}\\n$gtitle"
		set rg [UTF::streamgraph %AUTO% -streams $videostream -stat rate -title "Multicast Thruput (TX rate = $(udprate))\\n$gtitle" -yticsynch 1 -graphsize "1024,768"]
		set lg [UTF::streamgraph %AUTO% -streams $videostream -stat lost -title "Multicast Lost (TX rate = $(udprate))\\n$gtitle" -graphsize "1024,768" -with "impulses"]
		set jg [UTF::streamgraph %AUTO% -streams $videostream -stat jitter -title "Multicast Jitter (TX rate = $(udprate))\\n$gtitle" -graphsize "1024,768"]
		$videostream start
		$videostream stats -clear
		set events {}
		set starttime [UTF::stream clock]
		for {set ix $startattn} {$ix < $endattn} {incr ix} {
		    lappend events [list "s" [expr {[UTF::stream clock] - $starttime}]]
		    $attnchannel attn $ix
		    UTF::Sleep $(holdtime)
		}
		$attnchannel attn $startattn
		UTF::Sleep [expr {$(recovermultiple) * $(holdtime)}]
		$videostream stop
		UTF::Sleep $(holdtime)
		$videostream start
		UTF::Sleep $(holdtime)
		return "[$rg plot][$lg plot -append][$jg plot -append]"
	    }
	}
	UTF::Try "Exiting" {
	    UTF::stream exitstreams
	    $(ap) igmp_querier disable
	}
    }
}