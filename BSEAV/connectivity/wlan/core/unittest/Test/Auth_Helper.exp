#!/usr/bin/expect
 package require Expect

# Written by John Brearley, 2010

# This helper script is used by Authorize.test.
# For more info, type: Test/Authorize.test -h

#=================== get_data =================================================
# Gets the next interactive prompt for the expect data stream.
#
# Calling parameters: none
#
# Returns 1 of the strings: EOF | ERROR msg | HOST hostname | SSH msg |
#==============================================================================
proc get_data { } {
   global id self timeout

   # Get next prompt, categorize and return it.
   # NB: Look for known errors first. The "no route to host" msg also
   # had "authorize" and was being incorrectly processed.

   # NB: We DONT put catch all at end of expect because:
   # 1) There are lots of nulls & whitespace
   # 2) Data we send shows up here, eg: yes, <password>

   set host ""
   expect {
      eof {
         # puts "id=$id got EOF"
         return EOF
      }
      "want to continue connecting (yes/no)?" {
         # puts "SSH continue connecting prompt OK."
         return "SSH continue"
      }
      "not open connection" {
         # puts "ERROR: could not open connection"
         return "ERROR could not open connection"
      }
      "not known" {
         # puts "ERROR: host not known."
         return "ERROR host not known"
      }
      "refused" {
         # puts "ERROR: connection to host refused."
         return "ERROR connection to host refused"
      }
      "\[Nn\]o route to host" {
         # puts "ERROR: no route to host"
         return "ERROR no route to host"
      }
      "\[Pp\]ermission denied" {
         # puts "ERROR permission denied"
         return "ERROR permission denied"
      }
      "\[Hh\]ost key verification failed" {
         # puts "ERROR host key verification failed"
         return "ERROR host key verification failed"
      }
      "added*to the list of known hosts" {
         # puts "SSH added to known hosts."
         return "SSH added"
      }
      -re ".*authorize" {
         if {[regexp {\s+(\S+)\s+authorize} $expect_out(buffer) - host]} {
            # puts "host=$host"
            return "HOST $host"
         }
      }
      "\[Pp\]assword" {
         # puts "SSH password prompt"
         return "SSH password"
      }
      "\[Ll\]ogin incorrect" {
         # puts "SSH login incorrect"
         return "SSH invalid"
      }
      "\[Ii\]nvalid" {
         # puts "SSH invalid"
         return "SSH invalid"
      }
      "\[Ll\]ast login:" {
         # puts "SSH last login"
         return "SSH last"
      }
      timeout {
         # puts "ERROR timeout"
         return "ERROR timeout"
      }
   }
}

#=================== next_action ==============================================
# Handles the state machine for incoming prompts and responses.
#
# Calling parameters: string
# string is formatted as: "code msg_text"
#
# Returns: null
# Updates global variables
#==============================================================================
proc next_action { string } {
   global curr_host curr_state password timeout_cnt
  
   # Get code & msg from calling parameter
   set code [lindex $string 0]
   set code [string trim $code]
   set msg [lrange $string 1 end]
   set msg [string trim $msg]
   if {$msg == ""} {
      set msg "<null>"
   }
   # puts "next_action code=$code msg=$msg"

   # Handle EOF from expect.
   if {$code == "EOF"} {
       # set curr_host "" ;# test code
       # set curr_state "invalid_password" ;# test code
       # Check state to decide how to handle EOF.
      if {$curr_state == "" && $curr_host == ""} {
         # Nothing in progress, we are done.
         puts "next_action normal EOF nothing in progress"
         return

      } elseif {$curr_state == "found_host" || $curr_state == "connected" ||\
         $curr_state == "sent_password"} {
         # Host is authorized OK, save results.
         puts "next_action EOF saving curr_state=$curr_state curr_host=$curr_host"
         save_results OK $curr_host
         return

      } elseif {$curr_state == "invalid_password"} {
         puts "next_action EOF invalid password, saving curr_state=$curr_state curr_host=$curr_host"
         save_results ERROR $curr_host
         return

      } else {
         # Incomplete authorization. Should not go here.
         puts "next_action ERROR: EOF incomplete authorization curr_state=$curr_state curr_host=$curr_host"
         save_results ERROR $curr_host
         return
      }
   }

   # One of the challenges here is that there is no "success" message
   # after a host is correctly authorized. Successs is implied by the
   # lack of an error message and that we have moved on to the next 
   # host in the list, or hit EOF.

   # At rest state. We expect the authorization prompt and host name.
   if {$curr_state == "" && $curr_host == "" && $code == "HOST"} {
      set curr_state found_host
      set curr_host $msg
      puts "next_action at rest, curr_state=$curr_state curr_host=$curr_host"
      return
   }

   # We get the next authorization prompt in these situations:
   # 1) The current host was correctly authorized on a previous run
   # 2) The current host connected OK and did NOT get a password prompt.
   # 3) We sent the password and there is no response.
   # 4) We got an invalid password response.
   if {($curr_state == "found_host" || $curr_state == "connected" ||\
      $curr_state == "sent_password" || $curr_state == "invalid_password") &&\
      $code == "HOST"} {

      # Save results for curr_host
      puts "next_action saving, curr_state=$curr_state curr_host=$curr_host"
      if {$curr_state == "invalid_password"} {
         save_results ERROR $curr_host
      } else {
         save_results OK $curr_host
      }

      # Set the state variables for the next host
      set curr_state found_host
      set curr_host $msg
      puts "next_action next host, curr_state=$curr_state curr_host=$curr_host"
      return
   }

   # Now we expect an SSH continue connecting prompt. We send "yes".
   if {$curr_state == "found_host" && $code == "SSH" && $msg == "continue"} {
      set curr_state connecting
      puts "next_action connecting, curr_state=$curr_state curr_host=$curr_host"
      exp_send "yes\r"
      return
   }

   # We usually (but not always) get an SSH added prompt.
   if {$curr_state == "connecting" && $code == "SSH" && $msg == "added"} {
      set curr_state connected
      puts "next_action connected, curr_state=$curr_state curr_host=$curr_host"
      return
   }

   # We can get (extra) added prompts at different states, which are ignored.
   if {$code == "SSH" && $msg == "added"} {
      puts "next_action added, curr_state=$curr_state curr_host=$curr_host"
      return
   }

   # We may get a password prompt. If a previous run of the script got the SSH
   # connection setup OK, we may come directly to the password prompt.
   if {($curr_state == "connecting" || $curr_state == "connected" ||\
      $curr_state == "found_host") && $code == "SSH" && $msg == "password"} {
      set curr_state sent_password
      puts "next_action sent password, curr_state=$curr_state curr_host=$curr_host"
      exp_send "$password\r"
      return
   }

   # If we get invalid password response, we keep sending the password. SSH will
   # give up after several tries. This allows the script to move to the next host
   # in the list. If we dont do this, the script will likely hang.
   if {($curr_state == "sent_password" || $curr_state == "invalid_password") &&\
      $code == "SSH" && ($msg == "password" || $msg == "invalid")} {
      set curr_state invalid_password
      puts "next_action invalid password, curr_state=$curr_state curr_host=$curr_host"
      exp_send "$password\r"
      return
   }

   # Ignore for SSH last login messages.
   if {$code == "SSH" && $msg == "last"} {
      return
   }

   # Ignore SSH password when state is null.
   if {$curr_state == "" && $code == "SSH" && $msg == "password"} {
      return
   }

   # Watch for ERROR messages, which include timeout, no route to host, etc
   if {$code == "ERROR"} {
      puts "next_action ERROR: $msg curr_state=$curr_state curr_host=$curr_host"
      if {$curr_host != ""} {
         # Save results only if we still have a valid host name.
         save_results ERROR "$curr_host $msg"
      }
      set curr_state ""
      set curr_host ""
      if {$msg == "timeout"} {
         incr timeout_cnt
      }
      return
   }

   # It seems we can be in connecting state and get new host msg.
   if {$curr_state == "connecting" && $code == "HOST"} {
      puts "next_action WARN: transition curr_state=$curr_state\
         curr_host=$curr_host string=$string"
      save_results OK $curr_host
      set curr_state found_host
      set curr_host $msg
      puts "next_action next host, curr_state=$curr_state curr_host=$curr_host"
      return
   }

   # Completely unexpected state transition. Log the failure and reset the 
   # state variables.
   puts "next_action ERROR: should not go here!!! curr_state=$curr_state\
      curr_host=$curr_host string=$string" 
   save_results ERROR $curr_host
   set curr_state ""
   set curr_host ""
   if {$code == "HOST"} {
      set curr_state found_host
      set curr_host $msg
      puts "next_action next host, curr_state=$curr_state curr_host=$curr_host"
   }
   return
}

#=================== save_results =============================================
# Save the results of authorizing a host
#
# Calling parameters: status host
# NB: host may be a string including an error message.
#
# Returns: null
# Updates global variables
#==============================================================================
proc save_results {status host } {
   global fail fail_list success success_list

   # Check host token
   set host [string trim $host]
   if {$host == ""} {
      set host "<null>"
   }

   # Save results
   if {$status == "OK"} {
      incr success
      lappend success_list $host

   } elseif {$status == "ERROR"} {
      incr fail
      lappend fail_list $host

   } else {
      error "save_results host=$host invalid status=$status"
   }
}

#==============================================================================
# Main program starts here.
#==============================================================================

# Give online help if needed.
set start_sec [clock seconds]
set self [file tail $::argv0] ;# get our own name
set x [lindex $argv 0]
set x [string tolower $x]
set x [string range $x 0 1]
# puts "x=$x"
if {$x == "-h"} {
   puts "Basic usage: $self config.tcl password <utf_dir>"
   puts "\nThis helper script is used by Authorize.test."
   puts "For more info, type: Test/Authorize.test -h"
   exit 1
}

# Get the required command line tokens.
if {$argc < 2} {
   puts "$self ERROR: too few calling tokens.\nFor more info, type: $self -h"
   exit 1
}
set config [lindex $argv 0]
set config [string trim $config]
set password [lindex $argv 1]
set password [string trim $password]
set utf_dir [lindex $argv 2]
set utf_dir [string trim $utf_dir]
if {$utf_dir == ""} {
   set utf_dir "."
}

# Adjust config as necessary.
if {![regexp {^[~/]} $config]} {
   # config is not a full pathname
   set config "$utf_dir/$config"
}
# puts "config=$config password=$password utf_dir=$utf_dir"

# Look for UTF.tcl
if {![file exists "$utf_dir/UTF.tcl"]} {
   puts "$self file UTF.tcl not found in utf_dir=$utf_dir"
   exit 1
}

# Turn on expect stdout.
log_user 1
# exp_internal 1

# Start expect session for helper script.
set script $utf_dir/Test/Auth_Helper.test
set catch_resp [catch "spawn $script -utfconf $config" catch_msg]
if {$catch_resp != 0} {
   puts "$self ERROR: spawn script=$script catch_resp=$catch_resp catch_msg=$catch_msg"
   exit 1
}

# Set expect parms
set timeout 30 ;# Cygwin PC can be slow
set id $spawn_id
puts "$self timeout=$timeout id=$id"

# Initialize state tracking variables.
set curr_host ""
set curr_state ""
set fail 0
set fail_list ""
set success 0
set success_list ""
set timeout_cnt 0

# We loop an indeterminate number of times responding to
# prompts as needed.
while { 1 } {
   # Get next prompt from expecta data stream.
   set resp [get_data]

   # Update the state machine.
   next_action $resp

   # Watch for expect process terminating or too many timeouts.
   if {$resp == "EOF" || $timeout_cnt >= 3} {
      break
   }
}

# Show final results.
set end_sec [clock seconds]
set delta_sec [expr $end_sec - $start_sec]
puts "$self fail=$fail $fail_list"
puts "$self success=$success $success_list"
puts "timeout_cnt=$timeout_cnt delta_sec=$delta_sec"
exit $fail
