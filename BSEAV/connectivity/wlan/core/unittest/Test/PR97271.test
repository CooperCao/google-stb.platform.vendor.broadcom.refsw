#!/bin/env utf
# -*-tcl-*-

# this is for PR97271 verification on 43142
#  

package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::PingTimes
package require UTF::Test::DataRate
package require UTF::Test::Fragmentation
package require UTF::Test::RTS
package require UTF::Test::Scan
package require UTF::Test::controlchart
package require UTF::Test::memchart
package require UTF::Test::ChannelSweep
package require UTF::Test::BigHammer
package require UTF::Test::IBSS
package require UTF::Test::DPT
package require UTF::Test::CalStability
package require UTF::Test::rssinoise
package require UTF::Sniffer
package require UTF::utils




#package provide UTF::Test::Sample_script_template 2.0

UTF::Test Sample_script_template {args} {
    UTF::Getopts {
	{sta.arg "4325sdio" "sta name"}
	{ap.arg "4704/4318" "AP name"}
	{trx.arg "" "Router trx"}
	{tag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{bin.arg "" "STA dongle image"}
	{email.arg "" "Email Address"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{nostareload "Don't even reload STA drivers"}
	{norestore "Don't reset to defaults"}
	{noscan "No scan tests"}
	{nojoin "No join security tests"}
	{nopm "No Power Management tests"}
	{nopm1 "No Slow Power Management tests"}
	{nopm2 "No Fast Power Management"}
	{noframeburst "No Framebursting"}
        {nofb0 "No non-frameburst open tests"}
	{noperf "No Performance tests"}
	{noperf20 "Don't do 20MHz performance tests"}
	{noperf40 "Don't do 40MHz performance tests"}
	{nochannels "Don't ch scan/sweep channels "}
	{nosetup "No Setup"}
	{nobtests "Disable Bangalore tests"}
	{nopingtimes "Disable PingTimes test"}
	{norate "Disable Fixed Rate tests"}
	{norts "Disable RTS tests"}
	{nofrag "Disable Fragmentation test"}
	{date.arg "" "Image date"}
        {apdate.arg "" "ap image date"}
        {history.arg 30 "History size for control charts"}
	{perfloop.arg 1 "Performance test loops"}
	{loop.arg 1 "Main test loops"}
	{nounload "Don't unload driver after test"}
	{nocache "Don't update performance cache"}
	{nowep "No WEP security"}
	{noshared "No shared security"}
	{notkip "No TKIP security"}
	{noaes "No AES security"}
	{nocal "No Calibration tests"}
	{nobighammer "No BigHammer tests"}
	{nobx "No Bidirectional Performance tests"}
	{noibss "No IBSS tests"}
	{nodpt "No DPT tests"}
	{title.arg "" "Title"}
	{branch.arg "auto" "Branch override"}
        {logdir.arg "" "Log directory override"}
	{chanspec.arg "" "Chanspec to use for all fixed-channel tests"}
	{nosetuptestbed "Don't run Setup Testbed hooks"}
	{noposttesthook "Don't run Post Test hooks"}
	{perfonly "Only run subset of performance tests"}
        {perfchans.arg ""  "channel list" } 
	{datarate_all.arg 0 "datarate all channel list" } 
	{pingonly.arg 0  "ping test only"}
	{chsweep.arg  1 "channel sweep default auto" }
        {apdata.arg  1  "ap datarate test"           }
        {sniffer.arg "" "sniffer object"          }
        {nosniffer "No Sniffer"}

    }

        

proc DataRate2 {AP STA}  {
       upvar {} {}
       upvar apdata apdata
    ConnectAPSTA $AP $STA

    # Figure out what band we're using so that we know how to set rate
    # to "auto".  Can't just use "rate" since we may not be bandlocked.
    if {[$AP band] eq "a"} {
	set lratecmd a_rate
    } else {
	set lratecmd bg_rate
    }

    set APIP [$AP ipaddr]

    # Ask the STA for the rateset, since that will be the common set
    # negotiated between AP and STA for this BSS.
    set RATESET [$STA wl rateset]
    set MCSSET ""

    # Split out any MCS rates to be handled seperately.
    regexp {(.*)(\nMCS SET : .*)} $RATESET - RATESET MCSSET
    set RATESET [regexp -all -inline {[\d.]+} $RATESET]
    set MCSSET [regexp -all -inline {[\d.]+} $MCSSET]

    # TARGET is the STA object to have its rate adjusted.
    # First pass, the AP
    # Second pass, the STA
    foreach TARGET [list $AP $STA] {
        if { $(apdata)== 0 && $TARGET == $AP } { $TARGET wl $lratecmd auto ; continue }   
	foreach r $RATESET {
	    UTF::Try "$TARGET: legacy rate set to $r" {
		$TARGET wl $lratecmd $r
                after 1000
               
                UTF::Message INFO "$STA" "bssid= [$STA wl bssid]"
		$STA ping $APIP
                
	    }
	}
	foreach r $MCSSET {
	    UTF::Try "$TARGET: mcs rate set to $r" {
		$TARGET wl nrate -m $r
                after 1000
                UTF::Message INFO "$STA" "bssid= [$STA wl bssid]"
  
		$STA ping $APIP
	    }
	}
	$TARGET wl $lratecmd auto
    }

    # Clean up
    catch {$STA wl disassoc}
    $AP wl $lratecmd auto
    $STA wl $lratecmd auto
}

##


proc chupdate { channel_in channel_out bw } {
   upvar $channel_out  channel 
   upvar $bw _bw 
    
  if {[regexp {(\d+)([ul])?} $channel_in match _channel bw ] } {
               

      if { ![info exist _channel ] } {
            if {$_channel >= 36} {
                set band "5"
            } else {
                set band "2.4"
            }
        }
        if {$bw eq "l"} {
                set cap "40"
        } elseif {$bw eq "u"} {
	    set cap "40"
        } else {
	    set cap "20"
        }

       set _bw $cap
        
       set channel $_channel
      return 1  
  } else {
      return 0
  }
}

####

proc DataRate3 {AP STA}  {
       upvar {} {}
       upvar apdata apdata
    ConnectAPSTA $AP $STA

    # Figure out what band we're using so that we know how to set rate
    # to "auto".  Can't just use "rate" since we may not be bandlocked.
    if {[$AP band] eq "a"} {
	set lratecmd a_rate
    } else {
	set lratecmd bg_rate
    }

    set APIP [$AP ipaddr]

    # Ask the STA for the rateset, since that will be the common set
    # negotiated between AP and STA for this BSS.
    set RATESET [$STA wl rateset]
    set MCSSET ""

    # Split out any MCS rates to be handled seperately.
    regexp {(.*)(\nMCS SET : .*)} $RATESET - RATESET MCSSET
    set RATESET [regexp -all -inline {[\d.]+} $RATESET]
    set MCSSET [regexp -all -inline {[\d.]+} $MCSSET]

    # TARGET is the STA object to have its rate adjusted.
    # First pass, the AP
    # Second pass, the STA
  #   $AP wl $lratecmd auto
  #  $STA wl $lratecmd auto

    foreach TARGET [list $AP $STA ] {
        if { $TARGET == $STA } { continue }   
	
	foreach r $MCSSET {
	    UTF::Try "$TARGET: mcs rate set to $r" {
		$TARGET wl nrate -m $r
                after 1000
		$STA ping $APIP
	    }
	}
       
        after 1000

        #	foreach r $RATESET {
	#    UTF::Try "$TARGET: legacy rate set to $r" {
	#	$TARGET wl $lratecmd $r
        #        after 1000
	#	$STA ping $APIP
	#    }
	#}
 

	$TARGET wl $lratecmd auto
    }

    # Clean up
    catch {$STA wl disassoc}
    $AP wl $lratecmd auto
    $STA wl $lratecmd auto
}




##################################################
###args processing       
####################################################
    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
	set ::UTF::MemChart::readonly 1
    }

    if {$(nobtests)} {
	# Common disable for historical "Bangalore" tests, and others
	set (nopingtimes) 1
	set (norate) 1
	set (norts) 1
	set (nofrag) 1
    }

    set Router  $(ap)
    set STA [lindex $(sta) 0]

   
    # Override default tags, push the tag into class object buffer 
    #, in object , may be set from the configuration file
    # by using the same command, cget can get it
    if {$(trx) ne ""} {
	$Router configure -image $(trx) -date {}
    } elseif {$(tag) ne ""} {
	$Router configure -tag $(tag) -date {}
    }

     if {$(apdate) ne ""} {
            $Router configure -date $(apdate)
    }

    if {$(bin) ne ""} {
	foreach STA $(sta) {
	    $STA configure -image $(bin) -date {}
	}
    }
    if {$(statag) ne ""} {
	foreach STA $(sta) {
	    $STA configure -tag $(statag) -date {}
	}
    }
    if {$(date) ne ""} {
	set date $(date)
	foreach S $(sta) {
	    $S configure -date $(date)
	}
	unset S
    } else {
	set date [clock format [clock seconds] -format "%Y.%-m.%-e"]
	# Clean up whitespace (RH9 compat)
	regsub -all {\s+} $date {} date
    }

    if {$(perfonly)} {
	# Enable perfonly on all STAs
	foreach S $(sta) {
	    $S configure -perfonly 1
	}
    }

    # Compact build list for title
    set build [UTF::BuildTitle $(sta)]

    if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}

	if {[regexp {(\d+sd)} $Router - c]} {
	    append (title) " with $c AP"
	}
    }
    set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)


#############################################################
# Define  global proc 
###########################################################
    proc systime {STA} {
	catch {
	    $STA rexec {vmstat 1 6 | awk 'FNR>3{print $14}'}

	}
    }

    proc pmperf {BUILD AP STA MSG args} {
	upvar {} testopts

	UTF::Getopts {
	    {PM.arg "0" "Power Management"}
	    {fb.arg "" "Frameburst"}
	    {ch.arg "" "Chanspec"}
	    {security.arg "open" "security"}
	}


	if {$(fb) eq ""} {
	    # Frameburst default depends on OS
	    if {![$STA cget -noframeburst] && [$STA hostis MacOS]} {
		set (fb) 1
	    } else {
		set (fb) 0
	    }
	} else {
	    # canonicalize
	    set (fb) [string is true $(fb)]
	}

	if {[$AP hostis Router Vx BSDAP DSL]} {
	    set LAN [$AP lan]
	} else {
	    set LAN $AP
	}
	if {$(PM) == 1} {
	    # Low performance tests may need longer to reduce
	    # quantization errors
	    set i 5
	} else {
	    set i 2
	}

	if {$(ch) ne ""} {
	    append MSG ": CH=$(ch)"
	}
	if {$(fb)} {
	    append MSG ": FB=$(fb)"
	}
	if {$(PM)} {
	    append MSG ": PM=$(PM)"
	}
	if {$(security) ne "open"} {
	    append MSG ": $(security)"
	}
	set setup 0
        #try test block 
     #1 WLAN<-LAN
	UTF::Try "$MSG: WLAN<-LAN" {
	    # Put STAs into PM mode before association, to make sure
	    # we can associate in PM mode.
	    if {![$STA cget -apmode]} {
		if {[catch {$STA wl PM $(PM)} ret] &&
		    ([regexp {killed} $ret] ||
		     ($(PM) && ![regexp {Not STA} $ret]))} {
		    error $ret
		}
	    }
	    if {[$STA wl frameburst] ne $(fb)} {
		$STA wl frameburst $(fb)
		if {[$STA wl frameburst] ne $(fb)} {
		    if {$(fb)} {
			error "failed to enable frameburst"
		    } else {
			error "failed to disable frameburst"
		    }
		}
	    }
	    if {$(ch) ne ""} {
		if {[$STA cget -apmode]} {
		    APChanspec $STA $(ch)
		} else {
		    APChanspec $AP $(ch)
		}
	    }
            # get args  or it may in the configure file  
	    if {$(security) ne [$AP cget -security]} {
		ConnectAPSTA $AP $STA -security $(security)
	    } elseif {[catch {$STA wl bssid} ret] || \
			  $ret eq "00:00:00:00:00:00"} {
		ConnectAPSTA $AP $STA
	    }
	    # Set frameburst after any AP restarts
	    $AP wl frameburst $(fb)

	    # If we're in SoftAP mode, set PM on the router.  Do this
	    # after assoc, since WET assoc may restart the router.
	    if {[$STA cget -apmode]} {
		$AP wl PM $(PM)
	    }

	    set k [concat $BUILD $AP $(PM)]
	    if {$(ch) ne ""} {
		lappend k "ch=$(ch)"
	    }
	    if {$(fb)} {
		lappend k "fb=$(fb)"
	    }

	    # Auto TCP window size setting based on phy rate
	    set w [$STA tcpautowindow]

	    if {$(security) ne "open"} {
		lappend k "$(security)"
	    }

	    if {[$STA cget -dosystime]} {
		after 5000 [namespace current]::systime $STA
	    }
	    set setup 1
	    controlchart [list $LAN $STA] -key $k -i $i -window $w \
		-loop $testopts(perfloop) -history $testopts(history)
	}




        #2 WLAN->LAN ,
	if {$setup} {
	    UTF::Try "$MSG: WLAN->LAN" {
		if {[$STA cget -dosystime]} {
		    after 5000 [namespace current]::systime $STA
		}
		controlchart [list $STA $LAN] -key $k -i $i -window $w \
		    -loop $testopts(perfloop) -history $testopts(history)
	    }


         #3 WLAN<>LAN
	    if {!$testopts(nobx)} {
		UTF::Try "$MSG: WLAN<>LAN" {
		    if {[$STA cget -dosystime]} {
			after 5000 [namespace current]::systime $STA
		    }
		    controlchart [list $STA $LAN $LAN $STA] -key $k -i $i \
			-window $w -loop $testopts(perfloop) \
			-history $testopts(history)
		}
	    }
	}
    } ;# end of the proc



    if {$(noscan)} {
        #dummy proc
	proc scan {AP STA MSG} {}

         
    } else {
	proc scan {AP STA MSG} {
	    UTF::Try "$MSG: Scan Tests" {
		UTF::Try "$MSG: Broadcast Scan" {
		    Scan $AP $STA
		}
		UTF::Try "$MSG: Scan directed to SSID" {
		    Scan $AP $STA -ssid
		}
		UTF::Try "$MSG: Scan directed to BSSID" {
		    Scan $AP $STA -bssid
		}
		UTF::Try "$MSG: Scan directed to SSID and BSSID" {
		    Scan $AP $STA -ssid -bssid
		}
		UTF::Try "$MSG: Passive Scan" {
		    Scan $AP $STA -passive
		}
		return
	    }
	}
    }



    ###define  join with security with previous channel and datereate set 
    if {$(nojoin)} {
	proc joinsec {AP STA MSG} {}
    } else {
	proc joinsec {AP STA MSG} {
	    # access option array
	    upvar {} {}
	    UTF::Try "$MSG: Association Tests" {
		if {!$(noshared) && ![$STA cget -nowep]} {
		    # use limited wep on some devices.
		    if {[$STA cget -usewep64]} {
			UTF::Try "$MSG: SHARED64 association" {
			    ConnectAPSTA $AP $STA -security shared64
			}
		    } else {
			UTF::Try "$MSG: SHARED association" {
			    ConnectAPSTA $AP $STA -security shared
			}
		    }
		}

		if {!$(notkip) && ![$STA cget -notkip]} {
		    UTF::Try "$MSG: TKIPPSK2 association" {
			ConnectAPSTA $AP $STA -security tkippsk2
		    }
		}
		if {!$(noaes) && ![$STA cget -noaes]} {
		    UTF::Try "$MSG: AESPSK association" {
			ConnectAPSTA $AP $STA -security aespsk
		    }
		}
		return
	    }
	}
    } ;# end of the proc




 #defaine main program test proc for a sta with the AP
 # the main only load sta build
    proc main {Router STA} {
	# access option array
	upvar {} {}
	upvar date date   ;# sta date DUT
        upvar apdate apdate
        upvar perfchans perfchans
        upvar datarate_all datarate_all  
        upvar pingonly pingonly
        upvar chsweep chsweep        


	set phyname ""

	if {$(branch) eq "auto"} {
	    set branch [$STA branchname]
	} else {
	    set branch $(branch)
	}


	# Find images
	if {!$(nostaload)} {
	    UTF::Try "$STA Find STA Image" {
		UTF::CheckImage $STA $date unknown
	    }
	}
	if {!$(nosetup)} {
	    if {$(nostaload)} {
		if {!$(nostareload)} {
		    UTF::Try "$STA reload" {
			$STA reload
		    }
		}
	    } else {
		UTF::Try "$STA load" {
		    $STA load
		}
	    }
	    UTF::Try "$STA defaults" {
		$STA services stop
		catch {$STA wl msglevel +error +assoc}
		if {![$STA hostis LMAC]} {
		    catch {$STA wl down}
		    # Enable 40 in 2.4, if available. , it may fall back to 20M if ap not
		    # Doesn't work for LMAC since LMAC is never "down"
                    # 1   ---20/40MHz      ; 2--20mhz ; 0-------20MZ 
		    $STA wl -u mimo_bw_cap 1
                    
		    $STA wl up
		    UTF::Sleep 1
		}
		$STA wl ver
		set what [$STA whatami]
		if {!$(nostaload)} {
		    # Pull out chip info and replace whitespace to
		    # make it easier for external parsers.
		    regsub -all {\s+} [lreplace $what 0 0] {_} w
		    if {[catch {$UTF::Summary header_update 1 $w} ret]} {
			UTF::Message WARN $STA $ret
		    }
		}
		set what
	    }

	    if {!$(nostaload) && [set reclaim [$STA reclaim]]} {
		UTF::Try "$STA: Reclaim" {
#		    if {$(bin) eq ""} {
#			# Only do MemSave for official builds
#			UTF::MemSave $reclaim "reclaim" [$STA imageinfo]
#		    }
		    # MemChart
		    memchart $reclaim -key [list $branch $STA reclaim] \
			-failonlow
		}
	    }
	}

        if { $(perfchans) ne "" } {
           set perfchans $(perfchans)
        } else {
	   set perfchans [$STA cget -perfchans]
        }

#
       if {$(perfchans) eq "" && $(chsweep) == 1 } {
         # default to finding chanspecs AP and STA have in common
	 set perfchans [UTF::Common [$Router allchanspecs] [$STA allchanspecs]]   
         #puts "perfchans  =  $perfchans -------------\n"

       }
        
       #set common_ch [UTF::Common [$Router allchanspecs] [$STA allchanspecs]]  
       #puts "perfchans  =  $common_ch -------------\n"

       if { [llength $perfchans] != 0 } { 
          UTF::Message INFO $STA "Channel testing on: \n $perfchans\n"
       }

#
	if {$perfchans ne ""} {  
	    # if perfchans were set, use them for the home channel
	    set 20chan [lindex $perfchans 0]
	} else {
	    # Try to guess a 40 and a 20 MHz channel

	    set 40chan ""
	    if {$(chanspec) ne ""} {
		# cmdline override
		set 20chan $(chanspec)
	    } else {
		# per device defaults
		set 20chan [$STA cget -chanspec220]
	    }

	    if {[catch {
		if {[regexp {36?l} [$Router wl chanspecs]] &&
		    [regexp {36?l} [$STA wl chanspecs]]} {
		    # 40 MHz channels are available
		    # check if we can use 5GHz band for 40MHz bw tests
		    set 40chan 3l
		    if {[catch {
			if {[lsearch [$Router wl bands] "a"] > -1 &&
			    [lsearch [$STA wl bands] "a"] > -1} {
			    set 40chan 36l
			}
		    } ret]} {
			UTF::Try "$STA: check for 5GHz band" {
			    error $ret
			}
		    }
		}
	    } ret]} {
		if {![regexp {Unsupported} $ret]} {
		    # If any of these commands are unsupported it's a safe bet
		    # that 40MHz isn't available.
		    UTF::Try "$STA: check for 40MHz channels" {
			error $ret
		    }
		}
	    }
	    if {$40chan eq ""} {
		UTF::Message INFO "" "No 40MHz testing"
	    } else {
		UTF::Message INFO "" "Using $40chan for 40MHz testing"
	    }

	    if {$40chan ne "" && !$(noperf40)} {
		lappend perfchans $40chan
	    }
	    if {!$(noperf20)} {
		lappend perfchans $20chan
	    }
	}




	# If performance tests are disabled, clean the channel list
	if {$(noperf)} {
	    set perfchans ""
	}

	if {![$STA cget -apmode]} {
	    UTF::Try "$Router: Home Channel $20chan" {
		APChanspec $Router $20chan
	    }
	}

         
	for {set i 0} {$i < $(loop)} {incr i} {

            #preset the security as open for the channel scan
	    UTF::Try "$Router: Open Security" {
		APConfigureSecurity $Router -security open
	    }

	    # Scan all channels
	    if {![$STA cget -perfonly] &&
		!$(nochannels) && ![$STA cget -nochannels]} {
		if {[catch {
		    ChannelSweep $Router $STA -msg $STA
		} ret]} {
		    UTF::Try "$STA: Channel Sweep" {
			error $ret
		    }
		}
	    }
             
#
	#  if { $(nochannels) &&  $(pingonly) ==  1 }  {  
        #  	if {[catch {
	#	    ChannelSweep $Router $STA -msg $STA
	#	} ret]} {
	#	    UTF::Try "$STA: Channel Sweep" {
        #			error $ret
	#	    }
	#	}
	#    }
#            
             
            #clean
	    catch {  $STA wl disassoc } 
            #catch {   $STA clear arp }
 
	    # Loop through channels to be tested.
	    foreach c $perfchans {

                ##############
                # chupdate $c _channel_out _band _bw 

                if {!$(nosniffer) && $(pingonly) == 1 } {  
		    # Setup sniffer to sniff on chanspec1 and start tshark command
		    
		    if {$(sniffer) != "" && [chupdate $c p_ch _bw] } {
                       # $(sniffer) setupSniffer $p_ch 
                        $(sniffer) setupSniffer $c
                        set cap $_bw
		    } else {
			$(sniffer) setupSniffer $c
                        set cap 20
		    }
                      
                     after 2000 
		    # start tshark command on sniffer object
		    if {$(sniffer) != ""} {
                        
                        # $(sniffer)
                         
			set filename "data_rate_ch"
                        append filename "G$cap"
			append filename "Ch$c"
			append filename ".pcap"


                        set filename "captureFile.pcap"

                        $(sniffer) start "tshark -i prism0 -w $filename"
                        after 2000
		    }
		}
               #
               ################

		UTF::Try "$STA: Channel $c " {
                    #
                    catch {$STA wl disassoc }
		    ConnectAPSTA $Router $STA -chanspec $c
		    if { $(pingonly) == 0 } {
		       rssinoise $Router $STA 
                    }

		}

                #date rate sweep
                #if {!$(norate)} {
		#    UTF::Try "$STA: Check different rate settings" {
		#	DataRate $Router $STA
		#    }
		#}

		if {!$(noframeburst) && ![$STA cget -noframeburst] && $(pingonly) == 0 } {
		    pmperf $branch $Router $STA $STA -fb 1 -ch $c
		}
		if {![$STA cget -perfonly] && !$(nopm) && $(pingonly) == 0  } {
		    if {!$(nopm2) && ![$STA cget -nopm2]} {
			pmperf $branch $Router $STA $STA -PM 2 -ch $c
		    }
		    if {!$(nopm1) && ![$STA cget -nopm1]} {
			pmperf $branch $Router $STA $STA -PM 1 -ch $c
		    }
		}
		if {!$(noaes) && ![$STA cget -noaes] && $(pingonly) == 0 } {
		    pmperf $branch $Router $STA $STA -security aespsk2 \
			-ch $c
		}
		# HT is disabled in TKIP and WEP, so no point testing
		# them in 40MHz
		if {![$STA cget -perfonly] && ![regexp {[lu]} $c] && $(pingonly) == 0 } {
		    if {!$(notkip) && ![$STA cget -notkip]} {
			pmperf $branch $Router $STA $STA -security tkippsk \
			    -ch $c
		    }
		    if {!$(nowep) && ![$STA cget -nowep]} {
			# use limited wep on some devices.
			if {[$STA cget -usewep64]} {
			    set wep wep64
			} else {
			    set wep wep
			}
			pmperf $branch $Router $STA $STA -security $wep \
			    -ch $c
		    }
		}



		# If the STA doesn't do frameburst then no-frameburst
		# becomes a performance test.
		if {(![$STA cget -perfonly] || [$STA cget -noframeburst]) &&
		    !$(nofb0)  &&  $(pingonly) == 0 } {
		    pmperf $branch $Router $STA $STA -fb 0 -PM 0 \
			-security open -ch $c
		}
		if {![$STA cget -perfonly] &&
		    !$(nobighammer) && ![$STA cget -nobighammer] && $(pingonly) == 0 } {
		    BigHammer $Router $STA "BigHammer on $c"
		}


                #
                if {$(sniffer) != ""  && $(pingonly) == 1 } {
                    after 10000 
		    set SummaryLoc [file dirname "$UTF::Logfile"]
		    UTF::stop_sniffer $(sniffer) 1 $SummaryLoc
                    after 1000
	        }
	    } ;# end of c






	    if {[llength $perfchans]} {
		# If we did some perf tests, check memory on STA.  If
		# we're using a Dongle SoftAP, check memory on the AP
		# too.
		foreach S [list $STA $Router] {
		    if {[$S hostis DHD WinDHD PXA LMAC] &&
			![$S cget -nomaxmem] && [$S cget -console] ne ""} {
			UTF::Try "$S: MaxMem in use" {
			    memchart [$S maxmem] -key [list $branch $S maxmem]
			}
		    }
		}
	    } else {
		# If we did no performance tests we need to set the
		# channel explicitly.
		UTF::Try "$STA: Home Channel $20chan" {
		    APChanspec $Router $20chan
		}
	    }



	    if {![$STA cget -perfonly]} {

		if {![$STA cget -apmode]} {
		    scan $Router $STA $STA
		} else {
		    # AP and STA are reversed
		    scan $STA $Router $STA
		}
		joinsec $Router $STA $STA

		if {!$(nobtests)} {
		    UTF::Try "$Router: Configure open security" {
			APConfigureSecurity $Router -security open
		    }
		}

		if {!$(nopingtimes)} {
		    # Check ping times
		    PingTimes $Router $STA
		}

		if {!$(norate) && [ llength $perfchans] != 0 && $(datarate_all) != 0 } {
                  #daterate for different channel
		    foreach c $perfchans {   


                  #######snif
                  #
		  if {!$(nosniffer)} {  
		    # Setup sniffer to sniff on chanspec1 and start tshark command
		    
		    if {$(sniffer) != "" && [chupdate $c p_ch _bw] } {
                        #$(sniffer) setupSniffer $p_ch 
                        $(sniffer) setupSniffer $c
                        set cap $_bw
		    } else {
			$(sniffer) setupSniffer $c
                        set cap 20
		    }
                      
		    # start tshark command on sniffer object
		    if {$(sniffer) != ""} {
                        
                        # $(sniffer)
                         
			set filename "data_rate_sweep_ch"
                        append filename "G$cap"
			append filename "Ch$c"
			append filename ".pcap"
               
                        set filename "captureFile.pcap"
                        $(sniffer) start "tshark -i prism0 -w $filename"
                        after 1000
		    }  
		 }  

                #   
                ####### 
		      UTF::Try "$STA: Check different rate settings at ch=$c " {
                        APChanspec $Router $c
                          DataRate2 $Router $STA
			# DataRate3 $Router $STA
		      }

                     ####
                     #
                      if {$(sniffer) != "" } {
                         after 10000
		         set SummaryLoc [file dirname "$UTF::Logfile"]
		         UTF::stop_sniffer $(sniffer) 1 $SummaryLoc
                         after 500
	              }
                     #
                     #######  
	      } ;# enf of c loop 

		}

		if {!$(norts)} {
		    UTF::Try "$STA: Check RTS thresholds" {
			RTS $Router $STA
		    }
		}

		if {!$(nofrag) && ![$STA cget -nofragmentation]} {
		    UTF::Try "$STA: Check Fragmentation threshold" {
			Fragmentation $Router $STA
		    }
		}

		if {!$(nocal) && ![$STA cget -nocal]} {
		    # CalStability will check phytype itself to determine if
		    # it should run.
		    CalStability $STA -chanspec $20chan
		}
	    }

	}


	if {[$STA cget -apmode]} {
	    # For reverse tests, disassoc AP to avoid lots of roaming
	    # messages when STA goes away.
	    catch {$Router wl disassoc}
	}

	if {$(noibss)} {
	    set ibsswith ""
	} else {
	    set ibsswith [$STA cget -ibsswith]
	}
	if {$(nodpt)} {
	    set dptwith ""
	} else {
	    set dptwith [$STA cget -dptwith]
	}

	if {$ibsswith ne ""} {
	    UTF::Try "$ibsswith: reload" {
		$ibsswith reload
	    }
	    IBSS $STA $ibsswith
	    if {$ibsswith ne $dptwith} {
		UTF::Try "$ibsswith: unload" {
		    $ibsswith unload
		}
	    }
	}
	if {$dptwith ne ""} {
	    if {$ibsswith ne $dptwith} {
		UTF::Try "$dptwith: reload" {
		    $dptwith reload
		}
	    }
	    DPT $Router $STA $dptwith
	    UTF::Try "$dptwith: unload" {
		$dptwith unload
	    }
	}
	if {!$(nounload)} {
	    UTF::Try "$STA: unload driver" {
		$STA unload
	    }
	}
	catch {$STA deinit}
    } ;# end of the Main

########################################################################
#test block
########################################################

    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}

       # UTF::CheckImage $Router $(apdate) unknown
	if {!$(noapload)} {
	    UTF::Try "$Router: Find Router Image" {
                 if { $(apdate) == "" } {
                     UTF::CheckImage $Router $(date) unknown
                } else {
                     UTF::CheckImage $Router $(apdate) unknown
               }
	    }

	    UTF::Try "$Router: Load Image" {
		if {[$Router hostis Router Vx BSDAP DSL]} {
		    if {[catch {$Router lan ifconfig [$Router lan cget -ipaddr]}]} {
			$Router lan ifconfig 192.168.1.50
		    }
		}

               
                if { $(apdate) == "" } {    
		  set ver [$Router load]
                } else {
                  set ver [$Router load -date $(apdate)]
                }

		set what [$Router whatami]
		# Pull out chip info and replace whitespace to make it
		# easier for external parsers.
		regsub -all {\s+} [lreplace $what 0 0] {_} w
		if {[catch {$UTF::Summary header_update 1 $w} ret]} {
		    UTF::Message WARN $Router $ret
		}
		return "$what $ver"
	    }
	}
	if {!$(norestore)} {
	    UTF::Try "$Router: Restore Defaults" {
		if {[$Router hostis Router Vx BSDAP DSL]} {
		    $Router restore_defaults
		} else {
		    $Router wl radio on
		    $Router wl ap 0
		    catch {$Router wl down}
		    # Enable 40 in 2.4, if available.
		    $Router wl -u mimo_bw_cap 1   ;# make it 20/40
		    $Router wl up
		    $Router wl disassoc
		    $Router services stop
		    $Router wl msglevel +error +assoc
		    $Router chipname ;#
		}
	    }
	}




	foreach STA $(sta) {
	    if {[catch {main $(ap) $STA} ret]} {
		UTF::Try "main loop" {
		    error $ret
		}
	    }
	}

	PreservedReport

	if {!$(noposttesthook) && [info exists ::UTF::PostTestHook]} {
	    UTF::Try "Post Test" {
		eval $::UTF::PostTestHook
	    }
	}


    } ;# end of Wrap summary block

###################################################

}
