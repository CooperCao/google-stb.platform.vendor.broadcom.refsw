#!/bin/env utf
# -*-tcl-*-

#
# script to see if pkteng works on a specific chip & driver.
#
# To get online help, type: Test/pkteng.test -h
#

# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set pkteng_help "\n\nBasic usage: Test/pkteng.test <options>\
    \n\nThis script will turn off all radios in your testrig, and turn on\
    \nyour sniffer and see if pkteng will send frames or not. The sniffer\
    \n.pcap file can be viewed in WireShark to see what happened.\
    \n\nValid options are:\n"

# Command line options string
set pkteng_getopts {
    {aps.arg ""          "List of AP to test"}
    {attnval.arg 0       "Setting for attenuator"}
    {chanspec.arg "36l"  "Channel to test"}
    {email.arg ""        "Email address list, format: userid1,userid2,... default is your userid"}
    {gap.arg "50"        "pkteng between frames, in usec"}
    {noapload            "Don't load the AP images, default is load the AP images"}
    {noinit              "Use the testbed as is, no initialization"}
    {nostaload           "Don't load the STA images, default is load the STA images"}
    {noradiosetup        "Leave the radios as is, default it to turn them all off"}
    {nrate.arg "7"       "MCS rate to test with"}
    {rate.arg ""         "Legacy rate test with, if specified, rate will override nrate"}
    {ringfilecnt.arg ""  "Specify sniffer ring buffer file count. Null means no ring buffer."}
    {ringfilesize.arg "" "Specify sniffer ring buffer file size in MBytes. Null means no ring buffer."}
    {rtrdate.arg ""      "Desired Router build date, format: yyyy.mm.dd"}
    {rtrtag.arg ""       "Router release tag"}
    {size.arg "1400"     "pkteng frame size, in bytes"}
    {sniffer.arg ""      "Sniffer to use in tests, default is to use the first sniffer found"}
    {stas.arg ""         "List of STA to test, default is to test all STA, including all clones."}
    {stadate.arg ""      "Desired STA build date, format: yyyy.mm.dd"}
    {statag.arg ""       "STA release tag"}
    {t.arg 5             "Time duration, in seconds to run pkteng"}
    {title.arg ""        "Title description text string for use in the reports"}
}

# Setup online help info.
UTF::setup_help $pkteng_help $pkteng_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any 
# additional code in this script.

# Load packages
package require UTF
package require UTF::Sniffer
package require UTF::utils
package require UTF::Test::APChanspec
package provide UTF::Test::pkteng 2.0

UTF::Test pkteng {args} {

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts "$::pkteng_getopts" "$::pkteng_help"

    # Get testbed info.
    set ::UTF::trailer_info [UTF::setup_testbed_info $(email) ""]
    UTF::Message LOG "$::localhost" "\n\n\nendpoint_device_list=$::endpoint_device_list"
    UTF::Message LOG "$::localhost" "endpoint_sta_list=$::endpoint_sta_list"
    UTF::Message LOG "$::localhost" "router_device_list=$::router_device_list"
    UTF::Message LOG "$::localhost" "router_sta_list=$::router_sta_list\n\n\n"

    # Validate sniffer name.
    if {$(sniffer) == ""} {
        set (sniffer) [lindex $::sniffer_sta_list 0]
    }
    UTF::Message LOG "$::localhost" "Checking sniffer: $(sniffer)"
    set resp [UTF::check_host_type $(sniffer) Sniffer]
    if {$resp == 0} {
        error "ERROR: $(sniffer) not type Sniffer. A Sniffer is required for this test!"
    }

    # If no STAs specified, find all the STA in the testrig.
    # This includes clones, if any. AP are not explicitly requested,
    # but user can reqest them
    set loose 1
    set STAs [UTF::find_stas $(stas) "$::sta_type_list" $loose]
    UTF::Message LOG "$::localhost" "STAs=$STAs"

    # So far, AP dont work with pkteng. But we let people try anyway...
    set APs $(aps)
    UTF::Message LOG "$::localhost" "APs=$APs"

    # Set email subject & report title.
    set email_subject [UTF::setup_email_subject $(title)]

    # Log testbed info. Although the trailer / testbed info is added to the
    # end of the summary web page, for development, a lot of the time the
    # script is deliberately aborted before this occurs. Logging the data
    # now ensures you can go see the data on your screen or the general log
    # file.
    UTF::Message INFO "" "$::UTF::trailer_info"

    # Main code body that starts html summary report and runs tests.
    UTF::WrapSummary $UTF::SummaryDir "$email_subject" "" "$(email)" {

        # Add a web link to the test.log file
        UTF::Try "Link to test.log" {
            return "html: <a href=\"./test.log\">test.log</a>"
        }
        set SummaryLoc [file dirname "$UTF::Logfile"]

        # Log key lists, etc.
        UTF::Message LOG "$::localhost" "endpoint_device_list=$::endpoint_device_list"
        UTF::Message LOG "$::localhost" "endpoint_sta_list=$::endpoint_sta_list"
        UTF::Message LOG "$::localhost" "router_device_list=$::router_device_list"
        UTF::Message LOG "$::localhost" "router_sta_list=$::router_sta_list"
        UTF::Message LOG "$::localhost" "STAs=$STAs"

        # Silence ALL the radios in the testrig, except sniffer.
        if {!$(noinit) && !$(noradiosetup)} {
            set cnt [llength "$::router_sta_list $::endpoint_sta_list"]
            UTF::Try "Turn off ALL $cnt radios in testrig" {
                set catch_resp [catch "UTF::turn_off_radios \"$::router_sta_list\" \"$::endpoint_sta_list\"" catch_msg]
                # Did we get any failures?
                if {$catch_resp == 0} {
                    return "$catch_msg"
                } else {
                    error "$catch_msg"
                }
            }

            # Push a second copy of results to web page in case framework put its own message instead.
            UTF::Try "Result from: Turn off ALL $cnt radios in testrig" {
                UTF::Message LOG "$::localhost" "See previous log file for details"
                # Did we get any errors in the previous section?
                if {$catch_resp == 0} {
                    return "$catch_msg"
                } else {
                    error "$catch_msg"
                }
            }

            # After STA has its radio turned off, deint the STA. This turns off the
            # messages from the STA. Later, when we load the STA, UTF will re-init
            # the STA and we get messages again. If we dont do the deinit, we will
            # get one copy of each message from each active clone as we load the driver
            # and do the pkteng tests. In one case I got 9 copies of each message
            # due to 8 clone variations for a 43236USB dongle. Most unhelpful!
            UTF::Message LOG "$::localhost" "deinit all devices"
            foreach STA "$::router_sta_list $::endpoint_sta_list" {
                catch "$STA deinit"
            }
        }

        # Reset all BT devices in testrig, if any. 
        if {!$(noinit)} {
            UTF::Try "Reset all BT devices" {
                UTF::reset_all_bt_devices
            }
        }

        # Set attenuator
        if {!$(noinit)} {
            UTF::Try "Set attenuator to: $(attnval)" {
                foreach item "ALL G1 G2 G3" {
                    catch "$item attn $(attnval)"
                }
            }
        }

        # Setup sniffer, even when -noinit is specified.
        set resp [UTF::setup_sniffer $(sniffer) $(chanspec)]

        # If sniffer doesnt work, stop the tests.
        if {$resp != ""} {
            error "Halting tests, sniffer setup failed!"
        }

        # Main processing loop for APs & STAs
        foreach STA "$APs $STAs" {
            set name [UTF::get_name $STA]

            # Skip OEM AP.
            set is_oem_ap [UTF::is_oem_ap $STA]
            if {$is_oem_ap} {
                UTF::Try "Skipping OEM AP $STA" {
                    return "Skipping OEM AP $STA"
                }
                continue
            }

            # Setup build date & tag info if needed.
            set is_ap [UTF::is_ap $STA]
            if {$is_ap} {
                if {$(rtrdate) != ""} {
                    $STA configure -date $(rtrdate)
                    $STA configure -image {}
                }
                if {$(rtrtag) != ""} {
                    $STA configure -tag $(rtrtag)
                    $STA configure -image {}
                }
            } else {
                if {$(stadate) != ""} {
                    $STA configure -date $(stadate)
                    $STA configure -image {}
                }
                if {$(statag) != ""} {
                    $STA configure -tag $(statag)
                    $STA configure -image {}
                }
            }
        
            # Load the AP/STA if required.
            if {!$(noinit)} {
                if {$is_ap} {
                    if {!$(noapload)} {
                        UTF::Try "Load AP $STA" {
                            UTF::load_rtr_retry $STA
                        }
                    } else {
                        UTF::Try "Reload AP $STA" {
                            UTF::reload_rtr $STA
                        }
                    }
                } else {
                    if {!$(nostaload)} {
                        UTF::Try "Load STA $STA" {
                            UTF::load_sta_retry $STA
                        }
                    } else {
                        UTF::Try "Reload STA $STA" {
                            UTF::reload_sta $STA
                        }
                    }
                }
            }

            # Start Sniffer capture
            UTF::Try "Start $(sniffer) capture for $STA" {
                UTF::start_sniffer $(sniffer) $(ringfilecnt) $(ringfilesize)
            }

            # Run pkteng commands
            set pkteng_stopped no
            UTF::Try "Test $STA pkteng CH=$(chanspec)" {

                # Get digits from chanspec to determine band.
                if {![regexp {(\d+)} $(chanspec) - ch]} {
                    set ch 0
                }
                # set ch 1 ;# test code

                # Basic STA setup
                catch "$STA wl disassoc"
                catch "$STA wl down"
                catch "$STA wl mimo_bw_cap 1"
                if {$ch >= 36} {
                    # Some devices, eg 43237 need to be band locked for pkteng
                    catch "$STA wl band a"
                } else {
                    catch "$STA wl band b"
                }
                catch "$STA wl up"
                catch "$STA wl mpc 0"
                if {$is_ap} {
                    UTF::set_ap_nvram $STA wl0_radio=1 wl1_radio=1
                } else {
                    $STA wl radio on
                }
                if {$is_ap} {
                    APChanspec $STA $(chanspec)
                } else {
                    $STA wl chanspec $(chanspec)
                }
                $STA wl chanspec ;# query the chanspec

                # NB: pkteng does NOT work with rate AUTO
                # You MUST use a fixed rate!
                set (rate) [string trim $(rate)]
                if {$(rate) != ""} {
                    set catch_resp [catch "$STA wl nrate -r $(rate)" catch_msg]
                } else {
                    set catch_resp [catch "$STA wl nrate -m $(nrate)" catch_msg]
                }
                $STA wl nrate ;# query the rate/nrate

                # Sometimes nrate (eg 43237sdio) doesnt work, but a_rate or bg_rate does work.
                if {$catch_resp != 0} {
                    if {$ch >= 36} {
                        set cmd a_rate ;# A band
                    } else {
                        set cmd bg_rate ;# B band
                    }
                    puts "chanspec=$(chanspec) ch=$ch cmd=$cmd"
                    if {$(rate) != ""} {
                        $STA wl $cmd -r $(rate)
                    } else {
                        $STA wl $cmd -m $(nrate)
                    }
                    $STA wl $cmd ;# query the rate/nrate
                }

                # Start pkteng
                set dest_mac "00:aa:00:aa:00:aa"
                set frame_cnt 0 ;# 0 means continuous test
                set src_mac "00:99:00:99:00:99"
                $STA wl pkteng_start $dest_mac tx $(gap) $(size) $frame_cnt $src_mac

                # Wait a bit, then stop pkteng, turn radio off.
                UTF::Sleep $(t) ;# 5 seconds at MCS 7 gives 30Mb .pcap file 
                $STA wl pkteng_stop tx
                if {$is_ap} {
                    UTF::set_ap_nvram $STA wl0_radio=0 wl1_radio=0
                } else {
                    $STA wl radio off
                }
                set pkteng_stopped yes
                return ""
            }

            # Did pkteng get stopped?
            if {$pkteng_stopped == "no"} {
                UTF::Message LOG "$name" "Make sure pkteng is stopped"
                catch "$STA wl pkteng_stop tx"
                if {$is_ap} {
                    catch "UTF::set_ap_nvram $STA wl0_radio=0 wl1_radio=0"
                } else {
                    catch "$STA wl radio off"
                }
            }

            # Stop Sniffer capture, always save the .pcap file.
            UTF::stop_sniffer $(sniffer) 1 $SummaryLoc $(ringfilecnt)

        # End main STA processing loop.
        }
    # End of code block for UTF::WrapSummary
    }
}
	
