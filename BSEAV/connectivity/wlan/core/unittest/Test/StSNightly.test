#!/bin/env utf
# -*-tcl-*-

#######################################################################################################
#######################################################################################################
#
#	DO NOT MODIFY THIS FILE
#	CONTACT Kevin Mirabadi
#
#######################################################################################################
#######################################################################################################

#
# StSNightly.test - Station-to-Station Protocol test script. NAN, AWDL, and P2P protocols are supported in this script.
#
# Written by: Kevin Mirabadi
#
# To get online help, type: Test/StSNightly.test -h
#

# $Id$
# $Copyright Broadcom Corporation$
#

# Test description:
#	Direct -> One P2P connection between GO & GC
#	Multi-channel ->
#		One P2P connection between GO & GC and 
#		One APSTA connection between (AP & GO) or (AP & GC)

# Examples to run the test:
# -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCI -title 'MCI 4357 Iguana NAN 1.0 Test Cases' -ap 4366c0-SoftAP1 -apdate 2016.4.27.0 -sta '4357i-NanMaster 4357i-NanSlave' -tests '[L1:APSTA:i1:i1:149/80:open:Create APSTA Link][L2:NAN:i1:i2:149/80:open:Create NAN Link][S1:L1:UDP:VI:BI:0:10][S2:L2:UDP:VI:BI:0:10]' -nan1
#
#Test/StSNightly.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap 'AP1-4331-4706:AP1-4360-4706 AP3-4360-4706:AP3-4331-4706' -sta '4355-Slave-WLAN 4355-Master-WLAN' -run_qos -qos_tests '[i1:i2:8:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]' -multicore_mode 0 -awdl -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap '4360-SoftAP' -apdate 2015.3.10.1 -sta '4355-Slave-WLAN 4355-Master-WLAN' -run_qos -qos_tests '[i1:i2:8:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]\|[i2:i1:8:P2P:TCP:BE:TX:0:60][i1:i2:8:APSTA:UDP:BE:TX:0:60]' -multicore_mode 0 -awdl -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap '4360-SoftAP' -apdate 2015.3.10.1 -sta '4355-Slave-WLAN 4355-Master-WLAN' -run_qos -qos_tests '[i1:i2:149/80:P2P:TCP:BE:BI:0:60][i1:i2:8:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60][i1:i2:8:APSTA:TCP:BE:BI:0:60]' -multicore_mode 0 -awdl -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap '4360-SoftAP' -apdate 2015.3.10.1 -sta '4355-Slave-WLAN 4355-Master-WLAN' -run_qos -qos_tests '[i1:i2:149/80:P2P:TCP:BE:BI:0:60][i1:i2:8:APSTA:TCP:BE:BI:0:60][i2:i3:149/80:P2P:TCP:BE:BI:0:60][i1:i3:8:APSTA:TCP:BE:BI:0:60]' -multicore_mode 0 -awdl -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCK -title 'MCK 4361 Iguana (No AP) P2P Video bi-dir Long Test P2PCh=36/80' -sta '4361i-PGO-WLAN 4361i-PGC-WLAN' -sts_bandwidth_VI 40M -run_qos -qos_tests '[i1:i2:149/80:P2P:TCP:BE:BI:0:60]' -multicore_mode 0 -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCK -title 'MCK 4361 Iguana (SoftAP) STA+GC P2P UDP Video bi-dir Long Test VSDB APCh=36/80 P2PCh=161/80' -ap '4360-SoftAP' -apdate '2015.3.10.1' -noapload -sta '4361i-PGO-WLAN 4361i-PGC-WLAN' -apsta_bandwidth_VI 40M -sts_bandwidth_VI 40M -run_qos -qos_tests '[i1:i2:149/80:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]' -multicore_mode 0 -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#Test/StSNightly.test -utfconf MCK -title 'MCK 4361 Iguana (AP) STA+GC P2P UDP Video bi-dir Long Test VSDB APCh=36/80 P2PCh=161/80' -ap 'AP1-4331-4706:AP1-4360-4706' -noapload -sta '4361i-PGO-WLAN 4361i-PGC-WLAN' -apsta_bandwidth_VI 40M -sts_bandwidth_VI 40M -run_qos -qos_tests '[i1:i2:149/80:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]' -multicore_mode 0 -no_wl_dump -nostaload -noapload -norestore -nosetuptestbed
#
##########################################################################################
# Notes:
#	Must have Network Time Protocol (NTP) setup at GO, GC, and UTF machines.
#	mac:
# 		Scripts uses IPV4
#		IPV6 and apple80211 functions work, but it is not totally complete
#	
# 	Voice functions is not implemented
# 	When doing iperf for APSTA and StS from the same machine, we need different
#		names, so iperf results can be differentiated between APSTA and StS
# Supported:
#	GO and GC are Linux
#	GO and GC are mac
# NOT Supported:
#	Windows GO or GC
# To Debug P2P:
#	-wlinitcmds {wl msglevel +mchan +ps +p2p +apsta +inform} 
# Chariot uses interval of 200 ms for throughput, but iperf uses min interval of 500 ms.
##########################################################################################
# For AWDL Linux:
# 1) trunk WL may not support the AWDL
# 2) before FW download, you must do dhd "dma_ring_indices 3", "h2d_phase 1", "force_trap_bad_h2d_phase 1" 
# 	Use "-postinstall {dhd -i eth0 dma_ring_indices 3; dhd -i eth0 h2d_phase 1; dhd -i eth0 force_trap_bad_h2d_phase 1}"
# 3) Use 'event' to confirm awdl is hopping on both channels:
#	dhd -i eth1 msglevel +event
#	wl event_msgs 0xf000000000000000000000000
##########################################################################################
# NoA (Notice of Absence) setting
# wl p2p_noa <type> <action> <option> <schedule>
# 		<type> 		= 0 periodic schedule
#		<action> 	= 1 Sleep if possible
#		<option> 	= 1 beacon interval percentage
#		<schedule> 	= none
# 		<start-pct> = 10
#		<duration-pct> = 50
##########################################################################################
# Channel switch time is about 2.2 ms (from the log data "wlc_set_chanspec - completed")
##########################################################################################
# Iperf:
# Version 2.0.5 has high CPU usage when using "-D" to start the server as daemon
# iperf_install_location_linux "/projects/hnd/archives/unix/UTF/usr/local/bin"
# iperf_install_location_mac   "/projects/hnd/archives/Mac/UTF/usr/bin"
#################################
# IPERF params:
#################################
# S - TOS - Type of Service: (or AC for Access Class)
# 765 4 3210 AC TOS  pktq_stats prec#
# ========== == ==== ================
# 000 0 0000 BE 0x00 0
# 001 0 0000 BK 0x20 2
# 010 0 0000 BK 0x40 4
# 011 0 0000 BE 0x60 6
# 100 0 0000 VI 0x80 8
# 101 0 0000 VI 0xA0 10
# 110 0 0000 VO 0xC0 12
# 111 0 0000 VO 0xE0 14
#################################
# l - length or packet size - 8 KB default
# BE 512
# BK 512
# VI 1470
# VO 200
#################################
# b - bandwidth or rate - 1 Mbps default
# BE 200M
# BK 25M
# VI 3.5M
# VO 8kbps
#################################
# APSTA authentication = "aespsk2", "tkippsk", "wep"
# StS authentication = "wpa2psk"
##########################################################################################
# QoS:
# 3 stream with total time of 30 sec
# stream 1 and 2 starts at 0 sec. stream 3 starts at 15 sec
# Throughput data:
#	part 1 from 3 to 13 for streams 1 and 2
#	part 2 from 18 to 28 for streams 1, 2, and 3
#
##############################
# All the 3 streams TOS
##############################
# BK BE BK
# VO BE VO (not used)
# VI BE VI (not used)
# --------
# BE VO BE 
# BK VO BK 
# VI VO VI 
# --------
# VO VI VO (not used) 
# BE VI BE 
# BK VI BK
# --------
# VI BK VI (not used)
# VO BK VO (not used)
# BE BK BE (not used)
##############################
##########################################################################################
# Gnuplot:
# line type 0 - dashed grey
# line type 1 - solid light red
# line type 2 - solid light green
# line type 3 - solid light blue
# line type 4 - solid light purple
# line type 5 - solid aqua
# line type 6 - solid brown
# line type 7 - solid yellow
# line type 8 - solid dark blue
# line type 9 - solid gold
# line type 10 - solid dark green
# line type 11 - solid dark purple
# line type 12 - solid dark brown
# line type 13 - solid light pink
# line type 14 - solid lime green
# line type 15 - solid grey blue
# line type 154 - solid orange
#----------------
# point type 0 - none
# point type 1 - horizontal bar
# point type 7 - open box 
#----------------
# point size 0 - none
# point size 1 - smallest
#----------------
# line width 1 point
# line width 2 points
##########################################################################################
# VSDB -> same band channels for both APSTA and StS -> Mimo -> nrate = 2x9 -> rsdb_mode = 0
# RSDB -> multi- APSTA on one band and StS on the other band -> Siso -> nrate = 1x9 -> rsdb_mode = 1
##########################################################################################
# Samsung oxygen sensor uses ADHOC network. Advanced IBSS (Independent Basic Service Set) called AIBSS is used 
# which can support up to 32 devices.  
#
#
# NANDP Info:
# It receives a Synchronization Beacon 1 frame with the RSSI higher than RSSI_close from a NAN Device within the same NAN Cluster,
# and the Master Rank of the Synchronization Beacon transmitter is higher than the device’s Master Rank, or it receives Synchronization 
# Beacon frames from three or more NAN Devices within the same NAN Cluster with RSSI higher than RSSI_middle and the Master Rank of 
# those devices are higher than the Master Rank of the receiving device the value for RSSI_close shall be greater than -60 dBm. The 
# value for RSSI_middle shall be greater than -75 dBm and less than the value defined for RSSI_close.
# If rssi is between RSSI_Close (-60dBm) to RSSI_middle (-75dBm), then device could take master role.  It is same for both 2.4g & 5g.

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::sts_help "\n\nBasic usage: Test/StSNightly.test <options>\
	\n\nThis script will setup your Station-to-Station Protocol test by loading the desired\
	\nbuilds, making connections between your wireless devices & running numerous\
	\ntests."

# Command line options string
set ::sts_getopts {
	{suiteid.arg "meta" "Metacript ID used for data store"}
	{email.arg ""		"Email address list, format: userid1,userid2,... default is your userid"}
	{title.arg ""		"Title description text string for use in the reports"}
	{ap.arg ""			"APSTA router names.  For simultaneous dualband routers, use a pair '2g:5g'"}
	{aptag.arg "" 		"Router release tag"}
	{apdate.arg "" 		"AP Image date"}
	{trx.arg "" 		"Router trx"}
	{stabin.arg "" 		"Private build STA dongle image (rtecdc.bin firmware)"}
	{stadhd.arg "" 		"Private build STA dongle Linux DHD image (wl.ko high driver)"}
	{statag.arg "" 		"STA release tag"}
	{stadate.arg ""		"STA Image date"}
	{stadhddate.arg ""	"STA DHD Image date"}
	{branch.arg "auto" 	"Branch override"}
	{noapload 			"Don't load images"}
	{nostaload 			"Don't reload STA drivers"}
	{nostareload 		"Don't even reload STA drivers"}
	{norestore 			"Don't reset to defaults"}
	{nounload 			"Don't unload driver after test"}
	{nosetup 			"No Setup"}
	{nocache 			"Don't update performance cache"}
	{noping				"Don't run ping/ayt tests, default is run the ping/ayt tests"}
	{nosetuptestbed 	"Don't run Setup Testbed hooks"}
	{noposttesthook 	"Don't run Post Test hooks"}
	{logdir.arg ""		"Log directory override"}
	{run_noa			"run NoA tests"}
	{perfint.arg 1		"Test interval in seconds for each test sample"}
	{sta.arg ""			"STAs to test"}
	{sts_chan.arg "149/80 157l 157 11 1 40"	"Specify GO/Master channels to test"}
	{ap_chan.arg "36/80 36l 36 1 44l 11"	"Specify AP channels to test"}
	{OppPS_CTWindow.arg "50"	"OppPS CTWindow Parameter (see P2P documents)"}
	{NoA_Param.arg "0 1 1 10 50"	"NoA (Notice of Absence) Parameters (see P2P documents)"}
	{debug_flag			"This flag will enable debug dumps"}
	{socram_dump_flag	"This flag will enable socram and FW image dumps"}
	{fb.arg ""			"frameburst value. BLANK=Default, 0=off 1=on"}
	{apsta_bandwidth_VO.arg 	"10M"	"Voice wlan bandwidth or rate list for each APSTA channel. Default is 10M"}
	{sts_bandwidth_VO.arg 	"10M"	"Voice StS bandwidth or rate list for each StS channel. Default is 10M"}
	{apsta_bandwidth_VI.arg 	"40M"	"Video wlan bandwidth or rate list for each APSTA channel. Default is 40M"}
	{sts_bandwidth_VI.arg 	"40M"	"Video StS bandwidth or rate list for each StS channel. Default is 40M"}
	{apsta_bandwidth_BE.arg 	"1.2g"	"Best-effort wlan bandwidth or rate list for each APSTA channel. Default is 1.2g"}
	{sts_bandwidth_BE.arg 	"1.2g"	"Best-effort StS bandwidth or rate list for each StS channel. Default is 1.2g"}
	{apsta_bandwidth_BK.arg 	"40M"	"Background wlan bandwidth or rate list for each APSTA channel. Default is 40M"}
	{sts_bandwidth_BK.arg 	"40M"	"Background StS bandwidth or rate list for each StS channel. Default is 40M"}
	{apsta_packet_size_VO.arg "200"	"Voice wlan packet size or length list for each APSTA channel. Default is 200"}
	{sts_packet_size_VO.arg "200"	"Voice StS packet size or length list for each StS channel. Default is 200"}
	{apsta_packet_size_VI.arg "1470"	"Video wlan packet size or length list for each APSTA channel. Default is 1470"}
	{sts_packet_size_VI.arg "1470"	"Video StS packet size or length list for each StS channel. Default is 1470"}
	{apsta_packet_size_BE.arg "512"	"Best-effort wlan packet size or length list for each APSTA channel. Default is 512"}
	{sts_packet_size_BE.arg "512"	"Best-effort StS packet size or length list for each StS channel. Default is 512"}
	{apsta_packet_size_BK.arg "512"	"Background wlan packet size or length list for each APSTA channel. Default is 512"}
	{sts_packet_size_BK.arg "512"	"Background StS packet size or length list for each StS channel. Default is 512"}
	{vsdb_mode.arg ""	"Virtual Simultaneous Daul Band Algorithm Mode. 0=Default (Beacon Position based), 1=Bandwidth Based, 2=Service Interval Based"}
	{vsdb_bw_percentage.arg "50" "Virtual Simultaneous Daul Band Bandwidth Perventage for Bandwidth Based Algorithm Mode. Default=50% for primary channel, rest for secondary channel"}
	{rsdb_mode.arg ""	"Real Simultaneous Daul Band Mode. BLANK=Default, 0=RSDB off (VSDB mode for same band), 1=RSDB on (for multi-band)"}
	{nrate_check.arg ""				"Check the nrate value. BLANK=Default, 1x9=RSDB 2x9=VSDB"}
	{rsdb_switch_test				"Run test to switch between RSDB and VSDB and validate the MCS rate"}
	{channel_sweep_test				"Run channel sweep test"}
	{mpc_mode.arg ""	"MPC Mode. BLANK=Default, 0=MPC off, 1=MPC on"}
	{quick_exit			"exit right after the 1st throughput is ran"}
	{graphs_with_min_max	"Generate graphs with min max values, default is graphs without min max values"}
	{new_beacon_interval.arg ""	"Change beacon interval to the new value. Default is blank (no beacon interval change. Default driver bi=100 ms)"}
	{qos_ampdu_mode.arg "1"	"Turn AMPDU on/off. Default is 1 (on)"}
	{measure_current_sta.arg ""	"Measurement current in middle of throughput run on the STA with Agilent instrument. Default is no current measurement"}
	{pm_mode.arg "2"		"PM mode to use for APSTA and P2P. Default is the driver PM 2 mode"}
	{no_ampdu_dump			"Do not dump ampdu while running throughput since it causes RX throughput drop, default is to run throughput with ampdu dump"}
	{no_wl_dump				"Do not dump any wl data while running throughput, default is to run throughput with wl data dump"}
	{scan_flag				"Do scan in the background while the throughput is running"}
	{escan_flag				"Do escan in the background while the throughput is running"}
	{kpi_flag				"Use KPI test special data collection"}
	{macos_pcap_flag		"For MacOS, dump PCAP for debugging"}
	{bt_root_sta.arg ""		"BT STA object with 'root' login. Default is BLANK"}
	{bt_user_sta.arg ""		"BT STA object with 'user' login (is needed for playFileIniTunes). Default is BLANK"}
	{bt_wav_file.arg "/Users/user/Music/iTunes/OneHour.wav"	"BT iTune wav file to play with playFileIniTunes)"}
	######################################################################################################################														
	{current_sample_time.arg "300E-6"	"Setup the sampling interval (5.12 to 40000 us). Default is 300 us sample time (300E-6 * 50000 = 15 seconds total measure time)"}
	{current_sample_points.arg "50000"	"Setup the number of points to measure the current (1 to 512K). Default is 50000 samples"}
	{current_offset_points.arg "-500"	"Setup the offset points before/after sampling starts. Default is -500 points"}
	{current_range.arg "1.0"	"Setup the current range. Default is 1 Amp"}
	{current_trigger.arg "0.075"	"Setup the starting current trigger point. Default is 75 mA"}
	{current_wait_sec.arg "0"	"Time to wait before reading the current results. Default is 3 seconds"}
	######################################################################################################################														
	{gnuplot_font.arg "/usr/share/fonts/dejavu/DejaVuSans-Bold.ttf"	"GNUPLOT font to use for the graphs"}
	{gnuplot_font_size.arg "8"	"GNUPLOT font size to use for the graphs"}
	######################################################################################################################														
	{sniffer.arg 					""	"sniffer object name"}
	{sniffer_channel.arg			"" 	"sniffer channel to use for data capture"}
	{sniffer_capture_time_sec.arg	""	"Time in sec to collect data. BLANK=Default (no capture)"}
	######################################################################################################################														
	{multicore_mode.arg ""	"CPU 1,2,3 mode on STAs. BLANK=Default, 1=multicore on, 0=multicore off"}
	{ping_count.arg "5"	"Number of times to ping. Default is 5 times"}
	{run_qos			"Run QoS tests and not StS"}
	{enable_ntp			"Enable NTP"}
	######################################################################################################################														
	# Defining Test Streams:
	#	e.g. one APSTA stream: [i1:i1:8:APSTA:TCP:BE:RX:0:10]
	#	e.g. one AWDL stream: [i3:i1:36/80:AWDL:TCP:BE:RX:0:10]
	#	e.g. two streams running simultaneously: [i1:i1:8:APSTA:TCP:BE:RX:0:10][i3:i1:36/80:AWDL:TCP:BE:RX:0:10]
	#	e.g. two streams running back to back:   [i1:i1:8:APSTA:TCP:BE:RX:0:10]|[i3:i1:36/80:AWDL:TCP:BE:RX:0:10]
	# Test Stream Options:
	# 	[sta_master:sta_slave:link_type:traffic_type:channel:start_time:
	#		src					- For APSTA: AP - index to 'ap' parameter. 
	#		 					  For P2P AWDL NAN: sta_master - index to 'sta' parameter. This is the GO/Master machine. 
	#		 					  For BT: 'bt_root_sta' parameter.  
	#		dst					- For APSTA: STA - index to 'sta' parameter. 
	#		 					  For P2P AWDL NAN BT: sta_slave - index to 'sta' parameter. This is the GC/Slave machine. 
	#		 					  For BT: Blank.
	#		channel				- For APSTA: index to 'ap_chan' parameter or channel number or all 'ap_chan' parameter 
	#		 					  For P2P AWDL NAN: index to 'sts_chan' parameter or channel number or all 'ap_chan' parameter 
	#		 					  For BT: Blank.
	#		link_type			- APSTA P2P AWDL NAN BT
	#		traffic_type		- TCP UDP A2DP
	# 		traffic_priority	- BE BK VI VO (this is iperf 'Type of Service' or 'tos'
	# 		traffic_direction	- RX TX BI
	# 		start_time			- iperf start time (0 or n sec)
	# 		end_time			- iperf end time (start time + n sec)
	######################################################################################################################
	# LT1 and LT2 will be replaced with "AWDL P2P AWDL NAN BT" based on 'lint_types' parameter
	{tests.arg "\
					[i1:i1:i1:LT1:TCP:BE:RX:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:0]|\
					[i1:i1:i1:LT1:TCP:BE:TX:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:0]|\
					[i1:i1:i1:LT1:TCP:BE:BI:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:0]|\
					\
					[i1:i1:i1:LT1:TCP:BE:RX:0:0][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:TX:0:0][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:BI:0:0][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					\
					[i1:i1:i1:LT1:TCP:BE:RX:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:RX:0:25][i1:i1:i1:LT2:TCP:BE:TX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:RX:0:25][i1:i1:i1:LT2:TCP:BE:BI:0:25]|\
					\
					[i1:i1:i1:LT1:TCP:BE:TX:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:TX:0:25][i1:i1:i1:LT2:TCP:BE:TX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:TX:0:25][i1:i1:i1:LT2:TCP:BE:BI:0:25]|\
					\
					[i1:i1:i1:LT1:TCP:BE:BI:0:25][i1:i1:i1:LT2:TCP:BE:RX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:BI:0:25][i1:i1:i1:LT2:TCP:BE:TX:0:25]|\
					[i1:i1:i1:LT1:TCP:BE:BI:0:25][i1:i1:i1:LT2:TCP:BE:BI:0:25]"}
	######################################################################################################################														
	{qos_tests.arg "\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					\
					[i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:VO:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:VO:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:5:20]|\
					\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BE:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BE:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BE:RX:5:20]|\
					\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:TX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VI:TX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BK:TX:5:20]|\
					[i1:i1:i1:LT1:UDP:BK:RX:0:25][i1:i1:i1:LT1:UDP:VI:RX:0:25][i1:i1:i1:LT1:UDP:BK:RX:5:20]"}
	######################################################################################################################														
	{testbed_path_loss.arg	 "0" "Testbed fixed path lose in dB"}
	{attn_type.arg 0	 	 "Types of RvR attenuation: 0=None, 1=APSTA, 2=StS, 3=APSTA+StS. Default is 0 (none)"}
	{rvr_attn_incr.arg		 "1" "RvR attenuation increment for each step. Default is 1 dB"}
	{rvr_apsta_attn_range.arg "10-90 90-10" "RvR APSTA attenuation range"}
	{rvr_sts_attn_range.arg	 "10-90 90-10" "RvR StS attenuation range"}
	######################################################################################################################														
	{roam_src_ap.arg		"" "Router roaming from"}
	{roam_dst_ap.arg		"" "Router roaming to"}
	{no5G80roaming			"No 5G 80Mhz Roaming Tests"}
	{no5G40roaming			"No 5G 40Mhz Roaming Tests"}
	{no5G20roaming			"No 5G 20Mhz Roaming Tests"}
	{no2G40roaming			"No 2G 40Mhz Roaming Tests"}
	{no2G20roaming			"No 2G 20Mhz Roaming Tests"}
	{nosmoothroaming 		"Don't do Smooth Roaming Test"}
	{nofailoverroaming 		"Don't do Failover Roaming Test"}
	{roam_estimate_attn 	"Display the estimated values for the attenuation on the report"}
	{roam_5G80_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_5G40_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_5G20_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_2G40_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_2G20_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	######################################################################################################################
	# AWDL (Apple Wifi Direct Link)
	# To get stready good throughput for AWDL only test, use awdl_chan_seq='0xe09be09be09be09be09be09be09be09be09be09be09be09be09be09be09be09b'
	{awdl_chan_seq.arg	"" "AWDL channel sequence for non-idle. default is BLANK"}
	######################################################################################################################														
	{nan1				"Run NANDP (Neighbor Awareness Networking Discovery Protocol) 1.0 tests, default is not running NAN tests"}
	{aibss				"Run AIBSS (Advanced IBSS) tests, default is not running AIBSS tests"}
	{11mc				"Run 11mc tests, default is not running 11mc tests"}
	######################################################################################################################														
}

# Setup online help info.
UTF::setup_help $::sts_help $::sts_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
	set ::argv ""
}

# Load packages
package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::controlchart
package require UTF::Test::memchart
package require UTF::Test::rssinoise
package require UTF::MemChart
package require UTF::Sniffer
package require math
package require UTF::KPI::KeyValue
package require UTF::KPI::OSEvents

namespace eval sts {}

################
set ::bt_test_flag 0
################
set ::controller "lan"
set ::curr_test_no -1
set ::curr_stream_no -1
################
set ::sts_link_types "P2P AWDL NANDP"
set ::sts::cc_error ""
set ::rvr_sts_attngrp ""
set ::p2p_ssid "P2PSSID"
################
set ::nan_ping_flag 0
set ::nan_base_cluster_id ""
################
set ::bt_load_flag 0
set ::bt_only_flag 0
################
set ::rvr_apsta_attngrp ""
################
set ::iperf_running_flag 0
set ::iperf_server_err ""
set ::iperf_starting_port 55001
set ::curr_iperf_port 0
################
set ::perfint 0
set ::apple_tool "/usr/local/bin/apple80211"
set ::vsdb_mode ""
set ::vsdb_bw_percentage ""
set ::rsdb_mode ""
set ::mpc_mode ""
set ::err_msg ""
set ::streams_total_time ""
set ::agilent_obj ""
set ::agilent_port ""
set ::voltage 0
set ::current_results ""
set ::pktq_stats_flag 0
set ::roaming_error_flag 0
set ::test_error_flag 0
set ::curr_csv_data_file ""
set ::curr_csv_data_fullname ""
set ::curr_csv_throughput_data_file ""
set ::curr_csv_throughput_data_fullname ""
set ::curr_gnuplot_data_line_cnt 0
set ::ping_count 0
set ::gnuplot_font ""
set ::gnuplot_font_size 0
set ::rvr_attn_incr 0
set ::rvr_test_flag 0
set ::rvr_zero_throughput_flag 0
set ::gnuplot_xtic_label ""
set ::gnuplot_x_max_rvr_val ""
set ::gnuplot_x_max_time_val ""
set ::curr_attn_incr 0
set ::graph_max_width 0
set ::graph_max_height 0
set ::curr_attn_value 0
set ::saved_hook_start_timestamp ""
set ::sniffer_object ""
set ::sniffer_channel ""
set ::sniffer_capture_time_sec ""
set ::sniffer_started_flag 0
set ::sniffer_filename ""
set ::sniffer_process_id 0
set ::sniffer_start_time_secs 0
set ::max_attn 0
set ::roaming_test_flag 0
set ::failover_test_flag 0
set ::roam_trigger_value ""
set ::roam_delta_value ""
set ::roaming_src_ap ""
set ::roaming_dst_ap ""
set ::roaming_channel 0
set ::roaming_dwell_time_sec 0
set ::roaming_max_loop_cnt 0
set ::roaming_src_ap_attn 0
set ::roaming_src_ap_attn_start 0
set ::roaming_src_ap_attn_end 0
set ::roaming_dst_ap_attn 0
set ::roaming_dst_ap_attn_start 0
set ::roaming_dst_ap_attn_end 0
set ::roaming_src_ap_mac ""
set ::roaming_dst_ap_mac ""
set ::roaming_src_ap_attn_group ""
set ::roaming_dst_ap_attn_group ""
set ::roaming_sniffer_file_name ""
set ::roaming_sniffer_start_attn 0
set ::roaming_sniffer_failed_flag 0
set ::roaming_sniffer_failed_msg ""
set ::roaming_test_title ""
set ::roaming_test_ssid "RoamingTestSSID"
set ::roaming_band ""
set ::roaming_cap ""
set ::roamed_flag 0
set ::roam_time -1
set ::roaming_html_results ""				
set ::last_csv_data_BaseTime ""
set ::last_csv_throughput_data_BaseTime ""
set ::error_cnt 0
set ::base_timestamp_tick 0
set ::halt_test_err ""
set ::panic_msg ""
set ::scan_test_flag 0
set ::escan_test_flag 0
set ::kpi_test_flag 0
set ::graph_label_test ""

proc sts::random_number {min max} {
	return [expr int(rand()*($max-$min+1)) + $min] 
}

proc sts::get_testnum { } {
    set testnum [file tail $UTF::Logfile]
    set testnum [file rootname $testnum]
    set testnum [string trim $testnum]
    return $testnum
}

proc sts::collect_rpopen_data {timeout_sec timed_host_fd_list timed_output\
    untimed_host_fd_list untimed_output} {
    upvar $timed_output timed_response
    upvar $untimed_output untimed_response

	UTF::Message INFO "" "************************Func:collect_rpopen_data***************************"

    # Check timeout is numeric, GE 1.
    if {![regexp {^\d+$} $timeout_sec] || $timeout_sec < 1} {
        error "invalid timeout_sec=$timeout_sec,\
            must be integer, GE 1"
    }

    # We need at least one pair of host & fd in one of the lists.
    if {[llength $timed_host_fd_list] < 2 && [llength $untimed_host_fd_list] < 2} {
        error "Need at least one host & fd\
            specified in either of: timed_host_fd_list=$timed_host_fd_list\
            untimed_host_fd_list=$untimed_host_fd_list"
    }

    # Check that output variables are not null & not the same.
    set timed_output [string trim $timed_output]
    set untimed_output [string trim $untimed_output]
    if {$timed_output == "" || $untimed_output == ""} {
        error "output variables must not be\
            null, timed_output=$timed_output untimed_output=$untimed_output"
    }
    if {$timed_output == $untimed_output} {
        error "output variables must not be\
            the same, timed_output=$timed_output untimed_output=$untimed_output"
    }

    # Load each list host names & file descriptor parameters into an array.
    UTF::Message LOG "" "timeout_sec=$timeout_sec timed_host_fd_list=$timed_host_fd_list\
            timed_output=$timed_output untimed_host_fd_list=$untimed_host_fd_list\
            untimed_output=$untimed_output"
    set cnt_timed 0
    set cnt_untimed 0
    set i 0
    foreach {host_fd_list timing} [list $timed_host_fd_list timed\
        $untimed_host_fd_list untimed] {
        # puts "host_fd_list=$host_fd_list timing=$timing"
        foreach {host fd} $host_fd_list {
            set host [string trim $host]
            set fd [string trim $fd]
            if {$host == "" || $fd == ""} {
                continue
            }

            set logname $host

            # Store data in next array column.
            incr i
            incr cnt_$timing
            set array(host,$i) $host
            set array(logname,$i) $logname
            set array(fd,$i) $fd
            set array(timing,$i) $timing ;# each fd is shown as timed or untimed

            # configure fd options
            set catch_resp [catch "fconfigure $fd -buffering line -buffersize 1024" catch_msg]
            if {$catch_resp != 0} {
                UTF::Message WARN "" "fconfigure $fd\
                catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        }
    }
    # puts "i=$i cnt_timed=$cnt_timed cnt_untimed=$cnt_untimed"

    # Wait for any of the file descriptors to produce output.
    set start_sec [clock seconds]
    while { 1 } {

        # In order to implement a timer, we need to periodically go 
        # through this while loop so we can check on overall elapsed
        # time and take recovery action as needed. So we use a 1 sec timer
        # to ensure this occurs.

        # Vwait needs to see some code in the current routine / file that
        # conditionaly writes to the variable that vwait will watch. If the
        # after statement is removed, you get TCL error "can't wait for
        # variable ::p2p_utils_reading, would wait forever".
        after 1000 {set ::p2p_utils_reading 1}

        # All the file descriptor event handlers have been told to 
        # write to the same global variable ::p2p_utils_reading. We use
        # vwait to wait for output from any of the file descriptors.
        vwait ::p2p_utils_reading

        # vwait received an event. We may have some output to process now.
        # Check each not-null fd in the array.
        set timed_done yes
	    for {set j 1} {$j <= $i} {incr j} {

            # Ignore any blank fd, we are done with them.
            set fd $array(fd,$j)
            set host $array(host,$j)
            set logname $array(logname,$j)
            set timing $array(timing,$j)
            # puts "j=$j fd=$fd host=$host logname=$logname timing=$timing"
            if {$fd == ""} {
                continue
            } elseif {$timing == "timed"} {
                set timed_done no
            }

            # Try to get data from fd.
            set msg ""
            set catch_resp [catch "set msg \[gets $fd\]" catch_msg]
            # puts "catch_resp=$catch_resp catch_msg=$catch_msg"
            if {$catch_resp != 0} {
                # This fd may have been valid earlier, but it is now expired.
                UTF::Message WARN "" "fd=$fd $catch_msg"
                set array(fd,$j) "" ;# we are done with this fd
                continue
            }

            # Process data from fd.
            if {[eof $fd]} {
                UTF::Message LOG "" "got normal EOF, closing fd=$fd host=$host"
                # Put file descriptor back to blocking so that close can
                # get a valid return status
                fconfigure $fd -blocking 1
                if {[catch {close $fd} ret]} {
                    UTF::Message ERROR "" "ERROR closing fd=$fd $ret"
                }
                set array(fd,$j) "" ;# we are done with this fd

            } elseif {![fblocked $fd]} {
                # Keep timed output separate from untimed_output.
                # Add timestamps to the _response data.
                set hhmmss [clock format [clock seconds] -format "%T"]
                if {$timing == "timed"} {
                    lappend timed_response "$hhmmss $host $msg" ;# dont use logname here!
                } else {
                    lappend untimed_response "$hhmmss $host $msg" ;# dont use logname here!
                }
                UTF::Message LOG "" $msg
            }
        }

        # Are we done or timed out?
        # NB: If we had only untimed fd, then we exit loop only on timeout.
        set elapsed_sec [expr {[clock seconds] - $start_sec}]
        # puts "elapsed_sec=$elapsed_sec"
        if {($timed_done == "yes" && $cnt_timed > 0) || $elapsed_sec > $timeout_sec} {
            break
        }
    }

    # If we timed out, terminate the pids associated for each timed file
    # descriptor that has not already been closed. Leave the untimed file
    # descriptors alone!
    if {$elapsed_sec > $timeout_sec} {
       	for {set j 1} {$j <= $i} {incr j} {
            set fd $array(fd,$j)
            set host $array(host,$j)
            set timing $array(timing,$j)
            if {$fd != "" && $timing == "timed"} {
                set pid [pid $fd]
                UTF::Message WARN "" "timeout, terminating fd=$fd pid=$pid for host=$host"
                set catch_resp [catch "exec kill -9 $pid" catch_msg]
				UTF::Sleep 1
                if {$catch_resp != 0} {
                    UTF::Message ERROR "" "did not terminate pid=$pid: $catch_msg"
                }
            }   
        }
    }

    # To simplify debugging, show list of untimed fd that are still open.
    if {$cnt_untimed > 0} {
        set untimed_list ""
        for {set j 1} {$j <= $i} {incr j} {
            set fd $array(fd,$j)
            set host $array(host,$j)
            set timing $array(timing,$j)
            if {$fd != "" && $timing == "untimed"} {
                lappend untimed_list "$host $fd"
            }
        }
        UTF::Message INFO "" "still active untimed host & fd: $untimed_list"
    }

    return ""
}

proc sts::kpi_dump_xml_data {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:kpi_dump_xml_data***************************"

	set kpi_test_db [UTF::KPI::KeyValue %AUTO% -parent $::kpi_base_db]

    $kpi_test_db set tryID $::UTF::__tryid
    $kpi_test_db set "logfile" $UTF::Logfile

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		$::kpi_base_db set "InfraChannel" "$::array_streams_apsta_link_chan(${::curr_test_no})"
		$::kpi_base_db set "AWDLChannel" "$::array_streams_sts_link_chan(${::curr_test_no})"

		########## linktype can be 'Infra, AWDL, BT' ##########
		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
			set linktype "Infra"
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "P2P"} {
			set linktype "P2P"
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "AWDL"} {
			set linktype "AWDL"
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "NANDP"} {
			set linktype "NAN"
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			set linktype "BT"
		} else {
			set linktype ""
		}
		
		$::kpi_base_db set "linktype" "$linktype"

		########## traffic_direction can be 'Downlink, Uplink, Bidirectional' ##########
		if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BIRX" || $::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
			set traffic_direction "Bidirectional"
		} elseif {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "RX"} {
			set traffic_direction "Downlink"
		} elseif {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "TX"} {
			set traffic_direction "Uplink"
		} else {
			set traffic_direction ""
		}
		
		$::kpi_base_db set "traffic_direction" "$traffic_direction"

		########## TrafficType can be 'TCP, UDP, A2DP' ##########
		########## TrafficPriority can be 'BE, BK, VI, VO' ##########
		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			set TrafficType "A2DP"
			set TrafficPriority ""
		} elseif {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set TrafficType "TCP"
			set TrafficPriority "BE"
		} else {
			set TrafficType "UDP"
			set TrafficPriority $::array_streams_traffic_priority(${::curr_test_no},${stream_no})
		}
		
		$::kpi_base_db set "TrafficType" "$TrafficType"
		$::kpi_base_db set "TrafficPriority" "$TrafficPriority"

		##########
		
		$::kpi_base_db set "trytext" "$stream_no"
		if {$::test_error_flag == 0} {
			$::kpi_base_db set "TryResult" "PASS"
		} else {
			$::kpi_base_db set "TryResult" "FAIL"
		}

		set actual_throughput_data_cnt [llength $::array_streams_throughput(${::curr_test_no},${stream_no})]
		# devide by 2 to remove the timestamp
		set actual_throughput_data_cnt [expr {$actual_throughput_data_cnt / 2.0}]

		UTF::Message INFO "" "::array_streams_throughput(${::curr_test_no},${stream_no})=$::array_streams_throughput(${::curr_test_no},${stream_no})"
		if {$::array_streams_tcp_writes(${::curr_test_no},${stream_no}) != ""} {
			UTF::Message INFO "" "::array_streams_tcp_rtt(${::curr_test_no},${stream_no})=$::array_streams_tcp_rtt(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_tcp_writes(${::curr_test_no},${stream_no})=$::array_streams_tcp_writes(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_tcp_errors(${::curr_test_no},${stream_no})=$::array_streams_tcp_errors(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_tcp_retries(${::curr_test_no},${stream_no})=$::array_streams_tcp_retries(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})=$::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})"
		}
		if {$::array_streams_udp_jitter(${::curr_test_no},${stream_no}) != ""} {
			UTF::Message INFO "" "::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_udp_jitter(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_udp_pps(${::curr_test_no},${stream_no})"
		}

		for {set index_cnt 0} {$index_cnt < $actual_throughput_data_cnt} {incr index_cnt} {

			catch {array unset kpi_test_vlaues}

			set kpi_test_vlaues(data_index_no) [expr $index_cnt + 1]
		
			set kpi_test_vlaues(throughput_time) [lindex $::array_streams_throughput(${::curr_test_no},${stream_no}) [expr $index_cnt * 2]]
			set kpi_test_vlaues(throughput) [lindex $::array_streams_throughput(${::curr_test_no},${stream_no}) [expr [expr $index_cnt * 2] + 1]]

			UTF::Message INFO "" "kpi_test_vlaues(throughput_time)=$kpi_test_vlaues(throughput_time)"
			UTF::Message INFO "" "kpi_test_vlaues(throughput)=$kpi_test_vlaues(throughput)"

			if {$::array_streams_tcp_writes(${::curr_test_no},${stream_no}) != ""} {
				set kpi_test_vlaues(tcp_rtt) [lindex $::array_streams_tcp_rtt(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(tcp_writes) [lindex $::array_streams_tcp_writes(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(tcp_errors) [lindex $::array_streams_tcp_errors(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(tcp_retries) [lindex $::array_streams_tcp_retries(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(tcp_used_memory) [lindex $::array_streams_tcp_used_memory(${::curr_test_no},${stream_no}) $index_cnt]

				UTF::Message INFO "" "kpi_test_vlaues(tcp_rtt)=$kpi_test_vlaues(tcp_rtt)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_writes)=$kpi_test_vlaues(tcp_writes)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_errors)=$kpi_test_vlaues(tcp_errors)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_retries)=$kpi_test_vlaues(tcp_retries)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_used_memory)=$kpi_test_vlaues(tcp_used_memory)"
			}
			if {$::array_streams_udp_jitter(${::curr_test_no},${stream_no}) != ""} {
				set kpi_test_vlaues(udp_latency) [lindex $::array_streams_udp_latency_avg(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(udp_jitter) [lindex $::array_streams_udp_jitter(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(udp_lost_packets) [lindex $::array_streams_udp_lost_packets(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(udp_out_of_order_packets) [lindex $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) $index_cnt]
				set kpi_test_vlaues(udp_pps) [lindex $::array_streams_udp_pps(${::curr_test_no},${stream_no}) $index_cnt]

				UTF::Message INFO "" "kpi_test_vlaues(udp_latency)=$kpi_test_vlaues(udp_latency)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_jitter)=$kpi_test_vlaues(udp_jitter)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_lost_packets)=$kpi_test_vlaues(udp_lost_packets)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_out_of_order_packets)=$kpi_test_vlaues(udp_out_of_order_packets)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_pps)=$kpi_test_vlaues(udp_pps)"
			}

			$kpi_test_db setarray kpi_test_vlaues
			$kpi_test_db write
		}
	}
}

proc sts::macos_pcap_debug_dump_start {cleanup_flag} {
	# access option array
	upvar {} {}

	#+++++++++++++++++++++++++++++++++++++++++++++++++++
	# Downstream data Only:
	#
	# 	AWDL Only  - 4 PCAP files
	# 	AWDL+Infra - 7 PCAP files
	#
	# CONTROLLER:
	#	(Infra) - tcpdump -i en12 -w controller_en12_sender.pcap
	#
	# DUT:
	#	(Infra) - tcpdump -i en0 -w en0_receiver.pcap
	#	tcpdump -i awdl0 -w awdl0_sender.pcap
	#	apple80211 awdl0 -logf="v set" -outfile=awdl_pcap.pcap -dlog
	#
	# AWDL Peer:
	#	(Infra) - tcpdump -i en0 -w en0_receiver.pcap
	#	tcpdump -i awdl0 -w awdl0_receiver.pcap
	#	apple80211 awdl0 -logf="v set" -outfile=awdl_pcap.pcap -dlog
	#
	# killall tcpdump apple80211:
	#	AWDL
	#	DUT
	#	(Infra) - CONTROLLER
	#
	#+++++++++++++++++++++++++++++++++++++++++++++++++++

	UTF::Try "PCAP Debug Start" {

		UTF::Message INFO "" "************************Func:macos_pcap_debug_dump_start $cleanup_flag***************************"

		if {$cleanup_flag} {
			UTF::Message LOG "" "Create '$::logdir/PCAPData' directory"
			catch {file mkdir "$::logdir/PCAPData"}
		}

		set stas_list ""

		if {$(ap) != ""} {
			set infra_flag 1
			
			foreach ap $(ap) {
				# check for 2g:5g param
				set ap2g [split $ap ":"]
				set ap2g [lindex $ap2g 0]

				set ap_host_type [$ap2g hostis]

				if {$ap_host_type == "Router"} {		
					set ap_controller [$ap2g cget -lanpeer]
					lappend stas_list "AP Controller '$ap_controller': $ap: PCAP"
					lappend stas_list "$ap_controller "
				} else {
					# SoftAP controller is the same as SoftAP machine
					set ap_controller $ap
					lappend stas_list "SoftAP Controller 'lan': $ap: PCAP"
					lappend stas_list "lan"
					lappend stas_list "SoftAP '$ap_controller': PCAP"
					lappend stas_list "$ap_controller"
				}
			}
		} else {
			lappend stas_list "Controller 'lan': No AP: PCAP"
			lappend stas_list "lan"
			set infra_flag 0
		}
		
		foreach sta $(sta) {
			lappend stas_list "STA '$sta': PCAP"
			lappend stas_list "$sta"
		}
		
		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label STA} $stas_list {

			set sta_label [string trim $sta_label]
			set STA [string trim $STA]

			if {$STA == $::array_streams_ap_controller(${::curr_test_no})} {
				# Infra exists
				set tmp_disp "Controller"
				set tmp_ip $::tg_lan_ip
				set infra_ifname $::tg_apsta_ifname
				set awdl_ifname ""
				set tmp_tcpdump_infra "tcpdump_controller_tx_$infra_ifname"
				set tmp_tcpdump_awdl ""
				set tmp_drvlog_awdl ""
			} elseif {$STA == $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})} {
				# DUT
				set tmp_disp $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})
				set tmp_ip $::array_sta_lan_ip(${STA})
				set infra_ifname $::array_sta_apsta_ifname(${STA})
				set awdl_ifname $::array_sta_sts_ifname(${STA})
				set tmp_tcpdump_infra "tcpdump_dut_rx_$infra_ifname"
				set tmp_tcpdump_awdl "tcpdump_dut_tx_$awdl_ifname"
				set tmp_drvlog_awdl "drvlog_dut_tx_$awdl_ifname"
			} else {
				# AWDL Peer
				set tmp_disp $::array_streams_dst_display_str(${::curr_test_no},${::curr_stream_no})
				set tmp_ip $::array_sta_lan_ip(${STA})
				set infra_ifname $::array_sta_apsta_ifname(${STA})
				set awdl_ifname $::array_sta_sts_ifname(${STA})
				set tmp_tcpdump_infra "tcpdump_awdlpeer_rx_$infra_ifname"
				set tmp_tcpdump_awdl "tcpdump_awdlpeer_rx_$awdl_ifname"
				set tmp_drvlog_awdl "drvlog_awdlpeer_rx_$awdl_ifname"
			}

			UTF::Try "$STA: $tmp_disp TcpDump/DrvLog $tmp_ip" {
				if {$cleanup_flag} {
					set catch_resp [catch "$STA rexec pwd" catch_msg]
					UTF::Message INFO "" "$STA rm -f *\.pcap"
					set catch_resp [catch "$STA rm -f *\.pcap" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				}
				
				set testnum [sts::get_testnum]
				regsub -all {.} $testnum "_" $testnum

				# AWDL tcpdump
				if {$STA == $::array_streams_ap_controller(${::curr_test_no})} {
					UTF::Message LOG "" "-----------------------TCPDUMP Controller Infra------------------------------"
					set tcpdump_name "$testnum\.$tmp_tcpdump_infra\.$STA.pcap"
					set ifname $infra_ifname
				} else {
					UTF::Message LOG "" "-----------------------TCPDUMP STA------------------------------"
					set tcpdump_name "$testnum\.$tmp_tcpdump_awdl\.$STA.pcap"
					set ifname $awdl_ifname
				}
				UTF::Message LOG "" "-----------------------'$tcpdump_name'------------------------------"
				UTF::Message INFO "" "$STA rpopen tcpdump -i $ifname -w $tcpdump_name"  
				set fd [$STA rpopen tcpdump -i $ifname -w $tcpdump_name]
				set catch_resp [catch {set fd_tcpdump_pid [pid $fd]} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep .1
				set catch_resp [catch "$STA rexec ls -la $tcpdump_name" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp != 0} {
					# failed
					incr ::error_cnt
					UTF::Message ERROR "" "tcpdump file not found"
					error "tcpdump file not found"							
				}
				if {$STA == $::array_streams_ap_controller(${::curr_test_no})} {
					set ::array_sta_apsta_tcpdump_pid(${STA}) $fd_tcpdump_pid
					set ::array_sta_apsta_tcpdump_filename(${STA}) $tcpdump_name
					UTF::Message LOG "" "::array_sta_apsta_tcpdump_filename(${STA})='$::array_sta_apsta_tcpdump_filename(${STA})'"
					UTF::Message LOG "" "::array_sta_apsta_tcpdump_filename(${STA})='$::array_sta_apsta_tcpdump_filename(${STA})'"
				} else {
					set ::array_sta_sts_tcpdump_pid(${STA}) $fd_tcpdump_pid
					set ::array_sta_sts_tcpdump_filename(${STA}) $tcpdump_name
					UTF::Message LOG "" "::array_sta_sts_tcpdump_pid(${STA})='$::array_sta_sts_tcpdump_pid(${STA})'"
					UTF::Message LOG "" "::array_sta_sts_tcpdump_filename(${STA})='$::array_sta_sts_tcpdump_filename(${STA})'"
				}

				# drvlog for the controller is not needed
				if {$STA != $::array_streams_ap_controller(${::curr_test_no})} {
					# AWDL drvlog
					set awdl_drvlog_name "$testnum\.$tmp_drvlog_awdl\.$STA.pcap"
					UTF::Message LOG "" "-----------------------DRVLOG STA '$awdl_drvlog_name'------------------------------"
					UTF::Message INFO "" "$STA rpopen apple80211 $awdl_ifname -logf=\"v set\" -outfile=$awdl_drvlog_name -dlog"  
					set fd [$STA rpopen apple80211 $awdl_ifname -logf=\"v set\" -outfile=$awdl_drvlog_name -dlog]
					set catch_resp [catch {set fd_drvlog_pid [pid $fd]} catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep .1
					set catch_resp [catch "$STA rexec ls -la $awdl_drvlog_name" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp != 0} {
						# failed
						incr ::error_cnt
						UTF::Message ERROR "" "drvlog file not found"
						error "drvlog file not found"							
					}
					set ::array_sta_sts_drvlog_pid(${STA}) $fd_drvlog_pid
					set ::array_sta_sts_drvlog_filename(${STA}) $awdl_drvlog_name
					UTF::Message LOG "" "::array_sta_sts_drvlog_pid(${STA})='$::array_sta_sts_drvlog_pid(${STA})'"
					UTF::Message LOG "" "::array_sta_sts_drvlog_filename(${STA})='$::array_sta_sts_drvlog_filename(${STA})'"
					
					if {$infra_flag} {					
						# Infra tcpdump
						set infra_tcpdump_name "$testnum\.$tmp_tcpdump_infra\.$STA.pcap"
						UTF::Message LOG "" "-----------------------TCPDUMP STA Infra '$infra_tcpdump_name'------------------------------"
						UTF::Message INFO "" "$STA rpopen tcpdump -i $infra_ifname -w $infra_tcpdump_name"  
						set fd [$STA rpopen tcpdump -i $infra_ifname -w $infra_tcpdump_name]
						set catch_resp [catch {set fd_tcpdump_pid [pid $fd]} catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						UTF::Sleep .1
						set catch_resp [catch "$STA rexec ls -la $infra_tcpdump_name" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						if {$catch_resp != 0} {
							# failed
							incr ::error_cnt
							UTF::Message ERROR "" "tcpdump file not found"
							error "tcpdump file not found"							
						}
						set ::array_sta_apsta_tcpdump_pid(${STA}) $fd_tcpdump_pid
						set ::array_sta_apsta_tcpdump_filename(${STA}) $infra_tcpdump_name
						UTF::Message LOG "" "::array_sta_apsta_tcpdump_pid(${STA})='$::array_sta_apsta_tcpdump_pid(${STA})'"
						UTF::Message LOG "" "::array_sta_apsta_tcpdump_filename(${STA})='$::array_sta_apsta_tcpdump_filename(${STA})'"
					}
				}
			
				set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
				
				return ""
			}
		}

		foreach STA "$sts_slave $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::array_streams_ap_controller(${::curr_test_no})" {
			UTF::Message LOG "" "========================================================"
			set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp != 0} {
				# failed
				incr ::error_cnt
				UTF::Message ERROR "" "Did not find PCAP file on $STA"
				error "Did not find PCAP file on $STA"							
			}
		}
		
		return ""
	}

	if {$::error_cnt > 0} {
		error "Halting tests!"
	}
}

proc sts::macos_pcap_debug_dump_stop {} {
	# access option array
	upvar {} {}

	UTF::Try "PCAP Debug Stop" {

		UTF::Message INFO "" "************************Func:macos_pcap_debug_dump_stop***************************"

		set sts_slave [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++++DEBUG+++++++++++++++++++++++++++++++++++++++++"
		foreach STA "$sts_slave $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::array_streams_ap_controller(${::curr_test_no})" {
		
			foreach interface_type "p2p wlan" {

				foreach log_type "tcpdump drvlog" {

					set var "array_sta_${interface_type}_${log_type}_filename(${STA})"
					if {![info exists ::${var}]} {
						UTF::Message INFO "" "'::${var}' does not exist. skip to next."
						continue
					}
					set item [expr \${::${var}}]
					UTF::Message INFO "" "::${var}='$item'"
				}
			}
		}
		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n"

		foreach STA "$sts_slave $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::array_streams_ap_controller(${::curr_test_no})" {
		
			foreach interface_type "p2p wlan" {

				foreach log_type "tcpdump drvlog" {

					set var "array_sta_${interface_type}_${log_type}_filename(${STA})"
					if {![info exists ::${var}]} {
						UTF::Message INFO "" "'::${var}' does not exist. skip to next."
						continue
					}
					set item [expr \${::${var}}]
					UTF::Message INFO "" "::${var}='$item'"
					if {$item != ""} {
						UTF::Message LOG "" "--------------------------------------------------------"
						UTF::Message LOG "" "$STA - Stopping PCAP $log_type file: '$item'"
						set var "array_sta_${interface_type}_${log_type}_pid(${STA})"
						set item_pid [expr \${::${var}}]
						UTF::Message INFO "" "::${var}='$item_pid'"
						UTF::Message INFO "" "exec kill -9 $item_pid"  
						set catch_resp [catch "exec kill -9 $item_pid" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

						UTF::Sleep 1

						# Coping it to the PCAPData directory in the UTF report

						UTF::Message INFO "" "$STA copyfrom $item $::logdir/PCAPData/$item"
						set catch_resp [catch "$STA copyfrom $item $::logdir/PCAPData/$item" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: scp catch_msg=$catch_msg"
						} else {
							catch "exec chmod 755 $::logdir/PCAPData/$item"
							set catch_resp [catch "exec ls -la $::logdir/PCAPData/$item" catch_msg]
							UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

							UTF::Message INFO "" "$STA rm -f $item"
							set catch_resp [catch "$STA rm -f $item" catch_msg]

							if {$catch_resp != 0} {
							   error "ERROR: rm catch_msg=$catch_msg"
							}

							set catch_resp [catch "$STA rexec ls -la $item" catch_msg]
						}
					}
				}
			}
		}

		foreach STA "$sts_slave $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::array_streams_ap_controller(${::curr_test_no})" {
			UTF::Message LOG "" "========================================================"
			set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} {
				# failed
				incr ::error_cnt
				UTF::Message ERROR "" "Found PCAP file on $STA"
				error "Found PCAP file on $STA"							
			}
		}
		
		UTF::Message INFO "" "PASS. Captured PCAP Files: $::logdir/PCAPData/"
		return "html: <a href=\"$::logdir/PCAPData/\">{Mac PCAP Debug Files}</a>"
	}

	if {$::error_cnt > 0} {
		error "Halting tests!"
	}
}

proc sts::control_chart {id sample_list cc_keys cc_title cc_units data_throughput_flag} {

	set sample_cnt [llength $sample_list]

	# Create control chart	
	# Control chart needs more than 2 samples
	if {$sample_cnt > 2} {
		UTF::Message INFO "" "UTF::ControlChart CC -s $sample_cnt -key $cc_keys -units $cc_units -title $cc_title -history 30"		
		UTF::ControlChart CC -s $sample_cnt -key $cc_keys -units $cc_units -title $cc_title -history 30
		
		# Get the Mean, Min, Max
		set cc_mmm [UTF::MeanMinMax $sample_list]

		# Add it to control chart
		set cc_result [CC addsample $cc_mmm]
	} else {
		UTF::Message INFO "" "UTF::MemChart CC -key $cc_keys -units $cc_units -title $cc_title"
		UTF::MemChart CC -key $cc_keys -units $cc_units -title $cc_title
		
		# Add it to control chart
		set cc_result [CC addsample $sample_list]
	}

	if {$data_throughput_flag == 1} {
		set rc [regexp -nocase {(LOW|WIDE|ZERO)} $cc_result - code] 
	} else {
		set rc [regexp -nocase {(HIGH|WIDE)} $cc_result - code] 
	}

	if {$rc} {
		UTF::Message ERROR "" "sts::control_chart Control chart value is $code"
		append ::sts::cc_error "($code)"
	}
	
	# Get the control chart graphics
	set chart [CC plotcontrolchart $cc_result]
	
	# Delete control chart	
	CC destroy

	# remove the "html:" from the beginning
	regsub -nocase {^html:} $chart "" chart

	# Add name id to differentiate between multiple charts
	set chart "<b>$id</b>&nbsp;&nbsp;${chart}"

	return "$chart"
}

proc sts::start_traffic {stream_no} {

	set sta_src 					$::array_streams_src_sta(${::curr_test_no},${stream_no}) 
	set sta_dst 					$::array_streams_dst_sta(${::curr_test_no},${stream_no})
	set sta_dst_ipaddr 				$::array_streams_dst_ip(${::curr_test_no},${stream_no}) 
	set stream_link_type 			$::array_streams_link_type(${::curr_test_no},${stream_no})
	set stream_traffic_type 		$::array_streams_traffic_type(${::curr_test_no},${stream_no})
	set stream_traffic_priority 	$::array_streams_traffic_priority(${::curr_test_no},${stream_no})
	set stream_iperf_tos			$::array_streams_iperf_tos(${::curr_test_no},${stream_no})
	set stream_iperf_scale 			$::array_streams_throughput_scale(${::curr_test_no},${stream_no})
	set src_tcpwin					$::array_streams_src_tcpwin(${::curr_test_no},${stream_no})
	set src_host_type				$::array_streams_src_host_type(${::curr_test_no},${stream_no})

	if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
		# StS link
		UTF::Message LOG "" "start_traffic $stream_traffic_type sta_src=$::array_streams_src(${::curr_test_no},${stream_no}) sta_dst=$::array_streams_dst(${::curr_test_no},${stream_no}) sta_dst_ipaddr=$sta_dst_ipaddr"
	} else {
		UTF::Message LOG "" "start_traffic $stream_traffic_type sta_src=$sta_src sta_dst=$sta_dst sta_dst_ipaddr=$sta_dst_ipaddr"
	}

	set iperf_name $::array_sta_iperf_name(${sta_src})
	set iperf_ver $::array_sta_iperf_ver(${sta_src})
	if {$iperf_ver == "2.0.5"} {
		if {$src_host_type == "MacOS" && $stream_link_type == "AWDL"} {
			set new_iperf_param "-V -A" 
		} else {
			set new_iperf_param "" 
		}
	} else {
		set new_iperf_param "-e" 
	}
	
	set common_params "-f$stream_iperf_scale -w $src_tcpwin -i $::perfint -S $stream_iperf_tos -t $::array_streams_end_time(${::curr_test_no},${stream_no}) -p $::curr_iperf_port"

	if {$src_host_type == "MacOS"} {
		set addr_params "$new_iperf_param -c $::array_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no})"
	} else {
		set addr_params "$new_iperf_param -c $sta_dst_ipaddr"
	}

	if {$stream_traffic_type == "TCP"} {
		set traffic_type_params "-l 8k"
	} else {
		set traffic_type_params "-u -b $::array_streams_bandwidth(${::curr_test_no},${stream_no}) -l $::array_streams_packet_size(${::curr_test_no},${stream_no})"
	}
	
	set iperf_params "$addr_params $traffic_type_params $common_params"
	# trim
	set iperf_params [regexp -all -inline {\S+} $iperf_params]

	# Start iperf as background task
	set ::array_streams_fd_tx(${::curr_test_no},${stream_no}) [$sta_src rpopen $iperf_name $iperf_params]

	fconfigure $::array_streams_fd_tx(${::curr_test_no},${stream_no}) -blocking 0
	fileevent $::array_streams_fd_tx(${::curr_test_no},${stream_no}) readable {set ::p2p_utils_reading READY}

	incr ::curr_iperf_port

	return ""
}

proc sts::start_all_server_streams {} {
	# access option array
	upvar {} {}

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:start_all_server_streams***************************"
	
	# reset the iperf starting port #
	set ::curr_iperf_port $::iperf_starting_port

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {[regexp -nocase {BT} $stream_no]} {
			UTF::Message INFO "" "stream_no='$stream_no'. Skipping BT"
			continue
		}

		set sta_src						$::array_streams_dst_sta(${::curr_test_no},${stream_no})
		set stream_link_type 			$::array_streams_link_type(${::curr_test_no},${stream_no})
		set stream_traffic_type 		$::array_streams_traffic_type(${::curr_test_no},${stream_no})
		set stream_traffic_priority 	$::array_streams_traffic_priority(${::curr_test_no},${stream_no})
		set stream_iperf_tos			$::array_streams_iperf_tos(${::curr_test_no},${stream_no})
		set stream_iperf_scale 			$::array_streams_throughput_scale(${::curr_test_no},${stream_no})
		set dst_tcpwin					$::array_streams_dst_tcpwin(${::curr_test_no},${stream_no})
		set dst_host_type				$::array_streams_dst_host_type(${::curr_test_no},${stream_no})

		# do not change this order since the script looks for "iperf -s" for killing process
		set iperf_name $::array_sta_iperf_name(${sta_src})
		set iperf_ver $::array_sta_iperf_ver(${sta_src})
		if {$iperf_ver == "2.0.5"} {
			if {$dst_host_type == "MacOS" && $stream_link_type == "AWDL"} {
				set new_iperf_param "-s -V -A" 
			} else {
				set new_iperf_param "-s" 
			}
		} else {
			set new_iperf_param "-s -e" 
		}
		
		set common_params "-f$stream_iperf_scale -w $dst_tcpwin -i $::perfint -S $stream_iperf_tos -p $::curr_iperf_port -P 1"

		if {$stream_traffic_type == "TCP"} {
			set traffic_type_params "-l 8k"
		} else {
			set traffic_type_params "-u"
		}

		set iperf_params "$new_iperf_param $traffic_type_params $common_params"
		# trim
		set iperf_params [regexp -all -inline {\S+} $iperf_params]

		# Start iperf server as background task
		set ::array_streams_fd_rx(${::curr_test_no},${stream_no}) [$sta_src rpopen $iperf_name $iperf_params]

		fconfigure $::array_streams_fd_rx(${::curr_test_no},${stream_no}) -blocking 0
		fileevent $::array_streams_fd_rx(${::curr_test_no},${stream_no}) readable {set ::p2p_utils_reading READY}

		# insert "RX_" and "TX_" at the beginning of the iperf id name in order to differentiate the RX and TX data
		set ::array_streams_fdname_rx(${::curr_test_no},${stream_no}) "RX_$stream_no\:$::array_streams_stream_short_label(${::curr_test_no},${stream_no})"
		set ::array_streams_fdname_tx(${::curr_test_no},${stream_no}) "TX_$stream_no\:$::array_streams_stream_short_label(${::curr_test_no},${stream_no})"

		UTF::Message INFO "" "Stream $stream_no $::array_streams_stream_short_label(${::curr_test_no},${stream_no}) - Started iperf server for $::array_streams_link_type(${::curr_test_no},${stream_no}) $::array_streams_traffic_priority(${::curr_test_no},${stream_no}) $::array_streams_traffic_direction(${::curr_test_no},${stream_no}) - fdname=$::array_streams_fdname_rx(${::curr_test_no},${stream_no}) fd=$::array_streams_fd_rx(${::curr_test_no},${stream_no})"

		incr ::curr_iperf_port
	}

	# reset the iperf starting port #
	set ::curr_iperf_port $::iperf_starting_port
	UTF::Sleep .2
}

proc sts::close_iperf_traffic {} {

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:close_iperf_traffic***************************"

	# iperf rpopen process is on the UTF machine

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {[info exists ::array_streams_fd_rx(${::curr_test_no},${stream_no})]} {
			set name $::array_streams_fdname_rx(${::curr_test_no},${stream_no})
			if {$name != ""} {
				set fd $::array_streams_fd_rx(${::curr_test_no},${stream_no})
				set catch_resp [catch {close $fd} catch_msg]
				UTF::Message INFO "" "close $fd catch_msg=$catch_msg"
			}
		}

		if {[info exists ::array_streams_fd_tx(${::curr_test_no},${stream_no})]} {
			set name $::array_streams_fdname_tx(${::curr_test_no},${stream_no})
			if {$name != ""} {
				set fd $::array_streams_fd_tx(${::curr_test_no},${stream_no})
				set catch_resp [catch {close $fd} catch_msg]
				UTF::Message INFO "" "close $fd catch_msg=$catch_msg"
			}
		}
	}
}

proc sts::stop_iperf_traffic {} {

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:stop_iperf_traffic***************************"

	# iperf rpopen process is on the UTF machine

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			# no iperf for BT
			continue
		}

		set name $::array_streams_fdname_rx(${::curr_test_no},${stream_no})
		set fd $::array_streams_fd_rx(${::curr_test_no},${stream_no})

		set catch_resp [catch {set iperf_endpoint_pid [pid $fd]} catch_msg]
		UTF::Message INFO "" "set iperf_endpoint_pid catch_msg=$catch_msg"

		if {$catch_resp != 0} {
			# failed to get pid
			UTF::Message INFO "" "stop_iperf_traffic name=$name fd=$fd pid=None (must be exited already)"  
		} else {	
			UTF::Message INFO "" "stop_iperf_traffic name=$name fd=$fd pid=$iperf_endpoint_pid"  

			UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
			set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "stop_iperf_traffic\
					did not terminate iperf_endpoint_pid=$iperf_endpoint_pid: $catch_msg"
				if {![regexp -nocase "No such process" $catch_msg]} {
					error "Iperf did not stop"
				}
			}
		}
	}
}

proc sts::awdl_macos_link_activate {sts_master sts_slave} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:awdl_macos_link_activate***************************"

	# sample shell command to kill dns-sd
	# while true; do awdl_status=$(apple80211 -awdl | grep "awdl is enabled"); if [ -n "$awdl_status" ]; then killall dns-sd 2> /dev/null;sleep 1; else break; fi;done

	foreach STA "$sts_slave $sts_master" {
		set catch_resp [catch "$STA rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
		if {$catch_resp != 0} {
			UTF::Message INFO "" "$STA: AWDL is not enabled"
		}

		set catch_resp [catch "$STA rexec killall dns-sd" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		if {$STA == $sts_slave} {
			UTF::Message INFO "" "Slave 1st STA='$STA'"
			set awdl_peer_macaddr [regexp -inline {ether\s+(\S+)} [$STA rexec ifconfig awdl0 ether]]
			UTF::Message INFO "" "awdl_peer_macaddr=$awdl_peer_macaddr"
			regexp -nocase {\{ether\s+(\S+)\}} $awdl_peer_macaddr - awdl_peer_macaddr
			set awdl_peer_macaddr [string trim $awdl_peer_macaddr]
			set awdl_peer_macaddr [string toupper $awdl_peer_macaddr]
			UTF::Message INFO "" "$STA: AWDL Peer mac address is $awdl_peer_macaddr"
		} else {
			UTF::Message INFO "" "Master 2nd STA='$STA'"
			set time_ms1 [clock clicks -milliseconds]
		}

		$STA rpopen dns-sd -includeAWDL -B _test local

		if {$STA == $sts_master} {

			UTF::Sleep .01

			set loop_cnt 0

			while {1} {
				set catch_resp [catch "$STA rexec apple80211 -awdl_peers" catch_msg]
				if {[string first $awdl_peer_macaddr $catch_msg] != -1} {
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg='$catch_msg'"
					UTF::Message INFO "" "DUT $STA found AWDL Peer $awdl_peer_macaddr"
					break
				}

				UTF::Sleep .01

				incr loop_cnt
				if {$loop_cnt > 500} {
					UTF::Message INFO "" "DUT $STA did not find AWDL Peer $awdl_peer_macaddr"

					foreach sta_name "$sts_slave $sts_master" {
						$sta_name rexec ifconfig -a
						set catch_resp [catch "$sta_name rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						set catch_resp [catch "$sta_name rexec ps -ef | grep \"dns-sd\"" catch_msg]					
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					}

					incr ::error_cnt
					error "$STA: DUT did not find AWDL Peer $awdl_peer_macaddr. Halting tests!"				
				}
			}

			set time_ms2 [clock clicks -milliseconds]
			UTF::Message INFO "" "time_ms2=$time_ms2"
			set diff_time_ms [expr {$time_ms2 - $time_ms1}]
			UTF::Message INFO "" "diff_time_ms=$diff_time_ms"
		} else {
			UTF::Sleep 5
			set catch_resp [catch "$STA rexec ps -ef | grep \"dns-sd\"" catch_msg]					
			UTF::Message INFO "" "ps -ef dns-sd catch_msg=$catch_msg"
		}
	}

	UTF::Sleep 5			
}

proc sts::awdl_discovery_time {} {
	# access option array
	upvar {} {}

	# sample shell command to kill dns-sd
	# while true; do awdl_status=$(apple80211 -awdl | grep "awdl is enabled"); if [ -n "$awdl_status" ]; then killall dns-sd 2> /dev/null;sleep 1; else break; fi;done

	UTF::Try "AWDL Discovery Time" {
		UTF::Message INFO "" "************************Func:awdl_discovery_time***************************"

		set sts_master $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
		set sts_slave $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})

		foreach STA "$sts_slave $sts_master" {
			set catch_resp [catch "$STA rexec apple80211 -awdl_enable | grep -i \"awdl is enabled\"" catch_msg]
			if {$catch_resp == 0} {
				# awdl is enabled, disable it
				set catch_resp [catch "$STA rexec apple80211 -awdl_enable=0" catch_msg]
				UTF::Sleep 2
			}
			
			set catch_resp [catch "$STA rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
			if {$catch_resp == 0} {
				# awdl is enabled
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				error "$STA: AWDL is enabled by default. Halting tests!"				
			} else {
				UTF::Message INFO "" "$STA: AWDL is not enabled by default."
			}

			set catch_resp [catch "$STA rexec killall dns-sd" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			
			if {$STA == $sts_slave} {
				set awdl_peer_macaddr [regexp -inline {ether\s+(\S+)} [$STA rexec ifconfig awdl0 ether]]
				UTF::Message INFO "" "awdl_peer_macaddr=$awdl_peer_macaddr"
				regexp -nocase {\{ether\s+(\S+)\}} $awdl_peer_macaddr - awdl_peer_macaddr
				set awdl_peer_macaddr [string trim $awdl_peer_macaddr]
				set awdl_peer_macaddr [string toupper $awdl_peer_macaddr]
				UTF::Message INFO "" "$STA: AWDL Peer mac address is $awdl_peer_macaddr"
			} else {
				set time_ms1 [clock clicks -milliseconds]
			}
			
			$STA rpopen dns-sd -includeAWDL -B _test local

			if {$STA == $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})} {

				UTF::Sleep .01
				
				set loop_cnt 0

				while {1} {
					set catch_resp [catch "$STA rexec apple80211 -awdl_peers" catch_msg]
					if {[string first $awdl_peer_macaddr $catch_msg] != -1} {
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg='$catch_msg'"
						UTF::Message INFO "" "DUT $STA found AWDL Peer $awdl_peer_macaddr"
						break
					}

					UTF::Sleep .01
					
					incr loop_cnt
					if {$loop_cnt > 500} {
						UTF::Message INFO "" "DUT $STA did not find AWDL Peer $awdl_peer_macaddr"
						
						foreach sta_name "$sts_slave $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})" {
							$sta_name rexec ifconfig -a
							set catch_resp [catch "$sta_name rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
							UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
							set catch_resp [catch "$sta_name rexec ps -ef | grep \"dns-sd\"" catch_msg]					
							UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						}
						
						incr ::error_cnt
						error "$STA: DUT did not find AWDL Peer $awdl_peer_macaddr. Halting tests!"				
					}
				}

				set time_ms2 [clock clicks -milliseconds]
				UTF::Message INFO "" "time_ms2=$time_ms2"
				set diff_time_ms [expr {$time_ms2 - $time_ms1}]
				UTF::Message INFO "" "diff_time_ms=$diff_time_ms"
				set ret_val [format "%.7f" $diff_time_ms]
				set discovery_time [format "%.2f" $diff_time_ms]
				if {$::kpi_test_flag} {
					$::kpi_base_db set "discovery_time" "$discovery_time"
				}
				set keys "$::array_streams_control_chart_base_key(${::curr_test_no}) AWDL_Discovery"
				set html_results [UTF::Test::memchart $ret_val -key $keys  -title "AWDL Discovery Time" -units "ms"]				
				return $html_results
			} else {
				UTF::Sleep 5
				set catch_resp [catch "$STA rexec ps -ef | grep \"dns-sd\"" catch_msg]					
				UTF::Message INFO "" "ps -ef dns-sd catch_msg=$catch_msg"
			}
		}
	}
}

proc sts::stop_all_server_streams {} {
	# access option array
	upvar {} {}

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:stop_all_server_streams***************************"

	set stas_list ""

	foreach ap $(ap) {
		# check for 2g:5g param
		set ap [split $ap ":"]
		set ap [lindex $ap 0]

		set ap_host_type [$ap hostis]

		if {$ap_host_type == "Router"} {		
			set ap_controller [$ap cget -lanpeer]
			append stas_list "$ap_controller "
		} else {
			# SoftAP controller is the same as SoftAP machine
			set ap_controller $ap
			append stas_list "lan $ap_controller "
		}
	}

	append stas_list $(sta)
	set stas_list [string trim $stas_list]

	foreach sta_name $stas_list {
		sts::stop_iperf_server $sta_name
	}
}

proc sts::stop_iperf_server {sta_name} {

	UTF::Message INFO "" "************************Func:stop_iperf_server $sta_name***************************"

	#UTF::Message INFO "" "-----------------------------------------------"
	#UTF::Message INFO "" "$sta_name rexec ps -ef"
	#set catch_resp [catch "$sta_name rexec ps -ef" catch_msg]
	#UTF::Message INFO "" "-----------------------------------------------"

	set iperf_name $::array_sta_iperf_name(${sta_name})
	if {$iperf_name == ""} {
		UTF::Message INFO "" "No iperf running on $sta_name"
		return
	}

	UTF::Message INFO "" "$sta_name rexec ps -ef | grep $iperf_name -s"
	set catch_resp [catch "$sta_name rexec ps -ef | grep \"$iperf_name -s\"" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	UTF::Message INFO "" "-----------------------------------------------"

	set tmp [split $catch_msg "\n"]
	set iperf_server_pid 0

	foreach line $tmp {
		if {![regexp {grep|python} $line]} {

			UTF::Message INFO "" "--->: $line"
			# test to see if iperf server is running
			set iperf_server_pid 0
			catch {
				regexp {([A-Za-z0-9._-]+)\s+([0-9]+)\s+} $line match owner iperf_server_pid
				UTF::Message INFO "" "Iperf server is ruuning. pid=$iperf_server_pid owner=$owner"
			}

			if {$iperf_server_pid > 0} {
				# found the iperf process. Kill it
				UTF::Message INFO "" "$sta_name rexec kill -9 $iperf_server_pid"  
				set catch_resp [catch "$sta_name rexec kill -9 $iperf_server_pid" catch_msg]
				UTF::Sleep 3
				if {$catch_resp != 0} {
					UTF::Message ERROR "" "stop_iperf_server\
						did not terminate iperf_server_pid=$iperf_server_pid: $catch_msg"
					if {![regexp -nocase "No such process" $catch_msg]} {
						incr ::error_cnt
						UTF::Message INFO "" "::error_cnt=$::error_cnt"
						error "Iperf did not terminate"
					}
				}
			}
		}
	}
}

proc sts::check_iperf_version {sta_name} {

	UTF::Message INFO "" "************************Func:check_iperf_version $sta_name***************************"

	UTF::Message INFO "" "$sta_name cget -iperf"
	set iperf_name [$sta_name cget -iperf]

	if {$iperf_name == ""} {
		set iperf_name "iperf"
	}

	# get the current iperf version
	UTF::Message INFO "" "$sta_name rexec which $iperf_name"
	set catch_resp [catch "$sta_name rexec which $iperf_name" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	UTF::Message INFO "" "$sta_name rexec $iperf_name -v"
	set catch_resp [catch "$sta_name rexec $iperf_name -v" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	set catch_resp2 [catch "$sta_name rexec ls -l /usr/local/bin/iperf*" catch_msg2]
	UTF::Message INFO "" "-----------------------------------------------"

	set	iperf_ver "BLANK"
	regexp -nocase {iperf version\s+(\S+)\s+} $catch_msg - iperf_ver

	UTF::Message INFO "" "iperf_name=$iperf_name"
	UTF::Message INFO "" "iperf_ver=$iperf_ver"

	set ::array_sta_iperf_name(${sta_name}) $iperf_name
	set ::array_sta_iperf_ver(${sta_name}) $iperf_ver

	UTF::Message INFO "" "::array_sta_iperf_name(${sta_name})                    ='$::array_sta_iperf_name(${sta_name})'"
	UTF::Message INFO "" "::array_sta_iperf_ver(${sta_name})                     ='$::array_sta_iperf_ver(${sta_name})'"

	set host_type [$sta_name hostis]
	UTF::Message INFO "" "$sta_name host_type=$host_type"
	
	if {$host_type == "MacOS"} {
		UTF::Message INFO "" "======================stop MacOS iperf server service========================="
		UTF::Message INFO "" "$sta_name rexec sudo launchctl unload /System/Library/LaunchDaemons/iperf.plist"
		set catch_resp [catch "$sta_name rexec sudo launchctl unload /System/Library/LaunchDaemons/iperf.plist" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		UTF::Message INFO "" "$sta_name rexec sudo launchctl list /System/Library/LaunchDaemons/iperf.plist"
		set catch_resp [catch "$sta_name rexec sudo launchctl list /System/Library/LaunchDaemons/iperf.plist" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp == 0} {
			incr ::error_cnt
			error "iperf.plist service is still running"
		}
	} else {	
		UTF::Message INFO "" "======================stop TCP iperf server service========================="
		UTF::Message INFO "" "$sta_name rexec chkconfig --level 2345 iperf off"
		set catch_resp [catch "$sta_name rexec chkconfig --level 2345 iperf off" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		UTF::Message INFO "" "$sta_name rexec service iperf stop"
		set catch_resp [catch "$sta_name rexec service iperf stop" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		UTF::Sleep 3

		UTF::Message INFO "" "---------------------iperf status--------------------------"
		UTF::Message INFO "" "$sta_name rexec service iperf status"
		set catch_resp [catch "$sta_name rexec service iperf status" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		UTF::Message INFO "" "-----------------------------------------------"

		if {[regexp -nocase {.*active \(running\).*} $catch_msg]} {
			UTF::Message INFO "" "Iperf server service is still running for $sta_name"
			set ::iperf_server_err $sta_name
		} else {
			UTF::Message INFO "" "Iperf server service is not running"
		}
	}
	
	return $iperf_ver
}

proc sts::setup_multicore {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup Multicore" {
		if {$(multicore_mode) == 0} {
			set multicore_state "Off"
		} else {
			set multicore_state "On"
		}

		set stas_list ""

		if {$(ap) != ""} {
			foreach ap $(ap) {
				# check for 2g:5g param
				set ap2g [split $ap ":"]
				set ap2g [lindex $ap2g 0]

				set ap_host_type [$ap2g hostis]

				if {$ap_host_type == "Router"} {		
					set ap_controller [$ap2g cget -lanpeer]
					lappend stas_list "AP Controller '$ap_controller': $ap: Multicore $multicore_state"
					lappend stas_list "$ap_controller "
				} else {
					# SoftAP controller is the same as SoftAP machine
					set ap_controller $ap
					lappend stas_list "SoftAP Controller 'lan': $ap: Multicore $multicore_state"
					lappend stas_list "lan"
					lappend stas_list "SoftAP '$ap_controller': Multicore $multicore_state"
					lappend stas_list "$ap_controller"
				}
			}
		} else {
			lappend stas_list "Controller 'lan': No AP: Multicore $multicore_state"
			lappend stas_list "lan"
		}

		foreach sta $(sta) {
			lappend stas_list "STA '$sta': Multicore $multicore_state"
			lappend stas_list "$sta"
		}

		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label STA} $stas_list {

			set sta_label [string trim $sta_label]
			set STA [string trim $STA]

			if {[$STA hostis] == "MacOS"} {
				continue
			}

			UTF::Try "$sta_label" {

				# cd /sys/devices/system/cpu
				# echo 0 > cpu1/online
				# echo 0 > cpu2/online
				# echo 0 > cpu3/online

				set multicore_set_flag 0
				for {set cpu_cnt 1} {$cpu_cnt <= 3} {incr cpu_cnt} {
					set catch_resp [catch "$STA cat /sys/devices/system/cpu/cpu$cpu_cnt/online" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

					if {$catch_resp == 1} {
						# failed
						set multicore_set_flag 1
						continue
					}

					if {$(multicore_mode) == 0 && $catch_msg == "1"} {
						set multicore_set_flag 1
						continue
					}
					if {$(multicore_mode) == 1 && $catch_msg == "0"} {
						set multicore_set_flag 1
						continue
					}
				}

				if {$multicore_set_flag == 0} {
					return "Multicore is already $multicore_state"
				}

				if {$(multicore_mode) == 0} {
					UTF::Message LOG "" "Turn off multicore"
					set catch_resp [catch "$STA ls /root/multicore_off" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						UTF::Message LOG "" "Found '/root/multicore_off' on '$STA'"
					} else {
						UTF::Message LOG "" "Create missing '/root/multicore_off' on '$STA'"
						$STA echo "\"cd /sys/devices/system/cpu ; echo 0 > cpu1/online ; echo 0 > cpu2/online ; echo 0 > cpu3/online\" >> /root/multicore_off"
						$STA chmod +x /root/multicore_off
					}

					set catch_resp [catch "$STA rexec /root/multicore_off" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep 5
				} else {
					UTF::Message LOG "" "Turn on multicore by rebooting the STA $STA"
					$STA power off
					UTF::Sleep 5
					$STA power on
					UTF::Sleep 120
				}
			}
		}
		
		return $multicore_state
	}
}

proc sts::setup_mac_radio_on {} {
	# access option array
	upvar {} {}

	set mac_flag 0

	foreach sta_name "$(sta)" {

		if {[$sta_name hostis] != "MacOS"} {
			continue
		}

		set mac_flag 1
		UTF::Try "$sta_name: MacOS Radio On" {
			catch {$sta_name attngrp attn 0}
			$sta_name rexec networksetup -setairportpower [$sta_name cget -device] on
		}
	}
	
	if {$mac_flag && $(ap) != ""} {

		set ap [lindex $(ap) 0]

		# check for 2g:5g param
		set ap2g [split $ap ":"]
		set ap2g [lindex $ap2g 0]

		UTF::Try "$ap2g: Set AP ATTN 0" {
			catch {$ap2g attngrp attn 0}
			return ""
		}
	}
	
	UTF::Sleep 1
}

proc sts::setup_mpc {} {
	# access option array
	upvar {} {}
	
	UTF::Try "Setup MPC=$::mpc_mode" {

		UTF::Message INFO "" "************************Func:setup_mpc***************************"

		foreach sta $(sta) {
			$sta wl down
			UTF::Sleep 2
			set catch_resp [catch {$sta wl mpc $::mpc_mode} catch_msg]
			UTF::Sleep 2
			set catch_resp [catch {$sta wl mpc} catch_msg]
			$sta wl up
			UTF::Sleep 2
		}

		return ""
	}
}

proc sts::setup_rsdb {} {
	# access option array
	upvar {} {}
	
	UTF::Try "Setup RSDB=$::rsdb_mode" {

		UTF::Message INFO "" "************************Func:setup_rsdb***************************"

		foreach sta $(sta) {
			$sta wl down
			UTF::Sleep 2
			set catch_resp [catch {$sta wl rsdb_mode $::rsdb_mode} catch_msg]
			UTF::Sleep 2
			set catch_resp [catch {$sta wl rsdb_mode} catch_msg]
			$sta wl up
			UTF::Sleep 2
		}

		return ""
	}
}

proc sts::enable_ntp {} {
	# access option array
	upvar {} {}

	if {$::bt_only_flag} {
		return
	}
	
	UTF::Try "Enable NTP" {
	
		UTF::Message INFO "" "************************Func:enable_ntp***************************"

		#########################################
		# Enable NTP
		#########################################

		set ntp_pass_flag 1

		set stas_list ""

		if {$(ap) != ""} {
			foreach ap $(ap) {
				# check for 2g:5g param
				set ap2g [split $ap ":"]
				set ap2g [lindex $ap2g 0]

				set ap_host_type [$ap2g hostis]

				if {$ap_host_type == "Router"} {		
					set ap_controller [$ap2g cget -lanpeer]
					lappend stas_list "AP Controller '$ap_controller': $ap: NTP"
					lappend stas_list "$ap_controller "
				} else {
					# SoftAP controller is the same as SoftAP machine
					set ap_controller $ap
					lappend stas_list "SoftAP Controller 'lan': $ap: NTP"
					lappend stas_list "lan"
					lappend stas_list "SoftAP '$ap_controller': NTP"
					lappend stas_list "$ap_controller"
				}
			}
		} else {
			lappend stas_list "Controller 'lan': No AP: NTP"
			lappend stas_list "lan"
		}

		foreach sta $(sta) {
			lappend stas_list "STA '$sta': NTP"
			lappend stas_list "$sta"
		}
		
		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label STA} $stas_list {

			set sta_label [string trim $sta_label]
			set STA [string trim $STA]

			if {[$STA hostis] == "MacOS"} {
				continue
			}

			UTF::Try "$sta_label" {
				set catch_resp [catch "$STA rexec systemctl enable ntpd.service" catch_msg]
				UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg'"
				set catch_resp [catch "$STA rexec systemctl start ntpd.service" catch_msg]
				UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg'"
				return ""
			}
		}
	}
}

proc sts::check_ntp {} {
	# access option array
	upvar {} {}
	
	if {$::bt_only_flag} {
		return
	}
	
	UTF::Try "Check NTP" {
	
		UTF::Message INFO "" "************************Func:check_ntp***************************"

		#########################################
		# see if NTP is running
		#########################################

		set ntp_pass_flag 1

		set stas_list ""

		if {$(ap) != ""} {
			foreach ap $(ap) {
				# check for 2g:5g param
				set ap2g [split $ap ":"]
				set ap2g [lindex $ap2g 0]

				set ap_host_type [$ap2g hostis]

				if {$ap_host_type == "Router"} {		
					set ap_controller [$ap2g cget -lanpeer]
					lappend stas_list "AP Controller '$ap_controller': $ap: NTP"
					lappend stas_list "$ap_controller "
				} else {
					# SoftAP controller is the same as SoftAP machine
					set ap_controller $ap
					lappend stas_list "SoftAP Controller 'lan': $ap: NTP"
					lappend stas_list "lan"
					lappend stas_list "SoftAP '$ap_controller': NTP"
					lappend stas_list "$ap_controller"
				}
			}
		} else {
			lappend stas_list "Controller 'lan': No AP: NTP"
			lappend stas_list "lan"
		}
		
		foreach sta $(sta) {
			lappend stas_list "STA '$sta': NTP"
			lappend stas_list "$sta"
		}
		
		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label STA} $stas_list {

			set sta_label [string trim $sta_label]
			set STA [string trim $STA]

			if {[$STA hostis] == "MacOS"} {
				continue
			}

			UTF::Try "$sta_label" {

				set rc_msg ""
				for {set retry_cnt 1} {$retry_cnt <= 3} {incr retry_cnt} {
					set catch_resp [catch "$STA rexec systemctl status ntpd.service" catch_msg]
					if {$catch_msg == "Timeout"} {
						# failed
						UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg' - Retry $retry_cnt"
						UTF::Message INFO "" "-----------------------------------------------"
						continue
					}
					UTF::Message INFO "" "-----------------------------------------------"

					set ntp_enabled_status ""
					regexp {ntpd.service;\s+(\S+)} $catch_msg match ntp_enabled_status  
					UTF::Message INFO "" "ntp_enabled_status=$ntp_enabled_status"

					set ntp_running_status ""
					regexp {Active:\s+(\S+)} $catch_msg match ntp_running_status  
					UTF::Message INFO "" "ntp_running_status=$ntp_running_status"

					if {$ntp_enabled_status == "enabled" || $ntp_running_status == "inactive"} {
						set rc_msg "(NTP was stopped)"
					} elseif {$ntp_running_status == "" || $ntp_running_status != "active"} {
						set ntp_pass_flag 0
						error $ntp_running_status
					}
					
					# NTP is running. Sync the clock now
					set catch_resp [catch "$STA rexec ntpq -p" catch_msg]
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec cat /var/lib/ntp/drift" catch_msg]
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec systemctl stop ntpd.service" catch_msg]
					UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg'"
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec ntpdate 10.16.16.12" catch_msg]
					UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg'"
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec systemctl start ntpd.service" catch_msg]
					UTF::Message INFO "" "catch_resp='$catch_resp' catch_msg='$catch_msg'"
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec ntpq -p" catch_msg]
					UTF::Message INFO "" "-----------------------------------------------"
					set catch_resp [catch "$STA rexec cat /var/lib/ntp/drift" catch_msg]
					UTF::Message INFO "" "-----------------------------------------------"
				}
				
				return "$ntp_running_status $rc_msg"
			}
		}
		
		if {!$ntp_pass_flag} {
			error "NTP not running"
		}
	}
}

proc sts::setup_iperfs {} {
	# access option array
	upvar {} {}
	
	if {$::bt_only_flag} {
		return
	}

	set iperf_failed_flag 0
	
	UTF::Try "Setup Iperf" {
	
		UTF::Message INFO "" "************************Func:setup_iperfs***************************"

		#########################################
		# Setup TCP Window Size
		#########################################
		sts::setup_tcp_window_size

		#########################################
		# see if iperf is installed
		#########################################

		set iperf_pass_flag 1
		set last_iperf_ver ""

		set stas_list ""

		foreach ap $(ap) {
			# check for 2g:5g param
			set ap2g [split $ap ":"]
			set ap2g [lindex $ap2g 0]

			set ap_host_type [$ap2g hostis]

			if {$ap_host_type == "Router"} {		
				set ap_controller [$ap2g cget -lanpeer]
				lappend stas_list "AP Controller '$ap_controller': $ap: Iperf Version"
				lappend stas_list "$ap_controller "
			} else {
				# SoftAP controller is the same as SoftAP machine
				set ap_controller $ap
				lappend stas_list "SoftAP Controller 'lan': $ap: Iperf Version"
				lappend stas_list "lan"
				lappend stas_list "SoftAP '$ap_controller': Iperf Version"
				lappend stas_list "$ap_controller"
			}
		}

		set sta_no 0
		foreach sta $(sta) {
			incr sta_no
			lappend stas_list "STA $sta_no '$sta': Iperf Version"
			lappend stas_list "$sta"
		}
		
		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label sta_name} $stas_list {

			set sta_label [string trim $sta_label]
			set sta_name [string trim $sta_name]

			UTF::Try "$sta_label" {
				set rc [sts::check_iperf_version $sta_name]
				if {$last_iperf_ver == ""} {
					set last_iperf_ver $rc
				}
				if {$last_iperf_ver != $rc} {
					UTF::Message WARN ""  "Iperf versions '$last_iperf_ver' and '$rc' are not the same"
					set iperf_pass_flag 0
				}
				return $rc
			}
		}

		#########################################
		# Stop all server streams
		#########################################
		sts::stop_all_server_streams

		if {!$iperf_pass_flag} {
			error "Iperf Version Mismatch"
		}

		if {$::iperf_server_err != ""} {
			error "Iperf server service is still running for $::iperf_server_err"
		}
		
		if {$iperf_failed_flag} {
			error "Could not stop TCP iperf server"
		}
	
		return $rc
	}
}

proc sts::setup_frameburst {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_frameburst***************************"

	if {$(fb) != ""} {

		UTF::Try "Setup Frameburst $(fb)" {

			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					# only BIRX needs to be processed
					continue
				}

				set src_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
				set dst_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})

				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {

					$dst_sta wl -i $::array_streams_dst_ifname(${::curr_test_no},${stream_no}) frameburst $(fb)
					$dst_sta wl -i $::array_streams_dst_ifname(${::curr_test_no},${stream_no}) frameburst
					
					# set framebust for softap also
					set ap_controller $::array_streams_ap_controller(${::curr_test_no})
					if {$::array_sta_softap_flag($ap_controller) == 1} {
						$ap_controller wl frameburst $(fb)
						$ap_controller wl frameburst
					}
					
				} else {
					$src_sta wl -i $::array_streams_src_ifname(${::curr_test_no},${stream_no}) frameburst $(fb)
					$src_sta wl -i $::array_streams_src_ifname(${::curr_test_no},${stream_no}) frameburst
					$dst_sta wl -i $::array_streams_dst_ifname(${::curr_test_no},${stream_no}) frameburst $(fb)
					$dst_sta wl -i $::array_streams_dst_ifname(${::curr_test_no},${stream_no}) frameburst
				}
			}

			return ""
		}
	}
}

proc sts::get_awdl_hex_chan {chan} {

	set chan_list "1 0x1001,2 0x1002,3 0x1003,4 0x1004,5 0x1005,6 0x1006,7 0x1007,8 0x1008,9 0x1009,10 0x100a,11 0x100b,5u 0x1903,\
		6u 0x1904,7u 0x1905,8u 0x1906,9u 0x1907,10u 0x1908,11u 0x1909,1l 0x1803,2l 0x1804,3l 0x1805,4l 0x1806,5l 0x1807,\
		6l 0x1808,7l 0x1809,36 0xd024,40 0xd028,44 0xd02c,48 0xd030,52 0xd034,56 0xd038,60 0xd03c,64 0xd040,100 0xd064,\
		104 0xd068,108 0xd06c,112 0xd070,116 0xd074,132 0xd084,136 0xd088,140 0xd08c,144 0xd090,149 0xd095,153 0xd099,\
		157 0xd09d,161 0xd0a1,165 0xd0a5,40u 0xd926,48u 0xd92e,56u 0xd936,64u 0xd93e,104u 0xd966,112u 0xd96e,136u 0xd986,\
		144u 0xd98e,153u 0xd997,161u 0xd99f,36l 0xd826,44l 0xd82e,52l 0xd836,60l 0xd83e,100l 0xd866,108l 0xd86e,\
		132l 0xd886,140l 0xd88e,149l 0xd897,157l 0xd89f,36/80 0xe02a,52/80 0xe03a,100/80 0xe06a,132/80 0xe08a,\
		149/80 0xe09b,40/80 0xe12a,56/80 0xe13a,104/80 0xe16a,136/80 0xe18a,153/80 0xe19b,44/80 0xe22a,60/80 0xe23a,\
		108/80 0xe26a,140/80 0xe28a,157/80 0xe29b,48/80 0xe32a,64/80 0xe33a,112/80 0xe36a,144/80 0xe38a,161/80 0xe39b"

	set chan_list [split $chan_list ","]

	foreach chan_items "$chan_list" {

		set chan_items [string trim $chan_items]

		foreach {channel channel_spec} $chan_items {

			if {$channel == $chan} {

				regsub {0x} $channel_spec "" var_chan
				return $var_chan
			}
		}
	}

	incr ::error_cnt
	UTF::Message INFO "" "***Fail. Invalid '$chan' Channel. Do not continue the test."
	set ::halt_test_err "Invalid $chan Channel"
	error "Invalid $chan Channel. Halting tests!"
}

proc sts::free_memory_after_sts_assoc {} {
	# access option array
	upvar {} {}

	foreach s "$::array_streams_sts_master_sta_list(${::curr_test_no}) $::array_streams_sts_slave_sta_list(${::curr_test_no})" {
		if {[$s rte_available]} {
			UTF::Try "$s: Free Memory After $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Assoc (K)" {
				# retry is needed due to issues with NPC serial port
				for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
					set catch_resp [catch "$s freekb" catch_msg]
					UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						break
					}
				}

				if {$catch_resp == 1} {
					error $catch_msg							
				}

				set ret_val [format "%.7f" $catch_msg]
				set branch [$s branchname]
				UTF::Test::memchart $ret_val -failonlow -key [list $branch $s $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) assocfree] -units kb -title "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Assoc Free"
			}
		}
	}
}

proc sts::setup_linux_awdl {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup AWDL: CH=$::array_streams_sts_link_chan(${::curr_test_no})" {

		UTF::Message INFO "" "************************Func:setup_linux_awdl***************************"

		# currently only one STA/Slave is supported
		set sta_master $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
		set sta_slave  $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})

		set awdl_bssid "00:ff:22:33:44:ff"
		set awdl_bssid [string toupper $awdl_bssid]

		# remove the 'l','u', and '/80' to get the control channel
		set awdl_control_chan [regexp -inline {\d+} $::array_streams_sts_link_chan(${::curr_test_no})]
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> awdl_control_chan='$awdl_control_chan'"

		UTF::Message LOG "" "DUT with higher MAC address '37' is assumed as master role"
		set master_macaddr "02:90:4C:C6:13:37"
		set master_macaddr [string toupper $master_macaddr]
		UTF::Message LOG "" "DUT with lower MAC address '25' is assumed as slave role"
		set slave_macaddr "02:90:4C:C6:12:25"
		set slave_macaddr [string toupper $slave_macaddr]

		set awdl_hex_chan [sts::get_awdl_hex_chan $::array_streams_sts_link_chan(${::curr_test_no})]
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> awdl_hex_chan='$awdl_hex_chan'"

		# Olympic always have one channel 6 in 1024tu. 
		# This is required as there are 2.4g devices around which cannot lose sync in mixed environment
		set awdl_sync_control_chan 6
		set awdl_hex_sync_chan [sts::get_awdl_hex_chan $awdl_sync_control_chan]
		UTF::Message INFO "" "awdl_sync_control_chan='$awdl_sync_control_chan' -> awdl_hex_sync_chan='$awdl_hex_sync_chan'"

		# awdl_chan_seq AWDL Only example:
		#	AWDL=149/80 (e09b)		Infra=None
		#		0xe09be09be09be09be09be09be09be09b1006e09be09be09be09be09be09be09b
		#
		# awdl_chan_seq AWDL+Infra example:
		#	AWDL=149/80 (e09b)		Infra=36/80 (e02a)
		#		0xe09be09be09be09be09be09be02ae02a1006e09be09be09be09be09be02ae02a
				
		if {$::array_streams_sts_only_flag(${::curr_test_no}) == 1} {
			# AWDL Only - do not use idle slots since it causes throughput drops
			
			set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" \
					$awdl_hex_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan \
					$awdl_hex_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan \
					$awdl_hex_sync_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan \
					$awdl_hex_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan]

			UTF::Message INFO "" "AWDL Only str_awdl_chan_seq='$str_awdl_chan_seq'"
		} else {
			# AWDL+Infra

			set awdl_apsta_hex_chan [sts::get_awdl_hex_chan $::array_streams_apsta_link_chan(${::curr_test_no})]
			UTF::Message INFO "" "::array_streams_apsta_link_chan(${::curr_test_no})='$::array_streams_apsta_link_chan(${::curr_test_no})' -> awdl_apsta_hex_chan='$awdl_apsta_hex_chan'"

			set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" \
					$awdl_hex_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan \
					$awdl_hex_chan $awdl_hex_chan $awdl_apsta_hex_chan $awdl_apsta_hex_chan \
					$awdl_hex_sync_chan $awdl_hex_chan $awdl_hex_chan $awdl_hex_chan \
					$awdl_hex_chan $awdl_hex_chan $awdl_apsta_hex_chan $awdl_apsta_hex_chan]

			UTF::Message INFO "" "AWDL+Infra str_awdl_chan_seq='$str_awdl_chan_seq'"
		}

		if {$(awdl_chan_seq) != ""} {
			set str_awdl_chan_seq $(awdl_chan_seq)
			UTF::Message INFO "" "Custom Parameter str_awdl_chan_seq='$str_awdl_chan_seq'"
		}

		UTF::Message INFO "" "------------------------------MASTER & SLAVE-----------------------------------"

		foreach STA "$sta_master $sta_slave" {
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_sync_params 440 16 16 10 16 $awdl_control_chan		
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_sync_params		
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_osoc_chan $awdl_control_chan
			# encoding=2 for 80/40/20 MHz
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_chan_seq 2 3 0 0xffff $str_awdl_chan_seq
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_chan_seq
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_extcounts 3 3 3 3
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_presencemode 4
		}

		UTF::Sleep 1

		UTF::Message INFO "" "----------------------------------------------------------------------"

		# awdl_oob_af_auto must be set after "awdl 1"
		# awdl_oob_af_auto <awdl_bssid> <dst_mac> <channel> <dwell_time> <flags> <pkt_lifetime> <tx_rate> <max_retries> <chan_map> <tx_aws_offset> <hex payload>
		$sta_master wl -i $::array_sta_sts_ifname(${STA}) awdl_oob_af_auto $awdl_bssid ff:ff:ff:ff:ff:88 0 10 7 20 6 3 65535 5000 112233445566778800
		$sta_slave wl -i $::array_sta_sts_ifname(${STA}) awdl_oob_af_auto $awdl_bssid ff:ff:ff:ff:ff:88 0 10 7 20 6 3 65535 5000 112233445566778800

		# enabling data traffic
		$sta_master wl -i $::array_sta_sts_ifname($sta_master) awdl_peer_op add $::array_sta_sts_macaddr(${sta_slave}) 1 0x2d1a7f1017ffff000000000000000000000000000000000000000000bf0c3258810ffaff0000faff0000
		# no delay should be here otherwise both sides could miss each other
		$sta_slave wl -i $::array_sta_sts_ifname(${sta_slave}) awdl_peer_op add $::array_sta_sts_macaddr($sta_master) 1 0x2d1a7f1017ffff000000000000000000000000000000000000000000bf0c3258810ffaff0000faff0000
		UTF::Sleep 2

		# During iperf Traffic, use aftxmode=3 to suppress the AFs 
		$sta_master wl -i $::array_sta_sts_ifname(${STA}) awdl_aftxmode 3
		$sta_slave wl -i $::array_sta_sts_ifname(${STA}) awdl_aftxmode 3

		foreach STA "$sta_master $sta_slave" {
			catch {$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_peer_op}
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_opmode
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_stats
			$STA wl -i $::array_sta_sts_ifname(${STA}) status 
		}
		
		foreach sta_name "$sta_master $sta_slave" {
			UTF::Message INFO "" "-------------------------------------------------------------"
			$sta_name rexec ifconfig -a

			if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
				set ::array_sta_sts_macaddr(${sta_name}) ""
				set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""
			}

			set tmp [$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})]

			# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
			
			if {$::array_sta_sts_macaddr(${sta_name}) == ""} {
				regexp {ether\s+(\S+)} $tmp match ::array_sta_sts_macaddr(${sta_name})
			}
			if {$::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				regexp {inet6\s+(\S+)} $tmp match ::array_sta_sts_ipv6_macaddr(${sta_name})
			}

			UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})            ='$::array_sta_sts_macaddr(${sta_name})'"
			UTF::Message INFO "" "::array_sta_sts_ipv6_macaddr(${sta_name})       ='$::array_sta_sts_ipv6_macaddr(${sta_name})'"

			if {$::array_sta_sts_macaddr(${sta_name}) == "" || $::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				incr ::error_cnt
				error "ERROR: 'Check macaddr and ipv6_macaddr for '$sta_name' interface '$::array_sta_sts_ifname(${sta_name})'. Halting tests!" 
			}
		}

		# current_time
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

		UTF::Message INFO "" "-----------------------------Set STA status $current_time------------------------------------------"
		
		set ::array_sta_sts_active_flag(${sta_slave}) 1
		set ::array_sta_sts_disassociated_flag(${sta_slave}) 0
		UTF::Message INFO "" "apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_slave})"
		UTF::Message INFO "" "sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_slave})"

		UTF::Message INFO "" "----------------------------STA $sta_slave Check $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel----------------------------"
		# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
		for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
			set temp [$sta_slave wl -i $::array_sta_sts_ifname(${sta_slave}) chanspec]
			regexp {(\S+) } $temp match slave_chan
			if {$::array_streams_sts_link_chan(${::curr_test_no}) == $slave_chan} {
				break
			} else {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}). Retry $retry_cnt"
			}
		}

		if {$::array_streams_sts_link_chan(${::curr_test_no}) != $slave_chan} {
			set ::err_msg [concat $::err_msg "($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}))"]
			UTF::Message ERROR "" "$::err_msg"
		} else {
			UTF::Message INFO "" "PASS. $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel is $::array_streams_sts_link_chan(${::curr_test_no})"
		}

		return $::array_streams_sts_link_chan(${::curr_test_no})
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "AWDL_panic" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	} else {
		# check for other error
		if {$::errorCode != "NONE"} {
			set lines [split $::errorInfo "\n"]
			set line [lindex $lines 0]
			set ::panic_msg "($line)"
			UTF::Message INFO "AWDL_error" "::errorCode=$::errorCode"
			UTF::Message INFO "AWDL_error" "::errorInfo=$::errorInfo"
			incr ::error_cnt
		}
	}
}

proc sts::setup_linux_idle_awdl {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup Idle AWDL: CH=$::array_streams_sts_link_chan(${::curr_test_no})" {

		UTF::Message INFO "" "************************Func:setup_linux_idle_awdl***************************"

		# currently only one STA/Slave is supported
		set sta_master $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
		set sta_slave  $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})

		foreach sta_name "$sta_master $sta_slave" {
			set catch_resp [catch {$sta_name dhd -i $::array_sta_apsta_ifname($sta_name) dma_ring_indices} catch_msg]
			if {$catch_resp != 0 || $catch_msg != "3"} {
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				error "$sta_name DHD dma_ring_indices !=3. Halting tests!" 
			}
			set catch_resp [catch {$sta_name dhd -i $::array_sta_apsta_ifname($sta_name) h2d_phase} catch_msg]
			if {$catch_resp != 0 || $catch_msg != "1"} {
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				error "$sta_name DHD h2d_phase !=1. Halting tests!" 
			}
			set catch_resp [catch {$sta_name dhd -i $::array_sta_apsta_ifname($sta_name) force_trap_bad_h2d_phase} catch_msg]
			if {$catch_resp != 0 || $catch_msg != "1"} {
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				error "$sta_name DHD force_trap_bad_h2d_phase !=1. Halting tests!" 
			}
		}

		set awdl_bssid "00:ff:22:33:44:ff"
		set awdl_bssid [string toupper $awdl_bssid]

		# remove the 'l','u', and '/80' to get the control channel
		set awdl_control_chan [regexp -inline {\d+} $::array_streams_sts_link_chan(${::curr_test_no})]
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> awdl_control_chan='$awdl_control_chan'"

		UTF::Message LOG "" "DUT with higher MAC address '37' is assumed as master role"
		set master_macaddr "02:90:4C:C6:13:37"
		set master_macaddr [string toupper $master_macaddr]
		UTF::Message LOG "" "DUT with lower MAC address '25' is assumed as slave role"
		set slave_macaddr "02:90:4C:C6:12:25"
		set slave_macaddr [string toupper $slave_macaddr]

		set awdl_hex_chan [sts::get_awdl_hex_chan $::array_streams_sts_link_chan(${::curr_test_no})]
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> awdl_hex_chan='$awdl_hex_chan'"

		# Olympic always have one channel 6 in 1024tu. 
		# This is required as there are 2.4g devices around which cannot lose sync in mixed environment
		set awdl_sync_control_chan 6
		set awdl_hex_sync_chan [sts::get_awdl_hex_chan $awdl_sync_control_chan]
		UTF::Message INFO "" "awdl_sync_control_chan='$awdl_sync_control_chan' -> awdl_hex_sync_chan='$awdl_hex_sync_chan'"

		# If there is no idle slots and AWDL Connection First, then later on, AP assoc will fails.
		# Idle slots is needed for scan and association.
		# Note: idle slots causes throughput drops

		# awdl_chan_seq idle example:
		#	AWDL=149/80 (e09b)		Infra=None
		#		0x1006e09be09b000000000000000000001006e09be09b00000000000000000000

		set idle_hex_chan "0000"

		set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" \
				$awdl_hex_sync_chan $awdl_hex_chan $awdl_hex_chan $idle_hex_chan \
				$idle_hex_chan $idle_hex_chan $idle_hex_chan $idle_hex_chan \
				$awdl_hex_sync_chan $awdl_hex_chan $awdl_hex_chan $idle_hex_chan \
				$idle_hex_chan $idle_hex_chan $idle_hex_chan $idle_hex_chan]

		UTF::Message INFO "" "Idle AWDL str_awdl_chan_seq='$str_awdl_chan_seq'"

		UTF::Message INFO "" "------------------------------MASTER-----------------------------------"

		# Set awdl link MAC addresses
		$sta_master wl -i $::array_sta_apsta_ifname($sta_master) awdl_if -C 2 $awdl_bssid up
		UTF::Sleep 1

		# setup IP StS on MASTER
		$sta_master rexec ifconfig $::array_sta_sts_ifname($sta_master) hw ether $master_macaddr
		UTF::Sleep 1
		set ::array_sta_sts_macaddr($sta_master) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$sta_master rexec ifconfig $::array_sta_sts_ifname($sta_master)]]
		set ::array_sta_sts_macaddr($sta_master) [string toupper $::array_sta_sts_macaddr($sta_master)]
		UTF::Message INFO "" "::array_sta_sts_macaddr($sta_master)=$::array_sta_sts_macaddr($sta_master)"
		if {$::array_sta_sts_macaddr($sta_master) != $master_macaddr} {
			incr ::error_cnt
			error "::array_sta_sts_macaddr($sta_master)=$::array_sta_sts_macaddr($sta_master) instead of $master_macaddr. Halting tests!"
		}
		$sta_master rexec ifconfig $::array_sta_sts_ifname($sta_master) $::array_sta_sts_ip($sta_master) up

		$sta_master rexec ifconfig -a

		UTF::Message INFO "" "------------------------------SLAVE-----------------------------------"

		# Set awdl link MAC addresses
		$sta_slave wl -i $::array_sta_apsta_ifname(${sta_slave}) awdl_if -C 2 $awdl_bssid up
		UTF::Sleep 1

		# setup IP StS SLAVE
		$sta_slave rexec ifconfig $::array_sta_sts_ifname(${sta_slave}) hw ether $slave_macaddr
		UTF::Sleep 1
		set ::array_sta_sts_macaddr(${sta_slave}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$sta_slave rexec ifconfig $::array_sta_sts_ifname(${sta_slave})]]
		set ::array_sta_sts_macaddr(${sta_slave}) [string toupper $::array_sta_sts_macaddr(${sta_slave})]
		UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_slave})=$::array_sta_sts_macaddr(${sta_slave})"
		if {$::array_sta_sts_macaddr(${sta_slave}) != $slave_macaddr} {
			incr ::error_cnt
			error "::array_sta_sts_macaddr(${sta_slave})=$::array_sta_sts_macaddr(${sta_slave}) instead of $slave_macaddr. Halting tests!"
		}
		$sta_slave rexec ifconfig $::array_sta_sts_ifname(${sta_slave}) $::array_sta_sts_ip(${sta_slave}) up

		$sta_slave rexec ifconfig -a

		UTF::Message INFO "" "------------------------------MASTER & SLAVE-----------------------------------"

		foreach STA "$sta_master $sta_slave" {
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_config 3
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_election_metric 1
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_af_hdr ff:ff:ff:ff:ff:88 0x7f010203
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_pktlifetime 10
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_sync_params 440 16 16 10 16 $awdl_sync_control_chan		
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_osoc_chan $awdl_control_chan
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_payload 0x5566779900888899fefe
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_election_tree 0 0 1 -50 0 -90 -90 -90 1 1 16 0 0
			UTF::Sleep 1
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_af_rssi -80
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_awbcnoffset 0
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_maxnomaster 8
			# encoding=2 for 80/40/20 MHz
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_chan_seq 2 3 0 0xffff $str_awdl_chan_seq
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_chan_seq
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_extcounts 3 0 0 0
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl 1
			UTF::Sleep 1
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_presencemode 4
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_aftxmode 0
			# awdl_oob_af_auto must be set after "awdl 1"
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_oob_af_auto $awdl_bssid ff:ff:ff:ff:ff:88 0 10 7 20 6 3 65535 5000 1122334455667788
		}

		UTF::Message INFO "" "----------------------------------------------------------------------"

		foreach STA "$sta_master $sta_slave" {
			catch {$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_peer_op}
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_opmode
			$STA wl -i $::array_sta_sts_ifname(${STA}) awdl_stats
			$STA wl -i $::array_sta_sts_ifname(${STA}) status 
		}
		
		foreach sta_name "$sta_master $sta_slave" {
			UTF::Message INFO "" "-------------------------------------------------------------"
			$sta_name rexec ifconfig -a

			if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
				set ::array_sta_sts_macaddr(${sta_name}) ""
				set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""
			}

			set tmp [$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})]

			# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
			
			if {$::array_sta_sts_macaddr(${sta_name}) == ""} {
				regexp {ether\s+(\S+)} $tmp match ::array_sta_sts_macaddr(${sta_name})
			}
			if {$::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				regexp {inet6\s+(\S+)} $tmp match ::array_sta_sts_ipv6_macaddr(${sta_name})
			}

			UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})            ='$::array_sta_sts_macaddr(${sta_name})'"
			UTF::Message INFO "" "::array_sta_sts_ipv6_macaddr(${sta_name})       ='$::array_sta_sts_ipv6_macaddr(${sta_name})'"

			if {$::array_sta_sts_macaddr(${sta_name}) == "" || $::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				incr ::error_cnt
				error "ERROR: 'Check macaddr and ipv6_macaddr for '$sta_name' interface '$::array_sta_sts_ifname(${sta_name})'. Halting tests!" 
			}
		}

		UTF::Message INFO "" "Check for peers to see if they are SYNC (time synchonised)"

		# current_time
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

		UTF::Message INFO "" "-----------------------------Set STA status $current_time------------------------------------------"
		
		set ::array_sta_sts_active_flag(${sta_slave}) 1
		set ::array_sta_sts_disassociated_flag(${sta_slave}) 0
		UTF::Message INFO "" "apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_slave})"
		UTF::Message INFO "" "sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_slave})"

		UTF::Message INFO "" "----------------------------STA $sta_slave Check $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel----------------------------"
		# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
		for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
			set temp [$sta_slave wl -i $::array_sta_sts_ifname(${sta_slave}) chanspec]
			regexp {(\S+) } $temp match slave_chan
			if {$::array_streams_sts_link_chan(${::curr_test_no}) == $slave_chan} {
				break
			} else {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}). Retry $retry_cnt"
			}
		}

		if {$::array_streams_sts_link_chan(${::curr_test_no}) != $slave_chan} {
			set ::err_msg [concat $::err_msg "($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}))"]
			UTF::Message ERROR "" "$::err_msg"
		} else {
			UTF::Message INFO "" "PASS. $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel is $::array_streams_sts_link_chan(${::curr_test_no})"
		}

		return $::array_streams_sts_link_chan(${::curr_test_no})
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "AWDL_panic" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	} else {
		# check for other error
		if {$::errorCode != "NONE"} {
			set lines [split $::errorInfo "\n"]
			set line [lindex $lines 0]
			set ::panic_msg "($line)"
			UTF::Message INFO "AWDL_error" "::errorCode=$::errorCode"
			UTF::Message INFO "AWDL_error" "::errorInfo=$::errorInfo"
			incr ::error_cnt
		}
	}
}

proc sts::setup_macos_awdl {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup AWDL: CH=$::array_streams_sts_link_chan(${::curr_test_no})" {

		UTF::Message INFO "" "************************Func:setup_macos_awdl***************************"

		# currently only one STA/Slave is supported
		set sta_master $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
		set sta_slave  $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})

		UTF::Message INFO "" "MacOS AWDL is fixed on 149/80 channel"
		UTF::Message INFO "" "AWDL channel = $::array_streams_sts_link_chan(${::curr_test_no})"
		#$sta_master rexec apple80211 -awdl_secondary_master_channel=$::array_streams_sts_link_chan(${::curr_test_no})
		#$sta_master rexec apple80211 -awdl_master_channel=$::array_streams_sts_link_chan(${::curr_test_no})
		$sta_master rexec apple80211 -awdl_master_channel
		$sta_master rexec apple80211 -awdl_secondary_master_channel
		$sta_slave rexec apple80211 -awdl_master_channel
		$sta_slave rexec apple80211 -awdl_secondary_master_channel
		
		foreach sta_name "$sta_master $sta_slave" {
			UTF::Message INFO "" "-------------------------------------------------------------"
			$sta_name rexec ifconfig -a

			if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
				set ::array_sta_sts_macaddr(${sta_name}) ""
				set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""
			}

			set tmp [$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})]

			# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap

			if {$::array_sta_sts_macaddr(${sta_name}) == ""} {
				regexp {ether\s+(\S+)} $tmp match ::array_sta_sts_macaddr(${sta_name})
			}
			if {$::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				regexp {inet6\s+(\S+)} $tmp match ::array_sta_sts_ipv6_macaddr(${sta_name})
			}

			UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})            ='$::array_sta_sts_macaddr(${sta_name})'"
			UTF::Message INFO "" "::array_sta_sts_ipv6_macaddr(${sta_name})       ='$::array_sta_sts_ipv6_macaddr(${sta_name})'"

			if {$::array_sta_sts_macaddr(${sta_name}) == "" || $::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
				incr ::error_cnt
				error "ERROR: 'Check macaddr and ipv6_macaddr for '$sta_name' interface '$::array_sta_sts_ifname(${sta_name})'. Halting tests!" 
			}
		}

		# current_time
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

		UTF::Message INFO "" "-----------------------------Set STA status $current_time------------------------------------------"
		
		set ::array_sta_sts_active_flag(${sta_slave}) 1
		set ::array_sta_sts_disassociated_flag(${sta_slave}) 0
		UTF::Message INFO "" "apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_slave})"
		UTF::Message INFO "" "sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_slave})"

		UTF::Message INFO "" "----------------------------STA $sta_slave Check $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel----------------------------"
		# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
		for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
			set temp [$sta_slave wl -i $::array_sta_sts_ifname(${sta_slave}) chanspec]
			regexp {(\S+) } $temp match slave_chan
			if {$::array_streams_sts_link_chan(${::curr_test_no}) == $slave_chan} {
				break
			} else {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}). Retry $retry_cnt"
			}
		}

		if {$::array_streams_sts_link_chan(${::curr_test_no}) != $slave_chan} {
			set ::err_msg [concat $::err_msg "($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) chan is $slave_chan instead of $::array_streams_sts_link_chan(${::curr_test_no}))"]
			UTF::Message ERROR "" "$::err_msg"
		} else {
			UTF::Message INFO "" "PASS. $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) channel is $::array_streams_sts_link_chan(${::curr_test_no})"
		}

		return $::array_streams_sts_link_chan(${::curr_test_no})
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "AWDL_panic" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	} else {
		# check for other error
		if {$::errorCode != "NONE"} {
			set lines [split $::errorInfo "\n"]
			set line [lindex $lines 0]
			set ::panic_msg "($line)"
			UTF::Message INFO "AWDL_error" "::errorCode=$::errorCode"
			UTF::Message INFO "AWDL_error" "::errorInfo=$::errorInfo"
			incr ::error_cnt
		}
	}
}

proc sts::mac_apple80211_create_p2p_go {} {

	UTF::Message INFO "" "************************Func:mac_apple80211_create_p2p_go***************************"

	UTF::Message INFO "" "::array_sta_sts_macaddr(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})=$::array_sta_sts_macaddr(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})"

	set catch_resp [catch {		

		UTF::Message INFO "" "$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool -vif_create=p2p_go,$::array_sta_sts_macaddr(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})"	
		set rc [$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool -vif_create=p2p_go,$::array_sta_sts_macaddr(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})]
		UTF::Sleep 1

		# the p2p is created
		regexp -nocase {Created (.*)} $rc match ::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})
		UTF::Message INFO "" "p2p interface '$::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})' is created"

		UTF::Message INFO "" "$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -p2p_go_default_ies=on"
		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -p2p_go_default_ies=on
		UTF::Sleep 1

		UTF::Message INFO "" "$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -ie_add=pb,5,dd0017f205"
		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -ie_add=pb,5,dd0017f205
		UTF::Sleep 1

		set tmp_chan $::array_streams_sts_link_chan(${::curr_test_no})
		# channels with "l" must be passed as "+" and "u" must be passed as "-"
		set Index [string last "u" $tmp_chan]
		if {$Index >= 0} {
			set tmp_chan [string replace $tmp_chan $Index end "-"]
			UTF::Message INFO "" "sts_chan=$tmp_chan"
		}
		set Index [string last "l" $tmp_chan]
		if {$Index >= 0} {
			set tmp_chan [string replace $tmp_chan $Index end "+"]
			UTF::Message INFO "" "sts_chan=$tmp_chan"
		}
				
		UTF::Message INFO "" "$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -p2p_go_conf=$::p2p_ssid,$tmp_chan,on,off"
		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) $::apple_tool $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) -p2p_go_conf=$::p2p_ssid,$tmp_chan,on,off
		UTF::Sleep 1

		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) rexec ifconfig $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) $::array_sta_sts_ip(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) netmask 255.255.255.0
		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) rexec ifconfig $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) up
		UTF::Sleep 2
		
		$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) rexec ifconfig $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})
		
	} catch_msg]
	
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::create_p2p_go {} {

	UTF::Message INFO "" "************************Func:create_p2p_go***************************"

	set sta_name $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})

	# sts macaddr is the same as apsta macaddr exept the 1st byte is '1'
	set ::array_sta_sts_macaddr(${sta_name}) [string replace $::array_sta_apsta_macaddr(${sta_name}) 0 0 "1"]
	UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})=$::array_sta_sts_macaddr(${sta_name})"

	set catch_resp [catch {
	
		$sta_name wl p2p_ifadd $::array_sta_sts_macaddr(${sta_name}) go $::array_streams_sts_link_chan(${::curr_test_no})
		UTF::Sleep 1

		# get the new P2P interface name
		set rc [$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})]
		regexp -nocase { (.*)} $rc match ::array_sta_sts_ifname(${sta_name})
		UTF::Message INFO "" "p2p interface '$::array_sta_sts_ifname(${sta_name})' is created"
		
		$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) $::array_sta_sts_ip(${sta_name}) netmask 255.255.255.0 up
		
		regsub -all {:} $::array_sta_sts_macaddr(${sta_name}) "" go_sts_macaddr_strip
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) add_ie 1 18 50:6F:9A 090202000409030600$go_sts_macaddr_strip
		set tmp "0902020004090D1900$go_sts_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) add_ie 2 41 50:6F:9A $tmp

		if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
			# AES=4, TKIP=8
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) wsec 4
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) set_pmk 12345678
			# WPA2-PSK auth needs to be 0x80
			# this can be done also by doing "join $::p2p_ssid imode bss amode wpa2psk" instead of "ssid $::p2p_ssid"
			# command and the driver will set wpa_auth to 0x80 automatically
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) wpa_auth 0x80
		}
		
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) ssid $::p2p_ssid
		UTF::Sleep 2
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) bss up
		UTF::Sleep 2
		
		UTF::Message INFO "" "-------------------------------------------------------------"
		$sta_name rexec ifconfig -a

		# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap

		set tmp [$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})]
		set ::array_sta_sts_macaddr(${sta_name}) ""
		regexp {ether\s+(\S+)} $tmp match ::array_sta_sts_macaddr(${sta_name})
		set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""
		regexp {inet6\s+(\S+)} $tmp match ::array_sta_sts_ipv6_macaddr(${sta_name})

		UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})            ='$::array_sta_sts_macaddr(${sta_name})'"
		UTF::Message INFO "" "::array_sta_sts_ipv6_macaddr(${sta_name})       ='$::array_sta_sts_ipv6_macaddr(${sta_name})'"
		
		if {$::array_sta_sts_macaddr(${sta_name}) == "" || $::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
			incr ::error_cnt
			error "ERROR: 'Check macaddr and ipv6_macaddr for '$sta_name' interface '$::array_sta_sts_ifname(${sta_name})'. Halting tests!" 
		}
	} catch_msg]
	
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::setup_nan {} {
	UTF::Message INFO "" "************************Func:setup_nan***************************"

	set ::nan_base_cluster_id ""	

	set sta_master $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
	set sta_slave  $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})

	set nan_link_chan $::array_streams_sts_link_chan(${::curr_test_no})
	# remove the 'l','u', and '/80' to get the control channel
	set nan_control_chan [regexp -inline {\d+} $nan_link_chan]
	
	if {$nan_control_chan > 15} {
		set nan_band "5g"
		set nan_soc_chans "6 $nan_control_chan"
	} else {
		set nan_band "2g"
		set nan_soc_chans "$nan_control_chan 149"
	}

	if {[regexp {/160} $nan_link_chan]} {
		set bw "160"
	} elseif {[regexp {/80} $nan_link_chan]} {
		set bw "80"
	} elseif {[regexp {[ul]$} $nan_link_chan]} {
		set bw "40"
	} else {
		set bw "20"
	}

	# nan_link_chanspec -> nan_control_chan/bandwidth
	set nan_link_chanspec "$nan_control_chan/$bw"

	UTF::Try "Setup NAN: CH=$nan_link_chan" {
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> nan_control_chan='$nan_control_chan'"
		UTF::Message INFO "" "nan_soc_chans='$nan_soc_chans' nan_link_chanspec='$nan_link_chanspec'"
		
		sts::setup_nan_master $sta_master $nan_soc_chans $nan_link_chanspec
		sts::setup_nan_slave $sta_slave $nan_soc_chans $nan_link_chanspec
		
		return $::array_streams_sts_link_chan(${::curr_test_no})
	}
}

proc sts::setup_nan_master {STA nan_soc_chans nan_link_chanspec} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_nan_master***************************"

	UTF::Try "$STA: Setup NAN Master: CH=$::array_streams_sts_link_chan(${::curr_test_no})" {

		UTF::Message INFO "" "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})"

		UTF::Message INFO "" "Master: macaddr=$::array_sta_apsta_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

        #############################Extra Setup#############################
		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 1
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
        #####################################################################

		$STA rexec ifconfig $::array_sta_apsta_ifname(${STA}) $::array_sta_apsta_ip(${STA}) up

		set rc [sts::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "country US"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "nan init 1"]
		UTF::Sleep 1
		set nan_macaddr [string replace $::array_sta_apsta_macaddr(${STA}) 0 1 "02"]
		set rc [sts::run_wl_cmd $STA "interface_create nan -m $nan_macaddr"]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set rc [sts::run_wl_cmd $STA "nan band auto"]
		set rc [sts::run_wl_cmd $STA "nan soc_chans $nan_soc_chans"]
		set rc [sts::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [sts::run_wl_cmd $STA "nan election_metrics 20 100"]
		#set rc [sts::run_wl_cmd $STA "nan cluster_id 50:6f:9a:01:00:01"]
		set rc [sts::run_wl_cmd $STA "nan enable 1"]
		UTF::Sleep 1
		set rc_status [sts::run_wl_cmd $STA "nan status"]
		set rc [sts::run_wl_cmd $STA "nan ctrl 0x7e"]
		UTF::Message INFO "" "10 sec delay is needed for the master start"
		UTF::Sleep 10
		# changing 'otahexmap 0x03' to 'otahexmap 0xff' will cause NAN 1.0 'wl scanresults' to return 'wl: Not Ready'
		set rc [sts::run_wl_cmd $STA "nan avail 1 entry 1 otahexmap 0x03 bitdur 2 chanspec $nan_link_chanspec"]
		set rc [sts::run_wl_cmd $STA "nan avail 3 entry 1 otahexmap 0x02 bitdur 2"]
		UTF::Sleep 1

		$STA rexec ifconfig $::array_sta_sts_ifname(${STA}) $::array_sta_sts_ip(${STA}) up
		$STA rexec ifconfig -a

		UTF::Sleep 1

		set ::array_sta_sts_macaddr(${STA}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$STA rexec ifconfig $::array_sta_sts_ifname(${STA})]]
		UTF::Message INFO "" "::array_sta_sts_macaddr(${STA})=$::array_sta_sts_macaddr(${STA})"

		set catch_resp [catch {$STA rexec dhd -i $::array_sta_apsta_ifname(${STA}) cons mu} catch_msg]

		set catch_resp [catch {$STA rexec wl nan dump rssi} catch_msg]
		set rc [sts::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		# master cluster_id is random value base_cluster_id plus ":00:00"
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set ::nan_base_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]
		UTF::Message INFO "" "::nan_base_cluster_id=$::nan_base_cluster_id"
		
		if {$cluster_id != "$::nan_base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$::nan_base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: anchor-master} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): anchor-master\}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role != "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			incr ::error_cnt
			error "Bad Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check master_rank
		###########################
		# master_rank is STA mac address plus ":xx:xx"
		regexp -nocase {master_rank:.*?\n(.*)\n.*amr:} $rc - master_rank
		UTF::Message INFO "" "master_rank='$master_rank'"
		regexp -nocase {:(.*)} $master_rank - master_rank
		set master_rank [string trim $master_rank]
		regsub -all { } $master_rank ":" master_rank
		# remove the end ":xx:xx"
		set master_rank [string replace $master_rank 17 end ""]
		UTF::Message INFO "" "master_rank=$master_rank"
		set base_mac_address $master_rank

		# NAN macaddr starts with 02
		set ::array_sta_sts_macaddr(${STA}) [string replace $::array_sta_apsta_macaddr(${STA}) 1 1 "2"]

		if {$master_rank != $::array_sta_sts_macaddr(${STA})} {
			# failed
			UTF::Message INFO "" "master_rank is '$master_rank' instead of '$::array_sta_sts_macaddr(${STA})'"
			incr ::error_cnt
			error "Bad master_rank"
		}
		
		return ""
	}

	if {$::error_cnt > 0} {
		error "html: Halting tests!"
	}
}

proc sts::setup_nan_slave {STA nan_soc_chans nan_link_chanspec} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_nan_slave***************************"

	UTF::Try "$STA: Setup NAN Slave" {

		UTF::Message INFO "" "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})"
	
		UTF::Message INFO "" "Non-Master: macaddr=$::array_sta_apsta_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

        #############################Extra Setup#############################
		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 1
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
        #####################################################################

		$STA rexec ifconfig $::array_sta_apsta_ifname(${STA}) $::array_sta_apsta_ip(${STA}) up

		set rc [sts::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "country US"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "nan init 1"]
		UTF::Sleep 1
		set nan_macaddr [string replace $::array_sta_apsta_macaddr(${STA}) 0 1 "02"]
		set rc [sts::run_wl_cmd $STA "interface_create nan -m $nan_macaddr"]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set rc [sts::run_wl_cmd $STA "nan band auto"]
		set rc [sts::run_wl_cmd $STA "nan soc_chans $nan_soc_chans"]
		set rc [sts::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [sts::run_wl_cmd $STA "nan election_metrics 20 10"]
		#set rc [sts::run_wl_cmd $STA "nan cluster_id 50:6f:9a:01:00:01"]
		set rc [sts::run_wl_cmd $STA "nan enable 1"]
		UTF::Sleep 1
		set rc_status [sts::run_wl_cmd $STA "nan status"]
		set rc [sts::run_wl_cmd $STA "nan ctrl 0x7e"]
		UTF::Message INFO "" "20 sec delay is mandatory to sync with Master"
		UTF::Sleep 20
		set rc [sts::run_wl_cmd $STA "nan avail 1 entry 1 otahexmap 0x03 bitdur 2 chanspec $nan_link_chanspec"]
		set rc [sts::run_wl_cmd $STA "nan avail 3 entry 1 otahexmap 0x02 bitdur 2"]
		UTF::Sleep 1

		$STA rexec ifconfig $::array_sta_sts_ifname(${STA}) $::array_sta_sts_ip(${STA}) up
		$STA rexec ifconfig -a

		UTF::Sleep 1

		set ::array_sta_sts_macaddr(${STA}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$STA rexec ifconfig $::array_sta_sts_ifname(${STA})]]
		UTF::Message INFO "" "::array_sta_sts_macaddr(${STA})=$::array_sta_sts_macaddr(${STA})"

		set catch_resp [catch {$STA rexec dhd -i $::array_sta_apsta_ifname(${STA}) cons mu} catch_msg]

		set catch_resp [catch {$STA rexec wl nan dump rssi} catch_msg]
		set rc [sts::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set non_master_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]

		if {$::nan_base_cluster_id != $non_master_cluster_id} {
			# failed
			UTF::Message INFO "" "Non Master Cluster ID is '$non_master_cluster_id' instead of '$::nan_base_cluster_id'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}
		
		if {$cluster_id != "$::nan_base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$::nan_base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: non-master-non-sync} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): non-master-non-sync\}} $role - role
		UTF::Message INFO "" "role=$role"
		if {$role == ""} {
			# Role is not "non-master-non-sync"
			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
		}
		
		# device can take master role 3 if the rssi threshold is hit
		if {$role != "1" && $role != "2" && $role != "3"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no}) rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role is '$role' instead of '1' for 'non-master-non-sync', '2' for 'non-master-sync',  or '3' for 'master'"
			error "Bad Non Master Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check amr
		###########################
		# amr is STA mac address plus ":xx:xx"
		regexp -nocase {amr:\n(.*)\n.*hop_count:} $rc - amr
		UTF::Message INFO "" "amr='$amr'"
		regexp -nocase {:(.*)} $amr - amr
		set amr [string trim $amr]
		regsub -all { } $amr ":" amr
		# remove the end ":xx:xx"
		set amr [string replace $amr 17 end ""]
		UTF::Message INFO "" "amr=$amr"

		set sts_sta $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
		if {$amr != $::array_sta_sts_macaddr(${sts_sta})} {
			# failed
			UTF::Message INFO "" "amr is '$amr' instead of '$::array_sta_sts_macaddr(${sts_sta})'"
			error "Bad Non Master amr"
		}

		if {$role == "1"} {
			return "Non-Master-Non-Sync"
		} elseif {$role == "2"} {
			return "Non-Master-Sync"
		} elseif {$role == "3"} {
			return "Master"
		}
	}
}

proc sts::setup_nan_merge {STA nan_soc_chans nan_link_chanspec} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_nan_merge***************************"

	UTF::Try "$STA: Setup NAN Merge" {

		UTF::Message INFO "" "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})"
	
		UTF::Message INFO "" "Merge: macaddr=$::array_sta_apsta_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

        #############################Extra Setup#############################
		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 1
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
        #####################################################################

		$STA rexec ifconfig $::array_sta_apsta_ifname(${STA}) $::array_sta_apsta_ip(${STA}) up

		set rc [sts::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "country US"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "nan init 1"]
		UTF::Sleep 1
		set nan_macaddr [string replace $::array_sta_apsta_macaddr(${STA}) 0 1 "02"]
		set rc [sts::run_wl_cmd $STA "interface_create nan -m $nan_macaddr"]
		# if STA nan is not enabled yet, then 'wl nan' is not supported yet"
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set rc [sts::run_wl_cmd $STA "nan band auto"]
		set rc [sts::run_wl_cmd $STA "nan soc_chans $nan_soc_chans"]
		set rc [sts::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [sts::run_wl_cmd $STA "nan election_metrics 20 200"]
		set rc [sts::run_wl_cmd $STA "nan cluster_id $::nan_base_cluster_id:00:00"]
		set rc [sts::run_wl_cmd $STA "nan enable 1"]
		UTF::Sleep 1
		set rc_status [sts::run_wl_cmd $STA "nan status"]
		set rc [sts::run_wl_cmd $STA "nan ctrl 0x7e"]
		UTF::Message INFO "" "20 sec delay is mandatory to sync"
		UTF::Sleep 20
		set rc [sts::run_wl_cmd $STA "nan avail 1 entry 1 otahexmap 0x03 bitdur 2 chanspec $nan_link_chanspec"]
		set rc [sts::run_wl_cmd $STA "nan avail 3 entry 1 otahexmap 0x02 bitdur 2"]
		UTF::Sleep 1

		$STA rexec ifconfig $::array_sta_sts_ifname(${STA}) $::array_sta_sts_ip(${STA}) up
		$STA rexec ifconfig -a

		UTF::Sleep 1

		set ::array_sta_sts_macaddr(${STA}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$STA rexec ifconfig $::array_sta_sts_ifname(${STA})]]
		UTF::Message INFO "" "::array_sta_sts_macaddr(${STA})=$::array_sta_sts_macaddr(${STA})"

		set catch_resp [catch {$STA rexec dhd -i $::array_sta_apsta_ifname(${STA}) cons mu} catch_msg]

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
				# only BIRX needs to be processed
				continue
			}

			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "NANDP"} {
				break
			}
		}

		set master_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
		set non_master_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
		
		foreach sta_name "$master_sta $non_master_sta $STA" {	
			set catch_resp [catch {$sta_name rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$sta_name rexec wl nan dump rssi} catch_msg]
			set rc [sts::run_wl_cmd $sta_name "nan status"]
		}

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set merge_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]

		if {$::nan_base_cluster_id != $merge_cluster_id} {
			# failed
			UTF::Message INFO "" "Merge (Base) Cluster ID is '$merge_cluster_id' instead of '$::nan_base_cluster_id'"
			incr ::error_cnt
			error "Bad Merge (Base) Cluster ID"
		}
		
		if {$cluster_id != "$::nan_base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$::nan_base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: anchor-master} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): anchor-master\}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role != "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			error "Bad Role"
		}

		###########################
		# check master_rank
		###########################
		# master_rank is STA mac address plus ":xx:xx"
		regexp -nocase {master_rank:.*?\n(.*)\n.*amr:} $rc - master_rank
		UTF::Message INFO "" "master_rank='$master_rank'"
		regexp -nocase {:(.*)} $master_rank - master_rank
		set master_rank [string trim $master_rank]
		regsub -all { } $master_rank ":" master_rank
		# remove the end ":xx:xx"
		set master_rank [string replace $master_rank 17 end ""]
		UTF::Message INFO "" "master_rank=$master_rank"
		set base_mac_address $master_rank

		if {$master_rank != $::array_sta_sts_macaddr(${STA})} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "master_rank is '$master_rank' instead of '$::array_sta_sts_macaddr(${STA})'"
			error "Bad master_rank"
		}
		
		UTF::Message INFO "" "========================================Check Master ($master_sta) role========================================"
		set rc [sts::run_wl_cmd $master_sta "nan status"]
		set role [regexp -inline {role [0-9]: } $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): \}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role == "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role for Master ($master_sta) cannot be '4' (anchor-master)"
			error "Bad Role"
		}

		UTF::Message INFO "" "========================================Check Non Master ($non_master_sta) role========================================"
		set rc [sts::run_wl_cmd $non_master_sta "nan status"]
		set role [regexp -inline {role [0-9]: } $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): \}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role == "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role for Non Master ($non_master_sta) cannot be '4' (anchor-master)"
			error "Bad Role"
		}		
	}
}

proc sts::setup_p2p_apsta {stream_no} {

	UTF::Try "Setup $::array_streams_link_type(${::curr_test_no},${stream_no}) $::array_streams_src_display_str(${::curr_test_no},${stream_no}) apsta" {
	
		UTF::Message INFO "" "************************Func:setup_p2p_apsta***************************"

		set sta_name $::array_streams_src_sta(${::curr_test_no},${stream_no})

		UTF::Message INFO "" "Setup P2P GO apsta"

		if {$::array_streams_src_host_type(${::curr_test_no},${stream_no}) == "MacOS"} {
			set catch_resp [catch {		
				$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) up
				UTF::Sleep 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) up
				UTF::Sleep 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) down
				UTF::Sleep 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) apsta 1
				UTF::Sleep 3
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) up
				UTF::Sleep 4
			} catch_msg]
			
			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) != "AWDL"} {
				foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
					catch {$sta_name rexec ifconfig awdl0 down}
					UTF::Sleep 1
				}
				catch {$sta_name rexec ifconfig awdl0 down}
				UTF::Sleep 1
			}			
		} else {
			set catch_resp [catch {		
				$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) up
				UTF::Sleep 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) down
				UTF::Sleep 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) apsta 1
				$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) up
				UTF::Sleep 4
			} catch_msg]
		}

		if {$catch_resp != 0} {
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			UTF::Message ERROR "" "***Failed. Setup GO apsta failed."
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $catch_msg
		}
	}
}

proc sts::setup_p2p_go {} {

	UTF::Try "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no}): CH=$::array_streams_sts_link_chan(${::curr_test_no})" {

		UTF::Message INFO "" "************************Func:setup_p2p_go***************************"

		UTF::Message INFO "" "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})"

		set sta_name $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})

		if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
			set catch_resp [catch "sts::mac_apple80211_create_p2p_go" catch_msg]					
		} else {
			set catch_resp [catch "sts::create_p2p_go" catch_msg]					
		}

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Setup GO failed."
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $catch_msg
		}
		
		# Confirm chanspec
		set temp [$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) chanspec]
		regexp {(\S+) } $temp match go_chan
		
		if {$::array_streams_sts_link_chan(${::curr_test_no}) != $go_chan} {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "GO chan is $go_chan instead of $::array_streams_sts_link_chan(${::curr_test_no})" 
		}		
	}
}

proc sts::mac_apple80211_create_p2p_gc {sta_name} {

	UTF::Message INFO "" "************************Func:mac_apple80211_create_p2p_gc***************************"

	UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})=$::array_sta_sts_macaddr(${sta_name})"

	set catch_resp [catch {		

		UTF::Message INFO "" "$sta_name $::apple_tool -vif_create=p2p_cli,$::array_sta_sts_macaddr(${sta_name})"
		set rc [$sta_name $::apple_tool -vif_create=p2p_cli,$::array_sta_sts_macaddr(${sta_name})]
		UTF::Sleep 1

		# the p2p is created
		regexp -nocase {Created (.*)} $rc match ::array_sta_sts_ifname(${sta_name})
		UTF::Message INFO "" "p2p interface '$::array_sta_sts_ifname(${sta_name})' is created"

		UTF::Message INFO "" "$sta_name $::apple_tool $::array_sta_sts_ifname(${sta_name}) -p2p_cli_default_ies=on"
		$sta_name $::apple_tool $::array_sta_sts_ifname(${sta_name}) -p2p_cli_default_ies=on
		UTF::Sleep 1

		UTF::Message INFO "" "$sta_name $::apple_tool $::array_sta_sts_ifname(${sta_name}) -ie_add=PA,5,dd0017f205"
		$sta_name $::apple_tool $::array_sta_sts_ifname(${sta_name}) -ie_add=PA,5,dd0017f205
		UTF::Sleep 1

		$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) $::array_sta_sts_ip(${sta_name}) netmask 255.255.255.0			
		$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) up			
		UTF::Sleep 2

		$sta_name rexec ifconfig -a
		
	} catch_msg]
	
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::create_p2p_gc {sta_name} {

	UTF::Message INFO "" "************************Func:create_p2p_gc***************************"

	# sts macaddr is the same as apsta macaddr exept the 1st byte is '1'
	set ::array_sta_sts_macaddr(${sta_name}) [string replace $::array_sta_apsta_macaddr(${sta_name}) 0 0 "1"]
	UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})=$::array_sta_sts_macaddr(${sta_name})"

	set catch_resp [catch {		
		
		$sta_name wl p2p_ifadd $::array_sta_sts_macaddr(${sta_name}) client
		UTF::Sleep 1

		# get the new P2P interface name
		set rc [$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})]
		regexp -nocase { (.*)} $rc match ::array_sta_sts_ifname(${sta_name})
		UTF::Message INFO "" "p2p interface '$::array_sta_sts_ifname(${sta_name})' is created"
		
		$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) $::array_sta_sts_ip(${sta_name}) netmask 255.255.255.0 up
		
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) add_ie 0x10 14 50:6F:9A 090202000400060200000B
		regsub -all {:} $::array_sta_sts_macaddr(${sta_name}) "" gc_sts_macaddr_strip
		set tmp "0902020004000D1900$gc_sts_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) add_ie 2 41 50:6F:9A $tmp
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) add_ie 0x20 41 50:6F:9A $tmp

		if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
			# AES=4, TKIP=8
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) wsec 4
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) sup_wpa 1
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) set_pmk 12345678
		}

		# must set infra=1 or use "imode bss" with the P2P join command
		catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) infra 1}
		
		UTF::Message INFO "" "-------------------------------------------------------------"
		$sta_name rexec ifconfig -a

		# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
		
		set tmp [$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})]
		set ::array_sta_sts_macaddr(${sta_name}) ""
		regexp {ether\s+(\S+)} $tmp match ::array_sta_sts_macaddr(${sta_name})
		set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""
		regexp {inet6\s+(\S+)} $tmp match ::array_sta_sts_ipv6_macaddr(${sta_name})

		UTF::Message INFO "" "::array_sta_sts_macaddr(${sta_name})            ='$::array_sta_sts_macaddr(${sta_name})'"
		UTF::Message INFO "" "::array_sta_sts_ipv6_macaddr(${sta_name})       ='$::array_sta_sts_ipv6_macaddr(${sta_name})'"
		
		if {$::array_sta_sts_macaddr(${sta_name}) == "" || $::array_sta_sts_ipv6_macaddr(${sta_name}) == ""} {
			incr ::error_cnt
			error "ERROR: 'Check macaddr and ipv6_macaddr for '$sta_name' interface '$::array_sta_sts_ifname(${sta_name})'. Halting tests!" 
		}
	} catch_msg]
	
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::setup_p2p_gc {} {

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {

		UTF::Try "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_dst_display_str(${::curr_test_no},${::curr_stream_no})" {

			UTF::Message INFO "" "************************Func:setup_gc $sta_name***************************"

			UTF::Message INFO "" "Setup $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) $::array_streams_dst_display_str(${::curr_test_no},${::curr_stream_no})"

			if {$::array_sta_host_type(${sta_name}) == "MacOS"} {
				set catch_resp [catch "sts::mac_apple80211_create_p2p_gc $sta_name" catch_msg]					
			} else {
				set catch_resp [catch "sts::create_p2p_gc $sta_name" catch_msg]					
			}

			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. Setup GC failed."
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error $catch_msg
			}
		}
	}
}

proc sts::apsta_link_cleanup {stream_no} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:mac_apple80211_p2p_link_cleanup***************************"

	set sta_name $::array_streams_dst_sta(${::curr_test_no},${stream_no})

	$sta_name rexec ifconfig -a
	catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) disassoc}
	UTF::Sleep 2
	$sta_name rexec ifconfig -a
}

proc sts::mac_apple80211_p2p_link_cleanup {stream_no} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:mac_apple80211_p2p_link_cleanup***************************"

	set sta_master_name $::array_streams_src_sta(${::curr_test_no},${stream_no})
	set sta_slave_name $::array_streams_dst_sta(${::curr_test_no},${stream_no})

	$sta_master_name rexec ifconfig -a
	$sta_slave_name rexec ifconfig -a
	
	catch {$sta_slave_name wl -i $::array_sta_sts_ifname(${sta_slave_name}) disassoc}
	UTF::Sleep 2
	catch {$sta_slave_name rexec ifconfig $::array_sta_sts_ifname(${sta_slave_name}) down}
	UTF::Sleep 2
	catch {$sta_master_name rexec ifconfig $::array_sta_sts_ifname(${sta_slave_name}) down}
	UTF::Sleep 2

	catch {$sta_slave_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) delete}
	UTF::Sleep 2
	catch {$sta_master_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) delete}
	UTF::Sleep 2
	
	catch {$sta_slave_name $::apple_tool -vif_delete=$::array_sta_sts_ifname(${sta_name})}
	UTF::Sleep 2
	catch {$sta_master_name $::apple_tool -vif_delete=$::array_sta_sts_ifname(${sta_name})}
	UTF::Sleep 2

	UTF::Message INFO "" "**********************************"
	$sta_master_name rexec ifconfig -a
	$sta_slave_name rexec ifconfig -a
}

proc sts::p2p_link_cleanup {stream_no} {
	
	UTF::Message INFO "" "************************Func:p2p_link_cleanup***************************"

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		$sta_name rexec ifconfig -a
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	$sta_name rexec ifconfig -a

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "NANDP"} {
			UTF::Message INFO "" "NAN Clean up for Linux needs 'wl nan dp_dataend 1 0' commnad"
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) nan dp_dataend 1 0}
			UTF::Message INFO "" "NAN Clean up for Linux needs 'wl nan enable 0' commnad"
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) nan enable 0}
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "AWDL"} {
			UTF::Message INFO "" "AWDL Clean up for Linux needs 'wl awdl 0' commnad"
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) awdl 0}
		} else {
			UTF::Message INFO "" "P2P Clean up for Linux needs 'wl disassoc' commnad"
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) disassoc}
		}
		UTF::Sleep 2
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) disassoc}
	UTF::Sleep 2

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) disassoc}
		UTF::Sleep 2
		catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) down}
		UTF::Sleep 2
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) down}
	UTF::Sleep 2

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) down}
		UTF::Sleep 2
		catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) down}
		UTF::Sleep 2
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) down}
	UTF::Sleep 2

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})}
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})} 

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		set catch_resp [catch {$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})} catch_msg]
		if {[string first "Not Found" $catch_msg] == -1} {
			regsub -all {:} $::array_sta_sts_macaddr(${sta_name}) "" gc_sts_macaddr_strip
			set tmp "0902020004000D1900$gc_sts_macaddr_strip"
			append tmp "000400010050F204000600101100045032502D0E010000" 
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) del_ie 0x20 41 50:6F:9A $tmp}
			UTF::Sleep 2
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) del_ie 2 41 50:6F:9A $tmp}
			UTF::Sleep 2
			catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) del_ie 0x10 14 50:6F:9A 090202000400060200000B}
			UTF::Sleep 2
		}
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	set catch_resp [catch {$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})} catch_msg]
	if {[string first "Not Found" $catch_msg] == -1} {
		regsub -all {:} $::array_sta_sts_macaddr(${sta_name}) "" go_sts_macaddr_strip
		set tmp "0902020004090D1900$go_sts_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) del_ie 2 41 50:6F:9A $tmp}
		UTF::Sleep 2
		catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) del_ie 1 18 50:6F:9A 090202000409030600$go_sts_macaddr_strip}
		UTF::Sleep 2
	}

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		set catch_resp [catch {$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})} catch_msg]
		if {[string first "Not Found" $catch_msg] == -1} {
			catch {$sta_name wl p2p_ifdel $::array_sta_sts_macaddr(${sta_name})}
			UTF::Sleep 2
		}
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	set catch_resp [catch {$sta_name wl p2p_if $::array_sta_sts_macaddr(${sta_name})} catch_msg]
	if {[string first "Not Found" $catch_msg] == -1} {
		catch {$sta_name wl p2p_ifdel $::array_sta_sts_macaddr(${sta_name})}
		UTF::Sleep 2
	}

	UTF::Sleep 4

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) down}
		UTF::Sleep 2
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name}) down}
	UTF::Sleep 2

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})}
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})} 

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) down}
		UTF::Sleep 2
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) down}
	UTF::Sleep 2

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		catch {$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})}
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	catch {$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})} 

	UTF::Message INFO "" "**********************************"
	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		$sta_name rexec ifconfig -a
	}
	set sta_name $::array_streams_sts_master_sta_list(${::curr_test_no})
	$sta_name rexec ifconfig -a

	# current_time
	set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
	set parts [split $time_ms "."]
	set round_down [lindex $parts 0]
	set fraction [lindex $parts 1]
	set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

	UTF::Message INFO "" "-----------------------------Reset STA status $current_time------------------------------------------"

	foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
		set ::array_sta_sts_active_flag(${sta_name}) 0
	}
}

proc sts::link_cleanup {} {
	
	UTF::Message INFO "" "************************Func:link_cleanup***************************"

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] == -1} {
			# Non StS link
			continue
		}

		if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
			continue
		}
			
		set sta_name $::array_streams_dst_sta(${::curr_test_no},${stream_no})

		switch $::array_streams_link_type(${::curr_test_no},${stream_no}) {

			APSTA {
				UTF::Try "APSTA Clean-up" {
					sts::apsta_link_cleanup $stream_no
				}
			}

			P2P {
				UTF::Try "P2P Clean-up" {
					if {$::array_sta_host_type(${sta_name}) == "MacOS"} {
						UTF::Message INFO "" "MacOS P2P clean up when apple80211 commands are used"
						sts::mac_apple80211_p2p_link_cleanup $stream_no
					} else {
						UTF::Message INFO "" "Linux P2P clean up"
						sts::p2p_link_cleanup $stream_no
					}
				}
			}

			AWDL {
				UTF::Try "AWDL Clean-up" {
					if {$::array_sta_host_type(${sta_name}) == "MacOS"} {
						UTF::Message INFO "" "MacOS AWDL is created by OS, therefore nothing to cleanup"
					} else {
					}
				}
			}

			NANDP {
				UTF::Try "NAN Clean-up" {
				}
			}

			BT {
			}

			AIBSS {
			}

			11mc {
			}
		}

	}
	
	return ""
}

proc sts::setup_opp_ps {} {

	UTF::Message INFO "" "************************Func:setup_opp_ps***************************"

	UTF::Try "Setup OppPS with CTWindow $::OppPS_CTWindow" {

		UTF::Message INFO "" "Setup OppPS with CTWindow=$::OppPS_CTWindow"

		set catch_resp [catch {$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) wl -i $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) p2p_ops 1 $::OppPS_CTWindow} catch_msg]

		if {$catch_resp == 0} {
			return $catch_msg
		} else {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $catch_msg
		}
	}
}

proc sts::setup_noa {} {

	UTF::Message INFO "" "************************Func:setup_noa***************************"

	UTF::Try "Setup NoA (Notice of Absence)" {

		UTF::Message INFO "" "Setup NoA (Notice of Absence)"

		set catch_resp [catch {$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) wl -i $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})}) p2p_noa $::NoA_Param} catch_msg]

		if {$catch_resp == 0} {
			return $catch_msg
		} else {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $catch_msg
		}
	}
}

proc sts::create_ap_connection {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_ap_connection***************************"

	#####################################################
	##### Current Measurement before AP association #####
	#####################################################
	if {$::agilent_obj != ""} {

		UTF::Try "DTIM Interval Measurement (AP Not Associated)" {
			foreach STA $(sta) {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}

			set ::cct_key "DTIM AP Not Associated"
			sts::measure_dtim_interval					
			return "html: $::current_results"
		}

		UTF::Try "Current Measurement (AP Not Associated)" {
			set ::cct_key "AP Not Associated"
			sts::measure_idle_current					
			return "html: $::current_results"
		}
	}

	#####################################################
	##############      STA joins AP     ################
	#####################################################
	sts::sta_join_ap

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "H" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}

	set ap_controller $::array_streams_ap_controller(${::curr_test_no})

	#####################################################
	# Free memory after AP association
	foreach s "$::array_streams_sts_master_sta_list(${::curr_test_no}) $::array_streams_sts_slave_sta_list(${::curr_test_no})" {
		if {[$s rte_available]} {
			if {$::array_sta_softap_flag($ap_controller) == 1} {
				set tmp_ap "SoftAP"
			} else {
				set tmp_ap "AP"
			}

			UTF::Try "$s: Free Memory After $tmp_ap Assoc (K)" {
				# retry is needed due to issues with NPC serial port
				for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
					set catch_resp [catch "$s freekb" catch_msg]
					UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						break
					}
				}

				if {$catch_resp == 1} {
					error $catch_msg							
				}

				set ret_val [format "%.7f" $catch_msg]
				set branch [$s branchname]
				UTF::Test::memchart $ret_val -failonlow -key [list $branch $s $tmp_ap assocfree] -units kb -title "$tmp_ap Assoc Free"
			}
		}
	}
	#####################################################

	if {$::error_cnt > 0} {
		sts::connection_test
	}
}

proc sts::sta_join_ap {} {
	# access option array
	upvar {} {}

	set ap_controller $::array_streams_ap_controller(${::curr_test_no})

	if {$::array_sta_softap_flag($ap_controller) == 1} {
		set tmp_ap "SoftAP"
	} else {
		set tmp_ap "AP"
	}

	if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "APSTA"} {
		set sta_list $::array_streams_apsta_sta_list(${::curr_test_no})
	} else {
		set sta_list $::array_streams_sts_slave_sta_list(${::curr_test_no})
	}

# kevin
	UTF::Message INFO "kevinz3" "---------------------------------sta_list=$sta_list--------------------------------------------------------------"

	foreach sta_name $sta_list {

		UTF::Try "$sta_name: $::array_sta_label(${sta_name}) Join $tmp_ap: CH=$::array_streams_apsta_link_chan(${::curr_test_no})" {

			UTF::Message INFO "" "************************Func:sta_join_ap***************************"

			UTF::Message INFO "" "-----------------------------------------------------------------------------------------------"

			# initialize
			set ::array_sta_apsta_active_flag(${sta_name}) 0
			set ::array_sta_apsta_disassociated_flag(${sta_name}) 1

			set catch_resp [catch "UTF::Test::ConnectAPSTA $::array_streams_ap(${::curr_test_no}) $sta_name -chanspec $::array_streams_apsta_link_chan(${::curr_test_no}) -security open" catch_msg]
			if {$catch_resp != 0} {
				# sometimes for b band, we need more time to associate. continue to see if it is associated

				for {set retry_cnt 0} {$retry_cnt <= 5} {incr retry_cnt} {
					UTF::Message INFO "" "UTF::Test::ConnectAPSTA issue '$catch_msg' - wait more time to associate"
					if {$retry_cnt == 2} {
						# still not associated. Try to join again
						catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) disassoc}
						UTF::Sleep 5
						catch "UTF::Test::ConnectAPSTA $::array_streams_ap(${::curr_test_no}) $sta_name"
					}
					UTF::Sleep 5
					set catch_resp [catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) bssid} catch_msg]
					if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
						continue
					}

					break
				}
			}

			set ifname $::array_sta_apsta_ifname(${sta_name})
			set ip $::array_sta_apsta_ip(${sta_name})
			set host_type $::array_sta_host_type(${sta_name})

			$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) assoc

			set catch_resp [catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) bssid} catch_msg]
			if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
				incr ::error_cnt	
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "bssid: $catch_msg"
			}

			if {$host_type != "MacOS"} {
				set sta_apsta_ip ""
				regexp {inet (\d+\.\d+\.\d+\.\d+)} [$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})] match sta_apsta_ip
				#regexp {inet addr:(\d+\.\d+\.\d+\.\d+)}
				UTF::Message INFO "" "sta_apsta_ip=$sta_apsta_ip"
				if {$sta_apsta_ip == ""} {
					regexp {inet addr:(\d+\.\d+\.\d+\.\d+)} [$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})] match sta_apsta_ip
					UTF::Message INFO "" "sta_apsta_ip=$sta_apsta_ip"
				}

				if {$sta_apsta_ip != $ip} {
					$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) $ip
					UTF::Sleep 2
				}
			}

			UTF::Sleep 15

			UTF::Message INFO "" "-------------------rssinoise Test-----------------------"
			set rssinoise_err ""
			set catch_resp [catch "UTF::Test::rssinoise $::array_streams_ap(${::curr_test_no}) $sta_name" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message INFO "" "***Failed. catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				set rssinoise_err "$catch_msg"
			}

			UTF::Message INFO "" "--------------------------------------------------------"

			# Confirm AP chanspec
			set temp [$::array_streams_ap(${::curr_test_no}) wl chanspec]
			regexp {(\S+) } $temp match ap_chan

			if {$::array_streams_apsta_link_chan(${::curr_test_no}) != $ap_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "AP chan is $ap_chan instead of $::array_streams_apsta_link_chan(${::curr_test_no})" 
			}		

			# Confirm STA chanspec
			set temp [$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) chanspec]
			regexp {(\S+) } $temp match joined_chan

			if {$::array_streams_apsta_link_chan(${::curr_test_no}) != $joined_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "joined AP chan is $joined_chan instead of $::array_streams_apsta_link_chan(${::curr_test_no})" 
			}

			set ::array_sta_apsta_active_flag(${sta_name}) 1
			set ::array_sta_apsta_disassociated_flag(${sta_name}) 0

			if {$rssinoise_err != ""} {
				UTF::Message INFO "" "***Failed. rssinoise test gave error '$rssinoise_err'"
				error "$joined_chan ($rssinoise_err)"
			}

			return $joined_chan
		}
		
		if {$(11mc)} {
			break
		}
	}
}

proc sts::slave_join_master {sta_name retry_cnt rvr_flag} {
	# access option array
	upvar {} {}

	set ping_error ""

	if {$rvr_flag == 1} {
		set tmp_str "$sta_name: $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Reassociate"
	} else {
		set tmp_str "$sta_name: $::array_streams_dst_display_str(${::curr_test_no},${::curr_stream_no}) Join $::array_streams_src_display_str(${::curr_test_no},${::curr_stream_no})"
		if {$retry_cnt > 0} {
			set tmp_str "$tmp_str (Retry $retry_cnt)"
		}
	}
	
	UTF::Try "$tmp_str" {

		UTF::Message INFO "" "************************Func:slave_join_master***************************"

		if {$retry_cnt > 2} {
			UTF::Message INFO "" "--------------------------DEBUG START-----------------------------------"
			$sta_name rexec ifconfig -a
			UTF::Message INFO "" "-------------------------------------------------------------"
			$sta_name rexec ifconfig -a
			UTF::Message INFO "" "-------------------------------------------------------------"
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scan
			UTF::Sleep 7
			$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scanresults
			UTF::Message INFO "" "--------------------------DEBUG END-----------------------------------"
		}

		UTF::Try "Test $::curr_test_no Streams Data" {
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				UTF::Try "Stream $stream_no Data" {
					UTF::Message INFO "" "print stream $stream_no"
					sts::array_setup_stream_data $::curr_test_no $stream_no 0 0 1 0
				}
			}
		}

		if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "NANDP"} {
			set master_sta $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})
			set slave_sta  $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})
			set slave_macaddr $::array_sta_sts_macaddr(${slave_sta})
			set rc [sts::run_wl_cmd $master_sta "nan dp_req ucast pub_id 1 confirm peer_mac $slave_macaddr svc_spec_info \"abcdef12345678\" qos 4 255 6 10"]
			set p2p_associated_flag 1
		} elseif {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "AWDL"} {
			if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
				# do not join using passive assoc scan
				set join_param ""
			} else {
				set join_param "-p"
			}

			UTF::Message INFO "" "Associate"

			if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
				$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param imode bss amode wpa2psk
			} else {
				$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param
			}

			set p2p_associated_flag 0
			for {set retry_cnt 0} {$retry_cnt < 6} {incr retry_cnt} {
				UTF::Sleep 5
				set catch_resp [catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) bssid} catch_msg]
				if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
					continue
				} else {
					$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) assoc
					set p2p_associated_flag 1
					break
				}
			}

			if {$p2p_associated_flag == 0} {
				UTF::Message INFO "" "----------------------------------------------"
				UTF::Message INFO "" "Associate again"
				catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scan}
				UTF::Sleep 10
				catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scanresults}

				if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
					$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param imode bss amode wpa2psk
				} else {
					$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param
				}

				UTF::Sleep 10
				$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) assoc

				set catch_resp [catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) bssid} catch_msg]
				if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
					if {$rvr_flag == 1} {
						error "html: <font color=\"red\"><b>$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is NOT associated</b></font>"
					}
					incr ::error_cnt
					UTF::Message INFO "" "::error_cnt=$::error_cnt"
					if {$rvr_flag == 1} {
						error "$catch_msg"
					} else {
						error "$catch_msg - Retry"
					}
				}
			}

			UTF::Sleep 10
		}
		
		for {set retry_cnt 1} {$retry_cnt <= 3} {incr retry_cnt} {
			for {set stream_no 1} {$stream_no <= $::array_ping_streams_cnt(${::curr_test_no})} {incr stream_no} {
				set ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) ""
			}
			set ::array_ping_streams_error_msg(${::curr_test_no}) ""
			set catch_resp1 [catch "sts::ping_sts_test" catch_msg1]
			if {$catch_resp1 != 0} {
				# failed
				UTF::Message INFO "" "catch_resp=$catch_resp1 catch_msg=$catch_msg1"
				if {$retry_cnt < 3} {
					UTF::Sleep 5
					UTF::Message INFO "" "--------------------------------Retry $retry_cnt--------------------------------------"
					continue
				}
				
				if {$rvr_flag == 1} {
					error "html: <font color=\"red\"><b>$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) ping failed</b></font>"
				}

				UTF::Message INFO "" "---------------------------Debug dump for GC Status-------------------------------------------"
				set catch_resp [catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) status} catch_msg]
				UTF::Message INFO "" "----------------------------------------------------------------------"

				set ping_error $catch_msg1
			}
		}

		if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "NANDP"} {
			set link_chan [lindex "$::array_streams_sts_link_chan(${::curr_test_no})" 0]
		} else {
			set link_chan $::array_streams_sts_link_chan(${::curr_test_no})
		}
		
		set link_type $::array_streams_link_type(${::curr_test_no},${::curr_stream_no})
		regsub -all {NANDP} $link_type "NAN" link_type

		# Confirm chanspec
		# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
		for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
			set temp [$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) chanspec]
			regexp {(\S+) } $temp match slave_chan
			UTF::Message INFO "" "link_chan ='$link_chan' slave_chan ='$slave_chan'"
			if {$link_chan == $slave_chan} {
				break
			} elseif {($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "AWDL" && $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "NANDP")} {
				break
			} else {
				UTF::Message INFO "" "$link_type chan is $slave_chan instead of $link_chan. Retry $retry_cnt"
			}
		}

		if {$link_chan != $slave_chan} {
			if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "NANDP"} {
				###########################
				# for debugging:
				$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scan
				UTF::Sleep 7
				$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scanresults
				$sta_name scan
				UTF::Sleep 7
				$sta_name scanresults
				###########################	
			}
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "$link_type chan is $slave_chan instead of $link_chan"
		}

		if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
			if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) security is not supported on Mac OS. $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Open Security is used instead."
				append temp "&nbsp;&nbsp;<blink><font color=\"red\"><b>Open Security</b></font></blink>"
			} else {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) security is $::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) on Linux OS"
				append temp "&nbsp;&nbsp;<font color=\"blue\"><b>$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) Security</b></font>"
			}
		}
		
		# current_time
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

		UTF::Message INFO "" "-----------------------------Set STA status $current_time------------------------------------------"

		set ::array_sta_sts_active_flag(${sta_name}) 1
		set ::array_sta_sts_disassociated_flag(${sta_name}) 0
		UTF::Message INFO "" "apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_name})"
		UTF::Message INFO "" "sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_name})"

		if {$p2p_associated_flag == 0} {
			error "html: <font color=\"red\"><b>Forced scan after 30 sec to associate</b></font>"
		}

		if {$ping_error != ""} {
			error "html: <font color=\"red\"><b>$ping_error</b></font>"
		}

		regsub -all {NANDP} $temp "NAN" temp

		return "html: $temp"
	}
}

proc sts::setup_ap_radio_channel {ap ap_chan} {
	# access option array
	upvar {} {}

	# check for 2g:5g param
	set AP [split $ap ":"]
	set AP2G [lindex $AP 0]
	set AP5G [lindex $AP end]
	UTF::Message LOG "" "AP2G=$AP2G" 		
	UTF::Message LOG "" "AP5G=$AP5G"		

	# ::array_streams_ap(${::curr_test_no}) is changed from '2g:5g' to '2g' or '5g' depending on ap channel
	set ::array_streams_ap(${::curr_test_no}) $AP2G

	set ap_controller $::array_streams_ap_controller(${::curr_test_no})
	
	if {$::array_sta_softap_flag($ap_controller) == 0} {
		#---------------------------------------------------
		#----------------    5G or 2.4G AP    --------------
		#---------------------------------------------------
		if {[$AP2G band $::array_streams_apsta_link_chan(${::curr_test_no})] eq "b"} {
			set ::array_streams_ap(${::curr_test_no}) $AP2G
		} else {
			set ::array_streams_ap(${::curr_test_no}) $AP5G
		}

		set title "$::array_streams_ap(${::curr_test_no}): Setup AP Channel $::array_streams_apsta_link_chan(${::curr_test_no})"
	} else {
		set title "$::array_streams_ap(${::curr_test_no}): Setup SoftAP Channel $::array_streams_apsta_link_chan(${::curr_test_no})"
	}
	
	UTF::Try "$title" {
									   
		UTF::Message INFO "" "************************Func:setup_ap_radio_channel***************************"

		UTF::Message LOG "" "::array_streams_ap(${::curr_test_no})='$::array_streams_ap(${::curr_test_no})' ::array_streams_apsta_link_chan(${::curr_test_no})='$::array_streams_apsta_link_chan(${::curr_test_no})'"

		if {$::array_sta_softap_flag($ap_controller) == 0} {
	
			UTF::Message INFO "" "=============================================================================="
			UTF::Message INFO "" "=============================Real AP Radio Setup=============================="
			UTF::Message INFO "" "=============================================================================="
			
			if {$AP2G == $AP5G} {
				UTF::Message INFO "" "AP has only 1 radio"
				set ap_wlname "0"
			} else {
				UTF::Message INFO "" "AP has 2 radio"
				# Get the correct wlN prefix for the Src AP
				set ap_wlname [$::array_streams_ap(${::curr_test_no}) wlname]
				regsub -all {[a-zA-Z]} $ap_wlname "" ap_wlname
			}

			UTF::Message INFO "" "ap_wlname=$ap_wlname"

			#####################################################
			# Turn off all AP radios
			#####################################################

			catch {$::array_streams_ap(${::curr_test_no}) nvram set wl0_radio=0}
			catch {$::array_streams_ap(${::curr_test_no}) nvram set wl1_radio=0}

			#####################################################
			# Turn on the correct AP radio
			#####################################################
			$::array_streams_ap(${::curr_test_no}) nvram set wl$ap_wlname\_radio=1

			$::array_streams_ap(${::curr_test_no}) nvram commit
			UTF::Sleep 1
			$::array_streams_ap(${::curr_test_no}) restart
			UTF::Sleep 5
			
			UTF::Message INFO "" "=============================================================================="
		}

		if {$ap == $(ap)} {				
			set ::roaming_src_ap $::array_streams_ap(${::curr_test_no})
		} else {
			set ::roaming_dst_ap $::array_streams_ap(${::curr_test_no})
		}

		UTF::Message INFO "" "=============================================================================="
		UTF::Message INFO "" "==============================AP Channel Setup================================"
		UTF::Message INFO "" "=============================================================================="
		
		# With CSA, when we switch channels on the AP we can do so using a channel switch announcement.  
		# This is faster on the AP side, as it doesn’t need a down/up, and faster on the STA side since 
		# the STA gets told when to switch instead of having to roam scan.
		UTF::Test::APChanspec $::array_streams_ap(${::curr_test_no}) $::array_streams_apsta_link_chan(${::curr_test_no}) -usecsa 1
		UTF::Sleep 5

		UTF::Message INFO "" "--------------------------------------------------------"

		# Confirm AP chanspec
		set temp [$::array_streams_ap(${::curr_test_no}) wl chanspec]
		regexp {(\S+) } $temp match ap_chan
		
		if {$::array_streams_apsta_link_chan(${::curr_test_no}) != $ap_chan} {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "AP chan is $ap_chan instead of $::array_streams_apsta_link_chan(${::curr_test_no})" 
		}		

		foreach sta_name $(sta) {
			if {$::array_sta_apsta_active_flag(${sta_name}) == 1 && $::array_sta_apsta_disassociated_flag(${sta_name}) == 0} {
				# Confirm STA chanspec
				set temp [$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) chanspec]
				regexp {(\S+) } $temp match joined_chan

				if {$::array_streams_apsta_link_chan(${::curr_test_no}) != $joined_chan} {
					incr ::error_cnt
					UTF::Message INFO "" "::error_cnt=$::error_cnt"
					error "joined AP chan is $joined_chan instead of $::array_streams_apsta_link_chan(${::curr_test_no})" 
				}
			}
		}

		return ""
	}

	# Open AP Security is already done after the AP load
	if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
		#---------------------------------------------------
		#--------------    Setup AP Security   -------------
		#---------------------------------------------------
		foreach AP $(ap) {
			sts::setup_ap_security $AP $::array_streams_link_security(${::curr_test_no},${::curr_stream_no})
		}
	}
}

proc sts::connection_test {} {
	# access option array
	upvar {} {}

	set ::err_msg ""
	
	UTF::Try "Connection Test $::curr_test_no" {
		UTF::Message INFO "" "************************Func:connection_test***************************"

		sts::setup_list_active_interface_objects

		UTF::Try "STAs Data" {
			set sta_cnt 0
			foreach sta_name $::array_streams_interface_possible_list(${::curr_test_no}) {

				if {![info exists ::array_sta_softap_flag(${sta_name})]} {
					continue
				}

				if {$::array_sta_softap_flag(${sta_name}) == 1} {
					continue
				}

				incr sta_cnt

				UTF::Try "STA $sta_cnt: $sta_name" {
					UTF::Message INFO "" "print STA sta=$sta_name data arrays"
					sts::array_setup_sta_data $sta_name 0 0 1
				}
			}
		}

		UTF::Message INFO "" "::controller                =	'$::controller'"           
		UTF::Message INFO "" "::curr_test_no              =	'$::curr_test_no'"         
		UTF::Message INFO "" "::curr_stream_no            =	'$::curr_stream_no'"       

		UTF::Try "Test $::curr_test_no Streams Data" {
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				UTF::Try "Stream $stream_no Data" {
					UTF::Message INFO "" "print stream $stream_no"
					sts::array_setup_stream_data $::curr_test_no $stream_no 0 0 1 0
				}
			}
		}

		UTF::Message INFO "" "===========================endpoint==========================="
		catch {$::array_streams_ap_controller(${::curr_test_no}) rexec ifconfig -a}

		UTF::Message INFO "" "============================================================================================================"
		
		foreach target $::array_streams_interface_possible_list(${::curr_test_no}) {

			if {![info exists ::array_sta_apsta_flag(${target})]} {
				UTF::Message INFO "" "Skip '$target'"
				continue
			}

			UTF::Message INFO "" "=========================================Interface STA=$target========================================="
			if {$::array_sta_apsta_flag(${target})} {
				UTF::Message INFO "" "---------------------APSTA $target---------------------"
			}
			if {$::array_sta_master_flag(${target})} {
				UTF::Message INFO "" "---------------------GO/Master $target---------------------"
			}
			if {$::array_sta_slave_flag(${target})} {
				UTF::Message INFO "" "---------------------GC/Slave $target---------------------"
			}
			catch {$target rexec ifconfig -a}

			set apsta_stream_no 0
			set sts_stream_no 0
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					# only BIRX needs to be processed
					continue
				}

				if {$target == $::array_streams_src_sta(${::curr_test_no},${stream_no}) || $target == $::array_streams_dst_sta(${::curr_test_no},${stream_no})} {
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
						# StS link
						set sts_stream_no $stream_no
						UTF::Message INFO "" "sts_stream_no=$sts_stream_no for $target is $::array_streams_link_type(${::curr_test_no},${stream_no})"
					} else {
						set apsta_stream_no $stream_no
						UTF::Message INFO "" "apsta_stream_no=$apsta_stream_no for $target is $::array_streams_link_type(${::curr_test_no},${stream_no})"
					}
				}
			}

			if {$sts_stream_no > 0} {
				set link_type $::array_streams_link_type(${::curr_test_no},${sts_stream_no})
				regsub -all {NANDP} $link_type "NAN" link_type_disp
				
				if {$link_type == "AWDL" && $::array_streams_src_host_type(${::curr_test_no},${sts_stream_no}) == "MacOS"} {
					set catch_resp [catch "$target rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					set catch_resp [catch "$target rexec ps -ef | grep \"dns-sd\"" catch_msg]					
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				}
			} else {
				set link_type $::array_streams_link_type(${::curr_test_no},${apsta_stream_no})
				set link_type_disp $link_type 
			}

			if {$link_type == "NANDP"} {
				set link_chan [lindex "$::array_streams_sts_link_chan(${::curr_test_no})" 0]
			} else {
				set link_chan $::array_streams_sts_link_chan(${::curr_test_no})
			}

			if {$::array_sta_apsta_flag(${target})} {
				UTF::Message INFO "" "----------------------------STA $target Check APSTA association----------------------------"
				set catch_resp [catch {$target wl -i $::array_sta_apsta_ifname(${target}) bssid} catch_msg]
				if {$catch_resp != 0 || [string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
					set ::array_sta_apsta_disassociated_flag(${target}) 1
					set msg "APSTA is NOT associated"
					UTF::Message ERROR "" "***Failed. $msg"
					if {[string first $msg $::err_msg] == -1} {
						append ::err_msg "($msg)"
					}
				} else {
					UTF::Message INFO "" "PASS. APSTA is associated"
					UTF::Message INFO "" "----------------------------STA $target Check APSTA channel----------------------------"
					set temp [$target wl -i $::array_sta_apsta_ifname(${target}) chanspec]
					regexp {(\S+) } $temp match joined_chan

					if {$::array_streams_apsta_link_chan(${::curr_test_no}) != $joined_chan} {
							set ::err_msg [concat $::err_msg "(STA $target joined AP chan is $joined_chan instead of $::array_streams_apsta_link_chan(${::curr_test_no}))"]
							UTF::Message ERROR "" "$::err_msg"
					} else {
						UTF::Message INFO "" "PASS. $::array_streams_dst_display_str(${::curr_test_no},${apsta_stream_no}) channel is $::array_streams_apsta_link_chan(${::curr_test_no})"
					}
				}
			}

			if {$::array_sta_sts_flag(${target})} {
				UTF::Message INFO "" "----------------------------STA $target Check $link_type_disp association----------------------------"
				set catch_resp [catch {$target wl -i $::array_sta_sts_ifname(${target}) bssid} catch_msg]
				if {$catch_resp != 0 || [string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
					set ::array_sta_sts_disassociated_flag(${target}) 1
					set msg "$link_type_disp is NOT associated"
					UTF::Message ERROR "" "***Failed. $msg"
					if {[string first $msg $::err_msg] == -1} {
						append ::err_msg "($msg)"
					}
				} else {
					UTF::Message INFO "" "PASS. $link_type_disp is associated"
					UTF::Message INFO "" "----------------------------STA $target Check $link_type_disp channel----------------------------"
					# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
					for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
						set temp [$target wl -i $::array_sta_sts_ifname(${target}) chanspec]
						regexp {(\S+) } $temp match slave_chan
						UTF::Message INFO "" "link_chan ='$link_chan' slave_chan ='$slave_chan'"
						if {$link_chan == $slave_chan} {
							break
						} elseif {($link_type != "AWDL" && $link_type != "NANDP")} {
							break
						} else {
							UTF::Message INFO "" "$link_type_disp chan is $slave_chan instead of $link_chan. Retry $retry_cnt"
						}
					}

					if {$link_chan != $slave_chan} {
						set ::err_msg [concat $::err_msg "($link_type_disp chan is $slave_chan instead of $link_chan)"]
						UTF::Message ERROR "" "$::err_msg"
					} else {
						UTF::Message INFO "" "PASS. $link_type_disp channel is $link_chan"
					}
				}
			}

			if {$::array_sta_apsta_flag(${target})} {
				UTF::Message INFO "" "=========================================================================="
				UTF::Message INFO "" "----------------------------STA $target Check APSTA----------------------------"
				$target wl -i $::array_sta_apsta_ifname(${target}) status
				if {$::array_sta_apsta_disassociated_flag(${target}) >= 1} {
					catch {
						$target wl -i $::array_sta_apsta_ifname(${target}) scan
						UTF::Sleep 7
						$target wl -i $::array_sta_apsta_ifname(${target}) scanresults
					}
				}
			}

			if {$::array_sta_sts_flag(${target})} {
				UTF::Message INFO "" "----------------------------STA $target Check $link_type_disp----------------------------"
				# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
				for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
					set catch_resp [catch {$target wl -i $::array_sta_sts_ifname(${target}) status} catch_msg]
					if {$::array_sta_sts_disassociated_flag(${target}) != 0} {
						break
					}
					regexp {Channel: (\S+)} $catch_msg match slave_chan
					UTF::Message INFO "" "link_chan ='$link_chan' slave_chan ='$slave_chan'"
					if {$link_chan == $slave_chan} {
						break
					} elseif {($link_type != "AWDL" && $link_type != "NANDP")} {
						break
					} else {
						UTF::Message INFO "" "$link_type_disp chan is $slave_chan instead of $link_chan. Retry $retry_cnt"
					}
				}
				# For AWDL, scan is not valid
				if {$link_type != "AWDL" && $::array_sta_sts_disassociated_flag(${target}) >= 1} {
					catch {
						$target wl -i $::array_sta_sts_ifname(${target}) scan
						UTF::Sleep 7
						$target wl -i $::array_sta_sts_ifname(${target}) scanresults
					}
				}
			}
			
			UTF::Message INFO "" "=========================================================================="
			UTF::Message INFO "" "----------------------------STA $target Check ifconfig----------------------------"
			if {$::array_sta_apsta_flag(${target})} {
				catch {$target rexec ifconfig $::array_sta_apsta_ifname(${target})}
				UTF::Sleep 1
			}
			if {$::array_sta_sts_flag(${target})} {
				catch {$target rexec ifconfig $::array_sta_sts_ifname(${target})}
				UTF::Sleep 1
			}
		}

		UTF::Message INFO "" "============================================================================================================"
		UTF::Message INFO "" "----------------------------Check ping----------------------------"
		
		set catch_msg ""
		set catch_resp [catch "sts::ping_test" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_msg != ""} {
			if {$::err_msg == ""} {
				set ::err_msg "$catch_msg"
			} else {
				set ::err_msg [concat $::err_msg "$catch_msg"]
			}
			UTF::Message ERROR "" "$::err_msg"
		}

		UTF::Try "Test $::curr_test_no Ping Streams Data" {
			for {set stream_no 1} {$stream_no <= $::array_ping_streams_cnt(${::curr_test_no})} {incr stream_no} {
				UTF::Try "Ping Stream $stream_no Data: $::array_ping_streams_stream_short_label(${::curr_test_no},${stream_no})" {
					UTF::Message INFO "" "print ping stream $stream_no"
					sts::array_setup_ping_stream_data $::curr_test_no $stream_no 0 0 1
				}
			}
		}
		
		if {$::err_msg == ""} {
			return ""
		} else {
			error "html: <font color=\"red\"><b>$::err_msg</b></font>"
		}
	}
}

proc sts::channel_sweep_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:channel_sweep_test***************************"

	set AP $::array_streams_ap(${::curr_test_no})
	set STA $::array_streams_dst_sta(${::curr_test_no},${::curr_stream_no})
	
	# default to finding chanspecs AP and STA have in common
	set allchanspecs [UTF::Common [$AP allchanspecs] [$STA allchanspecs]]

	UTF::Message INFO $AP "Available channels: $allchanspecs"

	# Partition into bands and bandwidths for convenient reporting
	foreach chanspec $allchanspecs {
		if {[regexp {^(\d+)(/?\w*)} $chanspec - c sb]} {
			if {$c > 15} {
				set band "5g"
			} else {
				set band "2g"
			}
			if {[regexp {/160} $sb]} {
				set bw "160"
			} elseif {[regexp {/80} $sb]} {
				set bw "80"
			} elseif {$sb eq ""} {
				set bw "20"
			} else {
				set bw "40"
			}
			
			# $bw/$chanspec is added to the list in order to be able to sort the chanspec in proper order 
			lappend array_chan_groups($band$bw) [list $bw/$chanspec $chanspec]
		} else {
			error "bad chanspec $chanspec"
		}
	}

	set chan_groups_list [lsort [array names array_chan_groups]]
	UTF::Message INFO "" "chan_groups_list=$chan_groups_list"

	foreach chan_group $chan_groups_list {
		set chanfail {}
		
		UTF::Try "$STA: P2P Channel Sweep $chan_group" {

			# sort by $bw/$chanspec
			set chanspecs_list [lsort -dictionary -index 0 $array_chan_groups($chan_group)]

			set chanspecs ""
			foreach item $chanspecs_list {
				lappend chanspecs [lindex $item 1]
			}
			UTF::Message INFO $AP "Testing $chanspecs"
			
			foreach ap_chan $chanspecs {
				UTF::Try "$STA: Chanspec $ap_chan" {
					set ::array_streams_apsta_link_chan(${::curr_test_no}) $ap_chan
					# 11h (11d) adds the relevant fields to the AP's beacons, etc to enable CSA
					UTF::Test::APChanspec $AP $::array_streams_apsta_link_chan(${::curr_test_no}) -use11h 0
					UTF::Sleep 4
					
					UTF::Message INFO "" "=========================================================================="
					UTF::Message INFO "" "----------------------------Check ping----------------------------"
					set catch_resp [catch "sts::ping_test" catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp != 0} {
						error "html: <font color=\"red\"><b>$catch_msg</b></font>"
					} else {
						return "html: <font color=\"blue\"><b>$catch_msg</b></font>"
					}
				}
			}
		}
		break
	}
}

proc sts::start_pre_throughputs {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:start_pre_throughputs***************************"

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	set apsta_disassociated_flag 0
	set sts_disassociated_flag 0
	foreach sta_name $(sta) {
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA is active"
		}
		if {$::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
			set apsta_disassociated_flag 1
			UTF::Message INFO "" "$sta_name APSTA is disassociated"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is active"
		}
		if {$::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
			set sts_disassociated_flag 1
			UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is disassociated"
		}
	}

	UTF::Message INFO "" "apsta_active_flag=$active_sta_apsta_flag apsta_disassociated_flag=$apsta_disassociated_flag"
	UTF::Message INFO "" "sts_active_flag=$active_sta_sts_flag sts_disassociated_flag=$sts_disassociated_flag"

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			UTF::Message INFO "" "stream_no='$stream_no'. Skipping BT"
			continue
		}

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA" && $active_sta_apsta_flag == 1 && $apsta_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
			UTF::Message INFO "" "APSTA is disassociated. Skip running iperf."
			continue
		}

		if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1  && $active_sta_sts_flag == 1 && $sts_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
			UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${stream_no}) is disassociated. Skip running iperf."
			continue
		}

		if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
			continue
		}

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
			set items_list "$::array_streams_dst_sta(${::curr_test_no},${stream_no}) $::array_streams_dst_ifname(${::curr_test_no},${stream_no})"
		} else {
			set items_list "$::array_streams_src_sta(${::curr_test_no},${stream_no}) $::array_streams_src_ifname(${::curr_test_no},${stream_no}) $::array_streams_dst_sta(${::curr_test_no},${stream_no}) $::array_streams_dst_ifname(${::curr_test_no},${stream_no})"
		}

		set link_type $::array_streams_link_type(${::curr_test_no},${stream_no})
		
		if {($link_type != "AWDL" && $link_type != "NANDP")} {
		
			UTF::Message INFO "" "************************Check for $link_type PM $(pm_mode)***************************"
		
			foreach {STA ifname} $items_list {
				UTF::Message INFO "" "************************STA=$STA***************************"
				set catch_resp [catch {$STA wl -i $ifname PM} catch_msg]
				if {$(pm_mode) != "" && $catch_msg != $(pm_mode)} {
					set msg "$link_type PM mode is $catch_msg instead of $(pm_mode)"
					UTF::Message ERROR "" "***Failed. $msg."
					if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
						append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
					}
				}

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "J" "::UTF::panic=$::panic_msg"
					set ::halt_test_err $::panic_msg
					incr ::error_cnt
					error "$::panic_msg. Halting tests!"
				} elseif {[regexp -nocase {driver adapter not found} $catch_msg] || [regexp -nocase {is not a valid wl driver} $catch_msg]} {
					incr ::error_cnt
					UTF::Message INFO "" "***Fail. Driver is crashed. Do not continue the test."
					set ::halt_test_err $catch_msg
					# set flag to dump socram and FW
					set ::socram_dump_flag 1
					error "$catch_msg. Halting tests!"
				}				
			}
		}

		set sta_src 					$::array_streams_src_sta(${::curr_test_no},${stream_no}) 
		set sta_dst 					$::array_streams_dst_sta(${::curr_test_no},${stream_no})
		set sta_dst_ipaddr 				$::array_streams_dst_ip(${::curr_test_no},${stream_no}) 
		set stream_link_type 			$::array_streams_link_type(${::curr_test_no},${stream_no})
		set stream_traffic_type 		$::array_streams_traffic_type(${::curr_test_no},${stream_no})
		set stream_traffic_priority 	$::array_streams_traffic_priority(${::curr_test_no},${stream_no})
		set stream_iperf_tos			$::array_streams_iperf_tos(${::curr_test_no},${stream_no})
		set stream_iperf_scale 			$::array_streams_throughput_scale(${::curr_test_no},${stream_no})
		set src_tcpwin					$::array_streams_src_tcpwin(${::curr_test_no},${stream_no})
		set src_host_type				$::array_streams_src_host_type(${::curr_test_no},${stream_no})

		if {[lsearch -exact $::sts_link_types $stream_link_type] != -1} {
			# StS link
			UTF::Message INFO "" "$::array_streams_src(${::curr_test_no},${stream_no}) $stream_link_type $::array_streams_traffic_direction(${::curr_test_no},${stream_no}):"
		} else {
			UTF::Message INFO "" "$sta_src $stream_link_type $::array_streams_traffic_direction(${::curr_test_no},${stream_no}):"
		}

		set iperf_name $::array_sta_iperf_name(${sta_src})
		set iperf_ver $::array_sta_iperf_ver(${sta_src})
		if {$iperf_ver == "2.0.5"} {
			if {$src_host_type == "MacOS" && $stream_link_type == "AWDL"} {
				set new_iperf_param "-V -A" 
			} else {
				set new_iperf_param "" 
			}
		} else {
			set new_iperf_param "-e" 
		}
		
		# "-t 2" is needed because there is TCP slow start with P2P throughput with APCh=36/80 P2PCh=11u
		# "-b 400M" is picked to flood the port to avoid slow start. Doing Video test at 20M is not good enough to flood the port

		set common_params "-f$stream_iperf_scale -w $src_tcpwin -i $::perfint -S $stream_iperf_tos -t 2 -p $::curr_iperf_port"

		if {$src_host_type == "MacOS"} {
			set addr_params "$new_iperf_param -c $::array_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no})"
		} else {
			set addr_params "$new_iperf_param -c $sta_dst_ipaddr"
		}

		if {$stream_traffic_type == "TCP"} {
			set traffic_type_params "-l 8k"
		} else {
			set traffic_type_params "-u -b 400M"
		}

		set iperf_params "$addr_params $traffic_type_params $common_params"
		# trim
		set iperf_params [regexp -all -inline {\S+} $iperf_params]

		# Start iperf as background task
		set ::array_streams_fd_tx(${::curr_test_no},${stream_no}) [$sta_src rpopen $iperf_name $iperf_params]

		fconfigure $::array_streams_fd_tx(${::curr_test_no},${stream_no}) -blocking 0
		fileevent $::array_streams_fd_tx(${::curr_test_no},${stream_no}) readable {set ::p2p_utils_reading READY}
		
		incr ::curr_iperf_port
	}

	set stream_ids [sts::get_stream_ids]
	
	if {$stream_ids != ""} {
		# using 5 sec timeout. If data is ready sooner, then it will not wait this long and comes back immediately
		sts::collect_rpopen_data 5 $stream_ids resp1 "" resp2

		sts::close_iperf_traffic
	}
}

proc sts::get_stream_ids {} {

	set stream_ids ""
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		catch {append stream_ids "$::array_streams_fdname_tx(${::curr_test_no},${stream_no}) $::array_streams_fd_tx(${::curr_test_no},${stream_no}) $::array_streams_fdname_rx(${::curr_test_no},${stream_no}) $::array_streams_fd_rx(${::curr_test_no},${stream_no}) "}
	}
	
	set stream_ids [string trim $stream_ids]

	return $stream_ids
}

proc sts::start_all_client_streams {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:start_all_client_streams***************************"

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	set apsta_disassociated_flag 0
	set sts_disassociated_flag 0
	foreach sta_name $(sta) {
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA is active"
		}
		if {$::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
			set apsta_disassociated_flag 1
			UTF::Message INFO "" "$sta_name APSTA is disassociated"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is active"
		}
		if {$::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
			set sts_disassociated_flag 1
			UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is disassociated"
		}
	}

	UTF::Message INFO "" "apsta_active_flag=$active_sta_apsta_flag apsta_disassociated_flag=$apsta_disassociated_flag"
	UTF::Message INFO "" "sts_active_flag=$active_sta_sts_flag sts_disassociated_flag=$sts_disassociated_flag"

	if {$::bt_test_flag} {
		#####################################################
		##########   Start BT iTune wav Play    #############
		#####################################################
		sts::bt_itune_play
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}
	}

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		#####################################################
		##########     Run Stream Throughput    #############
		#####################################################
		UTF::Message INFO "" "************************************************throughput stream_no=$stream_no***************************************************"

		set ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) ""

		UTF::Message INFO "" "::array_streams_link_type(${::curr_test_no},${stream_no})=$::array_streams_link_type(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_traffic_direction(${::curr_test_no},${stream_no})=$::array_streams_traffic_direction(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_traffic_priority(${::curr_test_no},${stream_no})=$::array_streams_traffic_priority(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_start_time(${::curr_test_no},${stream_no})=$::array_streams_start_time(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_end_time(${::curr_test_no},${stream_no})=$::array_streams_end_time(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_sta(${::curr_test_no},${stream_no})=$::array_streams_src_sta(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_host_type(${::curr_test_no},${stream_no})=$::array_streams_src_host_type(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_ifname(${::curr_test_no},${stream_no})=$::array_streams_src_ifname(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_ip(${::curr_test_no},${stream_no})=$::array_streams_src_ip(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_ipv6_macaddr(${::curr_test_no},${stream_no})=$::array_streams_src_ipv6_macaddr(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_dst_sta(${::curr_test_no},${stream_no})=$::array_streams_dst_sta(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_dst_host_type(${::curr_test_no},${stream_no})=$::array_streams_dst_host_type(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_dst_ifname(${::curr_test_no},${stream_no})=$::array_streams_dst_ifname(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_dst_ip(${::curr_test_no},${stream_no})=$::array_streams_dst_ip(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no})=$::array_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no})"		
		UTF::Message INFO "" "::array_streams_iperf_tos(${::curr_test_no},${stream_no})=$::array_streams_iperf_tos(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_throughput_scale(${::curr_test_no},${stream_no})=$::array_streams_throughput_scale(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_packet_size(${::curr_test_no},${stream_no})=$::array_streams_packet_size(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_bandwidth(${::curr_test_no},${stream_no})=$::array_streams_bandwidth(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_src_tcpwin(${::curr_test_no},${stream_no})=$::array_streams_src_tcpwin(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_file_name(${::curr_test_no},${stream_no})='$::array_streams_file_name(${::curr_test_no},${stream_no})'"
		UTF::Message INFO "" "::array_streams_plot_name_lt(${::curr_test_no},${stream_no})='$::array_streams_plot_name_lt(${::curr_test_no},${stream_no})'"
		UTF::Message INFO "" "::array_streams_plot_name_pt(${::curr_test_no},${stream_no})='$::array_streams_plot_name_pt(${::curr_test_no},${stream_no})'"
		UTF::Message INFO "" "::array_streams_plot_minmax_name_lt(${::curr_test_no},${stream_no})='$::array_streams_plot_minmax_name_lt(${::curr_test_no},${stream_no})'"
		UTF::Message INFO "" "================================================================"

		if {!$(no_wl_dump) && $::array_streams_cnt(${::curr_test_no}) == 1 && $::pktq_stats_flag == 1} {
			UTF::Message INFO "" "************************QoS pktq_stats (reset values before running first stream)***************************"
			foreach STA "$::array_streams_interface_active_list(${::curr_test_no})" {
				catch {$STA wl pktq_stats}
			}
		}
		UTF::Message INFO "" "****************************************************************"				

		# delay before starting stream?
		if {$::array_streams_cnt(${::curr_test_no}) == 1 && $::array_streams_start_time(${::curr_test_no},${stream_no}) > 0} {
			# this is the 1st stream delay
			set delay_stream_secs $::array_streams_start_time(${::curr_test_no},${stream_no})		
			UTF::Message INFO "" "stream delay=$::array_streams_start_time(${::curr_test_no},${stream_no})"
			UTF::Sleep $delay_stream_secs		
		} elseif {$::array_streams_cnt(${::curr_test_no}) > 1 && $::array_streams_start_time(${::curr_test_no},${stream_no}) > 0} {
			# this is not the 1st stream delay.
			# delay is from the 1st stream. subtract time past since 1st stream.

			# find the first stream time
			set first_stream_name $::array_streams_stream_label(${::curr_test_no},1)
			UTF::Message INFO "" "first_stream_name=$first_stream_name"
			set first_stream_time_secs $::array_streams_start_stream_time_secs(${::curr_test_no},1)
			UTF::Message INFO "" "first_stream_time_secs=$first_stream_time_secs"

			set curr_time_secs [clock clicks -milliseconds]
			set curr_time_secs [format "%2.3f" [expr {$curr_time_secs / 1000.0}]]
			set time_elapsed_secs [expr {$curr_time_secs - $first_stream_time_secs}]
			UTF::Message INFO "" "curr_time_secs - first_stream_time_secs=time_elapsed_secs =>> $curr_time_secs - $first_stream_time_secs=$time_elapsed_secs"
			set delay_stream_secs [expr {$::array_streams_start_time(${::curr_test_no},${stream_no}) - $time_elapsed_secs}]
			set delay_stream_secs [format "%2.3f" $delay_stream_secs]
			UTF::Message INFO "" "::array_streams_start_time(${::curr_test_no},${stream_no}) - time_elapsed_secs=delay_stream_secs =>> $::array_streams_start_time(${::curr_test_no},${stream_no}) - $time_elapsed_secs=$delay_stream_secs"
			UTF::Message INFO "" "actual stream delay=$delay_stream_secs"
			UTF::Sleep $delay_stream_secs		
		}

		# how long all streams will run?
		if {[expr {$::array_streams_start_time(${::curr_test_no},${stream_no}) + $::array_streams_end_time(${::curr_test_no},${stream_no})}] > $::streams_total_time} {
			UTF::Message INFO "" "::array_streams_start_time(${::curr_test_no},${stream_no}) + ::array_streams_end_time(${::curr_test_no},${stream_no}) > ::streams_total_time"
			UTF::Message INFO "" "$::array_streams_start_time(${::curr_test_no},${stream_no}) + $::array_streams_end_time(${::curr_test_no},${stream_no}) > $::streams_total_time"
			set ::streams_total_time [expr {$::array_streams_start_time(${::curr_test_no},${stream_no}) + $::array_streams_end_time(${::curr_test_no},${stream_no})}]
			UTF::Message INFO "" "streams_total_time=$::streams_total_time"
		} else {
			UTF::Message INFO "" "::array_streams_start_time(${::curr_test_no},${stream_no}) + ::array_streams_end_time(${::curr_test_no},${stream_no}) <= ::streams_total_time"
			UTF::Message INFO "" "$::array_streams_start_time(${::curr_test_no},${stream_no}) + $::array_streams_end_time(${::curr_test_no},${stream_no}) <= $::streams_total_time"
		}

		UTF::Message INFO "" "Start the iperf"

		# Timestamp of the current stream iperf starting is put here because of "disconnect" and stream getting
		# skipped still needs a timestamp
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
		set current_time "$current_time.$fraction"
		UTF::Message INFO "" "timestamp1=$current_time"
		set ::array_streams_start_stream_time_secs(${::curr_test_no},${stream_no}) "$time_ms"
		UTF::Message INFO "" "::array_streams_start_stream_time_secs(${::curr_test_no},${stream_no})=$::array_streams_start_stream_time_secs(${::curr_test_no},${stream_no})"

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA" && $active_sta_apsta_flag == 1 && $apsta_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
			UTF::Message INFO "" "Skip APSTA iperf since it is disassociated"
			continue
		}

		if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1 && $active_sta_sts_flag == 1 && $sts_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
			UTF::Message INFO "" "Skip $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) iperf since it is disassociated"
			continue
		}

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			sts::bt_start_throughput_measurement $::array_streams_src_sta(${::curr_test_no},${stream_no}) $stream_no $::array_streams_end_time(${::curr_test_no},${stream_no})
		} else {		
			set catch_resp [catch {sts::start_traffic $stream_no} catch_msg]
			if {$catch_resp != 0} {
				UTF::Message INFO "" "***Failed. catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
			}
		}
	}
	
	if {$::error_cnt > 0} {

		UTF::Message INFO "" "start_all_client_streams failed"

		UTF::Message INFO "" "************************post_perf_hook***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		sts::process_perf_hook post_perf_hook 0 0

		error "Start iperf clients failed"							
	} elseif {!$(no_wl_dump)} {
		set ::iperf_running_flag 1
		
		UTF::Message LOG "" "init the beacon rate vars"

		foreach STA "$::array_streams_interface_active_list(${::curr_test_no})" {

			foreach sta_name $(sta) {
				if {[string compare $STA $sta_name] == 0} {
					set str_interface "$::array_sta_apsta_ifname(${sta_name})"
					break
				} elseif {[string compare $STA $::array_sta_sts(${sta_name})] == 0} {
					set str_interface "$::array_sta_sts_ifname(${sta_name})"
					break
				}
			}

			set catch_resp [catch {$STA wl -i $str_interface counters} catch_msg]
			if {$catch_resp == 0} {
				set bcnrate ""
				regexp {rxbeaconmbss\s([0-9]+)} $catch_msg - bcnrate
				if {$bcnrate != ""} {
					set time_ms [clock clicks -milliseconds]
					set ::array_streams_last_BeaconRate_time(${STA}) $time_ms
					set ::array_streams_last_BeaconRate(${STA}) $bcnrate
					UTF::Message INFO "" "Time -> '$::array_streams_last_BeaconRate_time(${STA})=$::array_streams_last_BeaconRate_time(${STA}) ms'"
					UTF::Message INFO "" "Beacons -> '$::array_streams_last_BeaconRate(${STA})=$::array_streams_last_BeaconRate(${STA})'"
				} else {
					UTF::Message LOG "" "Error: bcnrate is not found in '$catch_msg'. Continue"
				}
			}
		}
	}
}

proc sts::remove_duplicates {items_list} {

	set items_list [string trim $items_list]
	regsub -all { {2,}} $items_list { } items_list 

	while { 1 } {
	
		set repeat_flag 0

		# check for duplicates
		foreach item $items_list {

			set idxs [lsearch -exact -all $items_list $item]
			
			if {[llength $idxs] > 1} {
				UTF::Message INFO "" "Found duplicate item for '$item'"
				# remove the 1st duplicate item
				set idx [lindex $idxs 0]
				set items_list [lreplace $items_list $idx $idx ""]	
				# remove empty element
				regsub -all {\{\}} $items_list "" items_list
				regsub -all { {2,}} $items_list { } items_list 
				set items_list [string trim $items_list]
				set repeat_flag 1
			}
		}
		
		if {$repeat_flag == 0} {
			break
		}
	}

	return $items_list
}

proc sts::perf_hook_remove_duplicates {items} {

	if {$::roaming_test_flag || $::scan_test_flag || $::escan_test_flag} {
		# Do not use scansuppress for Roaming test or the Scan/eScan test
		UTF::Message INFO "" "Do not use scansuppress"
		regsub -all -nocase {\{\s*\S+\s+wl\s+scansuppress\s+1\s*\}} $items "" items
	}

	set ret_items [sts::remove_duplicates $items]
				
	return $ret_items
}

proc sts::setup_perf_hook {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_perf_hook***************************"

#kevin
#	if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "APSTA" && $::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS" && $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "AWDL"} {
#		# skip for AWDL OSX
#		return
#	}
	
	set test_pre_perf_sta "{%S wl ampdu_clear_dump}"
	set test_pre_perf_ap "{%S wl ampdu_clear_dump}"
	set test_post_perf_sta "{%S wl dump ampdu} {%S wl rate} {%S wl assoc} {%S wl rssi} {%S wl nrate} {%S wl counters}"
	if {$::roaming_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl bssid}"]
	} else {
		set test_pre_perf_sta [concat $test_pre_perf_sta " {%S wl roam_trigger -100 all}"]
	}
	if {$::scan_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl scan}"]
	}
	if {$::escan_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl wl_escanresults}"]
	}
	set test_post_perf_ap "{%S wl dump ampdu} {%S wl sta_info} {%S wl rate} {%S wl rssi} {%S wl nrate} {%S wl counters}"

	# add the above test script pre and post commands to the beginning of config pre_perf_hook and post_perf_hook

	UTF::Message INFO "" "-----AP PRE------"
	foreach item $(ap) {
		# check for 2g:5g param
		set item [split $item ":"]
		set item [lindex $item 0]

		set value [$item cget -pre_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item pre_perf_hook='$value'"

		set value [concat $test_pre_perf_ap $value]
		set value [sts::perf_hook_remove_duplicates $value]
		$item configure -pre_perf_hook $value
		
		set value [$item cget -pre_perf_hook]
		UTF::Message INFO "" "After:  $item pre_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----STA PRE------"
	foreach item "$::array_streams_interface_existing_list(${::curr_test_no})" {

		# skip invalid interfaces
		if {[info exists ::array_sta_sta_flag(${item})]} {
			# skip the AP/SoftAP interfaces
			if {$::array_sta_sta_flag(${item}) != 1} {
				#UTF::Message INFO "" "$item is not an STA. Skip."
				continue
			}
		}

		set value [$item cget -pre_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item pre_perf_hook='$value'"

		set value [concat $test_pre_perf_sta $value]
		set value [sts::perf_hook_remove_duplicates $value]
		$item configure -pre_perf_hook $value
		
		set value [$item cget -pre_perf_hook]
		UTF::Message INFO "" "After:  $item pre_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----AP POST------"
	foreach item $(ap) {
		# check for 2g:5g param
		set item [split $item ":"]
		set item [lindex $item 0]

		set value [$item cget -post_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item post_perf_hook='$value'"

		set value [concat $test_post_perf_ap $value]
		set value [sts::perf_hook_remove_duplicates $value]
		$item configure -post_perf_hook $value
		
		set value [$item cget -post_perf_hook]
		UTF::Message INFO "" "After:  $item post_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----STA POST------"
	foreach item "$::array_streams_interface_existing_list(${::curr_test_no})" {

		# skip invalid interfaces
		if {[info exists ::array_sta_sta_flag(${item})]} {
			# skip the AP/SoftAP interfaces
			if {$::array_sta_sta_flag(${item}) != 1} {
				#UTF::Message INFO "" "$item is not an STA. Skip."
				continue
			}
		}

		set value [$item cget -post_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item post_perf_hook='$value'"
		
		set value [concat $test_post_perf_sta $value]
		set value [sts::perf_hook_remove_duplicates $value]
		$item configure -post_perf_hook $value
		
		set value [$item cget -post_perf_hook]
		UTF::Message INFO "" "After:  $item post_perf_hook='$value'"
	}
}

proc sts::parse_nrate {msg} {

	set nrate ""
	set nss ""
	set legacy_rate ""

	# samples:
	# mcs index 1 stf mode 0 fixed
	# vht mcs 9 Nss 3 Tx Exp 0 ldpc sgi auto

	if {[regexp {mcs\s*index\s*(\d+)} $msg - nrate]} {
		UTF::Message INFO "" "mcs nrate = $nrate"
	} elseif {[regexp {legacy\s*rate\s*(\d+)} $msg - nrate]} {
		UTF::Message INFO "" "legacy rate = $nrate"
    	set nrate "legacy $nrate"
    } elseif {[regexp -nocase {vht\s*mcs\s*(\d+)\s*Nss\s*(\d+)} $msg - nrate nss]} {
    	set nrate "$nss\x$nrate"
		UTF::Message INFO "" "vht rate = $nrate"
	}
	
	# put braket around the value otherwise "0x3" will become "3"
	set nrate "\[$nrate\]"
	
	return $nrate
}

proc sts::graph_map_nrate {msg} {

	set new_nrate ""
	set nrate ""
	set nss ""

	# remove the brakets around the nrate value
	regsub -all {\[} $msg "" msg
	regsub -all {\]} $msg "" msg
	
	if {[regexp -nocase {(\d+)x(\d+)} $msg - nss nrate]} {
		# vht rate
		set new_nrate [expr {[expr {[expr {$nss - 1}] * 10}] + $nrate + 24}]
		UTF::Message INFO "" "vht nrate $nss\x$nrate -> $new_nrate"
	} elseif {[regexp {legacy (\d+)} $msg - legacy_rate]} {

		switch $legacy_rate {

			54 {
				set new_nrate "-1"
			}

			48 {
				set new_nrate "-2"
			}

			36 {
				set new_nrate "-3"
			}

			24 {
				set new_nrate "-4"
			}

			18 {
				set new_nrate "-5"
			}

			12 {
				set new_nrate "-6"
			}

			11 {
				set new_nrate "-7"
			}

			9 {
				set new_nrate "-8"
			}

			6 {
				set new_nrate "-9"
			}

			5.5 {
				set new_nrate "-10"
			}

			2 {
				set new_nrate "-11"
			}

			1 {
				set new_nrate "-12"
			}
		}

		# legacy rate
		UTF::Message INFO "" "legacy rate $legacy_rate -> $new_nrate"

    } else {
		set new_nrate $msg
		UTF::Message INFO "" "rate $msg -> $new_nrate"
	}

	return $new_nrate
}

proc sts::process_perf_hook {perf_hook throughput_flag write_flag} {
	# access option array
	upvar {} {}

	if {$perf_hook == "pre_perf_hook"} {

		if {$::rvr_test_flag == 0} {
			set ::saved_hook_start_timestamp ""
			UTF::Message INFO "" "Cleared ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"
		}
		
		###################################################################
		# Initialize CSV Throughput Variables
		###################################################################
		sts::array_init_csv_data 0 1

	} elseif {$perf_hook == "post_perf_hook"} {
		###################################################################
		# Initialize CSV Data Variables
		###################################################################
		sts::array_init_csv_data 1 0

		set time_ms [clock clicks -milliseconds]
		UTF::Message INFO "" "time_ms=$time_ms"

		if {$::saved_hook_start_timestamp == ""} {
			set ::saved_hook_start_timestamp $time_ms
			UTF::Message INFO "" "Set ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"
		}

		set diff_timestamp_ms [expr {$time_ms - $::saved_hook_start_timestamp}]
		set diff_timestamp_sec [format "%2.0f" [expr {$diff_timestamp_ms / 1000.0}]]
		set ::csv_data_BaseTime [clock format [expr {$::base_timestamp_tick + $diff_timestamp_sec}] -format "%M:%S"]
		
		set time_sec [format "%2.3f" [expr {$time_ms / 1000.0}]]
		UTF::Message INFO "" "time_sec=$time_sec"
		set parts [split $time_sec "."]
		set round_down [lindex $parts 0]
		UTF::Message INFO "" "time_sec round_down=$round_down"
		set fraction [lindex $parts 1]
		UTF::Message INFO "" "time_sec fraction=$fraction"

		set timestamp [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
		set timestamp "$timestamp.$fraction"

		set ::csv_data_Time "\[$timestamp\]"
		
		UTF::Message INFO "" "------------------------------$timestamp-----------------------------------"
	}

	UTF::Message INFO "" "============================================================================================================"
	UTF::Message INFO "" "************************Func:process_perf_hook***************************"

	UTF::Message INFO "" "perf_hook=$perf_hook throughput_flag=$throughput_flag write_flag=$write_flag"

	set targets "$::array_streams_ap_controller(${::curr_test_no}) $::array_streams_interface_existing_list(${::curr_test_no})"
	set targets [sts::remove_duplicates $targets]

	foreach target $targets {
		UTF::Message INFO "" "##############################target=$target###################################"

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
			if {[info exists ::array_sta_softap_flag(${target})] && $::array_sta_softap_flag(${target}) == 1} {
				if {$target == $::array_streams_src_sta(${::curr_test_no},${stream_no}) || $target == $::array_streams_src(${::curr_test_no},${stream_no})} {
					UTF::Message INFO "" "$target $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
					break
				}
			} else {
				if {$target == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) || $target == $::array_streams_dst(${::curr_test_no},${stream_no})} {
					UTF::Message INFO "" "$target $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
					break
				}
			}
		}
		
		if {$stream_no > $::array_streams_cnt(${::curr_test_no})} {
			# failed
			incr ::error_cnt
			UTF::Message ERROR "" "$target is not found in the streams"
			error "$target is not found in the streams"										
		}

		set active_sta_apsta_flag 0
		set active_sta_sts_flag 0
		set apsta_disassociated_flag 0
		set sts_disassociated_flag 0
		foreach sta_name $(sta) {
			if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
				set active_sta_apsta_flag 1
				UTF::Message INFO "" "$sta_name APSTA is active"
			}
			if {$::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
				set apsta_disassociated_flag 1
				UTF::Message INFO "" "$sta_name APSTA is disassociated"
			}
			if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
				set active_sta_sts_flag 1
				UTF::Message INFO "" "$sta_name StS is active"
			}
			if {$::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
				set sts_disassociated_flag 1
				UTF::Message INFO "" "$sta_name StS is disassociated"
			}
		}

		UTF::Message INFO "" "apsta_active_flag=$active_sta_apsta_flag apsta_disassociated_flag=$apsta_disassociated_flag"
		UTF::Message INFO "" "sts_active_flag=$active_sta_sts_flag sts_disassociated_flag=$sts_disassociated_flag"

		set str_interface ""
		set active2_sta_apsta_flag 0
		set active2_sta_sts_flag 0
		set curr_sta_name -1		
		if {[string compare $target $::array_streams_ap_controller(${::curr_test_no})] != 0} {
			foreach sta_name $(sta) {
				if {[string compare $target $sta_name] == 0} {
					UTF::Message INFO "" "APSTA STA $target"
					set active2_sta_apsta_flag 1
					set str_interface "-i $::array_sta_apsta_ifname(${sta_name})"
					UTF::Message INFO "" "APSTA: apsta_ifname(${sta_name})=$str_interface active2_sta_apsta_flag=$active2_sta_apsta_flag active2_sta_sts_flag=$active2_sta_sts_flag"
					set curr_sta_name $sta_name
					break
				} elseif {[string compare $target $::array_sta_sts(${sta_name})] == 0} {
					UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${stream_no}) STA $target"
					set active2_sta_sts_flag 1
					set str_interface "-i $::array_sta_sts_ifname(${sta_name})"
					UTF::Message INFO "" "StS: sts_ifname(${sta_name})=$str_interface active2_sta_apsta_flag=$active2_sta_apsta_flag active2_sta_sts_flag=$active2_sta_sts_flag"
					set curr_sta_name $sta_name
					break
				}
			}
		} else {
			UTF::Message INFO "" "Controller: $target"
		}

		# Skip APSTA STA when APSTA is not active
		if {$active_sta_apsta_flag == 0 && $active2_sta_apsta_flag == 1} {
			UTF::Message INFO "" "APSTA is not active. Skip APSTA STA."
			continue
		}
		
		# Skip StS STA when StS is not active
		if {$active_sta_sts_flag == 0 && $active2_sta_sts_flag == 1} {
			UTF::Message INFO "" "StS $::array_streams_link_type(${::curr_test_no},${stream_no}) is not active. Skip StS $::array_streams_link_type(${::curr_test_no},${stream_no}) STA."
			continue
		}

		# Skip controller when APSTA is not active
		if {[string compare $target $::array_streams_ap_controller(${::curr_test_no})] == 0 && $active_sta_apsta_flag == 0} {
			UTF::Message INFO "" "APSTA is not active. Skip controller."
			continue
		}
		
		# Skip StS Master when StS is not active
		if {[string compare $target $::array_streams_sts_master_sta_list(${::curr_test_no})] == 0 && $active_sta_sts_flag == 0} {
			UTF::Message INFO "" "StS $::array_streams_link_type(${::curr_test_no},${stream_no}) is not active and we must Skip commands for Master/GO."
			continue
		}
			
		if {$target == $::array_streams_ap_controller(${::curr_test_no}) || $target == $::roaming_src_ap || $target == $::roaming_dst_ap} {
			set target_type "Ap"
		} else {
			set target_type "Sta"
		}

		foreach cmd [$target cget -$perf_hook] {
			UTF::Message INFO "" "------------------------------cmd=$cmd-----------------------------------"

			# check for panic, trap, assert message
			if {[info exists ::UTF::panic]} {
				set msg "$::UTF::panic"
				UTF::Message INFO "G" "::UTF::panic=$msg"
				# add this error to the results and continue
				if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
					append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
				}
			}

			# check for warning message
			if {[info exists ::UTF::warn]} {
				set msg "$::UTF::warn"
				UTF::Message INFO "GW" "::UTF::warn=$msg"
				# add this error to the results and continue
				if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
					append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
				}
			}			

			if {$cmd == "pktq_stats"} {
				UTF::Message INFO "" "pktq_stats command is being used"
				set ::pktq_stats_flag 1
			}

			if {$throughput_flag && ([regexp {wl dump ampdu} $cmd] || [regexp {wl dump amsdu} $cmd] || [regexp {wl counters} $cmd])} {
				if {$(no_ampdu_dump)} {
					UTF::Message INFO "" "Throughput is running. Skip command '$cmd' to avoid RX throughput drop."
					continue
				}
			}

			if {$throughput_flag && ([regexp {wl dump phycal} $cmd] || [regexp {wl phy_cal_disable} $cmd] || [regexp {wl scansuppress} $cmd])} {
				UTF::Message INFO "" "Throughput is running. Skip command '$cmd'."
				continue
			}

			if {$target_type == "Ap" && ($cmd == "%S wl rssi" || $cmd == "%S wl sta_info")} {
			
				set str_macaddr ""
				set save_cmd $cmd
				foreach sta_name $(sta) {

					#UTF::Message INFO "" "sta_name=$sta_name"
					#UTF::Message INFO "" "::array_sta_apsta_flag(${sta_name})=$::array_sta_apsta_flag(${sta_name})"
					#UTF::Message INFO "" "::array_sta_sts_flag(${sta_name})=$::array_sta_sts_flag(${sta_name})"
					#UTF::Message INFO "" "::array_sta_master_flag(${sta_name})=$::array_sta_master_flag(${sta_name})"
					#UTF::Message INFO "" "::array_sta_slave_flag(${sta_name})=$::array_sta_slave_flag(${sta_name})"
					#UTF::Message INFO "" "::array_sta_plus_master_flag(${sta_name})=$::array_sta_plus_master_flag(${sta_name})"
					#UTF::Message INFO "" "::array_sta_plus_slave_flag(${sta_name})=$::array_sta_plus_slave_flag(${sta_name})"
				
					if {$::array_sta_master_flag(${sta_name}) && $::array_sta_plus_master_flag(${sta_name}) == 0} {
						# do these commands for Master only when AP is connected to it
						continue
					}

					set str_macaddr $::array_sta_apsta_macaddr(${sta_name})
					set cmd [concat $save_cmd " $str_macaddr"]
					UTF::Message INFO "" "new cmd=$cmd"

					# send the command
					set catch_resp [catch [string map [list %S $target] $cmd] ret]

					if {$catch_resp != 0 || $ret == "N/A"} {
						UTF::Message ERROR "$target" "catch_msg=$ret"
						continue
					}

					if {[regexp {wl rssi} $cmd]} {
						if {[regexp -nocase {([\d\-]+)} $ret - rssi]} {
							if {$rssi > 0} {
								set msg "Bad $rssi RSSI"
								UTF::Message ERROR "" "***Failed. $msg."
								if {[string first $msg $::array_streams_stream_error_msg(${::curr_test_no},${stream_no})] == -1} {
									append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($msg)"
								}
								continue
							} else {
								set ::csv_data_StaApRssi(${sta_name}) $rssi
							}
						}
					} elseif {[regexp {wl sta_info} $cmd]} {
						sts::process_ap_stainfo ${sta_name} $ret
					}
				}

				continue
			}

			if {$cmd == "%S wl assoc"} {
				if {$active_sta_apsta_flag == 1} {
					if {[string compare $target $::array_streams_src_sta(${::curr_test_no},${stream_no})] == 0  && $::array_sta_plus_slave_flag(${curr_sta_name})} {
						UTF::Message INFO "" "$target APSTA is active but it is connected to GO. we must Skip this 'wl assoc' command."
						continue
					}
					if {[lsearch -exact $::array_streams_sts_slave_sta_list(${::curr_test_no}) $target] >= 0  && $::array_sta_plus_master_flag(${curr_sta_name})} {
						UTF::Message INFO "" "$target APSTA is active but it is connected to GC. we must Skip this 'wl assoc' command."
						continue
					}
				}
				if {[info exists ::array_sta_master_flag(${target})]} {
					if {$active_sta_sts_flag == 1 && $::array_sta_apsta_flag(${target}) == 0} {
						UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${stream_no}) is active but we must Skip 'wl assoc' command for Master."
						continue
					}
				}
			}

			# add the interface name for non-ap
			regsub { wl } $cmd " wl $str_interface " new_cmd
			UTF::Message INFO "" "cmd=$new_cmd"
			
			# send the command
    		set catch_resp [catch [string map [list %S $target] $new_cmd] ret]

			if {$catch_resp != 0 || $ret == "N/A"} {
				UTF::Message ERROR "$target" "catch_msg=$ret"

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "I" "::UTF::panic=$::panic_msg"
					set ::halt_test_err $::panic_msg
					incr ::error_cnt
					error "$::panic_msg. Halting tests!"
				} elseif {[regexp -nocase {driver adapter not found} $ret] || [regexp -nocase {is not a valid wl driver} $ret]} {
					incr ::error_cnt
					UTF::Message INFO "" "***Fail. Driver is crashed. Do not continue the test."
					set ::halt_test_err $ret
					# set flag to dump socram and FW
					set ::socram_dump_flag 1
					error "$ret. Halting tests!"
				}				
				continue
			}

			if {$cmd == "%S wl dump ampdu"} {
				sts::process_ampdu_data $target_type $target $ret
				continue
			}				

			if {[regexp {wl rssi} $cmd]} {
				if {[regexp -nocase {([\d\-]+)} $ret - rssi]} {
					if {[lsearch -exact $::array_streams_sts_slave_sta_list(${::curr_test_no}) $target] >= 0 && $apsta_disassociated_flag == 1} {
						# GC disassociated
						set ::csv_data_${target_type}Rssi(${target}) "" 
					} else {
						set ::csv_data_${target_type}Rssi(${target}) $rssi 
					}
				}
				continue
			} elseif {$cmd == "%S wl bssid"} {
				set ::csv_data_${target_type}Bssid(${target}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $ret]
				continue
			} elseif {$cmd == "%S wl rate"} {
				if {[regexp -nocase {([\.\d]+)\s*Mbps} $ret - rate]} {
					set ::csv_data_${target_type}TxRate(${target}) $rate 
				}
				continue
			} elseif {$cmd == "%S wl nrate"} {
				set nrate [sts::parse_nrate $ret]
				set ::csv_data_${target_type}McsRate(${target}) $nrate
				continue
			} elseif {$::iperf_running_flag && [regexp {wl counters} $cmd] && $target_type != "Ap"} {
				# number of beacons is about 10 / sec when throughput is running
				# number of beacons is about 3 / sec when idle
				
				# here the beacon information is gathered for non-idle case
				
				set bcnrate 0
				regexp {rxbeaconmbss\s([0-9]+)} $ret - bcnrate
				
				set time_ms [clock clicks -milliseconds]

				if {[info exists ::array_streams_last_BeaconRate(${target})]} {
					set bcntime [expr {$time_ms - $::array_streams_last_BeaconRate_time(${target})}]
					set tmp_bcnrate [expr {$bcnrate - $::array_streams_last_BeaconRate(${target})}]
					set BeaconRate [format "%2.3f" [expr {$tmp_bcnrate * 1000.0 / $bcntime}]]
					if {$BeaconRate < 0} {
						set BeaconRate 0
					}
					set ::csv_data_${target_type}BeaconRate(${target}) $BeaconRate
					UTF::Message INFO "" "Time -> '$time_ms - $::array_streams_last_BeaconRate_time(${target})=$bcntime ms'"
					UTF::Message INFO "" "Beacons -> '$bcnrate - $::array_streams_last_BeaconRate(${target})=$tmp_bcnrate'"
					UTF::Message INFO "" "BeaconRate='($tmp_bcnrate * 1000) / $bcntime=$BeaconRate'"
				}
				
				set ::array_streams_last_BeaconRate_time(${target}) $time_ms
				set ::array_streams_last_BeaconRate(${target}) $bcnrate
				
				continue
			}
			
			# get STA state
			if {$cmd == "%S wl assoc"} {
				if {[regexp -nocase {not.*associated} $ret]} {
					set ::csv_data_StaState(${target}) "ROAMING"
					if {$active_sta_apsta_flag == 1 && $active_sta_apsta_flag == 1} {
						if {$::array_sta_apsta_disassociated_flag(${curr_sta_name}) == 0} {
							set msg "APSTA disassociated"
							UTF::Message ERROR "" "***Failed. $msg."
							if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
								append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
							}
							sts::check_sta_apsta_association $curr_sta_name
						}	
					} else {
						if {$::array_sta_sts_disassociated_flag(${curr_sta_name}) == 0} {
							set msg "$::array_streams_link_type(${::curr_test_no},${stream_no}) disassociated"
							UTF::Message ERROR "" "***Failed. $msg."
							if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
								append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
							}
							sts::check_sta_sts_association $curr_sta_name
						}
					}
				} elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $ret]} {
					set ::csv_data_StaState(${target}) "ASSOCIATED"
					if {$active_sta_apsta_flag == 1 && $active_sta_apsta_flag == 1} {
						if {$::array_sta_apsta_disassociated_flag(${curr_sta_name}) == 0} {
							set msg "APSTA reassociated"
							UTF::Message INFO "" "$msg."
							if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
								append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
							}
							sts::check_sta_apsta_association $curr_sta_name
						}	
					} else {
						if {$::array_sta_sts_disassociated_flag(${curr_sta_name}) == 0} {
							set msg "$::array_streams_link_type(${::curr_test_no},${stream_no}) reassociated"
							UTF::Message INFO "" "$msg."
							if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
								append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
							}
							sts::check_sta_sts_association $curr_sta_name
						}
					}
				} elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $ret]} {
					set ::csv_data_StaState(${target}) "ASSOCIATED BEACONS"
					if {$active_sta_apsta_flag == 1 && $active_sta_apsta_flag == 1} {
						if {$::array_sta_apsta_disassociated_flag(${curr_sta_name}) > 0} {
							sts::check_sta_apsta_association $curr_sta_name
						}	
					} else {
						if {$::array_sta_sts_disassociated_flag(${curr_sta_name}) > 0} {
							sts::check_sta_sts_association $curr_sta_name
						}
					}
				} else {
					set ::csv_data_StaState(${target}) ""
					if {$active_sta_apsta_flag == 1 && $active_sta_apsta_flag == 1} {
						if {$::array_sta_apsta_disassociated_flag(${curr_sta_name}) == 0} {
							sts::check_sta_apsta_association $curr_sta_name
						}	
					} else {
						if {$::array_sta_sts_disassociated_flag(${curr_sta_name}) == 0} {
							sts::check_sta_sts_association $curr_sta_name
						}
					}
				}
				if {$active_sta_apsta_flag == 1 && $active_sta_apsta_flag == 1} {
					UTF::Message INFO "" "State: ::array_sta_apsta_disassociated_flag(${curr_sta_name})=$::array_sta_apsta_disassociated_flag(${curr_sta_name})"
				} else {
					UTF::Message INFO "" "State: ::array_sta_sts_disassociated_flag(${curr_sta_name})=$::array_sta_sts_disassociated_flag(${curr_sta_name})"
				}
				continue
			}			
		}
	}

	if {$write_flag && $perf_hook == "post_perf_hook"} {
		#####################################################
		#########  Write Data Result to CVS File  ###########
		#####################################################
		sts::array_write_csv_data 1 0
	}

	UTF::Message INFO "" "****************************************************************"
}

proc sts::check_sta_apsta_association {sta_name} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:check_sta_apsta_association***************************"

	if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
		UTF::Message INFO "" "----------------------------Check APSTA association----------------------------"
		# This will run when STA is disassociated and
		# delay here for RvR will adjust the timing since iperf did not run
		UTF::Sleep $::array_streams_end_time(${::curr_test_no},${::curr_stream_no})
		set catch_resp [catch {$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) bssid} catch_msg]
		if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
			UTF::Message ERROR "" "APSTA is NOT associated"
			incr ::array_sta_apsta_disassociated_flag(${sta_name})
			UTF::Message INFO "" "incr apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_name})"
		} else {
			UTF::Message INFO "" "APSTA is associated"
			set ::array_sta_apsta_disassociated_flag(${sta_name}) 0
			UTF::Message INFO "" "clear apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_name})"
		}
	}
}

proc sts::check_sta_sts_association {sta_name} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:check_sta_sts_association***************************"

	if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
		UTF::Message INFO "" "----------------------------Check $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) association----------------------------"
		# This will run when StS is disassociated and
		# delay here for RvR will adjust the timing since iperf did not run
		UTF::Sleep $::array_streams_end_time(${::curr_test_no},${::curr_stream_no})
		set catch_resp [catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) bssid} catch_msg]
		if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
			UTF::Message ERROR "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is NOT associated"
			incr ::array_sta_sts_disassociated_flag(${sta_name})
			UTF::Message INFO "" "incr sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_name})"
		} else {
			UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is associated"
			set ::array_sta_sts_disassociated_flag(${sta_name}) 0
			UTF::Message INFO "" "clear sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_name})"
		}
	}
}

proc sts::process_ap_stainfo {target results} {

	UTF::Message INFO "" "************************Func:process_ap_stainfo***************************"
	
	# Get StaApTxRateStaInfo
	if {[regexp -nocase {last\s*tx\s*pkt:\s*(\d+)\s*kbps} $results - rate]} {
		# convert kbps to Mbps
		set ::csv_data_StaApTxRateStaInfo(${target}) [expr {double($rate) / 1000.0}]
	}

	# Get StaApRxRate
	# "rate of last rx pkt: 24000 kbps"
	if {[regexp -nocase {last\s*rx\s*pkt:\s*(\d+)\s*kbps} $results - rate]} {
		# convert kbps to Mbps
		set ::csv_data_StaApRxRate(${target}) [expr {double($rate) / 1000.0}]
	}

	# Get StaApIdleTime
	if {[regexp -nocase {idle\s*(\d+)\s*seconds} $results - time]} {
		set ::csv_data_StaApIdleTime(${target}) $time 
	}

	# Get StaApConnectTime
	if {[regexp -nocase {in\s*network\s*(\d+)\s*seconds} $results - time]} {
		set ::csv_data_StaApConnectTime(${target}) $time 
	}

	# Get StaApState
	if {[regexp -nocase {state:\s*(.*)flags} $results - state]} {
		set state [string trim $state]
		set state [string toupper $state]
		set ::csv_data_StaApState(${target}) $state 
	}

	# Get StaApTxPkts
	if {[regexp -nocase {tx\s*total\s*pkts:\s*(\d+)} $results - pkts]} {
		set ::csv_data_StaApTxPkts(${target}) $pkts 
	}

	# Get StaApTxFailures
	if {[regexp -nocase {tx\s*failures:\s*(\d+)} $results - count]} {
		set ::csv_data_StaApTxFailures(${target}) $count 
	}
}

proc sts::ampdu_data_cleanup {ampdu_data per_flag} {

	regsub -all {\n} $ampdu_data "" ampdu_data
	regsub -all {:} $ampdu_data "" ampdu_data
	if {$per_flag} {
		# for PER, extract the percentage values
		regsub -all {\d+\(} $ampdu_data "" ampdu_data
		regsub -all {%\)} $ampdu_data "" ampdu_data
	} else {
		# for non PER, extract the values
		regsub -all {\(\d+%\)} $ampdu_data "" ampdu_data
	}
	regsub -all {[a-zA-Z]} $ampdu_data "" ampdu_data
	regsub -all {\s+} $ampdu_data " " ampdu_data
	set ampdu_data [string trim $ampdu_data]
	
	return $ampdu_data
}

proc sts::process_ampdu_data {target_type target ampdu_data} {

	# target_type is Ap or Sta
	
	set var "csv_data_${target_type}"

	# data are 1 line or more
	# avoid "00:90:4c:18:60:58: max_pdu 48 release 48" which could be anywhere
	
    #RX MCS :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  7(1%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  14(2%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  21(3%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  28(4%)
    
    regexp -nocase {RX\s*MCS(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxMcs(${target})
	set ::${var}RxMcs(${target}) [sts::ampdu_data_cleanup [expr \${::${var}RxMcs(${target})}] 0]
	UTF::Message INFO "" "::${var}RxMcs(${target})=[expr \${::${var}RxMcs(${target})}]"
    regexp -nocase {TX\s*MCS(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxMcs(${target})
	set ::${var}TxMcs(${target}) [sts::ampdu_data_cleanup [expr \${::${var}TxMcs(${target})}] 0]
	UTF::Message INFO "" "::${var}TxMcs(${target})=[expr \${::${var}TxMcs(${target})}]"
	
	#MPDUdens:  49 (1%) 223 (4%)  37 (0%)  38 (0%)  32 (0%)  49 (1%)  46 (0%)  52 (1%)
	#	 :  45 (0%)  49 (1%)  53 (1%)  55 (1%)  48 (0%)  50 (1%)  33 (0%)  37 (0%)
	#	 :  32 (0%)  34 (0%)  27 (0%)  44 (0%)  30 (0%)  36 (0%)  32 (0%)  36 (0%)
	#	 :  41 (0%)  38 (0%)  32 (0%)  47 (0%)  46 (0%)  41 (0%)  35 (0%)  29 (0%)
	#	 :  46 (0%)  39 (0%)  34 (0%)  42 (0%)  35 (0%)  44 (0%)  49 (1%)  23 (0%)
	#	 :  21 (0%)  25 (0%)  29 (0%)  28 (0%)  29 (0%)  35 (0%)  36 (0%) 2838 (58%)

	regexp -nocase {MPDUdens(\s*:(\s*\d+\s*\(\d+%\)\s*){1,}){1,}} $ampdu_data ::${var}MpduDensity(${target})
	set ::${var}MpduDensity(${target}) [sts::ampdu_data_cleanup [expr \${::${var}MpduDensity(${target})}] 0]
	UTF::Message INFO "" "::${var}MpduDensity(${target})=[expr \${::${var}MpduDensity(${target})}]"

    regexp -nocase {RX\s*MCS\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxMcsSgi(${target})
    set ::${var}RxMcsSgi(${target}) [sts::ampdu_data_cleanup [expr \${::${var}RxMcsSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}RxMcsSgi(${target})=[expr \${::${var}RxMcsSgi(${target})}]"
    regexp -nocase {TX\s*MCS\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxMcsSgi(${target})
	set ::${var}TxMcsSgi(${target}) [sts::ampdu_data_cleanup [expr \${::${var}TxMcsSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}TxMcsSgi(${target})=[expr \${::${var}TxMcsSgi(${target})}]"
    regexp -nocase {MCS\s*PER(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}McsPer(${target})
	set ::${var}McsPer(${target}) [sts::ampdu_data_cleanup [expr \${::${var}McsPer(${target})}] 1]
	UTF::Message INFO "" "::${var}McsPer(${target})=[expr \${::${var}McsPer(${target})}]"
    regexp -nocase {RX\s*VHT(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxVht(${target})
	set ::${var}RxVht(${target}) [sts::ampdu_data_cleanup [expr \${::${var}RxVht(${target})}] 0]
	UTF::Message INFO "" "::${var}RxVht(${target})=[expr \${::${var}RxVht(${target})}]"
	regexp -nocase {TX\s*VHT(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxVht(${target})
	set ::${var}TxVht(${target}) [sts::ampdu_data_cleanup [expr \${::${var}TxVht(${target})}] 0]
	UTF::Message INFO "" "::${var}TxVht(${target})=[expr \${::${var}TxVht(${target})}]"
	regexp -nocase {RX\s*VHT\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxVhtSgi(${target})
	set ::${var}RxVhtSgi(${target}) [sts::ampdu_data_cleanup [expr \${::${var}RxVhtSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}RxVhtSgi(${target})=[expr \${::${var}RxVhtSgi(${target})}]"
    regexp -nocase {TX\s*VHT\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxVhtSgi(${target})
	set ::${var}TxVhtSgi(${target}) [sts::ampdu_data_cleanup [expr \${::${var}TxVhtSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}TxVhtSgi(${target})=[expr \${::${var}TxVhtSgi(${target})}]"
    regexp -nocase {VHT\s*PER(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}VhtPer(${target})
	set ::${var}VhtPer(${target}) [sts::ampdu_data_cleanup [expr \${::${var}VhtPer(${target})}] 1]
	UTF::Message INFO "" "::${var}VhtPer(${target})=[expr \${::${var}VhtPer(${target})}]"
}

proc sts::create_test_set_streams_graphs {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_test_set_streams_graphs***************************"

	set final_html_results ""

	#####################################################
	## For each stream                                 ##
	## Create new ControlChart object & graphics file  ##
	#####################################################
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		UTF::Message INFO "" "=============================Process Stream Result===================================="

		set stream_report_label $::array_streams_stream_label(${::curr_test_no},${stream_no})

		UTF::Message INFO "" "stream_no=$stream_no"
		UTF::Message INFO "" "stream_report_label=$stream_report_label"
		UTF::Message INFO "" "::array_streams_link_type(${::curr_test_no},${stream_no})=$::array_streams_link_type(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_traffic_priority(${::curr_test_no},${stream_no})=$::array_streams_traffic_priority(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_cnt(${::curr_test_no})=$::array_streams_cnt(${::curr_test_no})"
		UTF::Message INFO "" "::array_streams_throughput(${::curr_test_no},${stream_no})=$::array_streams_throughput(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_tcp_rtt(${::curr_test_no},${stream_no})=$::array_streams_tcp_rtt(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_tcp_writes(${::curr_test_no},${stream_no})=$::array_streams_tcp_writes(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_tcp_errors(${::curr_test_no},${stream_no})=$::array_streams_tcp_errors(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_tcp_retries(${::curr_test_no},${stream_no})=$::array_streams_tcp_retries(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})=$::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_latency_min(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_min(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_latency_max(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_max(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_udp_jitter(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_udp_pps(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})"

		set html_results ""

		#####################################################
		## Control Charts
		#####################################################
		set ::sts::cc_error ""

		if {$::array_streams_stream_data_missing_flag(${::curr_test_no},${stream_no})} {
			set html_results "<b>$stream_report_label</b>"
			# since all data missing then override all errors for this stream
			set ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(All data missing)"
			set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::array_streams_stream_error_msg(${::curr_test_no},${stream_no})]
			append html_results "&nbsp;&nbsp;<font color=\"red\"><b>$tmp</b></font>"
			append html_results "<br>"
			append final_html_results $html_results
			set ::test_error_flag 1
			continue
		}
		
		UTF::Message INFO "" "#############################Control Chart Throughput stream_no=$stream_no####################################"
		# example: set html_results "<b>VI-P2P:GC<-GO</b>&nbsp;&nbsp;<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAANCAMAAADG8S11AAABIFBMVEX///++vr6g/yB8/0DNwLDB/8Ggts3w//DNt57//8D//4D/wMD/oHD/oGD/oED/gECAgACAYP+AYMCAQICAQBSAFBSAFABVay+QUEDdoN2UANPugu7/pQCggCD19dy4hgu9t2vw5ozplnr6gHL/RQDwgID/f1D/FJMAztH/AP8A//+HzusAAM0AAIAZGXAAAIsAAP8ui1ciiyIA/38AZAAA/wD/1wCv7u7/tsHu3YLg///wVfCt2OaQ7pDwMjL////l5eXMzMzAwMCzs7OZmZl/f39mZmZNTU0zMzMaGhoAAABA4ND//wClKip//9T/gP9AgACLAAAwYIDAgP8AgED/wCBBaeHIyADAQAAA7u7AAP8AgP8AwAD/AACgoKAAAAB3sO+0AAAAAXRSTlMAQObYZgAAAExJREFUKJFjYICCWIZYEGBAg+hCuEAsDKBpRhPCr5cIgMMErBBTAA3EUAAo104awB30dNWOPxXg1I6SIMixHiVBkqWdUBrCpRcjBQIAmV9ohnWheeUAAAAASUVORK5CYII=\" alt=\"data\" /> <a href=\"DIN07T48RC50%20P2PQoS%20%20%2050%20open%20open%204359-GOd35%204359-PGO%204359-GOd35%204359-PGO%202%203%201%20%200%200%20\[VIP-GC1GO\]%20A=0%20PT1.png\">19.23 \[19.69 - 19.75\], range 0.10 \[0.07\] LOW</a>"
		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
			set y_label_unit "Kbps"		
			set y_label "BT Throughput"
		} elseif {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
			set y_label_unit "Mbps"		
			set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Throughput"
		} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
			set y_label_unit "Mbps"		
			set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Throughput"
		}
		set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) THR"
		UTF::Message INFO "" "KEY=$ckey"
		UTF::Message INFO "" "sts::control_chart '$stream_report_label' '$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})' '$ckey' '$y_label' '$y_label_unit' 1"
		set html_results [sts::control_chart "$stream_report_label" $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no}) $ckey "$y_label" "$y_label_unit" 1]

		set throughput 0
		set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results match throughput throughput_min throughput_max]

		if {$result == 1 && $throughput >= 0 && $::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) != 1} {
		
			if {$::rvr_test_flag == 1} {
				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
					set stream_sta_obj $(bt_root_sta)
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
						}
					} else {
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
						}
					}
				}
				# this throughput data goes to csv file, only for RvR
				set ::csv_data_StaThroughput(${stream_sta_obj})(${stream_name}) $throughput
				set ::csv_data_StaThroughputMin(${stream_sta_obj})(${stream_name}) $throughput_min
				set ::csv_data_StaThroughputMax(${stream_sta_obj})(${stream_name}) $throughput_max
			}

			if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			
				# TCP Stream
				
				set html_results_tcp_rtt ""
				if {$::array_streams_tcp_rtt(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart RTT stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) RTT"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) RTT"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) RTT"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'RTT' '$::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'ms' 0"
					set html_results_tcp_rtt [sts::control_chart "RTT" $::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no}) $ckey "$y_label" "ms" 0]

					# tcp_rtt of zero and low are OK
					regsub { ZERO} $html_results_tcp_rtt { OK} html_results_tcp_rtt
					regsub { LOW} $html_results_tcp_rtt { OK} html_results_tcp_rtt

					set tcp_rtt ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_rtt match tcp_rtt tcp_rtt_min tcp_rtt_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaTCPRTT(${stream_sta_obj})(${stream_name}) $tcp_rtt
					}

					UTF::Message INFO "" "tcp_rtt=$tcp_rtt"

					set tcp_rtt_err_cnt 0
					foreach stream_tcp_rtt $::array_streams_tcp_rtt(${::curr_test_no},${stream_no}) {
						if {$stream_tcp_rtt >= 300} {
							incr tcp_rtt_err_cnt
						}
					}

					set rc [sts::max_range $tcp_rtt_err_cnt]
					UTF::Message INFO "" "tcp_rtt_err_cnt=$tcp_rtt_err_cnt rc=$rc"

					# tcp_rtt of 300 ms or more is not acceptable
					if {$tcp_rtt == "" || $tcp_rtt >= 300 || $tcp_rtt_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_rtt_err_cnt RTT >= 300 ms"
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($tcp_rtt_err_cnt RTT > $rc)"
					}
				}

				set html_results_tcp_retries ""
				if {$::array_streams_tcp_retries(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart Retries stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Retries"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Retries"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) RET"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'Retries' '$::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'Cnt' 0"
					set html_results_tcp_retries [sts::control_chart "Retries" $::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no}) $ckey "$y_label" "Cnt" 0]

					# tcp_retries of zero and low are OK
					regsub { ZERO} $html_results_tcp_retries { OK} html_results_tcp_retries
					regsub { LOW} $html_results_tcp_retries { OK} html_results_tcp_retries

					set tcp_retries ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_retries match tcp_retries tcp_retries_min tcp_retries_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaTCPRetries(${stream_sta_obj})(${stream_name}) $tcp_retries
					}

					UTF::Message INFO "" "tcp_retries=$tcp_retries"

					set tcp_retries_err_cnt 0
					foreach stream_tcp_retries $::array_streams_tcp_retries(${::curr_test_no},${stream_no}) {
						if {$stream_tcp_retries >= 30} {
							incr tcp_retries_err_cnt
						}
					}

					set rc [sts::max_range $tcp_retries_err_cnt]
					UTF::Message INFO "" "tcp_retries_err_cnt=$tcp_retries_err_cnt rc=$rc"

					# tcp_retries of 30 or more is not acceptable
					if {$tcp_retries == "" || $tcp_retries >= 30 || $tcp_retries_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_retries_err_cnt Retries >= 30"
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($tcp_retries_err_cnt Retries > $rc)"
					}
				}

				set html_results_tcp_used_memory ""
				if {$::array_streams_tcp_used_memory(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart Used Memory stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Used Memory"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Used Memory"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) USE"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'Used Memory' '$::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'K' 0"
					set html_results_tcp_used_memory [sts::control_chart "Used Memory" $::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no}) $ckey "$y_label" "K" 0]

					# tcp_used_memory of zero and low are OK
					regsub { ZERO} $html_results_tcp_used_memory { OK} html_results_tcp_used_memory
					regsub { LOW} $html_results_tcp_used_memory { OK} html_results_tcp_used_memory

					set tcp_used_memory ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_used_memory match tcp_used_memory tcp_used_memory_min tcp_used_memory_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaTCPUsedMemory(${stream_sta_obj})(${stream_name}) $tcp_used_memory
					}

					UTF::Message INFO "" "tcp_used_memory=$tcp_used_memory"

					set tcp_used_memory_err_cnt 0
					foreach stream_tcp_used_memory $::array_streams_tcp_used_memory(${::curr_test_no},${stream_no}) {
						if {$stream_tcp_used_memory >= 500} {
							incr tcp_used_memory_err_cnt
						}
					}

					set rc [sts::max_range $tcp_used_memory_err_cnt]
					UTF::Message INFO "" "tcp_used_memory_err_cnt=$tcp_used_memory_err_cnt rc=$rc"

					# tcp_used_memory of 500k or more is not acceptable
					if {$tcp_used_memory == "" || $tcp_used_memory >= 500 || $tcp_used_memory_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_used_memory_err_cnt Used Memory >= 500K"
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($tcp_used_memory_err_cnt Used Memory > $rc)"
					}
				}

				append html_results " $html_results_tcp_rtt $html_results_tcp_retries $html_results_tcp_used_memory"

			} elseif {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			
				# UDP Stream

				# check the UDP throughput value to be close to set bandwidth value
				# throughput needs to be within 10% of the bandwidth
				
				set iperf_bandwidth 0
				regexp {^([-+]?[0-9]*\.?[0-9]+)(.)} $::array_streams_bandwidth(${::curr_test_no},${stream_no}) match iperf_bandwidth scale
				
				set tmp [expr {$iperf_bandwidth * 0.1}]
				if {$tmp > 0} {
					set tmp_iperf_bandwidth [expr {$iperf_bandwidth - $tmp}]
				}
				
				UTF::Message INFO "" "throughput='$throughput' iperf_bandwidth='$iperf_bandwidth' tmp_iperf_bandwidth='$tmp_iperf_bandwidth'"
				if {$::rvr_test_flag == 0 && $::roaming_test_flag == 0 && $::failover_test_flag == 0 && $throughput < $tmp_iperf_bandwidth} {
					# error
					UTF::Message ERROR "" "Throughput is $throughput and it is lower than UDP bandwidth of $::array_streams_bandwidth(${::curr_test_no},${stream_no})"
					append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(Throughput < $::array_streams_bandwidth(${::curr_test_no},${stream_no}))"
				}

				set html_results_udp_latency ""
				if {$::array_streams_udp_latency_avg(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart Latency stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Latency"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Latency"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) LAT"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'Latency' '$::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'ms' 0"
					set html_results_udp_latency [sts::control_chart "Latency" $::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no}) $ckey "$y_label" "ms" 0]

					# udp_latency of zero and low are OK
					regsub { ZERO} $html_results_udp_latency { OK} html_results_udp_latency
					regsub { LOW} $html_results_udp_latency { OK} html_results_udp_latency

					set udp_latency ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_latency match udp_latency udp_latency_min udp_latency_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaUDPLatency(${stream_sta_obj})(${stream_name}) $udp_latency
					}

					UTF::Message INFO "" "udp_latency=$udp_latency"

					set udp_latency_err_cnt 0
					foreach stream_udp_latency $::array_streams_udp_latency_avg(${::curr_test_no},${stream_no}) {
						if {$stream_udp_latency >= 5} {
							incr udp_latency_err_cnt
						}
					}

					set rc [sts::max_range $udp_latency_err_cnt]
					UTF::Message INFO "" "udp_latency_err_cnt=$udp_latency_err_cnt rc=$rc"

					# udp_latency of 5 ms or more is not acceptable
					if {$udp_latency == "" || $udp_latency >= 5 || $udp_latency_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$udp_latency_err_cnt Latency >= 5 ms"
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($udp_latency_err_cnt Latency > $rc)"
					}
				}
				
				set html_results_udp_jitter ""
				if {$::array_streams_udp_jitter(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart Jitter stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Jitter"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Jitter"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) JIT"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'Jitter' '$::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'ms' 0"
					set html_results_udp_jitter [sts::control_chart "Jitter" $::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no}) $ckey "$y_label" "ms" 0]

					# udp_jitter of zero and low are OK
					regsub { ZERO} $html_results_udp_jitter { OK} html_results_udp_jitter
					regsub { LOW} $html_results_udp_jitter { OK} html_results_udp_jitter

					set udp_jitter ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_jitter match udp_jitter udp_jitter_min udp_jitter_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaUDPJitter(${stream_sta_obj})(${stream_name}) $udp_jitter
						set ::csv_data_StaUDPJitterMin(${stream_sta_obj})(${stream_name}) $udp_jitter_min
						set ::csv_data_StaUDPJitterMax(${stream_sta_obj})(${stream_name}) $udp_jitter_max
					}

					UTF::Message INFO "" "udp_jitter=$udp_jitter"
					
					set udp_jitter_err_cnt 0
					foreach stream_udp_jitter $::array_streams_udp_jitter(${::curr_test_no},${stream_no}) {
						if {$stream_udp_jitter >= 1} {
							incr udp_jitter_err_cnt
						}
					}

					set rc [sts::max_range $udp_jitter_err_cnt]
					UTF::Message INFO "" "udp_jitter_err_cnt=$udp_jitter_err_cnt rc=$rc"

					# Jitter of 1 ms or more is not acceptable for the UDP
					if {$udp_jitter == "" || $udp_jitter >= 1 || $udp_jitter_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$udp_jitter_err_cnt Jitter >= 1 ms"
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($udp_jitter_err_cnt Jitter > $rc)"
					}
				}

				set html_results_udp_lost_packets ""
				if {$::array_streams_udp_lost_packets(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart Lost Packets stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) Lost Packets"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) Lost Packets"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) LOS"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'Lost Packets' '$::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'Packets' 0"
					set html_results_udp_lost_packets [sts::control_chart "Lost Packets" $::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no}) $ckey "$y_label" "Packets" 0]

					# packet loss with zero or low are OK
					regsub { ZERO} $html_results_udp_lost_packets { OK} html_results_udp_lost_packets
					regsub { LOW} $html_results_udp_lost_packets { OK} html_results_udp_lost_packets

					set udp_lost_packets ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_lost_packets match udp_lost_packets udp_lost_packets_min udp_lost_packets_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaUDPLostPackets(${stream_sta_obj})(${stream_name}) $udp_lost_packets
						set ::csv_data_StaUDPLostPacketsMin(${stream_sta_obj})(${stream_name}) $udp_lost_packets_min
						set ::csv_data_StaUDPLostPacketsMax(${stream_sta_obj})(${stream_name}) $udp_lost_packets_max
					}

					UTF::Message INFO "" "udp_lost_packets=$udp_lost_packets"
					set udp_lost_packets [format "%2.0f" $udp_lost_packets]
					set rc [sts::max_range $udp_lost_packets]
					UTF::Message INFO "" "udp_lost_packets=$udp_lost_packets rc=$rc"

					# packet loss of more than 0 is not acceptable for the UDP
					if {$udp_lost_packets == "" || $udp_lost_packets > 0} {
						# error
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($udp_lost_packets Lost Packets > $rc)"
					}
				}

				set html_results_udp_out_of_order_packets ""
				if {$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) != ""} {
					UTF::Message INFO "" "#############################Control Chart out-of-order stream_no=$stream_no####################################"
					if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} { 
						set y_label "$::array_streams_link_type(${::curr_test_no},${stream_no}) out-of-order Packets"
					} elseif {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} { 
						set y_label "$::array_streams_dst_display_str(${::curr_test_no},${stream_no}) out-of-order Packets"
					}
					set ckey "$::array_streams_control_chart_key(${::curr_test_no},${stream_no}) OOO"
					UTF::Message INFO "" "KEY=$ckey"
					UTF::Message INFO "" "sts::control_chart 'out-of-order Packets' '$::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})' '$ckey' '$y_label' 'Packets' 0"
					set html_results_udp_out_of_order_packets [sts::control_chart "out-of-order Packets" $::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no}) $ckey "$y_label" "Packets" 0]

					# out-of-order Packets of zero or low are OK
					regsub { ZERO} $html_results_udp_out_of_order_packets { OK} html_results_udp_out_of_order_packets
					regsub { LOW} $html_results_udp_out_of_order_packets { OK} html_results_udp_out_of_order_packets

					set udp_out_of_order_packets ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_out_of_order_packets match udp_out_of_order_packets udp_out_of_order_packets_min udp_out_of_order_packets_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} else {
							if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
								}
							} else {
								if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
									set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
								} else {
									set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
								}
							}
						}
						set ::csv_data_StaUDPOutofOrderPackets(${stream_sta_obj})(${stream_name}) $udp_out_of_order_packets
						set ::csv_data_StaUDPOutofOrderPacketsMin(${stream_sta_obj})(${stream_name}) $udp_out_of_order_packets_min
						set ::csv_data_StaUDPOutofOrderPacketsMax(${stream_sta_obj})(${stream_name}) $udp_out_of_order_packets_max
					}

					UTF::Message INFO "" "udp_out_of_order_packets=$udp_out_of_order_packets"
					set udp_out_of_order_packets [format "%2.0f" $udp_out_of_order_packets]
					set rc [sts::max_range $udp_out_of_order_packets]
					UTF::Message INFO "" "udp_out_of_order_packets=$udp_out_of_order_packets rc=$rc"

					# More than 0 out-of-order Packets is not acceptable for the UDP
					if {$udp_out_of_order_packets == "" || $udp_out_of_order_packets > 0} {
						# error
						append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($udp_out_of_order_packets out-of-order Packets > $rc)"
					}
				}

				append html_results " $html_results_udp_latency $html_results_udp_jitter $html_results_udp_lost_packets $html_results_udp_out_of_order_packets"
			}			
		} else {
			set active_sta_apsta_flag 0
			set active_sta_sts_flag 0
			set apsta_disassociated_flag 0
			set sts_disassociated_flag 0
			foreach sta_name $(sta) {
				if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
					set active_sta_apsta_flag 1
					UTF::Message INFO "" "$sta_name APSTA link is active"
				}
				if {$::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
					set apsta_disassociated_flag 1
					UTF::Message INFO "" "$sta_name APSTA is disassociated"
				}
				if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
					set active_sta_sts_flag 1
					UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${stream_no}) link is active"
				}
				if {$::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
					set sts_disassociated_flag 1
					UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${stream_no}) is disassociated"
				}
			}

			set tmp_msg ""

			if {$active_sta_apsta_flag == 1 && $apsta_disassociated_flag > 0} {
				set tmp_msg [concat $tmp_msg "APSTA is NOT associated. "]
			}

			if {$active_sta_sts_flag == 1 && $sts_disassociated_flag > 0} {
				set tmp_msg [concat $tmp_msg "$::array_streams_link_type(${::curr_test_no},${stream_no}) is NOT associated. "]
			}

			if {$::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) == 1} {
				set tmp_msg [concat $tmp_msg "Skip running iperf."]
			}

			if {$tmp_msg == ""} {
				set tmp_msg "(All Data Missing)"
			}
			
			set html_results "<font color=\"red\"><b>$stream_no $tmp_msg</b></font>"
			set ::sts::cc_error ""
			set ::test_error_flag 1
		}

		if {$::sts::cc_error != ""} {
			set ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "$::sts::cc_error$::array_streams_stream_error_msg(${::curr_test_no},${stream_no})"
			set ::sts::cc_error ""
		}
		
		UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${stream_no}) ::array_streams_stream_error_msg(${::curr_test_no},${stream_no})=$::array_streams_stream_error_msg(${::curr_test_no},${stream_no})"
		if {$::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) != ""} {
			# html conversion 
			set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::array_streams_stream_error_msg(${::curr_test_no},${stream_no})]
			append html_results "&nbsp;&nbsp;<font color=\"red\"><b>$tmp</b></font>"
			set ::test_error_flag 1
		}

		append html_results "<br>"
		append final_html_results $html_results
	}

	#####################################################
	## throughput time plot graph for this group of streams
	#####################################################
	if {$::rvr_test_flag == 1} {
		set html_results_plot ""
	} else {
		set testnum [sts::get_testnum]
		regsub -all {.} $testnum "_" $testnum
		set html_results_plot "<a href=\"GraphsData/$testnum.StaThroughput.htm\">Graphs</a>&nbsp;&nbsp;<a href=\"GraphsData/$testnum.StaThroughput.htm\"><img src=\"GraphsData/$testnum.StaThroughput_sm.png\"></a>"
	}

	#####################################################
	## current measurement time plot graph for this group of streams
	#####################################################
	set html_results_current ""
	if {$::agilent_obj != ""} {
		if {$::current_results == ""} {
			append html_results_current "&nbsp;&nbsp;<blink><font color=\"red\"><b>'No Current Data'</b></font></blink>"
			set ::test_error_flag 1
		} else {
			set html_results_current "<br>$::current_results"
		}					
	}

	#####################################################
	## Report
	#####################################################
	set report_html_results "$final_html_results$html_results_plot$html_results_current"

	UTF::Message INFO "" "::array_streams_error_msg(${::curr_test_no})=$::array_streams_error_msg(${::curr_test_no})"
	if {$::array_streams_error_msg(${::curr_test_no}) != ""} {
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::array_streams_error_msg(${::curr_test_no})]
		append report_html_results "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
		set error_flag 1
	}

	if {$::debug_flag == 1} {
		UTF::Try "DEBUG DUMP" {
			$sta_name wl dump stats dma phystate
			$sta_name wl status
		}
	}

	if {$::kpi_test_flag} {
		sts::kpi_dump_xml_data
	}

	regsub -all {NANDP} $report_html_results "NAN" report_html_results

	return $report_html_results	
}

proc sts::run_rvr_test {} {
	# access option array
	upvar {} {}

	#####################################################
	#######         Create CSV Data File        #########
	#####################################################
	sts::setup_csv_header

	UTF::Message INFO "" "************************Func:run_rvr_test***************************"

	set ::saved_hook_start_timestamp ""
	UTF::Message INFO "" "Cleared ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"

	set ::panic_msg ""
	set rvr_error_flag 0
	set ::gnuplot_xtic_label ""
	set ::gnuplot_x_max_rvr_val ""
	set attn_up_start ""
	set attn_up_end ""
	set attn_down_new_start ""
	set attn_down_start ""
	set attn_down_end ""
	set ::curr_attn_incr 0
	set rvr_loop_cnt 0

	if {$(attn_type) == 1} {
		set attn_range $(rvr_apsta_attn_range)
		set attn_disp_type "APSTA"
	} elseif {$(attn_type) == 2} {
		set attn_range $(rvr_sts_attn_range)
		set attn_disp_type "P2P"
	} elseif {$(attn_type) == 3} {
		set attn_range "0-90 90-0"
		set attn_disp_type "WLAN&P2P"
	}

	UTF::Message LOG "" "attn_range=$attn_range"

	UTF::Message LOG "" "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"

	set attn_direction_changed_flag 0
	set attn_adjustment_value 0

	foreach attn_element $attn_range {

		# for range "x-y": 
		if {[regexp {([0-9]+)\-([0-9]+)} $attn_element match range1 range2]} {
			if {$range1 <= $range2} {
				set attn_up_start $range1
				set attn_up_end $range2
				set attn_val $attn_up_start
				set max_loop_cnt [expr {$attn_up_end - $attn_up_start + $::rvr_attn_incr}]
				set attn_direction up
				set attn_adjustment_value 0
			} else {
				set attn_down_start $range1
				set attn_down_end $range2

				if {$attn_down_new_start != ""} {
					UTF::Message LOG "" "attn_down_new_start=$attn_down_new_start"
					set attn_down_start $attn_down_new_start
				}
				
				set attn_val $attn_down_start
				set max_loop_cnt [expr {$attn_down_start - $attn_down_end + $::rvr_attn_incr}]
				set attn_direction down
				set attn_direction_changed_flag 1
				set attn_adjustment_value 0
			}
		} else {
			# for single value
			if {[regexp {^[+-]?[0-9]+$} $attn_element]} {
				set attn_val $attn_element
				set max_loop_cnt 1
				set attn_direction up
			}
		}

		if {$::curr_attn_value == $attn_val} {
			# this is a repeat attn since we changes direction. Skip this attn
			
			UTF::Message LOG "" "skip attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"

			set max_loop_cnt [expr {$max_loop_cnt - 1}]
			
			if {$attn_direction == "up"} {
				set attn_val [expr {$attn_val + $::rvr_attn_incr}]
			} else {
				set attn_val [expr {$attn_val - $::rvr_attn_incr}]
			}
		}

		UTF::Message LOG "" "===================================================================="
		set j 0
		while {$j < $max_loop_cnt} {

			# this block is done here so the report shows StS assoc on the report and not under the attn steps
			foreach sta_name $(sta) {
				UTF::Message LOG "" "RvR $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Re-Assoc: ::array_sta_sts_active_flag(${sta_name})=$::array_sta_sts_active_flag(${sta_name}) ::array_sta_sts_disassociated_flag(${sta_name})=$::array_sta_sts_disassociated_flag(${sta_name})"
				# ::array_sta_sts_disassociated_flag > 0 must try to re-assoc
				if {$::array_sta_sts_active_flag(${sta_name}) == 1 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
					UTF::Message LOG "" "-------------------------------------------RvR $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Re-Assoc-------------------------------------------"
					sts::slave_join_master $sta_name 0 1
				}
			}
		
			UTF::Try "$attn_disp_type Attn $attn_val" {

				foreach sta_name $(sta) {
					if {$::array_sta_apsta_active_flag(${sta_name}) == 1 && $::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
						UTF::Message LOG "" "-------------------------------------------RvR APSTA Assoc Check-------------------------------------------"
						sts::check_sta_apsta_association $sta_name
					}

					# ::array_sta_sts_disassociated_flag > 0 must try to re-assoc
					if {$::array_sta_sts_active_flag(${sta_name}) == 1 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
						UTF::Message LOG "" "-------------------------------------------RvR $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Assoc Check-------------------------------------------"
						sts::check_sta_sts_association $sta_name
					}
				}

				UTF::Message LOG "" "attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"

				if {$(attn_type) == 1 || $(attn_type) == 3} {
					set catch_resp [catch {$::rvr_apsta_attngrp attn $attn_val} catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "Attenuator failed at $attn_val"
						error "Attenuator failed at $attn_val"							
					}
				} 
				
				if {$(attn_type) == 2 || $(attn_type) == 3} {
					set catch_resp [catch {$::rvr_sts_attngrp attn $attn_val} catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "Attenuator failed at $attn_val"
						error "Attenuator failed at $attn_val"							
					}
				}

				if {$::curr_attn_value == -1} {
					set ::curr_attn_incr $::rvr_attn_incr
				} else {
					set ::curr_attn_incr [expr {abs($attn_val - $::curr_attn_value)}]
				}
				
				set ::curr_attn_value $attn_val

				UTF::Sleep .1

				#####################################################
				#######        Attn n - Run This test       #########
				#####################################################
				incr rvr_loop_cnt
				set html_results [sts::run_test $rvr_loop_cnt]

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "B" "::UTF::panic=$::panic_msg"
					set rvr_error_flag 1
					break
				}

				if {$::test_error_flag == 0} {
					return "html: $html_results"
				} else {
					set rvr_error_flag 1
					error "html: $html_results"
				}
				# end of UTF::Try Attn
			}

			# check for panic, trap, assert message
			if {[info exists ::UTF::panic] || $::panic_msg != ""} {
				if {$::panic_msg == ""} {
					set ::panic_msg "($::UTF::panic)"
				}
				UTF::Message INFO "C" "::UTF::panic=$::panic_msg"
				set rvr_error_flag 1
				incr ::error_cnt
				error "$::panic_msg"
			}

			if {$::error_cnt > 0} {
				error "html: $::halt_test_err"
			}
		
			UTF::Message INFO "" "clear stream ::curr_test_no=$::curr_test_no ::curr_stream_no=$::curr_stream_no test results data arrays"
			sts::array_setup_stream_data $::curr_test_no $::curr_stream_no 0 1 0 1

			set up_direction_break_flag 0
			if {$attn_direction == "up"} {				
				foreach sta_name $(sta) {

					UTF::Message INFO "" "apsta_disassociated_flag=$::array_sta_apsta_disassociated_flag(${sta_name})"
					UTF::Message INFO "" "sts_disassociated_flag=$::array_sta_sts_disassociated_flag(${sta_name})"

					if {$(attn_type) == 1 && $::array_sta_apsta_disassociated_flag(${sta_name}) >= 3} {
						UTF::Message INFO "" "APSTA is disconnected for the past 3 steps for STA $sta_name. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}

					if {$(attn_type) == 2 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 3} {
						UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is disconnected for the past 3 steps for STA $sta_name. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}

					if {$(attn_type) == 3 && $::array_sta_apsta_disassociated_flag(${sta_name}) >= 3 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 3} {
						UTF::Message INFO "" "APSTA & $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) are disconnected for the past 3 steps for STA $sta_name. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}
				}
				
				if {$up_direction_break_flag == 1} {
					set attn_up_end $attn_val
					set attn_down_new_start $attn_val
				}
			}

			if {[expr {[expr {$attn_val + 1}] % 10}] == 1 || ($attn_direction == "up" && $attn_val == $attn_up_end)} {
				if {$::curr_gnuplot_data_line_cnt > 0 && $::gnuplot_xtic_label != ""} {
					set ::gnuplot_xtic_label "$::gnuplot_xtic_label,"
				}
				set graph_attn_val [expr {$attn_val + $::testbed_path_loss}]
				set tmp_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $attn_adjustment_value}]
				set ::gnuplot_xtic_label "$::gnuplot_xtic_label\'$graph_attn_val\' $tmp_gnuplot_data_line_cnt"
				set ::gnuplot_x_max_rvr_val $tmp_gnuplot_data_line_cnt
				UTF::Message INFO "" "xtic $graph_attn_val $tmp_gnuplot_data_line_cnt attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
			}

			if {$attn_direction == "up"} {				
				if {$up_direction_break_flag == 1} {
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}

				# when rvr_attn_incr>=2, do not skip the highest up attn
				if {$attn_val != $attn_up_end && [expr {$attn_val + $::rvr_attn_incr}] > $attn_up_end} {
					# start the down attn from this value otherwise odd number with rvr_attn_incr=2 could skip the "% 10" condition 
					set attn_down_new_start $attn_val
					set attn_val $attn_up_end
				} else {		
					set attn_val [expr {$attn_val + $::rvr_attn_incr}]
				}
				
				if {$attn_val > $attn_up_end} {
					UTF::Message INFO "" "attn up break out. attn_val=$attn_val attn_up_end=$attn_up_end loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}
			} else {
				set attn_val [expr {$attn_val - $::rvr_attn_incr}]
				
				if {$attn_val < $attn_down_end} {
					UTF::Message INFO "" "attn down break out. attn_val=$attn_val attn_down_end=$attn_down_end loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}
			}

			set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]

			set j [expr {$j + $::rvr_attn_incr}]
		}
	}

	# check for panic, trap, assert message
	set panic_err ""
	if {$::panic_msg != ""} {
		# failed
		UTF::Message INFO "D" "::UTF::panic=$::panic_msg"
		set rvr_error_flag 1
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::panic_msg]
		set panic_err "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
	}

	#####################################################
	#######         Create Summary Graphs       #########
	#####################################################
	set graph_err ""
	set rvr_img ""
	set ::throughput_png_file ""
	set catch_resp [catch {sts::create_summary_graphs} catch_msg]
	if {$catch_resp != 0} {
		# failed
        UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set rvr_error_flag 1
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $catch_msg]
		set graph_err "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
	} else {
		set testnum [sts::get_testnum]
		regsub -all {.} $testnum "_" $testnum
		set rvr_img "<br><p><a href=\"GraphsData/$testnum.StaThroughput.htm\"><img src=\"$::throughput_png_file\" alt=\"\" width=\"720\" height=\"480\" border=\"0\"></a></p>"
	}

	if {$rvr_error_flag == 0} {
		return "$rvr_img"
	} else {
		set ::test_error_flag 1
		return "<font color=\"red\"><b>RvR Test Failed</b></font>$panic_err$graph_err$rvr_img"
	}
}

proc sts::run_test {rvr_loop_cnt} {
	# access option array
	upvar {} {}

	catch {unset ::array_streams_last_BeaconRate_time}
	catch {unset ::array_streams_last_BeaconRate}
	catch {unset ::array_streams_error}

	set ::iperf_running_flag 0
	set ::test_error_flag 0
	set ::streams_total_time 0
	set ::rvr_zero_throughput_flag 0

	set run_test_flag 0

	if {$::bt_only_flag} {
		set run_test_flag 1
	}

	UTF::Message INFO "" "************************Func:run_test***************************"

	UTF::Message INFO "" "::array_streams_total_streams_label(${::curr_test_no})='$::array_streams_total_streams_label(${::curr_test_no})'"
	UTF::Message INFO "" "----------------------------------------------------------------"

	set sta_cnt 0
	foreach sta_name $(sta) {
		incr sta_cnt
	
		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++STA $sta_cnt $sta_name++++++++++++++++++++++++++++++++++++++++++++"

		if {$::rvr_test_flag == 0} {
			if {$::array_sta_apsta_active_flag(${sta_name}) == 1 && $::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
				#####################################################
				#######      Check STA APSTA Association     #########
				#####################################################
				sts::check_sta_apsta_association $sta_name
			}
			UTF::Message INFO "" "::array_sta_apsta_active_flag(${sta_name})=$::array_sta_apsta_active_flag(${sta_name}) ::array_sta_apsta_disassociated_flag(${sta_name})=$::array_sta_apsta_disassociated_flag(${sta_name})"
			if {$::array_sta_sts_active_flag(${sta_name}) == 1 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
				#####################################################
				#######       Check STA P2P Association     #########
				#####################################################
				sts::check_sta_sts_association $sta_name
			}
			UTF::Message INFO "" "::array_sta_sts_active_flag(${sta_name})=$::array_sta_sts_active_flag(${sta_name}) ::array_sta_sts_disassociated_flag(${sta_name})=$::array_sta_sts_disassociated_flag(${sta_name})"
		}
		
		# check for APSTA throughput test to be run
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			if {$::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
				UTF::Message INFO "" "APSTA is disassociated"

				# mark all the streams for this GC with throughput_skipped_flag
				for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

					set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
						}

						if {$stream_sta_obj == $sta_name} {
							UTF::Message INFO "" "::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no})=1 for APSTA STA $sta_name"
							set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
						}
					}
				}
			} else {
				# APSTA test needs to run
				UTF::Message INFO "" "APSTA run_test_flag=1"
				set run_test_flag 1
			}
		}

		# check for StS throughput test to be run
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			if {$::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is disassociated"

				# mark all the StS streams for this Slave with throughput_skipped_flag
				for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

					set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) != "APSTA"} {
						# always StS Slave interface
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
						}
						
						if {$stream_sta_obj == $sta_name} {
							UTF::Message INFO "" "::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no})=1 for $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) STA $sta_name"
							set ::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) 1
						}
					}
				}
			} else {
				# StS test needs to run
				UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) run_test_flag=1"
				set run_test_flag 1
			}
		}
	}
	
	if {$run_test_flag == 1} {
		#####################################################
		##############     Start Sniffer     ################
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			set ::sniffer_filename "sniffer_ch$::sniffer_channel.pcap"
			regsub {\/} $::sniffer_filename "_" ::sniffer_filename

			UTF::Message INFO "" "###########################Start Sniffer######################################"
			set catch_resp [catch {$::sniffer_object start "tshark -i prism0 -w /tmp/$::sniffer_filename"} catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

			if {$catch_resp == 0} {
				set ::sniffer_start_time_secs [clock seconds]
				set sniffer_timestamp [clock format $::sniffer_start_time_secs -format "%H:%M:%S"]
				UTF::Message INFO "" "###########################Sniffer Started @ '$sniffer_timestamp'######################################"
				set ::sniffer_process_id $catch_msg
				set ::sniffer_started_flag 1
			} else {
				set ::test_error_flag 1
				set msg "Sniffer did not start"
				UTF::Message ERROR "" "***Failed. $msg."
				if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
					append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
				}
			}
		}

		#########################################
		# Stop all server streams
		#########################################
		sts::close_iperf_traffic
		sts::stop_iperf_traffic
		sts::stop_all_server_streams

		#########################################
		# MacOS AWDL Link Activation - Only for OSX AWDL (Not Linux AWDL)
		#########################################
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "AWDL" && $::array_streams_src_host_type(${::curr_test_no},${stream_no}) == "MacOS"} {
				set sts_master $::array_streams_src_sta(${::curr_test_no},${stream_no})
				set sts_slave $::array_streams_dst_sta(${::curr_test_no},${stream_no})
				UTF::Message INFO "" "stream_no='$stream_no' sts_master='$sts_master' sts_slave='$sts_slave'"
				sts::awdl_macos_link_activate $sts_master $sts_slave
				break
			}
		}

		#########################################
		# Start all iperf servers
		#########################################
		sts::start_all_server_streams

		UTF::Message INFO "" "************************pre_perf_hook***************************"
		#########################################
		# Process pre_perf_hook
		#########################################
		sts::process_perf_hook pre_perf_hook 0 0

		if {($::rvr_test_flag == 1 && $rvr_loop_cnt == 1) || $::rvr_test_flag == 0} {
		
			# run Pre-Throughputs only for non-RvR test or the 1st step of the RvR test
			# Do not run Pre-Throughputs for MacOS AWDL tests, since it causes issue some times
			
			if {!($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "APSTA" && $::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS" && $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "AWDL")} {
				#####################################################
				#### Start Pre-Throughputs for this test Streams ####
				#####################################################
				sts::start_pre_throughputs

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					return "panic"
				}

				#########################################
				# Stop all server streams
				#########################################
				sts::close_iperf_traffic
				sts::stop_iperf_traffic
				sts::stop_all_server_streams

				#########################################
				# Start all server streams
				#########################################
				sts::start_all_server_streams
			}
		}
		
		#####################################################
		#######       Start This test Streams       #########
		#####################################################
		sts::start_all_client_streams

		#####################################################
		#######     Process Test Streams Result     #########
		#####################################################
		sts::process_test_set_streams_results
	} else {
		UTF::Message INFO "" "Skipped running iperf."
		# iperf is skipped but we need to wait 'iperf time' in RvR for the test to be smooth to re-join
		# the sleep is done in check_sta_apsta_association and check_sta_sts_association
		
		#########################################
		# Process post_perf_hook
		#########################################
		sts::process_perf_hook post_perf_hook 0 1
	}

	#####################################################
	#######      Create Test Streams Graphs     #########
	#####################################################
	if {$::rvr_zero_throughput_flag == 1 || $run_test_flag == 0} {

		set apsta_disassociated_flag 0
		set sts_disassociated_flag 0
		set sta_cnt 0
		foreach sta_name $(sta) {
			incr sta_cnt
			UTF::Message INFO "" "++++++++++++++++++++++++++++++++++STA $sta_name++++++++++++++++++++++++++++++++++++++++++++"
			if {$::array_sta_apsta_active_flag(${sta_name}) == 1 && $::array_sta_apsta_disassociated_flag(${sta_name}) >= 1} {
				set apsta_disassociated_flag 1
			}
			if {$::array_sta_sts_active_flag(${sta_name}) == 1 && $::array_sta_sts_disassociated_flag(${sta_name}) >= 1} {
				set sts_disassociated_flag 1
			}
		}

		set assoc_msg ""
		
		if {$apsta_disassociated_flag == 1} {
			set assoc_msg [concat $assoc_msg "APSTA is NOT associated. "]
		}
		
		if {$sts_disassociated_flag == 1} {
			set assoc_msg [concat $assoc_msg "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) is NOT associated. "]
		}

		if {$run_test_flag == 0} {
			set assoc_msg [concat $assoc_msg "Skip running iperf."]
		} else {
			set assoc_msg [concat $assoc_msg "No Throughput."]
		}

		set rc "<font color=\"red\"><b>$assoc_msg</b></font>"
	} else {
		set rc [sts::create_test_set_streams_graphs]
	}

	#####################################################
	######  Write Throughput Result to CVS File  ########
	#####################################################
	if {$::rvr_test_flag == 1} {
		UTF::Message INFO "" "###########################RvR Write Throughput Result to CVS File######################################"
		sts::array_write_csv_data 0 1
	}

	UTF::Message INFO "" "#################################################################"

	return $rc
}

proc sts::process_all_tests {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:process_all_tests***************************"

	for {set test_cnt 1} {$test_cnt <= $::array_streams_test_cnt} {incr test_cnt} {

		set ::curr_test_no $test_cnt
		set ::curr_stream_no 1

		if {$::kpi_test_flag} {
			if {$::array_streams_ap_controller(${::curr_test_no}) == ""} {
				$::kpi_base_db set "test_type" "Direct"
			} else {
				$::kpi_base_db set "test_type" "Infra\+AWDL"
			}
		}

		# current_time
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]

		if {$test_cnt == 1} {

			UTF::Message INFO "" "===================================Setup Only Once========================================================="
		
			UTF::Message INFO "" "-----------------------------Reset STA status $current_time------------------------------------------"

			foreach sta_apsta_d_index $(sta) {
				set ::array_sta_apsta_active_flag(${sta_apsta_d_index}) 0
				set ::array_sta_sts_active_flag(${sta_apsta_d_index}) 0
				set ::array_sta_apsta_disassociated_flag(${sta_apsta_d_index}) 0
				set ::array_sta_sts_disassociated_flag(${sta_apsta_d_index}) 0
			}

			#########################################
			# setup_perf_hook
			#########################################
			sts::setup_perf_hook

			# setup apsta only for P2P
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "P2P"} {
					# StS link
					sts::setup_p2p_apsta $stream_no
					break
				}
			}

			set setup_awdl_flag 0
		
			for {set stream_cnt 1} {$stream_cnt <= $::array_streams_cnt(${::curr_test_no})} {incr stream_cnt} {

				set ::curr_stream_no $stream_cnt

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_cnt}) == "BITX"} {
					# only BIRX needs to be processed
					continue
				}

				UTF::Message INFO "" "::curr_test_no='$::curr_test_no' stream_cnt='$stream_cnt' ::array_streams_link_type(${::curr_test_no},${stream_cnt})='$::array_streams_link_type(${::curr_test_no},${stream_cnt})'"

				if {$::array_streams_link_type(${::curr_test_no},${stream_cnt}) == "APSTA"} {

					#####################################################
					################   Setup AP Radio   #################
					#####################################################
					if {$::array_streams_ap(${::curr_test_no}) != ""} {
						sts::setup_ap_radio_channel $::array_streams_ap(${::curr_test_no}) $::array_streams_apsta_link_chan(${::curr_test_no})

						if {$::error_cnt > 0} {
							continue
						}
					}

					#####################################################
					############   Create AP Connection   ###############
					#####################################################
					sts::create_ap_connection

					if {$::error_cnt > 0} {
						continue
					}
				}

				#####################################################
				##### Current Measurement before StS association ####
				#####################################################
				if {$::agilent_obj != ""} {
					UTF::Try "Current Measurement ($::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Not Associated)" {
						set ::cct_key "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) Not Associated"
						sts::measure_idle_current					
						return "html: $::current_results"
					}
				}

				switch $::array_streams_link_type(${::curr_test_no},${stream_cnt}) {

					P2P {
						sts::setup_p2p_go
						sts::setup_p2p_gc
					}

					AWDL {
						if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
							sts::setup_macos_awdl
						} else {
							sts::setup_linux_idle_awdl
							set setup_awdl_flag 1
							set setup_awdl_stream_no $::curr_stream_no
						}
					}

					NANDP {
						sts::setup_nan
					}

					BT {
					}

					AIBSS {
					}

					11mc {
					}
				}

				if {$::error_cnt > 0} {
					error "ERROR: 'Setup for '$::array_streams_link_type(${::curr_test_no},${stream_cnt})' failed. Halting tests!" 
				}

				if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${::curr_stream_no})] != -1} {

					#####################################################
					################### Setup StS PM ####################
					#####################################################
					if {$(pm_mode) != ""} {
						set link_type $::array_streams_link_type(${::curr_test_no},${::curr_stream_no})
						regsub -all {NANDP} $link_type "NAN" link_type_disp
						
						if {$link_type != "AWDL" && $link_type != "NANDP"} {
						
							UTF::Try "Setup $link_type PM $(pm_mode)" {

								# PM mode should not be set on Master/GO

								set failed_flag 0 
								foreach sta_name "$::array_streams_sts_master_sta_list(${::curr_test_no}) $::array_streams_sts_slave_sta_list(${::curr_test_no})" {
									set set_pm_flag 1 
									UTF::Message INFO "" "************************sta_name=$sta_name with $::array_streams_link_type(${::curr_test_no},${::curr_stream_no})=$::array_sta_sts(${sta_name})***************************"
									if {$sta_name == $::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})} {
										UTF::Message INFO "" "Master/GO PM mode should not be changed"
										set set_pm_flag 0 
									}
									catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) dtim}
									catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) PM}
									if {$set_pm_flag == 1} {
										catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) PM $(pm_mode)}
										UTF::Sleep 3
										set catch_resp [catch {$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) PM} catch_msg]
										if {$catch_msg != $(pm_mode)} {
											set failed_flag 1 
										}
									}
								}
								if {$failed_flag} {
									error "PM mode is not $(pm_mode)" 
								}

								return "PM $(pm_mode)"
							}
						}
					}

					if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) != "AWDL"} {
						foreach sta_name $::array_streams_sts_slave_sta_list(${::curr_test_no}) {
							#####################################################
							##############       GC Join GO      ################
							#####################################################
							# GC joining GO fails randomly, therefore
							# retry is added for now till this issue is fixed
							for {set retry_cnt 0} {$retry_cnt < 5} {incr retry_cnt} {

								UTF::Message INFO "" "sts::slave_join_master $sta_name retry count $retry_cnt 0"

								set ::error_cnt 0
								sts::slave_join_master $sta_name $retry_cnt 0

								if {$::error_cnt > 0} {
									UTF::Message INFO "" "***Failed. sts::slave_join_master $sta_name retry count $retry_cnt failed"
									UTF::Sleep 5
									# retry
									continue
								}

								# passed
								break
							}
						}

						if {$::error_cnt > 0} {
							switch $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) {
							
								P2P {
									set msg "P2P GCr Join GO"
								}

								AWDL {
									set msg "AWDL Slave Join Master"
								}

								NANDP {
									set msg "NAN Non-Master Join Master"
								}
								
								default {
									set msg "UNKNOWN Join"
								}
							}
							
							error "ERROR: '$msg failed. Halting tests!" 
						}
					}

					sts::free_memory_after_sts_assoc

					if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
						#########################################
						# PCAP Dump Start
						#########################################
						if {$::macos_pcap_debug_flag} {
							sts::macos_pcap_debug_dump_start 1
						}

						if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "AWDL"} {
							#########################################
							# Get AWDL Discovery Time
							#########################################
							sts::awdl_discovery_time
						}

						#########################################
						# PCAP Dump Stop
						#########################################
						if {$::macos_pcap_debug_flag} {
							sts::macos_pcap_debug_dump_stop
						}
					}
				}
			}

			if {$setup_awdl_flag} {
				#########################################
				# Setup AWDL Linux for running throughput
				#########################################
				set ::curr_stream_no $setup_awdl_stream_no
				sts::setup_linux_awdl
			}
		}

		#####################################################
		# update streams sts link macaddr and ipv6_macaddr ##
		#####################################################
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			foreach sta_name "$::array_streams_src_sta(${::curr_test_no},${stream_no}) $::array_streams_dst_sta(${::curr_test_no},${stream_no})" {

				if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
					# StS link
					if {$sta_name == $::array_streams_src_sta(${::curr_test_no},${stream_no})} {
						set ::array_streams_src_macaddr(${::curr_test_no},${stream_no}) $::array_sta_sts_macaddr(${sta_name})
						set ::array_streams_src_ipv6_macaddr(${::curr_test_no},${stream_no}) $::array_sta_sts_ipv6_macaddr(${sta_name})
					} elseif {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no})} {
						set ::array_streams_dst_macaddr(${::curr_test_no},${stream_no}) $::array_sta_sts_macaddr(${sta_name})
						set ::array_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no}) $::array_sta_sts_ipv6_macaddr(${sta_name})
					}
				}
			}

			UTF::Message INFO "" "===================================Setup Only Once is Done========================================================="
		}

		##########################################################
		# update ping streams sts link macaddr and ipv6_macaddr ##
		##########################################################
		for {set ping_stream_no 1} {$ping_stream_no <= $::array_ping_streams_cnt(${::curr_test_no})} {incr ping_stream_no} {
			foreach sta_name "$::array_ping_streams_src_sta(${::curr_test_no},${ping_stream_no}) $::array_ping_streams_dst_sta(${::curr_test_no},${ping_stream_no})" {

				if {[lsearch -exact $::sts_link_types $::array_ping_streams_link_type(${::curr_test_no},${ping_stream_no})] != -1} {
					# StS link
					if {$sta_name == $::array_ping_streams_src_sta(${::curr_test_no},${ping_stream_no})} {
						set ::array_ping_streams_src_macaddr(${::curr_test_no},${ping_stream_no}) $::array_sta_sts_macaddr(${sta_name})
						set ::array_ping_streams_src_ipv6_macaddr(${::curr_test_no},${ping_stream_no}) $::array_sta_sts_ipv6_macaddr(${sta_name})
					} elseif {$sta_name == $::array_ping_streams_dst_sta(${::curr_test_no},${ping_stream_no})} {
						set ::array_ping_streams_dst_macaddr(${::curr_test_no},${ping_stream_no}) $::array_sta_sts_macaddr(${sta_name})
						set ::array_ping_streams_dst_ipv6_macaddr(${::curr_test_no},${ping_stream_no}) $::array_sta_sts_ipv6_macaddr(${sta_name})
					}
				}
			}
		}

		#####################################################
		# update streams interface status                  ##
		#####################################################
		sts::setup_list_active_interface_objects
		set ::array_streams_interface_existing_list(${::curr_test_no}) $::array_streams_interface_active_list(${::curr_test_no})

		UTF::Message INFO "" "============================================***************Info test_no=$::curr_test_no***************============================================"
		UTF::Message INFO "" "::array_streams_total_streams_label(${::curr_test_no})='$::array_streams_total_streams_label(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_interface_possible_list(${::curr_test_no})='$::array_streams_interface_possible_list(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_interface_existing_list(${::curr_test_no})='$::array_streams_interface_existing_list(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_interface_active_list(${::curr_test_no})='$::array_streams_interface_active_list(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_apsta_sta_list(${::curr_test_no})='$::array_streams_apsta_sta_list(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_sts_master_sta_list(${::curr_test_no})='$::array_streams_sts_master_sta_list(${::curr_test_no})'"
		UTF::Message INFO "" "::array_streams_sts_slave_sta_list(${::curr_test_no})='$::array_streams_sts_slave_sta_list(${::curr_test_no})'"
		UTF::Message INFO "" "============================================"


		if {$test_cnt == 1} {

			UTF::Message INFO "" "===================================Setup Only Once========================================================="
		
			#########################################
			# Check OTP
			#########################################
			sts::validate_mac_addr
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}

			#########################################
			# Setup frameburst
			#########################################
			sts::setup_frameburst
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}

			if {$(new_beacon_interval) != ""} {
				sts::change_beacon_interval $(new_beacon_interval)
			}

			UTF::Message INFO "" "===================================Setup Only Once is Done========================================================="
		}
		
		if {$::agilent_obj != ""} {

			UTF::Try "DTIM Interval Measurement (No Traffic)" {
				UTF::Message INFO "" "15 sec delay to make sure we are idle and the previous test is done with sending packets"  
				UTF::Sleep 15
				foreach STA $(sta) {
					catch {$STA wl dtim}
					catch {$STA wl PM}
				}

				set ::cct_key "DTIM No Traffic"
				sts::measure_dtim_interval					
				return "html: $::current_results"
			}
		
			UTF::Try "Current Measurement (No Traffic)" {
				foreach STA "$::array_streams_interface_active_list(${::curr_test_no})" {
					catch {$STA wl dtim}
					catch {$STA wl PM}
				}
				set ::cct_key "No Traffic"
				sts::measure_idle_current

				set current_results $::current_results

				UTF::Message INFO "" "**********************************************************************************************"
				UTF::Message INFO "" "**********************Setup instrument for the measurement with traffic***********************"
				sts::setup_current_measurement_with_traffic

				return "html: $current_results"
			}
		}

		#####################################################
		#######     Setup Sniffer for Non-Roaming    ########
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			UTF::Try "Setup Sniffer Channel $::sniffer_channel" {
				$::sniffer_object setupSniffer $::sniffer_channel
			}
		}

		#####################################################
		##############    Connection Test    ################
		#####################################################
		if {$::roaming_test_flag == 0} {
			UTF::Message INFO "" "connection_test before each test"
			sts::connection_test
		}

		if {$::channel_sweep_test_flag} {
			UTF::Message INFO "" "channel_sweep_test"
			sts::channel_sweep_test
			# kevin
			exit
		}

		#########################################
		# PCAP Dump Start
		#########################################
		if {$::macos_pcap_debug_flag} {
			sts::macos_pcap_debug_dump_start 0
		}

		if {$::rvr_test_flag == 0} {
			#####################################################
			#######          Non RvR or Roaming         #########
			#####################################################

			UTF::Try "$::array_streams_total_streams_label(${::curr_test_no})" {
				#####################################################
				#######         Create CSV Data File        #########
				#####################################################
				sts::setup_csv_header

				#####################################################
				#######             Run This test           #########
				#####################################################
				set ::curr_attn_value 0
				set html_results [sts::run_test 0]

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "A" "::UTF::panic=$::panic_msg"
					set ::test_error_flag 1
				}

				#####################################################
				#######         Create Summary Graphs       #########
				#####################################################
				set graph_err ""
				set catch_resp [catch {sts::create_summary_graphs} catch_msg]
				if {$catch_resp != 0} {
					# failed
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					set ::test_error_flag 1
					# html conversion 
					set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $catch_msg]
					append html_results "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
				} else {
					set html_results "$html_results"				
				}

				if {$::roaming_test_flag == 1} {
					set ::roaming_html_results $html_results				
					UTF::Message LOG "" "Saved roaming html_results='$::roaming_html_results'"
				}

				if {$::test_error_flag == 0} {
					return "html: $html_results"
				} else {
					error "html: $html_results"
				}
			}
		} else {
			#####################################################
			#######                 RvR                 #########
			#####################################################

			if {$(attn_type) == 1} {
				set ::attn_type_label "RvR-APSTA: "
			} elseif {$(attn_type) == 2} {
				if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "NANDP"} {
					set ::attn_type_label "RvR-NAN: "
				} elseif {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "AWDL"} {
					set ::attn_type_label "RvR-AWDL: "
				} else {		
					set ::attn_type_label "RvR-P2P: "
				}
			} elseif {$(attn_type) == 3} {
				if {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "NANDP"} {
					set ::attn_type_label "RvR-APSTA&NAN: "
				} elseif {$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) == "AWDL"} {
					set ::attn_type_label "RvR-APSTA&AWDL: "
				} else {				
					set ::attn_type_label "RvR-APSTA&P2P: "
				}
			}

			set test_title "$::attn_type_label$::array_streams_total_streams_label(${::curr_test_no})"
			set ::graph_label_test "$::attn_type_label$::graph_label_test"

			UTF::Try "$test_title" {
				#####################################################
				#######           Run This RvR test         #########
				#####################################################
				set ::curr_attn_value -1
				set rvr_html_results [sts::run_rvr_test]

				if {$::test_error_flag == 0} {
					return "html: $rvr_html_results"
				} else {
					error "html: $rvr_html_results"
				}
			}
		}

		# check for panic, trap, assert message
		if {[info exists ::UTF::panic]} {
			set ::panic_msg "($::UTF::panic)"
			UTF::Message INFO "E" "::UTF::panic=$::panic_msg"
			set ::test_error_flag 1
		}

		if {$::socram_dump_flag} {
			#####################################################
			#############     dhd_socram_dump     ###############
			#####################################################
			sts::dhd_socram_dump
		}
		
		#########################################
		# PCAP Dump Stop
		#########################################
		if {$::macos_pcap_debug_flag} {
			sts::macos_pcap_debug_dump_stop
		}

		sts::get_dhd_memory_dump

		#########################################
		# Free Memory After the Test
		#########################################
		foreach STA $(sta) {
			UTF::Try "$STA: Free Memory After Test (K)" {
				# retry is needed due to issues with NPC serial port
				for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
					set catch_resp [catch "$STA freekb" catch_msg]
					UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						break
					}
				}

				if {$catch_resp == 1} {
					error $catch_msg							
				}

				set ret_val [format "%.7f" $catch_msg]
				set branch [$STA branchname]
				UTF::Test::memchart $ret_val -failonlow -key [list $branch $STA testfree] -units kb -title "Test Free"
			}
		}

		UTF::Message INFO "" "connection_test after each test"
		sts::connection_test

		sts::get_dhd_memory_dump

		#####################################################
		##############    Get Sniffer Data   ################
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			if {$::sniffer_started_flag} {
				$::sniffer_object stop $::sniffer_process_id
				set ::sniffer_started_flag 0
				UTF::Message INFO "" "###########################Sniffer Stopped After Throughput Run######################################"
			}
		
			sts::get_sniffer_data
		}

		if {$::panic_msg != "" || [info exists ::UTF::panic]} {
			UTF::Message INFO "" "Break due to ::panic_msg=$::panic_msg"
			break
		}

		if {$::error_cnt > 0 && $::halt_test_err != ""} {
			break
		}

		if {$(quick_exit)} {
		
			exit

			UTF::Try "Debug Info" {
				foreach interface_object $::array_streams_interface_existing_list(${::curr_test_no}) {

					# skip invalid interfaces
					if {[info exists ::array_sta_sta_flag(${interface_object})]} {
						# skip the AP/SoftAP interfaces
						if {$::array_sta_sta_flag(${interface_object}) != 1} {
							#UTF::Message INFO "" "$interface_object is not an STA. Skip."
							continue
						}
					}
					
					catch {$interface_object wl out}
					UTF::Message INFO "" "ooooooooooooooooooooooooooooooooooooooooooooooooooo"
				}
			}

			exit
		}

		if {$::bt_test_flag} {
			#####################################################
			##########    Stop BT iTune wav Play    #############
			#####################################################
			sts::bt_itune_stop
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}
		
		# end of foreach test_cnt - one group of simultaneous streams finished. Go to next test_cnt
	}

	UTF::Message INFO "" "------------------------loop 1 done---------------------------"

	if {$::agilent_obj != ""} {

		UTF::Try "DTIM Interval Measurement (No Traffic)" {
			UTF::Message INFO "" "15 sec delay to make sure we are idle and the previous test is done with sending packets"  
			UTF::Sleep 15
			foreach STA $(sta) {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}

			set ::cct_key "DTIM No Traffic"
			sts::measure_dtim_interval					
			return "html: $::current_results"
		}
		
		UTF::Try "Current Measurement (No Traffic)" {
			foreach STA "$::array_streams_interface_active_list(${::curr_test_no})" {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}
			set ::cct_key "No Traffic"
			sts::measure_idle_current					
			return "html: $::current_results"
		}
	}
}

proc sts::round_control_chart_stream_data {stream_data_list} {
	
	UTF::Message INFO "" "************************round_control_chart_stream_data***************************"

	set new_control_chart_data ""
	
	foreach data $stream_data_list {
		set new_data [expr {round($data)}]
		set new_control_chart_data [concat $new_control_chart_data $new_data]
	}
	
	return $new_control_chart_data
}

proc sts::total_control_chart_stream_data {stream_data_list} {
	
	UTF::Message INFO "" "************************total_control_chart_stream_data***************************"

	set total_control_chart_data 0
	
	foreach data $stream_data_list {
		set total_control_chart_data [expr {$total_control_chart_data + $data}]
	}
	
	return $total_control_chart_data
}

proc sts::build_control_chart_stream_data {stream_data_list} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************build_control_chart_stream_data***************************"

	set stream_data_cnt [llength $stream_data_list]
	UTF::Message INFO "" "stream_data_cnt=$stream_data_cnt"

	# max UTF control chart sample size is 25
	set utf_control_chart_sample_size 25
	set new_control_chart_data ""
	# if we have more data samples, then we need to integrate them
	if {$stream_data_cnt > $utf_control_chart_sample_size} {

		UTF::Message INFO "" "More than 25 data sample. Integrate them to 3 data sample"
		
		# How many data values needs to be averaged/integrated?

		# change the utf control chart scale
		set utf_control_chart_sample_size 3
		
		set average_data_cnt [expr {$stream_data_cnt / $utf_control_chart_sample_size}]
		UTF::Message INFO "" "average_data_cnt=$average_data_cnt"
		
		# math::integrate requires min 5 data points. It must be even number
		# average_data_cnt is at least 5 since we have more than 25 samples
		
		# is average_data_cnt even?
		if {[expr {$average_data_cnt % 2}] == 1} {
			set average_data_cnt [expr {$average_data_cnt - 1}]
			UTF::Message INFO "" "use even number average_data_cnt=$average_data_cnt"
		}
		
		UTF::Message INFO "" "================"

		set group_data_cnt 0
		set group_data_list ""
		foreach data [split $stream_data_list " "] {
			#UTF::Message INFO "" "data=$data"
			set group_data_list [concat $group_data_list "$group_data_cnt $data"]
			incr group_data_cnt
			#UTF::Message INFO "" "group_data_cnt=$group_data_cnt"

			if {$group_data_cnt == $average_data_cnt} {
				UTF::Message INFO "" "group_data_list=$group_data_list"
				set tmp [lindex [::math::integrate $group_data_list] 0]
				set integrated_data [format %0.1f [expr {$tmp / $average_data_cnt}]]
				UTF::Message INFO "" "integrated_data=$integrated_data"
				UTF::Message INFO "" "group_data_cnt=$group_data_cnt"
				set new_control_chart_data [concat $new_control_chart_data $integrated_data]
				UTF::Message INFO "" "new_control_chart_data=$new_control_chart_data"
				UTF::Message INFO "" "================"
				if {[llength $new_control_chart_data] == $utf_control_chart_sample_size} {
					break
				}
				set group_data_cnt 0
				set group_data_list ""
			}
		}
	} else {
		set new_control_chart_data $stream_data_list
	}
	
	return $new_control_chart_data
}

proc sts::process_test_set_streams_results {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:process_test_set_streams_results***************************"

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	
	if {$::agilent_obj != ""} {
		UTF::Message INFO "" "Get Agilent Current"
		set current_measure_start_time_secs [clock seconds]

		UTF::Message INFO "" "wait $(current_wait_sec) for the iperf to run, before Agilent starts reading the current data"
		UTF::Sleep $(current_wait_sec)
		
		set ::cct_key "With Traffic"
		sts::measure_current_with_traffic					

		set current_measure_time_elapsed_secs [expr {[clock seconds] - $current_measure_start_time_secs}]
		UTF::Message INFO "" "current_measure_time_elapsed_secs=$current_measure_time_elapsed_secs"
		
		set timeout_sec [expr {round([expr {$::streams_total_time + 1 - $current_measure_time_elapsed_secs}])}]	
		UTF::Message INFO "" "time left=$timeout_sec"
		
		if {$timeout_sec < 0} {
			set timeout_sec 1
			UTF::Message INFO "" "time left=$timeout_sec"
		}
	} else {
		set timeout_sec [expr {$::streams_total_time}]
	}

	if {$::roaming_test_flag} {
		#####################################################
		#######               Roaming               #########
		#####################################################

		UTF::Message INFO "" "========================Roaming==========================="

		# sniffer stages:
		# 	0 = start
		# 	1 = started
		# 	2 = wait
		# 	3 = stop
		# 	4 = stopped
		# 	5 = move sniffer data
		set sniffer_stage 0

		set pid_sniffer 0		
		set ::roamed_flag 0

		# for raoming, the first GC is only used
		set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

		set hook_start_time_secs [clock seconds]

		set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_pcap_file ".pcap"
		set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_csv_file ".csv"

		# Start roaming attenuation

		set src_ap_attn_val $::roaming_src_ap_attn_start
		set dst_ap_attn_val $::roaming_dst_ap_attn_start

		for {set loop_cnt 0} {$loop_cnt < $::roaming_max_loop_cnt} {incr loop_cnt} {

			set hook_start_time_ms [clock clicks -milliseconds]
			UTF::Message INFO "" "hook_start_time_ms=$hook_start_time_ms"
		
			if {!$::failover_test_flag} {

				# set smooth roaming attenuation
				$::roaming_src_ap_attn_group attn $src_ap_attn_val
				$::roaming_dst_ap_attn_group attn $dst_ap_attn_val
			} else {
				# set failover roaming attenuation
				switch $loop_cnt {
					0 {
						$::roaming_src_ap_attn_group attn $src_ap_attn_val
						$::roaming_dst_ap_attn_group attn $::max_attn
					}

					3 {
						# from AP goes away suddenly
						$::roaming_src_ap_attn_group attn $::max_attn
						$::roaming_dst_ap_attn_group attn $dst_ap_attn_val
					}
				}
			}

			set bssid ""
			set rssi ""
			set catch_resp [catch "$sta_name wl rssi" rssi]
			set catch_resp [catch "$sta_name wl bssid" bssid]

			# current_time
			set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
			set parts [split $time_ms "."]
			set round_down [lindex $parts 0]
			set fraction [lindex $parts 1]
			set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
			set current_time "$current_time.$fraction"
			# ---------------

			UTF::Message LOG "" "================== current_time=$current_time loop_cnt=$loop_cnt src_ap_attn_val=$src_ap_attn_val dst_ap_attn_val=$dst_ap_attn_val rssi=$rssi bssid=$bssid ======================="

			if {$::roamed_flag == 0 && $bssid == $::roaming_dst_ap_mac} {
				UTF::Message LOG "" "***********************************************************************************"
				UTF::Message LOG "" "************************************ ROAMED ***************************************"
				UTF::Message LOG "" "***********************************************************************************"

				set ::roamed_flag 1
				set ::array_streams_ap(${::curr_test_no}) [lindex $(ap) 1]
				UTF::Message LOG "" "::array_streams_ap(${::curr_test_no})=$::array_streams_ap(${::curr_test_no})"

				if {!$::failover_test_flag} {

					# for smooth roaming only, estimate the sniffer start value

					set start_val [expr {int($src_ap_attn_val) - 3}]

					UTF::Message LOG "" "Actual sniffer start attenuation value = $start_val"
					UTF::Message LOG "" "Parameter sniffer start attenuation value = $::roaming_sniffer_start_attn"
					if {$::roaming_sniffer_start_attn == ""} {
						set ::roaming_sniffer_start_attn $start_val
					}
				}

				if {$sniffer_stage == 0} {
					UTF::Message ERROR "" "***Failed. Roamed but sniffer is not started."
					set ::roaming_sniffer_failed_flag 1
					set ::roaming_sniffer_failed_msg "Roamed but sniffer is not started"
				}
			}

			if {($::failover_test_flag && $loop_cnt == $sniffer_failover_start_cnt) || ((!$::failover_test_flag) && $sniffer_stage == 0 && $::roaming_sniffer_start_attn != "" && $src_ap_attn_val >= $::roaming_sniffer_start_attn)} {

				UTF::Message LOG "" "*************************** Roaming Start Sniffer *****************************"

				# sniffer started
				set sniffer_stage 1

				set catch_resp [catch {$::sniffer_object startRoamCmdline "/root/bin/tshark_cmd_line"} catch_msg]
				if {$catch_resp != 0} {
					UTF::Message LOG "" "***Failed. Sniffer did not start"
					set pid_sniffer 0
					set ::roaming_sniffer_failed_flag 1
					set ::roaming_sniffer_failed_msg "Sniffer did not start"
				} else {
					UTF::Message LOG "" "PASS. Sniffer is started"
					set pid_sniffer $catch_msg
				}
				catch {$::sniffer_object ls -la /root/bin/$roaming_sniffer_pcap_file}
			} else {
				UTF::Message INFO "" "--------------------------------SNIFFER DEBUG----------------------------------"  
				if {$pid_sniffer > 0} {
					if {$sniffer_stage == 1 || $sniffer_stage == 2 || $sniffer_stage == 3} {

						set catch_resp [catch "exec ps -ef | grep \"iperf\"" catch_msg]					
						UTF::Message INFO "" "ps -ef catch_msg=$catch_msg"

						#set catch_resp [catch "$::sniffer_object rexec ps -ef" catch_msg]
						#UTF::Message INFO "" "$::sniffer_object ps -ef catch_msg=$catch_msg"

						set catch_resp [catch "$::sniffer_object rexec ps $pid_sniffer" catch_msg]
						UTF::Message INFO "" "$::sniffer_object ps tshark catch_msg=$catch_msg"

						if {[regexp -nocase "tshark" $catch_msg]} {
							UTF::Message INFO "" "Sniffer is collecting data"  
						} else {
							UTF::Message INFO "" "Sniffer is NOT running"  
							set ::roaming_sniffer_failed_flag 1
							set ::roaming_sniffer_failed_msg "Sniffer is NOT running"
						}

						catch {$::sniffer_object ls -la /root/bin/$roaming_sniffer_pcap_file}

						$::sniffer_object wl ver
					}
				}
				UTF::Message INFO "" "-----------------------------------------------------------------------"  

				# stop the sniffer if it is not already stopped
				if {$sniffer_stage != 3} {

					# stop the sniffer when we are roamed
					if {$bssid == $::roaming_dst_ap_mac} {

						#************************************ ROAMED ***************************************"

						if {$sniffer_stage == 1} {
							# sniffer wait
							set sniffer_stage 2
							UTF::Message LOG "" "******************* sniffer_stage == 2 (Roamed, wait 1 step) *********************"
						} elseif {$sniffer_stage == 2} {
							# sniffer wait
							set sniffer_stage 3
							UTF::Message LOG "" "******************* sniffer_stage == 3 (Roamed, wait 1 step) *********************"
						} elseif {$sniffer_stage == 3} {
							# sniffer stop
							set sniffer_stage 4
							# only stop the sniffer. do not bring over sniffer file since it takes time
							catch {$::sniffer_object stopall}

							UTF::Message LOG "" "******************* sniffer_stage == 4 (Stopped Sniffer) *********************"
						}
					}
				} else {
					# roaming / sniffer is done
					# do not break from the loop, otherwise the graphs x-axis will not be right
				}
			}

			#########################################
			# Process post_perf_hook
			#########################################
			sts::process_perf_hook post_perf_hook 1 1
			
			UTF::Message INFO "" "---------------------------------------------------------------"

			if {!$::failover_test_flag} {

				# attenuation changes will only happen for smooth roaming

				if {$src_ap_attn_val < $::roaming_src_ap_attn_end} {
					incr src_ap_attn_val
				}

				if {$dst_ap_attn_val > $::roaming_dst_ap_attn_end} {
					set dst_ap_attn_val [expr {$dst_ap_attn_val - 1}]
				}

				if {$dst_ap_attn_val < 0} {
					set dst_ap_attn_val 0
				}

				if {[expr {$loop_cnt + 1}] == $::roaming_max_loop_cnt && $::roamed_flag == 0} {
					# still not roamed and this is the end of the loop
					# rssi values are not exact calculations, therefore increase the loop count

					if {$loop_cnt < 40} {
						set loop_cnt [expr {$loop_cnt + 5}]
					}
				}
			}

			set hook_time_elapsed_ms [expr {[clock clicks -milliseconds] - $hook_start_time_ms}]
			UTF::Message INFO "" "hook_time_elapsed_ms=$hook_time_elapsed_ms"

			set dwell_time_ms [expr {$::roaming_dwell_time_sec * 1000.0}]
			
			set dwell_time_left_ms [expr {$dwell_time_ms - $hook_time_elapsed_ms}]	

			if {$dwell_time_left_ms < 0} {
				set dwell_time_left_ms 0
				UTF::Message INFO "" "NEW dwell_time_left_ms=$dwell_time_left_ms"
			}

			set dwell_time_left_ms [format "%2.3f" [expr {$dwell_time_left_ms / 1000.0}]]
			UTF::Message INFO "" "dwell_time_left_ms=$dwell_time_left_ms"

			UTF::Sleep $dwell_time_left_ms
		}

		# stop the sniffer if still running
		if {$sniffer_stage == 1 || $sniffer_stage == 2 || $sniffer_stage == 3 || $sniffer_stage == 4} {
			UTF::Message LOG "" "******************* exit sniffer *********************"
			# sniffer stopped
			set sniffer_stage 5
			sts::roaming_stop_sniffer
			UTF::Message LOG "" "******************* sniffer_stage == 5 (Moved Sniffer Data) *********************"
		}

		set hook_time_elapsed_secs [expr {[clock seconds] - $hook_start_time_secs}]
		UTF::Message INFO "" "hook_time_elapsed_secs=$hook_time_elapsed_secs"

		set timeout_sec [expr {round([expr {$::streams_total_time + 1 - $hook_time_elapsed_secs}])}]	
		UTF::Message INFO "" "time left=$timeout_sec"

		if {$timeout_sec < 1} {
			set timeout_sec 1
		}

		UTF::Message INFO "" "************************last post_perf_hook***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		sts::process_perf_hook post_perf_hook 0 0
		
	} else {
		#####################################################
		#######  Non Roaming (RvR and regular test) #########
		#####################################################

		set rsdb_switch_test_stage 0
		set hook_start_time_secs [clock seconds]

		set get_cpu_stat_flag 1

		while {1} {
			set time1_ms [clock clicks -milliseconds]

			set timestamp [clock format [clock seconds] -format "%H:%M:%S"]

			UTF::Message INFO "" "------------------------$timestamp---------------------------"

			if {$(no_wl_dump)} {
				UTF::Message INFO "" "Do not dump any wl data while running throughput"
				break
			}
			
			#########################################
			# Process post_perf_hook
			#########################################
			# for regular test, run post_perf_hook here
			# for rvr test, run post_perf_hook at the end in orfer to have correct AP mpdu values
			if {$::rvr_test_flag == 0} {
				sts::process_perf_hook post_perf_hook 1 1
			}

			UTF::Message INFO "" "---------------------------------------------------------------"

			#####################################################
			##############      Stop Sniffer     ################
			#####################################################
			if {$::sniffer_started_flag} {
				set sniffer_time_elapsed_secs [expr {[clock seconds] - $::sniffer_start_time_secs}]
				if {$sniffer_time_elapsed_secs >= $::sniffer_capture_time_sec} {
					$::sniffer_object stop $::sniffer_process_id
					set sniffer_timestamp [clock format [clock seconds] -format "%H:%M:%S"]
					UTF::Message INFO "" "###########################Sniffer Stopped @ '$sniffer_timestamp'######################################"
					set ::sniffer_started_flag 0
				}
			}

			set time2_ms [clock clicks -milliseconds]
			set loop_time_ms [expr {$time2_ms - $time1_ms}]
			# it could takes up to 5 sec for all the post_perf_hook commands to process.
			# make sure that we at least stayed in the loop for 2 sec
			if {$loop_time_ms < 2000} {
				set delay_ms [format "%2.3f" [expr {[expr {2000.0 - $loop_time_ms}] / 1000.0}]]
				UTF::Sleep $delay_ms
			}

			set hook_time_elapsed_secs [expr {[clock seconds] - $hook_start_time_secs}]
			UTF::Message INFO "" "hook_time_elapsed_secs=$hook_time_elapsed_secs"

			if {$get_cpu_stat_flag == 1 && $hook_time_elapsed_secs > 10} {
				# dump CPU stat after 10 sec.
				foreach sta_name $(sta) {
					UTF::Message INFO "" "###########################$sta_name mpstat -P ALL######################################"
					set get_cpu_stat_flag 0
					set catch_resp [catch {$sta_name mpstat -P ALL} catch_msg]
				}
			}

			set timeout_sec [expr {round([expr {$::streams_total_time + 1 - $hook_time_elapsed_secs}])}]	
			UTF::Message INFO "" "time left=$timeout_sec"

			if {$timeout_sec <= 3} {
				if {$timeout_sec < 1} {
					set timeout_sec 1
				}
				UTF::Message INFO "" "time left=$timeout_sec"
				break
			}

			if {$::rvr_test_flag == 1} {
				# for RvR test, we need to run the post_perf_hook only once
				break
			}

			if {$::rsdb_switch_test_flag} {
				# for this special rsdb_switch_test, the first GC is only used
				set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]
				set object $sta_name
				set object_ifname $::array_sta_apsta_ifname(${sta_name})

				if {$hook_time_elapsed_secs > 120 && $rsdb_switch_test_stage == 0} {
					UTF::Message INFO "" "###########################rsdb_switch_test######################################"
					UTF::Message INFO "" "rsdb_switch_test_stage=$rsdb_switch_test_stage"					
					#set catch_resp [catch {$object wl rsdb_mode} catch_msg]
					#UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"	
					set nrate [sts::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "1x9"} {
						set ::test_error_flag 1
						set msg "rsdb_switch nrate != 1x9"
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 1x9 instead of $nrate"
						if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
							append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
						}
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=1x9"					
					}
					set rsdb_switch_test_stage 1
					set catch_resp [catch {$object wl rsdb_switch} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					UTF::Sleep 5
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set nrate [sts::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "2x9"} {
						set ::test_error_flag 1
						set msg "rsdb_switch nrate != 2x9"
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 2x9 instead of $nrate"
						if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
							append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
						}
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=2x9"					
					}
				}
				if {$hook_time_elapsed_secs > 240 && $rsdb_switch_test_stage == 1} {
					UTF::Message INFO "" "###########################rsdb_switch_test######################################"
					UTF::Message INFO "" "rsdb_switch_test_stage=$rsdb_switch_test_stage"					
					set rsdb_switch_test_stage 2
					set catch_resp [catch {$object wl rsdb_switch} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					UTF::Sleep 5
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set nrate [sts::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "1x9"} {
						set ::test_error_flag 1
						set msg "rsdb_switch nrate != 1x9"
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 1x9 instead of $nrate"
						if {[string first $msg $::array_streams_error_msg(${::curr_test_no})] == -1} {
							append ::array_streams_error_msg(${::curr_test_no}) "($msg)"
						}
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=1x9"					
					}
				}
			}
		}
	}

	set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	UTF::Message INFO "" "timestamp2=$timestamp"
	
	UTF::Message INFO "" "###########################THROUGHPUT DATA######################################"
	set stream_ids [sts::get_stream_ids]
	if {$stream_ids != ""} {
		# using ::streams_total_time sec timeout. If data is ready sooner, then it will not wait this long and comes back immediately
		# if we transmit data for n sec and there are stalls, then the receiver data could be for much longer time than n sec, therefore
		# the wait time is padded by 25%
		set extra_time [expr {int($::streams_total_time / 4)}]
		UTF::Message INFO "" "::streams_total_time=$::streams_total_time extra_time=$extra_time"
		if {$(bt_root_sta) != ""} {
			# Added 10 sec extra pad for BT since there was no pad time and it was returning no data
			if {$extra_time < 10} {
				set extra_time 10
			}
		}
		set wait_time [expr $timeout_sec + $extra_time]
		sts::collect_rpopen_data $wait_time $stream_ids resp1 "" resp2
	}

	set ::iperf_running_flag 0

	set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	UTF::Message INFO "" "timestamp3=$timestamp"

	if {$(no_wl_dump) == 0 && $::rvr_test_flag == 1} {
		UTF::Message INFO "" "************************last post_perf_hook for RvR to write the data and enable scanning for re-assoc***************************"
		sts::process_perf_hook post_perf_hook 0 1
	} elseif {$(no_wl_dump) == 0 && $::roaming_test_flag == 0} {
		# For regular and RvR tests:
		# For non-RvR to have uniform x-axis time interval, do not save this post data. 
		# MUST run it in order to enable scanning otherwise StS cannot re-associate
		UTF::Message INFO "" "************************last post_perf_hook (without saving) to enable scanning for re-assoc***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		sts::process_perf_hook post_perf_hook 0 0
	}

	set tot_throughputs ""
	set throughput_scale ""
	set any_throughput_data_flag 0
	set bt_throughput_cnt 0

	# find the first stream time
	set first_stream_name $::array_streams_stream_label(${::curr_test_no},1)
	UTF::Message INFO "" "first_stream_name=$first_stream_name"
	set first_stream_time_secs $::array_streams_start_stream_time_secs(${::curr_test_no},1)
	UTF::Message INFO "" "first_stream_time_secs=$first_stream_time_secs"

	# Notice:
	# UDP latency data for throughput stalls are "-/-/-/-" which needs to be converted to zeros
	# 10:48:34 RX_4:VI-AWDL:AWDL->PEER [  3] 7.00-8.00 sec  0.00 MBytes  0.00 Mbits/sec   0.000 ms    0/    0 (0%) -/-/-/- ms    0 pps
	
	UTF::Message INFO "" "###########################THROUGHPUT DATA with Info######################################"
	foreach line $resp1 {
		UTF::Message INFO "" "$line"
	}
	UTF::Message INFO "" "#################################################################"
	
	# get samples for the control chart
	# take all the data from P2P and APSTA and put them in the correct host arry
	#	array(4360-P2P-GC)
	#	array(4360-P2P-GO)
	#	array(4360-WLAN-GC)
	#	array(lan)
	foreach line $resp1 {
		set time ""
		set stream_no 0
		set interval_start_time ""
		set interval_end_time ""
		set throughput 0
		set throughput_scale ""
		
		set tcp_writes ""
		set tcp_errors ""
		set tcp_retries ""
		set tcp_used_memory ""
		set tcp_used_memory_scale ""
		set tcp_rtt ""
		 
		set udp_jitter ""
		set udp_lost_packets ""
		set packet_total ""
		set udp_lost_packets_percent ""
		set udp_latency_avg ""
		set udp_latency_min ""
		set udp_latency_max ""
		set udp_latency_stdev ""
		set udp_pps ""
		set out_of_order_packets 0

		set bt_throughput_flag 0

		UTF::Message INFO "" "$line"

		# For TX lines:
		# 	Process tx totals
		#	For TCP, process 'TCP retries', 'memory consumed for the traffic in Kilobytes', and 'RTT in microseconds'
		# Skip the rest of the TX data since we process the RX lines
		
		if {[regexp " TX_" $line]} {
			#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         udp_jitter                 udp_packet_loss        /     packet_total              udp_lost_packets_percent
			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+).*\(([-+]?[0-9]*\.?[0-9]+)%\)} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets packet_total udp_lost_packets_percent]
			if {$rc == 0} {
				# lost_packets_percent could be a string and not a value

				set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+).*\((\S+)%\)} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets packet_total udp_lost_packets_percent]
				if {$rc != 0} {
					# set the lost_packets_percent to max value
					set lost_packets_percent 100
				} else {
					# try for a TCP response:
					# 16:27:08 TX_4:TCP-AWDL:AWDL->PEER [ ID] Interval        Transfer    Bandwidth       Write/Err  Rtry    Cwnd/RTT
					# 16:27:08 TX_4:TCP-AWDL:AWDL->PEER [  3] 0.00-1.00 sec  7.52 MBytes  63.0 Mbits/sec  962/0          6      347K/421875 us
					#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         Write               /         Err                      Rtry                      Cwnd         Cwnd_scale /           RTT
					set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?([-+]?[0-9]*\.?[0-9]+) +?([-+]?[0-9]*\.?[0-9]+) *?(.) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?us} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale tcp_writes tcp_errors tcp_retries tcp_used_memory tcp_used_memory_scale tcp_rtt]
					if {$rc == 0} {
						#05:03:44 TX_1:VI-P2P:GC<-GO [ ID] Interval       Transfer     Bandwidth      PPS
						#16:24:52 TX_1:Master->Slave [  3] 0.00-60.00 sec   286 MBytes  40.0 Mbits/sec 3401 pps
						#                ------------time--------  host       interval_start_time        interval_end_time      
						set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec} $line match time stream_label interval_start_time interval_end_time]
					}
				}
			}

			if {$rc == 0} {continue}

			# extract stream_no from stream_label
			set stream_no ""
			regexp {TX_(\d+):} $stream_label match stream_no
			if {$stream_no == ""} {
				incr ::error_cnt
				error "Failed to extract stream_no from '$stream_label'" 
			}

			UTF::Message LOG "" "TX: stream_no=$stream_no interval_start_time=$interval_start_time interval_end_time=$interval_end_time Throughput=$throughput throughput_scale=$throughput_scale tcp_writes=$tcp_writes tcp_errors=$tcp_errors tcp_retries=$tcp_retries tcp_used_memory=$tcp_used_memory tcp_used_memory_scale=$tcp_used_memory_scale tcp_rtt=$tcp_rtt"

			if {[expr {$interval_end_time - $interval_start_time}] > $::perfint} {
				# end of iperf msg shows totals
				UTF::Message INFO "" "--->TX Total: $line"
				set ::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no}) $interval_end_time
			} elseif {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
				# For TCP, save the TCP data

				# check for bad stall data
				if {$tcp_rtt < 0} {
					UTF::Message INFO "" "changing bad tcp_rtt=$tcp_rtt to zero"
					set tcp_rtt "0" 
				}
				if {$tcp_writes < 0} {
					UTF::Message INFO "" "changing bad tcp_writes=$tcp_writes to zero"
					set tcp_writes "0" 
				}
				if {$tcp_errors < 0} {
					UTF::Message INFO "" "changing bad tcp_errors=$tcp_errors to zero"
					set tcp_errors "0" 
				}
				if {$tcp_retries < 0} {
					UTF::Message INFO "" "changing bad tcp_retries=$tcp_retries to zero"
					set tcp_retries "0" 
				}
				if {$tcp_used_memory < 0} {
					UTF::Message INFO "" "changing bad tcp_used_memory=$tcp_used_memory to zero"
					set tcp_used_memory "0" 
				}
				
				# convert RTT from us to ms
				set tcp_rtt_ms [format "%2.3f" [expr {$tcp_rtt / 1000.0}]]
				
				append ::array_streams_tcp_rtt(${::curr_test_no},${stream_no}) "$tcp_rtt_ms "
				append ::array_streams_tcp_writes(${::curr_test_no},${stream_no}) "$tcp_writes "
				append ::array_streams_tcp_errors(${::curr_test_no},${stream_no}) "$tcp_errors "
				append ::array_streams_tcp_retries(${::curr_test_no},${stream_no}) "$tcp_retries "
				append ::array_streams_tcp_used_memory(${::curr_test_no},${stream_no}) "$tcp_used_memory "
			}
			
			continue
		}

		if {[regexp "datagrams received out-of-order" $line]} {
		
			# "11:45:20  LOG   lan-S1     [  3]  0.0- 1.0 sec  436 datagrams received out-of-order"
			#                ------------time--------  host       interval_start_time        interval_end_time          out_of_order_packets
			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec *?([-+]?[0-9]*\.?[0-9]+).*out-of-order} $line match time stream_label interval_start_time interval_end_time out_of_order_packets]
			if {$rc != 0} {
				# extract stream_no from stream_label
				set stream_no ""
				regexp {RX_(\d+):} $stream_label match stream_no
				if {$stream_no == ""} {
					incr ::error_cnt
					error "Failed to extract stream_no from '$stream_label'" 
				}
		
				UTF::Message INFO "" "RX OOO: stream_no=$stream_no interval_start_time=$interval_start_time interval_end_time=$interval_end_time out-of-order=$out_of_order_packets"

				# skip more than 1 sec intervals (totals at the end of iperf)
				
				if {[expr {$interval_end_time - $interval_start_time}] <= $::perfint} {

					# removed the last data in the array_out_of_order_packets and replace it with this
					# out_of_order_packets value
					set out_of_order_data_cnt [llength $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})]
					set ::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) [lrange $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) 0 [expr {$out_of_order_data_cnt - 2}]]
					set ::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) "$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) $out_of_order_packets"

					UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
				} else {
					# end of iperf msg shows total out-of-order packets for this stream
					# 17:32:34  LOG   lan-S3     [  3]  0.0-15.0 sec  282 datagrams received out-of-order
					UTF::Message INFO "" "RX OOO Total: $line"					
					set ::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no}) $interval_end_time
				}
			}
			
			continue
		}

		# 1st try for a UDP response:
		# set line "15:16:43 lan-Stream2 \[  3\]  8.5- 9.0 sec  24.2 MBytes   203 Mbits/sec   0.057 ms    3/17229 (1%)"
		# 18:01:36 4360-P2P-GO [ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams
		# "13:33:04 4335-P2P-GO [  3]  7.0- 8.0 sec  3.34 MBytes  28.0 Mbits/sec   1.756 ms    3/ 2385 (0.13%)"
		# "08:00:16 4335-P2P-GC [  3]  1.0- 2.0 sec  0.00 KBytes  0.00 Kbits/sec  16.087 ms    0/    0 (NaN%)"
		# "08:00:56 lan [  3]  3.0- 4.0 sec  0.00 KBytes  0.00 Kbits/sec  23.278 ms    0/    0 (nan%)"
		#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         udp_jitter                   udp_packet_loss      /     packet_total         udp_lost_packets_percent        udp_latency_avg      /      udp_latency_min       /      udp_latency_max       /     udp_latency_stdev      ms           udp_pps          pps
		set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?\(([-+]?[0-9]*\.?[0-9]+)%\) +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) +?pps} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets packet_total udp_lost_packets_percent udp_latency_avg udp_latency_min udp_latency_max udp_latency_stdev udp_pps]
		if {$rc == 0} {
			# lost_packets_percent could be a string and not a value

			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?\((\S+)%\) +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) +?pps} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets packet_total udp_lost_packets_percent udp_latency_avg udp_latency_min udp_latency_max udp_latency_stdev udp_pps]
			if {$rc != 0} {
				# set the lost_packets_percent to max value
				set lost_packets_percent 100
			} else {
				# try for a TCP response:
				# 17:01:01  LOG   lan-S1     [ ID] Interval       Transfer     Bandwidth
				# 17:01:01  LOG   lan-S1     [  3]  0.0- 1.0 sec  70.2 MBytes   589 Mbits/sec
				#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale 
				set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec} $line match time stream_label interval_start_time interval_end_time throughput throughput_scale]

				if {$rc == 0} {
					# try for a BT response:
					# 11:08:41  INFO             11:08:41 RX_1:BT Throughput = 248 kb/s 
					set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+) +?Throughput = +?([-+]?[0-9]*\.?[0-9]+) +?(.)b/s} $line match time stream_label throughput throughput_scale]
					if {$rc != 0} {
						set bt_throughput_flag 1
						
						set interval_start_time $bt_throughput_cnt
						set interval_end_time [expr $bt_throughput_cnt + 1]
						
						incr bt_throughput_cnt
					}
				}
			}
		}

		if {$rc == 0} {continue}

		# extract stream_no from stream_label
		set stream_no ""
		regexp {RX_(\d+):} $stream_label match stream_no
		if {$stream_no == ""} {
			incr ::error_cnt
			error "Failed to extract stream_no from '$stream_label'" 
		}
		
		UTF::Message LOG "" "RX: stream_no=$stream_no interval_start_time=$interval_start_time interval_end_time=$interval_end_time Throughput=$throughput throughput_scale=$throughput_scale udp_jitter=$udp_jitter udp_lost_packets=$udp_lost_packets packet_total=$packet_total udp_lost_packets_percent=$udp_lost_packets_percent udp_latency_avg=$udp_latency_avg udp_latency_min=$udp_latency_min udp_latency_max=$udp_latency_max udp_latency_stdev=$udp_latency_stdev udp_pps=$udp_pps"

		if {$bt_throughput_flag == 0} {
			# in very rare situation, the throughput could become bogus number
			if {$throughput > 10000 || $interval_start_time == $interval_end_time} {
				if {![regexp {Bogus throughput} $::array_streams_stream_error_msg(${::curr_test_no},${stream_no})]} {
					append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(Bogus throughput)"
				}
				UTF::Message LOG "" "Throughput bogus number $throughput is replaced with -5"
				set throughput "-5"
			}
		}

		# figure out the correct time for this throughput
		set new_stream_time_secs [expr {$interval_start_time + $::array_streams_start_stream_time_secs(${::curr_test_no},${stream_no}) - $first_stream_time_secs}]
		set new_stream_time_secs [format "%2.3f" $new_stream_time_secs]
		set new_stream_time_secs_round [expr {round($new_stream_time_secs)}]
		set new_time [clock format [expr {$::base_timestamp_tick + $new_stream_time_secs_round}] -format "%M:%S"]
		UTF::Message INFO "" "Stream $stream_no time=$new_time"
		UTF::Message INFO "" "$interval_start_time + ($::array_streams_start_stream_time_secs(${::curr_test_no},${stream_no}) - $first_stream_time_secs)=$new_stream_time_secs     round=$new_stream_time_secs_round     time=$new_time"
		if {$interval_start_time != $new_stream_time_secs_round} {
			UTF::Message INFO "" "Old Time=$interval_start_time New Time=$new_stream_time_secs_round"
		}

		# put the throughput value in the right bucket

		set any_throughput_data_flag 1

		if {[expr {$interval_end_time - $interval_start_time}] <= $::perfint} {

			append ::array_streams_throughput(${::curr_test_no},${stream_no}) "$new_time $throughput "
			set ::array_streams_last_throughput_timestamp(${::curr_test_no},${stream_no}) "$new_time"

			if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			
				# if iperf displays udp_lost_packets_percent as '(-nan%)', then change it to zero
				if {![regexp {([0-9]+)} $udp_lost_packets_percent]} {
					set udp_lost_packets_percent "0"
				}
						
				# check for bad stall data
				if {$udp_latency_avg < 0} {
					UTF::Message INFO "" "changing bad udp_latency_avg='$udp_latency_avg' to zero"
					set udp_latency_avg "0" 
				}
				if {$udp_latency_min < 0} {
					UTF::Message INFO "" "changing bad udp_latency_min='$udp_latency_min' to zero"
					set udp_latency_min "0" 
				}
				if {$udp_latency_max < 0} {
					UTF::Message INFO "" "changing bad udp_latency_max='$udp_latency_max' to zero"
					set udp_latency_max "0" 
				}
				if {$udp_latency_stdev < 0} {
					UTF::Message INFO "" "changing bad udp_latency_stdev='$udp_latency_stdev' to zero"
					set udp_latency_stdev "0" 
				}
				if {$udp_jitter < 0} {
					UTF::Message INFO "" "changing bad udp_jitter='$udp_jitter' to zero"
					set udp_jitter "0" 
				}
				if {$udp_lost_packets < 0} {
					UTF::Message INFO "" "changing bad udp_lost_packets='$udp_lost_packets' to zero"
					set udp_lost_packets "0" 
				}
				if {$packet_total < 0} {
					UTF::Message INFO "" "changing bad packet_total='$packet_total' to zero"
					set packet_total "0" 
				}
				if {$udp_lost_packets_percent < 0} {
					UTF::Message INFO "" "changing bad udp_lost_packets_percent='$udp_lost_packets_percent' to zero"
					set udp_lost_packets_percent "0" 
				}
				if {$udp_pps < 0} {
					UTF::Message INFO "" "changing bad udp_pps='$udp_pps' to zero"
					set udp_pps "0" 
				}
				
				append ::array_streams_udp_latency_avg(${::curr_test_no},${stream_no}) "$udp_latency_avg "
				append ::array_streams_udp_latency_min(${::curr_test_no},${stream_no}) "$udp_latency_min "
				append ::array_streams_udp_latency_max(${::curr_test_no},${stream_no}) "$udp_latency_max "
				append ::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no}) "$udp_latency_stdev "
				append ::array_streams_udp_jitter(${::curr_test_no},${stream_no}) "$udp_jitter "
				append ::array_streams_udp_lost_packets(${::curr_test_no},${stream_no}) "$udp_lost_packets "
				append ::array_streams_packet_total(${::curr_test_no},${stream_no}) "$packet_total "
				append ::array_streams_udp_lost_packets_percent(${::curr_test_no},${stream_no}) "$udp_lost_packets_percent "
				append ::array_streams_udp_pps(${::curr_test_no},${stream_no}) "$udp_pps "

				# insert a temp value of 0 for the out_of_order_packets value till the next data is read and this value gets adjusted
				append ::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no}) "0 "
			}			
		} else {
			UTF::Message INFO "" "interval_start_time=$interval_start_time current_interval_start_time=$interval_start_time"
			UTF::Message INFO "" "Do not save this data due to timestamp showing the total time"
			UTF::Message INFO "" "RX Total - $line"					
			set ::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no}) $interval_end_time
		}
		
		UTF::Message INFO "" "---"
	}

	if {$any_throughput_data_flag == 0} {
		if {$::rvr_test_flag == 1} {
			UTF::Message LOG "" "RvR Test hit zero Throughput"
			UTF::Message INFO "" "****************************************************************"
			set ::rvr_zero_throughput_flag 1
			return "No Throughput Data"
		} else {
			UTF::Message LOG "" "***Failed. All Throughput data arrays are empty"
			UTF::Message INFO "" "****************************************************************"
			# set ::test_error_flag 1
			# kevin
			# error "html: <font color=\"red\"><b>No Throughput Data</b></font>"
		}
	}

	UTF::Message INFO "" "#############################check/fix stream missing data####################################"

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		UTF::Message INFO "" "::array_streams_end_time(${::curr_test_no},${stream_no})=$::array_streams_end_time(${::curr_test_no},${stream_no})"

		if {$::array_streams_throughput(${::curr_test_no},${stream_no}) == ""} {
			UTF::Message LOG "" "***Failed. All throughput data is missing for stream $stream_no"
			set ::array_streams_stream_data_missing_flag(${::curr_test_no},${stream_no}) "1"
			set expected_throughput_data_cnt $::array_streams_end_time(${::curr_test_no},${stream_no})
			UTF::Message INFO "" "expected_throughput_data_cnt = $expected_throughput_data_cnt"
			set actual_throughput_data_cnt 0
		} else {
			# calculate the number of data samples expected
			# if a stream stoped early then report it as error
			set tmp [expr {$::array_streams_end_time(${::curr_test_no},${stream_no}) / $::perfint}]
			# leave one sample room
			set expected_throughput_data_cnt [expr {$tmp - 1}]
			UTF::Message INFO "" "expected_throughput_data_cnt = $expected_throughput_data_cnt"

			set actual_throughput_data_cnt [llength $::array_streams_throughput(${::curr_test_no},${stream_no})]
			# devide by 2 to remove the timestamp
			set actual_throughput_data_cnt [expr {$actual_throughput_data_cnt / 2.0}]
			UTF::Message INFO "" "actual_throughput_data_cnt for stream $stream_no = $actual_throughput_data_cnt"
		}

		if {$actual_throughput_data_cnt < $expected_throughput_data_cnt} {

			set ::test_error_flag 1

			if {$::array_streams_stream_data_missing_flag(${::curr_test_no},${stream_no})} {
				if {$::array_streams_throughput_skipped_flag(${::curr_test_no},${stream_no}) == 1} {
					UTF::Message LOG "" "All throughput data is missing for stream $stream_no since iperf was skipped"
				}
			} else {
				UTF::Message LOG "" "***Failed. Some throughput data is missing for stream $stream_no"
				UTF::Message INFO "" "::array_streams_throughput(${::curr_test_no},${stream_no})=$::array_streams_throughput(${::curr_test_no},${stream_no})"
				append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(Some data missing)"
			}

			UTF::Message INFO "" "#############################insert dummy data for missing data####################################"

			# add '-5' in data for missing throughput value
			# for UDP, do not add dummy data for missing jitter and packet loss data

			set data_missing_cnt [expr {$expected_throughput_data_cnt - $actual_throughput_data_cnt}]
			UTF::Message LOG "" "add dummy '-5' throughput data $data_missing_cnt times"			
			
			for {set cnt 0} {$cnt < $data_missing_cnt} {incr cnt} {
				if {$::array_streams_last_throughput_timestamp(${::curr_test_no},${stream_no}) == ""} {
					# no data
					set last_time_tick [clock scan "00:00:00"]
					set new_time_tick [expr {$last_time_tick - $::base_timestamp_tick + $::array_streams_start_time(${::curr_test_no},${stream_no})}]
				} else {
					set last_time_timestamp "00:$::array_streams_last_throughput_timestamp(${::curr_test_no},${stream_no})"
					set last_time_tick [clock scan $last_time_timestamp]
					set new_time_tick [expr {$last_time_tick - $::base_timestamp_tick + $::perfint}]
				}
				set new_timestamp [clock format $new_time_tick -format "%M:%S"]
				append ::array_streams_throughput(${::curr_test_no},${stream_no}) "$new_timestamp -5 "
				set ::array_streams_last_throughput_timestamp(${::curr_test_no},${stream_no}) "$new_timestamp"
			}
		}

		UTF::Message INFO "" "---------------------------------------------------------------------------------------------------"
		
		UTF::Message INFO "" "************************          control chart throughput           ***************************"

		# strip the timestamp from the throughput values
		set throughput_index 0
		foreach throughput_value $::array_streams_throughput(${::curr_test_no},${stream_no}) {
			incr throughput_index
			if {[expr {$throughput_index % 2}] == 0} {
				# even number data is the throughput value
				append ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no}) "$throughput_value "
			}
		}

		UTF::Message INFO "" "::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"

		# replace bad throughput of '-5' with '0' for the control chart
		if {[regexp {\-5} $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})]} {
			UTF::Message INFO "" "org ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "Replacing '-5' with '0'"
			regsub -all {\-5} $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no}) "0" ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})
			UTF::Message INFO "" "new ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"
		}

    	set ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no}) [string trim $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})]
		set ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {

			UTF::Message INFO "" "************************            control chart tcp_rtt             ***************************"
			set ::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_tcp_rtt(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_rtt(${::curr_test_no},${stream_no})"

			UTF::Message INFO "" "************************            control chart tcp_retries             ***************************"
			set ::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_tcp_retries(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_retries(${::curr_test_no},${stream_no})"
			
			UTF::Message INFO "" "************************            control chart tcp_used_memory             ***************************"
			set ::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no})=$::array_streams_controlchart_tcp_used_memory(${::curr_test_no},${stream_no})"
		}
		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {

			UTF::Message INFO "" "************************            control chart udp_latency           ***************************"
			set ::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})"

			UTF::Message INFO "" "************************            control chart udp_jitter             ***************************"
			set ::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_udp_jitter(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})"
			
			UTF::Message INFO "" "************************         control chart udp_lost_packets         ***************************"
			set ::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no}) [sts::total_control_chart_stream_data $::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})]
			set ::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no}) [sts::round_control_chart_stream_data $::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no}) " $::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no}) $::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})"
			
			UTF::Message INFO "" "************************         control chart packet_total        ***************************"
			set ::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no}) [sts::total_control_chart_stream_data $::array_streams_packet_total(${::curr_test_no},${stream_no})]
			set ::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no}) [sts::round_control_chart_stream_data $::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no}) " $::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no}) $::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})=$::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})"
			
			UTF::Message INFO "" "************************      control chart udp_lost_packets_percent     ***************************"
			set ::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_udp_lost_packets_percent(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no})"
			
			UTF::Message INFO "" "************************     control chart udp_out_of_order_packets      ***************************"
			set ::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no}) [sts::total_control_chart_stream_data $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})]
			set ::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no}) [sts::round_control_chart_stream_data $::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no}) " $::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no}) $::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
			UTF::Message INFO "" "::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})"

			UTF::Message INFO "" "************************            control chart udp_pps           ***************************"
			set ::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no}) [sts::build_control_chart_stream_data $::array_streams_udp_pps(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})"
		}
	}

	UTF::Message INFO "" "#############################find zero throughput data count####################################"

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set zero_throughput_cnt 0
		set stall_throughput_cnt 0
		set died_stream_flag 0
		set died_throughput_check_flag 0
		set died_throughput_cnt 0
		set throughput_index 0

		foreach throughput_value $::array_streams_throughput(${::curr_test_no},${stream_no}) {

			incr throughput_index
			if {[expr {$throughput_index % 2}] == 0} {
				# even number data is the throughput value

				if {$throughput_value == 0} {
					UTF::Message INFO "" "   Item $throughput_index - ZERO"
					incr zero_throughput_cnt
					incr stall_throughput_cnt

					if {$stall_throughput_cnt > 1} {
						UTF::Message INFO "" "back to back ZERO throughput is detected. This is a stall count $stall_throughput_cnt."
					}
				} elseif {$throughput_value < 0} {
					UTF::Message INFO "" "   Item $throughput_index - Data=$throughput_value - DIED"
					if {$died_throughput_check_flag == 1} {
						incr died_throughput_cnt
					}					
				} else {
					set stall_throughput_cnt 0
					set died_throughput_check_flag 1
					set died_throughput_cnt 0
				}
			}
		}
		
		# if there is no throughput for more than 3 sec at the end, then the stream must of died
		if {$died_throughput_cnt > 2} {
			set died_stream_flag 1
			UTF::Message INFO "" "died_throughput_cnt=$died_throughput_cnt"
		}
	
		if {$zero_throughput_cnt > 0 || $died_stream_flag == 1} {

			set tmp ""
			if {$zero_throughput_cnt > 0} {
				if {$zero_throughput_cnt == 1} {
					set tmp "1 zero throughput"
				} else {
					set tmp "$zero_throughput_cnt zeros throughput"
					if {$stall_throughput_cnt > 0} {
						if {$stall_throughput_cnt == 1} {
							set tmp2 "second"
						} else {
							set tmp2 "seconds"
						}
						append tmp " with $stall_throughput_cnt $tmp2 STALL"
					}
				}
			}

			if {$died_stream_flag == 1} {
				if {$tmp != ""} {
					append tmp " "
				}
				append tmp "DIED"
			}

			set ::test_error_flag 1
			UTF::Message LOG "" "***Failed. $tmp for stream $stream_no"
			append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($tmp)"
		}

		# check to see if the rx took longer than tx

		UTF::Message INFO "" "::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no})=$::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no})"					
		UTF::Message INFO "" "::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no})=$::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no})"

		if {$::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no}) == ""} {
			UTF::Message INFO "" "Stream $stream_no is missing TX time"
			append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(Check TX time)"
		} else {
			if {$::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no}) != "" && $::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no}) == ""} {
				UTF::Message INFO "" "Stream $stream_no is missing RX time"
				append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(Check RX time)"
			} elseif {$::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no}) != "" && $::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no}) != ""} {
				set extra_time [format "%2.1f" [expr $::array_streams_rx_stream_time_secs(${::curr_test_no},${stream_no}) - $::array_streams_tx_stream_time_secs(${::curr_test_no},${stream_no})]]

				if {$extra_time > 0.5} {
					UTF::Message INFO "" "Stream $stream_no took $extra_time sec longer"
					append ::array_streams_stream_error_msg(${::curr_test_no},${stream_no}) "(RX took $extra_time sec longer)"
				}
			}
		}

		set tmp [llength $::array_streams_link_type(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "size=$tmp - ::array_streams_link_type(${::curr_test_no},${stream_no})=$::array_streams_link_type(${::curr_test_no},${stream_no})"
		set tmp [llength $::array_streams_traffic_priority(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "size=$tmp - ::array_streams_traffic_priority(${::curr_test_no},${stream_no})=$::array_streams_traffic_priority(${::curr_test_no},${stream_no})"
		set tmp [llength $::array_streams_end_time(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "size=$tmp - ::array_streams_end_time(${::curr_test_no},${stream_no})=$::array_streams_end_time(${::curr_test_no},${stream_no})"
	}

	UTF::Message INFO "" "###########################SAVED DATA######################################"

	set tmp ::array_streams_cnt(${::curr_test_no})
	UTF::Message INFO "" "size=$tmp - ::array_streams_total_streams_label(${::curr_test_no})=$::array_streams_total_streams_label(${::curr_test_no})"


	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_throughput(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_throughput(${::curr_test_no},${stream_no})=$::array_streams_throughput(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set len [llength $::array_streams_tcp_rtt(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_rtt(${::curr_test_no},${stream_no})=$::array_streams_tcp_rtt(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set len [llength $::array_streams_tcp_writes(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_writes(${::curr_test_no},${stream_no})=$::array_streams_tcp_writes(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set len [llength $::array_streams_tcp_errors(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_errors(${::curr_test_no},${stream_no})=$::array_streams_tcp_errors(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set len [llength $::array_streams_tcp_retries(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_retries(${::curr_test_no},${stream_no})=$::array_streams_tcp_retries(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			set len [llength $::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})=$::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_latency_min(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_min(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_min(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_latency_max(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_max(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_max(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no})=$::array_streams_udp_latency_stdev(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_jitter(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_udp_jitter(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_packet_total(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_packet_total(${::curr_test_no},${stream_no})=$::array_streams_packet_total(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_lost_packets_percent(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_lost_packets_percent(${::curr_test_no},${stream_no})=$::array_streams_udp_lost_packets_percent(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			set len [llength $::array_streams_udp_pps(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_udp_pps(${::curr_test_no},${stream_no})"
		}
	}
	UTF::Message INFO "" "============================================================="
	UTF::Message INFO "" "For Control Charts:"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})=$::array_streams_controlchart_throughput(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_latency(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_jitter(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_lost_packets(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})=$::array_streams_controlchart_packet_total(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_lost_packets_percent(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
	}	
	UTF::Message INFO "" "-------------------------------------------------------------"
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

		set len [llength $::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})=$::array_streams_controlchart_udp_pps(${::curr_test_no},${stream_no})"
	}
	UTF::Message INFO "" "============================================================="
	
	if {$::rvr_test_flag == 0} {

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set array_csv_throughput(${::curr_test_no},${stream_no}) ""
			
			set base_time [lindex $::array_streams_throughput(${::curr_test_no},${stream_no}) 0]
			if {$base_time != "00:00"} {
				UTF::Message INFO "" "###########################insert filler BLANK data for CSV if stream data did not start from time 00:00 (e.g. QoS stream)######################################"

				set new_base_time "00:00"
				set new_str_list "$new_base_time BLANK "
				set new_str_udp_list "BLANK "
				while {1} {
					set new_base_time "00:$new_base_time"
					set new_base_time_tick [clock scan $new_base_time]
					set diff_timestamp_tick [expr {$new_base_time_tick - $::base_timestamp_tick + $::perfint}]
					set new_base_time [clock format $diff_timestamp_tick -format "%M:%S"]
					#UTF::Message INFO "" "new_base_time=$new_base_time"
					if {$new_base_time == $base_time} {
						break
					}
					append new_str_list "$new_base_time BLANK "
					append new_str_udp_list "BLANK "
				}
				
    			set new_str_list [string trim $new_str_list]
    			set new_str_udp_list [string trim $new_str_udp_list]
				UTF::Message INFO "" "Stream $stream_no starting time is $base_time instead of 00:00. Adding fillers '$new_str_list'"
				
				set array_csv_throughput(${::curr_test_no},${stream_no}) "$new_str_list $::array_streams_throughput(${::curr_test_no},${stream_no})"
				if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
					set array_csv_tcp_rtt(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_tcp_rtt(${::curr_test_no},${stream_no})"
					set array_csv_tcp_writes(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_tcp_writes(${::curr_test_no},${stream_no})"
					set array_csv_tcp_errors(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_tcp_errors(${::curr_test_no},${stream_no})"
					set array_csv_tcp_retries(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_tcp_retries(${::curr_test_no},${stream_no})"
					set array_csv_tcp_used_memory(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})"
				}
				if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
					set array_csv_udp_latency(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})"
					set array_csv_jitter(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_udp_jitter(${::curr_test_no},${stream_no})"
					set array_csv_udp_lost_packets(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})"
					set array_csv_udp_out_of_order_packets(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
					set array_csv_udp_pps(${::curr_test_no},${stream_no}) "$new_str_udp_list $::array_streams_udp_pps(${::curr_test_no},${stream_no})"
				}
			} else {
				set array_csv_throughput(${::curr_test_no},${stream_no}) "$::array_streams_throughput(${::curr_test_no},${stream_no})"
				if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
					set array_csv_tcp_rtt(${::curr_test_no},${stream_no}) "$::array_streams_tcp_rtt(${::curr_test_no},${stream_no})"
					set array_csv_tcp_writes(${::curr_test_no},${stream_no}) "$::array_streams_tcp_writes(${::curr_test_no},${stream_no})"
					set array_csv_tcp_errors(${::curr_test_no},${stream_no}) "$::array_streams_tcp_errors(${::curr_test_no},${stream_no})"
					set array_csv_tcp_retries(${::curr_test_no},${stream_no}) "$::array_streams_tcp_retries(${::curr_test_no},${stream_no})"
					set array_csv_tcp_used_memory(${::curr_test_no},${stream_no}) "$::array_streams_tcp_used_memory(${::curr_test_no},${stream_no})"
				}
				if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
					set array_csv_udp_latency(${::curr_test_no},${stream_no}) "$::array_streams_udp_latency_avg(${::curr_test_no},${stream_no})"
					set array_csv_jitter(${::curr_test_no},${stream_no}) "$::array_streams_udp_jitter(${::curr_test_no},${stream_no})"
					set array_csv_udp_lost_packets(${::curr_test_no},${stream_no}) "$::array_streams_udp_lost_packets(${::curr_test_no},${stream_no})"
					set array_csv_udp_out_of_order_packets(${::curr_test_no},${stream_no}) "$::array_streams_udp_out_of_order_packets(${::curr_test_no},${stream_no})"
					set array_csv_udp_pps(${::curr_test_no},${stream_no}) "$::array_streams_udp_pps(${::curr_test_no},${stream_no})"
				}
			}
		}

		UTF::Message INFO "" "###########################Write Throughput Data to CSV######################################"
		
		# find the stream with the most data points
		set stream_throughput_list_len 0
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set len [llength $array_csv_throughput(${::curr_test_no},${stream_no})]
			UTF::Message INFO "" "length array_csv_throughput(${::curr_test_no},${stream_no})=$len"
			if {$stream_throughput_list_len < $len} {
				set stream_throughput_list_len $len
			}
		}

		# 1st stream starting time
		set parts [split $::array_streams_start_stream_time_secs(${::curr_test_no},1) "."]
		set base_round_down [lindex $parts 0]
		set base_fraction [lindex $parts 1]
		set timestamp [clock format [expr {round($base_round_down)}] -format "%H:%M:%S"]
		set timestamp "$timestamp.$base_fraction"

		set item_cnt 0
		
		for {set throughput_index 0} {$throughput_index < $stream_throughput_list_len} {incr throughput_index; incr throughput_index; incr item_cnt} {

			###################################################################
			# Initialize CSV Throughput Variables
			###################################################################
			sts::array_init_csv_data 0 1

			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

				set len [llength $array_csv_throughput(${::curr_test_no},${stream_no})]

				if {$throughput_index >= $len} {
					# if this stream array is shorter then the rest, then we need to skip this index 
					UTF::Message INFO "" "stream_no=$stream_no len $len is shorter than $throughput_index. skip this."
					continue
				}

				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
					set stream_sta_obj $(bt_root_sta)
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
						}
					} else {
						if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
							set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
						} else {
							set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
						}
					}
				}

				if {$::csv_data_BaseTime == ""} {

					set ::csv_data_BaseTime [lindex $array_csv_throughput(${::curr_test_no},${stream_no}) $throughput_index]
					
					# add the hour before converting
					set new_base_timestamp "00:$::csv_data_BaseTime"
					set new_base_timestamp_tick [clock scan $new_base_timestamp]
					set diff_timestamp_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
					set round_down [expr {$diff_timestamp_tick + $base_round_down}]
					set timestamp [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
					set timestamp "$timestamp.$base_fraction"

					set ::csv_data_Time "\[$timestamp\]"
				}

				set data [lindex $array_csv_throughput(${::curr_test_no},${stream_no}) [expr {$throughput_index + 1}]]

				if {$data != "BLANK"} {
				
					# this throughput data goes to csv file, only for Non-RvR
					set ::csv_data_StaThroughput(${stream_sta_obj})(${stream_name}) $data
					# there are no min and max throughput info for each iperf data results
					set ::csv_data_StaThroughputMin(${stream_sta_obj})(${stream_name}) ""
					set ::csv_data_StaThroughputMax(${stream_sta_obj})(${stream_name}) ""

					if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
						set ::csv_data_StaTCPRTT(${stream_sta_obj})(${stream_name}) [lindex $array_csv_tcp_rtt(${::curr_test_no},${stream_no}) $item_cnt]
						set ::csv_data_StaTCPWrites(${stream_sta_obj})(${stream_name}) [lindex $array_csv_tcp_writes(${::curr_test_no},${stream_no}) $item_cnt]
						set ::csv_data_StaTCPErrors(${stream_sta_obj})(${stream_name}) [lindex $array_csv_tcp_errors(${::curr_test_no},${stream_no}) $item_cnt]
						set ::csv_data_StaTCPRetries(${stream_sta_obj})(${stream_name}) [lindex $array_csv_tcp_retries(${::curr_test_no},${stream_no}) $item_cnt]
						set ::csv_data_StaTCPUsedMemory(${stream_sta_obj})(${stream_name}) [lindex $array_csv_tcp_used_memory(${::curr_test_no},${stream_no}) $item_cnt]
					}
					if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {

						set data_jitter [lindex $array_csv_jitter(${::curr_test_no},${stream_no}) $item_cnt]
						if {$data_jitter != "BLANK"} {
							set ::csv_data_StaUDPLatency(${stream_sta_obj})(${stream_name}) [lindex $array_csv_udp_latency(${::curr_test_no},${stream_no}) $item_cnt]
							set ::csv_data_StaUDPJitter(${stream_sta_obj})(${stream_name}) $data_jitter
							set ::csv_data_StaUDPJitterMin(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPJitterMax(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPLostPackets(${stream_sta_obj})(${stream_name}) [lindex $array_csv_udp_lost_packets(${::curr_test_no},${stream_no}) $item_cnt]
							set ::csv_data_StaUDPLostPacketsMin(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPLostPacketsMax(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPOutofOrderPackets(${stream_sta_obj})(${stream_name}) [lindex $array_csv_udp_out_of_order_packets(${::curr_test_no},${stream_no}) $item_cnt]
							set ::csv_data_StaUDPOutofOrderPacketsMin(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPOutofOrderPacketsMax(${stream_sta_obj})(${stream_name}) ""
							set ::csv_data_StaUDPPPS(${stream_sta_obj})(${stream_name}) [lindex $array_csv_udp_pps(${::curr_test_no},${stream_no}) $item_cnt]
						}
					}
				}
			}

			#####################################################
			######  Write Throughput Result to CVS File  ########
			#####################################################
			sts::array_write_csv_data 0 1		
		}
	}
}

proc sts::setup_cct {} {
	# access option array
	upvar {} {}

	set ::curr_test_no 1

	UTF::Try "DTIM Interval Measurement (APSTA UP)" {
		foreach STA $(sta) {
			catch {$STA wl dtim}
			catch {$STA wl PM}
		}

		set ::cct_key "DTIM APSTA UP"
		sts::measure_dtim_interval					
		return "html: $::current_results"
	}

	UTF::Try "Current Measurement (APSTA UP)" {

		foreach STA $(sta) {
			catch {$STA wl dtim}
			catch {$STA wl PM}
		}

		set ::cct_key "APSTA UP"
		sts::measure_idle_current					
		return "html: $::current_results"
	}

	UTF::Try "Setup CCT" {
		UTF::Message INFO "" "************************Func:setup_cct***************************"

		set cct_interface_list $::array_streams_interface_active_list(${::curr_test_no})

		if {$cct_interface_list == ""} {
			set cct_interface_list $::array_streams_interface_possible_list(${::curr_test_no})
		}

		foreach STA "$cct_interface_list" {
			catch {$STA wl phy_watchdog}
#				catch {$STA wl phy_watchdog 0}
#				UTF::Sleep 1
#				catch {$STA wl phy_watchdog}

			catch {$STA wl pm2_sleep_ret}
#				catch {$STA wl pm2_sleep_ret 20}
#				UTF::Sleep 1
#				catch {$STA wl pm2_sleep_ret}

			catch {$STA wl frameburst}
			catch {$STA wl mpc}
			catch {$STA wl scansuppress}
		}
	}
}

proc sts::measure_idle_current {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_idle_current***************************"
	
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port $(current_sample_time) $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	sts::process_current_data
}

proc sts::measure_dtim_interval {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_dtim_interval***************************"

	# current_measure_time = current_sample_time * current_sample_points -> 40E-6 * 50000 = 2 seconds
	
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port "40E-6" $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	sts::process_current_data
}

proc sts::setup_current_measurement_with_traffic {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_current_measurement_with_traffic***************************"
		
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port $(current_sample_time) $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
}

proc sts::measure_current_with_traffic {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_current_with_traffic***************************"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	sts::process_current_data
}

proc sts::process_current_data {} {

	UTF::Message INFO "" "************************Func:process_current_data***************************"
		
	set current_high_value [$::agilent_obj get_current_trigger_data_high_value ""]
	if {$current_high_value == ""} {
		set current_high_value 0
	}
	set current_high_value [format "%2.8f" [expr {$current_high_value * 1000.0}]]
	set current_floor_value [$::agilent_obj get_current_trigger_data_low_value ""]
	if {$current_floor_value == ""} {
		set current_floor_value 0
	}
	set current_floor_value [format "%2.8f" [expr {$current_floor_value * 1000.0}]]

	set rc [$::agilent_obj get_current_trigger_data ""]
	set current_values [split $rc ","]

	####################################################################

	set ckey "$::array_streams_control_chart_base_key(${::curr_test_no}) current_floor_value"
	UTF::Message INFO "" "KEY=$ckey"
	set current_results_low_value [sts::control_chart "Floor Value" $current_floor_value $ckey "Current" "mA" 0]

	# current of zero and low are OK
	regsub { ZERO} $current_results_low_value { OK} current_results_low_value
	regsub { LOW} $current_results_low_value { OK} current_results_low_value

	set ckey "$::array_streams_control_chart_base_key(${::curr_test_no}) current_high_value"
	UTF::Message INFO "" "KEY=$ckey"
	set current_results_high_value [sts::control_chart "High Value" $current_high_value $ckey "Current" "mA" 0]

	# current of zero and low are OK
	regsub { ZERO} $current_results_high_value { OK} current_results_high_value
	regsub { LOW} $current_results_high_value { OK} current_results_high_value

	####################################################################
	
	# genrate the gnu_data file which has the current vs time data
	
    set logdir [file nativename [file dir $UTF::Logfile]]
    set testnum [file tail $UTF::Logfile]
    set testnum [file rootname $testnum]
    set testnum [string trim $testnum]
	
	set gnu_data_fd [open "${logdir}/${testnum}_current.gnu_data" w]
	set line_cnt 0
	
	foreach value $current_values {

		incr line_cnt

		#UTF::Message LOG "" "(line=$line_cnt)(value=$value)"

		# current in mA (default Agilent is A)
		set value [expr {$value * 1000.0}]

		# x-axis (time) starts from 0 and it is in ms. y-axis (current) is in mA
		puts $gnu_data_fd [format "%2.3f %2.8f" [expr {[expr {$line_cnt - 1}] * $::current_actual_sample_time * 1000.0}] $value]
	}
	close $gnu_data_fd

	UTF::Message LOG "" "===================================================================="
	UTF::Message LOG "" "Graph the results:"

	set gpc_fd [open "${logdir}/${testnum}.gnu_plot" w]

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}_canvas.html\""
	puts $gpc_fd "set terminal canvas standalone mousing size 1024,768 jsdir \"http://www.sj.broadcom.com/projects/hnd_sig_ext4/rmcmahon/gnuplotfiles\""
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set label \"\" at graph 0.1, graph 0.9"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lw 2 lt 1 title \"\""

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}.png\""
	puts $gpc_fd "set terminal png size 640,480"
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set label \"\" at graph 0.1, graph 0.9"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lw 2 lt 1 title \"\""

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}_sm.png\""
	puts $gpc_fd "set terminal png transparent size 62,13"
	puts $gpc_fd "set tmargin 0; set bmargin 0"
	puts $gpc_fd "set lmargin 0; set rmargin 0.15"
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "unset xtics; unset ytics; unset key; unset xlabel; unset ylabel; unset border; unset grid; unset yzeroaxis; unset xzeroaxis; unset title; set lmargin 0; set rmargin 0; set tmargin 0; set bmargin 0"
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lt 1"

	close $gpc_fd

	set rc [catch "exec $::UTF::Gnuplot ${logdir}/${testnum}.gnu_plot" result]

	########################################

	set ::current_results ""
    append ::current_results "<a href=\"${logdir}/${testnum}_canvas.html\"><b>Current Plot</b></a>&nbsp;&nbsp;<img src=\"${testnum}_sm.png\" alt=\"${testnum}_sm.png\" id=\"img_test_result\" border=\"0\">"
	append ::current_results "&nbsp;&nbsp;$current_results_low_value&nbsp;&nbsp;$current_results_high_value"
	UTF::Message LOG "" "::current_results=$::current_results"
}

proc sts::setup_list_active_interface_objects {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_list_active_interface_objects***************************"

	set ::array_streams_interface_active_list(${::curr_test_no}) ""
	
	foreach target $::array_streams_interface_possible_list(${::curr_test_no}) {

		UTF::Message INFO "" "-----------------------------target=$target------------------------------------------"

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
			if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
				continue
			}

			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA" && $target == $::array_streams_dst_sta(${::curr_test_no},${stream_no})} {
				if {$::array_sta_apsta_active_flag(${target}) == 1} {
					UTF::Message INFO "" "$::array_streams_dst_sta(${::curr_test_no},${stream_no}) $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
					append ::array_streams_interface_active_list(${::curr_test_no}) "$::array_streams_dst_sta(${::curr_test_no},${stream_no}) "
					break
				}
			}
		}

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
			if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
				continue
			}

			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) != "APSTA" && $target == $::array_streams_dst(${::curr_test_no},${stream_no})} {
				set sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
				if {$::array_sta_sts_active_flag(${sta}) == 1} {
					UTF::Message INFO "" "$::array_streams_dst(${::curr_test_no},${stream_no}) $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
					append ::array_streams_interface_active_list(${::curr_test_no}) "$::array_streams_dst(${::curr_test_no},${stream_no}) "
					break
				}
			}
		}

		if {![info exists ::array_sta_softap_flag(${target})]} {
			continue
		}
	
		if {$::array_sta_softap_flag(${target}) == 1} {
			continue
		}
		
		UTF::Message INFO "" "::array_sta_apsta_active_flag(${target})=$::array_sta_apsta_active_flag(${target}) ::array_sta_apsta_disassociated_flag(${target})=$::array_sta_apsta_disassociated_flag(${target})"
		UTF::Message INFO "" "::array_sta_sts_active_flag(${target})=$::array_sta_sts_active_flag(${target}) ::array_sta_sts_disassociated_flag(${target})=$::array_sta_sts_disassociated_flag(${target})"
	}

	regsub -all { {2,}} $::array_streams_interface_active_list(${::curr_test_no}) { } ::array_streams_interface_active_list(${::curr_test_no}) 
	set ::array_streams_interface_active_list(${::curr_test_no}) [string trim $::array_streams_interface_active_list(${::curr_test_no})]
	UTF::Message INFO "" "::array_streams_interface_active_list(${::curr_test_no})='$::array_streams_interface_active_list(${::curr_test_no})'"
}

proc sts::setup_csv_header {} {
	# access option array
	upvar {} {}

	UTF::Message LOG "Before" "::array_streams_ap_controller(${::curr_test_no})='$::array_streams_ap_controller(${::curr_test_no})' ::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})'"

	UTF::Message INFO "" "************************Func:setup_csv_header***************************"

	catch {file mkdir "$::logdir/GraphsData"}

	set csv_columns_ap_title "ApTxRate,ApMcsRate,ApMpduDensity,ApRxMcs,ApTxMcs,ApRxMcsSgi,ApTxMcsSgi,ApMcsPer,ApRxVht,ApTxVht,ApRxVhtSgi,ApTxVhtSgi,ApVhtPer"
	set csv_columns_sta_title "StaApRssi,StaApTxRateStaInfo,StaApRxRate,StaApIdleTime,StaApConnectTime,StaApState,StaApTxPkts,StaApTxFailures,StaState,StaTxRate,StaMcsRate,StaRssi,StaMpduDensity,StaRxMcs,StaTxMcs,StaRxMcsSgi,StaTxMcsSgi,StaMcsPer,StaRxVht,StaTxVht,StaRxVhtSgi,StaTxVhtSgi,StaVhtPer,StaBeaconRate"
	if {$::roaming_test_flag} {
		set csv_columns_sta_title [concat $csv_columns_sta_title ",StaBssid"]
	}
	set csv_columns_sta_throughput_title "StaThroughput,StaThroughputMin,StaThroughputMax,StaTCPRTT,StaTCPWrites,StaTCPErrors,StaTCPRetries,StaTCPUsedMemory,StaUDPLatency,StaUDPJitter,StaUDPJitterMin,StaUDPJitterMax,StaUDPLostPackets,StaUDPLostPacketsMin,StaUDPLostPacketsMax,StaUDPOutofOrderPackets,StaUDPOutofOrderPacketsMin,StaUDPOutofOrderPacketsMax,StaUDPPPS"

	regsub -all {\s} $csv_columns_ap_title "" csv_columns_ap_title
	regsub -all {\s} $csv_columns_sta_title "" csv_columns_sta_title
	regsub -all {\s} $csv_columns_sta_throughput_title "" csv_columns_sta_throughput_title

	set csv_columns_ap_title [split $csv_columns_ap_title ","]
	set csv_columns_sta_title [split $csv_columns_sta_title ","]
	set csv_columns_sta_throughput_title [split $csv_columns_sta_throughput_title ","]

	set output_str_ap ""
	
	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	set sta_cnt 0
	foreach sta_name $(sta) {
		incr sta_cnt
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA link is active"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) link is active"
		}
	}

	if {$(ap) != "" && $active_sta_apsta_flag == 1} {
		set cnt 0

		foreach ap $(ap) {
			# check for 2g:5g param
			set AP [split $ap ":"]
			set AP [lindex $AP 0]
			
			#UTF::Message INFO "" "##############################AP=$AP###################################"

			foreach column_ap "$csv_columns_ap_title" {
				if {$cnt > 0} {
					set output_str_ap [concat $output_str_ap ","]
				}

				set output_str_ap [concat $output_str_ap "${column_ap}(${AP})"] 
				incr cnt
			}

			regsub -all {\s} $output_str_ap "" output_str_ap
		}

		#UTF::Message INFO "" "output_str_ap='$output_str_ap'"
	}

	set tcp_flag 0
	set udp_flag 0
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "TCP"} {
			# this stream is a TCP
			set tcp_flag 1
		}
		if {$::array_streams_traffic_type(${::curr_test_no},${stream_no}) == "UDP"} {
			# this stream is a UDP
			set udp_flag 1
		}
	}

	set output_str_sta ""
	set output_str_sta_throughput ""
	set cnt 0
	set cnt_throughput 0

	foreach STA "$::array_streams_interface_existing_list(${::curr_test_no})" {

		# skip invalid interfaces
		if {[info exists ::array_sta_sta_flag(${STA})]} {
			# skip the AP/SoftAP interfaces
			if {$::array_sta_sta_flag(${STA}) != 1} {
				#UTF::Message INFO "" "$STA is not an STA. Skip."
				continue
			}
		}
		
		#UTF::Message INFO "" "##############################STA=$STA###################################"
		#UTF::Message INFO "" "output_str_sta=$output_str_sta"
		#UTF::Message INFO "" "output_str_sta_throughput=$output_str_sta_throughput"

		set active_sta_apsta_flag 0
		set active_sta_sts_flag 0
		set interface_sta ""
		foreach sta_name $(sta) {
			if {[string compare $STA $sta_name] == 0} {
				set active_sta_apsta_flag 1
				set interface_sta $sta_name
				#UTF::Message INFO "" "APSTA STA='$STA' interface_sta='$interface_sta'"
				break
			} elseif {[string compare $STA $::array_sta_sts(${sta_name})] == 0} {
				set active_sta_sts_flag 1
				set interface_sta $sta_name
				#UTF::Message INFO "" "$::array_streams_link_type(${::curr_test_no},${::curr_stream_no}) STA='$STA' interface_sta='$interface_sta'"
				break
			}
		}

		foreach column_sta "$csv_columns_sta_title" {
			if {$cnt > 0} {
				set output_str_sta [concat $output_str_sta ","]
			}

			set output_str_sta [concat $output_str_sta "${column_sta}(${STA})"] 
			incr cnt
		}

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
			#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

			if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
					set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
				} else {
					set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
				}
			} else {
				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
					set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
				} else {
					set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
				}
			}

			foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

				if {[regexp {StaThroughput} $column_sta_throughput]} {

					if {$::rvr_test_flag == 0} {
						# min max vaule is only for RvR
						if {[regexp {StaThroughputMin} $column_sta_throughput] || [regexp {StaThroughputMax} $column_sta_throughput]} {
							continue
						}
					}

					set var "csv_data_${column_sta_throughput}"
					if {$cnt_throughput > 0} {
						set output_str_sta_throughput [concat $output_str_sta_throughput ","]
					}

					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}($(bt_root_sta))(${stream_name})"] 
					} else {
						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"]
					}
					incr cnt_throughput
				}
			}
		}

		if {$tcp_flag} {
			# TCP Writes
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPWrites} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP Errors
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPErrors} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP Retries
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPRetries} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP UsedMemory
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPUsedMemory} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP RTT
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPRTT} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}
		}
		
		if {$udp_flag} {
			# UDP Latency
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPLatency} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP Jitter
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPJitter} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPJitterMin} $column_sta_throughput] || [regexp {StaUDPJitterMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP LostPackets
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPLostPackets} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPLostPacketsMin} $column_sta_throughput] || [regexp {StaUDPLostPacketsMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP OutofOrderPackets
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPOutofOrderPackets} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPOutofOrderPacketsMin} $column_sta_throughput] || [regexp {StaUDPOutofOrderPacketsMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP PPS
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})
				#UTF::Message INFO "" "stream_no=$stream_no stream_name=$stream_name"

				if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_src(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
						set stream_sta $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
				
				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPPPS} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${stream_sta})(${stream_name})"] 
						incr cnt_throughput
					}
				}
			}
		}
	}

	regsub -all {\s} $output_str_sta "" output_str_sta
	#UTF::Message INFO "" "output_str_sta='$output_str_sta'"
	regsub -all {\s} $output_str_sta_throughput "" output_str_sta_throughput
	#UTF::Message INFO "" "output_str_sta_throughput='$output_str_sta_throughput'"

	set testnum [sts::get_testnum]
	regsub -all {.} $testnum "_" $testnum
	set filename_data "$testnum\.test_data"
	set ::curr_csv_data_file "${filename_data}.csv"
	set ::curr_csv_data_fullname "$::logdir/GraphsData/${filename_data}.csv"
	set filename_throughput "$testnum\.test_throughput_data"
	set ::curr_csv_throughput_data_file "${filename_throughput}.csv"
	set ::curr_csv_throughput_data_fullname "$::logdir/GraphsData/${filename_throughput}.csv"
	set ::curr_gnuplot_data_line_cnt 0
	#UTF::Message INFO "" "::curr_csv_data_fullname='$::curr_csv_data_fullname'"
	set csv_data_fd [open "$::curr_csv_data_fullname" w 0644]
	puts $csv_data_fd "$::graph_label_test$::array_streams_total_streams_label(${::curr_test_no})"
	#UTF::Message INFO "" "::curr_csv_throughput_data_fullname='$::curr_csv_throughput_data_fullname'"
	set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" w 0644]
	puts $csv_throughput_fd "$::graph_label_test$::array_streams_total_streams_label(${::curr_test_no})"

	set ::csv_columns_throughput_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_sta_throughput"
	if {$output_str_ap != ""} {
		set ::csv_columns_data_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_ap,$output_str_sta"
	} else {
		set ::csv_columns_data_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_sta"
	}
	puts $csv_data_fd $::csv_columns_data_list
	close $csv_data_fd
	puts $csv_throughput_fd $::csv_columns_throughput_list
	close $csv_throughput_fd

	#UTF::Message INFO "" "::csv_columns_data_list='$::csv_columns_data_list'"
	set ::csv_columns_data_list [split $::csv_columns_data_list ","]

	#UTF::Message INFO "" "::csv_columns_throughput_list='$::csv_columns_throughput_list'"
	set ::csv_columns_throughput_list [split $::csv_columns_throughput_list ","]

	#return "<a href=\"GraphsData/${filename_data}.csv\"><b>\{CSV Data\}</b></a>&nbsp;&nbsp;<a href=\"GraphsData/${filename_throughput}.csv\"><b>\{CSV Throughput\}</b></a>"
}

proc sts::array_init_csv_data {data_flag throughput_data_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:array_init_csv_data $data_flag $throughput_data_flag***************************"

	if {$data_flag} {
		foreach column "$::csv_columns_data_list" {
			set var "csv_data_${column}"
			catch {array unset ::${var}}
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}

	if {$throughput_data_flag} {
		foreach column_throughput "$::csv_columns_throughput_list" {
			set var "csv_data_${column_throughput}"
			catch {array unset ::${var}}
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc sts::array_write_csv_data {data_flag throughput_data_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:array_write_csv_data $data_flag $throughput_data_flag***************************"

	set ::csv_data_Attenuation $::curr_attn_value
	set ::csv_data_AttenuationIncr $::curr_attn_incr
	set ::csv_data_GnuplotCnt $::curr_gnuplot_data_line_cnt

	if {$data_flag} {
		set output_str_data ""
		set cnt 0

		foreach column "$::csv_columns_data_list" {
			if {$cnt > 0} {
				set output_str_data [concat $output_str_data ", "]
			}

			set var "csv_data_${column}"
			set output_str_data [concat $output_str_data [expr \${::${var}}]]
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			incr cnt
		}
		
		set csv_data_fd [open "$::curr_csv_data_fullname" a 0644]
		puts $csv_data_fd $output_str_data
		close $csv_data_fd
		
		set ::last_csv_data_BaseTime $::csv_data_BaseTime
	}

	if {$throughput_data_flag} {
		set output_str_throughput ""
		set cnt_throughput 0

		foreach column_throughput "$::csv_columns_throughput_list" {
			if {$cnt_throughput > 0} {
				set output_str_throughput [concat $output_str_throughput ", "]
			}

			set var "csv_data_${column_throughput}"
			set output_str_throughput [concat $output_str_throughput [expr \${::${var}}]]
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			incr cnt_throughput
		}
		
		set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" a 0644]
		puts $csv_throughput_fd $output_str_throughput
		close $csv_throughput_fd

		set ::last_csv_throughput_data_BaseTime $::csv_data_BaseTime
	}
}

proc sts::all_data_array_delete {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:all_array_delete***************************"

	UTF::Message INFO "" "delete all the STA data arrays (for endpoint, AP Controller, STA)"
	sts::array_setup_sta_data -1 1 0 0

	UTF::Message INFO "" "delete all the STA Link data arrays"
	sts::array_setup_sta_link_data -1 1 0 0

	UTF::Message INFO "" "delete all stream data arrays"
	sts::array_setup_stream_data -1 -1 1 0 0 0

	UTF::Message INFO "" "delete all ping stream data arrays"
	sts::array_setup_ping_stream_data -1 -1 1 0 0
}

proc sts::array_setup_sta_data {sta_name delete_flag create_flag print_flag} {

	UTF::Message INFO "" "************************Func:array_setup_sta_data sta_name=$sta_name delete_flag=$delete_flag create_flag=$create_flag print_flag=$print_flag***************************"

	if {$delete_flag && $create_flag} {
		incr ::error_cnt
		UTF::Message INFO "" "***Fail. Cannot set the delete_flag and create_flag simultaneously"
		error "Cannot set the delete_flag and create_flag simultaneously" 
	}

	set stream_sta_data_name_list "controller_list,ap_list,sta_list,controller_flag,ap_flag,softap_flag,sta_flag,apsta_flag,sts_flag,master_flag,slave_flag,plus_master_flag,plus_slave_flag,label,host_type,lan_ip,apsta_active_flag,apsta_disassociated_flag,apsta_ifname,apsta_macaddr,apsta_ipv6_macaddr,apsta_ip,apsta_tcpdump_pid,apsta_tcpdump_filename,apsta_drvlog_pid,apsta_drvlog_filename,sts,sts_active_flag,sts_disassociated_flag,sts_ifname,sts_macaddr,sts_ipv6_macaddr,sts_ip,sts_tcpdump_pid,sts_tcpdump_filename,sts_drvlog_pid,sts_drvlog_filename,iperf_name,iperf_ver,iperf_tcpwin"
	set stream_sta_data_name_list [split $stream_sta_data_name_list ","]

	if {[info exists ::array_sta_controller_list]} {
		set array_empty_flag 0
	} else {
		set array_empty_flag 1
	}

	foreach data_name "$stream_sta_data_name_list" {
		if {$delete_flag} {
			set var_del "array_sta_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			if {$data_name == "controller_list" || $data_name == "ap_list" || $data_name == "sta_list"} {
				if {$array_empty_flag} {
					set var "array_sta_${data_name}"
					set ::${var} "" 
					#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
				}
			} else {
				set var "array_sta_${data_name}(${sta_name})"
				if {[string last "_flag" $data_name] == -1} {
					set ::${var} "" 
				} else {
					set ::${var} 0 
				}
				#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			}
		}

		if {$print_flag} {
			if {$data_name == "controller_list" || $data_name == "ap_list" || $data_name == "sta_list"} {
				set var "array_sta_${data_name}"
			} else {
				set var "array_sta_${data_name}(${sta_name})"
			}
			
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc sts::array_setup_sta_link_data {sta_link_id delete_flag create_flag print_flag} {

	UTF::Message INFO "" "************************Func:array_setup_sta_link_data sta_link_id=$sta_link_id delete_flag=$delete_flag create_flag=$create_flag print_flag=$print_flag***************************"

	if {$delete_flag && $create_flag} {
		incr ::error_cnt
		UTF::Message INFO "" "***Fail. Cannot set the delete_flag and create_flag simultaneously"
		error "Cannot set the delete_flag and create_flag simultaneously" 
	}

	set stream_sta_link_data_list "type,src,dst,chan,security,title"
	set stream_sta_link_data_list [split $stream_sta_link_data_list ","]

	if {[info exists ::array_sta_link_type(${sta_link_id})]} {
		set array_empty_flag 0
	} else {
		set array_empty_flag 1
	}

	foreach data_name "$stream_sta_link_data_list" {
		if {$delete_flag} {
			set var_del "array_sta_link_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			set var "array_sta_link_${data_name}(${sta_link_id})"
			if {[string last "_flag" $data_name] == -1} {
				set ::${var} "" 
			} else {
				set ::${var} 0 
			}
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}

		if {$print_flag} {
			set var "array_sta_link_${data_name}(${sta_link_id})"
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc sts::array_setup_stream_data {test_cnt stream_cnt delete_flag create_flag print_flag results_data_flag} {

	UTF::Message INFO "" "************************Func:array_setup_stream_data test_cnt=$test_cnt stream_cnt=$stream_cnt delete_flag=$delete_flag create_flag=$create_flag print_flag=$print_flag results_data_flag=$results_data_flag***************************"
	
	if {$delete_flag && $create_flag} {
		incr ::error_cnt
		UTF::Message INFO "" "***Fail. Cannot set the delete_flag and create_flag simultaneously"
		error "Cannot set the delete_flag and create_flag simultaneously" 
	}

	set stream_test_data_name_list "test_cnt,cnt,ap,ap_controller,ap_controller_ip,apsta_link_chan,sts_link_chan,sts_link_first_flag,interface_possible_list,interface_existing_list,interface_active_list,total_streams_label,bt_sta_list,apsta_sta_list,sts_master_sta_list,sts_slave_sta_list,bt_only_flag,apsta_only_flag,sts_only_flag,control_chart_base_key,control_chart_key,stream_short_label,stream_label,link_type,link_security,traffic_type,traffic_priority,traffic_direction,start_time,end_time,file_name,plot_name_lt,plot_name_pt,plot_minmax_name_lt,apsta_ap,src_sta_idx,src_sta,src,src_host_type,src_ifname,src_ip,src_macaddr,src_ipv6_macaddr,src_tcpwin,src_display_str,dst_sta_idx,dst_sta,dst,dst_host_type,dst_ifname,dst_ip,dst_macaddr,dst_ipv6_macaddr,dst_tcpwin,dst_display_str,iperf_tos,throughput_scale,packet_size,bandwidth,fd_rx,fdname_rx,fd_tx,fdname_tx"
	set stream_results_data_name_list "error_msg,stream_error_msg,stream_data_missing_flag,throughput_skipped_flag,start_stream_time_secs,tx_stream_time_secs,rx_stream_time_secs,throughput,tcp_writes,tcp_errors,tcp_retries,tcp_used_memory,tcp_rtt,udp_latency_avg,udp_latency_min,udp_latency_max,udp_latency_stdev,udp_jitter,udp_lost_packets,packet_total,udp_lost_packets_percent,udp_out_of_order_packets,udp_pps,controlchart_throughput,controlchart_tcp_retries,controlchart_tcp_used_memory,controlchart_tcp_rtt,controlchart_udp_latency,controlchart_udp_jitter,controlchart_udp_lost_packets,controlchart_packet_total,controlchart_udp_lost_packets_percent,controlchart_udp_out_of_order_packets,controlchart_udp_pps,last_throughput_timestamp"

	if {$results_data_flag} {
		set stream_data_name_list "$stream_results_data_name_list"
	} else {
		set stream_data_name_list "$stream_test_data_name_list,$stream_results_data_name_list"
	}
	set stream_data_name_list [split $stream_data_name_list ","]
	
	if {[info exists ::array_streams_test_cnt]} {
		set array_empty_flag 0
	} else {
		set array_empty_flag 1
	}

	if {[info exists ::array_streams_cnt(${test_cnt})]} {
		set array_empty_1d_flag 0
	} else {
		set array_empty_1d_flag 1
	}

	foreach data_name "$stream_data_name_list" {
		if {$delete_flag} {
			set var_del "array_streams_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			if {$data_name == "test_cnt"} {
				set var "array_streams_${data_name}"
				if {$array_empty_flag} {
					set ::${var} "" 
					#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
				}
			} elseif {$data_name == "cnt" || $data_name == "ap" || $data_name == "ap_controller" || $data_name == "ap_controller_ip" || $data_name == "apsta_link_chan" || $data_name == "sts_link_chan" || $data_name == "sts_link_first_flag" || $data_name == "interface_possible_list" || $data_name == "interface_existing_list" || $data_name == "interface_active_list" || $data_name == "total_streams_label" || $data_name == "bt_sta_list" || $data_name == "apsta_sta_list" || $data_name == "sts_master_sta_list" || $data_name == "sts_slave_sta_list" || $data_name == "bt_only_flag" || $data_name == "apsta_only_flag" || $data_name == "sts_only_flag" || $data_name == "control_chart_base_key" || $data_name == "error_msg"} {
				set var "array_streams_${data_name}(${test_cnt})"
				if {$array_empty_1d_flag} {
					set ::${var} "" 
					#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
				}
			} else {
				set var "array_streams_${data_name}(${test_cnt},${stream_cnt})"
				if {[string last "_flag" $data_name] == -1} {
					set ::${var} "" 
				} else {
					set ::${var} 0 
				}
				#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			}
		}

		if {$print_flag} {
			if {$data_name == "test_cnt"} {
				set var "array_streams_${data_name}"
			} elseif {$data_name == "cnt" || $data_name == "ap" || $data_name == "ap_controller" || $data_name == "ap_controller_ip" || $data_name == "apsta_link_chan" || $data_name == "sts_link_chan" || $data_name == "sts_link_first_flag" || $data_name == "interface_possible_list" || $data_name == "interface_existing_list" || $data_name == "interface_active_list" || $data_name == "total_streams_label" || $data_name == "bt_sta_list" || $data_name == "apsta_sta_list" || $data_name == "sts_master_sta_list" || $data_name == "sts_slave_sta_list" || $data_name == "bt_only_flag" || $data_name == "apsta_only_flag" || $data_name == "sts_only_flag" || $data_name == "control_chart_base_key" || $data_name == "error_msg"} {
				set var "array_streams_${data_name}(${test_cnt})"
			} else {
				set var "array_streams_${data_name}(${test_cnt},${stream_cnt})"
			}
			
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc sts::array_setup_ping_stream_data {test_cnt stream_cnt delete_flag create_flag print_flag} {

	UTF::Message INFO "" "************************Func:array_setup_ping_stream_data test_cnt=$test_cnt stream_cnt=$stream_cnt delete_flag=$delete_flag create_flag=$create_flag print_flag=$print_flag***************************"
	
	if {$delete_flag && $create_flag} {
		incr ::error_cnt
		UTF::Message INFO "" "***Fail. Cannot set the delete_flag and create_flag simultaneously"
		error "Cannot set the delete_flag and create_flag simultaneously" 
	}

	set stream_ping_data_name_list "test_cnt,cnt,error_msg,stream_error_msg,stream_short_label,link_type,src_sta,src_host_type,src_ifname,src_ip,src_macaddr,src_ipv6_macaddr,dst_sta,dst_host_type,dst_ifname,dst_ip,dst_macaddr,dst_ipv6_macaddr"
	set stream_ping_data_name_list [split $stream_ping_data_name_list ","]
	
	if {[info exists ::array_ping_streams_test_cnt]} {
		set array_empty_flag 0
	} else {
		set array_empty_flag 1
	}

	if {[info exists ::array_ping_streams_cnt(${test_cnt})]} {
		set array_empty_1d_flag 0
	} else {
		set array_empty_1d_flag 1
	}

	foreach data_name "$stream_ping_data_name_list" {
		if {$delete_flag} {
			set var_del "array_ping_streams_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			if {$data_name == "test_cnt"} {
				set var "array_ping_streams_${data_name}"
				if {$array_empty_flag} {
					set ::${var} "" 
					#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
				}
			} elseif {$data_name == "cnt" || $data_name == "error_msg"} {
				set var "array_ping_streams_${data_name}(${test_cnt})"
				if {$array_empty_1d_flag} {
					set ::${var} "" 
					#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
				}
			} else {
				set var "array_ping_streams_${data_name}(${test_cnt},${stream_cnt})"
				if {[string last "_flag" $data_name] == -1} {
					set ::${var} "" 
				} else {
					set ::${var} 0 
				}
				#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			}
		}

		if {$print_flag} {
			if {$data_name == "test_cnt"} {
				set var "array_ping_streams_${data_name}"
			} elseif {$data_name == "cnt" || $data_name == "error_msg"} {
				set var "array_ping_streams_${data_name}(${test_cnt})"
			} else {
				set var "array_ping_streams_${data_name}(${test_cnt},${stream_cnt})"
			}
			
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc sts::p2p_associate {} {
	
	UTF::Message INFO "" "************************Func:p2p_associate***************************"

	if {$::array_streams_src_host_type(${::curr_test_no},${::curr_stream_no}) == "MacOS"} {
		# do not join using passive assoc scan
		set join_param ""
	} else {
		set join_param "-p"
	}
		
	UTF::Sleep 10
	$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) scan
	UTF::Sleep 10
	if {$::array_streams_link_security(${::curr_test_no},${::curr_stream_no}) != "open"} {
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param imode bss amode wpa2psk
	} else {
		$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) join $::p2p_ssid $join_param
	}
	UTF::Sleep 10
	$sta_name wl -i $::array_sta_sts_ifname(${sta_name}) assoc

	$sta_name rexec ifconfig $::array_sta_sts_ifname(${sta_name})
	UTF::Sleep 1
	$::array_streams_src_sta(${::curr_test_no},${::curr_stream_no}) rexec ifconfig $::array_sta_sts_ifname(${::array_streams_src_sta(${::curr_test_no},${::curr_stream_no})})
	UTF::Sleep 1
}

proc sts::ping_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:ping_test***************************"

	for {set stream_no 1} {$stream_no <= $::array_ping_streams_cnt(${::curr_test_no})} {incr stream_no} {
		set ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) ""
	}
	set ::array_ping_streams_error_msg(${::curr_test_no}) ""
	
	return "[sts::ping_link 1 1]"
}

proc sts::ping_apsta_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:ping_apsta_test***************************"
	
	return "[sts::ping_link 1 0]"
}

proc sts::ping_sts_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:ping_sts_test***************************"
	
	return "[sts::ping_link 0 1]"
}

proc sts::ping_link {apsta_flag sts_flag} {
	# access option array
	upvar {} {}

	set mac_ipv6_flag 0
	set rc 0

	if {$(pm_mode) == 0} {
		set max_ping_time_ms 5
	} elseif {$(pm_mode) == 1} { 
		set max_ping_time_ms 250
	} else {
		set max_ping_time_ms 10
	}

	set streams_high_ping_time_error ""
	set ::array_ping_streams_error_msg(${::curr_test_no}) ""

	for {set stream_no 1} {$stream_no <= $::array_ping_streams_cnt(${::curr_test_no})} {incr stream_no} {
	
		set stream_high_ping_time_error ""
		set ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) ""
		
		set label $::array_ping_streams_stream_short_label(${::curr_test_no},${stream_no})
		set stream_sta_obj $::array_ping_streams_src_sta(${::curr_test_no},${stream_no})
		set dst_ip $::array_ping_streams_dst_ip(${::curr_test_no},${stream_no})
		set src_ifname $::array_ping_streams_src_ifname(${::curr_test_no},${stream_no})
		set ipv6_dst_macaddr $::array_ping_streams_dst_ipv6_macaddr(${::curr_test_no},${stream_no})

	    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
		UTF::Message INFO "" "Start Time=$timestamp"

		UTF::Message INFO "" "Ping: $label"

		if {$::array_ping_streams_link_type(${::curr_test_no},${stream_no}) == "AWDL" && $::array_ping_streams_src_host_type(${::curr_test_no},${stream_no}) == "MacOS"} {
			set mac_ipv6_flag 1
			UTF::Message INFO "" "$stream_sta_obj rexec ping6 -c $::ping_count -I $src_ifname $ipv6_dst_macaddr"
			set catch_resp [catch {$stream_sta_obj rexec ping6 -c $::ping_count -I $src_ifname $ipv6_dst_macaddr} catch_msg]
		} else {
			UTF::Message INFO "" "$stream_sta_obj rexec ping -c $::ping_count $dst_ip"
			set catch_resp [catch "$stream_sta_obj rexec ping -c $::ping_count $dst_ip" catch_msg]
		}

	    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
		UTF::Message INFO "" "End Time=$timestamp"

		if {$catch_resp != 0} {
			# failed
			UTF::Message ERROR "" "***Failed. $catch_msg"
			set msg "Ping failed with '$catch_msg'"
			if {[string first $msg $::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no})] == -1} {
				append ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($msg)"
			}
			set msg "Ping $label Failed"
			if {[string first $msg $::array_ping_streams_error_msg(${::curr_test_no})] == -1} {
				append ::array_ping_streams_error_msg(${::curr_test_no}) "($msg)"
			}
		} else {
			set lines [split $catch_msg "\n"]

			set ping_cnt 0
			set ping_transmitted 0
			set ping_received 0
			foreach line $lines {
				set time ""
				if {$mac_ipv6_flag} {
					# mac: "16 bytes from fe80::a811:78ff:fe97:d896%awdl0, icmp_seq=0 hlim=64 time=1.207 ms"
					regexp -nocase {hlim=.* time=([-+]?[0-9]*\.?[0-9]+) +?ms} $line - time
				} else {
					# Linux: "64 bytes from 192.168.1.234: icmp_seq=1 ttl=64 time=0.025 ms"
					regexp -nocase {ttl=.* time=([-+]?[0-9]*\.?[0-9]+) +?ms} $line - time
				}

				if {$time != ""} {
					incr ping_cnt
					if {$time > $max_ping_time_ms} {
						# failed
						UTF::Message ERROR "" "***Failed. Ping time $time ms is more than $max_ping_time_ms ms"
						if {$ping_cnt == 1} {
							UTF::Message INFO "" "Skipping the 1st ping long time"
						} else {
							if {$stream_high_ping_time_error == "" || $time > $stream_high_ping_time_error} {
								set stream_high_ping_time_error $time
							}
						}
					}
				} else {
					# ping totals line
					# 5 packets transmitted, 5 received, 0% packet loss, time 4005ms					
					regexp -nocase {^(\d+) packets transmitted, (\d+) received,} $line - ping_transmitted ping_received
					UTF::Message INFO "" "ping_transmitted='$ping_transmitted' ping_received='$ping_received'"
				}				
			}

			if {$ping_cnt != $::ping_count && $ping_transmitted != $ping_received} {
				# failed
				UTF::Message ERROR "" "***Failed. Packet Loss. Received $ping_received pings instead of $ping_transmitted"
				set msg "Ping Packet Loss. Received $ping_received pings instead of $ping_transmitted"
				if {[string first $msg $::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no})] == -1} {
					append ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($msg)"
				}
				set msg "Ping $label Packet Loss"
				if {[string first $msg $::array_ping_streams_error_msg(${::curr_test_no})] == -1} {
					append ::array_ping_streams_error_msg(${::curr_test_no}) "($msg)"
				}
			}
			
			# temp workaround - do not report ping time error of less than 100 ms
			if {$stream_high_ping_time_error < 100} {
				set stream_high_ping_time_error ""
			}

			if {$stream_high_ping_time_error != ""} {
				if {$stream_high_ping_time_error > 1} {
					UTF::Message INFO "" "Rounding ping time $stream_high_ping_time_error"
					set stream_high_ping_time_error [expr {round($stream_high_ping_time_error)}]
				}

				set msg "Ping time $stream_high_ping_time_error ms is more than $max_ping_time_ms ms"
				if {[string first $msg $::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no})] == -1} {
					append ::array_ping_streams_stream_error_msg(${::curr_test_no},${stream_no}) "($msg)"
				}
			}
	
			if {$streams_high_ping_time_error == "" || $stream_high_ping_time_error > $streams_high_ping_time_error} {
				set streams_high_ping_time_error $stream_high_ping_time_error
			}
		}
		
		UTF::Message INFO "" "---------------------------------------------------------------------"
	}

	if {$streams_high_ping_time_error != ""} {
		if {$streams_high_ping_time_error > 1} {
			UTF::Message INFO "" "Rounding ping time $streams_high_ping_time_error"
			set streams_high_ping_time_error [expr {round($streams_high_ping_time_error)}]
		}
		
		set msg "Ping time $streams_high_ping_time_error ms is more than $max_ping_time_ms ms"
		if {[string first $msg $::array_ping_streams_error_msg(${::curr_test_no})] == -1} {
			append ::array_ping_streams_error_msg(${::curr_test_no}) "($msg)"
		}

		# ping time failed
		
		if {$rc == 0} {
			# for roaming test, do not report ping time error since the top nested report line will show
			# this error instead of the roaming graph results
			if {$::roaming_test_flag} {
				UTF::Message INFO "" "Roaming test: Do not report error for ping time"
			} else {
				set rc -1
			}
		}
	}

	if {$::array_ping_streams_error_msg(${::curr_test_no}) == ""} {
		return ""
	} else {
		error $::array_ping_streams_error_msg(${::curr_test_no})
	}
}

proc sts::setup_tcp_window_size {} {
	# access option array
	upvar {} {}
	
	UTF::Message INFO "" "************************Func:setup_tcp_window_size***************************"

	set stas_list ""

	foreach ap $(ap) {
		# check for 2g:5g param
		set ap [split $ap ":"]
		set ap [lindex $ap 0]

		set ap_host_type [$ap hostis]

		if {$ap_host_type == "Router"} {		
			set ap_controller [$ap cget -lanpeer]
			append stas_list "$ap_controller "
		} else {
			# SoftAP controller is the same as SoftAP machine
			set ap_controller $ap
			append stas_list "lan $ap_controller "
		}
	}

	append stas_list $(sta)
	set stas_list [string trim $stas_list]

	UTF::Message INFO "" "stas_list=$stas_list"

	foreach STA $stas_list {

		set type [$STA hostis]
		set tcp_window_size [$STA cget -tcpwindow]

		UTF::Message INFO "" "STA=$STA type=$type tcp_window_size=$tcp_window_size"

		if {$type == "Linux" || $type == "DHD" || $type == "Panda"} {

			# tcptune 

			if {$tcp_window_size == "auto" || $tcp_window_size == ""} {
				if {$tcp_window_size == "auto"} {
					UTF::Message ERROR "" "***Failed. tcpwindow parameter for $STA cannot be 'auto' in the config file."
				} else {
					UTF::Message ERROR "" "***Failed. tcpwindow parameter for $STA is missing in the config file."
				}
				incr ::error_cnt
				error "Bad tcpwindow parameter for $STA"
			}
		
			# tcptune will adjust the window size
			set resp [$STA tcptune $tcp_window_size]

			UTF::Message INFO "" "machine=$STA tcptune tcp_window_size=$tcp_window_size"	
		}	
	}
}

proc sts::validate_mac_addr {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:validate_mac_addr***************************"

	set otp_err_flag 0
	set nvram_add_err_flag 0

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
		if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
			continue
		}

		if {$::array_streams_src_macaddr(${::curr_test_no},${stream_no}) == $::array_streams_dst_macaddr(${::curr_test_no},${stream_no})} {
			set otp_err_flag 1
			UTF::Message INFO "" "Found duplicate Mac addresses for '$::array_streams_src_macaddr(${::curr_test_no},${stream_no})' in stream $stream_no"
			break
		} else {
			UTF::Message INFO "" "stream $stream_no pass: '$::array_streams_src_macaddr(${::curr_test_no},${stream_no})' != '$::array_streams_dst_macaddr(${::curr_test_no},${stream_no})'"
		}
	}

	if {$otp_err_flag == 1} {
		UTF::Message INFO "" "Found OTP programming issue"

		if {$::array_streams_src_host_type(${::curr_test_no},${stream_no}) != "MacOS"} {
			# to fix otp issue, all STAs must have 'nvram_add' parameter in the config file
			foreach sta_name $(sta) {
				set sta_macaddr ""
				regexp {macaddr=(\S+)} [$sta_name cget -nvram_add] match sta_macaddr
				if {$sta_macaddr == ""} {
					set nvram_add_err_flag 1
					UTF::Message ERROR "" "***Failed. OTP programming issue. STA $sta_name is missing 'nvram_add' parameter in the UTF config file"
				}
			}
		}
		
		incr ::error_cnt

		UTF::Try "Check OTP" {
			if {$nvram_add_err_flag == 1} {
				error "OTP programming issue. 'nvram_add' parameter missing in config file. Halting tests!"
			} else {
				# At this point, any OTP programing can be fixed with
				# ifconfig eth3 hw ether 'macaddr_from_config_nvram_add'
				# This will not work Linux AWDL since the mac_ids are not in the config

				error "OTP programming issue. Halting tests!"
			}
		}
	}
}

proc sts::channel_switch_time {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:channel_switch_time***************************"

	foreach sta_name $(sta) {
	
		if {$::array_sta_softap_flag(${sta_name}) == 1} {
			UTF::Message INFO "" "Skip SoftAP $sta_name"
			continue
		}
	
		set title ""
		set apsta_stream_no 0
		set sts_stream_no 0
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
			if {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no})} {
				set title $::array_streams_dst_display_str(${::curr_test_no},${stream_no})
			}
		}

#kevin
			UTF::Message INFO "kevin11" "here for $sta_name"

		set branch [$sta_name branchname]
		set Channelswitch_value ""
		set Bandswitch_value ""
		
		UTF::Try "$sta_name: $title Channel Switch Time" {

			set catch_resp [catch "$sta_name wl -i $::array_sta_apsta_ifname(${sta_name}) dump chanswitch" dump]

			if {$catch_resp != 0} {
				UTF::Message INFO $sta_name "$dump"
				set Bandswitch_value "N/A"
				if {[regexp {Unsupported} $dump]} {
					return "N/A"
				} else {
					return "$dump"
				}
			}
			if {![regexp {(Channelswitch: .*? Samples)} $dump - chan]} {
				UTF::Message INFO $sta_name "No channelswitch information"
				set Bandswitch_value "N/A"
				return "N/A"
			}

			# channel switch value
			# wlc_set_chanspec: Channelswitch: Avg 3.178 Millisecs, 8 Samples

			if {[regexp {Channelswitch: Avg (\d+\.\d+)} $dump match Channelswitch_value]} {
				UTF::Message INFO "" "Channelswitch=$Channelswitch_value"
			}

			# band switch value
			#wlc_set_chanspec: Bandswitch: Avg 5.229 Millisecs, 5 Samples
			if {[regexp {Bandswitch: Avg (\d+\.\d+)} $dump match Bandswitch_value]} {
				UTF::Message INFO "" "Bandswitch=$Bandswitch_value"
			} else {
				UTF::Message INFO $sta_name "No bandswitch information"
				set Bandswitch_value "N/A"
			}

			if {$Channelswitch_value == "" || $Channelswitch_value == "N/A"} {
				return "N/A"
			}

			set key [concat $branch chanswitch $sta_name]
			set html_results [sts::control_chart "" $Channelswitch_value $key "Channel Switch Time" "ms" 0]
			# zero and low are OK
			regsub { ZERO} $html_results { OK} html_results
			regsub { LOW} $html_results { OK} html_results
			return "html: $html_results"
		}

		UTF::Try "$sta_name: $title Band Switch Time" {

			if {$Bandswitch_value == "" || $Bandswitch_value == "N/A"} {
				return "N/A"
			}

			set key [concat $branch bandswitch $sta_name]
			set html_results [sts::control_chart "" $Bandswitch_value $key "Band Switch Time" "ms" 0]
			regsub { ZERO} $html_results { OK} html_results
			regsub { LOW} $html_results { OK} html_results
			return "html: $html_results"
		}
	}
}	

proc sts::get_beacon_rate {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:get_beacon_rate***************************"

	foreach sta_name $::array_streams_interface_possible_list(${::curr_test_no}) {

		if {![info exists ::array_sta_softap_flag(${sta_name})]} {
			continue
		}
		if {$::array_sta_softap_flag(${sta_name}) == 1} {
			continue
		}
		if {$::array_sta_master_flag(${sta_name}) == 1} {
			continue
		}
		
		break		
	}

	UTF::Try "$sta_name: Get Beacon Rate" {
	
		# Default driver bi=100 ms, therfore we should see 10 beacons/sec

		if {$(ap) != ""} {
			catch {$::array_streams_ap(${::curr_test_no}) wl bi}
		}

		set master_bcnrate -1
		set bcnrate 0
		foreach sta_name $::array_streams_interface_possible_list(${::curr_test_no}) {

			if {![info exists ::array_sta_softap_flag(${sta_name})]} {
				continue
			}

			if {$::array_sta_softap_flag(${sta_name}) == 1} {
				continue
			}
			
			set station_ifname $::array_sta_apsta_ifname(${sta_name})

			UTF::Try "$sta_name: Get Beacon Rate" {

				catch {$sta_name wl PM}
				catch {$sta_name wl bi}

				set output [$sta_name wl -i $station_ifname counters rxbeaconmbss]
				regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate1
				UTF::Sleep 10
				set output [$sta_name wl -i $station_ifname counters rxbeaconmbss]
				regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate2

				if {$::array_sta_plus_master_flag(${sta_name})} {
					set master_bcnrate [format "%2.1f" [expr {[expr {$bcnrate2 - $bcnrate1}] / 10.0}]]
					UTF::Message INFO "" "rxbeaconmbss=($bcnrate2 - $bcnrate1) / 10 sec=$master_bcnrate"
					UTF::Message INFO "" "Master BeaconRxRate: ${master_bcnrate}/s"
					return "Master BeaconRxRate: ${master_bcnrate}/s"
				} else {
					set bcnrate [format "%2.1f" [expr {[expr {$bcnrate2 - $bcnrate1}] / 10.0}]]
					UTF::Message INFO "" "rxbeaconmbss=($bcnrate2 - $bcnrate1) / 10 sec=$bcnrate"
					UTF::Message INFO "" "BeaconRxRate: ${bcnrate}/s"
					return "BeaconRxRate: ${bcnrate}/s"
				}				
			}
		}
		
		if {$master_bcnrate != -1} {
			set total_bcnrate [expr {$master_bcnrate + $bcnrate}]
			UTF::Message INFO "" "Total BeaconRxRate: ($master_bcnrate + $bcnrate)=$total_bcnrate"
		} else {
			set total_bcnrate $bcnrate
		}

		set ckey "$::array_streams_control_chart_base_key(${::curr_test_no}) BeaconRate"
		set total_bcnrate "$total_bcnrate $total_bcnrate $total_bcnrate"
		set html_results [sts::control_chart "" $total_bcnrate $ckey "Beacons" "Sec" 0]
		return "html: $html_results"
	}
}

proc sts::change_beacon_interval {new_bi} {

	UTF::Message INFO "" "************************Func:change_beacon_interval***************************"

	UTF::Try "$::array_streams_ap(${::curr_test_no}): Change Beacon Interval to $new_bi" {

		$::array_streams_ap(${::curr_test_no}) wl bi
		$::array_streams_ap(${::curr_test_no}) wl bi $new_bi
		$::array_streams_ap(${::curr_test_no}) wl down
		UTF::Sleep 2
		$::array_streams_ap(${::curr_test_no}) wl up
		UTF::Sleep 5
		$::array_streams_ap(${::curr_test_no}) wl bi
	}
}

proc sts::leak_check {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:leak_check***************************"

	if {!$(nounload)} {
		foreach object "$(sta) $::array_streams_ap(${::curr_test_no})" {

			if {$object == ""} {
				continue
			}

			set host_type [$object hostis]
			UTF::Message LOG "" "host_type=$host_type"

			if {$host_type != "DHD"} {
				UTF::Message LOG "" "$object is not DHD host type"
				continue
			}

			if {$object == "" || $::array_streams_sts_only_flag(${::curr_test_no}) == 1} {
				# for direct StS tests, AP radio is disabled and leak check is skipped
				continue
			}

			if {$::array_sta_softap_flag(${::array_streams_ap(${::curr_test_no})}) == 0} {
				# AP
				if {![catch {$object wl assert_type} at]} {
					UTF::Try "$object: Leak check" {
						$object wl assert_type 1
						$object wl down
						$object wl up
						$object wl assert_type [lindex $at 0]
					}
				}
			} else {
				# SoftAP
				UTF::Try "$object: MaxMem in use" {

					if {$(branch) eq "auto"} {
						set branch [$object branchname]
					} else {
						set branch $(branch)
					}
				
					UTF::Test::memchart [$object maxmem] -key [list $branch $object maxmem]
				}
			}
		}
	}
}

proc sts::get_dhd_memory_dump {} {
	# access option array
	upvar {} {}

	foreach sta_name "$(sta)" {

		UTF::Message LOG "" "sta_name=$sta_name"

		set sta_host_type [$sta_name hostis]
		UTF::Message LOG "" "sta_host_type=$sta_host_type"

		if {$sta_host_type == "DHD"} {

			UTF::Message INFO "" "************************Func:get_dhd_memory_dump***************************"

			# If the dump was triggered by messages from DHD, the dump is called dongle_dhd.dmp
			# If the dump was triggered by sdio errors, the dump is called dongle_sderr.dmp
			# If the dump was triggered by FW messages, the dump is called dongle.dmp
			
			foreach dmp_name "dongle_dhd dongle_sderr dongle" {

				UTF::Message LOG "" "Check for file /root/$dmp_name\.dmp"
				set catch_resp [catch "$sta_name rexec ls -la /root/$dmp_name\.dmp" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp == 0} {

					UTF::Try "$sta_name: DHD Memory Dump" {
						set testnum [sts::get_testnum]
						set test_dir [file dirname $UTF::Logfile]

						UTF::Message INFO "" "$sta_name copyfrom /root/$dmp_name\.dmp $test_dir/$testnum.$sta_name.$dmp_name\.dmp"
						set catch_resp [catch "$sta_name copyfrom /root/$dmp_name\.dmp $test_dir/$testnum.$sta_name.$dmp_name\.dmp" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: scp catch_msg=$catch_msg"
						} else {
							set catch_resp [catch "exec ls -la $test_dir/$testnum.$sta_name.$dmp_name\.dmp" catch_msg]
							UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

							UTF::Message INFO "" "$sta_name rm -f /root/$dmp_name\.dmp"
							set catch_resp [catch "$sta_name rm -f /root/$dmp_name\.dmp" catch_msg]

							if {$catch_resp != 0} {
							   error "ERROR: rm catch_msg=$catch_msg"
							}
						}

						UTF::Message INFO "" "PASS. Captured File: $testnum.$sta_name.$dmp_name\.dmp"
						UTF::Message INFO "" "========================================================================================================="

						if {![file exists "$test_dir/rtecdc.exe"]} {
							# copying rtecdc.exe to the report location
							set catch_resp [catch "$sta_name rexec readlink /root/hndrte-exe.lnk" catch_msg]			
							UTF::Message INFO "" "$sta_name copyfrom $catch_msg $test_dir"
							set catch_resp [catch "$sta_name copyfrom $catch_msg $test_dir" catch_msg]
						}
						
						error "Captured File: $testnum.$sta_name.$dmp_name\.dmp"
					}
				}
			}
			
			UTF::Message LOG "" "Check for file /soc_ram.bin"
			set catch_resp [catch "$sta_name rexec ls -la /soc_ram.bin" catch_msg]
        	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} {

				UTF::Try "$sta_name: DHD 'soc_ram.bin' Dump" {
					set testnum [sts::get_testnum]
					set test_dir [file dirname $UTF::Logfile]

					UTF::Message INFO "" "$sta_name copyfrom /soc_ram.bin $test_dir/$testnum.$sta_name.soc_ram.bin"
					set catch_resp [catch "$sta_name copyfrom /soc_ram.bin $test_dir/$testnum.$sta_name.soc_ram.bin" catch_msg]

					if {$catch_resp != 0} {
					   error "ERROR: scp catch_msg=$catch_msg"
					} else {
						set catch_resp [catch "exec ls -la $test_dir/$testnum.$sta_name.soc_ram.bin" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						
						UTF::Message INFO "" "$sta_name rm -f /soc_ram.bin"
						set catch_resp [catch "$sta_name rm -f /soc_ram.bin" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: rm catch_msg=$catch_msg"
						}
					}

					UTF::Message INFO "" "PASS. Captured File: $testnum.$sta_name.soc_ram.bin"
					UTF::Message INFO "" "========================================================================================================="
					error "Captured File: $testnum.$sta_name.soc_ram.bin"
				}
			}
		}
	}
	
	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "F" "::UTF::panic=$::panic_msg"
		set ::test_error_flag 1
	}
}

proc sts::sta_dhd_socram_dump {sta_name} {
	# access option array
	upvar {} {}

	set sta_host_type [$sta_name hostis]
	UTF::Message LOG "" "sta_host_type=$sta_host_type"

	if {$sta_host_type == "DHD"} {

		UTF::Message INFO "" "************************Func:sta_dhd_socram_dump $sta_name***************************"

		UTF::Try "$sta_name: Socram and FW Image Dump" {
			set testnum [sts::get_testnum]
			set test_dir [file dirname $UTF::Logfile]

			if {![file exists "$test_dir/rtecdc.exe"]} {
				# copying rtecdc.exe to the report location
				set catch_resp [catch "$sta_name rexec readlink /root/hndrte-exe.lnk" catch_msg]			
				UTF::Message INFO "" "$sta_name copyfrom $catch_msg $test_dir"
				set catch_resp [catch "$sta_name copyfrom $catch_msg $test_dir" catch_msg]
			}

			set temp [$sta_name cget -sta]
			set ifname [lindex $temp 1]

			$sta_name dhd -i $ifname upload socram.bin
			UTF::Message INFO "" "$sta_name copyfrom /root/socram.bin $test_dir/$testnum.$sta_name.socram.bin"
			set catch_resp [catch "$sta_name copyfrom /root/socram.bin $test_dir/$testnum.$sta_name.socram.bin" catch_msg]

			UTF::Message INFO "" "$sta_name rm -f /root/socram.bin"
			set catch_resp [catch "$sta_name rm -f /root/socram.bin" catch_msg]

			return ""
		}
	}
}

proc sts::dhd_socram_dump {} {
	# access option array
	upvar {} {}

	set dhd_socram_dump_flag 0
	
	foreach sta_name "$(sta)" {

		UTF::Message LOG "" "sta_name=$sta_name"

		set sta_host_type [$sta_name hostis]
		UTF::Message LOG "" "sta_host_type=$sta_host_type"

		if {$sta_host_type == "DHD"} {

			set dhd_socram_dump_flag 1
		
			sts::sta_dhd_socram_dump $sta_name
		}
	}

	if {$dhd_socram_dump_flag} {
		error "Socram and FW image dumped. Halting tests!"				
	} else {
		return ""
	}
}

proc sts::get_sniffer_data {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:get_sniffer_data***************************"

	UTF::Try "Sniffer Data for Channel $::sniffer_channel" {

		catch {$::sniffer_object rexec ifconfig -a}
		UTF::Message INFO "" "------------------------------------------"

		UTF::Message LOG "" "Check for sniffer file /tmp/$::sniffer_filename"
		set catch_resp [catch "$::sniffer_object rexec ls -la /tmp/$::sniffer_filename" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp == 0} {

			set testnum [sts::get_testnum]
			set test_dir [file dirname $UTF::Logfile]

			UTF::Message INFO "" "$::sniffer_object copyfrom /tmp/$::sniffer_filename $test_dir/$testnum.$::sniffer_filename"
			set catch_resp [catch "$::sniffer_object copyfrom /tmp/$::sniffer_filename $test_dir/$testnum.$::sniffer_filename" catch_msg]

			if {$catch_resp != 0} {
			   error "ERROR: scp catch_msg=$catch_msg"
			} else {
				catch "exec chmod 755 $test_dir/$testnum.$::sniffer_filename"
				set catch_resp [catch "exec ls -la $test_dir/$testnum.$::sniffer_filename" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

				UTF::Message INFO "" "$::sniffer_object rm -f /tmp/$::sniffer_filename"
				set catch_resp [catch "$::sniffer_object rm -f /tmp/$::sniffer_filename" catch_msg]

				if {$catch_resp != 0} {
				   error "ERROR: rm catch_msg=$catch_msg"
				}
			}

			UTF::Message INFO "" "PASS. Captured Sniffer File: $test_dir/$testnum.$::sniffer_filename"
			return "html: <a href=\"$test_dir/$testnum.$::sniffer_filename\">{Sniffer pcap File}</a>"
		} else {
			error "/tmp/$::sniffer_filename missing on $::sniffer_object"
		}
	}
}

proc sts::unload_sta_driver {} {
	# access option array
	upvar {} {}

	UTF::Try "Running Processes" {
	
		set stas_list ""

		if {$(ap) != ""} {
			foreach ap $(ap) {
				# check for 2g:5g param
				set ap2g [split $ap ":"]
				set ap2g [lindex $ap2g 0]

				set ap_host_type [$ap2g hostis]

				if {$ap_host_type == "Router"} {		
					set ap_controller [$ap2g cget -lanpeer]
					lappend stas_list "AP Controller '$ap_controller': $ap"
					lappend stas_list "$ap_controller "
				} else {
					# SoftAP controller is the same as SoftAP machine
					set ap_controller $ap
					lappend stas_list "SoftAP Controller 'lan': $ap"
					lappend stas_list "lan"
					lappend stas_list "SoftAP '$ap_controller'"
					lappend stas_list "$ap_controller"
				}
			}
		} else {
			lappend stas_list "Controller 'lan': No AP"
			lappend stas_list "lan"
		}

		foreach sta $(sta) {
			lappend stas_list "STA '$sta'"
			lappend stas_list "$sta"
		}
		
		set stas_list [string trim $stas_list]
		UTF::Message INFO "stas_list" "$stas_list"

		foreach {sta_label sta_name} $stas_list {

			set sta_label [string trim $sta_label]
			set sta_name [string trim $sta_name]

			UTF::Try "$sta_label" {
				UTF::Message INFO "" "Dumping Running Processes to catch 'fork' issue"
				set catch_resp [catch "$sta_name ps -ef f" catch_msg]
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Message INFO "" "-----------------------------------------------"
			}

			catch {$sta_name deinit}
		}
	}
	
	UTF::Message INFO "" "************************Func:unload_sta_driver***************************"

	UTF::Try "Unload Driver" {

		foreach sta_name $(sta) {

			UTF::Try "$sta_name" {
				$sta_name unload
			}

			catch {$sta_name deinit}
		}
	}
}

proc sts::create_summary_graphs_link {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_summary_graphs_link***************************"

	set testnum [sts::get_testnum]
	regsub -all {.} $testnum "_" $testnum

	set ::graphs_all_list ""

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	foreach sta_name $(sta) {
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA is active"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				if {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) && [lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
					# StS link
					UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${stream_no}) is active"
					break
				}
			}
		}
	}

	# both TCP and UDP graphs are processed
	foreach graph_name "$::throughput_graphs_name_list" {
		lappend ::graphs_all_list "${graph_name}"
	}

	#UTF::Message LOG "" "======================================ampdu_heatmap_flag===================================================="
	
	set objects "$::array_streams_interface_existing_list(${::curr_test_no}) $(ap)"
	set objects [sts::remove_duplicates $objects]
	
	foreach object $objects {

		#UTF::Message LOG "" "-----------------------------------object=$object-----------------------------------------------------"

		if {$object == $::array_streams_ap(${::curr_test_no}) || $object == $::roaming_src_ap || $object == $::roaming_dst_ap} {
			set object_type "Ap"
			set ap_flag 1
		} else {
			set object_type "Sta"
			set ap_flag 0
		}

		set ampdu_heatmap_flag 0
		if {$ap_flag == 1 && $active_sta_apsta_flag == 1} {
			# AP with APSTA active - ampdu_heatmap graphs are needed
			set ampdu_heatmap_flag 1
		}

		if {[lsearch -exact $::array_streams_apsta_sta_list(${::curr_test_no}) $object] >= 0 && $active_sta_apsta_flag == 1} {
			# APSTA STA is active - ampdu_heatmap graphs are needed
			set ampdu_heatmap_flag 1
		}

		if {$ampdu_heatmap_flag} {
			set graphs_list "$::graphs_name_list $::ampdu_heatmap_graphs_name_list"
		} else {
			set graphs_list "$::graphs_name_list"
		}

		foreach graph_name $graphs_list {

			if {[string first $object_type $graph_name] == 0} {
				lappend ::graphs_all_list "${graph_name}(${object})"
			}
		}
	}

	#UTF::Message LOG "" "======================================All Graphs Link Starts===================================================="
	
	lappend ::graphs_all_list $::other_graphs_name_list
	regsub -all {\{} $::graphs_all_list "" ::graphs_all_list
	regsub -all {\}} $::graphs_all_list "" ::graphs_all_list
	# do not sort, so throughput graph is first	
	#set ::graphs_all_list [lsort $::graphs_all_list]
	UTF::Message INFO "" "::graphs_all_list=$::graphs_all_list"
	
	foreach graph_name $::graphs_all_list {

		#UTF::Message LOG "" "======================================graph_name=$graph_name===================================================="

		if {$graph_name == "CSVThroughput" || $graph_name == "CSVData" || $graph_name == "MainReport"} {
			continue
		}

		set htmFile [open $::logdir/GraphsData/$testnum.${graph_name}.htm w 0644]
		puts $htmFile {<?xml version="1.0" encoding="utf-8"?>}
		puts $htmFile {<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">}
		puts $htmFile {<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">}
		puts $htmFile ""
		puts $htmFile "<head>"
		puts $htmFile "<title></title>"
		puts $htmFile "<style>"
		puts $htmFile ""
		puts $htmFile "p.small \{line-height:70%;\}"
		puts $htmFile "p.medium \{line-height:90%;\}"
		puts $htmFile "</style>"
		puts $htmFile "</head>"
		puts $htmFile ""
		puts $htmFile "<body>"
		puts $htmFile "<p class=\"small\">"
		puts $htmFile ""

		puts $htmFile "<font size=\"2\" color=\"blue\">"

		foreach sta_graph_name $::throughput_graphs_name_list {
			if {[string first "Sta" $sta_graph_name] == 0} {
				set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
				set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}.png"
				if {[file exists "$png_file"]} {
					puts $htmFile "<a href=\"$testnum.${sta_graph_name}.htm\">{$sta_graph_name_short}</a>"	
				} else {
					puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
				}
			}
		}
		foreach other_graph_name $::other_graphs_name_list {
			if {$other_graph_name == "MainReport"} {
				puts $htmFile "<a href=\"../summary.html\">{MainReport}</a>"		
			} elseif {$other_graph_name == "CSVThroughput"} {
				puts $htmFile "<a href=\"$::curr_csv_throughput_data_file\">{CSV Throughput}</a>"		
			} elseif {$other_graph_name == "CSVData"} {
				puts $htmFile "<a href=\"$::curr_csv_data_file\">{CSV Data}</a>"		
			} else {
				puts $htmFile "<a href=\"$testnum.$other_graph_name.htm\">{$other_graph_name}</a>"		
			}
		}
		puts $htmFile "</font><br>"
		puts $htmFile "<br>"
		puts $htmFile ""

		#UTF::Message LOG "" "======================================finished the 1st line link items for $graph_name===================================================="
		
		foreach STA "$::array_streams_interface_existing_list(${::curr_test_no})" {

			UTF::Message LOG "" "######################################Interface=$STA####################################################"

			# skip invalid interfaces
			if {[info exists ::array_sta_sta_flag(${STA})]} {
				# skip the AP/SoftAP interfaces
				if {$::array_sta_sta_flag(${STA}) != 1} {
					#UTF::Message INFO "" "$STA is not an STA. Skip."
					continue
				}
			}

			set active2_sta_apsta_flag 0
			set active2_sta_sts_flag 0
			foreach sta_name $(sta) {
				if {[string compare $STA $sta_name] == 0} {
					UTF::Message INFO "" "$sta_name APSTA link is active"
					set active2_sta_apsta_flag 1
				}
				if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
					UTF::Message INFO "" "$sta_name StS link is active"
					set active2_sta_sts_flag 1
				}
			}

			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				if {[info exists ::array_sta_softap_flag(${STA})] && $::array_sta_softap_flag(${STA}) == 1} {
					if {$STA == $::array_streams_src_sta(${::curr_test_no},${stream_no}) || $STA == $::array_streams_src(${::curr_test_no},${stream_no})} {
						UTF::Message INFO "" "$STA $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
						break
					}
				} else {
					if {$STA == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) || $STA == $::array_streams_dst(${::curr_test_no},${stream_no})} {
						UTF::Message INFO "" "$STA $::array_streams_link_type(${::curr_test_no},${stream_no}) stream_no=$stream_no"
						break
					}
				}
			}

			if {$stream_no > $::array_streams_cnt(${::curr_test_no})} {
				# failed
				incr ::error_cnt
				UTF::Message ERROR "" "$STA is not found in the streams"
				error "$STA is not found in the streams"										
			}
			
			if {$::array_streams_apsta_only_flag(${::curr_test_no})} {
				# one STA only
				set sta_str "STA"
				UTF::Message INFO "" "1 - sta_str=$sta_str"
			} elseif {$active2_sta_apsta_flag == 1} {
				set sta_str "APSTA"
				UTF::Message INFO "" "2 - sta_str=$sta_str"
			} elseif {$active2_sta_sts_flag == 1} {
				set sta_str "$::array_streams_link_type(${::curr_test_no},${stream_no})"
				UTF::Message INFO "" "3 - sta_str=$sta_str"
			}
		
			puts $htmFile "<font size=\"2\" color=\"black\"><b>$sta_str </b></font>"
			puts $htmFile "<font size=\"2\" color=\"red\"><b>$STA</b></font>"
			puts $htmFile "<font size=\"2\" color=\"black\"><b> Graphs: </b></font>"
			puts $htmFile "<font size=\"2\" color=\"blue\">"
			foreach sta_graph_name $::graphs_name_list {
				#UTF::Message LOG "" "--------------------------------------sta_graph_name=$sta_graph_name----------------------------------------------------"

				if {$active2_sta_apsta_flag == 0 && $active2_sta_sts_flag == 1} {
					if {$sta_graph_name == "StaApConnectTime" || $sta_graph_name == "StaApRssi"} {
						#UTF::Message INFO "" "Graph $graph_name: Interface $STA - For StS, skip graphing $sta_graph_name"
						continue
					}
				}
					
				if {[string first "Sta" $sta_graph_name] == 0} {
					set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
					if {!([string first "StaThroughput" $sta_graph_name] == 0 || [string first "StaTCPWrites" $sta_graph_name] == 0 || [string first "StaTCPErrors" $sta_graph_name] == 0 || [string first "StaTCPRetries" $sta_graph_name] == 0 || [string first "StaTCPUsedMemory" $sta_graph_name] == 0 || [string first "StaTCPRTT" $sta_graph_name] == 0 \
					      || [string first "StaUDPLatency" $sta_graph_name] == 0 || [string first "StaUDPJitter" $sta_graph_name] == 0 || [string first "StaUDPLostPackets" $sta_graph_name] == 0 || [string first "StaUDPOutofOrderPackets" $sta_graph_name] == 0 || [string first "StaUDPPPS" $sta_graph_name] == 0)} {
						set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}(${STA}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${sta_graph_name}(${STA}).htm\">{$sta_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
						}
					}
				}
			}
			puts $htmFile "</font><br>"
			puts $htmFile ""

			set ampdu_heatmap_flag 0
			if {[lsearch -exact $::array_streams_apsta_sta_list(${::curr_test_no}) $STA] >= 0 && $active2_sta_apsta_flag == 1} {
				# APSTA STA is active - ampdu_heatmap graphs are needed
				set ampdu_heatmap_flag 1
			}

			if {$ampdu_heatmap_flag} {
				set tmp_str "$sta_str $STA Graphs: "
				regsub -all {.} $tmp_str {\&nbsp;\&nbsp;} tmp_str

				puts $htmFile "<font size=\"2\" color=\"black\"><b>$tmp_str</b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach sta_graph_name $::ampdu_heatmap_graphs_name_list {
					if {[string first "Sta" $sta_graph_name] == 0} {
						set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
						set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}(${STA}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${sta_graph_name}(${STA}).htm\">{$sta_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""
			}
		}

		if {$(ap) != "" && $active_sta_apsta_flag == 1} {
			foreach ap $(ap) {
				#UTF::Message LOG "" "-----------------------------------ap=$ap-----------------------------------------------------"
				# check for 2g:5g param
				set AP [split $ap ":"]
				set AP [lindex $AP 0]
				puts $htmFile "<font size=\"2\" color=\"black\"><b>AP </b></font>"
				puts $htmFile "<font size=\"2\" color=\"red\"><b>$AP</b></font>"
				puts $htmFile "<font size=\"2\" color=\"black\"><b> Graphs: </b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach ap_graph_name $::graphs_name_list {
					if {[string first "Ap" $ap_graph_name] == 0} {
						set ap_graph_name_short [string replace $ap_graph_name 0 1 ""]
						set png_file "$::logdir/GraphsData/$testnum.${ap_graph_name}(${AP}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${ap_graph_name}(${AP}).htm\">{$ap_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$ap_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""

				set tmp_str "AP $AP Graphs: "
				regsub -all {.} $tmp_str {\&nbsp;\&nbsp;} tmp_str

				puts $htmFile "<font size=\"2\" color=\"black\"><b>$tmp_str</b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach ap_graph_name $::ampdu_heatmap_graphs_name_list {
					if {[string first "Ap" $ap_graph_name] == 0} {
						set ap_graph_name_short [string replace $ap_graph_name 0 1 ""]
						set png_file "$::logdir/GraphsData/$testnum.${ap_graph_name}(${AP}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${ap_graph_name}(${AP}).htm\">{$ap_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$ap_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""
			}
		}
				
		puts $htmFile "</p>"
		
		puts $htmFile "<p class=\"medium\">"

		if {$::roaming_test_flag} {
			puts $htmFile "<font size=\"4\" color=\"orange\"><b>$::roaming_test_title</b></font><br>"
		}

		puts $htmFile "<font size=\"4\" color=\"orange\"><b>$::graph_label_test$::array_streams_total_streams_label(${::curr_test_no})</b></font><br>"
		puts $htmFile "<font size=\"4\" color=\"orange\"><b>$graph_name Summary Graph</b></font><br>"
		puts $htmFile "</p>"
		puts $htmFile "<table border=\"0\">"
		if {$graph_name == "AllGraphs"} {
			foreach graph_all_name $::graphs_all_list {
				if {[string first "Ap" $graph_all_name] == 0 && $active_sta_apsta_flag == 0} {
					continue
				}
				if {[string first "Ap" $graph_all_name] == 0 || [string first "Sta" $graph_all_name] == 0 } {
					set png_file "$::logdir/GraphsData/$testnum.$graph_all_name.png"
					if {[file exists "$png_file"]} {
						puts $htmFile "<tr><td>$graph_all_name</td><td><img src=\"$png_file\" alt=\"\" width=\"$::graph_max_width\" height=\"::graph_max_height\" border=\"0\"></td></tr>"
					} else {
						puts $htmFile "<tr><td>$graph_all_name</td><td><font color=\"red\">N/A</font></td></tr>"
					}
				}
			}
		} else {			
			puts $htmFile "<td><img src=\"$::logdir/GraphsData/$testnum.${graph_name}.png\" alt=\"\" width=\"$::graph_max_width\" height=\"$::graph_max_height\" border=\"0\"></td>"
		}
		puts $htmFile "</table>"
		puts $htmFile ""
		puts $htmFile "</body>"
		puts $htmFile "</HTML>"
		close $htmFile
	}

	return "<a href=\"GraphsData/$testnum.StaThroughput.htm\"><b>\{Graph Summaries\}</b></a>"
}

proc find_csv_column_index {column_title all_columns_list} {

	UTF::Message INFO "" "************************Func:find_csv_column_index***************************"

	set index [lsearch -exact $all_columns_list $column_title]
	if {$index >= 0} {
		UTF::Message LOG "" "column_title=$column_title index=$index"
	} else {
		UTF::Message LOG "" "CSV column title $column_title is not found"
	}
	
	return $index
}

proc sts::create_summary_graphs {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_summary_graphs***************************"

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	foreach sta_name $(sta) {
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA is active"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				if {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) && [lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
					# StS link
					UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${stream_no}) is active"
					break
				}
			}
		}
	}
	
	UTF::Message INFO "" "::last_csv_data_BaseTime=$::last_csv_data_BaseTime ::last_csv_throughput_data_BaseTime=$::last_csv_throughput_data_BaseTime"
	if {$::last_csv_data_BaseTime == ""} {
		# there must be no data in the 'test_data.csv' file
		# this get hit with BT only thoughput test and AWDL MacOS
		set ::last_csv_data_BaseTime $::last_csv_throughput_data_BaseTime
	}
	if {$::last_csv_throughput_data_BaseTime == ""} {
		UTF::Message ERROR "" "***Failed. ::last_csv_throughput_data_BaseTime is BLANK"
		error "Graphing failed"	
	}
	set last_csv_data_BaseTime "00:$::last_csv_data_BaseTime"
	set last_csv_data_BaseTime_tick [clock scan $last_csv_data_BaseTime]
	set last_csv_throughput_data_BaseTime "00:$::last_csv_throughput_data_BaseTime"
	set last_csv_throughput_data_BaseTime_tick [clock scan $last_csv_throughput_data_BaseTime]
	UTF::Message INFO "" "last_csv_data_BaseTime_tick=$last_csv_data_BaseTime_tick last_csv_throughput_data_BaseTime_tick=$last_csv_throughput_data_BaseTime_tick"
	
	if {$last_csv_data_BaseTime_tick > $last_csv_throughput_data_BaseTime_tick} {
		set ::gnuplot_x_max_time_val $::last_csv_data_BaseTime
	} else {
		set ::gnuplot_x_max_time_val $::last_csv_throughput_data_BaseTime
	}
	UTF::Message INFO "" "::gnuplot_x_max_time_val=$::gnuplot_x_max_time_val"
	
	####################

	if {$::bt_load_flag} {
		if {$::bt_only_flag} {
			set tmp_throughput_label "BT Throughput (Kbps)"
		} else {
			if {$::array_streams_link_type(${::curr_test_no},${fixit_stream_no}) != "APSTA"} {
				set tmp_throughput_label "Throughputs (Infra & AWDL (Mbps))(BT (Kbps))"
			} elseif {$::array_streams_link_type(${::curr_test_no},${fixit_stream_no}) != "APSTA"} {
				set tmp_throughput_label "Throughputs (AWDL (Mbps))(BT (Kbps))"
			} elseif {} {
				set tmp_throughput_label "Throughputs (Infra (Mbps))(BT (Kbps))"
			}
		}
	} else {
		set tmp_throughput_label "Throughput (Mbps)"
	}
	
	set ::throughput_graphs_name_label_list "$tmp_throughput_label,TCP RTT (ms),TCP Writes,TCP Errors,TCP Retries,TCP Used Memory (k),UDP Latency (ms),UDP Jitter (ms),UDP Lost Packets,UDP OOO Packets,UDP PPS (pps)"
	set ::throughput_graphs_name_list "StaThroughput StaTCPRTT StaTCPWrites StaTCPErrors StaTCPRetries StaTCPUsedMemory StaUDPLatency StaUDPJitter StaUDPLostPackets StaUDPOutofOrderPackets StaUDPPPS"

	set ::graphs_name_label_list "MCS Rate (Index #),Rate (Mbps),RSSI (dB),Beacons/Sec,Connect Time (Seconds),RSSI (dB),MCS Rate (Index #),Rate (Mbps)"
	set ::graphs_name_list "StaMcsRate StaTxRate StaRssi StaBeaconRate StaApConnectTime StaApRssi ApMcsRate ApTxRate"

	set ::ampdu_heatmap_graphs_name_label_list "MPDU Density,MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),PER,VHT Rate,VHT Rate,VHT Rate,VHT Rate,PER,MPDU Density,MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),PER,VHT Rate,VHT Rate,VHT Rate,VHT Rate,PER"
	set ::ampdu_heatmap_graphs_name_list "StaMpduDensity StaRxMcs StaTxMcs StaRxMcsSgi StaTxMcsSgi StaMcsPer StaRxVht StaTxVht StaRxVhtSgi StaTxVhtSgi StaVhtPer ApMpduDensity ApRxMcs ApTxMcs ApRxMcsSgi ApTxMcsSgi ApMcsPer ApRxVht ApTxVht ApRxVhtSgi ApTxVhtSgi ApVhtPer"

	set ::other_graphs_name_list "CSVThroughput CSVData AllGraphs MainReport"

	set ::throughput_graphs_name_label_list [split $::throughput_graphs_name_label_list ","]
	set ::graphs_name_label_list [split $::graphs_name_label_list ","]
	set ::ampdu_heatmap_graphs_name_label_list [split $::ampdu_heatmap_graphs_name_label_list ","]

	# both TCP and UDP graphs are processed
	foreach graph_name $::throughput_graphs_name_list graph_name_label $::throughput_graphs_name_label_list {
		sts::create_2d_summary_graphs $graph_name $graph_name_label
	}
	
	foreach graph_name $::graphs_name_list graph_name_label $::graphs_name_label_list {
		if {[string first "Ap" $graph_name] == 0} {
			if {$active_sta_apsta_flag == 0} {
				continue
			}
			set object_list "$(ap)"
		} else {
			set object_list "$::array_streams_interface_existing_list(${::curr_test_no})"
		}

		# if direct P2P test, then skip StaApConnectTime and StaApRssi graphs
		if {$::array_streams_ap_controller(${::curr_test_no}) == ""} {
			if {$graph_name == "StaApConnectTime" || $graph_name == "StaApRssi"} {
				UTF::Message INFO "" "For Direct P2P, skip graphing $graph_name"
				continue
			}
		}

		set object_list [sts::remove_duplicates $object_list]
		
		foreach object $object_list {
			UTF::Message INFO "" "##############################object=$object###################################"
			sts::create_2d_summary_graphs "${graph_name}(${object})" $graph_name_label
		}
	}

	foreach graph_name $::ampdu_heatmap_graphs_name_list graph_name_label $::ampdu_heatmap_graphs_name_label_list {
		if {[string first "Ap" $graph_name] == 0} {
			if {$active_sta_apsta_flag == 0} {
				continue
			}
			set object_list "$(ap)"
		} else {
			set object_list "$::array_streams_interface_existing_list(${::curr_test_no})"
		}

		set object_list [sts::remove_duplicates $object_list]

		foreach object $object_list {

			set ap [lindex $(ap) 0]
			set ap2g [split $ap ":"]
			set ap2g [lindex $ap2g 0]

			# ampdu 3D graphs for StS is the same as APSTA
			set ampdu_heatmap_flag 0
			if {$object == $ap2g || $object == $::roaming_src_ap || $object == $::roaming_dst_ap} {
				set ampdu_heatmap_flag 1
			}
			if {[lsearch -exact $::array_streams_apsta_sta_list(${::curr_test_no}) $object] >= 0 && $active_sta_apsta_flag == 1} {
				# APSTA STA is active - ampdu_heatmap graphs are needed
				set ampdu_heatmap_flag 1
			}

			if {$ampdu_heatmap_flag == 0} {
				continue
			}
			UTF::Message INFO "" "##############################object=$object###################################"
			set new_graph_name "${graph_name}(${object})"
			sts::create_3d_summary_graphs $new_graph_name $graph_name_label
		}
	}
	
	#####################################################
	#######     Create Summary Graphs Link      #########
	#####################################################
	set graph_summaries_link [sts::create_summary_graphs_link]

	return $graph_summaries_link
}

proc sts::create_2d_summary_graphs {graph_name graph_ylabel} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_2d_summary_graphs $graph_name***************************"

	set stream_time 0
	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
		if {$stream_time < $::array_streams_end_time(${::curr_test_no},${stream_no})} {
			set stream_time $::array_streams_end_time(${::curr_test_no},${stream_no})
		}
	}

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0
	foreach sta_name $(sta) {
		if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
			set active_sta_apsta_flag 1
			UTF::Message INFO "" "$sta_name APSTA link is active"
		}
		if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
			set active_sta_sts_flag 1
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
				if {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) && [lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
					# StS link
					UTF::Message INFO "" "$sta_name $::array_streams_link_type(${::curr_test_no},${stream_no}) is active"
					break
				}
			}
		}
	}

	UTF::Message INFO "" "apsta_active_flag=$active_sta_apsta_flag"
	UTF::Message INFO "" "sts_active_flag=$active_sta_sts_flag"

	set csv_header_line_cnt 2
		
	###################################################################
	# genrate the gnu_data file
	###################################################################

	set rate_flag 0
	set nrate_flag 0
	set rssi_flag 0
	set graph_special_flag 0
	set graph_throughput_flag 0

	if {[regexp {StaThroughput} $graph_name] || [regexp {StaTCPWrites} $graph_name] || [regexp {StaTCPErrors} $graph_name] || [regexp {StaTCPRetries} $graph_name] || [regexp {StaTCPUsedMemory} $graph_name] || [regexp {StaTCPRTT} $graph_name] || [regexp {StaUDPLatency} $graph_name] || [regexp {StaUDPJitter} $graph_name] || [regexp {StaUDPLostPackets} $graph_name] || [regexp {StaUDPOutofOrderPackets} $graph_name] || [regexp {StaUDPPPS} $graph_name]} {
		set graph_special_flag 1
		if {[regexp {StaThroughput} $graph_name]} {
			set graph_throughput_flag 1
		}
	}

	if {$::rvr_test_flag == 0} {
		set csv_index_BaseTime [find_csv_column_index "BaseTime" $::csv_columns_data_list]
	} else {
		set csv_index_GnuplotCnt [find_csv_column_index "GnuplotCnt" $::csv_columns_data_list]
	}

	if {$graph_special_flag} {

		# graph_name(4354e-FC19-DUTx)(APSTA:STA<-LAN)
		#             sta_name   stream_no

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "BT"} {
				set stream_sta_obj $(bt_root_sta)
			} else {
				if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "APSTA"} {
					if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
						set stream_sta_obj $::array_streams_src_sta(${::curr_test_no},${stream_no})
					} else {
						set stream_sta_obj $::array_streams_dst_sta(${::curr_test_no},${stream_no})
					}
				} else {
					if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
						set stream_sta_obj $::array_streams_src(${::curr_test_no},${stream_no})
					} else {
						set stream_sta_obj $::array_streams_dst(${::curr_test_no},${stream_no})
					}
				}
			}

			set var "${graph_name}(${stream_sta_obj})(${stream_name})"

			set array_csv_index(${::curr_test_no},${stream_no}) [find_csv_column_index "${var}" $::csv_columns_throughput_list]		
			if {$array_csv_index(${::curr_test_no},${stream_no}) == -1} {
				UTF::Message INFO "" "CSV column title ${var} is not found. Skip this column"
				return
			}
			if {$::graphs_with_min_max} {
				set array_csv_index_min(${::curr_test_no},${stream_no}) [find_csv_column_index "${graph_name}Min(${stream_sta_obj})(${stream_name})" $::csv_columns_throughput_list]
				set array_csv_index_max(${::curr_test_no},${stream_no}) [find_csv_column_index "${graph_name}Max(${stream_sta_obj})(${stream_name})" $::csv_columns_throughput_list]
			} else {
				# use reg throughput as max
				set array_csv_index_max(${::curr_test_no},${stream_no}) $array_csv_index(${::curr_test_no},${stream_no})
			}
		}
		
		# read the csv data to figure out max_value

		set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" r]

		set max_value 0
		set csv_curr_line_no 0

		while {[gets $csv_throughput_fd line]>=0} { 
			incr csv_curr_line_no

			# skip csv header
			if {$csv_curr_line_no <= $csv_header_line_cnt} {
				continue
			}

			set columns [split $line ","]
			
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

				set array_data_max(${::curr_test_no},${stream_no}) "[lindex $columns $array_csv_index_max(${::curr_test_no},${stream_no})]"
				set array_data_max(${::curr_test_no},${stream_no}) [string trim $array_data_max(${::curr_test_no},${stream_no})]

				if {$array_data_max(${::curr_test_no},${stream_no}) > $max_value} {
					set max_value $array_data_max(${::curr_test_no},${stream_no})
				}
			}
		}
		
		close $csv_throughput_fd
		
		UTF::Message INFO "" "max_value=$max_value"

		if {[expr {round($max_value)}] < 40} {
			set max_value 40
			UTF::Message INFO "" "max_value adjusted to $max_value"
		}
	} else {
		set csv_index [find_csv_column_index $graph_name  $::csv_columns_data_list]

		if {$csv_index == -1} {
			UTF::Message INFO "" "CSV column title $graph_name is not found. Skip this column"
			return
		}

		if {[regexp {ApTxRate} $graph_name] || [regexp {StaTxRate} $graph_name]} {
			set rate_flag 1
		}

		if {[regexp {ApMcsRate} $graph_name] || [regexp {StaMcsRate} $graph_name]} {
			set nrate_flag 1
		}
		
		if {[regexp {ApRssi} $graph_name] || [regexp {StaRssi} $graph_name]} {
			set rssi_flag 1
		}
	}

	UTF::Message INFO "" "========================2D graph_name=$graph_name==========================="

	###################################################################
	# genrate the gnu_data file
	###################################################################

	regsub -all {:} $graph_name "-" graph_file_name
	regsub -all {\->} $graph_file_name "TX" graph_file_name
	regsub -all {<\-} $graph_file_name "RX" graph_file_name
	regsub -all {<>} $graph_file_name "BI" graph_file_name

	set testnum [sts::get_testnum]
	regsub -all {.} $testnum "_" $testnum

	if {$graph_special_flag == 1} {

		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set idx $::array_streams_file_name(${::curr_test_no},${stream_no})
			set filename "$testnum\.${graph_file_name}(${idx})"
			set gnu_data_filename(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
			set gnu_data_fd(${idx}) [open "$gnu_data_filename(${idx})" w 0644]
			UTF::Message INFO "" "========================2D gnu_data_filename(${idx})=$gnu_data_filename(${idx})==========================="
			UTF::Message INFO "" "gnu_data_fd(${idx})=$gnu_data_fd(${idx})"

			if {$::graphs_with_min_max} {
				set filename "$testnum\.${graph_file_name}Min(${idx})"
				set gnu_data_filename_min(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_min_fd(${idx}) [open "$gnu_data_filename_min(${idx})" w 0644]
				UTF::Message INFO "" "========================2D gnu_data_filename_min(${idx})=$gnu_data_filename_min(${idx})==========================="

				set filename "$testnum\.${graph_file_name}Max(${idx})"
				set gnu_data_filename_max(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_max_fd(${idx}) [open "$gnu_data_filename_max(${idx})" w 0644]
				UTF::Message INFO "" "========================2D gnu_data_filename_max(${idx})=$gnu_data_filename_max(${idx})==========================="
			}
		}
	} else {
		set filename "$testnum\.${graph_file_name}"
		set gnu_data_filename "$::logdir/GraphsData/${filename}.gnu_data"
		set gnu_data_fd [open "$gnu_data_filename" w 0644]
		UTF::Message INFO "" "========================2D gnu_data_filename=$gnu_data_filename==========================="
	}

	###################################################################
	# genrate the gnu_data files for ap_state, apsta_state, sts_state
	###################################################################

	set active_sta_apsta_flag 0
	set active_sta_sts_flag 0

	if {$graph_special_flag == 1 && $graph_throughput_flag == 1} {
		set sta_no 0
		foreach sta_name $(sta) {
			incr sta_no
			UTF::Message INFO "" "-----------------------------------STATE($sta_name) sta_no=$sta_no----------------------------------------------"

			if {[expr {round($max_value)}] > 500} {
				set base_sta_graph_assoc_val 20
				UTF::Message INFO "" "500 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 20]
						UTF::Message INFO "" "500 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 6}]
				set sta_graph_assoc_val_apsta [expr {$base_sta_graph_assoc_val + 3}]
				set sta_graph_assoc_val_sts  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 100} {
				set base_sta_graph_assoc_val 10
				UTF::Message INFO "" "100 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 10]
						UTF::Message INFO "" "100 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 4}]
				set sta_graph_assoc_val_apsta [expr {$base_sta_graph_assoc_val + 2}]
				set sta_graph_assoc_val_sts  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 50} {
				set base_sta_graph_assoc_val 4
				UTF::Message INFO "" "50 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 6]
						UTF::Message INFO "" "50 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 4}]
				set sta_graph_assoc_val_apsta [expr {$base_sta_graph_assoc_val + 2}]
				set sta_graph_assoc_val_sts  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 10} {
				set base_sta_graph_assoc_val 1
				UTF::Message INFO "" "10 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 2]
						UTF::Message INFO "" "10 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 1}]
				set sta_graph_assoc_val_apsta [expr {$base_sta_graph_assoc_val + .5}]
				set sta_graph_assoc_val_sts  $base_sta_graph_assoc_val
			} else {
				set base_sta_graph_assoc_val .5
				UTF::Message INFO "" "base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 1]
						UTF::Message INFO "" "sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + .4}]
				set sta_graph_assoc_val_apsta [expr {$base_sta_graph_assoc_val + .2}]
				set sta_graph_assoc_val_sts  $base_sta_graph_assoc_val
			}
			UTF::Message INFO "" "sta_graph_assoc_val_ap=$sta_graph_assoc_val_ap"
			UTF::Message INFO "" "sta_graph_assoc_val_apsta=$sta_graph_assoc_val_apsta"
			UTF::Message INFO "" "sta_graph_assoc_val_sts=$sta_graph_assoc_val_sts"

			set active_sta_apsta_flag 0
			set active_sta_sts_flag 0
			UTF::Message INFO "" "::array_sta_apsta_active_flag(${sta_name})=$::array_sta_apsta_active_flag(${sta_name}) ::array_sta_apsta_disassociated_flag(${sta_name})=$::array_sta_apsta_disassociated_flag(${sta_name})"
			UTF::Message INFO "" "::array_sta_sts_active_flag(${sta_name})=$::array_sta_sts_active_flag(${sta_name}) ::array_sta_sts_disassociated_flag(${sta_name})=$::array_sta_sts_disassociated_flag(${sta_name})"

			if {$::array_sta_apsta_active_flag(${sta_name}) == 0 && $::array_sta_sts_active_flag(${sta_name}) == 0} {
				UTF::Message INFO "" "STA $sta_name is not active. Skip."
				continue
			}
			
			UTF::Message INFO "" "sta=$sta_name"
			UTF::Message INFO "" "::array_sta_sts(${sta_name})=$::array_sta_sts(${sta_name})"
			UTF::Message INFO "" "::array_sta_label(${sta_name})=$::array_sta_label(${sta_name})"
			UTF::Message INFO "" "::array_sta_plus_master_flag(${sta_name})=$::array_sta_plus_master_flag(${sta_name})"
			UTF::Message INFO "" "::array_sta_plus_slave_flag(${sta_name})=$::array_sta_plus_slave_flag(${sta_name})"

			# skip the STA that is GO/Master and it is connected to AP
			if {$::array_sta_apsta_active_flag(${sta_name}) == 1 && $::array_sta_sts_active_flag(${sta_name}) == 1} {

				if {$::array_sta_plus_master_flag(${sta_name}) == 1} {
					# skip since it is not connected to AP
					UTF::Message INFO "" "Skipping STA '$sta_name' since it is GO/Master and it is connected to AP"
					continue
				}
			}

			if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
				set active_sta_apsta_flag 1
				set csv_index_StaState_apsta [find_csv_column_index "StaState($sta_name)" $::csv_columns_data_list]

				set filename "$testnum\.${graph_file_name}APSTAState(${sta_name})"
				set gnu_data_filename_sta_state_apsta(${sta_name}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_apsta_fd(${sta_name}) [open "$gnu_data_filename_sta_state_apsta(${sta_name})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_apsta(${sta_name})=$gnu_data_filename_sta_state_apsta(${sta_name})==========================="
			}

			if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
				set active_sta_sts_flag 1
				set csv_index_StaState_sts [find_csv_column_index "StaState($::array_sta_sts(${sta_name}))" $::csv_columns_data_list]

				set filename "$testnum\.${graph_file_name}StSState(${sta_name})"
				set gnu_data_filename_sta_state_sts(${sta_name}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_sts_fd(${sta_name}) [open "$gnu_data_filename_sta_state_sts(${sta_name})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_sts(${sta_name})=$gnu_data_filename_sta_state_sts(${sta_name})==========================="
			}

			if {$(ap) != "" && $active_sta_apsta_flag == 1} {
				set csv_index_StaState_ap [find_csv_column_index "StaApState(${sta_name})" $::csv_columns_data_list]

				set filename "$testnum\.${graph_file_name}APState(${sta_name})"
				set gnu_data_filename_sta_state_ap(${sta_name}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_ap_fd(${sta_name}) [open "$gnu_data_filename_sta_state_ap(${sta_name})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_ap(${sta_name})=$gnu_data_filename_sta_state_ap(${sta_name})==========================="
			}

			set csv_fd [open "$::curr_csv_data_fullname" r]

			set csv_curr_line_no 0

			while {[gets $csv_fd line]>=0} { 
				incr csv_curr_line_no

				# skip csv header
				if {$csv_curr_line_no <= $csv_header_line_cnt} {
					continue
				}

				set columns_data [split $line ","]

				if {$::rvr_test_flag == 0} {
					set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
				} else {
					set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
				}

				if {$active_sta_apsta_flag == 1} {
					set data_StaState_apsta "[lindex $columns_data $csv_index_StaState_apsta]"
					set data_StaState_apsta [string trim $data_StaState_apsta]
					switch $data_StaState_apsta {
						ROAMING {
							set StaAssocBeacon_apsta 0
						}

						ASSOCIATED {
							set StaAssocBeacon_apsta [expr {$sta_graph_assoc_val_apsta / 2.0}]
						}

						"ASSOCIATED BEACONS" {
							set StaAssocBeacon_apsta $sta_graph_assoc_val_apsta
						}

						default {
							set StaAssocBeacon_apsta ""
						}
					}

					UTF::Message INFO "" "StaState_apsta='$data_StaState_apsta' -> StaAssocBeacon_apsta=$StaAssocBeacon_apsta"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_apsta_fd(${sta_name}) "$tmp $StaAssocBeacon_apsta"
				}

				if {$active_sta_sts_flag == 1} {
					set data_StaState_sts "[lindex $columns_data $csv_index_StaState_sts]"
					set data_StaState_sts [string trim $data_StaState_sts]
					switch $data_StaState_sts {
						ROAMING {
							set StaAssocBeacon_sts 0
						}

						ASSOCIATED {
							set StaAssocBeacon_sts [expr {$sta_graph_assoc_val_sts / 2.0}]
						}

						"ASSOCIATED BEACONS" {
							set StaAssocBeacon_sts $sta_graph_assoc_val_sts
						}

						default {
							set StaAssocBeacon_sts ""
						}
					}

					UTF::Message INFO "" "StaState_sts='$data_StaState_sts' -> StaAssocBeacon_sts=$StaAssocBeacon_sts"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_sts_fd(${sta_name}) "$tmp $StaAssocBeacon_sts"
				}

				if {$(ap) != "" && $active_sta_apsta_flag == 1} {
					set data_StaState_ap "[lindex $columns_data $csv_index_StaState_ap]"
					set data_StaState_ap [string trim $data_StaState_ap]

					# figure out the StaAssocAuthen_ap
					if {[regexp -nocase {ASSOCIATED} $data_StaState_ap] && [regexp {AUTHENTICATED} $data_StaState_ap]} {
						set StaAssocAuthen_ap $sta_graph_assoc_val_ap
					} elseif {$data_StaState_ap != ""} {
						set StaAssocAuthen_ap [expr {$sta_graph_assoc_val_ap / 2.0}]
					} else {
						set StaAssocAuthen_ap 0
					}

					UTF::Message INFO "" "StaState_ap='$data_StaState_ap' -> StaAssocAuthen_ap=$StaAssocAuthen_ap"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_ap_fd(${sta_name}) "$tmp $StaAssocAuthen_ap"
				}
			}

			if {$active_sta_apsta_flag == 1} {
				close $gnu_data_sta_state_apsta_fd(${sta_name})
			}

			if {$active_sta_sts_flag == 1} {
				close $gnu_data_sta_state_sts_fd(${sta_name})
			}

			if {$(ap) != "" && $active_sta_apsta_flag == 1} {
				close $gnu_data_sta_state_ap_fd(${sta_name})
			}

			close $csv_fd
		}
	}
	
	###################################################################
	# genrate the gnu_data files for throughput and others
	###################################################################

	if {$graph_special_flag == 1} {
		set csv_fd [open "$::curr_csv_throughput_data_fullname" r]
	} else {
		set csv_fd [open "$::curr_csv_data_fullname" r]
	}
	
	set max_val 0
	set min_val 99999
	set csv_curr_line_no 0
	set bigest_nrate_data 0
	set found_data_flag 0

	while {[gets $csv_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns_data [split $line ","]

		if {$::rvr_test_flag == 0} {
			set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
		} else {
			set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
		}

		if {$graph_special_flag == 1} {

			set found_data_flag 1
		
			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

				set data(${::curr_test_no},${stream_no}) ""
				if {$::graphs_with_min_max} {
					set data_min(${::curr_test_no},${stream_no}) ""
					set data_max(${::curr_test_no},${stream_no}) ""
				}
				
				set data(${::curr_test_no},${stream_no}) "[lindex $columns_data $array_csv_index(${::curr_test_no},${stream_no})]"
				set data(${::curr_test_no},${stream_no}) [string trim $data(${::curr_test_no},${stream_no})]
				if {$data(${::curr_test_no},${stream_no}) == ""} {
					continue
				}
				if {$data(${::curr_test_no},${stream_no}) == 0} {
					if {[regexp {StaTCPWrites} $graph_name] || [regexp {StaTCPErrors} $graph_name] || [regexp {StaTCPRetries} $graph_name] || [regexp {StaTCPUsedMemory} $graph_name] || [regexp {StaTCPRTT} $graph_name] || [regexp {StaUDPLatency} $graph_name] || [regexp {StaUDPJitter} $graph_name] || [regexp {StaUDPLostPackets} $graph_name] || [regexp {StaUDPOutofOrderPackets} $graph_name] || [regexp {StaUDPPPS} $graph_name]} {
						set data(${::curr_test_no},${stream_no}) [format "%.2f" [expr {double(0.01)}]]
						UTF::Message INFO "" "Log graph - modified data=0 to $data(${::curr_test_no},${stream_no})"
					}
				}
				if {$::graphs_with_min_max} {
					set data_min(${::curr_test_no},${stream_no}) "[lindex $columns_data $array_csv_index_min(${::curr_test_no},${stream_no})]"
					set data_min(${::curr_test_no},${stream_no}) [string trim $data_min(${::curr_test_no},${stream_no})]
					set data_max(${::curr_test_no},${stream_no}) "[lindex $columns_data $array_csv_index_max(${::curr_test_no},${stream_no})]"
					set data_max(${::curr_test_no},${stream_no}) [string trim $data_max(${::curr_test_no},${stream_no})]

					if {$data_max(${::curr_test_no},${stream_no}) > $max_val} {
						set max_val $data_max(${::curr_test_no},${stream_no})
					}
					if {$data_min(${::curr_test_no},${stream_no}) < $min_val} {
						set min_val $data_min(${::curr_test_no},${stream_no})
					}
				} else {
					if {$data(${::curr_test_no},${stream_no}) > $max_val} {
						set max_val $data(${::curr_test_no},${stream_no})
					}
					if {$data(${::curr_test_no},${stream_no}) < $min_val} {
						set min_val $data(${::curr_test_no},${stream_no})
					}
				}
			}

			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

				set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

				# For RvR, to fix the graphs when there is no throughput (or jitter, lost packet, or ooo) value and pushing the graph to 0 x axis:
				# 	orginal data:   data   data   blank   blank   blank   blank   data   data
				# 	new data:       data   data     0     blank   blank     0     data   data
				
				set idx $::array_streams_file_name(${::curr_test_no},${stream_no})

				if {$::rvr_test_flag == 1 && [info exists gnu_no_data_spc_flag(${idx})]} {
					if {$gnu_no_data_spc_flag(${idx}) == 1 && $data(${::curr_test_no},${stream_no}) != ""} {
						# no throughput to throughput (RvR going back up) - force a zero data
						set zero_line_no [expr {$gnuplot_line_no - 1}]
						set tmp $zero_line_no
						puts $gnu_data_fd(${idx}) "$tmp 0"
					} elseif {$gnu_no_data_spc_flag(${idx}) == 0 && $data(${::curr_test_no},${stream_no}) == ""} {
						# throughput to no throughput (RvR going down) - force a zero data
						puts $gnu_data_fd(${idx}) "$gnuplot_line_no 0"
					}
				}
				
				if {$data(${::curr_test_no},${stream_no}) == ""} {
					set gnu_no_data_spc_flag(${idx}) 1
					continue
				}

				set gnu_no_data_spc_flag(${idx}) 0

				if {$::rvr_test_flag == 0} {
					set tmp $BaseTime
				} else {
					set tmp $gnuplot_line_no
				}
				
				# write the throughput data to gnu file
				puts $gnu_data_fd(${idx}) "$tmp $data(${::curr_test_no},${stream_no})"
				if {$::graphs_with_min_max} {
					puts $gnu_data_min_fd(${idx}) "$tmp $data_min(${::curr_test_no},${stream_no})"
					puts $gnu_data_max_fd(${idx}) "$tmp $data_max(${::curr_test_no},${stream_no})"
				}
			}
		} else {
			set data "[lindex $columns_data $csv_index]"
			set data [string trim $data]

			if {$data == ""} {
				if {[regexp {ApConnectTime} $graph_name] || $rate_flag == 1 || $nrate_flag == 1} {
					set data 0
				}
			}

			if {$nrate_flag == 1} {
				set data [sts::graph_map_nrate $data]

				if {$data > $bigest_nrate_data} {
					set bigest_nrate_data $data
				}
			}

			if {$data != "" && $data != "0.00"} {
				set found_data_flag 1
			}

			if {$::rvr_test_flag == 0} {
				set tmp $BaseTime
			} else {
				set tmp $gnuplot_line_no
			}

			if {$rssi_flag == 1} {
				# RSSI of 0 or blank are invalid
				if {$data != "" && $data != 0} {
					puts $gnu_data_fd "$tmp $data"			
				}
			} else {
				if {$data != ""} {
					puts $gnu_data_fd "$tmp $data"			
				}
			}

			if {$data != ""} {
				if {$data > $max_val} {
					set max_val $data
				}
				if {$data < $min_val} {
					set min_val $data
				}
			}
		}
	}

	close $csv_fd

	if {$graph_special_flag == 1} {
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set idx $::array_streams_file_name(${::curr_test_no},${stream_no})
			close $gnu_data_fd(${idx})
			if {$::graphs_with_min_max} {
				close $gnu_data_min_fd(${idx})
				close $gnu_data_max_fd(${idx})
			}
		}
	} else {
		close $gnu_data_fd
	}
	UTF::Message INFO "" "end closed gnu_data"
	UTF::Message INFO "" "end closed csv"

	if {$found_data_flag == 0} {
		UTF::Message INFO "" "No data was found for column title $graph_name. Skip this graph"
		return
	}	

	if {$::graph_max_width == 0} {
		
		if {$::rvr_test_flag == 0} {
			# use 1280 for every minute of throughput

			set max_x_time $BaseTime
			# covert x axis time to secs
			# add the hour before converting
			set new_base_timestamp "00:$max_x_time"
			set new_base_timestamp_tick [clock scan $new_base_timestamp]
			set max_x_time_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
			UTF::Message INFO "" "max_x_time = $BaseTime = $max_x_time_tick"

			set ::graph_max_width [expr {round([expr {double([expr {$max_x_time_tick * 1280.0}]) / 60.0}])}]
			if {$::graph_max_width < 1280} {
				set ::graph_max_width 1280
			}
			set ::graph_max_height 720
		} else {
			set ::graph_max_width 900
			set ::graph_max_height 600
		}
	
		UTF::Message INFO "" "::graph_max_width=$::graph_max_width ::graph_max_height=$::graph_max_height"
	}

	UTF::Message INFO "" "max_val=$max_val min_val=$min_val"

	if {$max_val < 10} {
		set max_val 10
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,$max_val)"
		set ytics 1.0
	} elseif {$max_val < 20} {
		set max_val 20
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,$max_val)"
		set ytics 2.0
	} elseif {$max_val < 50} {
		set max_val 50
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,$max_val)"
		set ytics 5.0
	} elseif {$max_val < 100} {
		set max_val 100
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,$max_val)"
		set ytics 10.0
	} elseif {$max_val < 200} {
		set max_val 200
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,100,$max_val)"
		set ytics 20.0
	} elseif {$max_val < 500} {
		set max_val 500
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,100,200,$max_val)"
		set ytics 50.0
	} elseif {$max_val < 1000} {
		set max_val 1000
		set max_val_log_ytics "set ytics ('0' 0.01,20,60,100,200,500,$max_val)"
		set ytics 100.0
	} elseif {$max_val < 2000} {
		set max_val 2000
		set max_val_log_ytics "set ytics ('0' 0.01,60,100,200,500,1000,$max_val)"
		set ytics 200.0
	} elseif {$max_val < 5000} {
		set max_val 5000
		set max_val_log_ytics "set ytics ('0' 0.01,100,200,500,1000,2000,$max_val)"
		set ytics 500.0
	} elseif {$max_val < 10000} {
		set max_val 10000
		set max_val_log_ytics "set ytics ('0' 0.01,100,200,500,1000,2000,$max_val)"
		set ytics 1000.0
	} elseif {$max_val < 20000} {
		set max_val 20000
		set max_val_log_ytics "set ytics ('0' 0.01,1000,2000,10000,$max_val)"
		set ytics 2000.0
	} elseif {$max_val < 50000} {
		set max_val 50000
		set max_val_log_ytics "set ytics ('0' 0.01,1000,2000,10000,20000,$max_val)"
		set ytics 5000.0
	} elseif {$max_val < 100000} {
		set max_val 100000
		set max_val_log_ytics "set ytics ('0' 0.01,10000,20000,50000,$max_val)"
		set ytics 10000.0
	} else {
		set max_val_log_ytics "set ytics ('0' 0.01,10000,20000,50000,100000,$max_val)"
		set ytics 10000.0
	}

	if {$min_val >= 0} {
		set min_val 0
	} elseif {$min_val < 10} {
		set min_val [expr {$min_val - 10}]
	} elseif {$min_val < 0} {
		set min_val -10
	}

	UTF::Message INFO "" "ytics=$ytics"

	set max_val_log_yrange "set yrange \[0.01:$max_val\]"

	regsub {ytics} $max_val_log_ytics {y2tics} max_val_log_y2tics
	regsub {yrange} $max_val_log_yrange {y2range} max_val_log_y2range

	UTF::Message INFO "" "new max_val=$max_val min_val=$min_val"

	###################################################################
	# genrate the gnu_plot file
	###################################################################
	set filename "$testnum\.${graph_file_name}"
	set gnu_plot_filename "$::logdir/GraphsData/${filename}.gnu_plot"
	set gnu_plot_fd [open "$gnu_plot_filename" w 0644]

	UTF::Message INFO "" "========================2D gnu_plot_filename=$gnu_plot_filename==========================="

	puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}.png\""
	set terminal_size "$::graph_max_width,$::graph_max_height"
	puts $gnu_plot_fd "set terminal png size $terminal_size notransparent font \"$::gnuplot_font\,$::gnuplot_font_size\""
	puts $gnu_plot_fd "set tmargin -1; set bmargin -1"
	puts $gnu_plot_fd "set lmargin -1; set rmargin -1"
	puts $gnu_plot_fd "set key outside spacing .9"
	
    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    puts $gnu_plot_fd "set title \"$::graph_label_test$::array_streams_total_streams_label(${::curr_test_no})\\n$graph_name\\n($timestamp)\""

	puts $gnu_plot_fd "set ylabel '$graph_ylabel'"
	
	if {$graph_special_flag == 1 && $::rvr_test_flag == 0} {
		puts $gnu_plot_fd "set border"
		puts $gnu_plot_fd "set grid ytic"
		puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
		puts $gnu_plot_fd "set xdata time"
		puts $gnu_plot_fd "set timefmt '%M:%S'"
		# rotate 0 and 90 works. "-45" does not work
		puts $gnu_plot_fd "#set xtics rotate by 90"
		puts $gnu_plot_fd "set ytics  0,$ytics"
		puts $gnu_plot_fd "set yrange \[$min_val:$max_val\]"
		puts $gnu_plot_fd "set xrange \[0:\"$::gnuplot_x_max_time_val\"\]"

		if {$stream_time > 60} {
			#puts $gnu_plot_fd "set y2label ''"
			puts $gnu_plot_fd "set y2tics 0,$ytics"
			puts $gnu_plot_fd "set y2range \[$min_val:$max_val\]"
		}
	} else {
		puts $gnu_plot_fd "set grid"
		
		if {$::rvr_test_flag == 1} {
			puts $gnu_plot_fd "set xlabel 'Relative Path Loss (dB)'"
			puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
			puts $gnu_plot_fd "set xrange \[0:$::gnuplot_x_max_rvr_val\]"
		} else {
			puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
			puts $gnu_plot_fd "set xdata time"
			puts $gnu_plot_fd "set timefmt '%M:%S'"
			puts $gnu_plot_fd "set xrange \[0:\"$::gnuplot_x_max_time_val\"\]"
		}
	}

	if {$nrate_flag == 1} {
		if {$bigest_nrate_data > 23} {
            puts $gnu_plot_fd "set ytics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'0x1' 24,'1x1' 25,'2x1' 26,'3x1' 27,'4x1' 28,'5x1' 29,'6x1' 30,'7x1' 31,'8x1' 32,'9x1' 33,'2x0' 34,'1x2' 35,'2x2' 36,'3x2' 37,'4x2' 38,'5x2' 39,'6x2' 40,'7x2' 41,'8x2' 42,'9x2' 43,'0x3' 44,'1x3' 45,'2x3' 46,'3x3' 47,'4x3' 48,'5x3' 49,'6x3' 50,'7x3' 51,'8x3' 52,'9x3' 53,'auto' 54)"
			puts $gnu_plot_fd "set yrange \[-12:54\]"
			if {$stream_time > 60} {
            	puts $gnu_plot_fd "set y2tics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'0x1' 24,'1x1' 25,'2x1' 26,'3x1' 27,'4x1' 28,'5x1' 29,'6x1' 30,'7x1' 31,'8x1' 32,'9x1' 33,'2x0' 34,'1x2' 35,'2x2' 36,'3x2' 37,'4x2' 38,'5x2' 39,'6x2' 40,'7x2' 41,'8x2' 42,'9x2' 43,'0x3' 44,'1x3' 45,'2x3' 46,'3x3' 47,'4x3' 48,'5x3' 49,'6x3' 50,'7x3' 51,'8x3' 52,'9x3' 53,'auto' 54)"
				puts $gnu_plot_fd "set y2range \[-12:54\]"
			}
			UTF::Message LOG "" "bigest_nrate_data=$bigest_nrate_data graph_highest_val=54"
		} else {
			puts $gnu_plot_fd "set ytics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'auto' 24)"
			puts $gnu_plot_fd "set yrange \[-12:24\]"
			if {$stream_time > 60} {
				puts $gnu_plot_fd "set y2tics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'auto' 24)"
				puts $gnu_plot_fd "set y2range \[-12:24\]"
			}
			UTF::Message LOG "" "bigest_nrate_data=$bigest_nrate_data graph_highest_val=23"
		}
	} elseif {$graph_ylabel == "UDP Jitter (ms)" || $graph_ylabel == "UDP Latency (ms)" || $graph_ylabel == "TCP RTT (ms)"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "UDP Lost Packets"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "UDP OOO Packets"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "Connect Time (Seconds)"} {
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set y2tics"
		}
	} elseif {$graph_ylabel == "Rate (Mbps)"} {
		puts $gnu_plot_fd "set yrange \[0:1600\]"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set y2tics"
			puts $gnu_plot_fd "set y2range \[0:1600\]"
		}
	} elseif {$graph_ylabel == "RSSI (dB)"} {
		puts $gnu_plot_fd "set ytics('-100' -100,'-90' -90,'-80' -80,'-70' -70,'-60' -60,'-50' -50,'-40' -40,'-30' -30,'-20' -20,'-10' -10,'0' 0)"
		puts $gnu_plot_fd "set yrange \[-100:0\]"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set y2tics('-100' -100,'-90' -90,'-80' -80,'-70' -70,'-60' -60,'-50' -50,'-40' -40,'-30' -30,'-20' -20,'-10' -10,'0' 0)"
			puts $gnu_plot_fd "set y2range \[-100:0\]"
		}
	} elseif {$graph_ylabel == "Beacons/Sec"} {
		puts $gnu_plot_fd "set ytics('0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15)"
		puts $gnu_plot_fd "set yrange \[0:15\]"
		if {$stream_time > 60} {
			puts $gnu_plot_fd "set y2tics('0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15)"
			puts $gnu_plot_fd "set y2range \[0:15\]"
		}
	}

	set object_name ""
	regexp {\s*\((.*)\)} $graph_name - object_name
	UTF::Message INFO "" "graph_name=$graph_name object_name=$object_name"

	if {$graph_special_flag == 1} {

		if {$graph_throughput_flag == 1} {
			set ::throughput_png_file "$::logdir/GraphsData/${filename}.png"
		}

		set out ""
		set out_sm ""
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set stream_plot_minmax_name_lt $::array_streams_plot_minmax_name_lt(${::curr_test_no},${stream_no})
			set stream_plot_name_lt $::array_streams_plot_name_lt(${::curr_test_no},${stream_no})
			set stream_plot_name_pt $::array_streams_plot_name_pt(${::curr_test_no},${stream_no})

			if {$stream_no > 1} {
				append out ", "
				append out_sm ", "
			}
			set idx $::array_streams_file_name(${::curr_test_no},${stream_no})
			set stream_title $::array_streams_stream_label(${::curr_test_no},${stream_no})
			append out "\"$gnu_data_filename(${idx})\" using 1:2 title \"$stream_title\" with linespoints lt $stream_plot_name_lt lw 3 pt $stream_plot_name_pt ps 1"
			append out_sm "\"$gnu_data_filename(${idx})\" using 1:2 axes x1y1 with lines"
			if {$::graphs_with_min_max} {
				append out ", \"$gnu_data_filename_min(${idx})\" using 1:2 title \"Min $stream_title\" with linespoints lt $stream_plot_minmax_name_lt lw 1 pt 0 ps 0, "
				append out "\"$gnu_data_filename_max(${idx})\" using 1:2 title \"Max $stream_title\" with linespoints lt $stream_plot_minmax_name_lt lw 1 pt 0 ps 0"
			}
		}

		if {$graph_throughput_flag == 1} {
			set gc_tot [llength $::array_streams_sts_slave_sta_list(${::curr_test_no})]
			set lt_cnt 0
			
			set gc_cnt 0
			foreach sta_name $(sta) {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 1
				}
				
				if {$::array_sta_apsta_active_flag(${sta_name}) == 1} {
					append out ", \"$gnu_data_filename_sta_state_apsta(${sta_name})\" using 1:2 title \"$tmp\APSTA Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
				}
			}
			
			set gc_cnt 0
			foreach sta_name $(sta) {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 13
				}
				
				if {$::array_sta_sts_active_flag(${sta_name}) == 1} {
					for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {
						if {$sta_name == $::array_streams_dst_sta(${::curr_test_no},${stream_no}) && [lsearch -exact $::sts_link_types $::array_streams_link_type(${::curr_test_no},${stream_no})] != -1} {
							# StS link
							append out ", \"$gnu_data_filename_sta_state_sts(${sta_name})\" using 1:2 title \"$tmp$::array_streams_link_type(${::curr_test_no},${stream_no}) Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
							break
						}
					}
				}
			}
			
			set gc_cnt 0
			foreach sta_name $(sta) {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 8
				}
				
				if {$(ap) != "" && $::array_sta_apsta_active_flag(${sta_name}) == 1} {
					append out ", \"$gnu_data_filename_sta_state_ap(${sta_name})\" using 1:2 title \"$tmp\AP Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
				}
			}
		}
		
		puts $gnu_plot_fd "plot $out"
	} else {
		puts $gnu_plot_fd "set style line 1 lt 1 lw 3 pt 7 ps 1"
		if {$::rvr_test_flag == 0} {
			puts $gnu_plot_fd "plot \"$::logdir/GraphsData/${filename}.gnu_data\" using 1:2 title \"$object_name\" with linespoints ls 1"
		} else {
			puts $gnu_plot_fd "plot \"$::logdir/GraphsData/${filename}.gnu_data\" title \"$object_name\" with linespoints ls 1"
		}
	}
	
	# for non-rvr throughput, create small graph also
	if {$graph_throughput_flag == 1 && $::rvr_test_flag == 0} {
		puts $gnu_plot_fd ""
		puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}_sm.png\""
		puts $gnu_plot_fd "set terminal png transparent size 62,13"
		puts $gnu_plot_fd "set tmargin 0; set bmargin 0"
		puts $gnu_plot_fd "set lmargin 0; set rmargin 0.15"
		puts $gnu_plot_fd "unset border"
		puts $gnu_plot_fd "unset key"
		puts $gnu_plot_fd "unset title"
		puts $gnu_plot_fd "unset xlabel"
		puts $gnu_plot_fd "unset ylabel"
		puts $gnu_plot_fd "unset y2label"
		puts $gnu_plot_fd "set xdata time"
		puts $gnu_plot_fd "set timefmt '%M:%S'"
		puts $gnu_plot_fd "unset xtics"
		puts $gnu_plot_fd "unset ytics"
		puts $gnu_plot_fd "unset y2tics"
		puts $gnu_plot_fd "set yrange \[$min_val:\]"
		puts $gnu_plot_fd "set y2range \[$min_val:\]"
		puts $gnu_plot_fd "unset grid"
		puts $gnu_plot_fd "plot $out_sm"
	}	
	
	close $gnu_plot_fd

	if {$graph_special_flag == 1} {
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

			set stream_name $::array_streams_stream_label(${::curr_test_no},${stream_no})

			set idx $::array_streams_file_name(${::curr_test_no},${stream_no})
			unset array_csv_index_max(${::curr_test_no},${stream_no})
			unset array_data_max(${::curr_test_no},${stream_no})
			unset gnu_data_filename(${idx})
			unset gnu_data_fd(${idx})
			if {$::graphs_with_min_max} {
				unset array_csv_index_min(${::curr_test_no},${stream_no})
				unset gnu_data_filename_min(${idx})
				unset gnu_data_min_fd(${idx})
				unset gnu_data_filename_max(${idx})
				unset gnu_data_max_fd(${idx})
				unset data_min(${::curr_test_no},${stream_no})
				unset data_max(${::curr_test_no},${stream_no})
			}
			unset data(${::curr_test_no},${stream_no})
		}
	}
	
	set catch_resp [catch "exec $::UTF::Gnuplot $::logdir/GraphsData/${filename}.gnu_plot" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::create_3d_summary_graphs {graph_name graph_ylabel} {

	UTF::Message INFO "" "************************Func:create_3d_summary_graphs $graph_name***************************"

	if {$graph_ylabel == "PER"} {
		set graph_per_flag 1
	} else {
		set graph_per_flag 0
	}

	# graph_name = graph_name(AP/STA Object_name)
	regexp {\s*\((.*)\)} $graph_name - object_name

	if {[string first "Sta" $graph_name] == 0} {
		# graph_name starts with "Sta"
		set object_type "Sta"
	} elseif {[string first "Ap" $graph_name] == 0} {
		# graph_name starts with "Ap"
		set object_type "Ap"
	} else {
		UTF::Message ERROR "" "***Failed. graph_name $graph_name does not start with 'Ap' or 'Sta'."
		error "Bad graph_name $graph_name"
	}

	if {$graph_per_flag} {
		if {[string first "VhtPer" $graph_name] > 0} {
			set csv_index_tx [find_csv_column_index ${object_type}TxVht($object_name) $::csv_columns_data_list]
		} else {
			set csv_index_tx [find_csv_column_index ${object_type}TxMcs($object_name) $::csv_columns_data_list]
		}
	}

	set csv_header_line_cnt 2

	if {$::rvr_test_flag == 0} {
		set csv_index_BaseTime [find_csv_column_index "BaseTime" $::csv_columns_data_list]
	} else {
		set csv_index_GnuplotCnt [find_csv_column_index "GnuplotCnt" $::csv_columns_data_list]
	}

	set csv_index [find_csv_column_index $graph_name $::csv_columns_data_list]

	if {$csv_index == -1} {
		UTF::Message INFO "" "CSV column title $graph_name is not found. Skip this column"
		return
	}

	UTF::Message INFO "" "========================3D graph_name=$graph_name==========================="

	set csv_data_fd [open "$::curr_csv_data_fullname" r]

	# read the csv data to figure out gnuplot yrange->max_y

	set y_max 0
	set len_max 0
	set csv_curr_line_no 0

	while {[gets $csv_data_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns [split $line ","]
		set data "[lindex $columns $csv_index]"
		set data [string trim $data]
		set len [llength $data]

		if {[expr {$len - 1}] > $len_max} {
			set len_max $len
		}
	}

	set y_max [expr {$len_max - 0.5}]

	UTF::Message INFO "" "gnuplot yrange->y_max=$y_max"

	###################################################################
	# genrate the gnu_data file
	###################################################################

	set testnum [sts::get_testnum]
	regsub -all {.} $testnum "_" $testnum
	set filename "$testnum\.${graph_name}"
	set gnu_data_filename "$::logdir/GraphsData/${filename}.gnu_data"
	set gnu_data_fd [open "$gnu_data_filename" w 0644]

	UTF::Message INFO "" "========================3D gnu_data_filename=$gnu_data_filename==========================="

	# do not init the ::gnuplot_xtic_label here since it is set in 2D graphs
	set gnuplot_xtic_max_range ""
	seek $csv_data_fd 0
	set csv_curr_line_no 0
	set z_min 99999
	set z_max 0
	set found_data_flag 0

	while {[gets $csv_data_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns_data [split $line ","]

		if {$::rvr_test_flag == 0} {
			set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
			set BaseTime [string trim $BaseTime]
			# covert to secs and build xtics
			# add the hour before converting
			set new_base_timestamp "00:$BaseTime"
			set new_base_timestamp_tick [clock scan $new_base_timestamp]
			set BaseTime_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
				
			if {$::gnuplot_xtic_label != ""} {
				set ::gnuplot_xtic_label "$::gnuplot_xtic_label,"
			}

			set ::gnuplot_xtic_label "$::gnuplot_xtic_label\'$BaseTime\' $BaseTime_tick"
			set gnuplot_xtic_max_range $BaseTime_tick
		} else {
			set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
		}

		set data "[lindex $columns_data $csv_index]"
		set data [string trim $data]
		if {$data != "" && $data != "0.00"} {
			set found_data_flag 1
		}
		set len [llength $data]
		# length of Y data must be max
		set diff_len [expr {$len_max - $len}]
		if {$diff_len != 0} {
			for {set cnt 0} {$cnt < $diff_len} {incr cnt} {
				if {$graph_per_flag} {
					lappend data "-1"
				} else {
					lappend data "0"
				}
			}
		}
		set data [string trim $data]
		set len [llength $data]

		if {$graph_per_flag} {
			# if AP/STA "TX MCS" and "MCS PER" are zero, then set the AP/STA "MCS PER" to "-1"
			# if AP/STA "TX VHT" and "VHT PER" are zero, then set the AP/STA "VHT PER" to "-1"
			
			set data_tx "[lindex $columns_data $csv_index_tx]"
			set data_tx [string trim $data_tx]
			UTF::Message INFO "" "==============================PER $csv_curr_line_no================================="

			UTF::Message INFO "" "PER: data_tx='$data_tx'"
			UTF::Message INFO "" "PER:    data='$data'"
			
			set new_per_list ""
			for {set cnt 0} {$cnt < $len} {incr cnt} {
				set tx_val [lindex $data_tx $cnt]
				set per_val [lindex $data $cnt]
				
				if {($tx_val == 0 || $tx_val == "") && ($per_val == 0 || $per_val == "" || $per_val == "-1")} {
					append new_per_list "-1 "
				} else {
					append new_per_list "$per_val "
				}
			}
			
			set data $new_per_list
			set data [string trim $data]
			
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "BaseTime=$BaseTime value='$data' len=$len"
			} else {
				UTF::Message LOG "" "gnuplot_line_no=$gnuplot_line_no value='$data' len=$len"
			}
		} else {
			set total_value 0
			foreach item "$data" {
				# leading zero mean 'octal' (or base 8), with only digits 0-7. 
				# use scan to covert it to decimal without the leading zero, otherwise you
				# could get error 'can't use invalid octal number as operand of "+" when using 'expr' command with invalid octal'
				scan $item %d item

				set total_value [expr {$total_value + $item}]
			}
			
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "BaseTime=$BaseTime value='$data' len=$len total_value=$total_value"
			} else {
				UTF::Message LOG "" "gnuplot_line_no=$gnuplot_line_no value='$data' len=$len total_value=$total_value"
			}
		}
		
		set y 0
		foreach item "$data" {
			# leading zero mean 'octal' (or base 8), with only digits 0-7. 
			# use scan to covert it to decimal without the leading zero, otherwise you
			# could get error 'can't use invalid octal number as operand of "+" when using 'expr' command with invalid octal'
			scan $item %d item

			if {$graph_per_flag} {
				set z $item
			} else {
				if {$total_value == 0} {
					set z 0
				} else {
					set z [expr {double([expr {$item * 100.0}]) / $total_value}]
					set z [format "%.2f" $z]
				}
			}
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "x=$BaseTime_tick y=$y z=$z"
				puts $gnu_data_fd "$BaseTime_tick $y $z"
			} else {
				UTF::Message LOG "" "x=$gnuplot_line_no y=$y z=$z"
				puts $gnu_data_fd "$gnuplot_line_no $y $z"
			}
			incr y

			if {$z > $z_max } {
				set z_max $z
			}
			if {$z < $z_min } {
				set z_min $z
			}
		}

		puts $gnu_data_fd ""
	}

	close $csv_data_fd
	close $gnu_data_fd
	UTF::Message INFO "" "end closed gnu_data"
	UTF::Message INFO "" "end closed csv"

	if {$found_data_flag == 0} {
		UTF::Message INFO "" "No data was found for column title $graph_name. Skip this graph"
		return
	}	

	if {$z_max < 0.001} {
		UTF::Message LOG "" "z_max=$z_max is forced to 0.001"
		set z_min 0.001
	}

	if {$z_max < 5} {
		UTF::Message LOG "" "z_max=$z_max is less than 5. z_min is forced to 0"
		set z_min 0
	} else {
		UTF::Message LOG "" "z_max=$z_max is forced to normal 100"
		set z_max 100
	}

	UTF::Message LOG "" "z_min=$z_min z_max=$z_max"

	###################################################################
	# genrate the gnu_plot file
	###################################################################
	set gnu_plot_filename "$::logdir/GraphsData/${filename}.gnu_plot"
	set gnu_plot_fd [open "$gnu_plot_filename" w 0644]

	UTF::Message INFO "" "========================3D gnu_plot_filename=$gnu_plot_filename==========================="

	puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}.png\""
	set terminal_size "$::graph_max_width,$::graph_max_height"
	puts $gnu_plot_fd "set terminal png size $terminal_size notransparent font \"$::gnuplot_font\,$::gnuplot_font_size\""
	puts $gnu_plot_fd "set tmargin -1; set bmargin -1"
	puts $gnu_plot_fd "set lmargin -1; set rmargin -1"
	puts $gnu_plot_fd "set grid"
	puts $gnu_plot_fd "unset key"

    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	# 3 line of title does not work with this type of graph and only the first two lines gets displayed
    puts $gnu_plot_fd "set title \"$::graph_label_test$::array_streams_total_streams_label(${::curr_test_no})\\n$graph_name ($timestamp)\""
	
	puts $gnu_plot_fd "set ylabel '$graph_ylabel'"

	if {$::rvr_test_flag == 1} {
		puts $gnu_plot_fd "set xlabel 'Relative Path Loss (dB)'"
		puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
		puts $gnu_plot_fd "set xrange \[0:$::gnuplot_x_max_rvr_val\]"
	} else {
		puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
		#puts $gnu_plot_fd "set xdata time"
		#puts $gnu_plot_fd "set timefmt '%M:%S'"
		puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
		# no xrange since we have xtics
	}

	if {[regexp -nocase {Vht} $graph_name]} {
		puts $gnu_plot_fd "set ytics('1x0' 0, '1x5' 5, '1x9' 9, '2x0' 10, '2x5' 15, '2x9' 19, '3x0' 20, '3x5' 25, '3x9' 29)"
	}
	puts $gnu_plot_fd "set style line 1 lt 1 lw 1 pt 0 ps 0"
	puts $gnu_plot_fd "set pm3d map corners2color c3"
	puts $gnu_plot_fd "set cbrange \[$z_min:$z_max\]"
	if {$graph_ylabel == "PER"} {
		set palette {(-1 "black", 0 "white", 50 "orange", 100 "red")}
	} else {
		set palette {(0 "black", 500 "blue", 10000 "red", 50000 "yellow", 90000 "white")}
	}
	puts $gnu_plot_fd "set palette defined $palette"	
	puts $gnu_plot_fd "set cblabel 'PerCent %'"
	puts $gnu_plot_fd "set yrange \[-0.5:$y_max\]"
	puts $gnu_plot_fd "splot \"$::logdir/GraphsData/${filename}.gnu_data\" title \"$object_name\" with image ls 1"
	puts $gnu_plot_fd "quit"

	close $gnu_plot_fd
	set catch_resp [catch "exec $::UTF::Gnuplot $::logdir/GraphsData/${filename}.gnu_plot" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc sts::max_range {val} {
	if {$val > 10000} {
		return 10000
	} elseif {$val > 1000} {
		return 1000
	} elseif {$val > 500} {
		return 500
	} elseif {$val > 100} {
		return 100
	} elseif {$val > 10} {
		return 10
	} else {
		return 0
	}
}

proc sts::round_down {val rounder} {
	set nval [expr {floor([expr {$val * $rounder}]) / $rounder}]
	return $nval
}

proc sts::round_up {val rounder} {
	set nval [expr {double([expr {$val * $rounder}]) / $rounder}]
	return $nval
}

proc format_number {num} {
  # number with 5 decimal places
  set num_dec5 [format "%.5f" $num]
  puts "\$num_dec5 = $num_dec5"
  set dec_point_pos [string first "." $num_dec5]
  puts "\$dec_point_pos = $dec_point_pos"
  # number with length of 8 characters
  if {$dec_point_pos < 7} {
    set num_len8 [string range $num_dec5 0 7]
    set result $num_len8
  } elseif {$dec_point_pos == 7 || $dec_point_pos == 8} {
    set num_len8 [string range $num_dec5 0 $dec_point_pos-1]
    set result $num_len8
  } else {
    puts "Number could not be formatted at 8 characters !"
    set result $num
  }
  puts "\$result = $result"
  return $result
}

proc sts::roaming_setup_sniffer {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup Sniffer" {
	
		UTF::Message INFO "" "************************Func:roaming_setup_sniffer***************************"

		set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_pcap_file ".pcap"
		set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_csv_file ".csv"

		UTF::Message LOG "" "=====================Setup sniffer================================"
		$::sniffer_object setupSniffer $::roaming_channel
		$::sniffer_object wl ver
		catch {$::sniffer_object stopall}
		catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_pcap_file}
		catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_csv_file}
		catch {$::sniffer_object rm -f /root/bin/tshark_cmd_line}
		catch {$::sniffer_object rm -f /root/bin/tshark_cmd_line_parse}

		###############################################################
		# sniffer pcap file will be captured
		# after stopping the sniffer, it will be filtered and converted to csv file for parsing
		###############################################################

		set cmd_line "tshark -i radiotap0 -w /root/bin/$roaming_sniffer_pcap_file"
		set cmd_line_file "tshark_cmd_line"
		set fd [open "$::logdir/$cmd_line_file" w+]
		puts $fd "$cmd_line"
		close $fd
		UTF::Sleep 1
		UTF::Message LOG "" "chmod 777 $::logdir/$cmd_line_file"
		exec chmod 777 $::logdir/$cmd_line_file
		UTF::Sleep .5
		
		set sniff_ip [$::sniffer_object cget -lan_ip]

		# copy the file to sniffer /root/bin/tshark_cmd_line
		UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
		set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			# failed. create the /root/bin directory since it could be missing
			UTF::Message LOG "" "$::sniffer_object mkdir -p /root/bin"
			catch {$::sniffer_object mkdir -p /root/bin}

			set catch_resp [catch {$::sniffer_object mkdir -p /root/bin} catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. Could not create /root/bin on Sniffer. Please cleanup /root/bin location."
				error "Cleanup sniffer /root/bin"
			} else {
				UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
				set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			}
		}
		UTF::Message LOG "" "====================================================="

		set cmd_line_parse "tshark -2 -r /root/bin/$roaming_sniffer_pcap_file -Y \"(wlan.fc.type_subtype == 40 || wlan.fc.type_subtype == 11) && (wlan.bssid == $::roaming_src_ap_mac || wlan.bssid == $::roaming_dst_ap_mac)\" -E header=y -E separator=, -T fields -e frame.number -e frame.time_relative -e wlan.duration -e ip.src -e ip.dst -e wlan.ta -e wlan.ra -e frame.len -e wlan.fc.type_subtype -e wlan_mgt.ssid -e wlan.flags -e wlan.fc.retry -e radiotap.channel.freq -e wlan_mgt.ht.info.primarychannel -e radiotap.vht.bw -e radiotap.datarate -e radiotap.dbm_antsignal -e wlan.seq -e wlan.ba.bm -e wlan.bssid > /root/bin/$roaming_sniffer_csv_file"
		set cmd_line_file "tshark_cmd_line_parse"
		set fd [open "$::logdir/$cmd_line_file" w+]
		puts $fd "$cmd_line_parse"
		close $fd
		UTF::Sleep 1
		UTF::Message LOG "" "chmod 777 $::logdir/$cmd_line_file"
		exec chmod 777 $::logdir/$cmd_line_file
		UTF::Sleep .5

		# copy the file to sniffer /root/bin/tshark_cmd_line_parse
		UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
		set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Could not copy '$cmd_line_file' to '/root/bin' on Sniffer."
			error "Failed to copy '$cmd_line_file' to '/root/bin' on Sniffer"
		}
	}
}

proc sts::roaming_stop_sniffer {} {
	# access option array
	upvar {} {}
	
	UTF::Message INFO "" "************************Func:roaming_stop_sniffer***************************"

	# stop the sniffer
	catch {$::sniffer_object stopall}
	
	set sniff_ip [$::sniffer_object cget -lan_ip]

	set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_pcap_file ".pcap"
	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	###############################################################
	# sniffer pcap file is captured now. filter and convert to csv file for parsing
	###############################################################

	# sync call to generate the csv file
	catch "$::sniffer_object rexec /root/bin/tshark_cmd_line_parse"

	UTF::Message LOG "" "Check for sniffer csv file /root/bin/$roaming_sniffer_csv_file"
	set catch_resp [catch "$::sniffer_object rexec ls -la /root/bin/$roaming_sniffer_csv_file" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	if {$catch_resp != 0} {
		UTF::Message LOG "" "***Failed. Sniffer parsing did not work. $catch_msg"
		set ::roaming_sniffer_failed_flag 1
		set ::roaming_sniffer_failed_msg "Sniffer parsing did not work"
	} else {
		# copy over the sniffer file to the report location
		UTF::Message LOG "" "scp -Bqr root@$sniff_ip:/root/bin/$roaming_sniffer_csv_file $::logdir/$roaming_sniffer_csv_file"
		set catch_resp [catch {exec scp -Bqr root@$sniff_ip:/root/bin/$roaming_sniffer_csv_file "$::logdir/$roaming_sniffer_csv_file"} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		if {$catch_resp == 0} {
			# copied the file, now remove it from the sniffer
			catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_pcap_file}
			catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_csv_file}
		}
	}

	# clean up sniffer temp files
	catch {$::sniffer_object rm -f /tmp/ether*}
}

proc sts::get_date_difference {start_datetime end_datetime} {

	set TimeDiff -1

	catch {
		regexp {(.*)\.(.*)} $start_datetime smatch start_date start_sec
		regexp {(.*)\.(.*)} $end_datetime lmatch end_date end_sec

		set start_num [clock scan $start_date]
		set start_num "$start_num\.$start_sec"
		set start_num [format "%.6f" $start_num]
		
		set end_num [clock scan $end_date]
		set end_num "$end_num\.$end_sec"
		set end_num [format "%.6f" $end_num]
		
		set TimeDiff [expr {$end_num - $start_num}]
		set TimeDiff [format "%.6f" $TimeDiff]
		UTF::Message INFO "" "\n$end_num - $start_num = $TimeDiff\n"
	}

	return $TimeDiff
}

proc sts::roaming_parse_sniffer {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:roaming_parse_sniffer***************************"

	# for raoming, the first GC is only used
	set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

	set ::roam_time -1

	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	# downstream throughput
	set FromIP $::array_streams_ap_controller_ip(${::curr_test_no})
	set ToIP $::array_sta_apsta_ip(${sta_name})
	set FromBssid $::roaming_src_ap_mac
	set ToBssid $::roaming_dst_ap_mac

	set BeginRoamTimeStamp ""
	set EndRoamTimeStamp ""
	set offset 0

	UTF::Message INFO "" "\nsniffer_file: $::logdir/$roaming_sniffer_csv_file\nFromIP: $FromIP\nToIP: $ToIP\nFromBssid: $FromBssid\nToBssid: $ToBssid\n"

	if {$::array_streams_traffic_type(${::curr_test_no},1) == "TCP"} {
		# for TCP look for a message with at least 1 byte
		set msg_len 1
	} else {
		# for UDP look for any length message
		set msg_len 0
	}

	set csv_fd [open $::logdir/$roaming_sniffer_csv_file]

	# find the Authentication in the trace
	# FC11 -> 2011-03-30 12:14:01.974201 Epigram_c5:00:34 -> Epigram_a6:00:30 IEEE 802.11 Authentication, SN=202, FN=0, Flags=........[Malformed Packet]  wlan.bssid == 00:90:4c:a6:00:30
	# FC15 -> 2014-09-29 14:35:01.648222 Broadcom_ee:b4:43 -> Epigram_0d:c0:d3 802.11 88 Authentication, SN=211, FN=0, Flags=........C  wlan.bssid == 00:90:4c:0d:c0:d3
	
	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************   Looking for Authentication    **************************"
	UTF::Message LOG "" "***********************************************************************************"

	# when 'wlan.fc.type_subtype == 11', that is the Authentication
	
	set csv_curr_line_no 0
	set csv_index_subtype -1
	set csv_index_ip_src -1
	set csv_index_ip_dst -1
	set csv_index_bssid -1
	set csv_index_msg_len -1
	set csv_index_msg_time -1
	while {[gets $csv_fd line] >= 0} {
		incr csv_curr_line_no
		set csv_columns_data [split $line ","]

		# find 'wlan.fc.type_subtype' in csv header
		if {$csv_curr_line_no == 1} {
			set csv_column_cnt 0
			foreach csv_column "$csv_columns_data" {
				if {$csv_column == "wlan.fc.type_subtype"} {
					set csv_index_subtype $csv_column_cnt
				} elseif {$csv_column == "ip.src"} {
					set csv_index_ip_src $csv_column_cnt
				} elseif {$csv_column == "ip.dst"} {
					set csv_index_ip_dst $csv_column_cnt
				} elseif {$csv_column == "wlan.bssid"} {
					set csv_index_bssid $csv_column_cnt
				} elseif {$csv_column == "frame.len"} {
					set csv_index_msg_len $csv_column_cnt
				} elseif {$csv_column == "frame.time_relative"} {
					set csv_index_msg_time $csv_column_cnt
				}
				incr csv_column_cnt
			}
			
			if {$csv_index_subtype == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'wlan.fc.type_subtype' in the sniffer csv hearder."
				error "subtype missing in the sniffer csv hearder"
			} elseif {$csv_index_ip_src == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'ip.src' in the sniffer csv hearder."
				error "ip.src missing in the sniffer csv hearder"
			} elseif {$csv_index_ip_dst == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'ip.dst' in the sniffer csv hearder."
				error "ip.dst missing in the sniffer csv hearder"
			} elseif {$csv_index_bssid == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'wlan.bssid' in the sniffer csv hearder."
				error "bssid missing in the sniffer csv hearder"
			} elseif {$csv_index_msg_len == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'frame.len' in the sniffer csv hearder."
				error "Msg length missing in the sniffer csv hearder"
			} elseif {$csv_index_msg_time == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'frame.time_relative' in the sniffer csv hearder."
				error "Msg time missing in the sniffer csv hearder"
			}

			continue
		}

		set csv_subtype [lindex $csv_columns_data $csv_index_subtype]

		if {$csv_subtype == 11} {
			UTF::Message INFO "" "'802.11 Authentication' $line"
			set offset [tell $csv_fd]
			break
		}
	}

	# TCP msg:
	#   DATE        TIME          IP FROM      ->     TO IP                                                                                                   Len=                                       wlan.bssid ==
	# 2014-10-24 11:46:39.321196 192.168.1.220 -> 192.168.1.236 TCP 3124 [TCP Out-Of-Order] [TCP Out-Of-Order] 53087 > 55001 [ACK] Seq=192407345 Ack=1 Win=46 Len=1448 TSval=4263696804 TSecr=186301512  wlan.bssid == 00:10:18:a9:36:35
	#                            DATE                      TIME                         IP FROM        ->      TO IP         ANY Len=    ANY wlan\.bssid ==
	# set result [regexp {([0-9]+\-[0-9]+\-[0-9]+ [0-9]+\:[0-9]+\:[0-9]+\.[0-9]+) (\d+\.\d+\.\d+\.\d+) -> (\d+\.\d+\.\d+\.\d+).* Len=(\d+).*wlan\.bssid == (.*:.*:.*:.*:.*:.*)} $line match dataTime from to len bssid]
	#
	# UDP Video msg:
	#   DATE        TIME          IP FROM      ->     TO IP     UDP length                                            wlan.bssid ==
	# 2014-10-24 12:13:44.735651 192.168.1.220 -> 192.168.1.236 UDP 1584 Source port: 35927  Destination port: 55005  wlan.bssid == 00:10:18:a9:36:35
	#                            DATE                      TIME                         IP FROM        ->      TO IP           UDP length ANY wlan\.bssid ==
	# set result [regexp {([0-9]+\-[0-9]+\-[0-9]+ [0-9]+\:[0-9]+\:[0-9]+\.[0-9]+) (\d+\.\d+\.\d+\.\d+) -> (\d+\.\d+\.\d+\.\d+) UDP (\d+).*wlan\.bssid == (.*:.*:.*:.*:.*:.*)} $line match dataTime from to len bssid]

	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************	Looking for 'BEGIN' Raoming	**************************"
	UTF::Message LOG "" "************************	Last downstream msg with $FromIP -> $ToIP  &  AP1 $FromBssid  & msg length of $msg_len or more"
	UTF::Message LOG "" "***********************************************************************************"

	# start from about 30 lines before the Authentication line 
	set BiginOffset [expr {$offset - 20000}]

	if {$BiginOffset < 0} {
		set BiginOffset 0
	}

	seek $csv_fd $BiginOffset

	set save_begin_roam_line ""
	set ap2_msg_cnt 0
	set cnt 0

	while {[gets $csv_fd line] >= 0} {

		set csv_columns_data [split $line ","]
		set csv_ip_src [lindex $csv_columns_data $csv_index_ip_src]
		set csv_ip_dst [lindex $csv_columns_data $csv_index_ip_dst]
		set csv_bssid [lindex $csv_columns_data $csv_index_bssid]
		set csv_msg_len [lindex $csv_columns_data $csv_index_msg_len]

		set csv_bssid [string toupper $csv_bssid]

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $ToBssid} {
			# AP2 msg
			incr ap2_msg_cnt
			if {$ap2_msg_cnt > 20} {
				# Done, since it is AP2 msgs now
				break
			}
		}

		UTF::Message INFO "" "$line"

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $FromBssid && $csv_msg_len >= $msg_len} {  
			set BeginRoamTimeStamp [lindex $csv_columns_data $csv_index_msg_time]
			set save_begin_roam_line $line
			incr cnt
			UTF::Message INFO "" "Begin Roam Data Count $cnt: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
			set ap2_msg_cnt 0
		} else {
			UTF::Message INFO "" "SKIP: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
		}
	}

	if {$save_begin_roam_line == ""} {
		UTF::Message ERROR "" "\n\n\nBegin roam time is not found"
		return "Roam begin time not found"
	}

	UTF::Message LOG "" "-----------------------------------------------------------------------------------"
	UTF::Message INFO "" "Begin roam: $save_begin_roam_line"
	UTF::Message LOG "" "-----------------------------------------------------------------------------------"

	# For 'END' Raoming voice and non-voice, look for any length message
	set msg_len 0

	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************	Looking for 'END' Raoming	**************************"
	UTF::Message LOG "" "************************	1st downstream msg with $FromIP -> $ToIP  &  AP2 $ToBssid  & msg length of $msg_len or more"
	UTF::Message LOG "" "***********************************************************************************"

	# start from about 10 lines before the Authentication line 
	set BiginOffset [expr {$offset - 5000}]

	if {$BiginOffset < 0} {
		set BiginOffset 0
	}

	seek $csv_fd $BiginOffset

	set save_end_roam_line ""
	set cnt 0
	set skip_flag 1

	while {[gets $csv_fd line] >= 0} {

		# skip lines till save_begin_roam_line is found
		if {$skip_flag == 1} {
			if {$line == $save_begin_roam_line} {
				set skip_flag 0
			} else {
				continue
			}
		}

		UTF::Message INFO "" "$line"

		set csv_columns_data [split $line ","]
		set csv_ip_src [lindex $csv_columns_data $csv_index_ip_src]
		set csv_ip_dst [lindex $csv_columns_data $csv_index_ip_dst]
		set csv_bssid [lindex $csv_columns_data $csv_index_bssid]
		set csv_msg_len [lindex $csv_columns_data $csv_index_msg_len]

		set csv_bssid [string toupper $csv_bssid]

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $ToBssid && $csv_msg_len >= $msg_len} {
			set EndRoamTimeStamp [lindex $csv_columns_data $csv_index_msg_time]
			set save_end_roam_line $line
			incr cnt
			UTF::Message INFO "" "End Roam Data Count $cnt: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
			break
		} else {
			UTF::Message INFO "" "SKIP: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
		}
	}

	if {$save_end_roam_line == ""} {
		UTF::Message ERROR "" "\n\n\nEnd roam time is not found"
		return "Roam end time not found"
	}

	UTF::Message LOG "" "-----------------------------------------------------------------------------------"
	UTF::Message INFO "" "End roam: $save_end_roam_line"
	UTF::Message LOG "" "-----------------------------------------------------------------------------------\n\n\n"

	close $csv_fd

	UTF::Message INFO "" "\nRoam end at:   $EndRoamTimeStamp\nRoam begin at: $BeginRoamTimeStamp\n"
	set roam_time [expr {$EndRoamTimeStamp - $BeginRoamTimeStamp}]
	set roam_time [expr {round([expr {$roam_time * 1000.0}])}]
	UTF::Message INFO "" "Roam Time=$roam_time ms"
	set ::roam_time $roam_time
	
	return ""
}

proc sts::get_roaming_time {test_type} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:get_roaming_time***************************"

	# for raoming, the first GC is only used
	set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	if {$::failover_test_flag} {
		set title "$test_type - Failover Roam Time"
		set roaming_type "Failover"
	} else {
		set title "$test_type - Smooth Roam Time"
		set roaming_type "Smooth"
	}

	# parse the sniffer file and calculate roaming time

	UTF::Try "$title (ms)" {

		set rc [sts::roaming_parse_sniffer]
		
		if {$::roam_time == -1 || $rc != ""} {

			UTF::Message ERROR "" "Roam time calculation failed"

			# Add a web link to the sniffer file
			UTF::Try "Link to sniffer file $roaming_sniffer_csv_file" {
				return "html: <a href=\"$::logdir/$roaming_sniffer_csv_file\">$roaming_sniffer_csv_file</a>"
			}

			incr ::error_cnt

			if {$rc != ""} {
				error $rc
			} else {
				error "Roam time not found"
			}
		} else {
			UTF::Message INFO "" "Roam time calculation successfull."

			UTF::Try "Delete sniffer file" {
				set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
				append roaming_sniffer_pcap_file ".pcap"
				set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
				append roaming_sniffer_csv_file ".csv"

				UTF::Message INFO "" "Deleting the sniffer file $::logdir/$roaming_sniffer_csv_file"

				set catch_resp [catch {exec rm -f $::logdir/$roaming_sniffer_csv_file} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp == 0} {
					set catch_resp [catch {exec rm -f $::logdir/$roaming_sniffer_pcap_file} catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				}

				if {$catch_resp != 0} {
					UTF::Message ERROR "" "Delete sniffer file failed"
					error "Delete sniffer file failed"
				}

				return ""
			}
		}

		set keys "$::array_streams_control_chart_base_key(${::curr_test_no}) $test_type $roaming_type roam_time"
		UTF::Message INFO "" "keys=$keys"

		# Create new ControlChart object & graphics file
		set html_results [sts::control_chart "" $::roam_time $keys "Roam Time" "ms" 0]

		if {$::failover_test_flag == 1} {
			if {$::roam_time > 15000} {
				# error
				set ::roaming_error_flag 1
				append html_results " &nbsp;<font color=\"red\"><b>Roam Time > 15 sec</b></font>"
			}
		} else {
			if {$::roam_time > 40} {
				# error
				set ::roaming_error_flag 1
				append html_results " &nbsp;<font color=\"red\"><b>Roam Time > 40 ms</b></font>"
			}
		}

		if {$::roaming_error_flag == 1} {
			error "html: $html_results"
		} else {
			return "html: $html_results"
		}
	}

	if {$::error_cnt == 0 && $::failover_test_flag == 0} {

		UTF::Try "$test_type - Smooth Roam Delta (dB)" {

			set csv_data_fd [open "$::curr_csv_data_fullname" r]

			# read the csv data to figure out 'Roam Delta'

			set y_max 0
			set len_max 0
			set csv_curr_line_no 0
			set csv_header_line_cnt 2
			set last_rssi_value ""
			set ::roam_delta_value ""
			
			set csv_index_bssid [find_csv_column_index "StaBssid($sta_name)" $::csv_columns_data_list]
			set csv_index_rssi [find_csv_column_index "StaRssi($sta_name)" $::csv_columns_data_list]

			while {[gets $csv_data_fd line]>=0} { 
				incr csv_curr_line_no

				# skip csv header
				if {$csv_curr_line_no <= $csv_header_line_cnt} {
					continue
				}

				set columns [split $line ","]
				set bssid "[lindex $columns $csv_index_bssid]"
				set bssid [string trim $bssid]
				set rssi "[lindex $columns $csv_index_rssi]"

				if {$bssid == $::roaming_src_ap_mac} {
					set last_rssi_value $rssi
				}
				if {$bssid == $::roaming_dst_ap_mac} {
					set ::roam_delta_value [expr {abs([expr {$rssi - $last_rssi_value}])}]
					UTF::Message LOG "" "::roam_delta_value = ($rssi) - ($last_rssi_value) = $::roam_delta_value"
					break
				}
			}

			set keys "$::array_streams_control_chart_base_key(${::curr_test_no}) $test_type $roaming_type roam_delta"
			UTF::Message INFO "" "keys=$keys"

			# Create new ControlChart object & graphics file
			set html_results [sts::control_chart "" $::roam_delta_value $keys "Roam Delta" "dB" 0]

			if {$::roaming_error_flag == 1} {
				error "html: $html_results"
			} else {
				return "html: $html_results"
			}
		}
	}	
}

proc sts::roaming_calculate_attn_values {} {
	# access option array
	upvar {} {}

	# for raoming, the first GC is only used
	set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

	set iperf_name $::array_sta_iperf_name(${sta_name})

	set tmp_roam_trig_value 0
	set tmp_roaming_delta ""
	set tmp_src_ap_ssid ""
	set tmp_dst_ap_ssid ""

	UTF::Message INFO "" "************************Func:roaming_calculate_attn_values***************************"

	UTF::Try "Calculate Attn Values" {
		UTF::Message INFO "" "src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap STA=$sta_name"

		set ::roaming_dwell_time_sec 3

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5

		###############################################			
		# Calculate attenuator values for the src_ap (going away)
		# Find attenuation at tmp_roam_trig_value - This is ::roaming_src_ap_attn_end value
		# ::roaming_src_ap_attn_start = ::roaming_src_ap_attn_end - attn cnt tmp_roaming_delta
		###############################################			

		for {set j 1} {$j <= 3} {incr j} {
				UTF::Message INFO "" "Associate $::roaming_src_ap $sta_name Try: $j"  
			UTF::Message INFO "" "Disassociate $sta_name"  
			catch {$sta_name wl disassoc}
			UTF::Sleep 2
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_name" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			UTF::Message LOG "" "-----------------------------------------------"
			if {$catch_resp == 0} { 
				break
			}
		}

		set catch_resp [catch "$sta_name wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$::roaming_src_ap_mac != "" && $::roaming_src_ap_mac != $catch_msg} {
				# ::roaming_src_ap_mac is config file did not match the read AP mac address
				UTF::Message INFO "" "AP Mac Id Mismatch. ::roaming_src_ap_macConfig=$::roaming_src_ap_mac APMac=$catch_msg"
			}

			set ::roaming_src_ap_mac $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac from association"  
		}

		set catch_resp [catch "$::roaming_src_ap wl ssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$tmp_src_ap_ssid != "" && $tmp_src_ap_ssid != $catch_msg} {
				# tmp_src_ap_ssid is config file did not match the read AP ssid
				UTF::Message ERROR "" "***Failed. Mismatch. tmp_src_ap_ssid=$tmp_src_ap_ssid Assoc_APssid=$catch_msg"
				error "$::roaming_src_ap SSID mismatch"
			}

			set tmp_src_ap_ssid $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with AP ssid=$tmp_src_ap_ssid"  
		}

		set catch_resp [catch "$sta_name wl roam_trigger $::roaming_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_name wl roam_trigger $::roaming_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			# roam_trigger is 0xffb5(-75)
			regexp {roam_trigger is .*\((-[0-9]+)\)} $catch_msg match tmp_roam_trig_value
			UTF::Message INFO "" "tmp_roam_trig_value=$tmp_roam_trig_value"
		}

		set catch_resp [catch "$sta_name wl roam_delta $::roaming_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_name wl roam_delta $::roaming_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			# roam_delta is 0x0014(20)
			regexp {roam_delta is .*\(([0-9]+)\)} $catch_msg match tmp_roaming_delta
			UTF::Message INFO "" "tmp_roaming_delta=$tmp_roaming_delta"
		}

		# Start downstream iperf traffic
		UTF::Message INFO "" "A - calculate_attn_values - Start the iperf"

		set fd_rx [$sta_name rpopen $iperf_name -s -fm -i $::perfint -p $::curr_iperf_port -l 8k -P 1]
		set stream_ids "iperf $fd_rx"
		set catch_resp [catch {set iperf_endpoint_pid [pid $fd_rx]} catch_msg]
		set fd_tx [$::array_streams_ap_controller(${::curr_test_no}) rpopen $iperf_name -c $::array_sta_apsta_ip(${sta_name}) -t 120 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
		fconfigure $fd_tx -blocking 0
		fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		UTF::Sleep .5
		incr ::curr_iperf_port

		set attn_val 0

		while { 1 } {

			$::roaming_src_ap_attn_group attn $attn_val
			UTF::Sleep $::roaming_dwell_time_sec

			set catch_resp [catch "$sta_name wl rssi" catch_msg]

			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. $catch_msg"
				error $catch_msg
			} else {
				set rssi [expr {int($catch_msg)}]

				UTF::Message INFO "" "-> attn_val=$attn_val rssi=$rssi"  
			}

			if {$attn_val > 100} {
				break
			}

			# break if rssi greater than tmp_roam_trig_value 
			if {[expr {int($rssi)}] < [expr {int($tmp_roam_trig_value) + int(-4)}]} {
				break
			}

			if {$attn_val == 0} {
				set attn_val [expr {int($tmp_roam_trig_value) - int($rssi)}]
				set attn_val [expr {abs(int($attn_val))}]
			} else {
				set attn_val [expr {$attn_val + 2}]
			}
		}

		set src_ap_roam_trigger_attn [expr {$attn_val - 1}]
		UTF::Message INFO "" "1 src_ap_roam_trigger_attn=$src_ap_roam_trigger_attn"

		if {!$::failover_test_flag} {
			UTF::Message LOG "" "*************************** Smooth Roaming *****************************"

			UTF::Message INFO "" "2 src_ap_roam_trigger_attn=$src_ap_roam_trigger_attn"

			# src_ap start = src_ap_roam_trigger_attn - tmp_roaming_delta(20dB)
			# src_ap end	= src_ap_roam_trigger_attn
			set ::roaming_src_ap_attn_start [expr {$src_ap_roam_trigger_attn - $tmp_roaming_delta - 1}]
			if {int($::roaming_src_ap_attn_start) < 0} {
				set ::roaming_src_ap_attn_start 0
			}
			if {$::roaming_src_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_start"
				}
		
				set ::roaming_src_ap_attn_start $::max_attn
			}
			set ::roaming_src_ap_attn_end [expr {$src_ap_roam_trigger_attn + 1}]
			if {$::roaming_src_ap_attn_end > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_end."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_end"
				}

				set ::roaming_src_ap_attn_end $::max_attn
			}
			
			set ::roaming_sniffer_start_attn [expr {$src_ap_roam_trigger_attn - 4}]
		} else {
			UTF::Message LOG "" "*************************** Failover Roaming *****************************"

			set ::roaming_src_ap_attn_start [expr {$src_ap_roam_trigger_attn - 35}]
			if {$::roaming_src_ap_attn_start < 0} {
				set ::roaming_src_ap_attn_start 0
			}
			if {$::roaming_src_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_start"
				}

				set ::roaming_src_ap_attn_start $::max_attn
			}
			set ::roaming_src_ap_attn_end $::roaming_src_ap_attn_start
		}

		UTF::Message INFO "" "src_ap Start=$::roaming_src_ap_attn_start"
		UTF::Message INFO "" "src_ap End  =$::roaming_src_ap_attn_end"

		UTF::Message INFO "" "Stop the iperf traffic"
		UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
		set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		UTF::Message LOG "" "--------------------------------------------------------------------------"
		
		###############################################			
		# Calculate attenuator values for the dst_ap
		# Find attenuation at (tmp_roam_trig_value - tmp_roaming_delta) - This is ::roaming_dst_ap_attn_end value
		# ::roaming_dst_ap_attn_start = ::roaming_dst_ap_attn_end - attn cnt src ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_name"  
		catch {$sta_name wl disassoc}

		$::roaming_src_ap_attn_group attn $::max_attn
		$::roaming_dst_ap_attn_group attn 0
		UTF::Sleep 5

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "Disassociate $sta_name"  
			catch {$sta_name wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_dst_ap $sta_name Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_dst_ap $sta_name" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			UTF::Message LOG "" "-----------------------------------------------"
			if {$catch_resp == 0} { 
				break
			}
		}

		set catch_resp [catch "$sta_name wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$::roaming_dst_ap_mac != "" && $::roaming_dst_ap_mac != $catch_msg} {
				# ::roaming_dst_ap_mac is config file did not match the read AP mac address
				UTF::Message INFO "" "AP Mac Id Mismatch. ::roaming_dst_ap_macConfig=$::roaming_dst_ap_mac APMac=$catch_msg"
			}

			set ::roaming_dst_ap_mac $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac from association"  
		}

		set catch_resp [catch "$::roaming_dst_ap wl ssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$tmp_dst_ap_ssid != "" && $tmp_dst_ap_ssid != $catch_msg} {
				# tmp_dst_ap_ssid is config file did not match the read AP ssid
				UTF::Message ERROR "" "***Failed. Mismatch. tmp_dst_ap_ssidConfig=$tmp_dst_ap_ssid APssid=$catch_msg"
				error "$::roaming_dst_ap SSID mismatch"
			}

			set tmp_dst_ap_ssid $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with AP ssid=$tmp_dst_ap_ssid"  
		}

		# Start downstream iperf traffic
		UTF::Message INFO "" "B - calculate_attn_values - Start the iperf"

		set fd_rx [$sta_name rpopen $iperf_name -s -fm -i $::perfint -p $::curr_iperf_port -l 8k -P 1]
		set stream_ids "iperf $fd_rx"
		set catch_resp [catch {set iperf_endpoint_pid [pid $fd_rx]} catch_msg]
		set fd_tx [$::array_streams_ap_controller(${::curr_test_no}) rpopen $iperf_name -c $::array_sta_apsta_ip(${sta_name}) -t 120 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
		fconfigure $fd_tx -blocking 0
		fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		UTF::Sleep .5
		incr ::curr_iperf_port

		set attn_val 0

		while { 1 } {

			$::roaming_dst_ap_attn_group attn $attn_val
			UTF::Sleep $::roaming_dwell_time_sec

			set catch_resp [catch "$sta_name wl rssi" catch_msg]

			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. $catch_msg"
				error $catch_msg
			} else {
				set rssi [expr {int($catch_msg)}]

				UTF::Message INFO "" "-> attn_val=$attn_val rssi=$rssi"  
			}

			if {$attn_val > 100} {
				break
			}

			# break if rssi greater than tmp_roam_trig_value - tmp_roaming_delta
			if {[expr {int($rssi)}] < [expr {int($tmp_roam_trig_value) + int($tmp_roaming_delta)}]} {
				UTF::Message INFO "" "rssi < tmp_roam_trig_value + tmp_roaming_delta"  
				UTF::Message INFO "" "$rssi < $tmp_roam_trig_value + $tmp_roaming_delta"  
				UTF::Message INFO "" "done"  
				break
			}

			if {$attn_val == 0} {
				UTF::Message INFO "" "attn_val is 0"  
				UTF::Message INFO "" "attn_val = tmp_roam_trig_value - rssi + tmp_roaming_delta"  
				set attn_val [expr {int($tmp_roam_trig_value) - int($rssi) + int($tmp_roaming_delta)}]
				set attn_val [expr {abs(int($attn_val))}]
				UTF::Message INFO "" "$attn_val = $tmp_roam_trig_value - $rssi + $tmp_roaming_delta"  
			} else {
				UTF::Message INFO "" "attn_val=$attn_val + 2"  
				set attn_val [expr {$attn_val + 2}]
			}
		}

		if {$attn_val < 0} {
			set attn_val 0
		}

		if {!$::failover_test_flag} {
			UTF::Message LOG "" "*************************** Smooth Roaming *****************************"

			set ::roaming_dst_ap_attn_start [expr {$attn_val + int([expr {$tmp_roaming_delta / 2.0}])}]
			set ::roaming_dst_ap_attn_end 0
			
			if {$::roaming_dst_ap_attn_start < 0} {
				set ::roaming_dst_ap_attn_start 0
			}
			if {$::roaming_dst_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_start"
				}

				set ::roaming_dst_ap_attn_start $::max_attn
			}
			if {$::roaming_dst_ap_attn_end < 0} {
				set ::roaming_dst_ap_attn_end 0
			}
			if {$::roaming_dst_ap_attn_end > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_end."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_end"
				}

				set ::roaming_dst_ap_attn_end $::max_attn
			}
			
			set ret_str "Attn: src_ap=$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end dst_ap=$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end sniffer_start=$::roaming_sniffer_start_attn"
		} else {
			UTF::Message LOG "" "*************************** Failover Roaming *****************************"

			#set ::roaming_dst_ap_attn_start [expr {$attn_val + int($tmp_roaming_delta) - 10.0}]
			set ::roaming_dst_ap_attn_start $::roaming_src_ap_attn_start
			if {$::roaming_dst_ap_attn_start < 0} {
				set ::roaming_dst_ap_attn_start 0
			}
			if {$::roaming_dst_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_start"
				}

				set ::roaming_dst_ap_attn_start $::max_attn
			}
			set ::roaming_dst_ap_attn_end $::roaming_dst_ap_attn_start
			set ret_str "Attn: src_ap=$::roaming_src_ap_attn_start dst_ap=$::roaming_dst_ap_attn_start"
		}

		UTF::Message INFO "" "dst_ap Start=$::roaming_dst_ap_attn_start"
		UTF::Message INFO "" "dst_ap End  =$::roaming_dst_ap_attn_end"

		UTF::Message INFO "" "Stop the iperf traffic"
		UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
		set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		UTF::Message LOG "" "--------------------------------------------------------------------------"

		return $ret_str
	}
}

proc sts::get_roaming_macid_values {} {
	# access option array
	upvar {} {}

	# for raoming, the first GC is only used
	set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

	set tmp2_roam_trig_value 0
	set ::roam_trigger_value ""
	set ::roam_delta_value ""

	UTF::Try "Check Mac IDs" {
		UTF::Message INFO "" "************************Func:get_roaming_macid_values***************************"
		UTF::Message INFO "" "src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap STA=$sta_name"

		UTF::Message INFO "" "--------------------------------src_ap------------------------------------"  

		###############################################			
		# src_ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_name"  
		catch {$sta_name wl disassoc}
		UTF::Sleep 2

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5

		# set the roaming ssid for bath APs		
		foreach ap "$::roaming_src_ap $::roaming_dst_ap" {
			set SSID ""
			if {$::array_sta_softap_flag(${::array_streams_ap_controller(${::curr_test_no})}) == 0} {
				# AP
				set wlname [$ap wlname]

				catch {$ap nvram set ${wlname}_ssid=$::roaming_test_ssid}
				$ap nvram commit
				$ap restart
				UTF::Sleep 10

				$ap configure -ssid $::roaming_test_ssid

				catch {$ap nvram get ${wlname}_ssid} SSID
			} else {
				# SoftAP
				catch "$ap wl ssid $::roaming_test_ssid"
				set catch_resp [catch "$ap wl ssid" SSID]
			}
			
			if {$SSID != $::roaming_test_ssid} {
				set tmp "SSID for $ap is '$SSID' instead of '$::roaming_test_ssid'"
				UTF::Message ERROR "" "***Failed. $tmp"
				incr ::error_cnt
				error $tmp
			}
		}

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_name"  
			catch {$sta_name wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_src_ap $sta_name Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_name" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		set src_ap_bssid ""
		set catch_resp [catch "$::roaming_src_ap wl bssid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set src_ap_bssid $catch_msg
			UTF::Message LOG "" "src_ap_bssid=$src_ap_bssid"
		}
		
		set catch_resp [catch "$sta_name wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set ::roaming_src_ap_mac $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac from association"  

			if {$::roaming_src_ap_mac == "" || $::roaming_src_ap_mac != $src_ap_bssid} {
				# ::roaming_src_ap_mac is config file did not match the read AP mac address
				UTF::Message ERROR "" "***Failed. Source AP association problem. AP BSSID '$src_ap_bssid' != STA BSSID '$::roaming_src_ap_mac'"
				incr ::error_cnt
				error "Source AP BSSID mismatch"
			}
		}

		set ap_band [$::roaming_src_ap band $::roaming_channel]
		
		set catch_resp [catch "$sta_name wl roam_trigger $ap_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_name wl roam_trigger $ap_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		}
		
		# roam_trigger is 0xffb5(-75)
		regexp {roam_trigger is .*\((-[0-9]+)\)} $catch_msg match tmp2_roam_trig_value
		UTF::Message INFO "" "tmp2_roam_trig_value=$tmp2_roam_trig_value"

		if {$::roam_trigger_value == ""} {
			set ::roam_trigger_value $tmp2_roam_trig_value
		} else {
			if {$tmp2_roam_trig_value != $::roam_trigger_value} {
				UTF::Message ERROR "" "***Failed. STA roam_trigger is $tmp2_roam_trig_value instead of $::roam_trigger_value"
				incr ::error_cnt
				error "STA roam_trigger is $tmp2_roam_trig_value instead of $::roam_trigger_value"
			}
		}

		set catch_resp [catch "$sta_name wl roam_delta $ap_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_name wl roam_delta $ap_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			# roam_delta is 0x0014(20)
			regexp {roam_delta is .*\(([0-9]+)\)} $catch_msg match ::roam_delta_value
		}

		set rc "Default roam_trigger=$tmp2_roam_trig_value, roam_delta=$::roam_delta_value"
		
		UTF::Message INFO "" "--------------------------------dst_ap------------------------------------"  
		###############################################			
		# dst_ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_name"  
		catch {$sta_name wl disassoc}

		$::roaming_src_ap_attn_group attn $::max_attn
		$::roaming_dst_ap_attn_group attn 0
		UTF::Sleep 5

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_name"  
			catch {$sta_name wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_dst_ap $sta_name Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_dst_ap $sta_name" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		set dst_ap_bssid ""
		set catch_resp [catch "$::roaming_dst_ap wl bssid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set dst_ap_bssid $catch_msg
			UTF::Message LOG "" "dst_ap_bssid=$dst_ap_bssid"
		}

		set catch_resp [catch "$sta_name wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set ::roaming_dst_ap_mac $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac from association"  

			if {$::roaming_dst_ap_mac == "" || $::roaming_dst_ap_mac != $dst_ap_bssid} {
				# ::roaming_dst_ap_mac is config file did not match the read AP mac address
				UTF::Message ERROR "" "***Failed. Source AP association problem. AP BSSID '$dst_ap_bssid' != STA BSSID '$::roaming_dst_ap_mac'"
				incr ::error_cnt
				error "Destination AP BSSID mismatch"
			}
		}

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5
		
		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_name"  
			catch {$sta_name wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_src_ap $sta_name Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_name" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		regexp {^(\d+)\-(\d+)$} $::roaming_src_ap_attn - ::roaming_src_ap_attn_start ::roaming_src_ap_attn_end
		regexp {^(\d+)\-(\d+)$} $::roaming_dst_ap_attn - ::roaming_dst_ap_attn_start ::roaming_dst_ap_attn_end
		if {$::roaming_src_ap_attn_start < 0} {
			set ::roaming_src_ap_attn_start 0
		}
		if {$::roaming_src_ap_attn_start > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_src_ap_attn_start"
			}
		
			set ::roaming_src_ap_attn_start $::max_attn
		}
		if {$::roaming_src_ap_attn_end < 0} {
			set ::roaming_src_ap_attn_end 0
		}
		if {$::roaming_src_ap_attn_end > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_end."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_src_ap_attn_end"
			}
		
			set ::roaming_src_ap_attn_end $::max_attn
		}
		if {$::roaming_dst_ap_attn_start < 0} {
			set ::roaming_dst_ap_attn_start 0
		}
		if {$::roaming_dst_ap_attn_start > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_dst_ap_attn_start"
			}
		
			set ::roaming_dst_ap_attn_start $::max_attn
		}
		if {$::roaming_dst_ap_attn_end < 0} {
			set ::roaming_dst_ap_attn_end 0
		}
		if {$::roaming_dst_ap_attn_end > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_end."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_dst_ap_attn_end"
			}
		
			set ::roaming_dst_ap_attn_end $::max_attn
		}
		UTF::Message LOG "" "::roaming_src_ap_attn_start=$::roaming_src_ap_attn_start ::roaming_src_ap_attn_end=$::roaming_src_ap_attn_end"
		UTF::Message LOG "" "::roaming_dst_ap_attn_start=$::roaming_dst_ap_attn_start ::roaming_dst_ap_attn_end=$::roaming_dst_ap_attn_end"
		UTF::Message LOG "" "Attn: src_ap=$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end dst_ap=$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end"
		UTF::Message INFO "" "::roam_trigger_value=$::roam_trigger_value"
		UTF::Message INFO "" "::roam_delta_value=$::roam_delta_value"

		if {$::failover_test_flag} {
			set ::roaming_dwell_time_sec 5
			set ::roaming_max_loop_cnt 8
			set ::streams_total_time [expr {$::roaming_dwell_time_sec * $::roaming_max_loop_cnt}]
			UTF::Message LOG "" "Failover ::streams_total_time=$::streams_total_time"
		} else {
			set ::roaming_dwell_time_sec 3
			set ::roaming_max_loop_cnt [expr {$::roaming_src_ap_attn_end - $::roaming_src_ap_attn_start + 1}]
			set ::streams_total_time [expr {$::roaming_dwell_time_sec * $::roaming_max_loop_cnt}]
			UTF::Message LOG "" "Smooth ::streams_total_time=$::streams_total_time"
		}

		UTF::Message LOG "" "::roaming_max_loop_cnt=$::roaming_max_loop_cnt"
		UTF::Message LOG "" "::roaming_src_ap_mac=$::roaming_src_ap_mac"
		UTF::Message LOG "" "::roaming_dst_ap_mac=$::roaming_dst_ap_mac"

		return $rc
	}
}

proc sts::process_all_roaming_tests {} {
	# access option array
	upvar {} {}
	
	UTF::Message INFO "" "************************Func:process_all_roaming_tests***************************"

	# for raoming, the first GC is only used
	set sta_name [lindex $::array_streams_sts_slave_sta_list(${::curr_test_no}) 0]

	set tests_type_list ""
	set tests_channel_list ""
	if {!$(no5G80roaming)} {	
		append tests_type_list "5G80 "
		append tests_channel_list "36/80 "
	}
	if {!$(no5G40roaming)} {
		append tests_type_list "5G40 "
		append tests_channel_list "36l "
	}
	if {!$(no5G20roaming)} {
		append tests_type_list "5G20 "
		append tests_channel_list "36 "
	}
	if {!$(no2G40roaming)} {
		append tests_type_list "2G40 "
		append tests_channel_list "11u "
	}
	if {!$(no2G20roaming)} {
		append tests_type_list "2G20 "
		append tests_channel_list "3 "
	}

	set tests_type_list [string trim $tests_type_list]
	set tests_channel_list [string trim $tests_channel_list]

	UTF::Message LOG "" "tests_type_list='$tests_type_list' tests_channel_list='$tests_channel_list'"

	foreach test_type $tests_type_list ::roaming_channel $tests_channel_list {
		set var "roam_${test_type}_src_ap_attn"
		set ::roaming_src_ap_attn $(${var})
		set var "roam_${test_type}_dst_ap_attn"
		set ::roaming_dst_ap_attn  $(${var})		
		set var "roam_${test_type}_sniffer_start_attn"
		set ::roaming_sniffer_start_attn $(${var})
		set var "roam_${test_type}_roam_trigger_value"
		set ::roam_trigger_value $(${var})

		UTF::Message LOG "" "test_type='$test_type' ::roaming_channel='$::roaming_channel' ::roaming_src_ap_attn=$::roaming_src_ap_attn ::roaming_dst_ap_attn=$::roaming_dst_ap_attn ::roaming_sniffer_start_attn=$::roaming_sniffer_start_attn ::roam_trigger_value=$::roam_trigger_value"

		set ::error_cnt 0
		
		if {$::roam_trigger_value != ""} {
			set catch_resp [catch "$sta_name wl roam_trigger $::roam_trigger_value all" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. 'wl roam_trigger $::roam_trigger_value all' $catch_msg"
				incr ::error_cnt
				error "'wl roam_trigger $::roam_trigger_value all' $catch_msg"
			}
		}

		set ::array_streams_ap(${::curr_test_no}) [lindex $(ap) 0]
		UTF::Message LOG "" "::array_streams_ap(${::curr_test_no})=$::array_streams_ap(${::curr_test_no})"
		
		if {[regexp {/80$} $::roaming_channel]} {
			set ::roaming_cap "80"
		} else {
			if {[regexp {[ul]$} $::roaming_channel]} {
				set ::roaming_cap "40"
			} else {
				set ::roaming_cap "20"
			}
		}

		set tmp_roaming_channel ""
		regsub -all -nocase {\/} $::roaming_channel "_" tmp_roaming_channel

		if {!$(nosmoothroaming)} {

			set ::roaming_test_title "$test_type - Smooth Roaming"
			
			UTF::Try "$::roaming_test_title" {

				set ::failover_test_flag 0

				sts::setup_ap_radio_channel $(roam_src_ap) $::roaming_channel
				sts::setup_ap_radio_channel $(roam_dst_ap) $::roaming_channel

				if {$::roaming_src_ap == "" || $::roaming_dst_ap == ""} {
					UTF::Message ERROR "" "***Failed. setup_ap_radio_channel issue."
					incr ::error_cnt
					error "Setup AP radio failed"
				}

				set ::roaming_src_ap_attn_group [$::roaming_src_ap cget -attngrp]
				set ::roaming_dst_ap_attn_group [$::roaming_dst_ap cget -attngrp]
				UTF::Message LOG "" "::roaming_src_ap_attn_group=$::roaming_src_ap_attn_group ::roaming_dst_ap_attn_group=$::roaming_dst_ap_attn_group"

				if {$::roaming_src_ap_attn_group == "" || $::roaming_dst_ap_attn_group == ""} {
					error "AP attenuation group is missing"
				}

				$::roaming_dst_ap_attn_group attn $::max_attn
				$::roaming_src_ap_attn_group attn 0
				UTF::Sleep 5

				set ::array_streams_ap(${::curr_test_no}) $::roaming_src_ap
				sts::sta_join_ap
				sts::connection_test
				
				if {$::array_sta_softap_flag(${::array_streams_ap_controller(${::curr_test_no})}) == 0} {
					# AP - get macaddr from AP nvram since the UTF config might be missing it
					set ::roaming_src_ap_mac [$::roaming_src_ap nvram get macaddr]
				} else {
					# SoftAP
					set ::roaming_src_ap_mac [$::roaming_src_ap macaddr]
				}
				
				set ::roaming_src_ap_mac [string toupper $::roaming_src_ap_mac]
				UTF::Message INFO "" "INFO: src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac" 

				if {$::roaming_src_ap_mac == ""} {
					UTF::Message ERROR "" "***Failed. ::roaming_src_ap_mac=$::roaming_src_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_src_ap_mac=$::roaming_src_ap_mac. Check config file"
				}

				if {$::array_sta_softap_flag(${::array_streams_ap_controller(${::curr_test_no})}) == 0} {
					# AP - get macaddr from AP nvram since the UTF config might be missing it
					set ::roaming_dst_ap_mac [$::roaming_dst_ap nvram get macaddr]
				} else {
					# SoftAP
					set ::roaming_dst_ap_mac [$::roaming_dst_ap macaddr]
				}
				
				set ::roaming_dst_ap_mac [string toupper $::roaming_dst_ap_mac]
				UTF::Message INFO "" "INFO: dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac"  

				if {$::roaming_dst_ap_mac == ""} {
					UTF::Message ERROR "" "***Failed. ::roaming_dst_ap_mac=$::roaming_dst_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_dst_ap_mac=$::roaming_dst_ap_mac. Check config file"
				}

				if {$::roaming_src_ap_mac == $::roaming_dst_ap_mac} {
					UTF::Message ERROR "" "***Failed. ::roaming_src_ap_mac=::roaming_dst_ap_mac=$::roaming_src_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_src_ap_mac=::roaming_dst_ap_mac=$::roaming_src_ap_mac. Check config file"
				}

				set ::roaming_band [$::roaming_src_ap band $::roaming_channel]
				
				UTF::Message INFO "" "chan=$::roaming_channel band=$::roaming_band cap=$::roaming_cap src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap"
				
				if {$(roam_estimate_attn)} {
					UTF::Message LOG "" "*************************** Estimate Smooth Roaming Attn *****************************"

					if {$::roaming_src_ap_attn != "" || $::roaming_dst_ap_attn != "" || $::roaming_sniffer_start_attn != ""} {
						incr ::error_cnt
						error "ERROR: parameters src_ap_attn, dst_ap_attn, and sniffer_start_attn must be blank when using roam_estimate_attn parameter. Halting tests!"
					}

					set catch_resp [catch "sts::roaming_calculate_attn_values" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}
					
					UTF::Message LOG "" "*********************** Display estimated attenuation vaules ***********************"
					UTF::Message LOG "" "Estimate: Add params -roam_${test_type}\_src_ap\_attn \"$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end\" -roam_${test_type}\_dst_ap\_attn \"$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end\" -roam_${test_type}\_sniffer\_start_attn $::roaming_sniffer_start_attn"
					error "Estimate: Add params -roam_${test_type}\_src_ap\_attn \"$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end\" -roam_${test_type}\_dst_ap\_attn \"$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end\" -roam_${test_type}\_sniffer\_start_attn $::roaming_sniffer_start_attn"					
				} else {
					UTF::Message LOG "" "*************************** Smooth Roaming Test *****************************"
					
					set catch_resp [catch "sts::get_roaming_macid_values" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}
					
					if {$::error_cnt > 0} {
						UTF::Message ERROR "" "***Failed. Roaming failed."
						error "Roaming failed"
					}
					
					set testnum [sts::get_testnum]
					set ::roaming_sniffer_file_name "$testnum.sniffer_$test_type\_$tmp_roaming_channel\_smooth_roaming"
					set catch_resp [catch "sts::roaming_setup_sniffer" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}

					set catch_resp [catch "sts::process_all_tests" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}

					if {$::roamed_flag == 0} {
						incr ::error_cnt
						error "Did not roam"
					}

					if {$::roaming_sniffer_failed_flag == 1} {
						set ::roaming_sniffer_failed_flag 0
						incr ::error_cnt
						error $::roaming_sniffer_failed_msg
					}
				
					# return the test line with graph link
					return "html: $::roaming_html_results"
				}
			}

			if {$::error_cnt == 0 && $(roam_estimate_attn) == 0} {
				sts::get_roaming_time $test_type
			}

			if {$::error_cnt > 0} {
				sts::connection_test
			}
		}

		if {!$(roam_estimate_attn) && !$(nofailoverroaming)} {
			UTF::Message LOG "" "*************************** Failover Roaming Test *****************************"
			set ::failover_test_flag 1

			set ::roaming_test_title "$test_type - Failover Roaming"
			
			UTF::Try "$::roaming_test_title" {

				set testnum [sts::get_testnum]
				set ::roaming_sniffer_file_name "$testnum.sniffer_$test_type\_$tmp_roaming_channel\_failover_roaming"
				sts::roaming_setup_sniffer
			}
		}
	}
}

#################################################################################

proc sts::bt_setup {} {
	# access option array
	upvar {} {}

	if {![regexp -nocase {BT:} $(tests)]} {
		# no BT stream to run for the tests
		return
	}

	UTF::Try "BT Setup" {
	
		UTF::Message INFO "" "************************Func:bt_setup***************************"

		set catch_resp [catch "$(bt_root_sta) rexec applebt --listPairedDevices" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		set paired_bt_dev_type ""
		set paired_bt_mac_id ""

		if {$catch_resp == 0} {
			set lines [split $catch_msg "\n"]

			set paired_bt_dev_type ""
			foreach line $lines {
				UTF::Message LOG "" "line='$line'"

				if {[regexp -nocase {.* Name: +?(.*?)} $line match bt_dev_name]} {
					UTF::Message INFO "" "bt_dev_name=$bt_dev_name"
				}
				if {[regexp -nocase {.* Bluetooth device address: +?([0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})} $line match paired_bt_mac_id]} {
					UTF::Message INFO "" "paired_bt_mac_id=$paired_bt_mac_id"
				}
				if {[regexp -nocase {.* Device Type: +?(.*?)} $line match paired_bt_dev_type]} {
					UTF::Message INFO "" "paired_bt_dev_type=$paired_bt_dev_type"
				}

				if {$paired_bt_dev_type == "Loudspeaker"} {
					UTF::Message INFO "" "Found paired speaker $paired_bt_mac_id"

					# BT Speaker Disconnect
					set catch_resp [catch "$(bt_root_sta) rexec applebt --disconnectAll" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep 1				

					# BT off
					set catch_resp [catch "$(bt_root_sta) rexec applebt --setPowerState 0" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep 3				

					# BT on
					set catch_resp [catch "$(bt_root_sta) rexec applebt --setPowerState 1" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

					# More than 10 sec delay is needed otherwise BT connect will fail
					UTF::Sleep 15				

					# BT Speaker Connect
					set catch_resp [catch "$(bt_root_sta) rexec applebt --connect $paired_bt_mac_id" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

					# BT Paired Devices
					set catch_resp [catch "$(bt_root_sta) rexec applebt --listPairedDevices" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					
					break
				}
			}
		}
		
		if {$paired_bt_dev_type != "Loudspeaker" || $paired_bt_mac_id == ""} {
			incr ::error_cnt
			error "BT Paired Loudspeaker not Found"			
		}

		UTF::Message LOG "" "Check to make sure BT Speaker is connected"

		# BT Connected Devices
		set catch_resp [catch "$(bt_root_sta) rexec applebt --listConnectedDevices" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		set connected_bt_dev_type ""
		set connected_bt_mac_id ""

		if {$catch_resp == 0} {
			set lines [split $catch_msg "\n"]

			set connected_bt_dev_type ""
			foreach line $lines {
				UTF::Message LOG "" "line='$line'"

				if {[regexp -nocase {.* Name: +?(.*?)} $line match bt_dev_name]} {
					UTF::Message INFO "" "bt_dev_name=$bt_dev_name"
				}
				if {[regexp -nocase {.* Bluetooth device address: +?([0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})} $line match connected_bt_mac_id]} {
					UTF::Message INFO "" "connected_bt_mac_id=$connected_bt_mac_id"
				}
				if {[regexp -nocase {.* Device Type: +?(.*?)} $line match connected_bt_dev_type]} {
					UTF::Message INFO "" "connected_bt_dev_type=$connected_bt_dev_type"
				}

				if {$connected_bt_dev_type == "Loudspeaker"} {
					UTF::Message INFO "" "Found connected speaker $connected_bt_mac_id"
					break
				}
			}
		}

		if {$connected_bt_dev_type != "Loudspeaker" || $connected_bt_mac_id == ""} {
			incr ::error_cnt
			error "BT Connected Loudspeaker not Found"			
		}

		if {$paired_bt_mac_id != $connected_bt_mac_id} {
			incr ::error_cnt
			error "BT Paired Loudspeaker $paired_bt_mac_id is not the same as Connected Loudspeaker $connected_bt_mac_id"			
		}
		
		return "BT Loudspeaker $connected_bt_mac_id"
	}
}

proc sts::bt_itune_stop {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:bt_itune_stop***************************"

	set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	set itune_pid ""
	regexp -nocase {PID:\s+(\S+)} $catch_msg - itune_pid
	if {$itune_pid != ""} {
		set catch_resp [catch "$(bt_root_sta) rexec kill -9 $itune_pid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	}

	# 3 sec min delay is needed here for iTume process to stop
	UTF::Sleep 4				

	for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_msg == "Inactive audio"} {
			break
		}
		UTF::Sleep 5				
		UTF::Message LOG "" "retry cnt=$retry_cnt - applebt --isActiveAudioDevice"
	}
	
	if {$catch_msg != "Inactive audio"} {
		incr ::error_cnt
		error "Active BT iTune audio"			
	}
	
	return
}

proc sts::bt_itune_play {} {
	# access option array
	upvar {} {}

	# sometimes the wav file does not start playing, therefore retry is added
	
	for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
	
		sts::bt_itune_stop

		UTF::Message INFO "" "************************Func:bt_itune_play***************************"

		# playFileIniTunes cannot be run as root and it needs to run as 'user'
		set catch_resp [catch {$(bt_user_sta) rpopen applebt --playFileIniTunes $(bt_wav_file)} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set timestamp [clock format [clock seconds] -format "%H:%M:%S"]
		UTF::Message INFO "" "------------------------$timestamp---------------------------"
		set fd $catch_msg
		fconfigure $fd -blocking 0
		fileevent $fd readable {set ::p2p_utils_reading READY}

		# 3 sec min delay is needed here for iTume process to come up
		UTF::Sleep 4				

		for {set retry2_cnt 0} {$retry2_cnt < 5} {incr retry2_cnt} {
			set catch_resp2 [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg2]
			UTF::Message LOG "" "catch_resp2=$catch_resp2 catch_msg2=$catch_msg2 retry2_cnt=$retry2_cnt"
			if {$catch_msg2 != "Inactive audio"} {
				break
			}
			UTF::Message LOG "" "ps -ef | grep playFileIniTunes"
			set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
			UTF::Sleep 4
			
			if {$retry2_cnt == 3} {
				sts::bt_setup
			}
		}

		if {$catch_msg2 == "Inactive audio"} {
			set inactive_audio_flag 1
			continue
		} else {
			set inactive_audio_flag 0
		}

		set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set itune_pid ""
		regexp -nocase {PID:\s+(\S+)} $catch_msg - itune_pid
		if {$itune_pid == ""} {
			incr ::error_cnt
			error "BT iTune PID is not found"			
		}

		UTF::Message LOG "" "ps -ef | grep playFileIniTunes"
		set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
		set catch_resp2 [catch {set fd_pid [pid $fd]} catch_msg2]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg fd_pid=$fd_pid"
		# iTune should be running now. The endpoint fsh command to lunch "rpopen applebt --playFileIniTunes"
		# is not needed to be active, therefore it is killed here
		set catch_resp [catch "exec kill -9 $fd_pid" catch_msg]
		UTF::Message INFO "" "kill catch_msg=$catch_msg"
		UTF::Sleep .1
		set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
		UTF::Message INFO "" "ps -ef catch_msg=$catch_msg"

		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_msg != "Inactive audio"} {
			set inactive_audio_flag 0
			break
		}
		UTF::Sleep 5				
		set inactive_audio_flag 1
		UTF::Message LOG "" "retry cnt=$retry_cnt - applebt --isActiveAudioDevice"
	}
	
	if {$inactive_audio_flag} {
		UTF::Sleep 5				
		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"		
		incr ::error_cnt
		error "Inactive BT iTune audio"			
	}
	
	return 
}

proc sts::bt_start_throughput_measurement {STA stream_no audio_throughput_time} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:bt_start_throughput_measurement $audio_throughput_time***************************"

	set catch_resp [catch {$STA rpopen applebt --A2DPBitRate $audio_throughput_time} catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	set ::array_streams_fd_rx(${::curr_test_no},${stream_no}) $catch_msg
	set ::array_streams_fdname_rx(${::curr_test_no},${stream_no}) "RX_$stream_no"
	fconfigure $::array_streams_fd_rx(${::curr_test_no},${stream_no}) -blocking 0
	fileevent $::array_streams_fd_rx(${::curr_test_no},${stream_no}) readable {set ::p2p_utils_reading READY}

	set ::array_streams_fd_tx(${::curr_test_no},${stream_no}) ""
	set ::array_streams_fdname_tx(${::curr_test_no},${stream_no}) ""
}

#################################################################################

proc sts::run_wl_cmd {STA cmd} {
	#set catch_resp [catch {$STA wl -i $::array_sta_apsta_ifname(${STA}) $cmd} catch_msg]
	set catch_resp [catch {$STA wl $cmd} catch_msg]
	#UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	if {$catch_resp == 1} {
		UTF::Message INFO "" "***Fail. $catch_msg"
		incr ::error_cnt
		error $catch_msg
	}
	
	return $catch_msg
}

proc sts::nan1_extra_setup {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan1_extra_setup***************************"

	set ::error_cnt 0

	UTF::Try "NAN SW Reload" {

		# unload all STAs first
		UTF::Try "Unload STAs" {
			foreach STA $(sta) {
				set catch_resp [catch {$STA rexec rmmod dhd} catch_msg]
			}
			UTF::Sleep 1
		}

		foreach STA $(sta) {
			set paniced_flag 0
			
			UTF::Try "$STA: reload" {
				set catch_resp [catch {$STA rexec insmod /root/dhd.ko} catch_msg]
				UTF::Message LOG "" "1 catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec dhd -i eth0 download /root/rtecdc.bin /root/nvram.txt} catch_msg]
				UTF::Message LOG "" "2 catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec ifconfig eth0 up} catch_msg]
				UTF::Message LOG "" "3 catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec wl clmload 0 /root/rtecdc.clmb} catch_msg]
				UTF::Message LOG "" "4 catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec wl vht_features} catch_msg]
				set catch_resp [catch {$STA rexec wl vht_features 7} catch_msg]
				set catch_resp [catch {$STA rexec wl vht_features} catch_msg]
				set catch_resp [catch {$STA rexec wl bands} catch_msg]
				set catch_resp [catch {$STA rexec wl channels} catch_msg]
				# kevin
				set catch_resp [catch {$STA rexec wl bus:enable_ds_hc 0} catch_msg]

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "NAN Reload" "::UTF::panic=$::panic_msg"
					set paniced_flag 1
				}

				return ""
			}
		}
	}
}

proc sts::nan1_publish_and_subscribe {master_sta non_master_sta sta_subscribe sta_publish} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan1_publish_and_subscribe***************************"

	UTF::Try "NAN Publish and Subscribe" {
		sts::nan1_extra_setup
		sts::setup_nan

		set rc [sts::run_wl_cmd $sta_publish "nan publish 1 name org.wifi.nan.test flags 0x1000"]
		UTF::Sleep 3
		set rc [sts::run_wl_cmd $sta_subscribe "nan subscribe 1 name org.wifi.nan.test"]
		UTF::Sleep 20

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$sta_publish rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$sta_subscribe rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		set rc [sts::run_wl_cmd $sta_publish "nan publish 1"]
		###########################
		# get publisher instance id
		###########################
		set publisher_instance_id ""
		regexp -nocase {Instance ID:(.*?)\n} $rc - publisher_instance_id
		set publisher_instance_id [string trim $publisher_instance_id]
		UTF::Message INFO "" "publisher_instance_id='$publisher_instance_id'"
		###########################
		# get publisher service hash
		###########################
		set publisher_service_hash ""
		regexp -nocase {Service hash:\n(.*?)\n} $rc - publisher_service_hash
		regsub {0000:} $publisher_service_hash {} publisher_service_hash
		set publisher_service_hash [string trim $publisher_service_hash]
		UTF::Message INFO "" "publisher_service_hash='$publisher_service_hash'"

#kevin - temp calls
set rc [sts::run_wl_cmd $sta_subscribe "nan publish_list"]
set rc [sts::run_wl_cmd $sta_subscribe "nan subscribe_list"]
return
		set rc [sts::run_wl_cmd $sta_subscribe "nan disc_results"]

		#set rc "Disc results:\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\n"

		###########################
		# check subscriber instance id
		###########################
		set subscriber_instance_id ""
		regexp -nocase {instance id: (.*?)\npeer} $rc - subscriber_instance_id
		set subscriber_instance_id [string trim $subscriber_instance_id]
		UTF::Message INFO "" "subscriber_instance_id='$subscriber_instance_id'"

		set catch_resp [catch {$sta_publish rexec wl nan status} catch_msg]
		set catch_resp [catch {$sta_subscribe rexec wl nan status} catch_msg]
		set catch_resp [catch {$sta_publish rexec wl nan dump stats} catch_msg]
		set catch_resp [catch {$sta_subscribe rexec wl nan dump stats} catch_msg]

		if {$subscriber_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "subscriber instance id is '$subscriber_instance_id' instead of '0x1'"
			error "Bad subscriber instance id"
		}

		if {$publisher_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "publisher instance id is '$publisher_instance_id' instead of '0x1'"
			error "Bad publisher instance id"
		}
		
		###########################
		# check subscriber peer instance id
		###########################
		set subscriber_peer_instance_id ""
		regexp -nocase {peer instance id: (.*?)\nService hash} $rc - subscriber_peer_instance_id
		set subscriber_peer_instance_id [string trim $subscriber_peer_instance_id]
		UTF::Message INFO "" "subscriber_peer_instance_id='$subscriber_peer_instance_id'"

		if {$subscriber_peer_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "subscriber peer instance id is '$subscriber_peer_instance_id' instead of '0x1'"
			error "Bad subscriber peer instance id"
		}

		###########################
		# check subscriber service hash
		###########################
		set subscriber_service_hash ""
		regexp -nocase {Service hash:\n (.*?)\n} $rc - subscriber_service_hash
		regsub {0000:} $subscriber_service_hash {} subscriber_service_hash
		set subscriber_service_hash [string trim $subscriber_service_hash]
		UTF::Message INFO "" "subscriber_service_hash='$subscriber_service_hash'"

		if {$subscriber_service_hash != $publisher_service_hash} {
			# failed
			UTF::Message INFO "" "Subscriber service hash is '$subscriber_service_hash' instead of '$publisher_service_hash'"
			error "Bad subscriber service hash"
		}
		
		###########################
		# check subscriber peer mac
		###########################
		set subscriber_peer_mac ""
		# peer mac is STA mac address of STA publish ($sta_publish in this case)
		regexp -nocase {.*peer mac: (.*)\n} $rc - subscriber_peer_mac
		set subscriber_peer_mac [string trim $subscriber_peer_mac]
		set subscriber_peer_mac [string toupper $subscriber_peer_mac]
		UTF::Message INFO "" "subscriber_peer_mac='$subscriber_peer_mac'"

		if {$subscriber_peer_mac != $::array_sta_apsta_macaddr(${sta_publish})} {
			# failed
			UTF::Message INFO "" "Subscriber peer mac address is '$subscriber_peer_mac' instead of '$::array_sta_apsta_macaddr(${sta_publish})'"
			error "Bad subscriber peer mac address"
		}
	}
}

proc sts::nan1_check_dwskips_value {msg expected_dwskips_value} {

	if {$expected_dwskips_value == 0} {
		UTF::Message INFO "" "========================check dwskips is 0==========================="
	} else {
		UTF::Message INFO "" "========================check dwskips is less than $expected_dwskips_value==========================="
	}

	set dwskips_value [sts::nan1_get_dwskips $msg]

	if {$expected_dwskips_value == 0 && $dwskips_value > 0} {
		# failed
		UTF::Message ERROR "" "dwskips is $dwskips_value instead of 0"
		error "dwskips is not zero"
	}

	if {$dwskips_value > $expected_dwskips_value} {
		# failed
		UTF::Message ERROR "" "dwskips $dwskips_value is more than $expected_dwskips_value"
		error "dwskips is high $dwskips_value"
	}
}

proc sts::nan1_sta_infra_scan {STA sta_role_anchor_master_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan1_sta_infra_scan $STA $sta_role_anchor_master_flag***************************"

	if {$sta_role_anchor_master_flag} {
		set role_name "Anchor-Master"
	} else {
		set role_name "Non-Master"
	}

	UTF::Try "NAN $role_name STA Infra Scan" {

		sts::setup_ap_radio_channel $::array_streams_ap(${::curr_test_no}) $::array_streams_apsta_link_chan(${::curr_test_no})
		set catch_resp [catch {$STA rexec wl assoc} catch_msg]

		if {$::array_streams_ap(${::curr_test_no}) == ""} {
			# failed
			incr ::error_cnt
			error "No AP found"
		}

		set catch_resp [catch "$::array_streams_ap(${::curr_test_no}) wl ssid" ap_ssid]
		set catch_resp [catch "$::array_streams_ap(${::curr_test_no}) wl bssid" ap_bssid]
		set ap_bssid [string toupper $ap_bssid]
		UTF::Message INFO "" "ap_ssid='$ap_ssid'"
		UTF::Message INFO "" "ap_bssid='$ap_bssid'"
		
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		
		# retry is needed for "wl scan" since sometimes it give "Not Ready"
		for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
			set catch_resp [catch {$STA rexec wl scan} catch_msg]
			if {$catch_resp == 0} {
				break
			} else {
				# scan failed
				UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
			}
		}

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Scan Failed. $catch_msg."
			error "Scan Failed. $catch_msg"
		}
		
		UTF::Sleep 12
		set catch_resp [catch {$STA rexec wl scanresults} catch_msg]
		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl scanresults | grep SSID} sta_scan_ssid]
		set all_sta_ssids [split $sta_scan_ssid "\n"]
		UTF::Message INFO "" "all_sta_ssids='$all_sta_ssids'"

		set pass_ssid_flag 0
		foreach sta_ssid $all_sta_ssids {
			regexp {SSID: \"(\S+)\"} $sta_ssid match sta_ssid
			if {$sta_ssid == $ap_ssid} {
				UTF::Message INFO "" "sta_ssid $sta_ssid = ap_ssid $ap_ssid"
				set pass_ssid_flag 1
				break
			}
		}

		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl scanresults | grep BSSID} sta_scan_bssid]
		set all_sta_bssids [split $sta_scan_bssid "\n"]
		UTF::Message INFO "" "all_sta_bssids='$all_sta_bssids'"

		set pass_bssid_flag 0
		foreach sta_bssid $all_sta_bssids {
			set sta_bssid [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $sta_bssid]
			set sta_bssid [string toupper $sta_bssid]
			if {$sta_bssid == $ap_bssid} {
				UTF::Message INFO "" "sta_bssid $sta_bssid = ap_bssid $ap_bssid"
				set pass_bssid_flag 1
				break
			}
		}

		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set catch_resp [catch {$STA rexec wl scan DUMMY} catch_msg]
		set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]

		if {$pass_ssid_flag == 0 || $pass_bssid_flag == 0} {
			# failed
			UTF::Message ERROR "" "AP SSID $ap_ssid $ap_bssid did not match any STA scan SSID"
			error "Scan Failed"
		}
		
		set msg_dump_status [sts::run_wl_cmd $STA "nan status"]		
		sts::nan1_check_role $msg_dump_status $sta_role_anchor_master_flag
		set catch_resp [catch {$STA rexec wl nan dump stats} msg_dump_stats]
		sts::nan1_check_dwskips_value $msg_dump_stats 0
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	}	
}

proc sts::nan1_sta_infra_assoc {STA sta_role_anchor_master_flag ap_chan} {
	# access option array
	upvar {} {}

	if {$sta_role_anchor_master_flag} {
		set role_name "Anchor-Master"
	} else {
		set role_name "Non-Master"
	}
	
	UTF::Try "NAN $role_name + STA $STA Assoc Infra chan $ap_chan" {
		UTF::Message INFO "" "************************Func:nan1_sta_infra_assoc $STA $sta_role_anchor_master_flag $ap_chan***************************"

		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		sts::setup_ap_radio_channel $::array_streams_ap(${::curr_test_no}) $::array_streams_apsta_link_chan(${::curr_test_no})
		UTF::Message INFO "" "\n\nIf ConnectAPSTA fails with wpa_state=SCANNING instead of wpa_state=ASSOCIATING, it means the STA does not see the AP and it is a NAN FW issue\n\n"
		set catch_resp [catch "UTF::Test::ConnectAPSTA $::array_streams_ap(${::curr_test_no}) $STA" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			error $catch_msg
		}
		
		UTF::Message INFO "" "20 sec delay after assoc is mandatory to sync with AM"
		UTF::Sleep 20

		sts::nan1_check_sta_infra_assoc_chan $STA $::array_streams_apsta_link_chan(${::curr_test_no})

		set msg_dump_status [sts::run_wl_cmd $STA "nan status"]		
		sts::nan1_check_role $msg_dump_status $sta_role_anchor_master_flag
		set catch_resp [catch {$STA rexec wl nan dump stats} msg_dump_stats]
		sts::nan1_check_dwskips_value $msg_dump_stats 20
	}
	
	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Asoc" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	}	
}

proc sts::nan1_get_dwskips {msg} {
	#set rc "DWSlots: 262 	DiscBcnSlots: 944	AnchorMasterRecExp: 0	BcnTpltUpd: 14\nBcnTx : 1206	SyncBcnTx: 262	DiscBcnTx: 944	BcnRx: 16	SDFTx: 0	SDFRx: 0\nAnchorMaster: 1	Master: 0	NonMasterSync: 0	NonMasterNonSync: 0\nUnschTx: 0	BcnTxErr: 0	SyncBcnTxMiss: 0	SyncBcnTxtimeErr: 0\nMschRegErr: 0	WrongChCB: 0	DWEarlyCB: 128	DWLateCB: 0	DWSkips: 19	DiscBcnSkips: 494\nMrgScan: 10	MrgScanRej: 9	JoinScanRej: 0	ScanRes: 0	NanEnab: 1	NanDisab: 0\n"
	set dwskips_value [regexp -inline {DWSkips:\s+(\d+)\s+DiscBcnSkips} $msg]
	UTF::Message INFO "" "dwskips_value=$dwskips_value"
	regexp -nocase {\{DWSkips:\s+(\d+)\s+DiscBcnSkips\}} $dwskips_value - dwskips_value
	UTF::Message INFO "" "dwskips_value=$dwskips_value"
	return $dwskips_value
}

proc sts::nan1_check_role {msg sta_role_anchor_master_flag} {

	set role_failed_flag 0

	set role [regexp -inline {role [0-9]:} $msg]
	regexp -nocase {\{role (\d+):\}} $role - role

	if {$sta_role_anchor_master_flag} {
		if {$role != 4} {
			set role_failed_flag 1
		}
	} else {
		if {$role != "1" && $role != "2" && $role != "3"} {
			set role_failed_flag 1
		}
	}

	UTF::Message INFO "" "role=$role"

	if {$role_failed_flag} {
		# failed
		if {$sta_role_anchor_master_flag} {
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			error "Bad Anchor-Master Role"
		} else {
			UTF::Message INFO "" "Role is '$role' instead of '1' for 'non-master-non-sync', '2' for 'non-master-sync',  or '3' for 'master'"
			error "Bad Non Master Role"
		}
	} else {
		return 0
	}
}

proc sts::nan1_check_amr {msg amr_val} {
	# amr is STA mac address plus ":xx:xx"
	set amr ""
	regexp -nocase {amr:\n(.*)\n.*hop_count:} $msg - amr
	if {$amr == ""} {
		UTF::Message INFO "" "msg='$msg'"
	}
	UTF::Message INFO "" "amr='$amr'"
	regexp -nocase {:(.*)} $amr - amr
	set amr [string trim $amr]
	regsub -all { } $amr ":" amr
	# remove the end ":xx:xx"
	set amr [string replace $amr 17 end ""]
	UTF::Message INFO "" "amr=$amr"

	if {$amr != $amr_val} {
		# failed
		UTF::Message INFO "" "amr is '$amr' instead of '$amr_val'"
		error "Bad amr"
	} else {
		return 0
	}
}

proc sts::nan1_check_sta_infra_assoc_chan {sta sta_expected_chan} {
# kevin
	set catch_resp [catch {$sta wl channel} catch_msg]
	set catch_resp [catch {$sta wl chanspec} catch_msg]
	set catch_resp [catch {$sta wl status} catch_msg]
	set sta_chan ""
	regexp {Channel: (\S+)} $catch_msg match sta_chan
	UTF::Message INFO "" "sta_chan=$sta_chan"
	if {$sta_expected_chan != $sta_chan} {
		UTF::Message ERROR "" "***Fail. $::array_streams_dst_display_str(${::curr_test_no},${::curr_stream_no}) chan is $sta_chan instead of $sta_expected_chan."
		error "Bad STA Channel"
	} else {
		return ""
	}
}

proc sts::nan1_cluster_merge {master_sta non_master_sta merge_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN Cluster Merge" {
		UTF::Message INFO "" "************************Func:nan1_cluster_merge***************************"

		# 3 STAs needed
		set nan_sta_cnt [llength $(sta)]
		if {$nan_sta_cnt != 3} {
			UTF::Message INFO "" "NAN Cluster Merge requires 3 STAs instead of '$(sta)'"
			error "NAN Cluster Merge requires 3 STAs instead of '$(sta)'" 
		}

		sts::nan1_extra_setup
		sts::setup_nan

		set apsta_link_chan $::array_streams_apsta_link_chan(${::curr_test_no})
		set nan_link_chan $::array_streams_sts_link_chan(${::curr_test_no})

		# remove the 'l','u', and '/80' to get the control channel

		set apsta_control_chan [regexp -inline {\d+} $apsta_link_chan]
		UTF::Message INFO "" "::array_streams_apsta_link_chan(${::curr_test_no})='$::array_streams_apsta_link_chan(${::curr_test_no})' -> apsta_control_chan='$apsta_control_chan'"

		if {$apsta_control_chan == ""} {
			# Workaround:
			# For NAN Only (no AP), there should be only 2.4G social channel but that does not work and
			# as a workaround 5G dummy channel 149 is also added instead of 0.
			set apsta_control_chan "149"
			UTF::Message INFO "" "Blank apsta_control_chan is replaced with '$apsta_control_chan'"
		}

		set nan_control_chan [regexp -inline {\d+} $nan_link_chan]
		UTF::Message INFO "" "::array_streams_sts_link_chan(${::curr_test_no})='$::array_streams_sts_link_chan(${::curr_test_no})' -> nan_control_chan='$nan_control_chan'"

		set nan_soc_chans "$nan_control_chan $apsta_control_chan"

		# nan_link_chanspec -> nan_control_chan/bandwidth
		set nan_link_chanspec "$nan_control_chan/20"

		sts::setup_nan_merge $merge_sta $nan_soc_chans $nan_link_chanspec
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		#error "Halting tests!"
	}
}

proc sts::nan1_infra_scan {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN Infra Scan" {
		UTF::Message INFO "" "************************Func:nan1_infra_scan***************************"

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_scan $master_sta 1
		sts::nan1_sta_infra_scan $non_master_sta 0
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	}	
}

proc sts::nan1_infra_assoc {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra" {
		UTF::Message INFO "" "************************Func:nan1_infra_assoc***************************"

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $master_sta 1 6
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $master_sta 1 11
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $master_sta 1 44
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $master_sta 1 36
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $non_master_sta 0 6
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $non_master_sta 0 11
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $non_master_sta 0 44
		UTF::Try "Check AM $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $non_master_sta 0 36
		UTF::Try "Check AM $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	#if {$::error_cnt > 0} {
	#	error "Halting tests!"
	#}	
}

proc sts::nan1_sta_infra_assoc_ping_scan {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Ping Scan" {
		UTF::Message INFO "" "************************Func:nan1_sta_infra_assoc_ping_scan***************************"

		sts::nan1_extra_setup
		sts::setup_nan

		sts::nan1_sta_infra_assoc $master_sta 1 44
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		sts::nan1_extra_setup
		sts::setup_nan
		sts::nan1_sta_infra_assoc $non_master_sta 0 11
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}

		catch {unset array_ping_pid}
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Start STA $STA Ping------------------------"
			UTF::Message INFO "" "$STA rpopen ping $::array_streams_ap_controller_ip(${::curr_test_no})"  
			set fd_tx [$STA rpopen ping $::array_streams_ap_controller_ip(${::curr_test_no})]
			set catch_resp [catch {set array_ping_pid(${STA}) [pid $fd_tx]} catch_msg]
			fconfigure $fd_tx -blocking 0
			fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		}

		sts::nan1_sta_infra_scan $master_sta 1
		sts::nan1_sta_infra_scan $non_master_sta 0

		# validate Role
		set msg_master_status [sts::run_wl_cmd $master_sta "nan status"]		
		set msg_non_master_status [sts::run_wl_cmd $non_master_sta "nan status"]
		sts::nan1_check_role $msg_master_status 1
		sts::nan1_check_role $msg_non_master_status 0
		# validate AMR
		sts::nan1_check_amr $msg_non_master_status $::array_sta_sts_macaddr(${master_sta})
		
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Stop STA $STA Ping------------------------"
			UTF::Message INFO "" "exec kill -9 $array_ping_pid(${STA})"  
			set catch_resp [catch "exec kill -9 $array_ping_pid(${STA})" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		}
		catch {unset array_ping_pid}
		
		return ""
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	} else {
		return ""
	}
}

proc sts::nan1_infra_assoc_roam {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Roam" {
		UTF::Message INFO "" "************************Func:nan1_infra_assoc_roam***************************"

		sts::nan1_extra_setup
		sts::setup_nan

		set ::array_streams_apsta_link_chan(${::curr_test_no}) 36l
		sts::nan1_sta_infra_assoc $master_sta 1 11
		sts::nan1_sta_infra_assoc $non_master_sta 0 11
		
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}

		# change the AP channel
		set ::array_streams_apsta_link_chan(${::curr_test_no}) 1
		sts::setup_ap_radio_channel $::array_streams_ap(${::curr_test_no}) $::array_streams_apsta_link_chan(${::curr_test_no})
		UTF::Sleep 5
		
		UTF::Try "Validate STA Channel $::array_streams_apsta_link_chan(${::curr_test_no})" {
			sts::nan1_check_sta_infra_assoc_chan $master_sta $::array_streams_apsta_link_chan(${::curr_test_no})
			sts::nan1_check_sta_infra_assoc_chan $non_master_sta $::array_streams_apsta_link_chan(${::curr_test_no})
		}
		
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 1
			return ""
		}
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [sts::run_wl_cmd $non_master_sta "nan status"]		
			sts::nan1_check_role $msg_dump_status 0
			return ""
		}
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	}	
}

proc sts::nan1_sta_infra_assoc_role_change {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Role Change" {
		UTF::Message INFO "" "************************Func:nan1_sta_infra_assoc_role_change***************************"

		sts::nan1_extra_setup
		sts::setup_nan

		sts::nan1_sta_infra_assoc $master_sta 1 44
		sts::nan1_sta_infra_assoc $non_master_sta 0 44
		
		catch {unset array_ping_pid}
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Start STA $STA Ping------------------------"
			UTF::Message INFO "" "$STA rpopen ping $::array_streams_ap_controller_ip(${::curr_test_no})"  
			set fd_tx [$STA rpopen ping $::array_streams_ap_controller_ip(${::curr_test_no})]
			set catch_resp [catch {set array_ping_pid(${STA}) [pid $fd_tx]} catch_msg]
			fconfigure $fd_tx -blocking 0
			fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		}

		sts::nan1_sta_infra_scan $master_sta 1
		sts::nan1_sta_infra_scan $non_master_sta 0

		# validate Role
		set msg_master_status [sts::run_wl_cmd $master_sta "nan status"]		
		set msg_non_master_status [sts::run_wl_cmd $non_master_sta "nan status"]
		sts::nan1_check_role $msg_master_status 1
		sts::nan1_check_role $msg_non_master_status 0
		# validate AMR
		sts::nan1_check_amr $msg_non_master_status $::array_sta_sts_macaddr(${master_sta})
		
		UTF::Message INFO "" "change role: non-master to master"
		set rc [sts::run_wl_cmd $non_master_sta "nan election_metrics 20 200"]
		UTF::Message INFO "" "20 sec delay is mandatory to sync"
		UTF::Sleep 20

		set catch_resp [catch {$master_sta rexec wl nan dump rssi} catch_msg]
		set catch_resp [catch {$non_master_sta rexec wl nan dump rssi} catch_msg]

		# validate Role
		set msg_master_status [sts::run_wl_cmd $non_master_sta "nan status"]
		set msg_non_master_status [sts::run_wl_cmd $master_sta "nan status"]
		sts::nan1_check_role $msg_master_status 1
		sts::nan1_check_role $msg_non_master_status 0
		
#kevin fix		
		# validate AMR
		sts::nan1_check_amr $msg_non_master_status $::array_sta_sts_macaddr(${master_sta})
		
		
		
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Stop STA $STA Ping------------------------"
			UTF::Message INFO "" "exec kill -9 $array_ping_pid(${STA})"  
			set catch_resp [catch "exec kill -9 $array_ping_pid(${STA})" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		}
		catch {unset array_ping_pid}
		
		return ""
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		#error "Halting tests!"
	} else {
		return ""
	}
}

proc sts::nan1_setup_again {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan1_setup_again***************************"

	UTF::Try "NAN Setup Again" {
		sts::nan1_extra_setup
		sts::setup_nan
	}
}

proc sts::run_nan1_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_nan1_test***************************"

	set ::curr_test_no 1

	for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${::curr_test_no})} {incr stream_no} {

		if {$::array_streams_traffic_direction(${::curr_test_no},${stream_no}) == "BITX"} {
			# only BIRX needs to be processed
			continue
		}

		if {$::array_streams_link_type(${::curr_test_no},${stream_no}) == "NANDP"} {
			break
		}
	}
	
	if {$stream_no > $::array_streams_cnt(${::curr_test_no})} {
		# failed
		UTF::Message INFO "" "NAN stream is not found"
		incr ::error_cnt
		error "NAN stream is not found"
	}

	set ::curr_stream_no $stream_no

	UTF::Message INFO "" "::array_streams_ap_controller(${::curr_test_no})='$::array_streams_ap_controller(${::curr_test_no})' ::array_streams_ap(${::curr_test_no})='$::array_streams_ap(${::curr_test_no})' ::curr_stream_no='$::curr_stream_no'"
	
	set STA1 [lindex "$(sta)" 0]
	set STA2 [lindex "$(sta)" 1]
	set STA3 [lindex "$(sta)" 2]

	set rc [sts::nan1_cluster_merge $STA1 $STA2 $STA3]
	set rc [sts::nan1_publish_and_subscribe $STA1 $STA2 $STA1 $STA2]
	set rc [sts::nan1_infra_scan $STA1 $STA2]
	set rc [sts::nan1_infra_assoc $STA1 $STA2]	
	set rc [sts::nan1_sta_infra_assoc_ping_scan $STA1 $STA2]
	set rc [sts::nan1_infra_assoc_roam $STA1 $STA2]
	set rc [sts::nan1_sta_infra_assoc_role_change $STA1 $STA2]
}

proc sts::run_aibss_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_aibss_test***************************"

	#####################################################################################################################

	foreach STA $(sta) {	

		UTF::Try "$STA: AIBSS Setup Chan $::array_streams_sts_link_chan(${::curr_test_no})" {
			UTF::Message INFO "" "macaddr=$::array_sta_apsta_macaddr(${STA})"
			UTF::Message INFO "" "APSTA ipaddr=$::array_sta_apsta_ip(${STA})"
			set catch_resp [catch {$STA rexec dmesg -C} catch_msg]
			set rc [sts::run_wl_cmd $STA "down"]
			UTF::Sleep .5
			set rc [sts::run_wl_cmd $STA "aibss 1"]
			UTF::Sleep .5
			set rc [sts::run_wl_cmd $STA "PM $(pm_mode)"]
			set rc [sts::run_wl_cmd $STA "atim 10"]
			set rc [sts::run_wl_cmd $STA "aibss_ps 1"]
			set rc [sts::run_wl_cmd $STA "chanspec $::array_streams_sts_link_chan(${::curr_test_no})"]
			set rc [sts::run_wl_cmd $STA "aibss_bcn_force_config 500,5000,5000"]
			set rc [sts::run_wl_cmd $STA "scansuppress 0"]
			set rc [sts::run_wl_cmd $STA "up"]
			UTF::Sleep 1
			set desired_bssid [string replace $::array_sta_apsta_macaddr(${STA}) 0 1 "02"]
			set rc [sts::run_wl_cmd $STA "desired_bssid $desired_bssid"]
			set rc [sts::run_wl_cmd $STA "join UTFOxygenSetup imode ibss"]
			UTF::Sleep 1
			$STA rexec ifconfig $::array_sta_apsta_ifname(${STA}) $::array_sta_apsta_ip(${STA}) up
			UTF::Sleep 1

			UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
			set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
			UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

			# Note after loading firmware and executing aibss activation commands DUT will not go to sleep for 25 sec (by design)
			UTF::Sleep 25

			set rc1 [sts::run_wl_cmd $STA "pm_dur"]
			UTF::Sleep 2
			set rc2 [sts::run_wl_cmd $STA "pm_dur"]
			regexp -nocase {([\.\d]+)\s*} $rc1 - rc1
			regexp -nocase {([\.\d]+)\s*} $rc2 - rc2

			set ps_sleep_duration [expr $rc2 - $rc1]
			UTF::Message LOG "" "ps_sleep_duration=$ps_sleep_duration ms"

			# Confirm STA chanspec
			set temp [$STA wl -i $::array_sta_apsta_ifname(${STA}) chanspec]
			regexp {(\S+) } $temp match joined_chan

			if {$::array_streams_sts_link_chan(${::curr_test_no}) != $joined_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "AIBSS joined chan is $joined_chan instead of $::array_streams_sts_link_chan(${::curr_test_no})" 
			}

			set ::array_sta_apsta_active_flag(${STA}) 1
			set ::array_sta_apsta_disassociated_flag(${STA}) 0

			###########################
			# check PS sleep duration at the end since we want to continue the test
			###########################
			if {$ps_sleep_duration < 1300 && $(pm_mode) == 1} {
				# failed
				UTF::Message INFO "" "PS sleep duration '$ps_sleep_duration' is lower than 1.5 sec"
				error "Low PS sleep duration"
			}
			
			return ""
		}
	}	
}

proc sts::run_11mc_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_11mc_test***************************"

	UTF::Try "11mc AP-STA Test" {

		UTF::Message INFO "" "================================================================="
		# 1st STA is the Target (AP)
		set AP [lindex "$(sta)" 0]
		UTF::Message INFO "" "Target (AP) $AP"

		set rc [sts::run_wl_cmd $AP "country US/0"]
		UTF::Sleep 1				
		set rc [sts::run_wl_cmd $AP "ap 1"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $AP "vht_features 3"]
		UTF::Sleep 1				
		set rc [sts::run_wl_cmd $AP "chanspec $(ap_chan)"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $AP "up"]
		UTF::Sleep 1
		$AP rexec ifconfig $::array_sta_apsta_ifname(${AP}) $::array_sta_apsta_ip(${AP}) up
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $AP "ssid ssid_11mc"]
		UTF::Sleep 1
		set catch_resp [catch {$AP rexec dmesg -C} catch_msg]
		set rc [sts::run_wl_cmd $AP "proxd ftm enable"]
		UTF::Sleep 1
		set catch_resp [catch {$AP rexec dhd -i eth0 dconpoll 1} catch_msg]
		UTF::Sleep 1
		$AP rexec ifconfig
		set rc [sts::run_wl_cmd $AP "assoc"]
		set ap_bssid [sts::run_wl_cmd $AP "bssid"]
		set ap_bssid [string toupper $ap_bssid]
		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$AP rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		UTF::Message INFO "" "================================================================="
		# 2nd STA is the Initiator (STA)
		set STA [lindex "$(sta)" 1]
		UTF::Message INFO "" "Initiator (STA) Setup"

		set rc [sts::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "mpc 0"]
		UTF::Sleep 1
		set rc [sts::run_wl_cmd $STA "chanspec $(ap_chan)"]
		UTF::Sleep 1
		$STA rexec ifconfig $::array_sta_apsta_ifname(${STA}) $::array_sta_apsta_ip(${STA}) up
		UTF::Sleep 1
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]
		set rc [sts::run_wl_cmd $STA "proxd ftm enable"]
		UTF::Sleep 1
		$STA rexec ifconfig

		set avg_dist_list ""

		for {set loop_cnt 1} {$loop_cnt <= 10} {incr loop_cnt} {
			UTF::Message INFO "" "========================================loop_cnt=$loop_cnt========================================"
			set error_flag 0

			set catch_resp [catch {sts::run_wl_cmd $STA "proxd ftm 1 delete"} catch_msg]
			UTF::Sleep 1
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 config options +initiator"]
			UTF::Sleep 1
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 config chanspec $(ap_chan)"]
			UTF::Sleep 1
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 config peer $ap_bssid"]
			UTF::Sleep 1
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 info"]
			UTF::Sleep 1
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 start"]
			UTF::Sleep 3
			set rc [sts::run_wl_cmd $STA "proxd ftm 1 result"]

			#set rc "> rtt result:\n>	sessionId=1, flags=0x0008\(''\), peer=00:10:18:EE:E7:FC\n>	session state=9\(ended\), status=0\(OK\)\n>	burst_duration: 10525us\n>	avg_dist=8.6875m, burst_num=1, valid_measure_cnt=5 num_ftm=6\n>	avg_rtt sample: rssi=-48 rtt=33894ns std_deviation =9.9 ratespec=0x02030010\n"

			set status [regexp -inline {status=[-+]?\d+.*burst_duration} $rc]
			UTF::Message INFO "" "status=$status"
			regexp -nocase {\{status=([-+]?\d+).*burst_duration\}} $status - status
			UTF::Message INFO "" "status=$status"

			if {$status != "0"} {
				# failed
				set status [regexp -inline {status=[-+]?\d+} $rc]
				regexp -nocase {\{status=([-+]?\d+)\}} $status - status
				UTF::Message INFO "" "Status is '$status' instead of '0'"
#				incr ::error_cnt
#				error "Bad Status"
				set error_flag 1
			}

			set avg_dist [regexp -inline {avg_dist=[-+]?[0-9]*\.?[0-9]+m, burst_num} $rc]
			UTF::Message INFO "" "avg_dist=$avg_dist"
			regexp -nocase {\{avg_dist=([-+]?[0-9]*\.?[0-9]+)m, burst_num\}} $avg_dist - avg_dist
			UTF::Message INFO "" "avg_dist=$avg_dist"

			if {$avg_dist < 0 || $avg_dist > 10} {
				# failed
				set status [regexp -inline {status=[0-9]} $rc]
				regexp -nocase {\{status=(\d+)\}} $status - status
				UTF::Message INFO "" "Average Distance '$avg_dist' is not between 0 to 10 meter"
#				incr ::error_cnt
#				error "Bad Average Distance"
				set error_flag 1
			}

			if {$error_flag == 0} {
				lappend avg_dist_list $avg_dist
			}
			
			UTF::Sleep 5
		}

		UTF::Message INFO "" "=================================================================================================="

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
	
		UTF::Message INFO "" "avg_dist_list='$avg_dist_list'"
		if {$avg_dist_list == ""} {
			error "No valid average distance value"
		}
		
		set keys "$::array_streams_control_chart_base_key(${::curr_test_no}) 11mc AP-STA Average Distance"
		set html_results [sts::control_chart "" $avg_dist_list $keys "Average Distance" "m" 0]

		if {$error_flag} {
			error "html: $html_results"
		} else {
			return "html: $html_results"
		}
	}

	#####################################################################################################################
}

proc sts::setup_tests_controller {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_controller***************************"

	set err_msg ""
	
	UTF::Try "Controller '$::controller'" {
		UTF::Message INFO "" "------------------------------------------------------------------------------------"
		UTF::Message INFO "" "Setup Controller '$::controller' array: array_setup_sta_data"
		UTF::Message INFO "" "------------------------------------------------------------------------------------"

		set controller_host_type [$::controller hostis]
		set controller_iperf_tcpwin [$::controller cget -tcpwindow]
		# '-lan_ip' gives you the corp ip address
		set controller_lan_ip [$::controller cget -lan_ip]
		# '-ipaddr' gives you the 192 ip address
		set controller_ip [$::controller cget -ipaddr]
		set controller_stas [$::controller cget -sta]
		set controller_ifname [lindex $controller_stas 1]
		set controller_macaddr [string toupper [$::controller macaddr]]
		set controller_ipv6_macaddr ""
		set catch_resp [catch {regexp {inet6\s+(\S+)} [$::controller rexec ifconfig $controller_ifname] match controller_ipv6_macaddr} catch_msg]
		if {$catch_resp != 0} {
			$::controller rexec ifconfig -a
			incr ::error_cnt
			set err_msg "'$catch_msg' (check UTF config for '$controller' interface '$controller_ifname'). Halting tests!"
			error $err_msg 
		}

		UTF::Message INFO "" "create Controller '$::controller' data arrays"
		sts::array_setup_sta_data $::controller 0 1 0
		append ::array_sta_controller_list "$::controller "
		set ::array_sta_controller_flag(${::controller}) "1"
		set ::array_sta_host_type(${::controller}) $controller_host_type
		set ::array_sta_lan_ip(${::controller}) $controller_lan_ip
		set ::array_sta_ifname(${::controller}) $controller_ifname
		set ::array_sta_ip(${::controller}) $controller_ip
		set ::array_sta_macaddr(${::controller}) $controller_macaddr
		set ::array_sta_macaddr(${::controller}) [string toupper $::array_sta_macaddr(${::controller})]
		set ::array_sta_ipv6_macaddr(${::controller}) $controller_ipv6_macaddr
		# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
		set ::array_sta_iperf_tcpwin(${::controller}) $controller_iperf_tcpwin

		UTF::Message INFO "" "print Controller '$::controller' data arrays"
		sts::array_setup_sta_data $::controller 0 0 1

		UTF::Message INFO "" "-------------------Controller=$::controller-----------------------"
		catch {$::controller rexec ifconfig -a}
		UTF::Message INFO "" "----------------------------------------------------------------------"
		
		set ::array_sta_controller_list [string trim $::array_sta_controller_list]	
		
		return ""
	}

	if {$err_msg != ""} {
		error $err_msg 
	}
}

proc sts::setup_tests_ap {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_ap***************************"

	set err_msg ""
	
	UTF::Message INFO "" "------------------------------------------------------------------------------------"
	UTF::Message INFO "" "Setup AP Controller array: array_setup_sta_data"
	UTF::Message INFO "" "------------------------------------------------------------------------------------"

	if {$(ap) != ""} {

		set ap_cnt 0
		foreach ap $(ap) {

			incr ap_cnt

			# check for 2g:5g param
			set ap2g [split $ap ":"]
			set ap2g [lindex $ap2g 0]

			set ap_host_type [$ap2g hostis]

			if {$ap_host_type == "Router"} {		
				UTF::Message INFO "" "$ap: Real AP Mode"
				set soft_ap_flag 0
				set disp_str "AP"
				set ap_controller [$ap2g cget -lanpeer]
			} else {
				UTF::Message INFO "" "$ap: SoftAP Mode"
				set soft_ap_flag 1
				set disp_str "SoftAP"
				# SoftAP controller is the same as SoftAP machine
				set ap_controller $ap
			}

			UTF::Try "$disp_str $ap_cnt: $ap" {
				set ap_controller_host_type [$ap_controller hostis]
				set ap_controller_iperf_tcpwin [$ap_controller cget -tcpwindow]
				# '-lan_ip' gives you the corp ip address
				set ap_controller_lan_ip [$ap_controller cget -lan_ip]
				# '-ipaddr' gives you the 192 ip address
				set ap_controller_apsta_ip [$ap_controller cget -ipaddr]
				set ap_controller_stas [$ap_controller cget -sta]
				set ap_controller_apsta_ifname [lindex $ap_controller_stas 1]
				set ap_controller_apsta_macaddr [$ap_controller macaddr]
				# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
				set ap_controller_apsta_ipv6_macaddr ""
				set catch_resp [catch {regexp {inet6\s+(\S+)} [$ap_controller rexec ifconfig $ap_controller_apsta_ifname] match ap_controller_apsta_ipv6_macaddr} catch_msg]
				if {$catch_resp != 0} {
					$ap_controller rexec ifconfig -a
					incr ::error_cnt
					set err_msg "'$catch_msg' (check UTF config for '$ap_controller' interface '$ap_controller_apsta_ifname'). Halting tests!"
					error $err_msg 
				}

				UTF::Message INFO "" "create AP ap_controller=$ap_controller data arrays"
				sts::array_setup_sta_data $ap_controller 0 1 0
				append ::array_sta_ap_list "$ap_controller "
				if {$soft_ap_flag} {
					set ::array_sta_softap_flag(${ap_controller}) "1"
				} else {
					set ::array_sta_ap_flag(${ap_controller}) "1"
				}
				set ::array_sta_host_type(${ap_controller}) $ap_controller_host_type
				set ::array_sta_iperf_tcpwin(${ap_controller}) $ap_controller_iperf_tcpwin
				set ::array_sta_lan_ip(${ap_controller}) $ap_controller_lan_ip
				set ::array_sta_apsta_ifname(${ap_controller}) $ap_controller_apsta_ifname
				set ::array_sta_apsta_ip(${ap_controller}) $ap_controller_apsta_ip
				# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
				set ::array_sta_apsta_macaddr(${ap_controller}) $ap_controller_apsta_macaddr
				set ::array_sta_apsta_ipv6_macaddr(${ap_controller}) $ap_controller_apsta_ipv6_macaddr

				UTF::Message INFO "" "print AP ap_controller=$ap_controller data arrays"
				sts::array_setup_sta_data $ap_controller 0 0 1

				if {$::array_sta_softap_flag(${ap_controller})} {		
					UTF::Message INFO "" "-------------------SoftAP Controller=$ap_controller-----------------------"
					catch {$ap_controller rexec ifconfig -a}
					UTF::Message INFO "" "----------------------------------------------------------------------"
				} else {
					UTF::Message INFO "" "-------------------AP Controller=$ap_controller-----------------------"
					catch {$ap_controller rexec ifconfig -a}
					UTF::Message INFO "" "----------------------------------------------------------------------"
				}
			}
		}
		
		set ::array_sta_ap_list [string trim $::array_sta_ap_list]		
	}

	if {$err_msg != ""} {
		error $err_msg 
	}
}

proc sts::setup_tests_sta {} {
	# access option array
	upvar {} {}

	set err_msg ""
	
	UTF::Message INFO "" "************************Func:setup_tests_sta***************************"

	UTF::Message INFO "" "------------------------------------------------------------------------------------"
	UTF::Message INFO "" "Setup STAs array: array_setup_sta_data"
	UTF::Message INFO "" "------------------------------------------------------------------------------------"

	set sta_cnt 0
	foreach sta_name $(sta) {

		incr sta_cnt

		UTF::Try "STA $sta_cnt: $sta_name" {
			UTF::Message INFO "" "create STA sta=$sta_name data arrays"
			sts::array_setup_sta_data $sta_name 0 1 0

			UTF::Message INFO "" "-----------------------------1-----------------------------------------"
			set temp [$sta_name cget -sta]
			UTF::Message INFO "1" "$sta_name cget -sta = '$temp'"
			set ::array_sta_sts(${sta_name}) [lindex $temp 2]
			if {$::array_sta_sts(${sta_name}) == ""} {
				incr ::error_cnt
				set err_msg "$sta_name StS interface is not defined in UTF config file. Halting tests!"
				error $err_msg 
			}
			UTF::Message INFO "" "-----------------------------::array_sta_sts(${sta_name})=$::array_sta_sts(${sta_name})-----------------------------------------"
			
			append ::array_sta_sta_list "$sta_name "
			set ::array_sta_sta_flag(${sta_name}) "1"
			set ::array_sta_apsta_flag(${sta_name}) "0"
			set ::array_sta_sts_flag(${sta_name}) "0"
			set ::array_sta_master_flag(${sta_name}) "0"
			set ::array_sta_slave_flag(${sta_name}) "0"
			set ::array_sta_plus_master_flag(${sta_name}) "0"
			set ::array_sta_plus_slave_flag(${sta_name}) "0"
			set ::array_sta_label(${sta_name}) "STA"
			set ::array_sta_host_type(${sta_name}) [$sta_name hostis]
			set ::array_sta_iperf_tcpwin(${sta_name}) [$sta_name cget -tcpwindow]

			UTF::Message INFO "" "APSTA: $sta_name cget -ipaddr"
			set ::array_sta_apsta_ip(${sta_name}) [$sta_name cget -ipaddr]
			UTF::Message INFO "" "-----------------------------::array_sta_apsta_ip(${sta_name})=$::array_sta_apsta_ip(${sta_name})-----------------------------------------"
			if {$::array_sta_apsta_ip(${sta_name}) == "" || $::array_sta_apsta_ip(${sta_name}) == "dhcp"} {			
				set err_msg "$sta_name APSTA IP is missing in UTF config file. Halting tests!"
				error $err_msg 
			}
			set ::array_sta_apsta_ifname(${sta_name}) [lindex $temp 1]
			# do not covert macaddr to upper case. iperf will fail when ipv6_macaddr is cap
			set ::array_sta_apsta_macaddr(${sta_name}) [$sta_name macaddr]
			set ::array_sta_apsta_ipv6_macaddr(${sta_name}) ""
			UTF::Message INFO "" "$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})"
			set catch_resp [catch {regexp {inet6\s+(\S+)} [$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name})] match ::array_sta_apsta_ipv6_macaddr(${sta_name})} catch_msg]
			if {$catch_resp != 0} {
				$sta_name rexec ifconfig -a
				incr ::error_cnt
				set err_msg "'$catch_msg' (check UTF config for '$sta_name' APSTA interface '$::array_sta_apsta_ifname(${sta_name})'). Halting tests!"
				error $err_msg 
			}

			UTF::Message INFO "" "StS: $::array_sta_sts(${sta_name}) cget -ipaddr"
			set catch_resp [catch {$::array_sta_sts(${sta_name}) cget -ipaddr} catch_msg]
			if {$catch_resp == 1 || $catch_msg == "dhcp"} {
				UTF::Try "UTF Config File" {
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					incr ::error_cnt
					set err_msg "$::array_sta_sts(${sta_name}) StS IP is missing in UTF config file. Halting tests!"
					error $err_msg 
				}
			} else {
				set ::array_sta_sts_ip(${sta_name}) $catch_msg
			}
			set ::array_sta_sts_ifname(${sta_name}) [lindex $temp 3]
			set ::array_sta_sts_macaddr(${sta_name}) ""
			# sts interface not created yet
			set ::array_sta_sts_ipv6_macaddr(${sta_name}) ""

			if {$::array_sta_sts_ifname(${sta_name}) == ""} {
				incr ::error_cnt
				set err_msg "$sta_name StS interface is not defined in UTF config file. Halting tests!"
				error $err_msg 
			}

			if {$::array_sta_host_type(${sta_name}) == "DHD"  || $::array_sta_host_type(${sta_name}) == "Linux"} {
				UTF::Message INFO "" "Bring up APSTA interface $::array_sta_apsta_ip(${sta_name})"
				$sta_name rexec ifconfig $::array_sta_apsta_ifname(${sta_name}) $::array_sta_apsta_ip(${sta_name}) up
				UTF::Sleep 1
			}

			if {$::array_sta_host_type(${sta_name}) == "MacOS"} {
				# Disable P2P Firewall
				$sta_name rexec "/usr/libexec/airportd prefs P2PFirewall=NO"
			}

			UTF::Message INFO "" "print STA sta=$sta_name data arrays"
			sts::array_setup_sta_data $sta_name 0 0 1

			UTF::Message INFO "" "-------------------STA=$sta_name-----------------------"
			catch {$sta_name rexec ifconfig -a}
			UTF::Message INFO "" "----------------------------------------------------------------------"
		}
	}

	if {$err_msg != ""} {
		error $err_msg 
	}
}

proc sts::setup_test_add_sta_link {sta_link_item} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_test_add_sta_link***************************"

	UTF::Message INFO "" "Link Item='$sta_link_item'"
	
	UTF::Message INFO "" "------------------------------------------------------------------------------------"
	UTF::Message INFO "" "Setup STA Link array: array_setup_sta_link_data"
	UTF::Message INFO "" "------------------------------------------------------------------------------------"

	# L1:AWDL:i1:i2:149:open:Create AWDL Link
	set rc [regexp {(.*?):(.*?):(.*?):(.*?):(.*?):(.*?):(.*$)} $sta_link_item match sta_link_id sta_link_type sta_link_src sta_link_dst sta_link_chan sta_link_security sta_link_title]

	UTF::Try "STA Link $sta_link_id: $sta_link_type" {

		if {$sta_link_security == ""} {
			set sta_link_security "open"
		}

		# workaround:
		# when link_type = "NAN", then the expr gives error "domain error: argument not in valid range"
		# replace NAN with NANDP
		if {$sta_link_type != ""} {
			set sta_link_type [string toupper $sta_link_type]
			regsub -all {NAN} $sta_link_type "" sta_link_type

			if {$sta_link_type == ""} {
				set sta_link_type "NANDP"
			}
		}
		
		UTF::Message INFO "" "create STA Link id=$sta_link_id data arrays"
		sts::array_setup_sta_link_data $sta_link_id 0 1 0

		set ::array_sta_link_type(${sta_link_id}) $sta_link_type
		set ::array_sta_link_src(${sta_link_id}) $sta_link_src
		set ::array_sta_link_dst(${sta_link_id}) $sta_link_dst
		set ::array_sta_link_chan(${sta_link_id}) $sta_link_chan
		set ::array_sta_link_security(${sta_link_id}) $sta_link_security
		set ::array_sta_link_title(${sta_link_id}) $sta_link_title

		UTF::Message INFO "" "print STA Link id=$sta_link_id data arrays"
		sts::array_setup_sta_link_data $sta_link_id 0 0 1
	}
}

proc sts::setup_test_remove_link {sta_link_item} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_test_remove_link***************************"
}

proc sts::setup_test_stream {test_cnt stream_cnt stream_item} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_test_stream***************************"

	UTF::Message INFO "" "Stream Item='$stream_item'"

	# T1:L1:UDP:VI:BI:0:300
	set rc [regexp {(.*?):(.*?):(.*?):(.*?):(.*?):(.*?):(.*$)} $stream_item match sta_test_id sta_link_id stream_traffic_type stream_traffic_priority stream_traffic_direction stream_start_time stream_end_time]

	UTF::Try "Stream $stream_cnt: $stream_item" {
	
		UTF::Message INFO "" "create stream test_cnt=$test_cnt stream_cnt=$stream_cnt test data arrays"
		sts::array_setup_stream_data $test_cnt $stream_cnt 0 1 0 0

		set stream_link_type 		$::array_sta_link_type(${sta_link_id})
		set stream_src_sta 			$::array_sta_link_src(${sta_link_id})
		set stream_dst_sta 			$::array_sta_link_dst(${sta_link_id})
		set stream_link_chan		$::array_sta_link_chan(${sta_link_id})
		set stream_link_security	$::array_sta_link_security(${sta_link_id})

		set stream_traffic_type [string toupper $stream_traffic_type]
		set stream_traffic_priority [string toupper $stream_traffic_priority]
		set stream_traffic_direction [string toupper $stream_traffic_direction]

		if {$stream_link_type == "BT"} {
			if {$stream_src_sta == ""} {
				incr ::error_cnt
				error "ERROR: 'BT stream_src_sta cannot be blank. Halting tests!" 
			}
			if {$stream_dst_sta != ""} {
				incr ::error_cnt
				error "ERROR: 'BT stream_dst_sta must be blank. Halting tests!" 
			}
			if {$stream_traffic_type != "A2DP"} {
				incr ::error_cnt
				error "ERROR: 'BT stream link has stream_traffic_type='$stream_traffic_type' instead of A2DP. Halting tests!" 
			}
			if {$stream_traffic_priority != ""} {
				incr ::error_cnt
				error "ERROR: 'BT stream_traffic_priority must be blank. Halting tests!" 
			}
			if {$stream_traffic_direction != ""} {
				incr ::error_cnt
				error "ERROR: 'BT stream_traffic_direction must be blank. Halting tests!" 
			}
		} else {
			# process stream_src_sta and stream_dst_sta

			if {[string first "i" $stream_src_sta] != 0} {
				incr ::error_cnt
				error "stream_src_sta='$stream_src_sta' is not starting with 'i'. Halting tests!"
			}
			if {[string first "i" $stream_dst_sta] != 0} {
				incr ::error_cnt
				error "stream_dst_sta='$stream_dst_sta' is not starting with 'i'. Halting tests!"
			}

			# remove the 'i'
			set new_stream_src_sta [regexp -inline {\d+} $stream_src_sta]
			set new_stream_dst_sta [regexp -inline {\d+} $stream_dst_sta]

			if {$stream_traffic_direction == "BITX"} {
				set stream_src_sta_idx $new_stream_dst_sta
				set stream_dst_sta_idx $new_stream_src_sta
			} else {
				set stream_src_sta_idx $new_stream_src_sta
				set stream_dst_sta_idx $new_stream_dst_sta
			}

			if {$stream_link_type == "APSTA"} {

				if {$(ap) == ""} {
					incr ::error_cnt
					error "'-ap' parameter is missing. Halting tests!"
				}

				# AP=new_stream_src_sta for BITX and not stream_src_sta_idx
				set stream_apsta_ap [lindex $(ap) [expr $new_stream_src_sta - 1]]

				# check for 2g:5g param
				set ap2g [split $stream_apsta_ap ":"]
				set ap2g [lindex $ap2g 0]

				set catch_resp [catch {$ap2g hostis} ap_host_type]
				if {$catch_resp != 0} {
					incr ::error_cnt
					error "APSTA stream_src_sta='$stream_src_sta' is not valid for AP. Halting tests!"
				}

				if {$ap_host_type == "Router"} {		
					UTF::Message INFO "" "$ap2g: Real AP Mode"
					set src_sta [$ap2g cget -lanpeer]
				} else {
					UTF::Message INFO "" "$ap2g: SoftAP Mode"
					# SoftAP controller is the same as SoftAP machine
					set src_sta $ap2g
				}

				set src $src_sta

				set s_tcpwin $::array_sta_iperf_tcpwin(${src_sta})
			} else {
				set stream_apsta_ap ""

				if {$stream_src_sta == $stream_dst_sta} {
					incr ::error_cnt
					error "stream_src_sta=stream_dst_sta=$stream_src_sta. Halting tests!"
				}

				set src_sta [lindex $(sta) [expr $stream_src_sta_idx - 1]]
				set src $::array_sta_sts($src_sta)
				if {$src == ""} {
					incr ::error_cnt
					if {$stream_traffic_direction == "BITX"} {
						error "$stream_link_type: Invalid stream_dst_sta='$stream_dst_sta'. Halting tests!"
					} else {
						error "$stream_link_type: Invalid stream_src_sta='$stream_src_sta'. Halting tests!"
					}
				}
				set s_tcpwin $::array_sta_iperf_tcpwin(${src_sta})
			}

			set dst_sta [lindex $(sta) [expr $stream_dst_sta_idx - 1]]
			if {$stream_link_type == "APSTA"} {
				set dst $dst_sta
			} else {
				set dst $::array_sta_sts($dst_sta)
			}
			if {$dst == ""} {
				incr ::error_cnt
				if {$stream_traffic_direction == "BITX"} {
					error "$stream_link_type: Invalid stream_src_sta='$stream_src_sta'. Halting tests!"
				} else {
					error "$stream_link_type: Invalid stream_dst_sta='$stream_dst_sta'. Halting tests!"
				}
			}
			set d_tcpwin $::array_sta_iperf_tcpwin(${dst_sta})

			if {$stream_traffic_direction == "BITX"} {
				set stream_dst_sta $src_sta
				set stream_src_sta $dst_sta
				set stream_dst $src
				set stream_src $dst
				set src_tcpwin $d_tcpwin
				set dst_tcpwin $s_tcpwin
			} else {
				set stream_src_sta $src_sta
				set stream_dst_sta $dst_sta
				set stream_src $src
				set stream_dst $dst
				set src_tcpwin $s_tcpwin
				set dst_tcpwin $d_tcpwin
			}

			if {$stream_src_sta == ""} {
				incr ::error_cnt
				error "stream_src_sta is BLANK. Halting tests!"
			}
			if {$stream_dst_sta == ""} {
				incr ::error_cnt
				error "stream_dst_sta is BLANK. Halting tests!"
			}

			# process stream_link_chan

			if {[string first "i" $stream_link_chan] == 0} {
				# remove the 'i'
				set stream_link_chan [regexp -inline {\d+} $stream_link_chan]
				if {$stream_link_type == "APSTA"} {
					set stream_link_chan [lindex $(ap_chan) [expr $stream_link_chan - 1]]
				} else {
					set stream_link_chan [lindex $(sts_chan) [expr $stream_link_chan - 1]]
				}
			}
		}

		# for NANDP, there must be 2.4G channel only
		if {$stream_link_type == "NANDP"} {
			if {[llength $stream_link_chan] != 1} {
				incr ::error_cnt
				error "NAN channel must have 2.4G channel only. Halting tests!"
			}						
		}

		UTF::Message INFO "" "test_cnt                      ='$test_cnt'"
		UTF::Message INFO "" "stream_cnt                    ='$stream_cnt'"
		UTF::Message INFO "" "stream_apsta_ap               ='$stream_apsta_ap'"
		UTF::Message INFO "" "stream_src_sta_idx            ='$stream_src_sta_idx'"
		UTF::Message INFO "" "stream_src_sta                ='$stream_src_sta'"
		UTF::Message INFO "" "stream_src                    ='$stream_src'"
		UTF::Message INFO "" "stream_dst_sta_idx            ='$stream_dst_sta_idx'"
		UTF::Message INFO "" "stream_dst_sta                ='$stream_dst_sta'"
		UTF::Message INFO "" "stream_dst                    ='$stream_dst'"
		UTF::Message INFO "" "stream_link_chan              ='$stream_link_chan'" 
		UTF::Message INFO "" "stream_link_type              ='$stream_link_type'"
		UTF::Message INFO "" "stream_link_security          ='$stream_link_security'"
		UTF::Message INFO "" "stream_traffic_type           ='$stream_traffic_type'"
		UTF::Message INFO "" "stream_traffic_priority       ='$stream_traffic_priority'"
		UTF::Message INFO "" "stream_traffic_direction      ='$stream_traffic_direction'" 
		UTF::Message INFO "" "stream_start_time             ='$stream_start_time'"
		UTF::Message INFO "" "stream_end_time               ='$stream_end_time'"

		set host_src $stream_dst_sta

		if {$stream_link_type == "BT"} {
			# Speaker<-STA/BT
			set stream_plot_name_lt 4
			set stream_plot_name_pt 9
			set stream_plot_minmax_name_lt 4
		} else {
			if {$stream_traffic_direction == "RX" || $stream_traffic_direction == "BIRX"} {
				set stream_display_traffic_direction "->"

				if {$stream_link_type == "APSTA"} {
					# APSTA link: AP->STA
					set stream_plot_name_lt 1
					set stream_plot_name_pt 11
					set stream_plot_minmax_name_lt 1
				} else {
					# StS link: Master/GO->Slave/GC
					set stream_plot_name_lt 13
					set stream_plot_name_pt 11
					set stream_plot_minmax_name_lt 13
				}
			} elseif {$stream_traffic_direction == "TX" || $stream_traffic_direction == "BITX"} {
				set stream_display_traffic_direction "<-"

				if {$stream_traffic_direction == "BITX"} {
					set host_src $stream_src_sta
				}

				if {$stream_link_type == "APSTA"} {
					# APSTA link: AP->STA
					set stream_plot_name_lt 3
					set stream_plot_name_pt 9
					set stream_plot_minmax_name_lt 3
				} else {
					# StS link: Master/GO->Slave/GC
					set stream_plot_name_lt 5
					set stream_plot_name_pt 9
					set stream_plot_minmax_name_lt 5
				}
			} else {
				incr ::error_cnt
				error "ERROR: 'Invalid stream_traffic_direction=$stream_traffic_direction. Halting tests!" 
			}
		}

		set apsta_sta_list $::array_streams_apsta_sta_list(${test_cnt})
		set sts_master_sta_list $::array_streams_sts_master_sta_list(${test_cnt})
		set sts_slave_sta_list $::array_streams_sts_slave_sta_list(${test_cnt})

		if {$stream_traffic_direction != "BITX"} {
			if {$stream_link_type == "APSTA"} {								
				set ::array_sta_apsta_flag(${stream_dst_sta}) "1"
			} else {
				set ::array_sta_sts_flag(${stream_src_sta}) "1"
				set ::array_sta_sts_flag(${stream_dst_sta}) "1"
				set ::array_sta_master_flag(${stream_src_sta}) "1"
				set ::array_sta_slave_flag(${stream_dst_sta}) "1"
			}
		}

		if {$stream_traffic_direction != "BITX"} {
			if {$stream_link_type == "APSTA"} {								
				# no duplicate
				set idxs [lsearch -exact -all $apsta_sta_list $stream_dst_sta]
				if {[llength $idxs] > 0} {
					incr ::error_cnt
					error "ERROR: '$stream_link_type: duplicate stream_dst_sta=$stream_dst_sta. Halting tests!"
				}

				append apsta_sta_list " $stream_dst_sta"
			} else {
				if {$sts_master_sta_list == ""} {
					set sts_master_sta_list $stream_src_sta
				}
				# one master only
				set idxs [lsearch -exact -all $sts_master_sta_list $stream_src_sta]
				if {[llength $idxs] != 1} {
					incr ::error_cnt
					error "ERROR: '$stream_link_type: multiple Master stream_src_sta=$stream_src_sta. Halting tests!"
				}

				# no duplicate
				set idxs [lsearch -exact -all $sts_slave_sta_list $stream_dst_sta]
				if {[llength $idxs] > 0} {
					incr ::error_cnt
					error "ERROR: '$stream_link_type: duplicate Slave stream_dst_sta=$stream_dst_sta. Halting tests!"
				}

				append sts_slave_sta_list " $stream_dst_sta"
			}

			set apsta_sta_list [string trim $apsta_sta_list]
			set sts_master_sta_list [string trim $sts_master_sta_list]
			set sts_slave_sta_list [string trim $sts_slave_sta_list]
		}

		# To display the AP and STA index number in the report

		set sta_src_idx ""
		set sta_dst_idx ""
		
		if {$stream_link_type == "APSTA"} {
		
			if {[llength $(ap)] > 1} {
				set sta_src_idx $stream_src_sta_idx
			}
			
			if {[llength $(sta)] > 1} {
				set sta_dst_idx $stream_dst_sta_idx
			}
		} else {
			set sta_src_idx "STA$stream_src_sta_idx"
			set sta_dst_idx "STA$stream_dst_sta_idx"
		}

		switch $stream_link_type {
			APSTA {
				if {$::array_sta_host_type(${host_src}) == "MacOS"} {
					set src_display_str "Infra$sta_src_idx"
				} else {
					set src_display_str "AP$sta_src_idx"
				}

				set dst_display_str "STA$sta_dst_idx"
			}

			P2P {
				set src_display_str "$sta_src_idx\(P2P)"
				set dst_display_str "$sta_dst_idx\(GC)"
			}

			AWDL {
				if {$::array_sta_host_type(${host_src}) == "MacOS"} {
					set src_display_str "$sta_src_idx\(AWDL)"
					set dst_display_str "$sta_dst_idx\(Peer)"
				} else {
					set src_display_str "$sta_src_idx\(AWDL)"
					set dst_display_str "$sta_dst_idx\(Slave)"
				}
			}

			NANDP {
				set src_display_str "$sta_src_idx\(NAN)"
				set dst_display_str "$sta_dst_idx\(Slave)"
			}

			BT {
				set src_display_str "BT"
				set dst_display_str "BT"
			}

			AIBSS {
				set src_display_str "$sta_src_idx\(AIBSS)"
				set dst_display_str "$sta_dst_idx\(AIBSS)"
			}

			11mc {
				set src_display_str "$sta_src_idx\(11mc)"
				set dst_display_str "$sta_dst_idx\(11mc)"
			}

			default {
				incr ::error_cnt
				error "ERROR: 'Invalid stream_link_type=$stream_link_type. Halting tests!" 
			}
		}

		if {$stream_link_type == "BT"} {
			set stream_short_label "BT"
			set stream_report_label "BT"
			set stream_label "BT"

			set stream_iperf_tos ""
			set stream_throughput_scale ""
			set stream_packet_size ""
			set stream_bid_bandwidth ""
			set stream_bandwidth ""
		} else {
			set stream_short_label "$src_display_str$stream_display_traffic_direction$dst_display_str"
			set stream_report_label "$stream_short_label ($stream_link_chan)"
			set stream_label "$stream_traffic_type\:$stream_traffic_priority\:$stream_report_label"

			switch $stream_traffic_priority {
				BK {
					# BK=001->0x20 or 010->0x40 
					set stream_iperf_tos "0x20"
					set stream_throughput_scale "m"
					if {$stream_link_type == "APSTA"} {
						set stream_packet_size 	$(apsta_packet_size_BK) 
						set stream_bandwidth 	$(apsta_bandwidth_BK)
					} else {
						set stream_packet_size 	$(sts_packet_size_BK) 
						set stream_bandwidth 	$(sts_bandwidth_BK)
					}
				}

				BE {
					# BE=000->0x00 or 011->0x60 
					set stream_iperf_tos "0"
					set stream_throughput_scale "m"
					if {$stream_link_type == "APSTA"} {
						set stream_packet_size 	$(apsta_packet_size_BE) 
						set stream_bandwidth 	$(apsta_bandwidth_BE)
					} else {
						set stream_packet_size 	$(sts_packet_size_BE) 
						set stream_bandwidth 	$(sts_bandwidth_BE)
					}
				}

				VI {
					# VI=100->0x80 or 101->0xA0 
					set stream_iperf_tos "0x80"
					set stream_throughput_scale "m"
					if {$stream_link_type == "APSTA"} {
						set stream_packet_size 	$(apsta_packet_size_VI) 
						set stream_bandwidth 	$(apsta_bandwidth_VI)
					} else {
						set stream_packet_size 	$(sts_packet_size_VI) 
						set stream_bandwidth 	$(sts_bandwidth_VI)
					}
				}				

				VO {
					# VO=110->0xC0 or 111->0xE0 
					set stream_iperf_tos "0xc0"
					set stream_throughput_scale "k"
					if {$stream_link_type == "APSTA"} {
						set stream_packet_size 	$(apsta_packet_size_VO) 
						set stream_bandwidth 	$(apsta_bandwidth_VO)
					} else {
						set stream_packet_size 	$(sts_packet_size_VO) 
						set stream_bandwidth 	$(sts_bandwidth_VO)
					}

					if {[regexp {M} $stream_bandwidth]} {
						set stream_throughput_scale "m"
					}
				}
				default {
					incr ::error_cnt
					error "ERROR: 'Invalid stream_traffic_priority=$stream_traffic_priority. Halting tests!" 
				}
			}

			set stream_bid_bandwidth ""
			if {[regexp {BI} $stream_traffic_direction]} {
				regexp {^([-+]?[0-9]*\.?[0-9]+)(.)} $stream_bandwidth match stream_bid_bandwidth scale
				set stream_bandwidth [expr {$stream_bid_bandwidth / 2.0}]
				set stream_bandwidth "$stream_bandwidth$scale"
			}
		}

		UTF::Message INFO "" "::array_sta_apsta_flag(${stream_dst_sta})                 ='$::array_sta_apsta_flag(${stream_dst_sta})'"
		UTF::Message INFO "" "::array_sta_sts_flag(${stream_src_sta})                   ='$::array_sta_sts_flag(${stream_src_sta})'"
		UTF::Message INFO "" "::array_sta_sts_flag(${stream_dst_sta})                   ='$::array_sta_sts_flag(${stream_dst_sta})'"
		UTF::Message INFO "" "::array_sta_master_flag(${stream_src_sta})                ='$::array_sta_master_flag(${stream_src_sta})'"
		UTF::Message INFO "" "::array_sta_slave_flag(${stream_dst_sta})                 ='$::array_sta_slave_flag(${stream_dst_sta})'"

		UTF::Message INFO "" "stream_iperf_tos              ='$stream_iperf_tos'"
		UTF::Message INFO "" "stream_throughput_scale       ='$stream_throughput_scale'"
		UTF::Message INFO "" "stream_packet_size            ='$stream_packet_size'"
		UTF::Message INFO "" "stream_bid_bandwidth          ='$stream_bid_bandwidth'"
		UTF::Message INFO "" "stream_bandwidth              ='$stream_bandwidth'"

		##########################################################################################
		#	Important Note:
		#	DUT and GC are the same machine, but when doing iperf for APSTA and StS from the 
		#	same machine, we need different	names, so iperf results can be differentiated 
		#	between APSTA and StS. Therefore iperf stream name is appended with stream count at 
		#	the beginning to resolve this issue.
		# 	Also, stream count at the beginning causes unique array index, otherwise the QoS
		#   test streams will have the same array index and overwrite data.
		##########################################################################################
		set stream_label "$stream_cnt\:$stream_label"
		# no space should be in array index 'stream_label'
		regsub -all { } $stream_label "" stream_label

		if {$stream_cnt > 1} {
			set total_streams_label $::array_streams_total_streams_label(${test_cnt})
		} else {
			set total_streams_label ""
		}

		if {$stream_traffic_direction != "BIRX"} {					

			set tmp_stream_report_label $stream_report_label

			if {$stream_traffic_direction == "BITX"} {
				# replace "<-" with "<>"
				regsub -all {<\-} $tmp_stream_report_label "<>" tmp_stream_report_label
				UTF::Message INFO "" "Bi-directional stream_report_label '$stream_report_label' is replaced with '$tmp_stream_report_label'"
			}

			if {$total_streams_label != ""} {
				append total_streams_label "\]\[$tmp_stream_report_label"
			} else {
				set total_streams_label "\[$tmp_stream_report_label"
			}
		}

		UTF::Message INFO "" "stream_short_label            ='$stream_short_label'"
		UTF::Message INFO "" "stream_report_label           ='$stream_report_label'"
		UTF::Message INFO "" "stream_label                  ='$stream_label'"
		UTF::Message INFO "" "stream_plot_name_lt           ='$stream_plot_name_lt'"
		UTF::Message INFO "" "stream_plot_name_pt           ='$stream_plot_name_pt'"
		UTF::Message INFO "" "stream_plot_minmax_name_lt    ='$stream_plot_minmax_name_lt'"

		UTF::Message INFO "" "total_streams_label           ='$total_streams_label'"
		UTF::Message INFO "" "apsta_sta_list                ='$apsta_sta_list'"
		UTF::Message INFO "" "sts_master_sta_list           ='$sts_master_sta_list'"
		UTF::Message INFO "" "sts_slave_sta_list            ='$sts_slave_sta_list'"
		UTF::Message INFO "" "src_tcpwin                    ='$src_tcpwin'"
		UTF::Message INFO "" "dst_tcpwin                    ='$dst_tcpwin'"

		set ::array_streams_test_cnt "$test_cnt"

		set ::array_streams_cnt(${test_cnt}) "$stream_cnt"
		set ::array_streams_total_streams_label(${test_cnt}) "$total_streams_label"
		set ::array_streams_apsta_sta_list(${test_cnt}) "$apsta_sta_list"
		set ::array_streams_sts_master_sta_list(${test_cnt}) "$sts_master_sta_list"
		set ::array_streams_sts_slave_sta_list(${test_cnt}) "$sts_slave_sta_list"

		set ::array_streams_stream_short_label(${test_cnt},${stream_cnt}) "$stream_short_label"
		set ::array_streams_stream_label(${test_cnt},${stream_cnt}) "$stream_label"
		if {$stream_link_type == "APSTA"} {
			set ::array_streams_apsta_link_chan(${test_cnt}) $stream_link_chan
		} else {
			set ::array_streams_sts_link_chan(${test_cnt}) $stream_link_chan
		}
		set ::array_streams_link_type(${test_cnt},${stream_cnt}) "$stream_link_type"
		set ::array_streams_link_security(${test_cnt},${stream_cnt}) "$stream_link_security"
		set ::array_streams_traffic_type(${test_cnt},${stream_cnt}) "$stream_traffic_type"
		set ::array_streams_traffic_priority(${test_cnt},${stream_cnt}) "$stream_traffic_priority"
		set ::array_streams_traffic_direction(${test_cnt},${stream_cnt}) "$stream_traffic_direction"
		if {$::roaming_test_flag} {
			if {$stream_start_time != "" || $stream_end_time != ""} {
				error "'tests' paramter for roaming should not have 'stream_start_time' and 'stream_end_time'"
			}

			set stream_start_time 0
			set stream_end_time $::streams_total_time
		} else {
			if {$stream_start_time == "" || $stream_end_time == ""} {
				error "'tests' paramters for 'stream_start_time' and/or 'stream_end_time' are blank"
			}
		}
		set ::array_streams_start_time(${test_cnt},${stream_cnt}) "$stream_start_time"
		set ::array_streams_end_time(${test_cnt},${stream_cnt}) "$stream_end_time"

		regsub -all {:} $stream_label "-" stream_file_name
		regsub -all { } $stream_file_name "-" stream_file_name
		regsub -all {<\-} $stream_file_name "RX" stream_file_name
		regsub -all {\->} $stream_file_name "TX" stream_file_name
		regsub -all {<>} $stream_file_name "BI" stream_file_name
		regsub -all {\/} $stream_file_name "-" stream_file_name
		set ::array_streams_file_name(${test_cnt},${stream_cnt}) "$stream_file_name"

		set ::array_streams_plot_name_lt(${test_cnt},${stream_cnt}) "$stream_plot_name_lt"
		set ::array_streams_plot_name_pt(${test_cnt},${stream_cnt}) "$stream_plot_name_pt"
		set ::array_streams_plot_minmax_name_lt(${test_cnt},${stream_cnt}) "$stream_plot_minmax_name_lt"

		set ::array_streams_apsta_ap(${test_cnt},${stream_cnt}) "$stream_apsta_ap"
		set ::array_streams_src_sta_idx(${test_cnt},${stream_cnt}) "$stream_src_sta_idx"
		set ::array_streams_src_sta(${test_cnt},${stream_cnt}) "$stream_src_sta"
		set ::array_streams_src(${test_cnt},${stream_cnt}) "$stream_src"
		set ::array_streams_dst_sta_idx(${test_cnt},${stream_cnt}) "$stream_dst_sta_idx"
		set ::array_streams_dst_sta(${test_cnt},${stream_cnt}) "$stream_dst_sta"
		set ::array_streams_dst(${test_cnt},${stream_cnt}) "$stream_dst"
		if {[lsearch -exact $::sts_link_types $::array_streams_link_type(${test_cnt},${stream_cnt})] != -1} {
			# StS link
			set ::array_streams_src_host_type(${test_cnt},${stream_cnt}) $::array_sta_host_type(${stream_src_sta})
			set ::array_streams_src_ifname(${test_cnt},${stream_cnt}) $::array_sta_sts_ifname(${stream_src_sta})
			set ::array_streams_src_ip(${test_cnt},${stream_cnt}) $::array_sta_sts_ip(${stream_src_sta})
			set ::array_streams_src_macaddr(${test_cnt},${stream_cnt}) $::array_sta_sts_macaddr(${stream_src_sta})
			set ::array_streams_src_ipv6_macaddr(${test_cnt},${stream_cnt}) $::array_sta_sts_ipv6_macaddr(${stream_src_sta})

			set ::array_streams_dst_host_type(${test_cnt},${stream_cnt}) $::array_sta_host_type(${stream_dst_sta})
			set ::array_streams_dst_ifname(${test_cnt},${stream_cnt}) $::array_sta_sts_ifname(${stream_dst_sta})
			set ::array_streams_dst_ip(${test_cnt},${stream_cnt}) $::array_sta_sts_ip(${stream_dst_sta})
			set ::array_streams_dst_macaddr(${test_cnt},${stream_cnt}) $::array_sta_sts_macaddr(${stream_dst_sta})
			set ::array_streams_dst_ipv6_macaddr(${test_cnt},${stream_cnt}) $::array_sta_sts_ipv6_macaddr(${stream_dst_sta})
		} else {
			# APSTA link
			set ::array_streams_src_host_type(${test_cnt},${stream_cnt}) $::array_sta_host_type(${stream_src_sta})
			set ::array_streams_src_ifname(${test_cnt},${stream_cnt}) $::array_sta_apsta_ifname(${stream_src_sta})
			set ::array_streams_src_ip(${test_cnt},${stream_cnt}) $::array_sta_apsta_ip(${stream_src_sta})
			set ::array_streams_src_macaddr(${test_cnt},${stream_cnt}) $::array_sta_apsta_macaddr(${stream_src_sta})
			set ::array_streams_src_ipv6_macaddr(${test_cnt},${stream_cnt}) $::array_sta_apsta_ipv6_macaddr(${stream_src_sta})

			set ::array_streams_dst_host_type(${test_cnt},${stream_cnt}) $::array_sta_host_type(${stream_dst_sta})
			set ::array_streams_dst_ifname(${test_cnt},${stream_cnt}) $::array_sta_apsta_ifname(${stream_dst_sta})
			set ::array_streams_dst_ip(${test_cnt},${stream_cnt}) $::array_sta_apsta_ip(${stream_dst_sta})
			set ::array_streams_dst_macaddr(${test_cnt},${stream_cnt}) $::array_sta_apsta_macaddr(${stream_dst_sta})
			set ::array_streams_dst_ipv6_macaddr(${test_cnt},${stream_cnt}) $::array_sta_apsta_ipv6_macaddr(${stream_dst_sta})
		}
		set ::array_streams_src_tcpwin(${test_cnt},${stream_cnt}) "$src_tcpwin"					
		set ::array_streams_dst_tcpwin(${test_cnt},${stream_cnt}) "$dst_tcpwin"
		if {$stream_traffic_direction == "BITX"} {
			set ::array_streams_src_display_str(${test_cnt},${stream_cnt}) "$dst_display_str"					
			set ::array_streams_dst_display_str(${test_cnt},${stream_cnt}) "$src_display_str"
		} else {
			set ::array_streams_src_display_str(${test_cnt},${stream_cnt}) "$src_display_str"					
			set ::array_streams_dst_display_str(${test_cnt},${stream_cnt}) "$dst_display_str"
		}

		set ::array_streams_iperf_tos(${test_cnt},${stream_cnt}) "$stream_iperf_tos"
		set ::array_streams_throughput_scale(${test_cnt},${stream_cnt}) "$stream_throughput_scale"
		set ::array_streams_packet_size(${test_cnt},${stream_cnt}) "$stream_packet_size"
		set ::array_streams_bandwidth(${test_cnt},${stream_cnt}) "$stream_bandwidth"

		if {$stream_traffic_direction != "BITX"} {
			set  possible_list "$::array_streams_interface_possible_list(${test_cnt}) $stream_src_sta $stream_dst_sta $stream_src $stream_dst"
			set  existing_list "$::array_streams_interface_existing_list(${test_cnt}) $stream_dst_sta $stream_dst"
			#set ::array_streams_interface_possible_list(${test_cnt}) [lsort -unique "$possible_list"]
			#set ::array_streams_interface_existing_list(${test_cnt}) [lsort -unique "$existing_list"]
			UTF::Message INFO "" "Before: ::array_streams_interface_possible_list(${test_cnt})=$possible_list"
			set ::array_streams_interface_possible_list(${test_cnt}) [sts::remove_duplicates $possible_list]
			UTF::Message INFO "" "After : ::array_streams_interface_possible_list(${test_cnt})=$::array_streams_interface_possible_list(${test_cnt})"
			UTF::Message INFO "" "Before: ::array_streams_interface_existing_list(${test_cnt})=$existing_list"
			set ::array_streams_interface_existing_list(${test_cnt}) [sts::remove_duplicates $existing_list]
			UTF::Message INFO "" "After : ::array_streams_interface_existing_list(${test_cnt})=$::array_streams_interface_existing_list(${test_cnt})"
			set ::array_streams_interface_active_list(${test_cnt}) $::array_streams_interface_existing_list(${test_cnt})
		}

		UTF::Message INFO "" "print stream test_cnt=$test_cnt stream_cnt=$stream_cnt test data arrays"
		sts::array_setup_stream_data $test_cnt $stream_cnt 0 0 1 0
	}
}

proc sts::setup_tests_streams_plot_colors {test_cnt} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_streams_plot_colors***************************"

	#####################################################
	###   Change plot colors, if there is a repeat    ###
	#####################################################
	set replace_lt_flag 0
	foreach key1 [lsort [array names ::array_streams_plot_name_lt]] {

		regexp {(\d+),(\d+)} $key1 match key1_test_no key1_stream_no

		if {$key1_test_no != $test_cnt} {
			continue
		}

		set base_lt $::array_streams_plot_name_lt($key1)

		set repeat_cnt 0
		foreach key2 [lsort [array names ::array_streams_plot_name_lt]] {

			regexp {(\d+),(\d+)} $key2 match key2_test_no key2_stream_no

			if {$key2_test_no != $test_cnt || $key1 == $key2} {
				continue
			}

			set compare_lt $::array_streams_plot_name_lt($key2)
			if {$base_lt == $compare_lt} {
				incr repeat_cnt
				if {$repeat_cnt > 0} {
					UTF::Message INFO "" "Found repeated plot_name_lt $base_lt"
					set replace_lt_flag 1
					break
				}
			}
		}

		if {$replace_lt_flag} {
			break
		}
	}

	if {$replace_lt_flag} {
		UTF::Try "Change Plot Colors" {
			UTF::Message INFO "" "Found repeated plot_name_lt"

			set lt_index 0
			foreach key [lsort [array names ::array_streams_plot_name_lt]] {

				regexp {(\d+),(\d+)} $key match key_test_no key_stream_no

				if {$key_test_no != $test_cnt} {
					continue
				}

				UTF::Message INFO "" "Org ::array_streams_plot_name_lt(${key})='$::array_streams_plot_name_lt(${key})'"
				incr lt_index
				set ::array_streams_plot_name_lt(${key}) $lt_index
				UTF::Message INFO "" "New ::array_streams_plot_name_lt(${key})='$::array_streams_plot_name_lt(${key})'"
			}
		}
	}
}

proc sts::setup_tests_streams_sta_config {test_cnt} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_streams_sta_config***************************"

	#####################################################
	###   Figure out STA+GO/Master or STA+GC/Slave    ###
	#####################################################
	# if apsta_dst = sts_src then it is (STA+GO/Master)
	# if apsta_dst = sts_dst then it is (STA+GC/Slave)
	UTF::Try "STA Config Type" {

		set apsta_stream_no 0
		set sts_stream_no 0
		for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${test_cnt})} {incr stream_no} {

			if {$::array_streams_traffic_direction(${test_cnt},${stream_no}) == "BITX"} {
				# only BIRX needs to be processed
				continue
			}

			if {$::array_streams_link_type(${test_cnt},${stream_no}) == "APSTA" || $(nan1)} {
				if {$apsta_stream_no == 0} {
					set apsta_stream_no $stream_no

					set ::array_streams_ap_controller(${test_cnt}) $::array_streams_src_sta(${test_cnt},${stream_no})
					set ::array_streams_ap_controller_ip(${test_cnt}) $::array_streams_src_ip(${test_cnt},${stream_no})
					# ::array_streams_ap(${test_cnt}) is '2g:5g' and later in setup_ap_radio_channel will be replaced to '2g' or '5g' depending on ap channel
					set ::array_streams_ap(${test_cnt}) $::array_streams_apsta_ap(${test_cnt},${stream_no})
				}
			} elseif {[lsearch -exact $::sts_link_types $::array_streams_link_type(${test_cnt},1)] != -1} {
				if {$sts_stream_no == 0} {
					set sts_stream_no $stream_no
				}
			}
		}

		UTF::Message INFO "" "::array_streams_ap_controller(${test_cnt})                      ='$::array_streams_ap_controller(${test_cnt})'"
		UTF::Message INFO "" "::array_streams_ap_controller_ip(${test_cnt})                   ='$::array_streams_ap_controller_ip(${test_cnt})'"
		UTF::Message INFO "" "::array_streams_ap(${test_cnt})                                 ='$::array_streams_ap(${test_cnt})'"

		if {$apsta_stream_no != 0 && $sts_stream_no != 0 && $apsta_stream_no > $sts_stream_no} {
			set ::array_streams_sts_link_first_flag(${test_cnt}) "1"
		} else {
			set ::array_streams_sts_link_first_flag(${test_cnt}) "0"
		}
		if {$::array_streams_apsta_sta_list(${test_cnt}) != "" && $::array_streams_sts_master_sta_list(${test_cnt}) == "" && $::array_streams_bt_sta_list(${test_cnt}) == ""} {
			set ::array_streams_apsta_only_flag(${test_cnt}) "1"
		} else {
			set ::array_streams_apsta_only_flag(${test_cnt}) "0"
		}
		if {$::array_streams_apsta_sta_list(${test_cnt}) == "" && $::array_streams_sts_master_sta_list(${test_cnt}) != "" && $::array_streams_bt_sta_list(${test_cnt}) == ""} {
			set ::array_streams_sts_only_flag(${test_cnt}) "1"
		} else {
			set ::array_streams_sts_only_flag(${test_cnt}) "0"
		}
		if {$::array_streams_apsta_sta_list(${test_cnt}) == "" && $::array_streams_sts_master_sta_list(${test_cnt}) == "" && $::array_streams_bt_sta_list(${test_cnt}) != ""} {
			set ::array_streams_bt_only_flag(${test_cnt}) "1"
		} else {
			set ::array_streams_bt_only_flag(${test_cnt}) "0"
		}
		UTF::Message INFO "" "::array_streams_sts_link_first_flag(${test_cnt})                ='$::array_streams_sts_link_first_flag(${test_cnt})'"
		UTF::Message INFO "" "::array_streams_apsta_only_flag(${test_cnt})                    ='$::array_streams_apsta_only_flag(${test_cnt})'"
		UTF::Message INFO "" "::array_streams_sts_only_flag(${test_cnt})                      ='$::array_streams_sts_only_flag(${test_cnt})'"
		UTF::Message INFO "" "::array_streams_bt_only_flag(${test_cnt})                       ='$::array_streams_bt_only_flag(${test_cnt})'"

		if {$(attn_type) > 3} {
			incr ::error_cnt
			error "Invalid attenuation type parameter. Halting tests!"
		} elseif {$(attn_type) == 1 || $(attn_type) == 2 || $(attn_type) == 3} {
			# RvR test
			set ::rvr_test_flag 1
			UTF::Message LOG "" "RvR test"

			if {$apsta_stream_no > 0} {
				set apsta_sta_name $::array_streams_dst_sta(${test_cnt},${apsta_stream_no})
				set ::rvr_apsta_attngrp [$apsta_sta_name cget -attngrp]
				UTF::Message LOG "" "STA $apsta_sta_name APSTA attenuation group is '$::rvr_apsta_attngrp'"
				if {$::rvr_apsta_attngrp == ""} {
					set ::rvr_apsta_attngrp [$::array_streams_ap(${test_cnt}) cget -attngrp]
					UTF::Message LOG "" "AP $::array_streams_ap(${test_cnt}) APSTA attenuation group is '$::rvr_apsta_attngrp'"
				}
				UTF::Message LOG "" "RvR APSTA attenuation group is '$::rvr_apsta_attngrp'"
				if {($(attn_type) == 1 || $(attn_type) == 3) && $::rvr_apsta_attngrp == ""} {
					incr ::error_cnt
					error "Invalid APSTA attenuation setup in the config file. Halting tests!"
				}
			}

			if {$sts_stream_no > 0} {
				set sts_sta_name $::array_streams_dst_sta(${test_cnt},${sts_stream_no})
				set ::rvr_sts_attngrp [$sts_sta_name cget -attngrp]
				UTF::Message LOG "" "RvR $::array_streams_link_type(${test_cnt},${sts_stream_no}) attenuation group is '$::rvr_sts_attngrp'"
				if {$(attn_type) > 1 && $::rvr_sts_attngrp == ""} {
					incr ::error_cnt
					error "Invalid $::array_streams_link_type(${test_cnt},${sts_stream_no}) attenuation setup in the config file. Halting tests!"
				}
			}
		}

		set sta_connection_type ""

		foreach key1 [lsort [array names ::array_streams_link_type]] {

			regexp {(\d+),(\d+)} $key1 match key1_test_no key1_stream_no

			if {$key1_test_no != $test_cnt} {
				continue
			}

			if {$::array_streams_link_type($key1) == "APSTA" && $::array_streams_traffic_direction($key1) != "BITX"} {
				set apsta_dst_key1 $::array_streams_dst_sta($key1)
				set apsta_dst $::array_streams_dst_sta(${key1_test_no},${key1_stream_no})
				set apsta_dst_disp $::array_streams_dst_display_str(${key1_test_no},${key1_stream_no})
				set loc [string first $apsta_dst_disp $::array_streams_total_streams_label(${key1_test_no})]
				set len [string length $apsta_dst_disp]

				foreach key2 [lsort [array names ::array_streams_link_type]] {

					regexp {(\d+),(\d+)} $key2 match key2_test_no key2_stream_no

					if {$key2_test_no != $test_cnt} {
						continue
					}

					if {$key1 == $key2 || $::array_streams_link_type($key2) == "APSTA" || $::array_streams_traffic_direction($key2) == "BITX"} {
						continue
					}

					if {$apsta_dst_key1 == $::array_streams_src_sta($key2)} {
						UTF::Message INFO "" "apsta_dst_key1=$apsta_dst_key1  ::array_streams_src_sta($key2)=$::array_streams_src_sta($key2)"

						set sts_src_disp $::array_streams_src_display_str(${key2_test_no},${key2_stream_no})

						# (STA+GO/Master)
						set sta_connection_type "$apsta_dst_disp+$sts_src_disp"
						set sta_plus_master_flag 1
						set sta_plus_slave_flag 0
					}
					if {$apsta_dst_key1 == $::array_streams_dst_sta($key2)} {
						UTF::Message INFO "" "apsta_dst_key1=$apsta_dst_key1  ::array_streams_dst_sta($key2)=$::array_streams_dst_sta($key2)"

						set sts_dst_disp $::array_streams_dst_display_str(${key2_test_no},${key2_stream_no})

						# (STA+GC/Slave)
						set sta_connection_type "$apsta_dst_disp+$sts_dst_disp"
						set sta_plus_master_flag 0
						set sta_plus_slave_flag 1
					}

					if {$sta_connection_type != ""} {
						set ::array_sta_plus_master_flag(${apsta_dst}) $sta_plus_master_flag
						set ::array_sta_plus_slave_flag(${apsta_dst}) $sta_plus_slave_flag
						set ::array_sta_label(${apsta_dst}) $sta_connection_type
						UTF::Message INFO "" "::array_sta_label(${apsta_dst})=$::array_sta_label(${apsta_dst})"

						set sta_connection_type "($sta_connection_type)"

						UTF::Message INFO "" "Before: $::array_streams_total_streams_label(${key1_test_no})"
						set ::array_streams_total_streams_label(${key1_test_no}) [string replace $::array_streams_total_streams_label(${key1_test_no}) $loc [expr $loc + $len - 1] $sta_connection_type]
						UTF::Message INFO "" "After:  $::array_streams_total_streams_label(${key1_test_no})"

						return $sta_connection_type
					}
				}
			}

			if {$sta_connection_type != ""} {
				return $combo_type
			}
		}
	}
}

proc sts::setup_tests_ping_streams {test_cnt} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_ping_streams***************************"

	UTF::Try "Test $test_cnt: Ping Streams" {

		UTF::Message INFO "" "------------------------------------------------------------------------------------"
		UTF::Message INFO "" "Setup array: ::array_ping_streams_*"
		UTF::Message INFO "" "------------------------------------------------------------------------------------"

		set ping_stream_cnt 0
		for {set stream_cnt 1} {$stream_cnt <= $::array_streams_cnt(${test_cnt})} {incr stream_cnt} {

			incr ping_stream_cnt

			UTF::Try "Ping Stream $ping_stream_cnt Data" {
				UTF::Message INFO "" "create ping stream test_cnt=$test_cnt ping_stream_cnt=$ping_stream_cnt data arrays"
				sts::array_setup_ping_stream_data $test_cnt $ping_stream_cnt 0 1 0

				if {$ping_stream_cnt == 1} {
					set ::array_ping_streams_test_cnt $::array_streams_test_cnt
				}

				set ::array_ping_streams_cnt(${test_cnt})                                   $ping_stream_cnt
				set ::array_ping_streams_stream_short_label(${test_cnt},${ping_stream_cnt}) $::array_streams_stream_short_label(${test_cnt},${stream_cnt})
				set ::array_ping_streams_link_type(${test_cnt},${ping_stream_cnt})          $::array_streams_link_type(${test_cnt},${stream_cnt})
				#
				set ::array_ping_streams_src_sta(${test_cnt},${ping_stream_cnt})            $::array_streams_src_sta(${test_cnt},${stream_cnt})
				set ::array_ping_streams_src_host_type(${test_cnt},${ping_stream_cnt})      $::array_streams_src_host_type(${test_cnt},${stream_cnt})
				set ::array_ping_streams_src_ifname(${test_cnt},${ping_stream_cnt})         $::array_streams_src_ifname(${test_cnt},${stream_cnt})
				set ::array_ping_streams_src_ip(${test_cnt},${ping_stream_cnt})             $::array_streams_src_ip(${test_cnt},${stream_cnt})
				set ::array_ping_streams_src_macaddr(${test_cnt},${ping_stream_cnt})        $::array_streams_src_macaddr(${test_cnt},${stream_cnt})
				set ::array_ping_streams_src_ipv6_macaddr(${test_cnt},${ping_stream_cnt})   $::array_streams_src_ipv6_macaddr(${test_cnt},${stream_cnt})
				#
				set ::array_ping_streams_dst_sta(${test_cnt},${ping_stream_cnt})            $::array_streams_dst_sta(${test_cnt},${stream_cnt})
				set ::array_ping_streams_dst_host_type(${test_cnt},${ping_stream_cnt})      $::array_streams_dst_host_type(${test_cnt},${stream_cnt})
				set ::array_ping_streams_dst_ifname(${test_cnt},${ping_stream_cnt})         $::array_streams_dst_ifname(${test_cnt},${stream_cnt})
				set ::array_ping_streams_dst_ip(${test_cnt},${ping_stream_cnt})             $::array_streams_dst_ip(${test_cnt},${stream_cnt})
				set ::array_ping_streams_dst_macaddr(${test_cnt},${ping_stream_cnt})        $::array_streams_dst_macaddr(${test_cnt},${stream_cnt})
				set ::array_ping_streams_dst_ipv6_macaddr(${test_cnt},${ping_stream_cnt})   $::array_streams_dst_ipv6_macaddr(${test_cnt},${stream_cnt})

				sts::array_setup_ping_stream_data $test_cnt $ping_stream_cnt 0 0 1
			}

			if {$::array_streams_traffic_direction(${test_cnt},${stream_cnt}) != "BITX" && $::array_streams_traffic_direction(${test_cnt},${stream_cnt}) != "BIRX"} {
				# add ping stream for the opposite side

				incr ping_stream_cnt

				UTF::Try "Ping Stream $ping_stream_cnt Data" {
					UTF::Message INFO "" "create ping stream test_cnt=$test_cnt ping_stream_cnt=$ping_stream_cnt data arrays"
					sts::array_setup_ping_stream_data $test_cnt $ping_stream_cnt 0 1 0

					set ::array_ping_streams_cnt(${test_cnt})                                   $ping_stream_cnt
					# change direction
					if {[regexp {\->} $::array_streams_stream_short_label(${test_cnt},${stream_cnt})]} {
						regsub {\->} $::array_streams_stream_short_label(${test_cnt},${stream_cnt}) "<\-" ::array_ping_streams_stream_short_label(${test_cnt},${ping_stream_cnt})
					} elseif {[regexp {<\-} $::array_streams_stream_short_label(${test_cnt},${stream_cnt})]} {
						regsub {<\-} $::array_streams_stream_short_label(${test_cnt},${stream_cnt}) "\->" ::array_ping_streams_stream_short_label(${test_cnt},${ping_stream_cnt})
					} 
					set ::array_ping_streams_link_type(${test_cnt},${ping_stream_cnt})          $::array_streams_link_type(${test_cnt},${stream_cnt})
					#
					set ::array_ping_streams_src_sta(${test_cnt},${ping_stream_cnt})            $::array_streams_dst_sta(${test_cnt},${stream_cnt})
					set ::array_ping_streams_src_host_type(${test_cnt},${ping_stream_cnt})      $::array_streams_dst_host_type(${test_cnt},${stream_cnt})
					set ::array_ping_streams_src_ifname(${test_cnt},${ping_stream_cnt})         $::array_streams_dst_ifname(${test_cnt},${stream_cnt})
					set ::array_ping_streams_src_ip(${test_cnt},${ping_stream_cnt})             $::array_streams_dst_ip(${test_cnt},${stream_cnt})
					set ::array_ping_streams_src_macaddr(${test_cnt},${ping_stream_cnt})        $::array_streams_dst_macaddr(${test_cnt},${stream_cnt})
					set ::array_ping_streams_src_ipv6_macaddr(${test_cnt},${ping_stream_cnt})   $::array_streams_dst_ipv6_macaddr(${test_cnt},${stream_cnt})
					#
					set ::array_ping_streams_dst_sta(${test_cnt},${ping_stream_cnt})            $::array_streams_src_sta(${test_cnt},${stream_cnt})
					set ::array_ping_streams_dst_host_type(${test_cnt},${ping_stream_cnt})      $::array_streams_src_host_type(${test_cnt},${stream_cnt})
					set ::array_ping_streams_dst_ifname(${test_cnt},${ping_stream_cnt})         $::array_streams_src_ifname(${test_cnt},${stream_cnt})
					set ::array_ping_streams_dst_ip(${test_cnt},${ping_stream_cnt})             $::array_streams_src_ip(${test_cnt},${stream_cnt})
					set ::array_ping_streams_dst_macaddr(${test_cnt},${ping_stream_cnt})        $::array_streams_src_macaddr(${test_cnt},${stream_cnt})
					set ::array_ping_streams_dst_ipv6_macaddr(${test_cnt},${ping_stream_cnt})   $::array_streams_src_ipv6_macaddr(${test_cnt},${stream_cnt})

					sts::array_setup_ping_stream_data $test_cnt $ping_stream_cnt 0 0 1
				}
			}
		}
	}
}

proc sts::setup_tests_items {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests_items***************************"

	UTF::Message INFO "" "------------------------------------------------------------------------------------"
	UTF::Message INFO "" "Setup array: ::array_streams_*"
	UTF::Message INFO "" "------------------------------------------------------------------------------------"

	#####################################################
	# remove space,tab,CR and break all the tests to test groups
	#####################################################
	regsub -all {[\n]} $(tests) "" all_tests
	regsub -all {[\r]} $all_tests "" all_tests
	regsub -all {[\t]} $all_tests "" all_tests
	regsub -all {'} $all_tests "" all_tests
	regsub -all {"} $all_tests "" all_tests
	regsub -all {\\} $all_tests "" all_tests
	# remove empty element
	regsub -all {\{\}} $all_tests "" all_tests
	set all_tests [string trim $all_tests]
	
	UTF::Message INFO "" "all_tests='$all_tests'"

	UTF::Message INFO "" "------------------------loop all_tests---------------------------"

	set test_cnt 0
	
	while {$all_tests != ""} {
	
		# first match of the test set items seperated by "|"
		set rc [regexp {(.*?)\|} $all_tests match test_items]
		if {$rc == 0} {
			# last test set items
			set test_items $all_tests
			set all_tests ""
		} else {
			# remove this test_items from the all_tests
			regsub {.*?\|} $all_tests "" all_tests
		}
		
		incr test_cnt
		
		UTF::Try "Test $test_cnt: $test_items" {

			UTF::Message INFO "" "test_items='$test_items'"

			set stream_cnt 0

			while {$test_items != ""} {
	
				# first match of the test item seperated by "]"
				set rc [regexp {\[(.*?)\]} $test_items match test_item]
				# remove this test_item from the test_items
				regsub {\[.*?\]} $test_items "" test_items

				# 1st byte of the test item is the test type
				regexp {(.)} $test_item match test_type

				switch $test_type {

					L {
						# Link
						sts::setup_test_add_sta_link $test_item
					}

					S {
						# Stream
						# check for bi-directional traffic
						# T1:L1:UDP:VI:BI:0:300
						set rc [regexp {.*?:.*?:.*?:.*?:(.*?):.*?:.*$} $test_item match stream_traffic_direction]
						if {$stream_traffic_direction == "BI"} {
							UTF::Message INFO "" "Expand bidirectional stream '$test_item'"
							# "BIRX"
							regsub {:BI:} $test_item ":BIRX:" new_test_item
							incr stream_cnt
							sts::setup_test_stream $test_cnt $stream_cnt $new_test_item
							# "BITX"
							regsub {:BI:} $test_item ":BITX:" new_test_item
							incr stream_cnt
							sts::setup_test_stream $test_cnt $stream_cnt $new_test_item
						} else {
							incr stream_cnt
							sts::setup_test_stream $test_cnt $stream_cnt $test_item
						}
					}

					R {
						# Link Remove
						sts::setup_test_remove_link $test_item
					}
					
					default {
						incr ::error_cnt
						error "ERROR: 'Invalid test_type=$test_type. Halting tests!" 
					}
				}
			}

			# kevin check array_streams_total_streams_label
			append ::array_streams_total_streams_label(${test_cnt}) "\]"
			UTF::Message INFO "" "::array_streams_total_streams_label(${test_cnt})            ='$::array_streams_total_streams_label(${test_cnt})'"

			sts::setup_tests_streams_plot_colors $test_cnt

			sts::setup_tests_streams_sta_config $test_cnt

			if {$(nan1)} {
				UTF::Try "Special NAN 1.0 Test" {
					UTF::Message INFO "" "This is a special NAN 1.0 test and test setup will happen dynamically when running each test case."
				}
			}

			#####################################################
			######      Figure out Control Chart Key        #####
			#####################################################

			set all_streams_new_label ""
			regsub -all { } $::array_streams_total_streams_label(${test_cnt}) "" all_streams_new_label
			regsub -all {\->} $all_streams_new_label "2" all_streams_new_label
			regsub -all {<\-} $all_streams_new_label "3" all_streams_new_label
			regsub -all {<>} $all_streams_new_label "1" all_streams_new_label
			regsub -all {:} $all_streams_new_label "-" all_streams_new_label

			set STA [lindex $(sta) 0]
			set branch [$STA branchname]
			set control_chart_base_key "$branch StSNightly $::array_streams_ap(${test_cnt}) $::vsdb_mode $::vsdb_bw_percentage $(pm_mode) $(qos_ampdu_mode) $(fb) A=$::curr_attn_value $all_streams_new_label"
			set ::array_streams_control_chart_base_key(${test_cnt}) "$control_chart_base_key"

			for {set stream_no 1} {$stream_no <= $::array_streams_cnt(${test_cnt})} {incr stream_no} {

				set stream_new_label ""
				regsub -all { } $::array_streams_stream_label(${test_cnt},${stream_no}) "" stream_new_label
				regsub -all {\->} $stream_new_label "2" stream_new_label
				regsub -all {<\-} $stream_new_label "3" stream_new_label
				regsub -all {<>} $stream_new_label "1" stream_new_label
				regsub -all {:} $stream_new_label "-" stream_new_label

				set control_chart_stream_key "$stream_new_label $::array_streams_link_type(${test_cnt},${stream_no}) $::array_streams_link_security(${test_cnt},${stream_no}) $::array_streams_bandwidth(${test_cnt},${stream_no}) $::array_streams_packet_size(${test_cnt},${stream_no})"

				set ::array_streams_control_chart_key(${test_cnt},${stream_no}) "$control_chart_base_key $control_chart_stream_key"
			}

			sts::setup_tests_ping_streams $test_cnt
			
			UTF::Message INFO "" "------------------------loop 2 streams_test_name done---------------------------"
		}
	}

	UTF::Message INFO "" "------------------------loop 1 all_tests done---------------------------"
}

proc sts::setup_tests {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_tests***************************"

	# Examples of the data:
	# all_tests='{[i1:i2:8:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]} {[i1:i2:8:P2P:TCP:BE:TX:0:60][i1:i2:8:APSTA:UDP:BE:TX:0:60]}'
	# streams_org_test_name='[i1:i2:8:APSTA:TCP:BE:BI:0:60][i1:i2:149/80:P2P:TCP:BE:BI:0:60]'
	# streams_test_name='i1:i2:8:APSTA:TCP:BE:BIRX:0:60 i2:i1:8:APSTA:TCP:BE:BITX:0:60 i1:i2:149/80:P2P:TCP:BE:BIRX:0:60 i2:i1:149/80:P2P:TCP:BE:BITX:0:60'
	# total_streams_label='[AP<>STA (8)][GO<>GC (149/80)]'

	sts::all_data_array_delete
	sts::setup_tests_controller
	sts::setup_tests_ap
	sts::setup_tests_sta

	sts::setup_tests_items
}

proc sts::setup_ap_security {AP link_security} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_ap_security $AP***************************"

	# check for 2g:5g param
	set AP [split $AP ":"]
	set AP [lindex $AP 0]
	set AP5G [lindex $AP end]

	set ap_host_type [$AP hostis]

	if {$ap_host_type == "Router"} {		
		set soft_ap_flag 0
	} else {
		set soft_ap_flag 1
	}

	UTF::Try "$AP Security '$link_security'" {
		if {$soft_ap_flag == 0 && $AP != $AP5G} {
			UTF::Test::APConfigureSecurity $AP5G -security $link_security
		}
		UTF::Test::APConfigureSecurity $AP -security $link_security
		set temp [$AP cget -security]

		UTF::Message INFO "" "Security is $temp"
		set temp "<font color=\"blue\"><b>$temp Security</b></font>"
		return "html: $temp"
	}
}

proc sts::sta_defaults {STA sta_num} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:sta_restore_defaults***************************"

	set sta_model ""
	set sta_osver ""

	$STA services stop
	catch {$STA wl msglevel +error +assoc}
	if {![$STA cget -nomimo_bw_cap] && !$(nan1)} {
		catch {$STA wl down}
		# Enable 40 in 2.4, if available.
		# Doesn't work for LMAC since LMAC is never "down"
		catch {$STA wl -u mimo_bw_cap 1}

		catch {$STA wl ampdu $(qos_ampdu_mode)}

		catch {$STA wl up}
		UTF::Sleep 1
	}

	$STA wl ver

	set what [$STA whatami]
	# Pull out chip info and replace whitespace to
	# make it easier for external parsers.
	regsub -all {\s+} [lreplace $what 0 0] {_} w

	if {$(nostaload)} {
		$UTF::Summary header $STA $w
	} else {
		$UTF::Summary header_update 1 $w
	}
	$STA dbrecord DUT

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "" "::UTF::panic=$::panic_msg"
		error $::panic_msg
	} else {
		UTF::Message INFO "" "NO ::UTF::panic"
	}
	
	return $what
}


#################################################################################
#################################################################################
#                                  M A I N
#################################################################################
#################################################################################
UTF::Test StSNightly {args} {
	global env

	# Basic command line option processing. Options are stored in the
	# unnamed array $()
	UTF::Getopts "$::sts_getopts" "$::sts_help"

	set today [join [clock format [clock seconds] -format "%Y %N %e"] .]

	# If necessary, override the config file log directory setting.
	if {$(logdir) != ""} {
		set UTF::SummaryDir $(logdir)
		UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
	}

	if {$(nocache)} {
		set ::UTF::ControlChart::readonly 1
		set ::UTF::MemChart::readonly 1
	}

	if {$(debug_flag)} {
		set ::debug_flag 1
	} else {
		set ::debug_flag 0
	}

	if {$(socram_dump_flag)} {
		set ::socram_dump_flag 1
	} else {
		set ::socram_dump_flag 0
	}

	if {$(kpi_flag)} {
		set ::kpi_test_flag 1
	} else {
		set ::kpi_test_flag 0
	}
	
	if {$(macos_pcap_flag)} {
		set ::macos_pcap_debug_flag 1
	} else {
		set ::macos_pcap_debug_flag 0
	}

	if {$(scan_flag)} {
		set ::scan_test_flag 1
	} else {
		set ::scan_test_flag 0
	}

	if {$(escan_flag)} {
		set ::escan_test_flag 1
	} else {
		set ::escan_test_flag 0
	}

	if {$(graphs_with_min_max)} {
		set ::graphs_with_min_max 1
	} else {
		set ::graphs_with_min_max 0
	}	

	set ::vsdb_mode $(vsdb_mode)	
	set ::vsdb_bw_percentage $(vsdb_bw_percentage)

	set ::rsdb_mode $(rsdb_mode)	

	if {$(rsdb_switch_test)} {
		set ::rsdb_switch_test_flag 1
	} else {
		set ::rsdb_switch_test_flag 0
	}	

	if {$(channel_sweep_test)} {
		set ::channel_sweep_test_flag 1
	} else {
		set ::channel_sweep_test_flag 0
	}	

	set ::mpc_mode $(mpc_mode)	

	set ::base_timestamp_tick [clock scan "00:00:00"]
	UTF::Message INFO "" "::base_timestamp_tick=$::base_timestamp_tick"

	if {$(roam_src_ap) != "" && $(roam_dst_ap) != ""} {
		UTF::Message INFO "" "Roaming test"
		set (ap) $(roam_src_ap)
		set ::roaming_test_flag 1
		set (ap_chan) "36l"
		set (sts_chan) "3"

		if {$(sniffer) == ""} {
			error "Sniffer parameter is missing. Halting tests!"
		}
	}

	if {$(sniffer) != ""} {
		set ::sniffer_object $(sniffer)

		set linuxver [$::sniffer_object rexec uname -r]
		if {![string match -nocase "*FC15*" $linuxver] && ![string match -nocase "*FC19*" $linuxver]} {
			error "Invalid Sniffer OS. Only FC15 or FC19 with BRCM wireshark is supported. Halting tests!"
		} else {
			if {[string match -nocase "*FC19*" $linuxver]} {
				UTF::Message INFO "" "Sniffer is FC19"
			} else {
				UTF::Message INFO "" "Sniffer is FC15"
			}
		}
		
		if {$::roaming_test_flag == 0} {
			if {$(sniffer_channel) == ""} {
				error "ERROR: parameters sniffer_channel is blank. Halting tests!"
			}
			if {$(sniffer_capture_time_sec) == ""} {
				error "ERROR: parameters sniffer_capture_time_sec is blank. Halting tests!"
			}

			set ::sniffer_channel $(sniffer_channel)
			set ::sniffer_capture_time_sec $(sniffer_capture_time_sec)
		}
    }

	set ::ping_count $(ping_count)
	set ::gnuplot_font $(gnuplot_font)
	set ::gnuplot_font_size $(gnuplot_font_size)
	set ::rvr_attn_incr $(rvr_attn_incr)
	set ::testbed_path_loss $(testbed_path_loss)
	
	set ::perfint $(perfint)

	if {$(measure_current_sta) != ""} {
		UTF::Message LOG "" "***Current Measurement Option***"
		
		# Get the Agilent object and port number
		set power_sta [$(measure_current_sta) cget -power_sta]
		set power_sta [string trim $power_sta]
		set fields [split $power_sta " "]
		set ::agilent_obj [lindex $fields 0]
		set ::agilent_port [lindex $fields 1]

		if {$::agilent_obj == "" || $::agilent_port == ""} {
			error "ERROR: Agilent setting and association with STA is not correct in the UTF config file. Halting tests!"
		}
		
		set ::voltage [$::agilent_obj cget -voltage]

		UTF::Message LOG "" "::agilent_obj=$::agilent_obj"
		UTF::Message LOG "" "::agilent_port=$::agilent_port"
		UTF::Message LOG "" "::voltage=$::voltage"
		
		# current_measure_time = current_sample_time * current_sample_points -> 100E-6 * 50000 = 5 seconds
		# current_measure_time = current_sample_time * current_sample_points -> 300E-6 * 50000 = 15 seconds
		set ::current_measure_time [expr {$(current_sample_time) * $(current_sample_points)}]
		UTF::Message LOG "" "::current_measure_time=$::current_measure_time"
	}

	##########################################################################################

	# Override default tags
	if {$(trx) ne ""} {
		foreach AP $(ap) {
			$AP configure -image $(trx) -date {}
		}
	} elseif {$(aptag) ne ""} {
		foreach AP $(ap) {
			$AP configure -tag $(aptag) -date {}
		}
	}
	if {$(apdate) ne "" && $(ap) ne ""} {
		foreach AP $(ap) {
			$AP configure -date $(apdate)
		}
	} else {
		set (apdate) $today
	}

	######################################################################
	##############    loading DHD and FW Private Image    ################
	##############    loading Specific DHD Date Image     ################
	######################################################################

	# Firmware loading rules:
	#	wl.ko for 43236 is the stadhd parameter -> 'stabin=rtecdc.bin.trx' and 'stadhd=wl.ko'
	#	wl.ko for 43224 is the stabin parameter -> 'stabin=wl.ko'

	foreach sta $(sta) {
	
		set sta_host_type [$sta hostis]
		UTF::Message LOG "" "$sta host_type=$sta_host_type"

		# DHD
		if {$sta_host_type == "DHD" || $sta_host_type == "Panda"} {
			if {$(stadhd) ne ""} {
				$sta configure -dhd_image $(stadhd)
				UTF::Message LOG "" "$sta DHD ko image from -> $(stadhd)" 		
			}

			if {$(stadhddate) ne ""} {
				$sta configure -dhd_date $(stadhddate)
				UTF::Message LOG "" "$sta DHD ko dated image from -> $(stadhddate)" 		
			}
		}

		# FW
		if {$(stabin) ne ""} {
			$sta configure -image $(stabin) -date {}
			UTF::Message LOG "" "$sta FW image from -> $(stabin)" 
		}
	}

	######################################################################
	
	if {$(statag) ne ""} {
		foreach STA $(sta) {
			$STA configure -tag $(statag) -date {}
		}
	}
	
	if {$(stadate) ne ""} {
		foreach STA $(sta) {
			$STA configure -date $(stadate)
		}
		unset STA
	} else {
		set (stadate) $today
	}

	# Compact build list for title
	set build [UTF::BuildTitle [lindex $(sta) 0]]

	if {$(title) eq ""} {
		if {[$STA hostis WinDHD Cygwin]} {
			set (title) [$STA host whatami]
		} elseif {[$STA hostis LMAC DHD]} {
			set (title) "Linux Dongle"
		} else {
			set (title) [$STA hostis]
		}

		if {[regexp {(\d+sd)} $(ap) - c]} {
			append (title) " with $c AP"
		}
	}

    set test_name [file tail $::argv0]
    set test_name [file rootname $test_name]

	set tmp "$(title) "

	if {$::agilent_obj != ""} {
		set tmp_current "Current Measurement "
	} else {
		set tmp_current ""
	}

	if {$(pm_mode) != "" && !$(nan1)} {
		set tmp_pm "PM=$(pm_mode) "
	} else {
		set tmp_pm ""
	}

	if {$::mpc_mode != ""} {
		set tmp_mpc "MPC=$::mpc_mode "
	} else {
		set tmp_mpc ""
	}	

	if {$::rsdb_mode != ""} {
		set tmp_rsdb "RSDB=$::rsdb_mode "
	} else {
		set tmp_rsdb ""
	}	

	append tmp "$tmp_mpc$tmp_rsdb$tmp_pm$tmp_current$test_name"
	
	set TITLE "UTF $tmp ($build)"	
	UTF::Message INFO "" $TITLE

	# $build is used in the title.  For private builds this will
	# indicate special images.

	# (branch) is used for comparison over time.  For private builds
	# this should be specified explicitly so the tests know which
	# branch to test.

	if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
		error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
	}
	unset build

	# Truncate build name for performance keys
	regsub {_.*} $(branch) {} (branch)

	UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {

		if {$::kpi_test_flag} {
			set ::UTF::__tryid "auto"
			UTF::Message INFO "" "Setup KPI Base XML data"  
			set ::kpi_base_db [UTF::KPI::KeyValue Base]
			# add the metascriptid, sessionid, and summaryurl to the KPI Base 
			UTF::Message INFO "" "$::kpi_base_db set -exclude 'metascriptid' meta sessionid '::UTF::SessionID' summaryurl 'UTF::Summary base']"  
			$::kpi_base_db set -exclude "metascriptid" meta sessionid "$::UTF::SessionID" summaryurl [$UTF::Summary base]
		} else {
			set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]
		}

		set ::logdir [file dirname $UTF::Logfile]

		# Need gnuplot 4.2 or higher for image heatmaps.
		set ::gnu_ver [UTF::GnuplotVersion]
		if {$::gnu_ver < 4.2} {
			UTF::Message ERROR "" "gnuplot $::gnu_ver is installed instead of 4.2 or higher which is needed for image heatmaps"
			error "gnuplot $::gnu_ver is old. Halting tests!"
		}
		UTF::Message INFO "" "gnuplot version=$::gnu_ver"  

		if {$::agilent_obj != ""} {
			UTF::Try "Setup Agilent" {
				set rc [$::agilent_obj set_voltage $::agilent_port $::voltage]
				if {$rc != 0} {
					incr ::error_cnt
					error "Failed to set Agilent voltage"
				} else {
					UTF::Message INFO "" "Reboot STA $(measure_current_sta)"					
					$(measure_current_sta) power cycle
					UTF::Sleep 60
					UTF::Message INFO "" "Agilent RST is issued and STA $(measure_current_sta) is rebooted"					
					return "$::voltage V (STA $(measure_current_sta) is rebooted)"
				}				
			}
			
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}

		if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
			UTF::Try "Setup testbed" {
				if {$(ap) != ""} {
					# check for 2g:5g param
					set AP [split $(ap) ":"]
					set AP2G [lindex $AP 0]
					
					set catch_resp [catch "[$AP2G cget -attngrp] attn 95" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						set ::max_attn 95
					} else {
						set ::max_attn 63
					}
				}
				UTF::Message LOG "" "::max_attn=$::max_attn"
				eval $::UTF::SetupTestBed
			}
		}

		#####################################################
		##############    Setup Multicore    ################
		#####################################################
		if {$(multicore_mode) != ""} {
			sts::setup_multicore
		}

		#####################################################
		############    Setup Mac Radio On    ###############
		#####################################################
		sts::setup_mac_radio_on

		if {[lindex $(ap) 0] != ""} {

			set ap_num 0
			foreach AP $(ap) {
				# check for 2g:5g param
				set AP [split $AP ":"]
				set AP [lindex $AP 0]
				
		    	incr ap_num
				if {!$(noapload)} {
					UTF::Try "$AP: Find AP Image" {
						UTF::CheckImage $AP $(apdate) unknown
					}

					UTF::Try "$AP: Load Image" {
						if {[$AP hostis Router Vx BSDAP DSL Airport]} {
							if {[catch {$AP lan ifconfig [$AP lan cget -ipaddr]}]} {
								$AP lan ifconfig 192.168.1.50
							}
						}
						$AP load
					}

					UTF::ReportDriver $AP $(apdate)
					
				}  elseif {[$AP hostis Linux]} {
					UTF::Try "$AP: reload" {
						$AP reload
					}
				}

				if {!$(norestore)} {
					UTF::Try "$AP: Restore Defaults" {
						if {[$AP hostis Router Vx BSDAP DSL Airport]} {
							$AP restore_defaults
						} else {
							$AP services stop
							if {[info exists ::UTF::Use11h]} {
								catch {$AP wl msglevel +error +assoc +regulatory}
							} else {
								catch {$AP wl msglevel +error +assoc}
							}

							if {![$AP cget -nomimo_bw_cap]} {
								catch {$AP wl down}
								# Enable 40 in 2.4, if available.
								if {[catch {$AP wl bw_cap 2 -1}]} {
									$AP wl -u mimo_bw_cap 1
								}
								$AP wl up
								UTF::Sleep 1
							}
						}

						set what [$AP whatami]
						# Pull out chip info and replace whitespace to make it
						# easier for external parsers.
						regsub -all {\s+} [lreplace $what 0 0] {_} w

						if {$(noapload)} {
							$UTF::Summary header $AP $w
						} else {
							$UTF::Summary header_update 1 $w
						}

						$AP dbrecord REF

						if {$::kpi_test_flag} {
							$::kpi_base_db set "apheader$ap_num" "$w"
							array set db [$AP dbget]
							foreach item [array names db] {
								UTF::Message LOG "" "apheader$ap_num\_$item=$db($item)"
								$::kpi_base_db set "apheader$ap_num\_$item" "$db($item)"
							}
						}
						
						set what
					}
				}
				
				sts::setup_ap_security $AP open
			}
		} else {
			# Direct P2P with no AP
			if {$::kpi_test_flag} {
				$::kpi_base_db set "apheader" "N/A"
			}
		}
		
		# Load the STAs if required.		
		set sta_num 0
		foreach STA $(sta) {

		    incr sta_num
			if {$(branch) eq "auto"} {
				set branch [$STA branchname]
			} else {
				set branch $(branch)
			}

			# Find images
			if {!$(nostaload)} {
				UTF::Try "$STA Find STA Image" {
					UTF::CheckImage $STA $(stadate) unknown
				}
			}

			if {!$(nosetup)} {
				if {$(nostaload)} {
					if {!$(nostareload)} {
					
						# retry is needed since sometimes the STA load fails and a reboot is needed
						for {set retry_load_cnt 0} {$retry_load_cnt < 3} {incr retry_load_cnt} {

							set reboot_flag 0

							UTF::Try "$STA reload" {
								set catch_resp [catch {$STA reload} catch_msg]
								UTF::Message INFO "" "Reload STA catch_resp=$catch_resp catch_msg=$catch_msg"
								if {$catch_resp != 0} {
									set reboot_flag 1
									error "Reload Failed: '$catch_msg'"
								} else {
									return "$catch_msg"
								}
							}

							if {$reboot_flag == 0} {
								UTF::Try "$STA defaults" {
									set catch_resp [catch {sts::sta_defaults $STA $sta_num} catch_msg]
									UTF::Message INFO "" "STA defaults catch_resp=$catch_resp catch_msg=$catch_msg"
									if {$catch_resp != 0} {
										set reboot_flag 1
										error "Defaults Failed: '$catch_msg'"
									} else {
										return "$catch_msg"
									}
								}
							}

							if {$reboot_flag == 1} {
								UTF::Try "Issue - Reboot STA $STA" {
									UTF::Message INFO "" "=========================================================================="
									UTF::Message INFO "" "Reboot the STA $STA with issue"
									$STA power off
									UTF::Sleep 5
									$STA power on
									UTF::Sleep 60
								}
							} else {
								break
							}
						}
					}
				} else {
					
					# retry is needed since sometimes the STA load fails and a reboot is needed
					for {set retry_load_cnt 0} {$retry_load_cnt < 3} {incr retry_load_cnt} {

						set load_err_flag 0
						set reboot_flag 0

						UTF::Try "$STA load" {
							set catch_resp [catch {$STA load} catch_msg]
							UTF::Message INFO "" "Load STA catch_resp=$catch_resp catch_msg=$catch_msg"
							if {$catch_resp != 0} {
								set load_err_flag 1
								if {[regexp -nocase {No matching images} $catch_msg]} {
									# no retry since the image is not found
									set retry_load_cnt 3
								} else {
									set reboot_flag 1
								}
								error "Load Failed: '$catch_msg'"
							} else {
								return "$catch_msg"
							}
						}

						if {$load_err_flag == 0} {
							UTF::Try "$STA defaults" {
								set catch_resp [catch {sts::sta_defaults $STA $sta_num} catch_msg]
								UTF::Message INFO "" "STA defaults catch_resp=$catch_resp catch_msg=$catch_msg"
								if {$catch_resp != 0} {
									set reboot_flag 1
									error "Defaults Failed: '$catch_msg'"
								} else {
									return "$catch_msg"
								}
							}
						}

						if {$reboot_flag == 1} {
							#####################################################
							#############   sta_dhd_socram_dump   ###############
							#####################################################
							sts::sta_dhd_socram_dump $STA
						
							UTF::Try "Issue - Reboot STA $STA" {
								UTF::Message INFO "" "=========================================================================="
								UTF::Message INFO "" "Reboot the STA $STA with issue"
								$STA power off
								UTF::Sleep 5
								$STA power on
								UTF::Sleep 60
							}
						} else {
							break
						}
					}
					
					UTF::ReportDriver $STA $(stadate)
				}

				if {$::kpi_test_flag} {
					UTF::Try "$STA Model/OS" {

						set what [$STA whatami]
						# Pull out chip info and replace whitespace to
						# make it easier for external parsers.
						regsub -all {\s+} [lreplace $what 0 0] {_} w

						$::kpi_base_db set "staheader$sta_num" "$w"

						# STA Model/OS
						set sta_osver [$STA os_version]
						catch {$STA lan rexec system_profiler -timeout 30 -detailLevel mini} output
						set sta_model "unknown"
						foreach line [split $output "\n"] {
							if {[regexp {Model Identifier:\s+(.*)} $line - sta_model]} {
								break
							}
						}
						UTF::Message LOG "" "staheader$sta_num\_modelID=$sta_model"
						$::kpi_base_db set "staheader$sta_num\_modelID" "$sta_model"
						UTF::Message LOG "" "staheader$sta_num\_os_version=$sta_osver"
						$::kpi_base_db set "staheader$sta_num\_os_version" "$sta_osver"

						array set db [$STA dbget]
						foreach item [array names db] {
							UTF::Message LOG "" "staheader$sta_num\_$item=$db($item)"
							$::kpi_base_db set "staheader$sta_num\_$item" "$db($item)"
						}

						return ${sta_model}/${sta_osver}
					}
				}

				# for rte, you can do "$STA rte mu" to get the memory usage
				if {!$(nostaload) && [$STA rte_available]} {
					UTF::Try "$STA: Free Memory After Load (K)" {
						# retry is needed due to issues with NPC serial port
						for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
							set catch_resp [catch "$STA freekb" catch_msg]
							UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
							if {$catch_resp == 0} {
								break
							}
						}

						if {$catch_resp == 1} {
							error $catch_msg							
						}

						set ret_val [format "%.7f" $catch_msg]
						UTF::Test::memchart $ret_val -failonlow -key [list $branch $STA loadfree] -units kb -title "Load Free"
					}
				}
			}
		}

		# If there are any STA that didnt load, halt the script.
		# We must have all devices functioning properly in the test rig.
		if {$::error_cnt > 0} {
		
			#####################################################
			##############   Unload STA driver   ################
			#####################################################
			sts::unload_sta_driver

			error "Halting tests!"
		}

		##################################################################
		#
		#	StS tests start here
		#
		##################################################################

		#########################################
		# Check for existing DHD Memory Dump from previous tests
		#########################################
		sts::get_dhd_memory_dump

		if {$::debug_flag == 1} {
			UTF::Try "DEBUG ENABLE" {
				$sta_name wl assert_type 1
				$sta_name wl msglevel +assoc +apsta +ampdu
			}
		}

		#########################################
		# Setup MPC
		#########################################
		if {$::mpc_mode != ""} {
			sts::setup_mpc
		}

		#########################################
		# Setup RSDB
		#########################################
		if {$::rsdb_mode != ""} {
			sts::setup_rsdb
		}

		#########################################
		# Enable NTP
		#########################################
		if {$(enable_ntp)} {
			sts::enable_ntp
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}
		
		#########################################
		# Check NTP
		#########################################
		sts::check_ntp
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#####################################################
		##################  Setup Tests  ####################
		#####################################################
		UTF::Try "Setup Tests" {
			sts::setup_tests
		}
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#########################################
		# Setup iperfs
		#########################################
		sts::setup_iperfs
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#########################################
		# Setup BT
		#########################################
		sts::bt_setup
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#####################################################
		############### Setup STAs APSTA PM #################
		#####################################################
		if {$(pm_mode) != "" && !$(nan1)} {
			UTF::Try "Setup APSTA PM $(pm_mode)" {
			
				# APSTA PM mode should not be set on SoftAP
				
				foreach STA $(sta) {
					UTF::Message INFO "" "************************STA=$STA***************************"
					catch {$STA wl dtim}
					catch {$STA wl PM}
					catch {$STA wl PM $(pm_mode)}
					UTF::Sleep 3
					set catch_resp [catch {$STA wl PM} catch_msg]
					if {$catch_msg != $(pm_mode)} {
						error "PM mode is not $(pm_mode)"
					}
				}
				
				return "PM $(pm_mode)"
			}
		}

		if {$::agilent_obj != ""} {
			#####################################################
			################     Setup CCT      #################
			#####################################################
			sts::setup_cct
		}

		if {$(nan1)} {
			#####################################################
			################    Run NAN Test    #################
			#####################################################
			sts::run_nan1_test
		} elseif {$(aibss)} {
			#####################################################
			################   Run AIBSS Test   #################
			#####################################################
			sts::run_aibss_test
		} elseif {$(11mc)} {
			#####################################################
			###############    Run 11mc Test    #################
			#####################################################
			sts::run_11mc_test
		} else {
			#####################################################
			##############    Process All Tests   ###############
			#####################################################
			if {$::roaming_test_flag == 0} {
				sts::process_all_tests
			} else {
				sts::process_all_roaming_tests
			}
		}

		#####################################################
		#############   Channel Switch Time   ###############
		#####################################################
		catch {sts::channel_switch_time}

		#####################################################
		#############     Get Beacon Rate     ###############
		#####################################################
		catch {sts::get_beacon_rate}

		#####################################################
		#############       Link Cleanup      ###############
		#####################################################
		catch {sts::link_cleanup}

		#####################################################
		#############   get_dhd_memory_dump   ###############
		#####################################################
		sts::get_dhd_memory_dump

		#####################################################
		#################   Leak Check   ####################
		#####################################################
		catch {sts::leak_check}

		#####################################################
		##############   Unload STA driver   ################
		#####################################################
		if {!$(nounload)} {
		
			sts::unload_sta_driver

			if {$::agilent_obj != ""} {
				UTF::Try "Current Measurement (No Driver)" {
					UTF::Sleep 2
					set ::cct_key "No Driver"
					sts::measure_idle_current					
					return "html: $::current_results"
				}
			}
		}

		#####################################################
		#############   get_dhd_memory_dump   ###############
		#####################################################
		sts::get_dhd_memory_dump

		PreservedReport

	# End of code block for UTF::WrapSummary
	}
}
