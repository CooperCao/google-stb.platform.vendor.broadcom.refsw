#!/bin/env utf
# -*-tcl-*-

# UTF script to find goodput of multiple clients
# zhuj
# $Copyright Broadcom Corporation$
#
package require UTF
package require UTF::Test::TrafficScheduling
package require UTF::Test::PacketLoss
package provide UTF::Test::Goodput 2.0

namespace eval UTF::Test::Goodput {
    proc _DumpCallback {} {
    }
    proc add_lines {gtitle xtitle ytitle} {
	set procname [namespace tail [lindex [info level 0] 0]]
	set dir [file nativename [file dir $UTF::Logfile]]
    }
    proc plot_goodput {csvfile graphsize} {

	set procname [namespace tail [lindex [info level 0] 0]]
	set dir [file nativename [file dir $UTF::Logfile]]
	if {![file exists "$dir/$csvfile"]} {
	    error "$procname ERROR: file $dir/$csvfile not found"
	}
	if {[catch {set csvhandle [open $dir/$csvfile r]} err]} {
	    error "$procname ERROR: $err"
	}
	# Define gnuplopt style values to use. See gnuplot manual for more details of parameters.
	set lt0 0 ;# line type 0 - dashed grey
	set lt1 1 ;# line type 1 - solid light red
	set lt2 2 ;# line type 2 - olid light green
	set lt3 3 ;# line type 3 - solid light blue
	set lt4 4 ;# line type 4 - solid light purple
	set lt5 5 ;# line type 5 - solid aqua
	set lt6 6 ;# line type 6 - solid brown
	set lt7 7 ;# line type 7 - solid yellow
	set lt8 8 ;# line type 8 - solid dark blue
	set lt9 9 ;# line type 9 - solid gold
	set lt10 10 ;# line type 10 - solid dark green
	set lt11 11 ;# line type 11 - solid dark purple
	set lt12 12 ;# line type 12 - solid dark brown
	set lt13 13 ;# line type 13 - solid light pink
	set lt14 14 ;# line type 14 - solid lime green
	set lt15 15 ;# line type 15 - solid grey blue
	set lt154 154 ;# line type 154 - solid orange

	set linetypes [list $lt1 $lt2 $lt3 $lt4 $lt5 $lt6 $lt7 $lt8 $lt9 $lt10 $lt11 $lt12 $lt13 $lt14 $lt15 $lt154]
	set lw1 1 ;# line width 1 point
	set lw2 2 ;# line width 2 points
	set pt0 0 ;# point type 0 - none
	set pt1 1 ;# point type 1 - horizontal bar
	set pt2 2 ;# point type 2 - x
	set pt4 4 ;# point type 4 - open square
	set pt6 6 ;# point type 6 - open circle
	set pt7 7 ;# point type 7 - solid circle 
	set pt8 8 ;# point type 8 - open triangle
	set ps0 0 ;# point size 0 - none
	set ps1 1 ;# point size 1 - smallest

	#reading data from input csv file into lists
	set xmin 1
	set xmax 1
	set ymin 0
	set ymax 0
	while {![eof $csvhandle]} {
	    set columns [split [gets $csvhandle] ","]

	    #skip column name or other lines not started with a number
	    if {![regexp {^\d+} $columns]} {
		continue
	    }
	    foreach {num_stas multiplier gput tos ap} $columns {
		if {$num_stas > $xmax} {
		    set xmax $num_stas
		}
		if {$gput > $ymax} {
		    set ymax $gput
		} elseif {$gput < $ymin} {
		    set ymin $gput
		}
		lappend cols(num_stas) $num_stas
		lappend cols(multiplier) $multiplier
		lappend cols(gput) $gput
		lappend cols(tos) $tos
		lappend cols(ap) $ap
	    }
	}
	close $csvhandle

	#writing x/y pair into gnuplot data file
	#x-axis is the number of stas, y-axis is the goodput
	set datafilename [file join $dir "goodput.data"]
	if {[catch {set datafile [open $datafilename w]} err]} {
	    error "$procname ERROR: $err"
	}

	#Getting unique ap names and tos bits
	#Preserving the order using dict keys rather than lsort -unique
	foreach element $cols(ap) {
	    dict set tmp $element 1
	}
	set uniqueAps [dict keys $tmp]
	foreach key [dict keys $tmp] {
	    dict unset tmp $key
	}

	foreach element $cols(tos) {
	    dict set tmp $element 1
	}
	set uniqueTos [dict keys $tmp]
	foreach key [dict keys $tmp] {
	    dict unset tmp $key
	}

	#
	set xstart 0
	set xend [expr {$xmax - 1}]
	set coldatanum 0
	set linestylenum 0
	set linestyles {}
	set linetitles {}
	foreach ap $uniqueAps {
	    foreach tos $uniqueTos {
		puts $datafile "#data block AP=$ap TOS=$tos"
		puts $datafile "#NumOfStas    Goodput(Mbits/s)"
		foreach num_stas [lrange $cols(num_stas) $xstart $xend] {
		    puts $datafile "$num_stas [lindex $cols(gput) $coldatanum]"
		    incr coldatanum
		}
		set xstart [expr {$xstart + $xmax}]
		set xend [expr {$xend + $xmax}]
		#gnuplot uses 2 blank lines to distinguish different sections
		puts $datafile ""
		puts $datafile ""
		lappend linestyles "[lindex $linetypes $linestylenum]"
		lappend linetitles "$ap:$tos"
		incr linestylenum
	    }
	    #data collected from different aps are seperated with 2 blank lines
	    puts $datafile ""
	    puts $datafile ""
	}

	close $datafile

	set gpcname "$dir/goodput.gpc"
	set gputpng "$dir/goodput.png"
	set smallgputpng "$dir/goodput_sm.png"
	#set xwidth 4
	if {[catch {set gpchandle  [open $gpcname w]} err]} {
	    error "$procname ERROR: could not open $gpcname $err"
	}
	# Set gnuplot version specific values.
	set gpver [UTF::GnuplotVersion]

	# ==================================================================
	# Create thumbnail sized _sm.png in a separate file. Turn off text labels,
	# border, tics & legend.
	puts $gpchandle "reset"
	puts $gpchandle "set output \"$smallgputpng\""
	if {$gpver > 4.0} {
	    puts $gpchandle "set terminal png size 96,39 notransparent"
	    puts $gpchandle {set tmargin -1; set bmargin -1}
	    puts $gpchandle {set lmargin -1; set rmargin -1}
	} else {
	    puts $gpchandle "set terminal png notransparent"
	    puts $gpchandle"set size 0.15,0.08"
	}
	puts $gpchandle "unset border"
	puts $gpchandle "unset key"
	puts $gpchandle "unset title"
	puts $gpchandle "unset xlabel"
	puts $gpchandle "unset ylabel"
	#puts $gpchandle "unset y2label"
	puts $gpchandle "unset xtics"
	puts $gpchandle "unset ytics"
	# Setting yrange ensures mogrified graph doesnt magnify issues.
	#puts $gpchandle "unset y2tics"
	puts $gpchandle "set yrange \[$ymin:\]"
	puts $gpchandle "unset grid"
	set plotcmd "plot "
	for {set i 0} {$i < $linestylenum} {incr i} {
	    #puts $gpchandle "plot $plot_cmds_sm\n"
	    if {$i > 0} {
		append plotcmd ", "
	    }
	    append plotcmd "'$datafilename' index $i using 1:2 with linespoints"
	    append plotcmd " lt [lindex $linestyles $i] lw $lw2 pt $pt6 ps $ps1"
	}
	puts $gpchandle $plotcmd
	puts $gpchandle "set output '$gputpng'"
	if {$gpver > 4.0} {
	    set xwidth 4
	    puts $gpchandle "set terminal png size $graphsize notransparent medium"
	    puts $gpchandle {set tmargin -1; set bmargin -1}
	    puts $gpchandle {set lmargin -1; set rmargin -1}
	} else {
	    set xwidth 1.9
	    puts $gpchandle "set terminal png notransparent"
	    puts $gpchandle "set size $xwidth,1"
	}
	puts $gpchandle "set title 'UDP Goodput vs Number of STAs'"
	puts $gpchandle "set xlabel 'Number of STAs'"
	puts $gpchandle "set ylabel 'Goodput (Mbits/s)'"
	puts $gpchandle "set key outside below vertical"
	puts $gpchandle "set border"
	puts $gpchandle "set grid"
	puts $gpchandle "set autoscale fix"
	puts $gpchandle "set xrange \[$xmin:$xmax\]"
	puts $gpchandle "set yrange \[$ymin:$ymax\]"
	puts $gpchandle "set xtic 1"
	puts $gpchandle "set ytic auto"
	set plotcmd "plot "
	for {set i 0} {$i < $linestylenum} {incr i} {
	    if {$i > 0} {
		append plotcmd ", "
	    }
	    append plotcmd "'$datafilename' index $i using 1:2 with linespoints"
	    append plotcmd " lt [lindex $linestyles $i] lw $lw2 pt $pt6 ps $ps1 pi -1 title '[lindex $linetitles $i]'"
	}
	puts $gpchandle $plotcmd
	close $gpchandle
	if {[catch {exec $::UTF::Gnuplot "$gpcname"} err]  && ![string match -nocase *warning* $err]\
		&& ![string match -nocase "*font*" $err]} {
	    error "$procname ERROR: gnuplot: $err"
	}
	if {![file exists "$gputpng"]} {
	    error "$procname ERROR: $gputpng file not created, $err"
	}
	if {![file exists "$smallgputpng"]} {
	    error "$procname ERROR: $smallgputpng file not created, $err"
	}
	# Return the .png file.
	UTF::Message INFO "" "$procname: created $gputpng smallgputpng"
	return "$smallgputpng"
    }
}
UTF::Test Goodput { args } {

    UTF::Getopts {
	{ap.arg "" "AP under test"}
	{stas.arg "" "STAs under test"}
	{distances.arg "" "Pairs of attenuation group and value to set"}
	{trx.arg "" "Router private image"}
	{bin.arg "" "STA private image"}
	{date.arg "" "Router Image date"}
	{stadate.arg "" "STA Image date"}
	{build.arg "" "build name"}
	{tag.arg "" "tag override"}
	{dhd_tag.arg "" "dhd tag override"}
	{statag.arg "" "statag override"}
	{title.arg "" "title of report"}
	{email.arg "" "email alias the report sent to"}
	{history.arg "30" "Control Chart history"}
	{nocache "Don't update control chart cache"}
	{direction.arg "DOWN" "traffic direction: up or down"}
	{ltosbits.arg "VO VI BE BK" ""}
	{flows.arg "1" "number of traffic flows per sta"}
	{w.arg "1M" "UDP buffer size"}
	{rate.arg "1G" "offered traffic rate in baseline test"}
	{vorate.arg "500M" "offered traffic rate for access class VO"}
	{holdtime.arg "10" "timer to check traffic"}
	{chanspec.arg {36/80} "List of chanspec to test"}
	{minmultiplier.arg "0.10" "minimum multiplier of maximum tput to find goodput"}
	{maxmultiplier.arg "1.0" "maximum multiplier of maximum tput to find goodput"}
	{step.arg ".01" "the step to change multiplier to find goodput"}
	{graphsize.arg "640,480" "PNG graph size"}
	{noload "not to load AP"}
	{nostaload "not to load STA"}
	{norestore "not to call restore_defaults after loading"}
	{noptp "not to setup ptp"}
	{atf.arg "1" "enable/disable ATF. By default ATF is enabled in driver."}
	{fb.arg "1" "enable/disable frameburst"}
	{modes.arg "" ""}
    }

    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }
    if {![regexp -nocase "UP" $(direction)]  && ![regexp -nocase "DOWN" $(direction)] \
	    && ![regexp -nocase "BIDIR" $(direction)]} {
	error "Invalid traffic direction $(direction). Expecting UP, DOWN or BIDIR."
    }
    foreach t $(ltosbits) {
	if {![regexp -nocase (BE|BK|VI|VO) $t]} {
	    error "Invalid tosbits $t. Expecting list of BK,BE,VI and VO."
	}
    }
    #res used to decide whether to exit the script execution
    set res 0
    set today [join [clock format [clock seconds] -format "%Y %N %e"] .]

    if {$(date) eq ""} {
	set date $today
    } else {
	set date $(date)
    }

    if {$(trx) ne ""} {
	$(ap) configure -image $(trx) -date {}
    } elseif {$(tag) ne ""} {
	$(ap) configure -tag $(tag) -date {}
    }
    if {$(bin) ne ""} {
	foreach STA $(stas) {
	    $STA configure -image $(bin) -date {}
	}
    } elseif {$(statag) ne ""} {
	foreach STA $(stas) {
	    $STA configure -tag $(statag) -date {}
	}
    }
    if {$(dhd_tag) ne ""} {
	foreach STA "$(ap) $(stas)" {
	    if {[$STA hostis DHD]} {
		$STA configure -dhd_tag $(dhd_tag)
	    }
	}
    }

    if {$(date) ne ""} {
	$(ap) configure -date $(date)
	if {[$(ap) hostis DHD]} {
	    $(ap) configure -dhd_date $(date)
	}
    }
    if {$(stadate) ne ""} {
	set stadate $(stadate)
	foreach STA $(stas) {
	    $STA configure -date $(stadate)
	    if {[$STA hostis DHD]} {
		$STA configure -dhd_date $(stadate)
	    }
	}
    } else {
	set stadate $today
    }
    # Compact build list for title
    # Include the WDS list, in case the AP list is empty.  Duplicates
    # will be removed automatically.
    set build [UTF::BuildTitle [concat $(ap) $(stas)]]
    set TITLE "$(title) ($build) (ch=${(chanspec)})"
    UTF::Message INFO "" $TITLE
    unset build

    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	#------------------------------
	#Image Loading
	#------------------------------
	if {!$(noload)} {
	    UTF::Try "[$(ap) cget -name]: Find AP Image" {
		# Locate image and add report header
		UTF::CheckImage $(ap) $date unknown
	    }

	    UTF::Try "[$(ap) cget -name]: Load Image" {
		if {$(norestore)} {
		    $(ap) load
		} else {
		    if {[$(ap) hostis Router]} {
			$(ap) load -erase
		    }
		}
	    }

	    # Bail out rather than continue with whatever happens to
	    # be on the router.
	    if {[$(ap) cget -_path] eq ""} {
		UTF::Message ERROR "" "No image found for AP $(ap),exiting."
		exit 1
	    }
	}
	if {!$(norestore)} {
	    if {[$(ap) hostis Router]} {
		UTF::Try "$(ap): Restore Defaults" {
		    if {$(noload)} {
			$(ap) restore_defaults
		    } else {
			$(ap) restore_defaults -noerase
		    }
		    # Collect HW info and update report header + DB
		    UTF::ReportWhatami $(ap) -role DUT -noload $(noload)
		}
	    } else {
		UTF::Try "$(ap): HW Info" {
		    UTF::ReportWhatami $(ap) -role DUT -noload $(noload)
		}
	    }
	}
	foreach STA $(stas) {
	    if {!$(nostaload)} {
		UTF::Try "$STA: Find STA Image" {
		    # Check primary image and start report header
		    UTF::CheckImage $STA $stadate unknown
		}
		UTF::Try "$STA: load" {
		    $STA load
		}
		# Check secondary driver and update report header
		UTF::ReportDriver $STA $stadate
	    } elseif {[catch {$STA wl ver}]} {
		# If there is no driver, exit
		UTF::Message ERROR "" "No image running for sta $STA, exiting."
		exit 1
	    }

	    UTF::Try "$STA: HW Info" {
		# Collect HW info and update report header + DB
		UTF::ReportWhatami $STA -role REF -noload $(nostaload)
	    }
	}
	#------------------------
	#End of Image Loading
	#------------------------

	UTF::Try "Common Setup" {
	    UTF::Try "Initial Cleanup" {
		UTF::Streamslib::force_cleanup [concat $(ap) $(stas)]
		UTF::stream allstreams destroy
	    }

	    #for Fedora19, need to setup ptpd2. The proc and array are in config file
	    #for Fedora22, ptpd2 should be running already
	    if {[info procs ::enable_ptp] ne "" && !$(noptp)} {
		UTF::Try "PTP setup" {
		    if {[array exists ::ptpinterfaces]} {
			UTF::Message INFO "" "[array get ::ptpinterfaces]"
			::enable_ptp
		    }
		}
	    }

	    #if ::UTF::SetupTestBed is defined in config file
	    #run the setup
	    if {[info exists ::UTF::SetupTestBed]} {
		UTF::Try "SetupTestBed" {
		    eval $::UTF::SetupTestBed
		}
	    } else {
		foreach STA $(stas) {
		    UTF::Try "$STA Disassoc" {
			catch {$STA wl -u disassoc}
		    }
		}
	    }
	    if {[$(ap) hostis Router]} {
		UTF::Try "Turn on the radio on $(ap)" {
		    set wlname [$(ap) wlname]
		    regsub {\.\d+} $wlname {} wlbase
		    if {[$(ap) nvram get ${wlbase}_radio] ne "1"} {
			lappend nv ${wlbase}_radio=1
		    }

		    if {[info exists nv]} {
			UTF::Message INFO "" "nv: $nv"
			$(ap) restart $nv
			UTF::Sleep 1
			unset nv
		    }
		}
	    }

	    UTF::Try "Attenuation Setup" {
		#all STAs at about the same distance from AP
		#set AP attn to 0
		#MBSS has the same attngroup
		set lattn {}
		if {$(distances) eq ""} {
		    foreach STA $(stas) {
			set attngrp [$STA cget -attngrp]
			UTF::Message INFO "" "$STA attngrp=$attngrp"
			if {$attngrp eq ""} {
			    set attngrp [$(ap) cget -attngrp]
			} else {
			    set apattngrp [$(ap) cget -attngrp]
			    if {$apattngrp ne ""} {
				$apattngrp attn 0
			    }
			    UTF::Message INFO "" "$apattngrp attn?"
			}
			if {$attngrp eq ""} {
			    UTF::Message WARNING "" "Attenuation group not found for $(ap) and $STA"
			} else {
			    catch {$attngrp attn $(attn)}
			}
			lappend lattn "$STA [$attngrp attn?]"
		    }
		} else {
		    foreach {G V} $(distances) {
			if {[$G info type] eq "::UTF::STA"} {
			    set G [$G cget -attngrp]
			}
			catch {$G attn $V}
			lappend lattn "$G [$G attn?]"
		    }
		}
		return $lattn
	    }
	}

	set ResultFileName goodputs.csv
	set CSVColNames "NumberOfStas,Multiplier,Goodput(Mbits/s),TOS,AP"
	set csvId [open [file join $UTF::Logdir $ResultFileName] a]
	puts $csvId $CSVColNames
	#close $csvId
	# On web summary page, add hyperlink to .csv file for easy access.
	UTF::Try "CSV results file" {
	    return "html: <a href=\"$ResultFileName\">$ResultFileName</a>"
	}

	set flows $(flows)
	set (notaf) 1
	if {[$(ap) wl -u chanspec] ne $(chanspec)} {
	    package require UTF::Test::APChanspec
	    APChanspec $(ap) $(chanspec)
	}

	set comments {
	#get actual baseline tput for each sta with each tos
	array set base {}
	foreach currenttos $(ltosbits) {
	    set txt " Baseline $(chanspec) \{$currenttos\} $(flows) flows/STA"
	    foreach sta $(stas) {
		set tos($sta) $currenttos
	    }
	    if {[catch {array set meanminmax [UTF::Test::PacketLoss::_BaseTest $(ap) "$(stas)" "na" -tos tos -txt $txt]} msg] \
		    || [array get meanminmax] eq {}} {
		UTF::Message ERROR "" "Failed to get baseline tput: $msg"
		exit
	    }

	    foreach sta $(stas) {
		set tput 0
		for {set j 1} {$j <= $(flows)} {incr j} {
		    if {[llength $meanminmax($sta,$j)]} {
			set tput [expr {int($tput + [lindex $meanminmax($sta,$j) 0])}]
			UTF::Message INFO "" "meanminmax($sta,$j)=$meanminmax($sta,$j), tput=$tput"
		    } else {
			UTF::Message ERROR "" "Failed to get baseline tput for $sta"
			exit
		    }
		}
		set base($sta,$currenttos) $tput
		UTF::Message INFO "" "base($sta,$currenttos)=$base($sta,$currenttos)"
	    }
	    array unset meanminmax
	    array unset tos
	}
    }
	set goodputs {}
	foreach tos $(ltosbits) {
	    #--------------------------------------------------------
	    #get tput for each individual STA for this Access Class
	    #this is the baseline and will be used in below test
	    #--------------------------------------------------------
	    set errcode 0
	    array set basetput {}
	    foreach sta $(stas) {
		set tput 0
		set ts "na"
		dict set TS $(ap) $ts $sta
		UTF::Try "Baseline $(chanspec) \{$tos\} $sta $(flows) flows/STA " {
		    set basetos($sta) $tos

		    #For Access Class VO, if the offered rate is too much, the baseline tput could be
		    #very low due to heavy oversubscription thus affect subsequence test result
		    if {[string toupper $tos] eq "VO"} {
			set rate $(vorate)
		    } else {
			set rate $(rate)
		    }
		    if {[catch {UTF::Test::TrafficScheduling::Scheduler $TS -tos basetos -holdtime $(holdtime)\
				    -modes $(modes) -flows $(flows) -rate $rate -fb $(fb) -w $(w)} lret]} {
			set errcode 1
			#throw FAIL $lret
		    }
		    set dictret [lindex $lret 0]
		    UTF::Message INFO "" "dictret=$dictret"
		    for {set j 1} {$j <= $(flows)} {incr j} {
			if {[catch {dict get $dictret $sta rate $j} meanminmax($sta,$j)]} {
			    UTF::Message ERROR "" "$meanminmax($sta,$j)"
			    set errcode 1
			    break
			} else {
			    UTF::Message INFO "" "$meanminmax($sta,$j)"
			    if {[llength $meanminmax($sta,$j)]} {
				set tput [expr {int($tput + [lindex $meanminmax($sta,$j) 0])}]
				UTF::Message INFO "" "meanminmax($sta,$j)=$meanminmax($sta,$j), tput=$tput"
			    } else {
				UTF::Message ERROR "" "Failed to get baseline tput for $sta"
				set errcode 1
				break
			    }
			}
			dict unset dictret $sta rate $j
		    }

		    #return result to this Try Block
		    if {$errcode} {
			throw FAIL "Failed to get baseline tput for $sta $tos: $lret"
		    } else {
			return [lindex $lret 1]
		    }
		}

		dict unset TS $(ap) $ts
		#skip test on other STAs if there is an error
		if {$errcode} {
		    break
		} else {
		    set basetput($sta) $tput
		}
	    }
	    array unset meanminmax
	    array unset basetos
	    #skip the test for this Access Class and go to the next one
	    if {$errcode} {
		array unset basetput
		continue
	    }

	    UTF::Message INFO "" "Baselinetput: [array get basetput]"

	    #---------------------------------------------------------------
	    #get goodput for different number of STAs for this Access Class
	    #---------------------------------------------------------------
	    for {set numstas 1} {$numstas <= [llength $(stas)]} {incr numstas} {
		set currentstas [lrange $(stas) 0 [expr {$numstas - 1}]]
		array set arrtos {}
		array set arrcurrentrates {}
		dict set TS $(ap) "na" $currentstas
		UTF::Try "\{$tos\} \{$currentstas\} goodput" {
		    set range [format %.2f [expr {$(maxmultiplier) - $(minmultiplier)}]]
		    set multiplier $(maxmultiplier)
		    set maxmultiplier $(maxmultiplier)
		    set minmultiplier $(minmultiplier)
		    set lastgput 0
		    set lastgputret {}
		    set lastgputmultiplier 0
		    set connected 0
		    set disconnect 0
		    while {$range > $(step)} {
			foreach  sta $currentstas {
			    set arrtos($sta) $tos
			    set arrcurrentrates($sta) [expr {int($multiplier * $basetput($sta))}]
			    set arrgputs($sta) 0
			}
			UTF::Message DEBUG "" "connected=$connected"
			if {[catch {UTF::Test::TrafficScheduling::Scheduler $TS -rates arrcurrentrates \
					-tos arrtos -warmup 1 -holdtime $(holdtime) \
					-connected $connected -disconnect $disconnect} lret]} {
			    throw FAIL $lret
			}

			set dictret [lindex $lret 0]
			dict for {sta stats} $dictret {
			    set ret ok
			    if {[catch {dict get $stats lost 1} lostcount($sta,1)] || \
				    [catch {dict get $stats rate 1} meanminmax($sta,1)] || \
				    $meanminmax($sta,1) eq ""} {
				set ret error
				break
			    }
			    UTF::Message INFO "" "multiplier=$multiplier"
			    UTF::Message INFO "" "lostcount($sta,1)=$lostcount($sta,1)"
			    UTF::Message INFO "" "meanminmax($sta,1)=$meanminmax($sta,1)"
			    if {[lindex $lostcount($sta,1) 0] > 0} {
				set ret continue
				break
			    } else {
				set arrgputs($sta) [format %.2f [lindex $meanminmax($sta,1) 0]]
			    }
			}
			if {$ret eq "error"} {
			    UTF::Message FAIL "" "$ret: Error to get throughput and/or lost count on $sta."
			    break
			}
			if {!$connected} {
			    set connected 1
			}

			#In case of 1 STA, it is faster to find goodput with fixed step search
			#In case of multiple STAs, it is faster to find goodput with binary search
			if {$ret eq "continue"} {
			    set maxmultiplier $multiplier
			    if {[llength $currentstas] == 1} {
				set multiplier [format %.2f [expr {$multiplier - $(step)}]]
			    } else {
				set halfrange [format %.2f [expr $range/2]]
				if {$halfrange >= $(step)} {
				    set multiplier [format %.2f [expr {$minmultiplier + $halfrange}]]
				} else {
				    set multiplier [format %.2f [expr {$minmultiplier + $(step)}]]
				}
			    }
			    set range [format %.2f [expr {$multiplier - $minmultiplier}]]
			    continue
			} elseif {$ret eq "ok"} {
			    foreach sta [array names arrgputs] {
				set lastgput [expr {$lastgput + $arrgputs($sta)}]
			    }
			    array unset arrgputs
			    set lastgput [format %.0f [expr {$lastgput / (1024*1024)}]]
			    set lastgputlret $lret
			    set lastgputmultiplier $multiplier
			    if {[llength $currentstas] == 1} {
				break
			    }
			    set minmultiplier $multiplier
			    set halfrange [format %.2f [expr $range/2]]
			    if {$halfrange >= $(step)} {
				set multiplier [format %.2f [expr {$maxmultiplier - $halfrange}]]
			    } else {
				set multiplier [format %.2f [expr {$maxmultiplier - $(step)}]]
			    }
			    set range [format %.2f [expr {$maxmultiplier - $multiplier}]]
			    continue
			}
		    }

		    set newentry "[llength $currentstas] $lastgputmultiplier $lastgput $tos $(ap)"
		    lappend goodputs $newentry
		    UTF::Message INFO "newentry=$newentry" ""
		    UTF::Message INFO "" "goodputs=$goodputs"

		    if {$ret eq "ok"} {
			return  [lindex $lret 1]
		    }
		    if {$ret eq "continue" && $lastgput != 0} {
			#lappend goodputs "[llength $currentstas] $lastgputmultiplier $lastgput $tos $(ap)"
			#UTF::Message INFO "" "goodputs=$goodputs"
			return [lindex $lastgputlret 1]
		    }
		    throw FAIL [lindex $lret 1]
		}
		dict unset TS $(ap) "na"
		array unset arrtos
		array unset arrcurrentrates
	    }
	    array unset basetput
	}
	UTF::Try "Goodputs" {
	    UTF::Message INFO "" "goodputs=$goodputs"
	    #writing results into a CSV file for post processing

	    foreach record $goodputs {
		foreach {num_stas multiplier goodput tos apname}  [split $record " "] {
		    puts $csvId "$num_stas,$multiplier,$goodput,$tos,$apname"
		}
	    }
	    close $csvId
	    if {[catch {plot_goodput $ResultFileName $(graphsize)} thumbnail]} {
		throw FAIL "Failed to generate goodput graph"
	    }
	    return "html: <a href=\"Goodputs\">$thumbnail</a>"
	}
    }
}
