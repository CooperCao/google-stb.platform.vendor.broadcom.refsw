#!/bin/env utf
# -*-tcl-*-

#
# WLAN <-> BlueTooth Coexistence test script
#
# To get online help, type: Test/Coex.test -h
#

# $Id$
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::Coex_help "\n\nBasic usage: Test/Coex.test <options>\
	\n\nThis script will setup your Coexistence test rig by loading the desired\
	\nbuilds, making connections between your wireless devices & running numerous\
	\ntests. Your testbed is expected to have the standard Coexistence configuration\
	\nwith a WLAN router, WLAN traffic generator, a combo WLAN/BlueTooth device and\
	\nBlueTooth reference device. The tests use IPERF, not CHARIOT.\
	\n\nFor the dates, TODAY will be translated to todays actual date.\
	\nCURRENT will match todays date, 1 day ago and 2 days ago.\
	\n\\* will find the most recent build, regardless of age.\
	\n2008.1 will find the most recent build in Jan 2008, no need to add \\* wildcard.\
	\n\nThe first time you run the script on a specific testbed that you personally\
	\nhave never used before with UTF, specify the -auth option and you will be\
	\nprompted for the login passwords for each device in the testbed that uses SSH.\
	\n\nvalid options are:\
	\n -utfconf path Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set ::Coex_getopts {
    {acl.arg ""
	"BT ACL packet type(s) for tests, default is to test all ACL packet types"}
    {ap.arg ""
	"WLAN router to test"}
    {attn_type.arg 0
	"Types of RvR attenuation: 0=None, 1=WLAN, 2=BT. Default is 0 (none)"}
    {auth
	"Go through authorization cycle for each device in the testbed that uses SSH"}
	{brief
	"Run BT ACL tests only on DM1 and 3-DH5 with perftime=10 and perfsize=5"}
    {bt.arg ""
	"BT DUT device to test"}
    {btcgr.arg ""
	"BT image file, usefull for testing private builds"}
    {btdate.arg ""
	"Desired BT build date, format: yyyy.mm.dd, default=null"}
    {btref.arg ""
	"BT Reference device to test"}
    {btver.arg ""
	"BlueTooth build version, default is \*"}
    {chanspec.arg ""
    	"AP channel, default channel is set by NVRAM"}
    {dbux
	"Post results to dbux; default is NOT posting to dbux"}
    {diagping
	"At start of each test, do diagnostic ping for WLAN, do AYT for BT"}
    {disassoc
	"Disassociate STAs at end of tests. By default, the STAs may be left associated"}
    {email.arg ""
	"Email address list, format: userid1,userid2,... default is your userid"}
    {ext
	"Use external builds"}
    {full
	"Reboot all hosts no matter what. Default is a conditional check & reboot."}
    {handle_acl_master.arg "12"
	"ACL handle for existing bt_master connection, default is to use handle stored in object"}
    {handle_acl_slave.arg "11"
	"ACL handle for existing bt_slave connection, default is to use handle stored in object"}
    {handle_sco_master.arg "1"
	"SCO/ESCO handle for existing bt_dut connection, default is to use handle stored in object"}
    {handle_sco_slave.arg "1"
	"SCO/ESCO handle for existing bt_ref connection, default is to use handle stored in object"}
    {history.arg 30
	"History size for control charts"}
    {link_policy.arg "4"
	"link policy"}
    {logdir.arg ""
	"Log directory override"}
    {max.arg 300
	"Expected maximum througput, -1 means no checks done"}
    {min.arg 0
	"Expected minimum througput, -1 means no checks done"}
    {noacl
	"Don't run BT ACL tests, default is to run BT ACL tests"}
    {noapload
	"Don't load the AP images, default is load the AP images"}
    {nobase
	"Don't run baseline tests, default is to run baseline tests"}
    {nobid
	"Don't run bidirectional tests, default is to run bidirectional tests"}
    {nocache
	"Don't update performance cache files"}
    {nocheck
	"Don't check the testbed, default is to run RebootTestbed"}
    {nocollect
	"Don't collect AP/STA default info, default is to collect this info"}
    {noping
	"Don't run ping/ayt tests, default is run the ping/ayt tests"}
    {norx
	"Don't run receive direction tests, default is to run receive tests"}
    {nosco
	"Don't run BT SCO tests, default is to run BT SCO tests"}
    {nosetup
	"Don't setup the radios & connections, default is to setup the radios & connections"}
    {nosetuptestbed
	"Don't execute setuptestbed , default is to execute setuptestbed when defined in utfconf"}
    {nostaload
	"Don't load the STA images, default is load the STA images"}
    {notx
	"Don't run transmit direction tests, default is to run transmit tests"}
    {nowlan
	"Don't run WLAN iperf tests, default is to run WLAN iperf tests"}
    {nomaster
	"Don't run BT master tests, default is to run BT master tests"}
    {noslave
	"Don't run BT slave tests, default is to run BT slave tests"}
    {nocoex
	"Don't run Coex tests, default is to run Coex tests"}
    {perfint.arg 2
	"Test interval in seconds for each test sample"}
    {perfloop.arg 1
	"Total performance test iterations for controlchart tests"}
    {perfsize.arg 15
	"Sample size for performance tests"}
    {perftime.arg 30
	"Total time duration, in seconds, for performance tests"}
    {relay.arg ""
       	"BT device relay, for HSIC pass-through tests; overrides utfconf file setting"}
    {retry.arg 3
	"Number of times to try rebooting an unresponsive host"}
    {reverseloadorder
	"Provide for case where BT firmware needs to load prior to wlan driver"}
    {rtrdate.arg ""
	"Desired Router build date, format: yyyy.mm.dd|CURRENT|TODAY|\\*, default=\\*"}
    {rtrdef.arg ""
	"Default Router STA for connections - not used"}
    {rtrtag.arg ""
	"Router release tag, default is NIGHTLY"}
    {rtrtrx.arg ""
	"Router image file, usefull for testing private builds"}
    {sco.arg ""
	"BT SCO packet type(s) for tests, default is to test all SCO packet types"}
    {sco_air_coding_format.arg "CVSD"
	"CVSD, u-law, or A-law for SCO/ESCO air coding format"}
    {sco_input_coding.arg "Linear"
	"Linear, u-law, or A-law for SCO/ESCO input coding"}
    {sco_input_data_format.arg "2\\'s_complement"
	"1's_complement, 2's_complement, or Sign-magnitude for SCO/ESCO input data format"}
    {sco_linear_pcm_bit_pos.arg "0"
	"0-7 (only used if INPUT_CONFIG = Linear) for SCO/ESCO linear pcm bit pos"}
    {sco_max_latency.arg "0xFFFF"
	"SCO/ESCO max latency"}
    {sco_retransmit_effort.arg "0"
	"0=no, 1= atleast 1 with optimized pwr, 2= atleast 1 with optimized link quality, 0xFF=dontcare for SCO/ESCO retransmit effort"}
    {sco_routing.arg "TRANSPORT"
	"PCM or TRANSPORT for SCO/ESCO routing"}
    {sco_sample_size.arg "16-bit"
	"8-bit | 16-bit (only used if INPUT_CONFIG = linear) for SCO/ESCO sample size"}
    {setup
	"Runs the setup method for each device in the testbed that uses SSH"}
    {showenv
	"Show environment variables in the log file"}
    {sniff_policy.arg "2"
	"enable sniff mode=2"}
    {sta.arg ""
	"WLAN STA to test"}
    {stabin.arg ""
	"STA .sys or .bin image file, usefull for testing private builds"}
    {stadate.arg ""
	"Desired STA build date, format: yyyy.mm.dd|CURRENT|TODAY|\\*, default=\\*"}
    {stadhd.arg ""
	"STA .ko linux DHD file, usefull for testing private builds"}
    {statag.arg ""
	"STA release tag, default is NIGHTLY"}
    {dhdtag.arg ""
	"STA DHD release tag, needed for some dongles, default is statag"}
    {title.arg ""
	"Title description text string for use in the reports, eg: \"Linux 4322USB dongle\""}
    {tx_sound_file.arg "or105-25sec.wav"
	"BT SCO/ESCO transmit sound file"}
    {useobjectsasis
	"Lets you specify specific builds/images in the config file so script loads exactly those mages."}
    {va.arg ""
	"Variable attenuator to use, default is to use first one defined in config file, if any"}
    {window.arg 512k
	"Window size for iperf tests, does not impact Mimo/EmbeddedNightly tests"}
    {wlan_testbed_path_loss.arg "40"
	"WLAN Testbed fixed path lose in dB"}
    {wlup_retry
	"do wlan up retry, default is no retry"}
    {bt_testbed_path_loss.arg "40"
	"BT Testbed fixed path lose in dB"}
    {rvr_wlan_attn_range_base_acl_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline ACL Master"}
    {rvr_wlan_attn_range_base_acl_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline ACL Slave"}
    {rvr_wlan_attn_range_base_esco_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline ESCO Master"}
    {rvr_wlan_attn_range_base_esco_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline ESCO Slave"}
    {rvr_wlan_attn_range_base_sco_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline SCO Master"}
    {rvr_wlan_attn_range_base_sco_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Baseline SCO Slave"}
    {rvr_wlan_attn_range_base_wlan.arg "10-60 59-10"
	"RvR WLAN attenuation range for WLAN"}
    {rvr_wlan_attn_range_coex_acl_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex ACL Master"}
    {rvr_wlan_attn_range_coex_acl_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex ACL Slave"}
    {rvr_wlan_attn_range_coex_esco_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex ESCO Master"}
    {rvr_wlan_attn_range_coex_esco_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex ESCO Slave"}
    {rvr_wlan_attn_range_coex_sco_master.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex SCO Master"}
    {rvr_wlan_attn_range_coex_sco_slave.arg "10-34 33-10"
	"RvR WLAN attenuation range for BT Coex SCO Slave"}
    {rvr_bt_attn_range_base_acl_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline ACL Master"}
    {rvr_bt_attn_range_base_acl_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline ACL Slave"}
    {rvr_bt_attn_range_base_esco_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline ESCO Master"}
    {rvr_bt_attn_range_base_esco_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline ESCO Slave"}
    {rvr_bt_attn_range_base_sco_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline SCO Master"}
    {rvr_bt_attn_range_base_sco_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Baseline SCO Slave"}
    {rvr_bt_attn_range_base_wlan.arg "10-60 59-10"
	"RvR BT attenuation range for WLAN"}
    {rvr_bt_attn_range_coex_acl_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex ACL Master"}
    {rvr_bt_attn_range_coex_acl_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex ACL Slave"}
    {rvr_bt_attn_range_coex_esco_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex ESCO Master"}
    {rvr_bt_attn_range_coex_esco_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex ESCO Slave"}
    {rvr_bt_attn_range_coex_sco_master.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex SCO Master"}
    {rvr_bt_attn_range_coex_sco_slave.arg "10-34 33-10"
	"RvR BT attenuation range for BT Coex SCO Slave"}
}

# Setup online help info.
UTF::setup_help $::Coex_help $::Coex_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
	set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any
# additional code in this script.

# Load packages
package require UTF
package require UTF::utils
package require UTF::WinBT
package require UTF::Test::APChanspec
package require UTF::Test::ConnectAPSTA
package require UTF::Test::ConnectBTdevices
package require UTF::Test::controlchart
package require UTF::Test::DisconnectBTdevices
package require UTF::Test::RebootTestbed
package require UTF::Test::ThruputBT

namespace eval coex {}
package provide UTF::Test::Coex 2.0

set ::acl_master_handle ""
set ::acl_slave_handle ""
set ::sco_master_handle ""
set ::sco_slave_handle ""
set ::acl_pkt_list ""
set ::sco_pkt_list ""
set ::key_base ""
set ::testbed_path_loss ""
set ::test_sets ""
set ::wlan_up_flag 0
set ::test_type ""
set ::test_subtype ""
set ::test_slave 0
set ::test_coex 0
set ::test_title ""
set ::rvr_wlan_attn_range ""
set ::rvr_bt_attn_range ""
set ::tc_title ""
set ::attn_type_label ""
set ::error_cnt 0
set ::bt_master ""
set ::bt_slave ""
set ::profile 0
set ::continue_flag 0
set ::test_prefix ""
set ::bt_dir_list ""
set ::bt_dir_display_list ""
set ::wlan_dir_display_list ""
set ::wlan_dir_list ""
set ::logdir ""
set ::keys ""
set ::bt_dir ""
set ::bt_test ""
set ::wlan_dir ""
set ::test_perftime 0
set ::pkt_type ""
set ::NewXLabel ""
set ::BT1 ""
set ::BT2 ""
set ::max_association_tries 3
set ::WLAN_DUT_CHAN ""
set ::wlan_relay ""

# Common procedures
proc coex::diag_ping {diagping test_type test_coex wlan_dut wlan_rtr bt_dut bt_ref } {

    UTF::Message INFO $::localhost \
	"************************Func:diag_ping***************************"

    # Optional diagnostic WLAN DUT <-> AP pings.
    if {$wlan_dut != "" && $wlan_rtr != "" && $diagping} {
	if {$test_type == "WLAN" || $test_coex == 1} {
	    UTF::Message LOG "" "Start diagnostic WLAN DUT <-> AP pings"
	    catch {$wlan_dut ping $wlan_rtr}
	    catch {$wlan_rtr ping $wlan_dut}
	    UTF::Message LOG "" "End diagnostic WLAN DUT <-> AP pings"
	}
    }

    # Optional diagnostic BT <-> BT AYT.
    if {$test_type == "BT" && $diagping} {
	UTF::Message LOG "" "Start diagnostic BT <-> BT AYT"
	catch {$bt_dut ayt $bt_ref}
	catch {$bt_ref ayt $bt_dut}
	UTF::Message LOG "" "End diagnostic BT <-> BT AYT"
    }
}

proc coex::initialize_variables {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"************************Func:initialize_variables***************************"

    # Command line options can overide which packet types to test.
    if {$(acl) == ""} {
	# define acl packet types for brief test
	if {!$(brief)} {
	    set ::acl_pkt_list "DM1 DH5 2-DH5 3-DH5"
	} else {
	    # brief
	    set ::acl_pkt_list "DM1 3-DH5"
	}
    } else {
	set ::acl_pkt_list $(acl)
    }
    set ::acl_pkt_list [string toupper $::acl_pkt_list]

    # Set common items for all tests.
    set stream [UTF::get_stream_name end]
    set ::key_base "$stream $::wlan_rtr Coex.test"

    set ::acl_master_handle ""
    set ::acl_slave_handle ""
    set ::sco_master_handle ""
    set ::sco_slave_handle ""

    set ::wlan_up_flag 1

    if {$(attn_type) == 1} {
	# WLAN RvR
	set ::testbed_path_loss $(wlan_testbed_path_loss)
    } elseif {$(attn_type) == 2} {
	# BT RvR
	set ::testbed_path_loss $(bt_testbed_path_loss)
    }

    ##############################################################################
    # ::test_sets structure defines all the coex tests. Parameters are:
    # ::test_type 		: WLAN or BT
    # ::test_subtype 		: 0 (means WLAN), ACL, SCO, eSCO
    # ::test_slave 		: 0 for Master, 1 for Slave
    # ::test_coex 		: 0 for Baseline, 1 for Coex
    # ::test_title		: Display title of this test
    # ::rvr_wlan_attn_range	: RvR WLAN attenuation range
    # ::rvr_bt_attn_range	: RvR BT attenuation range
    ##############################################################################
    set ::test_sets \
	[list \
	     WLAN 0 0 0 "WLAN:" $(rvr_wlan_attn_range_base_wlan) $(rvr_bt_attn_range_base_wlan)\
	     BT ACL 0 0 "Base ACL Mst:" $(rvr_wlan_attn_range_base_acl_master) $(rvr_bt_attn_range_base_acl_master)\
	     BT ACL 1 0 "Base ACL Slv:" $(rvr_wlan_attn_range_base_acl_slave) $(rvr_bt_attn_range_base_acl_slave)\
	     BT SCO 0 0 "Base SCO Mst:" $(rvr_wlan_attn_range_base_sco_master) $(rvr_bt_attn_range_base_sco_master)\
	     BT SCO 1 0 "Base SCO Slv:" $(rvr_wlan_attn_range_base_sco_slave) $(rvr_bt_attn_range_base_sco_slave)\
	     BT ESCO 0 0 "Base ESCO Mst:" $(rvr_wlan_attn_range_base_esco_master) $(rvr_bt_attn_range_base_esco_master)\
	     BT ESCO 1 0 "Base ESCO Slv:" $(rvr_wlan_attn_range_base_esco_slave) $(rvr_bt_attn_range_base_esco_slave)\
	     BT ACL 0 1 "Coex ACL Mst:" $(rvr_wlan_attn_range_coex_acl_master) $(rvr_bt_attn_range_coex_acl_master)\
	     BT ACL 1 1 "Coex ACL Slv:" $(rvr_wlan_attn_range_coex_acl_slave) $(rvr_bt_attn_range_coex_acl_slave)\
	     BT SCO 0 1 "Coex SCO Mst:" $(rvr_wlan_attn_range_coex_sco_master) $(rvr_bt_attn_range_coex_sco_master)\
	     BT SCO 1 1 "Coex SCO Slv:" $(rvr_wlan_attn_range_coex_sco_slave) $(rvr_bt_attn_range_coex_sco_slave)\
	     BT ESCO 0 1 "Coex ESCO Mst:" $(rvr_wlan_attn_range_coex_esco_master) $(rvr_bt_attn_range_coex_esco_master)\
	     BT ESCO 1 1 "Coex ESCO Slv:" $(rvr_wlan_attn_range_coex_esco_slave) $(rvr_bt_attn_range_coex_esco_slave)]
}

proc coex::initialize_test_variables {} {

    UTF::Message INFO $::localhost \
	"***********************Func:initialize_test_variables***************************"

    set ::error_cnt 0
    set ::continue_flag 0

    if {$::test_coex == 1} {
	set ::test_prefix "Coex"
    } else {
	set ::test_prefix "Baseline"
    }

    if {$::test_slave == 1} {
	# Slave test - Ref -> Cohost
	set ::bt_master $::bt_ref
	set ::bt_slave $::bt_dut
	# because the way ThruputBT.test is written, it expects the
	# 1st param to be dut and the 2nd param to be the ref,
	# therefore you can:
	# 1) pass $::bt_dut $::bt_ref with ::bt_dir_list="ref2dut dut2ref bidirectional"
	# 2) pass $::bt_master $::bt_slave with ::bt_dir_list="dut2ref ref2dut bidirectional"
	set ::bt_dir_list "dut2ref ref2dut bidirectional"
	set ::bt_dir_display_list "REF->DUT REF<-DUT REF<>DUT"
    } else {
	# Master test - Cohost -> Ref
	set ::bt_master $::bt_dut
	set ::bt_slave $::bt_ref
	set ::bt_dir_list "dut2ref ref2dut bidirectional"
	set ::bt_dir_display_list "DUT->REF DUT<-REF DUT<>REF"
    }

    set ::wlan_dir_display_list "WLAN->LAN WLAN<-LAN WLAN<>LAN"
    set ::wlan_dir_list "dut2tg tg2dut bidirectional"
}

proc coex::run_rvr_test {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:run_rvr_test***************************"

    # open the gpf file for graphing
    set gpf_fd [open "${::logdir}/temp_gpf.gpf" w]

    if {$(attn_type) == 1} {
	set attn_range $::rvr_wlan_attn_range
    } elseif {$(attn_type) == 2} {
	set attn_range $::rvr_bt_attn_range
    }

    set tot_attn_cnt 0
    set ::NewXLabel ""
    set bt_reconnect_flag 0

    foreach attn_element $attn_range {

	# for range "x-y":
	if {[regexp {([0-9]+)\-([0-9]+)} $attn_element match range1 range2]} {
	    if {$range1 <= $range2} {
		set attn_val $range1
		set loop_cnt [expr ($range2 - $range1) + 1]
		set attn_direction up
	    } else {
		set attn_val $range1
		set loop_cnt [expr ($range1 - $range2) + 1]
		set attn_direction down
	    }
	} else {
	    # for single vlaue
	    if {[regexp {^[+-]?[0-9]+$} $attn_element]} {
		set attn_val $attn_element
		set loop_cnt 1
		set attn_direction up
	    }
	}

	UTF::Message LOG $::localhost "===================================================================="
	UTF::Message LOG $::localhost "attn_val=$attn_val loop_cnt=$loop_cnt attn_direction=$attn_direction"

	for {set j 0} {$j < $loop_cnt} {incr j} {

	    UTF::Message LOG $::localhost "--------------------------------------------------------------------"

	    if {$(attn_type) == 1} {

		G1 attn $attn_val
		G2 attn $attn_val
		set ::attn_type_label "WLAN"

	    } elseif {$(attn_type) == 2} {

		G3 attn $attn_val
		set ::attn_type_label "BT"
	    }

	    UTF::Try "$::test_title$::tc_title $::attn_type_label Attn $attn_val" {

		if {$bt_reconnect_flag == 1} {

		    UTF::Message LOG $::localhost \
			"--------------------------------------------------------------------"
		    UTF::Message LOG $::localhost "BT is disconnected. Try re-connecting again."

		    if {![catch {
			UTF::Test::ConnectBTdevices $::BT1 \
			    $::BT2 -type $::test_subtype \
			    -sco_routing $(sco_routing) -sco_input_coding $(sco_input_coding) \
			    -sco_input_data_format $(sco_input_data_format) \
			    -sco_air_coding_format $(sco_air_coding_format) \
			    -sco_sample_size $(sco_sample_size) \
			    -sco_linear_pcm_bit_pos $(sco_linear_pcm_bit_pos) \
			    -sco_retransmit_effort $(sco_retransmit_effort) \
			    -sco_max_latency $(sco_max_latency) -link_policy $(link_policy) \
			    -sniff_policy $(sniff_policy)
		    } reconnect_catch_msg]} {
			UTF::Message LOG "" \
			    "Re-connect $::BT1 $::BT2 OK: $reconnect_catch_msg"
			set bt_reconnect_flag 0
		    }
		    UTF::Message LOG $::localhost \
			"--------------------------------------------------------------------"
		}

		UTF::Message LOG $::localhost "$::attn_type_label attn_val=$attn_val"

		# add the attenuation to the keys
		set new_keys "$::keys attn=$attn_val"

		set catch_resp1 [catch {
		    UTF::Test::ThruputBT $::bt_master $::bt_slave \
			-bt_dir $::bt_dir -bt_test $::bt_test \
			-bt_pkt $::pkt_type -profile $::profile \
			-title $::tc_title -wlan_dut $::wlan_dut \
			-wlan_tg $::wlan_tg -wlan_dir $::wlan_dir \
			-wlan_relay $::wlan_relay -key $new_keys \
			-perfloop $(perfloop) -perftime $::test_perftime \
			-perfsize $(perfsize) -perfint $(perfint) \
			-history $(history)-bt_slave_test $::test_slave \
			-handle_acl_master $::acl_master_handle \
			-handle_acl_slave $::acl_slave_handle \
			-handle_sco_master $::sco_master_handle \
			-handle_sco_slave $::sco_slave_handle \
			-tx_sound_file $(tx_sound_file) \
			-attn_type $(attn_type)
		} catch_msg1]
		if {$catch_resp1 == 0} {
		    return $catch_msg1
		} else {
		    error $catch_msg1
		}
	    }

	    # first check for Coex (WLAN and BT)
	    set result [regexp {>WLAN<.*>BT<} $catch_msg1 match]
	    if {$result == 1} {
		# Coex - get WLAN throughput vlaue
		set result \
		    [regexp {>WLAN<.*\">(\d+\.\d+) \[.*\], range .*>BT<.*} \
			 $catch_msg1 match throughput1]
		if {$result == 0} {
		    # did not find WLAN value
		    set throughput1 0
		    UTF::Message LOG $::localhost \
			"Did not find Coex WLAN throughput value"
		}
		# Coex - get BT throughput vlaue
		set result \
		    [regexp {>WLAN<.*>BT<.*\">(\d+\.\d+) \[.*\], range} \
			 $catch_msg1 match throughput2]
		if {$result == 0} {
		    # did not find BT value
		    set throughput2 0
		    UTF::Message LOG $::localhost \
			"Did not find Coex BT throughput value"
		}
	    } else {
		# not coex
		set throughput2 0

		# get the returned WLAN or BT throughput value
		set result \
		    [regexp {\">(\d+\.\d+) \[.*\], range} \
			 $catch_msg1 match throughput1]
		if {$result == 0} {
		    set throughput1 0
		    UTF::Message LOG $::localhost \
			"Did not find WLAN/BT throughput value"
		}
	    }

	    if {[expr [expr $tot_attn_cnt + 1] % 10] == 1} {
		if {$tot_attn_cnt > 0} {
		    set ::NewXLabel "$::NewXLabel,"
		}
		set graph_attn_val [expr $attn_val + $::testbed_path_loss]
		set ::NewXLabel "$::NewXLabel\"$graph_attn_val\" $tot_attn_cnt"
	    }


	    # save the throughput value in the gpf file for graphing
	    puts $gpf_fd "$tot_attn_cnt $throughput1 $throughput2"

	    incr tot_attn_cnt

	    if {$attn_direction == "up"} {
		incr attn_val
	    } else {
		set attn_val [expr $attn_val - 1]
	    }

	    # For RvR test, if this test step failed and returned no throughput
	    # value, then it is possible that BT is disconnected and we need to
	    # re-connect again
	    if {$catch_resp1 != 0 && $::test_type == "BT" && \
		    $throughput1 == "0" && $throughput2 == "0"} {
		set bt_reconnect_flag 1
	    }
	}
    }

    # close the gpf file for graphing
    close $gpf_fd

    #####################################################
    ################   Graph RvR Test   #################
    #####################################################
    coex::graph_rvr_test
}

proc coex::graph_rvr_test {} {

    UTF::Message INFO $::localhost \
	"***********************Func:graph_rvr_test***************************"

    UTF::Try "$::test_title $::tc_title $::attn_type_label Attn RvR Graph" {

	# rename the gpf file for graphing
	set testnum [UTF::get_testnum]
	set filename "rvr_test_$testnum"
	set gpfFile "${::logdir}/${filename}.gpf"
	file rename "${::logdir}/temp_gpf.gpf" $gpfFile

	set fd [open "${::logdir}/${filename}.gpc" w]
	puts $fd "set output \"${::logdir}/${filename}.png\""
	puts $fd "set title \"$::test_title $::tc_title $::attn_type_label Attn\""
	puts $fd "set terminal png"
	puts $fd "set nokey"
	puts $fd "set xlabel \"Path Loss (dB)\""
	if {$::test_coex == 1} {
	    puts $fd "set ylabel \"WLAN Throughput (Mbps)\""
	    puts $fd "set y2label \"BT Throughput (Mbps)\""
	    puts $fd "set y2tics"
	} else {
	    puts $fd "set ylabel \"Throughput (Mbps)\""
	}
	puts $fd "set ytics nomirror"
	puts $fd "set grid"
	puts $fd "set border"
	puts $fd "set key outside"
	puts $fd "set xtics ($::NewXLabel)"
	if {$::test_coex == 1} {
	    puts $fd "plot \"$gpfFile\" using 1:2 title \"WLAN\" with linespoints 1 7, \"$gpfFile\" using 1:3 title \"BT\" with linespoints 3 7"
	} else {
	    if {$::test_type == "WLAN"} {
		puts $fd "plot \"$gpfFile\" using 1:2 title \"WLAN\" with linespoints 1 7"
	    } else {
		puts $fd "plot \"$gpfFile\" using 1:2 title \"BT\" with linespoints 3 7"
	    }
	}
	close $fd
	set rc [catch {exec /usr/bin/gnuplot ${::logdir}/${filename}.gpc} result]

	set htmFile [open ${::logdir}/${filename}.htm w 0600]
	puts $htmFile "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
	puts $htmFile "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
	puts $htmFile "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">"
	puts $htmFile ""
	puts $htmFile "<head>"
	puts $htmFile "<title></title>"
	puts $htmFile "</head>"
	puts $htmFile ""
	puts $htmFile "<img src=\"${filename}.png\" alt=\"url\" width=\"680\" height=\"680\" border=\"0\">"
	puts $htmFile "</body>"
	puts $htmFile ""
	puts $htmFile "</HTML>"
	close $htmFile


	# change the permission of the htm file
	exec chmod 777 ${::logdir}/${filename}.htm

	return "html:<p><a href=\"${::logdir}/${filename}.htm\"><img src=\"${filename}.png\" alt=\"${filename}.png\" id=\"img_test_result\" width=\"300\" height=\"300\" border=\"0\"></a></p>"
    }
}

proc coex::setup_wlan_connection {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:setup_wlan_connection***************************"

    if {$::test_type == "WLAN"} {

	# If required, reload STAs & Routers, associate the AP and STAS.
	if {!$(nosetup)} {

	    UTF::Try "WLAN Open Connection" {

		# Before WLAN or BT open, make sure the attenuator is set to 0 for RvR
		if {$(attn_type) != 0} {
		    # This is RvR test. Reset attenuator groups
		    UTF::Message LOG $::localhost "Setting all attenuator groups G1 G2 G3 to zero for RvR test"
		    G1 attn 0
		    G2 attn 0
		    G3 attn 0
		}

		# If we did not explicitly load the STA drivers, then reload them
		if {$(nostaload)} {

		    ### allow for reversing driver load sequence:
		    ###  Normal case: wlan driver, BTCohost, BTRef;
		    ###  Reversed case: BTCohost, BTRef, wlan driver
		    if {!$(reverseloadorder)} {
			set ldList "$::wlan_dut $::bt_dut $::bt_ref"
		    } else {
			set ldList "$::bt_dut $::bt_ref $::wlan_dut"
		    }

		    foreach item $ldList {
			UTF::Try "Reload $item" {

			    # reload the STA.
			    if {[catch {UTF::reload_sta $item} catch_msg]} {
				incr ::error_cnt
				error $catch_msg
			    }
			    return $catch_msg
			}
		    }
		}

		# If we did not explicitly load the router, then reboot it
		if {$(noapload)} {
		    UTF::Try "Reboot $::wlan_rtr" {

			# Make sure router is powered on!
			catch {$::wlan_rtr power on}
			UTF::Sleep 5

			# Reboot router.
			if {[catch {$::wlan_rtr reboot} catch_msg]} {
			    incr ::error_cnt
			    error $catch_msg
				}
		    }
		}

		# If there are any device that didnt reload, halt the script.
		# We must have all devices functioning properly in the Coex
		# test rig.
		if {$::error_cnt > 0} {
		    error "Halting tests!"
		}

		# Associate STAs, open connections. Although the
		# ConnectAPSTA script will join multiple STAs at once
		# it has a VERY NASTY habit of stopping on the first
		# error. So if one driver is unresponsive, it doesn't
		# even bother trying the remaining STAs. This can lead
		# to all sorts of false failures because the other STAs
		# aren't even connected. So we run the ConnectAPSTA
		# separately for each STA AP pair.
		foreach {STA AP} "$::wlan_dut $::wlan_rtr" {
		    UTF::Try "Open Connection $AP $STA" {
			# There have been times when tests would have
			# passed if we had tried to open the connection
			# after the first failure. So we try multiple times.
			for {set j 1} {$j <= $::max_association_tries} {incr j} {
			    UTF::Message INFO "" "Open Connection $AP $STA Try: $j"
			    set catch_resp [catch {
				UTF::Test::ConnectAPSTA $AP $STA -security open
			    } catch_msg]
			    if {$catch_resp == 0} {
				UTF::Message LOG "" \
				    "Open Connection $AP $STA Try: $j OK: $catch_msg"
				break
			    } else {
				UTF::Message ERROR "" \
				    "Open Connection $AP $STA Try: $j failed: $catch_msg"
			    }
			}

			# Check status & rssi.
			if {$catch_resp ==0} {
			    catch {$STA wl PM 0} ;# enforce PM=0
			    catch {$STA wl frameburst 1} ;# Turn on frameburst
			    catch {$STA wl status}
			    if {[catch {$STA wl rssi} WLAN_DUT_RSSI]} {
				set WLAN_DUT_RSSI ""
			    }
			    set WLAN_RTR_RSSI [UTF::get_ap_rssi $AP $STA]
			    set ::WLAN_DUT_CHAN [$STA wl chanspec]
			} else {
			    # Getting RSSI from unresponsive hardware can take
			    # up to 20 minutes, so this is the error bypass.
			    set WLAN_DUT_RSSI ""
			    set WLAN_RTR_RSSI ""
			    set ::WLAN_DUT_CHAN ""
			}

			# Return status depends on which attempt
			# succeeded or not.
			if {$j == 1 && $catch_resp == 0} {
			    # Succeeded the first time.
			    return "WLAN_RTR_RSSI=$WLAN_RTR_RSSI WLAN_DUT_RSSI=$WLAN_DUT_RSSI WLAN_DUT_CHAN=$::WLAN_DUT_CHAN"
			} elseif {$catch_resp == 0} {
			    # Succeeded on retry, shows as an error to get
			    # peoples attention to potential unreliablity.
			    error "Open connection succeeded on try: $j WLAN_RTR_RSSI=$WLAN_RTR_RSSI WLAN_DUT_RSSI=$WLAN_DUT_RSSI WLAN_DUT_CHAN=$::WLAN_DUT_CHAN"
			} else {
			    # Tried N times, still failed. We are done.
			    incr ::error_cnt
			    error "Open connection failed, tried $::max_association_tries times!"
			}
		    }
		}

		# Do WLAN ping tests if required. Use all connection lists. Add in
		# the lan/wan peer devices, if any, for each Router.
		if {!$(noping)} {
		    UTF::Try "Ping WLAN" {

			# Ping WLAN devices in each direction
			set ping_pairs [UTF::Combinations 2 [list $::wlan_rtr $::wlan_dut $::wlan_tg]]
			foreach pair $ping_pairs {
			    set sta0 [lindex $pair 0]
			    set sta1 [lindex $pair 1]
			    UTF::Try "Ping $sta0 <--> $sta1" {
				# NB: On the router, the ping command is very limited
				# and only sends 1 packet. To send more than 1 packet
				# you would need to add a loop here.
				# Send pings in each direction.
				$sta0 ping $sta1
				$sta1 ping $sta0
			    }
			}
		    }
		}

		return "WLAN_RTR_RSSI=$WLAN_RTR_RSSI WLAN_DUT_RSSI=$WLAN_DUT_RSSI WLAN_DUT_CHAN=$::WLAN_DUT_CHAN"
	    }
	}
    }
}

proc coex::setup_bt_connection {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:setup_bt_connection***************************"

    if {$::test_type == "BT"} {

	if {!$(nosetup)} {

	    # Before WLAN or BT open, make sure the attenuator is reset for RvR
	    if {$(attn_type) != 0} {
		# This is RvR test. Reset attenuator groups
		UTF::Message LOG $::localhost "Setting all attenuator groups G1 G2 G3 to zero for RvR test"
		G1 attn default
		G2 attn default
		G3 attn default
	    }

	    # Open BT connections.
	    foreach {::BT1 ::BT2} "$::bt_master $::bt_slave" {
		UTF::Try "$::test_title BT Open Connection" {

		    set sta_reload_flag 0

		    # There have been times when tests would have
		    # passed if we had tried to open the connection
		    # after the first failure. So we try multiple
		    # times.
		    for {set j 1} {$j <= $::max_association_tries} {incr j} {
			UTF::Message INFO "" "Open Connection $::BT1 $::BT2 Try: $j"
			set catch_resp [catch {
			    UTF::Test::ConnectBTdevices $::BT1 \
				$::BT2 -type $::test_subtype \
				-sco_routing $(sco_routing) -sco_input_coding $(sco_input_coding) \
				-sco_input_data_format $(sco_input_data_format) \
				-sco_air_coding_format $(sco_air_coding_format) \
				-sco_sample_size $(sco_sample_size) \
				-sco_linear_pcm_bit_pos $(sco_linear_pcm_bit_pos) \
				-sco_retransmit_effort $(sco_retransmit_effort) \
				-sco_max_latency $(sco_max_latency) \
				-link_policy $(link_policy) \
				-sniff_policy $(sniff_policy)
			} catch_msg]
			# set catch_resp 1 ;# test code
			if {$catch_resp == 0} {
			    UTF::Message LOG "" "Open Connection $::BT1 $::BT2 Try: $j OK: $catch_msg"
			    break
			} else {
			    # if the 2nd retry failed, then something serious is
			    # wrong and we do a reload of the STA drivers to see if
			    # we recover from this

			    if {$j > $::max_association_tries} { ;# old code : if {$j == 2} changed 6/12/16

				UTF::Message ERROR "" "Reload STA"

				### allow for reversing driver load sequence:
				###  Normal case: wlan driver, BTCohost, BTRef;
				###  Reversed case: BTCohost, BTRef, wlan driver
				if {!$(reverseloadorder)} {
				    set ldList "$::wlan_dut $::bt_dut $::bt_ref"
				} else {
				    set ldList "$::bt_dut $::bt_ref $::wlan_dut"
				}

				foreach STA $ldList {
				    UTF::Try "Load STA $STA" {
					if {![catch {
					    UTF::reload_sta $STA
					} catch_msg]} {
					    return $catch_msg
					} else {
					    incr ::error_cnt
					    error $catch_msg
					}
				    }
			    }

			    foreach {STA AP} "$::wlan_dut $::wlan_rtr" {
				for {set k 1} {$k <= $::max_association_tries} {incr k} {
				    UTF::Message INFO "" "Open Connection $AP $STA Try: $k"
				    if {![catch {
					UTF::Test::ConnectAPSTA $AP $STA -security open
				    } catch_msg]} {
					UTF::Message LOG "" \
					    "Open Connection $AP $STA Try: $k OK: $catch_msg"
					break
				    } else {
					UTF::Message ERROR "" \
					    "Open Connection $AP $STA Try: $k failed: $catch_msg"
				    }
				}
			    }

			    set sta_reload_flag 1
			}

			    UTF::Message ERROR "" \
				"Open Connection $::BT1 $::BT2 Try: $j failed: $catch_msg"

#### tima: unconditional reload removed since we already have a
#### conditional reload above
#			    # Additional error recover is to reload BT devices
#			    UTF::Message INFO "" "Recovery - Reload $::BT1"
#			    catch {$::BT1 reload}
#			    UTF::Message INFO "" "Recovery - Reload $::BT2"
#			    catch {$::BT2 reload}
			}
		    }

		    # NB: ConnectBTdevices returns RSSI info, which
		    # shows up in catch_msg. So we return catch_msg to
		    # push the RSSI info onto the summary web page.

		    # Return status depends on which attempt succeeded
		    # or not.
		    if {$j == 1 && $catch_resp == 0} {
			# Succeeded the first time.
			return $catch_msg
		    } elseif {$catch_resp == 0} {
			# Succeeded on retry, shows as an error to get
			# peoples attention to potential unreliablity.

			if {$sta_reload_flag == 1} {
			    error "BT Open connection succeeded on try: $j with STA reloaded $catch_msg"
			} else {
			    error "BT Open connection succeeded on try: $j $catch_msg"
			}
		    } else {
			# Tried N times, still failed. We are done.
			incr ::error_cnt
			error "BT Open connection failed, tried	$::max_association_tries times!"
		    }

		    # Do BT ping (ayt) tests if required.
		    if {!$(noping)} {
			# BT ayt test is similar to ping
			set bt_dir_display [lindex $::bt_dir_display_list 2]
			UTF::Try "Ping BT - AYT $bt_dir_display" {
			    # NB: On BT devices, the ayt command is very limited
			    # and only sends 1 packet. To send more than 1 packet
			    # you would need to add a loop here.
			    # Do ayt in each direction.
			    $::bt_master ayt $::bt_slave
			    $::bt_slave ayt $::bt_master
			    return ""
			}
		    }
		}
	    }
	}
    }
}

proc coex::close_bt_connection {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:close_bt_connection***************************"

    if {$::test_type == "BT"} {

	UTF::Try "$::test_title BT Close Connection" {

	    #################################################################
	    # Update of the handles needs to be done here since the ThruputBT
	    # module could do a reset and change the handles
	    #################################################################

	    if {$::test_subtype == "ACL" || $::test_subtype == "SCO" || $::test_subtype == "ESCO"} {
		# If no ACL handles are present in the BT objects, use the command
		# line values
		set ::acl_master_handle [$::bt_master show_acl_handles]
		if {$::acl_master_handle == ""} {
		    $::bt_master save_acl_handles $(handle_acl_master)
		    UTF::Message LOG $::localhost "Using command line\
						handle_acl_master=$(handle_acl_master)"
		}
		set ::acl_slave_handle [$::bt_slave show_acl_handles]
		if {$::acl_slave_handle == ""} {
		    $::bt_slave save_acl_handles $(handle_acl_slave)
		    UTF::Message LOG $::localhost "Using command line\
						handle_acl_slave=$(handle_acl_slave)"
		}
	    }

	    if {$::test_subtype == "SCO" || $::test_subtype == "ESCO"} {
		# If no SCO handles are present in the BT objects, use the command
		# line values
		set ::sco_master_handle [$::bt_master show_sco_handles]
		if {$::sco_master_handle == ""} {
		    $::bt_master save_sco_handles $(handle_acl_master)
		    UTF::Message LOG $::localhost "Using command line\
						handle_acl_master=$(handle_acl_master)"
		}
		set ::sco_slave_handle [$::bt_slave show_sco_handles]
		if {$::sco_slave_handle == ""} {
		    $::bt_slave save_sco_handles $(handle_acl_slave)
		    UTF::Message LOG $::localhost "Using command line\
						handle_acl_slave=$(handle_acl_slave)"
		}
	    }

	    set catch_resp1 [catch {
		UTF::Test::DisconnectBTdevices $::bt_master $::bt_slave \
		    -type $::test_subtype \
		    -handle_acl_master $::acl_master_handle \
		    -handle_acl_slave $::acl_slave_handle \
		    -handle_sco_master $::sco_master_handle \
		    -handle_sco_slave $::sco_slave_handle
	    } catch_msg1]

	    UTF::Message LOG $::localhost "DisconnectBTdevices catch_resp1=$catch_resp1 catch_msg1=$catch_msg1"
	    # set catch_resp1 1 ;# test code
	    if {$catch_resp1 == 0 && $catch_msg1 == ""} {
		return
	    } else {
		UTF::Message ERROR "" "Close Connection $::BT1 $::BT2 failed: $catch_msg1"
		UTF::Message ERROR "" "Reload STA"

		### allow for reversing driver load sequence:
		###  Normal case: wlan driver, BTCohost, BTRef;
		###  Reversed case: BTCohost, BTRef, wlan driver
		if {!$(reverseloadorder)} {
		    set ldList "$::wlan_dut $::bt_dut $::bt_ref"
		} else {
		    set ldList "$::bt_dut $::bt_ref $::wlan_dut"
		}

		foreach STA $ldList {
		    UTF::Try "Load STA $STA" {
			if {![catch {UTF::reload_sta $STA} catch_msg]} {
			    return $catch_msg
			} else {
			    incr ::error_cnt
			    error $catch_msg
			}
		    }
		}

		foreach {STA AP} "$::wlan_dut $::wlan_rtr" {
		    for {set j 1} {$j <= $::max_association_tries} {incr j} {
			UTF::Message INFO "" "Open Connection $AP $STA Try: $j"
			if {![catch {
			    UTF::Test::ConnectAPSTA $AP $STA -security open
			} catch_msg]} {
			    UTF::Message LOG "" \
				"Open Connection $AP $STA Try: $j OK: $catch_msg"
			    break
			} else {
			    UTF::Message ERROR "" \
				"Open Connection $AP $STA Try: $j failed: $catch_msg"
			}
		    }
		}

		error "Disconnect failed. Reloaded STA"
	    }
	}
    }
}

proc coex::setup_bt_wlan_state {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:setup_bt_wlan_state***************************"

    if {$::test_type == "BT"} {

	# if this is an RvR WLAN test, then only do WLAN & Coex (no Baseline since WLAN is down)

	if {($::test_slave == 0 && $(nomaster)) ||
	    ($::test_slave == 1 && $(noslave)) ||
	    ($::test_coex == 0 && $(nobase)) ||
	    ($::test_coex == 1 && $(nocoex)) ||
	    ($::test_subtype == "ACL" && $(noacl)) ||
	    ($::test_subtype == "SCO" && $(nosco)) ||
	    ($::test_subtype == "ESCO" && $(nosco)) ||
	    ($::test_coex == 0 && $(attn_type) == 1) } {

	    set ::continue_flag 1
	    return
	}

	# For BT baseline, WLAN must be down or COEX code allocates bandwidth
	# to WLAN even if its not using it.

	# BT baseline -> wl down
	# BT coex -> wl up

	set option ""

	if {$::test_coex == 1 && $::wlan_up_flag == 0} {
	    set option "up"
	    set ::wlan_up_flag 1
	} elseif {$::test_coex == 0 && $::wlan_up_flag == 1} {
	    set option "down"
	    set ::wlan_up_flag 0
	}

	if {$option != ""} {
	    UTF::Try "WLAN $option" {
		catch {$::wlan_dut wl PM 0} ;# enforce PM=0
		catch {$::wlan_dut wl frameburst 1} ;# Turn on frameburst

		set catch_resp2 [catch {$::wlan_dut wl $option} catch_msg2]

		set catch_resp3 0
		if {$option == "up"} {
		    set catch_resp3 [catch {
			UTF::Test::ConnectAPSTA $::wlan_rtr $::wlan_dut -security open
		    } catch_msg3]
		}

		## UTF::Message DEBUG "" "wlup_retry value is set to: $(wlup_retry)"

		if {$catch_resp2 == 0 && $catch_resp3 == 0} {
		    return
		} else {
		    if { !$(wlup_retry) } {
			## original code with no retry
			error "$catch_msg2 $catch_msg3"
		    } else {
			## retry, if specified
			UTF::Message DEBUG "" "WLAN $option retry loop..."
			for { set j 2 } { $j <= $::max_association_tries } {incr j} {
			    if {![catch {
				UTF::Test::ConnectAPSTA $::wlan_rtr $::wlan_dut -security open
			    } catch_msg3 ]} {
				UTF::Message DEBUG "" "WLAN up succeeded in try $j: $catch_msg3"
				break
			    }
			}
		    }
		    ## end of retry
		}
	    }
	}
    }
}

proc coex::run_throughput_tests {} {
    # access option array
    upvar {} {}

    UTF::Message INFO $::localhost \
	"***********************Func:run_throughput_tests***************************"

    if {$::test_coex == 1} {
	# run coex test
	set ::profile 2
    } else {
	# BT test
	set ::profile 0
    }

    # Create list of tests parameters
    # Format is: ::test_title test_subtitle ::profile packet_type_list ...
    if {$::test_type == "WLAN"} {
	set test_parms_list [list WLAN "" 1 "auto"]
    } elseif {$::test_subtype == "ACL"} {
	set test_parms_list [list BT ACL $::profile $::acl_pkt_list]
    } elseif {$::test_subtype == "SCO"} {
	set ::sco_pkt_list "SCO"
	set test_parms_list [list BT SCO $::profile $::sco_pkt_list]
    } elseif {$::test_subtype == "ESCO"} {
	set ::sco_pkt_list "ESCO"
	# "ThruputBT.test" runs SCO and ESCO the same way and it takes only SCO param.
	set test_parms_list [list BT SCO $::profile $::sco_pkt_list]
    }

    if {$::test_slave == 0} {
	set ::keys "$::key_base $::test_prefix Master"
    } else {
	set ::keys "$::key_base $::test_prefix Slave"
    }

    set c [lindex $::WLAN_DUT_CHAN 0]
    set ::keys "$::keys chan=$c"

    # Process each set of test paramters
    foreach {title subtitle ::profile pkt_type_list} $test_parms_list {
	# puts "title=$title subtitle=$subtitle ::profile=$::profile pkt_type_list=$pkt_type_list"

	# Process each list of pkt types.
	foreach ::pkt_type $pkt_type_list {

	    for {set wlan_dir_index 0} {$wlan_dir_index <= 2} {incr wlan_dir_index} {

		if {($::test_type == "WLAN" && $(nowlan) ) } {
		    continue
		}

		set ::wlan_dir [lindex $::wlan_dir_list $wlan_dir_index]
		set wlan_dir_display [lindex $::wlan_dir_display_list $wlan_dir_index]

		# User may choose to skip selected test directions.
		if {$::test_slave == 0} {
		    # master
		    if {($::wlan_dir == "dut2tg" && $(notx)) ||
			($::wlan_dir == "tg2dut" && $(norx)) ||
			($::wlan_dir == "bidirectional" && $(nobid))} {
			continue
		    }
		} else {
		    # slave
		    if {($::wlan_dir == "dut2tg" && $(norx)) ||
			($::wlan_dir == "tg2dut" && $(notx)) ||
			($::wlan_dir == "bidirectional" && $(nobid))} {
			continue
		    }
		}

		for {set bt_dir_index 0} {$bt_dir_index <= 2} {incr bt_dir_index} {

		    set ::bt_dir [lindex $::bt_dir_list $bt_dir_index]
		    set bt_dir_display [lindex $::bt_dir_display_list $bt_dir_index]

		    if {$title == "BT"} {
			if {$::test_coex == 1} {
			    set ::tc_title "$::pkt_type $wlan_dir_display;$bt_dir_display"
			} else {
			    set ::tc_title "$::pkt_type $bt_dir_display"
			}
			set ::bt_test $subtitle
		    } else {
			set ::tc_title "$subtitle $wlan_dir_display"
			set ::bt_test n/a ;# WLAN tests
		    }

		    # User may choose to skip selected test directions.
		    if {$::test_slave == 0} {
			# master
			if {($::bt_dir == "dut2ref" && $(notx)) ||
				($::bt_dir == "ref2dut" && $(norx)) ||
				($::bt_dir == "bidirectional" && $(nobid))} {
			    continue
			}
		    } else {
			# slave
			if {($::bt_dir == "dut2ref" && $(norx)) ||
			    ($::bt_dir == "ref2dut" && $(notx)) ||
			    ($::bt_dir == "bidirectional" && $(nobid))} {
			    continue
			}
		    }

		    #################################################################
		    # Update of the handles needs to be done here since the ThruputBT
		    # module could do a reset and change the handles
		    #################################################################

		    if {$::test_subtype == "ACL" || $::test_subtype == "SCO" || $::test_subtype == "ESCO"} {
			# If no ACL handles are present in the BT objects, use the command
			# line values
			set ::acl_master_handle [$::bt_master show_acl_handles]
			if {$::acl_master_handle == ""} {
			    $::bt_master save_acl_handles $(handle_acl_master)
			    UTF::Message LOG $::localhost \
				"Using command line handle_acl_master=$(handle_acl_master)"
			}
			set ::acl_slave_handle [$::bt_slave show_acl_handles]
			if {$::acl_slave_handle == ""} {
			    $::bt_slave save_acl_handles $(handle_acl_slave)
			    UTF::Message LOG $::localhost \
				"Using command line handle_acl_slave=$(handle_acl_slave)"
			}
		    }

		    if {$::test_subtype == "SCO" || $::test_subtype == "ESCO"} {
			# If no SCO handles are present in the BT objects, use the command
			# line values
			set ::sco_master_handle [$::bt_master show_sco_handles]
			if {$::sco_master_handle == ""} {
			    $::bt_master save_sco_handles $(handle_acl_master)
			    UTF::Message LOG $::localhost \
				"Using command line handle_acl_master=$(handle_acl_master)"
			}
			set ::sco_slave_handle [$::bt_slave show_sco_handles]
			if {$::sco_slave_handle == ""} {
			    $::bt_slave save_sco_handles $(handle_acl_slave)
			    UTF::Message LOG $::localhost \
				"Using command line handle_acl_slave=$(handle_acl_slave)"
			}
		    }

		    # for BT Coex - increase the test time since we do not get enough samples for
		    # bidirectional and also some extra time is needed to make sure that wlan
		    # and bt are running simultaneously
		    set ::test_perftime [expr int($(perftime))]

			### action disabled for brief tests
			if { !$(brief) } {
				if {$::test_type == "BT" && $::test_coex == 1} {
					set ::test_perftime [expr $::test_perftime * 2]
				}
			}
					
		    # Run the specific test.

		    if {$(attn_type) == 0} {

			# non-RvR test
			
			# settings for brief tests
			if { $(brief) } {
				set ::test_perftime 10
				set (perfsize) 5
				# UTF::Message DEBUG "" "perfsize value set to: $(perfsize)" ; exit
			}

			UTF::Try "$::test_title $::tc_title" {

			    # add the attenuation to the keys
			    set new_keys "$::keys attn=0"
			    UTF::Message LOG $::localhost "keys=$new_keys"

			    # Optional diagnostic WLAN DUT <-> AP pings.
			    coex::diag_ping $(diagping) $::test_type $::test_coex $::wlan_dut $::wlan_rtr $::bt_master $::bt_slave

			    UTF::Test::ThruputBT $::bt_master $::bt_slave -bt_dir $::bt_dir -bt_test $::bt_test\
				-bt_pkt $::pkt_type -profile $::profile -title $::tc_title\
				-wlan_dut $::wlan_dut -wlan_tg $::wlan_tg -wlan_dir $::wlan_dir -wlan_relay $::wlan_relay\
				-key $new_keys -perfloop $(perfloop) -perftime $::test_perftime\
				-perfsize $(perfsize) -perfint $(perfint) -history $(history)\
				-bt_slave_test $::test_slave \
				-handle_acl_master $::acl_master_handle \
				-handle_acl_slave $::acl_slave_handle \
				-handle_sco_master $::sco_master_handle \
				-handle_sco_slave $::sco_slave_handle	\
				-tx_sound_file $(tx_sound_file) \
				-attn_type $(attn_type)
			}

		    } else {

			#####################################################
			#################   Run RvR Test   ##################
			#####################################################
			coex::run_rvr_test
		    }

		    if {$::test_type == "WLAN"} {
			# this is WLAN test and we do not need to loop through 3 BT directions
			break
		    }
		}

		if {$::test_coex == 0 && $::test_type != "WLAN"} {
		    # this is not a coex or wlan test and we do not need to loop through 3 wlan directions
		    break
		}
	    }
	}
    }
}

UTF::Test Coex {args} {
    global env

    # Basic command line option processing. Options are stored in the
    # unnamed array $()
    UTF::Getopts $::Coex_getopts $::Coex_help

    # To support testing of more build variations in the same config file,
    # which includes clone objects, the user can override the default STA
    # and other devices in the config file.
    if {$(ap) != ""} {
	set ::wlan_rtr $(ap)
    }
    if {$(bt) != ""} {
	set ::bt_dut $(bt)
    }
    if {$(btref) != ""} {
	set ::bt_ref $(btref)
    }
    if {$(sta) != ""} {
	set ::wlan_dut $(sta)
    }

    #
    # add wlan_relay for HSIC pass-through
    #

    if {[$::wlan_dut hostis "HSIC"]} {
	if {$(relay) != ""} {
	    set ::wlan_relay $(relay)
	} else {
	    ## When wlan_relay not defined, use -relay option defined in HSIC object
	    if { $::wlan_relay == "" } {
		set ::wlan_relay [ $::wlan_dut cget -relay ]
	    }
	}
    } else {
	# remove ::wlan_relay for non-HSIC cases, even if given
	if { $::wlan_relay != "" } {
	    UTF::Message DEBUG "" "\n\n::wlan_relay defined in utfconf where it is not required for non-HSIC platform. Removing ${::wlan_relay}...\n\n"
	    set ::wlan_relay ""
	}
	if { $(relay) != "" } {
	    error "\n\n\-relay option used where it is not required for non-HSIC platform. Remove \-relay option and try again...\n\n"
	}
    }
    # end case HSIC pass-through

    # DEBUG Check wlan_relay definition.
    # UTF::Message DEBUG "" "wlan_relay definition: $$::wlan_relay"
    # puts "wlan_relay definition: $$::wlan_relay\n\:\:wlan_dut is $::wlan_dut\n\$\(sta\) is $(sta)\n"
    # exit 1

    # The Coexistence config file is expected to map specific objects to
    # higher level names. We verify that the required names point to STA
    # objects of the correct UTF type. Specify the required variable names
    # along with one or more object types, types delimited by "|".
    set coex_sta_types [string trim $::coex_sta_type_list]
    regsub -all {\s} $coex_sta_types {|} coex_sta_types
    set coex_list "::bt_dut WinBT ::bt_ref WinBT ::wlan_dut $coex_sta_types\
		::wlan_rtr Router ::wlan_tg Linux"
    set ::error_cnt 0
    foreach {var type} $coex_list {

	# Check var is defined
	if {![info exists $var]} {
	    incr ::error_cnt
	    UTF::Message ERROR "" \
		"Your UTF config file is missing variable $var, which needs to specify a STA of type $type"
	    continue
	}
	# Check var is a STA of the desired type.
	set sta_name [set $var] ;# dereference var
	regsub -all {\|} $type " " type ;# convert type to space separated list
	if {[catch {
	    UTF::check_sta_type $sta_name $type
	} catch_msg]} {
	    incr ::error_cnt
	    UTF::Message ERROR "" $catch_msg
	    continue
	}
    }

    # Exit if any errors were found in the config file.
    if {$::error_cnt > 0} {
	UTF::Message ERROR "" "Please update your UTF config file and try again!"
	exit 1
    }

    # Check for duplicate STA names in use. Get list of actual STA names.
    set sta_list ""
    set var_list ""
    foreach {var -} $coex_list {
	lappend sta_list [set $var]
	lappend var_list $var=[set $var]
    }
    set sta_list [lsort $sta_list]
    # puts "sta_list=$sta_list var_list=$var_list"

    # Get unique list of STA names and check for duplicates.
    set unique_sta_list [lsort -unique $sta_list]
    if {$unique_sta_list != $sta_list} {
	UTF::Message ERROR "" \
	    "You are using the same STA name for more than one function within the test rig:"
	UTF::Message ERROR "" $var_list
	UTF::Message ERROR "" \
	    "Each of the above variables in your UTF config file must be assigned to a unique STA name, not used by by any of the other variables."
	UTF::Message ERROR "" "Please update your UTF config file and try again!"
	exit 1
    }

    # Dont alter the tag/date options, as that will impact the values
    # that may be stored in the config file individual objects.

    # Setup email option if necessary. UTF email utilities will set
    # default to your username as necessary.
    if {$(email) == ""} {
	# Check for utf config file email default
	if {[info exists UTF::email_list]} {
	    set (email) $UTF::email_list
	}
    }

    # Environment variables can alter the defaults for noapload & nostaload
    if {[info exists env(UTF_debug_noapload)] && $env(UTF_debug_noapload) == 1} {
	set (noapload) 1
    }
    if {[info exists env(UTF_debug_nostaload)] && $env(UTF_debug_nostaload) == 1} {
	set (nostaload) 1
    }
    # puts "email=$(email) noapload=$(noapload) nostaload=$(nostaload)"
    # parray "" ;# displays unnamed array of calling options

    # Get testbed info.
    set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]

    # Trim the list of host devices that will be tested down to match the
    # the sta_list. We dont look at the STAs in the wan/lan lists, as they
    # are used as needed or not.
    foreach item [concat $::endpoint_sta_list $::endpoint_sta_bt_list \
		      $::router_sta_list] {

	# Look for STA item in the sta_list
	if {[lsearch -exact $sta_list $item] >= 0} {
	    # puts "item=$item found in sta_list=$sta_list"
	} else {

	    # Item not found. Remove STAs from list of items to test.
	    # puts "item=$item not in sta_list=$sta_list"
	    UTF::remove_test_item $item
	}
    }

    # Look for variable attenuator.
    if {$(va) == ""} {
	set va_list [UTF::get_names_values UTF::Aeroflex]
	set (va) [lindex $va_list 0] ;# use first one found
	# puts "found va_list=$va_list"
    }

    # Validate variable attenuator name.
    if {$(va) != ""} {
	UTF::Message LOG $::localhost "Checking variable attenuator: $(va)"
	UTF::check_host_os $(va)
    }

    # If attn_type > 0, the config file needs an attenuator defined
    # with G1, G2 & G3 groups.
    if {$(attn_type) > 0} {
	if {$(va) == ""} {
	    error "For attn_type > 0, you must specify a variable attenuator to use"
	}
	# We need 3 attenuator groups defined.
	UTF::Message LOG $::localhost "Checking attenuator groups G1 G2 G3 are defined"
	UTF::check_host_os G1
	UTF::check_host_os G2
	UTF::check_host_os G3
    }

    # The first time a different UTF testbed is used, you need to go through
    # the authorization process for each device that has a login process.
    # This option makes it easier for the end user.
    if {$(auth)} {
	UTF::auth_devices
    }

    # Once in a while the testbed needs to be updated by running the
    # setup method on all devices. This option makes it easier for the
    # end user.
    if {$(setup)} {
	UTF::setup_devices
    }

    # Setup build info for routers / STAs
    set buildfinderror [UTF::setup_build_info $(rtrtrx) $(rtrtag) $(rtrdate) \
			    $(statag) $(stadate) $(noapload) $(nostaload) "summaryinfo" \
			    $(btver) $(btdate) $(ext) $(stabin) $(btcgr) "" $(stadhd) \
			    $(useobjectsasis) $(dhdtag)]

    # Set email subject & report title.
    set email_subject [UTF::setup_email_subject $(title)]

    # Main code body that starts html summary report and runs tests.
    # puts "UTF::SummaryDir=$UTF::SummaryDir summaryinfo=$summaryinfo
    #	email_subject=$email_subject"

    # Ensure that we always graph at least all of the performance data
    # that we collect on this test run. If we dont, then you get a
    # graph of the last 30 samples and the previous (perfloop - 30)
    # samples are NOT graphed, which is extremely unhelpful.
    if {$(history) < $(perfloop)} {
	set (history) $(perfloop)
    }

    # If requested, dont save the performance results in the cache files.
    if {$(nocache)} {
	set ::UTF::ControlChart::readonly 1
    }

    # Log testbed info. Although the trailer / testbed info is added
    # to the end of the summary web page, for development, a lot of
    # the time the script is deliberately aborted before this
    # occurs. Logging the data now ensures you can go see the data on
    # your screen or the general log file.
    UTF::Message INFO "" $::UTF::trailer_info

    UTF::WrapSummary $UTF::SummaryDir $email_subject $summaryinfo $(email) {

	# Some testrigs have Aeroflex attenuator initialization
	# strings defined, usually to set all channels to 0
	# attenuation. If found, setup the attenuator.
	if { !$(nosetuptestbed) } {
	    if {[info exists ::UTF::SetupTestBed]} {
		UTF::Try "Setup attenuator" {
		    eval $::UTF::SetupTestBed
		    return
		}
	    }
	}

	# If requested, log all the environment variables. This is
	# useful for sorting out issues with cron jobs.
	if {$(showenv)} {
	    UTF::Try "Environment variables" {
		set env_names [array names env]
		set env_names [lsort $env_names]
		foreach item $env_names {
		    UTF::Message INFO $::localhost "env($item)=$env($item)"
		}
	    }
	}

	# If a build was not found, log it and halt the script. We
	# must have builds for all devices in the Coex test rig.
	if {$buildfinderror != ""} {
	    UTF::Try "Find build for: $buildfinderror" {
		UTF::Message ERROR $::localhost "No build found for: $buildfinderror"
		error "no build found for $buildfinderror"
	    }
	    error "Halting tests!"
	}

	# Reboot hosts in testbed as needed. Default is to check for
	# unresponsive hosts and reboot only the unresponsive ones.
	if {!$(nocheck)} {
	    UTF::Try "RebootTestbed full=$(full)" {
		# Getopts doesnt like null options, so we have to work
		# around this.
		if {$(full)} {
		    RebootTestbed -full -retry $(retry)
		} else {
		    RebootTestbed -retry $(retry)
		}
	    }
	}

	# If there are any unresponsive hosts, log them and halt the
	# script.  We must have all devices functioning properly in
	# the Coex test rig.
	if {[info exists ::unresponsive_hosts] && $::unresponsive_hosts != ""} {
	    error "Halting tests!"
	}

	# Disassociate all STAs if required.
	if {!$(nosetup)} {
	    UTF::Try "Disassociate STAs" {
		catch {$::wlan_dut wl disassoc}

		# Need BT disassoc equivalent

		return
	    }
	}

	# Check disk utilization of all STA to be tested.
	## HSIC and Android have read-only file system, and always returns an
	## error; skip disk check
	if {![$::wlan_dut hostis "Android"] && ![$::wlan_dut hostis HSIC]} {
	    UTF::check_disk_usage \
		[concat $::endpoint_sta_list $::router_sta_list \
		     [list $::bt_dut $::bt_ref]]
	}

	# Load the STAs if required.
	set ::error_cnt 0 ;# error count for script critical items
	if {!$(nostaload)} {
	    UTF::Try "Load STAs" {
		if {!$(reverseloadorder)} {
		    set ldList [list $::wlan_dut $::bt_dut $::bt_ref]
		} else {
		    set ldList [list $::bt_dut $::bt_ref $::wlan_dut]
		}
		foreach STA $ldList {
		    UTF::Try "Load STA $STA" {
			if {![catch {UTF::load_sta_retry $STA} catch_msg]} {
			    return $catch_msg
			} else {
			    # STA may have recovered or loaded OK on the 2nd try.
			    if {![string match -nocase "*try*pass:*" $catch_msg] &&\
				    ![regexp -nocase "removed.*rebooting" $catch_msg] &&\
				    ![regexp -nocase "devcon.*completed" $catch_msg] && \
				    ![regexp -nocase "recovered" $catch_msg]} {
				incr ::error_cnt
			    }
			    error $catch_msg
			}
			UTF::ReportDriver $STA $date ;#added 5/20/16
		    }
		}
	    }
	}

	# If there are any STA that didnt load, halt the script.
	# We must have all devices functioning properly in the Coex test rig.
	if {$::error_cnt > 0} {
	    error "Halting tests!"
	}

	# Load the Routers if required.
	if {!$(noapload)} {
	    UTF::Try "Load Routers" {
		foreach Router $::wlan_rtr {
		    UTF::Try "Load Router $Router" {
			set catch_resp [catch {UTF::load_rtr_retry $Router} catch_msg]

			# User may want a different channel
			if {$(chanspec) != ""} {
			    UTF::Test::APChanspec $Router $(chanspec)

			    set c [lindex [$Router wl chanspec] 0]
			    if {$c ne $(chanspec)} {
				error "Chanspec $c != $(chanspec)"
			    }
			}

			# Check for loading errors
			if {$catch_resp == 0} {
			    return $catch_msg
			} else {
			    # AP may have loaded OK on the 2nd try.
			    if {![string match -nocase "*try*pass:*" $catch_msg]} {
				incr ::error_cnt
			    }
			    error $catch_msg
			}
		    }
		}
	    }
	}

	# If there are any RTR that didnt load, halt the script.
	# We must have all devices functioning properly in the Coex test rig.
	if {$::error_cnt > 0} {
	    error "Halting tests!"
	}

	# Collect AP/STA info in the log. What to collect for BT?
	if {!$(nocollect)} {
	    UTF::Try "Collecting defaults, nrate, etc" {
		foreach STA "$::wlan_rtr $::wlan_dut" {
		    UTF::Try "$STA data" {
			UTF::Message INFO $::localhost "Collecting defaults, nrate, etc for: $STA"
			foreach cmd {up PM frameburst radio rssi nrate rate} { ;# added wl up prior to other wl commands 11/10/15
			    catch {$STA wl $cmd}
			}
			# Collect hardware version info
			if {[catch {$STA whatami} resp]} {
			    set $resp ""
			}
			# Push hardware version info up to main web page.
			return $resp
		    }
		}
	    }
	}

	# Update the report header table with actual OS & hw versions.
	set summaryinfo [UTF::update_report_hwinfo $summaryinfo]

	# Update report title with actual TAG numbers
	eval UTF::update_report_title $::wlan_rtr $::wlan_dut
	$::wlan_dut dbrecord DUT ;#added 5/20/16

	set ::logdir [file dirname $UTF::Logfile]

	##################################################################
	#
	#	Coex tests start here
	#
	##################################################################
	# MS time stamp turned off
	catch { unset ::UTF::MSTimeStamps } unsetHR
		if { $unsetHR != "" } {
			UTF::Message ERROR "" "Unsetting MSTimeStamps failed: $unsetHR."
		} else {
			UTF::Message INFO "" "Unsetting MSTimeStamps succeeded."
		}

	#####################################################
	#############  Initialize Variables  ################
	#####################################################
	coex::initialize_variables

	# Process each ::test_sets paramters
	foreach {::test_type ::test_subtype ::test_slave ::test_coex ::test_title ::rvr_wlan_attn_range ::rvr_bt_attn_range} $::test_sets {

	    UTF::Message INFO "debug" "::test_type=$::test_type ::test_subtype=$::test_subtype ::test_slave=$::test_slave ::test_coex=$::test_coex ::test_title=$::test_title ::rvr_wlan_attn_range=$::rvr_wlan_attn_range ::rvr_bt_attn_range=$::rvr_bt_attn_range"

	    #####################################################
	    ###########  Initialize Test Variables  #############
	    #####################################################
	    coex::initialize_test_variables

	    #####################################################
	    ############	Setup BT WLAN State	   ##############
	    #####################################################
	    coex::setup_bt_wlan_state

	    if {$::continue_flag == 1} {
		continue
	    }

	    #####################################################
	    ############   Setup WLAN Connection   ##############
	    #####################################################
	    coex::setup_wlan_connection

	    #####################################################
	    #############   Setup BT Connection   ###############
	    #####################################################
	    coex::setup_bt_connection

	    if {$::error_cnt > 0} {
		error "Halting tests!"
	    }

	    #####################################################
	    ##############  Run Throughput Tests  ###############
	    #####################################################
	    coex::run_throughput_tests

	    #####################################################
	    #############   Close BT Connection   ###############
	    #####################################################
	    coex::close_bt_connection
	}

	# Report how many times error recovery was invoked and longest
	# socket delay observed.
	UTF::Try "Error recovery procedure count" {
	    if {[info exists ::ThruputBT::erp_cnt]} {
		UTF::Message LOG $::localhost "erp_cnt=$::ThruputBT::erp_cnt max_socket_delay=$::ThruputBT::running_max_socket_delay seconds occured at: $::ThruputBT::running_max_socket_timestamp"
		if {$::ThruputBT::erp_cnt == 0} {
		    return
		} else {
		    error $::ThruputBT::erp_cnt
		}
	    } else {
		return "n/a"
	    }
	}

	# Disassociate STAs if requested.
	if {$(disassoc)} {
	    UTF::Try "Disassociate STAs" {
		foreach STA $::wlan_dut {
		    catch {$STA wl disassoc}
		}
		return ""
	    }
	}

	# Posting to dbux ;# retries added 5/30/16
    	if {$(dbux)} {
	    	set rMax 3
            UTF::Try "Post test info to dbux" {
            	if {$(stabin) != ""} {
                    catch {UTF::post_to_dbux $STA 1 coex} dMsg
            	} else {
                    catch {UTF::post_to_dbux $STA 0 coex} dMsg
            	}
            	UTF::Message DEBUG "" "Returned message from dbux: $dMsg"
            	if { [regexp -nocase {.*failed.*} $dMsg] } {
	            	UTF::Message FAIL "" "dBux posting attempt failed."
	            	for { set rCnt 1 } { $rCnt <= $rMax } { incr rCnt } {
		            	UTF::Message DEBUG "" "Retry dBux posting: $rCnt of 3"
		            	UTF::Sleep 3
    	            	if {$(stabin) != ""} {
		                    catch {UTF::post_to_dbux $STA 1 coex} rMsg
		            	} else {
		                    catch {UTF::post_to_dbux $STA 0 coex} rMsg
		            	}
		            	UTF::Message DEV "" "dBux retry return message: $rMsg"
		            	if { $rMsg == "" } {
			            	UTF::Message DEBUG "" "dBux posting retry succeeded on try $rCnt of $rMax"
			            	break
		            	} else {
			            	UTF::Message DEBUG "" "dBux posting retry failed: $rCnt of $rMax"
		            	}
	            	}
	            	if { $rCnt > $rMax } {
		            	#UTF::Message FAIL "" "dBux posting failed after $rMax retries."
		            	error "dBux posting failed after $rMax retries."
	            	}
            	}
            }
        }

	# Do optional post test analysis. The "" passes the unnamed options array.
# 	UTF::do_post_test_analysis Coex.test ""

	# Final testbed cleanup. Reboot only the hosts in the testbed that
	# crashed during the tests that just ran.
	if {!$(nocheck)} {
	    UTF::Try "RebootTestbed full=0" {
		RebootTestbed
	    }
	}

	# Update the report header table with end test time.
	set summaryinfo [UTF::update_report_testtime $summaryinfo]

	# End of code block for UTF::WrapSummary
    }

}

