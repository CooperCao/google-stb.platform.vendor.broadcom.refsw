#!/bin/env utf
# -*-tcl-*-

#######################################################################################################
#######################################################################################################
#
#	DO NOT MODIFY THIS FILE
#	CONTACT Kevin Mirabadi
#
#######################################################################################################
#######################################################################################################

#
# P2P test script 
#
# Written by: Kevin Mirabadi
#
# To get online help, type: Test/P2PQoSNightly.test -h
#

# $Id: 3772b17de57693f915dd49fbfcb7690adb83f5c5 $
# $Copyright Broadcom Corporation$
#

# Test description:
#	Direct -> One P2P connection between GO & GC
#	Multi-channel ->
#		One P2P connection between GO & GC and 
#		One WLAN connection between (AP & GO) or (AP & GC)

# Examples to run the test:
# Direct P2P
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4349 Video Direct P2P' -sta_gc '4349a2-FC19-DUTf' -sta_go '4349a2-FC19-GOf' -nos -nom -wlan_bandwidth_VI 30M -p2p_bandwidth_VI 30M -run_qos -qos_tests '[P2P:VI:RX:0:5]' -p2p_chan 11u -fb1
# TCP, 1 stream WLAN
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 FC15 WLAN QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta "4360-FC15-GC" -wlan_security aespsk2 -ap_chan "36/80" -wlan_bandwidth_BE "5M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[WLAN:TCP:RX:0:20]" -date 2013.2.21.0
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4331 FC15 WLAN QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta "4360-FC15-GC" -ap_chan "36l" -wlan_bandwidth_BE "5M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[WLAN:TCP:RX:0:20]"
# TCP, 2 stream WLAN
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 FC15 WLAN QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta "4360-FC15-GC" -wlan_security aespsk2 -ap_chan "36/80" -wlan_bandwidth_BE "5M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[WLAN:TCP:TX:0:120][WLAN:TCP:TX:30:60]" -date 2013.2.21.0
# WLAN & P2P
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 FC15 QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta_go "4360-FC15-GO" -sta_gc "4360-FC15-GC" -nom -nod -wlan_security aespsk2 -p2p_security -ap_chan "36/80" -p2p_chan "36/80" -wlan_bandwidth_BE "100M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[P2P:BE:RX:0:30][WLAN:BE:RX:10:10]" -date 2013.2.21.0
# run P2P tests (not QoS)
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 FC15 QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta_go "4360-FC15-GO" -sta_gc "4360-FC15-GC" -nos -wlan_security aespsk2 -p2p_security -ap_chan "149l" -p2p_chan "36l" -wlan_bandwidth_BE "10M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[P2P:VI:BI:0:60][P2P:VI:BI:10:30]" -date 2013.2.21.0 -ap_connect GC
# Apple - Multi-chan TCP repeat 10 times throughput & repeat 5 channels
#Test/P2PQoSNightly.test -utfconf utfconf/MCN.tcl -title "MCN 4360 Mac QoS" -ap "AP1-4331-4706 AP1-4360-4706" -sta_go "4360-FC15-GO" -sta_gc "4360-FC15-GC" -nod -nos -ap_chan "157l 157l 157l 157l 157l" -p2p_chan "36l 36l 36l 36l 36l" -wlan_bandwidth_BE "10M" -wlan_bandwidth_BK "5M" -wlan_bandwidth_VI "5M" -wlan_bandwidth_VO "5M" -noapload -norestore -qos_tests "[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]|[P2P:TCP:RX:0:60]" -date 2013.2.21.0 -ap_connect GC -run_qos
# Current Measurement - WLAN ONLY
#Test/P2PQoSNightly.test -utfconf utfconf/MCA.tcl -title "MCA MBP 4360 VI WLAN TX Test" -ap "AP1-4331-4706 AP1-4360-4706" -sta "4360-MBPX-DUT" -wlan_security aespsk2 -ap_chan 48u -wlan_bandwidth_BE 100M -wlan_bandwidth_BK 20M -wlan_bandwidth_VI 20M -wlan_bandwidth_VO 10M -run_qos -qos_tests "[WLAN:VI:TX:0:30]" -noapload -norestore  -measure_current_sta "4360-MBPX-DUT"
# Run one QoS test
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title \"MCK 4360 7_10_TOB FC15 WLAN QoS\" -ap \"AP1-4331-4706 AP1-4360-4706\" -apdate \"2014.1.28.0\" -sta \"4360-FC19-DUT\" -wlan_security aespsk2 -ap_chan 36l -wlan_bandwidth_BE 80M -wlan_bandwidth_BK 80M -wlan_bandwidth_VI 80M -wlan_bandwidth_VO 80M -run_qos -qos_tests \"[WLAN:BK:TX:0:25][WLAN:BE:TX:0:25][WLAN:BK:TX:5:15]\" -noapload -norestore
#
# WLAN RvR
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4354 PCIe 7_10_TOB FC15 RvR TCP WLAN' -sta '4354e-FC19-DUTx' -ap '4360-SoftAP2' -apdate '2014.3.27.0' -ap_connect GC -ap_chan 36/80 -fb1 -attn_type 1 -perftime 5 -norx -nobi -rvr_wlan_attn_range '30-70 70-30' -rvr_attn_incr 2
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4354 PCIe 7_10_TOB FC15 RvR TCP WLAN' -sta '4354e-FC19-DUTx' -ap '4360-SoftAP2' -apdate '2014.3.27.0' -ap_connect GC -ap_chan 36/80 -fb1 -attn_type 1 -run_qos -qos_tests "[WLAN:TCP:RX:0:5]" -rvr_wlan_attn_range '30-70 70-30' -rvr_attn_incr 2
# P2P RvR
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4354 PCIe 7_10_TOB FC15 RvR Video P2P' -ap '4360-SoftAP2' -apdate '2014.3.27.0' -sta_gc '4354e-FC19-DUTx' -sta_go '4354e-FC19-GOx' -nos -nom -wlan_bandwidth_VI 30M -p2p_bandwidth_VI 30M -run_qos -qos_tests '[P2P:TCP:RX:0:5]' -ap_chan 36/80 -p2p_chan 36l -fb1 -attn_type 2 -stadate 2014.4.7.0 -ap_connect GC
# RvR Direct P2P
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4356 PCIe 7_10_TOB FC15 RvR Direct P2P' -sta_gc '4356e-FC19-DUTx' -sta_go '4356e-FC19-GOx' -nos -nom -wlan_bandwidth_VI 30M -p2p_bandwidth_VI 30M -run_qos -qos_tests '[P2P:TCP:RX:0:5]' -ap_chan 36/80 -p2p_chan 36l -fb1 -attn_type 2 -ap_connect GC
#
# AWDL:
#Test/P2PQoSNightly.test -utfconf MCC -title 'MCC 4355 AWDL TCP' -ap '4360-SoftAP' -apdate '2014.3.27.0' -sta_gc '4355-Slv' -sta_go '4355-Mst' -nom -nod  -ap_connect GC -run_qos -qos_tests '[WLAN:TCP:BI:0:30][P2P:TCP:BI:0:30]' -awdl -ap_connect GC -ap_chan 149/80 -p2p_chan 149/80 -noapload -norestore -nounload
# AWDL MacOS:
#Test/P2PQoSNightlyk2.test -utfconf MCC -title 'MCC Gala MacOS AWDL Direct Test AWDLCh=149' -sta_gc 'Gala-DUT' -sta_go 'Gala-AWDL' -run_qos -qos_tests '[P2P:VI:TX:0:30]\|[P2P:VI:RX:0:30]\|[P2P:TCP:TX:0:30]\|[P2P:TCP:RX:0:30]' -p2p_chan 149 -p2p_bandwidth_VI 40M -awdl -no_wl_dump -nounload
#Test/P2PQoSNightlynew.test -utfconf MCC -title 'MCC Gala MacOS Infra+AWDL Test InfraCh=6 AWDLCh=149' -ap '4360-SoftAP' -apdate '2014.3.27.0' -sta_gc 'Gala-AWDL' -sta_go 'Gala-DUT' -ap_connect GO -run_qos -qos_tests '[WLAN:BE:TX:0:60][P2P:BE:TX:0:60]\|[WLAN:BE:RX:0:60][P2P:BE:RX:0:60]\|[WLAN:TCP:TX:0:60][P2P:TCP:TX:0:60]\|[WLAN:TCP:RX:0:60][P2P:TCP:RX:0:60]' -ap_chan 6 -p2p_chan 149 -wlan_bandwidth_BE 100M -p2p_bandwidth_BE 100M -awdl -no_wl_dump -nounload
#
# Sniffer (TCP WLAN ONLY):
#Test/P2PQoSNightly.test -utfconf utfconf/MCC.tcl -title "MCC 4358 PCIe 7_35 FC15 TCP WLAN Only" -sta "4358e-DUT-105" -ap "AP1-4331-4706 AP1-4360-4706" -apdate "2014.1.28.0" -perftime 25 -ap_connect GC -ap_chan 36/80 -fb1 -run_qos -qos_tests "[WLAN:TCP:RX:0:30]\|[WLAN:TCP:RX:0:30]\|[WLAN:TCP:RX:0:30]" -sniffer "snif" -sniffer_channel 36/80 -sniffer_capture_time_sec 10
#
#Running two TCP downstream simultaneously for 5 minutes:
#Test/P2PQoSNightly.test -utfconf utfconf/?.tcl -title ? -sta ? -ap ? -ap_chan ? -run_qos -qos_tests "[WLAN:TCP:RX:0:300][WLAN:TCP:RX:0:300]"
#Running two Video downstream simultaneously for 5 minutes:
#Test/P2PQoSNightly.test -utfconf utfconf/?.tcl -title ? -sta ? -ap ? -ap_chan ? -run_qos -qos_tests "[WLAN:VI:RX:0:300][WLAN:VI:RX:0:300]"
# Roaming:
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 Video Roaming" -sta "4360-FC19-DUT" -roam_src_ap "AP1-4331-4706 AP1-4360-4706" -roam_dst_ap "AP3-4331-4706 AP3-4360-4706" -sniffer "snif" -nofailoverroaming -no5G20roaming -no2G40roaming -no2G20roaming -run_qos -qos_tests "[WLAN:VI:RX]" -ap_chan "36/80" -noapload -roam_estimate_attn
#Test/P2PQoSNightly.test -utfconf utfconf/MCK.tcl -title "MCK 4360 Video Roaming" -sta "4360-FC19-DUT" -roam_src_ap "AP1-4331-4706 AP1-4360-4706" -roam_dst_ap "AP3-4331-4706 AP3-4360-4706" -sniffer "snif" -nofailoverroaming -no5G20roaming -no2G40roaming -run_qos -qos_tests "[WLAN:VI:RX]" -ap_chan "36/80" -noapload -roam_5G80_src_ap_attn "14-31" -roam_5G80_dst_ap_attn "24-0" -roam_5G80_sniffer_start_attn 26 -roam_5G40_src_ap_attn "16-33" -roam_5G40_dst_ap_attn "25-0" -roam_5G40_sniffer_start_attn 28 -roam_2G20_src_ap_attn "30-50" -roam_2G20_dst_ap_attn "22-0" -roam_2G20_sniffer_start_attn 35 -no5G40roaming -no5G80roaming -nounload -wlan_bandwidth_VI 2M
# rsdb_switch_test:
#Test/P2PQoSNightly.test -utfconf MCE -title 'MCE 4349 a2 PCIe 9_10_TOB UDP Video bi-dir Long VSDB/RSDB Test APCh=36/80 P2PCh=7' -ap '4360-SoftAP2' -apdate '2014.3.27.0' -sta_gc '4349-FC19-DUTsw' -sta_go '4349-FC19-GOsw' -nos -nod -wlan_bandwidth_VI 60M -p2p_bandwidth_VI 60M -run_qos -qos_tests '[P2P:VI:TX:0:360][WLAN:VI:TX:0:360]' -ap_chan 36/80 -p2p_chan 7 -rsdb_mode 1 -rsdb_switch_test -p2p_connection_first
# NAN test:
#Test/P2PQoSNightly.test -utfconf MCK -title 'MCK 43602 Test Cases' -sta '43602-Mst 43602-NonMst 43602-NonMst2' -nan
# AIBSS test:
#Test/P2PQoSNightly.test -utfconf MCK -title 'MCK 43602' -sta '43602-DUTt 43602-GOt 43602-DUTNPt' -aibss -run_qos -qos_tests '[WLAN:TCP:BI:0:30]' -pm_mode 1 -ap_chan 36/80 -nounload
#Test/P2PQoSNightly.test -utfconf MCK -title 'MCK 43602' -sta '43602-DUTn 43602-GOn 43602-DUTNPn' -aibss -stabin /projects/hnd_swbuild/USERS/asmolnik/build_linux/trunk/linux-external-dongle-pcie/2015.7.30.0/release/bcm/firmware/43602a1-ram/pcie-ag-splitrx-pktctx-proptxstatus-ampduhostreorder-aibss-relmcast-norsdb-redux-assert.bin -run_qos -qos_tests '[WLAN:TCP:BI:0:30]' -pm_mode 1 -ap_chan 36/80 -nostaload -norestore -nounload
# Multi-STA WLAN test:
#Test/P2PQoSNightly.test -utfconf MCP -title 'MCP 43569a2 Multi-STA TCP WLAN Only' -sta '43569-DUTx 43569-GOx 43569-DUT2x' -ap '4360-SoftAP1' -apdate '2014.3.27.0' -ap_connect GC -ap_chan 36/80 -fb1 -pm_mode 0 -no_ampdu_dump
#
# AWDL Demo:
#Test/P2PQoSNightlyptptan.test -utfconf MCH -title 'MCH 4357 Trunk AWDL Only UDP Video bi-dir Long Test AWDLCh=149/80' -sta_gc 4357-ASlave-WLAN -sta_go 4357-AMaster-WLAN -p2p_bandwidth_VI 40M -run_qos -qos_tests '[P2P:VI:BI:0:60]' -p2p_chan 149/80  -multicore_mode 0 -awdl -no_wl_dump
#Test/P2PQoSNightlyptptan.test -utfconf MCH -title 'MCH 4357 Trunk AWDL Only TCP bi-dir Long Test AWDLCh=149/80' -sta_gc 4357-ASlave-WLAN -sta_go 4357-AMaster-WLAN -run_qos -qos_tests '[P2P:TCP:BI:0:60]' -p2p_chan 149/80  -multicore_mode 0 -awdl -no_wl_dump
#Test/P2PQoSNightlyptptan.test -utfconf MCH -title 'MCH 4357 Trunk STA+AWDL UDP Video bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap 4360-SoftAP1 -apdate 2015.3.10.1 -sta_gc 4357-ASlave-WLAN -sta_go 4357-AMaster-WLAN -wlan_bandwidth_VI 10M -p2p_bandwidth_VI 10M -ap_connect GO -run_qos -qos_tests '[WLAN:VI:BI:0:20][P2P:VI:BI:0:20]' -ap_chan 8 -p2p_chan 149/80 -multicore_mode 0 -awdl -no_wl_dump
#Test/P2PQoSNightlyptptan.test -utfconf MCH -title 'MCH 4357 Trunk STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap 4360-SoftAP1 -apdate 2015.3.10.1 -sta_gc 4357-ASlave-WLAN -sta_go 4357-AMaster-WLAN -ap_connect GO -run_qos -qos_tests '[WLAN:TCP:BI:0:20][P2P:TCP:BI:0:20]' -ap_chan 8 -p2p_chan 149/80 -multicore_mode 0 -awdl -no_wl_dump
#Test/P2PQoSNightlysunder.test -utfconf MCH -title 'MCH 4357 13.10.188 STA+AWDL UDP Video bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap '4360-SoftAP1' -apdate '2015.3.10.1' -sta_gc '4357R-ASlave-WLAN' -sta_go '4357R-AMaster-WLAN' -wlan_bandwidth_VI 10M -p2p_bandwidth_VI 10M -ap_connect GO -run_qos -qos_tests '[WLAN:VI:BI:0:60][P2P:VI:BI:0:60]' -ap_chan 8 -p2p_chan 149/80 -multicore_mode 0 -awdl -no_wl_dump -stabin /projects/hnd_swbuild/build_linux/IGUANA_REL_13_10_188/linux-external-dongle-pcie/2016.7.5.0/release/bcm/firmware/4357a0-ram/config_pcie_awdl.bin
#Test/P2PQoSNightlyptp2.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL UDP Video bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap 4360-SoftAP -apdate 2015.3.10.1 -sta_gc 4355-Slave-WLAN -sta_go 4355-Master-WLAN -wlan_bandwidth_VI 10M -p2p_bandwidth_VI 10M -ap_connect GO -run_qos -qos_tests '[WLAN:VI:BI:0:20][P2P:VI:BI:0:20]' -ap_chan 8 -p2p_chan 149/80 -multicore_mode 0 -awdl -no_wl_dump
#Test/P2PQoSNightlyptp2.test -utfconf MCC -title 'MCC 4355c0 STA+AWDL TCP bi-dir Long Test VSDB APCh=8 AWDLCh=149/80' -ap 4360-SoftAP -apdate 2015.3.10.1 -sta_gc 4355-Slave-WLAN -sta_go 4355-Master-WLAN -ap_connect GO -run_qos -qos_tests '[WLAN:TCP:BI:0:20][P2P:TCP:BI:0:20]' -ap_chan 8 -p2p_chan 149/80 -multicore_mode 0 -awdl -no_wl_dump
#
##########################################################################################
# Notes:
#	Must have Network Time Protocol (NTP) setup at GO, GC, and UTF machines.
#	mac:
# 		Scripts uses IPV4
#		IPV6 and apple80211 functions work, but it is not totally complete
#	
# 	Voice functions is not implemented
# 	When doing iperf for WLAN and P2P from the same machine, we need different
#		names, so iperf results can be differentiated between WLAN and P2P
# Supported:
#	GO and GC are Linux
#	GO and GC are mac
# NOT Supported:
#	Windows GO or GC
# To Debug P2P:
#	-wlinitcmds {wl msglevel +mchan +ps +p2p +apsta +inform} 
# Chariot uses interval of 200 ms for throughput, but iperf uses min interval of 500 ms.
##########################################################################################
# NoA (Notice of Absence) setting
# wl p2p_noa <type> <action> <option> <schedule>
# 		<type> 		= 0 periodic schedule
#		<action> 	= 1 Sleep if possible
#		<option> 	= 1 beacon interval percentage
#		<schedule> 	= none
# 		<start-pct> = 10
#		<duration-pct> = 50
##########################################################################################
# Channel switch time is about 2.2 ms (from the log data "wlc_set_chanspec - completed")
##########################################################################################
# Iperf:
# Version 2.0.5 has high CPU usage when using "-D" to start the server as daemon
# iperf_install_location_linux "/projects/hnd/archives/unix/UTF/usr/local/bin"
# iperf_install_location_mac   "/projects/hnd/archives/Mac/UTF/usr/bin"
#################################
# IPERF params:
#################################
# S - TOS - Type of Service: (or AC for Access Class)
# 765 4 3210 AC TOS  pktq_stats prec#
# ========== == ==== ================
# 000 0 0000 BE 0x00 0
# 001 0 0000 BK 0x20 2
# 010 0 0000 BK 0x40 4
# 011 0 0000 BE 0x60 6
# 100 0 0000 VI 0x80 8
# 101 0 0000 VI 0xA0 10
# 110 0 0000 VO 0xC0 12
# 111 0 0000 VO 0xE0 14
#################################
# l - length or packet size - 8 KB default
# BE 512
# BK 512
# VI 1470
# VO 200
#################################
# b - bandwidth or rate - 1 Mbps default
# BE 200M
# BK 25M
# VI 3.5M
# VO 8kbps
#################################
##########################################################################################
# QoS:
# 3 stream with total time of 30 sec
# stream 1 and 2 starts at 0 sec. stream 3 starts at 15 sec
# Throughput data:
#	part 1 from 3 to 13 for streams 1 and 2
#	part 2 from 18 to 28 for streams 1, 2, and 3
#
##############################
# All the 3 streams TOS
##############################
# BK BE BK
# VO BE VO (not used)
# VI BE VI (not used)
# --------
# BE VO BE 
# BK VO BK 
# VI VO VI 
# --------
# VO VI VO (not used) 
# BE VI BE 
# BK VI BK
# --------
# VI BK VI (not used)
# VO BK VO (not used)
# BE BK BE (not used)
##############################
##########################################################################################
# Gnuplot:
# line type 0 - dashed grey
# line type 1 - solid light red
# line type 2 - solid light green
# line type 3 - solid light blue
# line type 4 - solid light purple
# line type 5 - solid aqua
# line type 6 - solid brown
# line type 7 - solid yellow
# line type 8 - solid dark blue
# line type 9 - solid gold
# line type 10 - solid dark green
# line type 11 - solid dark purple
# line type 12 - solid dark brown
# line type 13 - solid light pink
# line type 14 - solid lime green
# line type 15 - solid grey blue
# line type 154 - solid orange
#----------------
# point type 0 - none
# point type 1 - horizontal bar
# point type 7 - open box 
#----------------
# point size 0 - none
# point size 1 - smallest
#----------------
# line width 1 point
# line width 2 points
##########################################################################################
# VSDB -> same band channels for both WLAN and P2P -> Mimo -> nrate = 2x9 -> rsdb_mode = 0
# RSDB -> multi- WLAN on one band and P2P on the other band -> Siso -> nrate = 1x9 -> rsdb_mode = 1
##########################################################################################
# Samsung oxygen sensor uses ADHOC network. Advanced IBSS (Independent Basic Service Set) called AIBSS is used 
# which can support up to 32 devices.  
#
#
# NANDP Info:
# It receives a Synchronization Beacon 1 frame with the RSSI higher than RSSI_close from a NAN Device within the same NAN Cluster,
# and the Master Rank of the Synchronization Beacon transmitter is higher than the device’s Master Rank, or it receives Synchronization 
# Beacon frames from three or more NAN Devices within the same NAN Cluster with RSSI higher than RSSI_middle and the Master Rank of 
# those devices are higher than the Master Rank of the receiving device the value for RSSI_close shall be greater than -60 dBm. The 
# value for RSSI_middle shall be greater than -75 dBm and less than the value defined for RSSI_close.
# If rssi is between RSSI_Close (-60dBm) to RSSI_middle (-75dBm), then device could take master role.  It is same for both 2.4g & 5g.

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::p2p_help "\n\nBasic usage: Test/P2PQoSNightly.test <options>\
	\n\nThis script will setup your P2P test rig by loading the desired\
	\nbuilds, making connections between your wireless devices & running numerous\
	\ntests."

# Command line options string
set ::p2p_getopts {
	{suiteid.arg "meta" "Metacript ID used for data store"}
	{email.arg ""		"Email address list, format: userid1,userid2,... default is your userid"}
	{title.arg ""		"Title description text string for use in the reports"}
	{ap.arg ""			"WLAN router name.  For simultaneous dualband routers, use a pair '2g 5g'"}
	{aptag.arg "" 		"Router release tag"}
	{apdate.arg "" 		"AP Image date"}
	{trx.arg "" 		"Router trx"}
	{stabin.arg "" 		"Private build STA dongle image (rtecdc.bin firmware)"}
	{stadhd.arg "" 		"Private build STA dongle Linux DHD image (wl.ko high driver)"}
	{statag.arg "" 		"STA release tag"}
	{stadate.arg ""		"STA Image date"}
	{stadhddate.arg ""	"STA DHD Image date"}
	{branch.arg "auto" 	"Branch override"}
	{noapload 			"Don't load images"}
	{nostaload 			"Don't reload STA drivers"}
	{nostareload 		"Don't even reload STA drivers"}
	{norestore 			"Don't reset to defaults"}
	{nounload 			"Don't unload driver after test"}
	{nosetup 			"No Setup"}
	{nocache 			"Don't update performance cache"}
	{noping				"Don't run ping/ayt tests, default is run the ping/ayt tests"}
	{nosetuptestbed 	"Don't run Setup Testbed hooks"}
	{noposttesthook 	"Don't run Post Test hooks"}
	{logdir.arg ""		"Log directory override"}
	{run_opp_ps			"run OppPS tests"}
	{run_noa			"run NoA tests"}
	{nos				"Don't run ANY Same Channel tests"}
	{nod				"Don't run ANY Direct tests"}
	{nom				"Don't run ANY Multi Channel tests"}
	{history.arg 30		"Performance history samples to keep in perfcache data"}
	{perfint.arg 1		"Test interval in seconds for each test sample"}
	{perfloop.arg 1		"Total performance test iterations"}
	{perftime.arg 25	"Total time duration, in seconds, for each performance tests"}
	{retry.arg 3		"Number of times to try rebooting an unresponsive host"}
	{sta_go.arg ""		"P2P GO (Group Owner) STA to test."}
	{sta_gc.arg ""		"P2P GC (Group Client) STA to test."}
	{sta.arg ""			"WLAN STA to test without any P2P testing (Do not create a P2P connection and run WLAN throughput only)."}
	{p2p_chan.arg "149/80 157l 157 11 1 40"	"Specify channels GO/DUT is to test"}
	{ap_chan.arg "36/80 36l 36 1 44l 11"	"Specify channels AP is to test"}
	{ap_connect.arg ""	"P2P connections to the AP. Default is BLANK"}
	{OppPS_CTWindow.arg "50"	"OppPS CTWindow Parameter (see P2P documents)"}
	{NoA_Param.arg "0 1 1 10 50"	"NoA (Notice of Absence) Parameters (see P2P documents)"}
	{use_wl_for_mac		"Use wl commands for P2P setup on mac instead of default apple80211 tool"}
	{debug_flag			"This flag will enable debug dumps"}
	{debug2_flag		"This flag will enable socram and FW image dumps"}
	{fb0				"This flag will enable non-frameburst testing"}
	{fb1				"This flag will enable frameburst testing"}
	{wlan_security.arg {open} "Enable WLAN Security. Default is Open Security (not aespsk2)"}
	{p2p_security		"Enable P2P Security. It is always wpa2psk security"}
	{wlan_bandwidth_VO.arg 	"10M"	"Voice wlan bandwidth or rate list for each WLAN channel. Default is 10M"}
	{p2p_bandwidth_VO.arg 	"10M"	"Voice p2p bandwidth or rate list for each P2P channel. Default is 10M"}
	{wlan_bandwidth_VI.arg 	"40M"	"Video wlan bandwidth or rate list for each WLAN channel. Default is 40M"}
	{p2p_bandwidth_VI.arg 	"40M"	"Video p2p bandwidth or rate list for each P2P channel. Default is 40M"}
	{wlan_bandwidth_BE.arg 	"1.2g"	"Best-effort wlan bandwidth or rate list for each WLAN channel. Default is 1.2g"}
	{p2p_bandwidth_BE.arg 	"1.2g"	"Best-effort p2p bandwidth or rate list for each P2P channel. Default is 1.2g"}
	{wlan_bandwidth_BK.arg 	"40M"	"Background wlan bandwidth or rate list for each WLAN channel. Default is 40M"}
	{p2p_bandwidth_BK.arg 	"40M"	"Background p2p bandwidth or rate list for each P2P channel. Default is 40M"}
	{wlan_packet_size_VO.arg "200"	"Voice wlan packet size or length list for each WLAN channel. Default is 200"}
	{p2p_packet_size_VO.arg "200"	"Voice p2p packet size or length list for each P2P channel. Default is 200"}
	{wlan_packet_size_VI.arg "1470"	"Video wlan packet size or length list for each WLAN channel. Default is 1470"}
	{p2p_packet_size_VI.arg "1470"	"Video p2p packet size or length list for each P2P channel. Default is 1470"}
	{wlan_packet_size_BE.arg "512"	"Best-effort wlan packet size or length list for each WLAN channel. Default is 512"}
	{p2p_packet_size_BE.arg "512"	"Best-effort p2p packet size or length list for each P2P channel. Default is 512"}
	{wlan_packet_size_BK.arg "512"	"Background wlan packet size or length list for each WLAN channel. Default is 512"}
	{p2p_packet_size_BK.arg "512"	"Background p2p packet size or length list for each P2P channel. Default is 512"}
	{vsdb_mode.arg ""	"Virtual Simultaneous Daul Band Algorithm Mode. 0=Default (Beacon Position based), 1=Bandwidth Based, 2=Service Interval Based"}
	{vsdb_bw_percentage.arg "50" "Virtual Simultaneous Daul Band Bandwidth Perventage for Bandwidth Based Algorithm Mode. Default=50% for primary channel, rest for secondary channel"}
	{rsdb_mode.arg ""	"Real Simultaneous Daul Band Mode. BLANK=Default, 0=RSDB off (VSDB mode for same band), 1=RSDB on (for multi-band)"}
	{nrate_check.arg ""				"Check the nrate value. BLANK=Default, 1x9=RSDB 2x9=VSDB"}
	{rsdb_switch_test				"Run test to switch between RSDB and VSDB and validate the MCS rate"}
	{mpc_mode.arg ""	"MPC Mode. BLANK=Default, 0=MPC off, 1=MPC on"}
	{notx				"Don't run transmit direction tests, default is to run transmit tests"}
	{norx				"Don't run receive direction tests, default is to run receive tests"}
	{nobi				"Don't run bidirectional tests, default is to run bidirectional tests"}
	{quick_exit			"exit right after the 1st throughput is ran"}
	{nowlanup				"Don't run WLAN upstream tests, default is to run upstream tests"}
	{nowlandn				"Don't run WLAN downstream tests, default is to run downstream tests"}
	{nowlanbid				"Don't run WLAN bidirectional tests, default is to run bidirectional tests"}
	{nop2pup				"Don't run P2P upstream tests, default is to run upstream tests"}
	{nop2pdn				"Don't run P2P downstream tests, default is to run downstream tests"}
	{nop2pbid				"Don't run P2P bidirectional tests, default is to run bidirectional tests"}
	{graphs_with_min_max	"Generate graphs with min max values, default is graphs without min max values"}
	{new_beacon_interval.arg ""	"Change beacon interval to the new value. Default is blank (no beacon interval change. Default driver bi=100 ms)"}
	{qos_ampdu_mode.arg "1"	"Turn AMPDU on/off. Default is 1 (on)"}
	{measure_current_sta.arg ""	"Measurement current in middle of throughput run on the STA with Agilent instrument. Default is no current measurement"}
	{pm_mode.arg "2"		"PM mode to use for WLAN and P2P. Default is the driver PM 2 mode"}
	{no_ampdu_dump			"Do not dump ampdu while running throughput since it causes RX throughput drop, default is to run throughput with ampdu dump"}
	{no_wl_dump				"Do not dump any wl data while running throughput, default is to run throughput with wl data dump"}
	{scan_flag				"Do scan in the background while the throughput is running"}
	{escan_flag				"Do escan in the background while the throughput is running"}
	{kpi_flag				"Use KPI test special data collection"}
	{macos_pcap_flag		"For MacOS, dump PCAP for debugging"}
	{bt_root_sta.arg ""		"BT STA object with 'root' login. Default is BLANK"}
	{bt_user_sta.arg ""		"BT STA object with 'user' login (is needed for playFileIniTunes). Default is BLANK"}
	{bt_wav_file.arg "/Users/user/Music/iTunes/OneHour.wav"	"BT iTune wav file to play with playFileIniTunes)"}
	######################################################################################################################														
	{current_sample_time.arg "300E-6"	"Setup the sampling interval (5.12 to 40000 us). Default is 300 us sample time (300E-6 * 50000 = 15 seconds total measure time)"}
	{current_sample_points.arg "50000"	"Setup the number of points to measure the current (1 to 512K). Default is 50000 samples"}
	{current_offset_points.arg "-500"	"Setup the offset points before/after sampling starts. Default is -500 points"}
	{current_range.arg "1.0"	"Setup the current range. Default is 1 Amp"}
	{current_trigger.arg "0.075"	"Setup the starting current trigger point. Default is 75 mA"}
	{current_wait_sec.arg "0"	"Time to wait before reading the current results. Default is 3 seconds"}
	######################################################################################################################														
	{gnuplot_font.arg "/usr/share/fonts/dejavu/DejaVuSans-Bold.ttf"	"GNUPLOT font to use for the graphs"}
	{gnuplot_font_size.arg "8"	"GNUPLOT font size to use for the graphs"}
	######################################################################################################################														
	{sniffer.arg 					""	"sniffer object name"}
	{sniffer_channel.arg			"" 	"sniffer channel to use for data capture"}
	{sniffer_capture_time_sec.arg	""	"Time in sec to collect data. BLANK=Default (no capture)"}
	######################################################################################################################														
	{multicore_mode.arg ""	"CPU 1,2,3 mode on STAs. BLANK=Default, 1=multicore on, 0=multicore off"}
	{ping_count.arg "5"	"Number of times to ping. Default is 5 times"}
	{p2p_connection_first	"First create P2P and then AP connections instead of first creating AP and then P2P connections"}
	{run_qos			"Run QoS tests and not P2P"}
	{qos_p2p_traffic	"Run QoS tests using P2P instead of WLAN"}
	{tests_tos.arg "TCP"	"tests traffic type 'TCP,VI,VO,BE,BK'. Default is TCP"}
	{enable_ntp			"Enable NTP"}
	######################################################################################################################														
	{tests.arg "\
					[WLAN:RX]|\
					[WLAN:TX]|\
					[WLAN:BI]|\
					[P2P:RX]|\
					[P2P:TX]|\
					[P2P:BI]|\
					[WLAN:RX][P2P:RX]|\
					[WLAN:RX][P2P:TX]|\
					[WLAN:RX][P2P:BI]|\
					[WLAN:TX][P2P:RX]|\
					[WLAN:TX][P2P:TX]|\
					[WLAN:TX][P2P:BI]|\
					[WLAN:BI][P2P:RX]|\
					[WLAN:BI][P2P:TX]|\
					[WLAN:BI][P2P:BI]|\
												"	"This is the list of all the P2P tests that will be run.\
														Runing 1 Iperf stream has the following format:\
															[stream_type:stream_direction]\
															Where:\
															sta_no is used only with multi-sta\
															stream_type is WLAN or P2P\
															stream_direction is TX RX\
														You can group multiple Iperf stream to run simultaneously by putting '|' at the end"}
	######################################################################################################################														
	{qos_tests.arg "\
					[WLAN:BK:TX:0:25][WLAN:BE:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:BE:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:BE:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:BE:RX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:BE:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:BE:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:BE:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:BE:RX:0:25][WLAN:BK:RX:5:15]|\
					\
					[WLAN:BE:TX:0:25][WLAN:VO:TX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VO:TX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VO:RX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VO:RX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VO:TX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VO:TX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VO:RX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VO:RX:0:25][WLAN:BE:RX:5:15]|\
					\
					[WLAN:BK:TX:0:25][WLAN:VO:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VO:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VO:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VO:RX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VO:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VO:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VO:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VO:RX:0:25][WLAN:BK:RX:5:15]|\
					\
					[WLAN:VI:TX:0:25][WLAN:VO:TX:0:25][WLAN:VI:TX:5:15]|\
					[WLAN:VI:TX:0:25][WLAN:VO:TX:0:25][WLAN:VI:RX:5:15]|\
					[WLAN:VI:TX:0:25][WLAN:VO:RX:0:25][WLAN:VI:TX:5:15]|\
					[WLAN:VI:TX:0:25][WLAN:VO:RX:0:25][WLAN:VI:RX:5:15]|\
					[WLAN:VI:RX:0:25][WLAN:VO:TX:0:25][WLAN:VI:TX:5:15]|\
					[WLAN:VI:RX:0:25][WLAN:VO:TX:0:25][WLAN:VI:RX:5:15]|\
					[WLAN:VI:RX:0:25][WLAN:VO:RX:0:25][WLAN:VI:TX:5:15]|\
					[WLAN:VI:RX:0:25][WLAN:VO:RX:0:25][WLAN:VI:RX:5:15]|\
					\
					[WLAN:BE:TX:0:25][WLAN:VI:TX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VI:TX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VI:RX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:TX:0:25][WLAN:VI:RX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VI:TX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VI:TX:0:25][WLAN:BE:RX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VI:RX:0:25][WLAN:BE:TX:5:15]|\
					[WLAN:BE:RX:0:25][WLAN:VI:RX:0:25][WLAN:BE:RX:5:15]|\
					\
					[WLAN:BK:TX:0:25][WLAN:VI:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VI:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VI:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:TX:0:25][WLAN:VI:RX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VI:TX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VI:TX:0:25][WLAN:BK:RX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VI:RX:0:25][WLAN:BK:TX:5:15]|\
					[WLAN:BK:RX:0:25][WLAN:VI:RX:0:25][WLAN:BK:RX:5:15]|\
												"	"This is the list of all the QoS tests that will be run.\
														Runing 1 Iperf stream has the following format:\
															[stream_type:stream_tos:stream_direction:stream_start_time:stream_time_duration]\
															Where:\
															sta_no is used only with multi-sta\
															stream_type is WLAN or P2P\
															stream_tos (Type of Service) is VO VI BE BK\
															stream_direction is TX RX\
															stream_start_time is the delay time in sec before starting the Iperf\
															stream_time_duration is the time in sec to run this iperf stream\
														You can group multiple Iperf stream to run simultaneously by putting '|' at the end"}
	######################################################################################################################														
	{testbed_path_loss.arg	 "0" "Testbed fixed path lose in dB"}
	{attn_type.arg 0	 	 "Types of RvR attenuation: 0=None, 1=WLAN, 2=P2P, 3=WLAN+P2P. Default is 0 (none)"}
	{rvr_attn_incr.arg		 "1" "RvR attenuation increment for each step. Default is 2 dB"}
	{rvr_wlan_attn_range.arg "10-90 90-10" "RvR WLAN attenuation range"}
	{rvr_p2p_attn_range.arg	 "10-90 90-10" "RvR P2P attenuation range"}
	######################################################################################################################														
	{roam_src_ap.arg		"" "Router roaming from"}
	{roam_dst_ap.arg		"" "Router roaming to"}
	{no5G80roaming			"No 5G 80Mhz Roaming Tests"}
	{no5G40roaming			"No 5G 40Mhz Roaming Tests"}
	{no5G20roaming			"No 5G 20Mhz Roaming Tests"}
	{no2G40roaming			"No 2G 40Mhz Roaming Tests"}
	{no2G20roaming			"No 2G 20Mhz Roaming Tests"}
	{nosmoothroaming 		"Don't do Smooth Roaming Test"}
	{nofailoverroaming 		"Don't do Failover Roaming Test"}
	{roam_estimate_attn 	"Display the estimated values for the attenuation on the report"}
	{roam_5G80_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_src_ap_attn.arg				 "" "This is the attenuation range for the source AP that the DUT is orginally connected to. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_dst_ap_attn.arg				 "" "This is the attenuation range for the dstination AP that the DUT is roaming to. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G40_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G20_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_2G40_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_2G20_sniffer_start_attn.arg		 "" "This is the attenuation level that the sniffer starts collecting data. Keep this as blank since the command line must set this parameter."}
	{roam_5G80_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_5G40_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_5G20_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_2G40_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	{roam_2G20_roam_trigger_value.arg		 "" "This is the roam trigger value. Default is blank."}
	######################################################################################################################														
	{awdl				"Use AWDL (Apple Wifi Direct Link) to run tests, default is non AWDL mode"}
	######################################################################################################################														
	{nan				"Run NANDP (Neighbor Awareness Networking Discovery Protocol) tests, default is not running NAN tests"}
	{nan_msch_collect	"Use 'wl msch_collect 1' when running NANDP tests, default is not to use 'wl msch_collect 1'" with NANDP tests}
	{aibss				"Run AIBSS (Advanced IBSS) tests, default is not running AIBSS tests"}
	{11mc				"Run 11mc tests, default is not running 11mc tests"}
	{nan2				"Run NAN 2.0 (Neighbor Awareness Networking Discovery Protocol) tests, default is not running NAN2 tests"}
	######################################################################################################################														
}

# Setup online help info.
UTF::setup_help $::p2p_help $::p2p_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
	set ::argv ""
}

# Load packages
package require UTF
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec
package require UTF::Test::APConfigureSecurity
package require UTF::Test::controlchart
package require UTF::Test::memchart
package require UTF::Test::rssinoise
package require UTF::MemChart
package require UTF::Sniffer
package require math
package require UTF::KPI::KeyValue
package require UTF::KPI::OSEvents

namespace eval p2p {}

################
set ::p2p_load_flag 0
set ::p2p_only_flag 0
set ::p2p_chan ""
set ::chanspec_p2p ""
set ::p2p_security ""
set ::mac_p2p_security_flag 0
set ::p2p::cc_error ""
set ::rvr_p2p_attngrp ""
set ::p2p_cleanup_flag 0
set ::p2p_ssid "P2PSSID"
set ::list_gc_wlan_objects ""
set ::go_wlan ""
################
set ::awdl_flag 0
################
set ::nan_ping_flag 0
set ::nan2_flag 0
set ::nan_base_cluster_id ""
################
set ::bt_load_flag 0
set ::bt_only_flag 0
################
set ::wlan_load_flag 0
set ::wlan_only_flag 0
set ::wlan_ap ""
set ::wlan_chan ""
set ::chanspec_wlan ""
set ::wlan_security ""
set ::list_sta_wlan_objects ""
set ::rvr_wlan_attngrp ""
################
set ::iperf_running_flag 0
set ::iperf_server_err ""
set ::iperf_starting_port 55001
set ::curr_iperf_port 0
################
set ::perfint 0
set ::perfloop 0
set ::history 0
set ::curr_stream_time 0
set ::apple_tool "/usr/local/bin/apple80211"
set ::test_type ""
set ::catch_resp 0
set ::catch_msg ""
set ::use_wl_for_mac 0
set ::ap_str ""
set ::key_base ""
set ::key_base2 ""
set ::ckey ""
set ::vsdb_mode ""
set ::vsdb_bw_percentage ""
set ::rsdb_mode ""
set ::mpc_mode ""
set ::err_msg ""
set ::curr_udp_packet_size 0
set ::curr_udp_bandwidth 0
set ::qos_streams_total_time ""
set ::agilent_obj ""
set ::agilent_port ""
set ::voltage 0
set ::current_results ""
set ::pktq_stats_flag 0
set ::soft_ap_flag 0
set ::list_ap_objects ""
set ::list_possible_interface_objects ""
set ::list_existing_interface_objects ""
set ::list_active_interface_objects ""
set ::connection_test_flag 0
set ::streams_total_error ""
set ::roaming_error_flag 0
set ::test_error_flag 0
set ::curr_csv_data_file ""
set ::curr_csv_data_fullname ""
set ::curr_csv_throughput_data_file ""
set ::curr_csv_throughput_data_fullname ""
set ::curr_gnuplot_data_line_cnt 0
set ::ping_count 0
set ::gnuplot_font ""
set ::gnuplot_font_size 0
set ::rvr_attn_incr 0
set ::rvr_test_flag 0
set ::rvr_zero_throughput_flag 0
set ::gnuplot_xtic_label ""
set ::gnuplot_x_max_rvr_val ""
set ::gnuplot_x_max_time_val ""
set ::curr_attn_incr 0
set ::graph_max_width 0
set ::graph_max_height 0
set ::curr_attn_value 0
set ::saved_hook_start_timestamp ""
set ::sniffer_object ""
set ::sniffer_channel ""
set ::sniffer_capture_time_sec ""
set ::sniffer_started_flag 0
set ::sniffer_filename ""
set ::sniffer_process_id 0
set ::sniffer_start_time_secs 0
set ::max_attn 0
set ::roaming_test_flag 0
set ::failover_test_flag 0
set ::roam_trigger_value ""
set ::roam_delta_value ""
set ::roaming_src_ap ""
set ::roaming_dst_ap ""
set ::roaming_channel 0
set ::roaming_dwell_time_sec 0
set ::roaming_max_loop_cnt 0
set ::roaming_src_ap_attn 0
set ::roaming_src_ap_attn_start 0
set ::roaming_src_ap_attn_end 0
set ::roaming_dst_ap_attn 0
set ::roaming_dst_ap_attn_start 0
set ::roaming_dst_ap_attn_end 0
set ::roaming_src_ap_mac ""
set ::roaming_dst_ap_mac ""
set ::roaming_src_ap_attn_group ""
set ::roaming_dst_ap_attn_group ""
set ::roaming_sniffer_file_name ""
set ::roaming_sniffer_start_attn 0
set ::roaming_sniffer_failed_flag 0
set ::roaming_sniffer_failed_msg ""
set ::roaming_test_title ""
set ::roaming_test_ssid "RoamingTestSSID"
set ::roaming_band ""
set ::roaming_cap ""
set ::roamed_flag 0
set ::roam_time -1
set ::roaming_html_results ""				
set ::last_csv_data_BaseTime ""
set ::last_csv_throughput_data_BaseTime ""
set ::error_cnt 0
set ::base_timestamp_tick 0
set ::multi_sta_flag 0
set ::halt_test_err ""
set ::panic_msg ""
set ::scan_test_flag 0
set ::escan_test_flag 0
set ::kpi_test_flag 0


proc p2p::random_number {min max} {
	return [expr int(rand()*($max-$min+1)) + $min] 
}

proc p2p::get_testnum { } {
    set testnum [file tail $UTF::Logfile]
    set testnum [file rootname $testnum]
    set testnum [string trim $testnum]
    return $testnum
}

proc p2p::get_name {object} {

	UTF::Message INFO "" "************************Func:get_name $object***************************"
    # Get proper host name for case of STA.
	UTF::Message INFO "" "$object cget -host"
    set catch_resp [catch "set x \[$object cget -host\]" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
    if {$catch_resp == 0} {
        set host $x
    } else {
        set host $object
    }
    if {$host == ""} {
        set host $object
    }

    # Return name.
	UTF::Message INFO "" "$host cget -name"
    set catch_resp [catch "set name \[$host cget -name\]" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
    if {$catch_resp != 0} {
        set name $host
    }
    if {$name == ""} {
        set name $host
    }
    
	UTF::Message LOG "" "get_name object=$object host=$host name=$name"

    return "$name"
}

proc p2p::collect_rpopen_data {timeout_sec timed_host_fd_list timed_output\
    untimed_host_fd_list untimed_output} {
    upvar $timed_output timed_response
    upvar $untimed_output untimed_response

	UTF::Message INFO "" "************************Func:collect_rpopen_data***************************"

    # Check timeout is numeric, GE 1.
    if {![regexp {^\d+$} $timeout_sec] || $timeout_sec < 1} {
        error "invalid timeout_sec=$timeout_sec,\
            must be integer, GE 1"
    }

    # We need at least one pair of host & fd in one of the lists.
    if {[llength $timed_host_fd_list] < 2 && [llength $untimed_host_fd_list] < 2} {
        error "Need at least one host & fd\
            specified in either of: timed_host_fd_list=$timed_host_fd_list\
            untimed_host_fd_list=$untimed_host_fd_list"
    }

    # Check that output variables are not null & not the same.
    set timed_output [string trim $timed_output]
    set untimed_output [string trim $untimed_output]
    if {$timed_output == "" || $untimed_output == ""} {
        error "output variables must not be\
            null, timed_output=$timed_output untimed_output=$untimed_output"
    }
    if {$timed_output == $untimed_output} {
        error "output variables must not be\
            the same, timed_output=$timed_output untimed_output=$untimed_output"
    }

    # Load each list host names & file descriptor parameters into an array.
    UTF::Message LOG "" "timeout_sec=$timeout_sec timed_host_fd_list=$timed_host_fd_list\
            timed_output=$timed_output untimed_host_fd_list=$untimed_host_fd_list\
            untimed_output=$untimed_output"
    set cnt_timed 0
    set cnt_untimed 0
    set i 0
    foreach {host_fd_list timing} [list $timed_host_fd_list timed\
        $untimed_host_fd_list untimed] {
        # puts "host_fd_list=$host_fd_list timing=$timing"
        foreach {host fd} $host_fd_list {
            set host [string trim $host]
            set fd [string trim $fd]
            if {$host == "" || $fd == ""} {
                continue
            }

            # Get proper log host name for case of STA.
            #set logname [p2p::get_name $host]
            set logname $host

            # Store data in next array column.
            incr i
            incr cnt_$timing
            set array(host,$i) $host
            set array(logname,$i) $logname
            set array(fd,$i) $fd
            set array(timing,$i) $timing ;# each fd is shown as timed or untimed

            # configure fd options
            set catch_resp [catch "fconfigure $fd -buffering line -buffersize 1024" catch_msg]
            if {$catch_resp != 0} {
                UTF::Message WARN "" "fconfigure $fd\
                catch_resp=$catch_resp catch_msg=$catch_msg"
            }
        }
    }
    # puts "i=$i cnt_timed=$cnt_timed cnt_untimed=$cnt_untimed"

    # Wait for any of the file descriptors to produce output.
    set start_sec [clock seconds]
    while { 1 } {

        # In order to implement a timer, we need to periodically go 
        # through this while loop so we can check on overall elapsed
        # time and take recovery action as needed. So we use a 1 sec timer
        # to ensure this occurs.

        # Vwait needs to see some code in the current routine / file that
        # conditionaly writes to the variable that vwait will watch. If the
        # after statement is removed, you get TCL error "can't wait for
        # variable ::p2p_utils_reading, would wait forever".
        after 1000 {set ::p2p_utils_reading 1}

        # All the file descriptor event handlers have been told to 
        # write to the same global variable ::p2p_utils_reading. We use
        # vwait to wait for output from any of the file descriptors.
        vwait ::p2p_utils_reading

        # vwait received an event. We may have some output to process now.
        # Check each not-null fd in the array.
        set timed_done yes
	    for {set j 1} {$j <= $i} {incr j} {

            # Ignore any blank fd, we are done with them.
            set fd $array(fd,$j)
            set host $array(host,$j)
            set logname $array(logname,$j)
            set timing $array(timing,$j)
            # puts "j=$j fd=$fd host=$host logname=$logname timing=$timing"
            if {$fd == ""} {
                continue
            } elseif {$timing == "timed"} {
                set timed_done no
            }

            # Try to get data from fd.
            set msg ""
            set catch_resp [catch "set msg \[gets $fd\]" catch_msg]
            # puts "catch_resp=$catch_resp catch_msg=$catch_msg"
            if {$catch_resp != 0} {
                # This fd may have been valid earlier, but it is now expired.
                UTF::Message WARN "" "fd=$fd $catch_msg"
                set array(fd,$j) "" ;# we are done with this fd
                continue
            }

            # Process data from fd.
            if {[eof $fd]} {
                UTF::Message LOG "" "got normal EOF, closing fd=$fd host=$host"
                # Put file descriptor back to blocking so that close can
                # get a valid return status
                fconfigure $fd -blocking 1
                if {[catch {close $fd} ret]} {
                    UTF::Message ERROR "" "ERROR closing fd=$fd $ret"
                }
                set array(fd,$j) "" ;# we are done with this fd

            } elseif {![fblocked $fd]} {
                # Keep timed output separate from untimed_output.
                # Add timestamps to the _response data.
                set hhmmss [clock format [clock seconds] -format "%T"]
                if {$timing == "timed"} {
                    lappend timed_response "$hhmmss $host $msg" ;# dont use logname here!
                } else {
                    lappend untimed_response "$hhmmss $host $msg" ;# dont use logname here!
                }
                UTF::Message LOG "" $msg
            }
        }

        # Are we done or timed out?
        # NB: If we had only untimed fd, then we exit loop only on timeout.
        set elapsed_sec [expr {[clock seconds] - $start_sec}]
        # puts "elapsed_sec=$elapsed_sec"
        if {($timed_done == "yes" && $cnt_timed > 0) || $elapsed_sec > $timeout_sec} {
            break
        }
    }

    # If we timed out, terminate the pids associated for each timed file
    # descriptor that has not already been closed. Leave the untimed file
    # descriptors alone!
    if {$elapsed_sec > $timeout_sec} {
       	for {set j 1} {$j <= $i} {incr j} {
            set fd $array(fd,$j)
            set host $array(host,$j)
            set timing $array(timing,$j)
            if {$fd != "" && $timing == "timed"} {
                set pid [pid $fd]
                UTF::Message WARN "" "timeout, terminating fd=$fd pid=$pid for host=$host"
                set catch_resp [catch "exec kill -9 $pid" catch_msg]
				UTF::Sleep 1
                if {$catch_resp != 0} {
                    UTF::Message ERROR "" "did not terminate pid=$pid: $catch_msg"
                }
            }   
        }
    }

    # To simplify debugging, show list of untimed fd that are still open.
    if {$cnt_untimed > 0} {
        set untimed_list ""
        for {set j 1} {$j <= $i} {incr j} {
            set fd $array(fd,$j)
            set host $array(host,$j)
            set timing $array(timing,$j)
            if {$fd != "" && $timing == "untimed"} {
                lappend untimed_list "$host $fd"
            }
        }
        UTF::Message INFO "" "still active untimed host & fd: $untimed_list"
    }

    return ""
}

proc p2p::kpi_dump_xml_data {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:kpi_dump_xml_data***************************"

	set kpi_test_db [UTF::KPI::KeyValue %AUTO% -parent $::kpi_base_db]

    $kpi_test_db set tryID $::UTF::__tryid
    $kpi_test_db set "logfile" $UTF::Logfile

	foreach stream_index $::streams_name_list {

		$::kpi_base_db set "InfraChannel" "$::wlan_chan"
		$::kpi_base_db set "AWDLChannel" "$::p2p_chan"

		########## linktype can be 'Infra, AWDL, BT' ##########
		if {$::array_streams_type(${stream_index}) == "WLAN"} {
			set linktype "Infra"
		} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
			set linktype "AWDL"
		} elseif {$::array_streams_type(${stream_index}) == "BT"} {
			set linktype "BT"
		} else {
			set linktype ""
		}
		
		$::kpi_base_db set "linktype" "$linktype"

		########## traffic_direction can be 'Downlink, Uplink, Bidirectional' ##########
		if {$::array_streams_direction(${stream_index}) == "BIRX" || $::array_streams_direction(${stream_index}) == "BITX"} {
			set traffic_direction "Bidirectional"
		} elseif {$::array_streams_direction(${stream_index}) == "RX"} {
			set traffic_direction "Downlink"
		} elseif {$::array_streams_direction(${stream_index}) == "TX"} {
			set traffic_direction "Uplink"
		} else {
			set traffic_direction ""
		}
		
		$::kpi_base_db set "traffic_direction" "$traffic_direction"

		########## TrafficType can be 'TCP, UDP, A2DP' ##########
		########## TrafficPriority can be 'BE, BK, VI, VO' ##########
		if {$::array_streams_type(${stream_index}) == "BT"} {
			set TrafficType "A2DP"
			set TrafficPriority ""
		} elseif {$::array_streams_tos(${stream_index}) == "TCP"} {
			set TrafficType "TCP"
			set TrafficPriority "BE"
		} else {
			set TrafficType "UDP"
			set TrafficPriority $::array_streams_tos(${stream_index})
		}
		
		$::kpi_base_db set "TrafficType" "$TrafficType"
		$::kpi_base_db set "TrafficPriority" "$TrafficPriority"

		##########
		
		$::kpi_base_db set "trytext" "$stream_index"
		if {$::test_error_flag == 0} {
			$::kpi_base_db set "TryResult" "PASS"
		} else {
			$::kpi_base_db set "TryResult" "FAIL"
		}

		set actual_throughput_data_cnt [llength $::array_streams_throughput(${stream_index})]
		# devide by 2 to remove the timestamp
		set actual_throughput_data_cnt [expr {$actual_throughput_data_cnt / 2.0}]

		UTF::Message INFO "" "::array_streams_throughput(${stream_index})=$::array_streams_throughput(${stream_index})"
		if {$::array_streams_tcp_writes(${stream_index}) != ""} {
			UTF::Message INFO "" "::array_streams_tcp_rtt(${stream_index})=$::array_streams_tcp_rtt(${stream_index})"
			UTF::Message INFO "" "::array_streams_tcp_writes(${stream_index})=$::array_streams_tcp_writes(${stream_index})"
			UTF::Message INFO "" "::array_streams_tcp_errors(${stream_index})=$::array_streams_tcp_errors(${stream_index})"
			UTF::Message INFO "" "::array_streams_tcp_retries(${stream_index})=$::array_streams_tcp_retries(${stream_index})"
			UTF::Message INFO "" "::array_streams_tcp_used_memory(${stream_index})=$::array_streams_tcp_used_memory(${stream_index})"
		}
		if {$::array_streams_udp_jitter(${stream_index}) != ""} {
			UTF::Message INFO "" "::array_streams_udp_latency_avg(${stream_index})=$::array_streams_udp_latency_avg(${stream_index})"
			UTF::Message INFO "" "::array_streams_udp_jitter(${stream_index})=$::array_streams_udp_jitter(${stream_index})"
			UTF::Message INFO "" "::array_streams_udp_lost_packets(${stream_index})=$::array_streams_udp_lost_packets(${stream_index})"
			UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${stream_index})=$::array_streams_udp_out_of_order_packets(${stream_index})"
			UTF::Message INFO "" "::array_streams_udp_pps(${stream_index})=$::array_streams_udp_pps(${stream_index})"
		}

		for {set index_cnt 0} {$index_cnt < $actual_throughput_data_cnt} {incr index_cnt} {

			catch {array unset kpi_test_vlaues}

			set kpi_test_vlaues(data_index_no) [expr $index_cnt + 1]
		
			set kpi_test_vlaues(throughput_time) [lindex $::array_streams_throughput(${stream_index}) [expr $index_cnt * 2]]
			set kpi_test_vlaues(throughput) [lindex $::array_streams_throughput(${stream_index}) [expr [expr $index_cnt * 2] + 1]]

			UTF::Message INFO "" "kpi_test_vlaues(throughput_time)=$kpi_test_vlaues(throughput_time)"
			UTF::Message INFO "" "kpi_test_vlaues(throughput)=$kpi_test_vlaues(throughput)"

			if {$::array_streams_tcp_writes(${stream_index}) != ""} {
				set kpi_test_vlaues(tcp_rtt) [lindex $::array_streams_tcp_rtt(${stream_index}) $index_cnt]
				set kpi_test_vlaues(tcp_writes) [lindex $::array_streams_tcp_writes(${stream_index}) $index_cnt]
				set kpi_test_vlaues(tcp_errors) [lindex $::array_streams_tcp_errors(${stream_index}) $index_cnt]
				set kpi_test_vlaues(tcp_retries) [lindex $::array_streams_tcp_retries(${stream_index}) $index_cnt]
				set kpi_test_vlaues(tcp_used_memory) [lindex $::array_streams_tcp_used_memory(${stream_index}) $index_cnt]

				UTF::Message INFO "" "kpi_test_vlaues(tcp_rtt)=$kpi_test_vlaues(tcp_rtt)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_writes)=$kpi_test_vlaues(tcp_writes)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_errors)=$kpi_test_vlaues(tcp_errors)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_retries)=$kpi_test_vlaues(tcp_retries)"
				UTF::Message INFO "" "kpi_test_vlaues(tcp_used_memory)=$kpi_test_vlaues(tcp_used_memory)"
			}
			if {$::array_streams_udp_jitter(${stream_index}) != ""} {
				set kpi_test_vlaues(udp_latency) [lindex $::array_streams_udp_latency_avg(${stream_index}) $index_cnt]
				set kpi_test_vlaues(udp_jitter) [lindex $::array_streams_udp_jitter(${stream_index}) $index_cnt]
				set kpi_test_vlaues(udp_lost_packets) [lindex $::array_streams_udp_lost_packets(${stream_index}) $index_cnt]
				set kpi_test_vlaues(udp_out_of_order_packets) [lindex $::array_streams_udp_out_of_order_packets(${stream_index}) $index_cnt]
				set kpi_test_vlaues(udp_pps) [lindex $::array_streams_udp_pps(${stream_index}) $index_cnt]

				UTF::Message INFO "" "kpi_test_vlaues(udp_latency)=$kpi_test_vlaues(udp_latency)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_jitter)=$kpi_test_vlaues(udp_jitter)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_lost_packets)=$kpi_test_vlaues(udp_lost_packets)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_out_of_order_packets)=$kpi_test_vlaues(udp_out_of_order_packets)"
				UTF::Message INFO "" "kpi_test_vlaues(udp_pps)=$kpi_test_vlaues(udp_pps)"
			}

			$kpi_test_db setarray kpi_test_vlaues
			$kpi_test_db write
		}
	}
}

proc p2p::macos_pcap_debug_dump_start {cleanup_flag} {
	# access option array
	upvar {} {}

	#+++++++++++++++++++++++++++++++++++++++++++++++++++
	# Downstream data Only:
	#
	# 	AWDL Only  - 4 PCAP files
	# 	AWDL+Infra - 7 PCAP files
	#
	# CONTROLLER:
	#	(Infra) - tcpdump -i en12 -w controller_en12_sender.pcap
	#
	# DUT:
	#	(Infra) - tcpdump -i en0 -w en0_receiver.pcap
	#	tcpdump -i awdl0 -w awdl0_sender.pcap
	#	apple80211 awdl0 -logf="v set" -outfile=awdl_pcap.pcap -dlog
	#
	# AWDL Peer:
	#	(Infra) - tcpdump -i en0 -w en0_receiver.pcap
	#	tcpdump -i awdl0 -w awdl0_receiver.pcap
	#	apple80211 awdl0 -logf="v set" -outfile=awdl_pcap.pcap -dlog
	#
	# killall tcpdump apple80211:
	#	AWDL
	#	DUT
	#	(Infra) - CONTROLLER
	#
	#+++++++++++++++++++++++++++++++++++++++++++++++++++

	UTF::Try "PCAP Debug Start" {

		UTF::Message INFO "" "************************Func:macos_pcap_debug_dump_start $cleanup_flag***************************"

		if {$cleanup_flag} {
			UTF::Message LOG "" "Create '$::logdir/PCAPData' directory"
			catch {file mkdir "$::logdir/PCAPData"}
		}

		if {$::p2p_load_flag} {
			# AWDL exists
		}

		if {$::tg_wlan == ""} {
			set infra_flag 0
		} else {
			set infra_flag 1
		}

		set gc_wlan [lindex $::list_gc_wlan_objects 0]

		foreach STA "$::tg_wlan $::go_wlan $gc_wlan" {

			if {$STA == $::tg_wlan} {
				# Infra exists
				set tmp_disp "Controller"
				set tmp_ip $::tg_lan_ip
				set infra_ifname $::tg_wlan_ifname
				set awdl_ifname ""
				set tmp_tcpdump_infra "tcpdump_controller_tx_$infra_ifname"
				set tmp_tcpdump_awdl ""
				set tmp_drvlog_awdl ""
			} elseif {$STA == $::go_wlan} {
				# DUT
				set tmp_disp $::go_display_str
				set tmp_ip $::array_sta_lan_ip(${STA})
				set infra_ifname $::array_sta_wlan_ifname(${STA})
				set awdl_ifname $::array_sta_p2p_ifname(${STA})
				set tmp_tcpdump_infra "tcpdump_dut_rx_$infra_ifname"
				set tmp_tcpdump_awdl "tcpdump_dut_tx_$awdl_ifname"
				set tmp_drvlog_awdl "drvlog_dut_tx_$awdl_ifname"
			} elseif {$STA == $gc_wlan} {
				# AWDL Peer
				set tmp_disp $::gc_display_str
				set tmp_ip $::array_sta_lan_ip(${STA})
				set infra_ifname $::array_sta_wlan_ifname(${STA})
				set awdl_ifname $::array_sta_p2p_ifname(${STA})
				set tmp_tcpdump_infra "tcpdump_awdlpeer_rx_$infra_ifname"
				set tmp_tcpdump_awdl "tcpdump_awdlpeer_rx_$awdl_ifname"
				set tmp_drvlog_awdl "drvlog_awdlpeer_rx_$awdl_ifname"
			}

			UTF::Try "$STA: $tmp_disp TcpDump/DrvLog $tmp_ip" {
				if {$cleanup_flag} {
					set catch_resp [catch "$STA rexec pwd" catch_msg]
					UTF::Message INFO "" "$STA rm -f *\.pcap"
					set catch_resp [catch "$STA rm -f *\.pcap" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				}
				
				set testnum [p2p::get_testnum]
				regsub -all {.} $testnum "_" $testnum

				# AWDL tcpdump
				if {$STA == $::tg_wlan} {
					UTF::Message LOG "" "-----------------------TCPDUMP Controller Infra------------------------------"
					set tcpdump_name "$testnum\.$tmp_tcpdump_infra\.$STA.pcap"
					set ifname $infra_ifname
				} else {
					UTF::Message LOG "" "-----------------------TCPDUMP STA------------------------------"
					set tcpdump_name "$testnum\.$tmp_tcpdump_awdl\.$STA.pcap"
					set ifname $awdl_ifname
				}
				UTF::Message LOG "" "-----------------------'$tcpdump_name'------------------------------"
				UTF::Message INFO "" "$STA rpopen tcpdump -i $ifname -w $tcpdump_name"  
				set fd [$STA rpopen tcpdump -i $ifname -w $tcpdump_name]
				set catch_resp [catch {set fd_tcpdump_pid [pid $fd]} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep .1
				set catch_resp [catch "$STA rexec ls -la $tcpdump_name" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp != 0} {
					# failed
					incr ::error_cnt
					UTF::Message ERROR "" "tcpdump file not found"
					error "tcpdump file not found"							
				}
				if {$STA == $::tg_wlan} {
					set ::array_sta_wlan_tcpdump_pid(${STA}) $fd_tcpdump_pid
					set ::array_sta_wlan_tcpdump_filename(${STA}) $tcpdump_name
					UTF::Message LOG "" "::array_sta_wlan_tcpdump_filename(${STA})='$::array_sta_wlan_tcpdump_filename(${STA})'"
					UTF::Message LOG "" "::array_sta_wlan_tcpdump_filename(${STA})='$::array_sta_wlan_tcpdump_filename(${STA})'"
				} else {
					set ::array_sta_p2p_tcpdump_pid(${STA}) $fd_tcpdump_pid
					set ::array_sta_p2p_tcpdump_filename(${STA}) $tcpdump_name
					UTF::Message LOG "" "::array_sta_p2p_tcpdump_pid(${STA})='$::array_sta_p2p_tcpdump_pid(${STA})'"
					UTF::Message LOG "" "::array_sta_p2p_tcpdump_filename(${STA})='$::array_sta_p2p_tcpdump_filename(${STA})'"
				}

				# drvlog for the controller is not needed
				if {$STA != $::tg_wlan} {
					# AWDL drvlog
					set awdl_drvlog_name "$testnum\.$tmp_drvlog_awdl\.$STA.pcap"
					UTF::Message LOG "" "-----------------------DRVLOG STA '$awdl_drvlog_name'------------------------------"
					UTF::Message INFO "" "$STA rpopen apple80211 $awdl_ifname -logf=\"v set\" -outfile=$awdl_drvlog_name -dlog"  
					set fd [$STA rpopen apple80211 $awdl_ifname -logf=\"v set\" -outfile=$awdl_drvlog_name -dlog]
					set catch_resp [catch {set fd_drvlog_pid [pid $fd]} catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep .1
					set catch_resp [catch "$STA rexec ls -la $awdl_drvlog_name" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp != 0} {
						# failed
						incr ::error_cnt
						UTF::Message ERROR "" "drvlog file not found"
						error "drvlog file not found"							
					}
					set ::array_sta_p2p_drvlog_pid(${STA}) $fd_drvlog_pid
					set ::array_sta_p2p_drvlog_filename(${STA}) $awdl_drvlog_name
					UTF::Message LOG "" "::array_sta_p2p_drvlog_pid(${STA})='$::array_sta_p2p_drvlog_pid(${STA})'"
					UTF::Message LOG "" "::array_sta_p2p_drvlog_filename(${STA})='$::array_sta_p2p_drvlog_filename(${STA})'"
					
					if {$infra_flag} {					
						# Infra tcpdump
						set infra_tcpdump_name "$testnum\.$tmp_tcpdump_infra\.$STA.pcap"
						UTF::Message LOG "" "-----------------------TCPDUMP STA Infra '$infra_tcpdump_name'------------------------------"
						UTF::Message INFO "" "$STA rpopen tcpdump -i $infra_ifname -w $infra_tcpdump_name"  
						set fd [$STA rpopen tcpdump -i $infra_ifname -w $infra_tcpdump_name]
						set catch_resp [catch {set fd_tcpdump_pid [pid $fd]} catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						UTF::Sleep .1
						set catch_resp [catch "$STA rexec ls -la $infra_tcpdump_name" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						if {$catch_resp != 0} {
							# failed
							incr ::error_cnt
							UTF::Message ERROR "" "tcpdump file not found"
							error "tcpdump file not found"							
						}
						set ::array_sta_wlan_tcpdump_pid(${STA}) $fd_tcpdump_pid
						set ::array_sta_wlan_tcpdump_filename(${STA}) $infra_tcpdump_name
						UTF::Message LOG "" "::array_sta_wlan_tcpdump_pid(${STA})='$::array_sta_wlan_tcpdump_pid(${STA})'"
						UTF::Message LOG "" "::array_sta_wlan_tcpdump_filename(${STA})='$::array_sta_wlan_tcpdump_filename(${STA})'"
					}
				}
			
				set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
				
				return ""
			}
		}

		foreach STA "$gc_wlan $::go_wlan $::tg_wlan" {
			UTF::Message LOG "" "========================================================"
			set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp != 0} {
				# failed
				incr ::error_cnt
				UTF::Message ERROR "" "Did not find PCAP file on $STA"
				error "Did not find PCAP file on $STA"							
			}
		}
		
		return ""
	}

	if {$::error_cnt > 0} {
		error "Halting tests!"
	}
}

proc p2p::macos_pcap_debug_dump_stop {} {
	# access option array
	upvar {} {}

	UTF::Try "PCAP Debug Stop" {

		UTF::Message INFO "" "************************Func:macos_pcap_debug_dump_stop***************************"

		set gc_wlan [lindex $::list_gc_wlan_objects 0]

		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++++DEBUG+++++++++++++++++++++++++++++++++++++++++"
		foreach STA "$gc_wlan $::go_wlan $::tg_wlan" {
		
			foreach interface_type "p2p wlan" {

				foreach log_type "tcpdump drvlog" {

					set var "array_sta_${interface_type}_${log_type}_filename(${STA})"
					if {![info exists ::${var}]} {
						UTF::Message INFO "" "'::${var}' does not exist. skip to next."
						continue
					}
					set item [expr \${::${var}}]
					UTF::Message INFO "" "::${var}='$item'"
				}
			}
		}
		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n"

		foreach STA "$gc_wlan $::go_wlan $::tg_wlan" {
		
			foreach interface_type "p2p wlan" {

				foreach log_type "tcpdump drvlog" {

					set var "array_sta_${interface_type}_${log_type}_filename(${STA})"
					if {![info exists ::${var}]} {
						UTF::Message INFO "" "'::${var}' does not exist. skip to next."
						continue
					}
					set item [expr \${::${var}}]
					UTF::Message INFO "" "::${var}='$item'"
					if {$item != ""} {
						UTF::Message LOG "" "--------------------------------------------------------"
						UTF::Message LOG "" "$STA - Stopping PCAP $log_type file: '$item'"
						set var "array_sta_${interface_type}_${log_type}_pid(${STA})"
						set item_pid [expr \${::${var}}]
						UTF::Message INFO "" "::${var}='$item_pid'"
						UTF::Message INFO "" "exec kill -9 $item_pid"  
						set catch_resp [catch "exec kill -9 $item_pid" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

						UTF::Sleep 1

						# Coping it to the PCAPData directory in the UTF report

						UTF::Message INFO "" "$STA copyfrom $item $::logdir/PCAPData/$item"
						set catch_resp [catch "$STA copyfrom $item $::logdir/PCAPData/$item" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: scp catch_msg=$catch_msg"
						} else {
							catch "exec chmod 755 $::logdir/PCAPData/$item"
							set catch_resp [catch "exec ls -la $::logdir/PCAPData/$item" catch_msg]
							UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

							UTF::Message INFO "" "$STA rm -f $item"
							set catch_resp [catch "$STA rm -f $item" catch_msg]

							if {$catch_resp != 0} {
							   error "ERROR: rm catch_msg=$catch_msg"
							}

							set catch_resp [catch "$STA rexec ls -la $item" catch_msg]
						}
					}
				}
			}
		}

		foreach STA "$gc_wlan $::go_wlan $::tg_wlan" {
			UTF::Message LOG "" "========================================================"
			set catch_resp [catch "$STA rexec ls -la *\.pcap" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} {
				# failed
				incr ::error_cnt
				UTF::Message ERROR "" "Found PCAP file on $STA"
				error "Found PCAP file on $STA"							
			}
		}
		
		UTF::Message INFO "" "PASS. Captured PCAP Files: $::logdir/PCAPData/"
		return "html: <a href=\"$::logdir/PCAPData/\">{Mac PCAP Debug Files}</a>"
	}

	if {$::error_cnt > 0} {
		error "Halting tests!"
	}
}

proc p2p::control_chart {id sample_list cc_keys cc_title cc_units data_throughput_flag} {

	set sample_cnt [llength $sample_list]

	# Create control chart	
	# Control chart needs more than 2 samples
	if {$sample_cnt > 2} {
		UTF::Message INFO "" "UTF::ControlChart CC -s $sample_cnt -key $cc_keys -units $cc_units -title $cc_title -history 30"		
		UTF::ControlChart CC -s $sample_cnt -key $cc_keys -units $cc_units -title $cc_title -history 30
		
		# Get the Mean, Min, Max
		set cc_mmm [UTF::MeanMinMax $sample_list]

		# Add it to control chart
		set cc_result [CC addsample $cc_mmm]
	} else {
		UTF::Message INFO "" "UTF::MemChart CC -key $cc_keys -units $cc_units -title $cc_title"
		UTF::MemChart CC -key $cc_keys -units $cc_units -title $cc_title
		
		# Add it to control chart
		set cc_result [CC addsample $sample_list]
	}

	if {$data_throughput_flag == 1} {
		set rc [regexp -nocase {(LOW|WIDE|ZERO)} $cc_result - code] 
	} else {
		set rc [regexp -nocase {(HIGH|WIDE)} $cc_result - code] 
	}

	if {$rc} {
		UTF::Message ERROR "" "p2p::control_chart Control chart value is $code"
		append ::p2p::cc_error "($code)"
	}
	
	# Get the control chart graphics
	set chart [CC plotcontrolchart $cc_result]
	
	# Delete control chart	
	CC destroy

	# remove the "html:" from the beginning
	regsub -nocase {^html:} $chart "" chart

	# Add name id to differentiate between multiple charts
	set chart "<b>$id</b>&nbsp;&nbsp;${chart}"

	return "$chart"
}

proc p2p::start_udp_traffic {endpoint1 endpoint2 endpoint2_ipaddr stream_index iperf_tos iperf_scale stream_iperf_tcpwin_src} {

	UTF::Message LOG "" "start_udp_traffic endpoint1=$endpoint1 endpoint2=$endpoint2 endpoint2_ipaddr=$endpoint2_ipaddr"

	set macos_ipv6_flag 0
	if {$::array_streams_src_host_type(${stream_index}) == "MacOS"} {
		if {$::use_wl_for_mac == 0} {
			set macos_ipv6_flag 1
			set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
			UTF::Message INFO "" "$stream_sta_obj: MacOS AWDL client"
		}
	}

	# endpoint1 -> endpoint2

	set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
	set iperf_name $::array_sta_iperf_name(${stream_sta_obj})

	# Start iperf as background task
	if {$::array_streams_type(${stream_index}) == "P2P" && $macos_ipv6_flag} {
		set ::array_streams_fd_tx(${stream_index}) [$endpoint1 rpopen $iperf_name -V -A -c $::array_streams_dst_ipv6_macaddr(${stream_index}) -u -w $stream_iperf_tcpwin_src -b $::curr_udp_bandwidth -l $::curr_udp_packet_size -t $::curr_stream_time -f$iperf_scale -S $iperf_tos -p $::curr_iperf_port]
	} else {
		set ::array_streams_fd_tx(${stream_index}) [$endpoint1 rpopen $iperf_name -c $endpoint2_ipaddr -u -e -w $stream_iperf_tcpwin_src -b $::curr_udp_bandwidth -l $::curr_udp_packet_size -t $::curr_stream_time -f$iperf_scale -S $iperf_tos -p $::curr_iperf_port]
	}
	fconfigure $::array_streams_fd_tx(${stream_index}) -blocking 0
	fileevent $::array_streams_fd_tx(${stream_index}) readable {set ::p2p_utils_reading READY}

	incr ::curr_iperf_port

	return ""
}

proc p2p::start_tcp_traffic {endpoint1 endpoint2 endpoint2_ipaddr stream_index iperf_scale stream_iperf_tcpwin_src} {

	UTF::Message LOG "" "start_tcp_traffic endpoint1=$endpoint1 endpoint2=$endpoint2 endpoint2_ipaddr=$endpoint2_ipaddr"

	set macos_ipv6_flag 0
	if {$::array_streams_src_host_type(${stream_index}) == "MacOS"} {
		if {$::use_wl_for_mac == 0} {
			set macos_ipv6_flag 1
			set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
			UTF::Message INFO "" "$stream_sta_obj: MacOS AWDL client"
		}
	}

	# endpoint1 -> endpoint2

	set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
	set iperf_name $::array_sta_iperf_name(${stream_sta_obj})

	# Start iperf as background task	
	if {$macos_ipv6_flag} {
		if {$::array_streams_type(${stream_index}) == "P2P"} {
			set ::array_streams_fd_tx(${stream_index}) [$endpoint1 rpopen $iperf_name -V -A -c $::array_streams_dst_ipv6_macaddr(${stream_index}) -w $stream_iperf_tcpwin_src -t $::curr_stream_time -f$iperf_scale -i $::perfint -p $::curr_iperf_port -l 8k]
		} else {
			set ::array_streams_fd_tx(${stream_index}) [$endpoint1 rpopen $iperf_name -c $endpoint2_ipaddr -w $stream_iperf_tcpwin_src -t $::curr_stream_time -f$iperf_scale -i $::perfint -p $::curr_iperf_port -l 8k]
		}
	} else {
		set ::array_streams_fd_tx(${stream_index}) [$endpoint1 rpopen iperf -c $endpoint2_ipaddr -e -t $::curr_stream_time -f$iperf_scale -i $::perfint -p $::curr_iperf_port -l 8k]
	}
	fconfigure $::array_streams_fd_tx(${stream_index}) -blocking 0
	fileevent $::array_streams_fd_tx(${stream_index}) readable {set ::p2p_utils_reading READY}

	incr ::curr_iperf_port

	return ""
}

proc p2p::start_traffic {endpoint1 endpoint2 endpoint2_ipaddr stream_index stream_tos stream_iperf_tos stream_iperf_scale stream_iperf_tcpwin_src} {

	if {$stream_tos == "TCP"} {
		set rc [p2p::start_tcp_traffic $endpoint1 $endpoint2 $endpoint2_ipaddr $stream_index $stream_iperf_scale $stream_iperf_tcpwin_src]
	} else {
		set rc [p2p::start_udp_traffic $endpoint1 $endpoint2 $endpoint2_ipaddr $stream_index $stream_iperf_tos $stream_iperf_scale $stream_iperf_tcpwin_src]	
	}

	return ""
}

proc p2p::start_all_server_streams {} {
	# access option array
	upvar {} {}

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:start_all_server_streams***************************"
	
	# reset the iperf starting port #
	set ::curr_iperf_port $::iperf_starting_port
	set stream_cnt 0

	catch {array unset ::array_streams_fdname_tx}
	catch {array unset ::array_streams_fd_tx}
	catch {array unset ::array_streams_fdname_rx}
	catch {array unset ::array_streams_fd_rx}

	foreach stream_index $::streams_name_list {

		incr stream_cnt

		if {[regexp -nocase {BT} $stream_index]} {
			UTF::Message INFO "" "stream_index='$stream_index'. Skipping BT"
			continue
		}

		set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
		set iperf_name $::array_sta_iperf_name(${stream_sta_obj})
		
		set server_param "-s"

		if {$::array_streams_dst_host_type(${stream_index}) == "MacOS" && $::array_streams_type(${stream_index}) == "P2P"} {
			if {$::use_wl_for_mac == 0} {
				# do not change this order since the script looks for "iperf -s" for killing process
				set server_param "-s -V -A"
				UTF::Message INFO "" "$::array_streams_dst(${stream_index}): MacOS AWDL server"
			}
		}
		
		if {$::array_streams_tos(${stream_index}) == "TCP"} {
			set ::array_streams_fd_rx(${stream_index}) [$::array_streams_dst(${stream_index}) rpopen $iperf_name $server_param -e -fm -i $::perfint -w $::array_streams_iperf_tcpwin_dst(${stream_index}) -p $::curr_iperf_port -l 8k -P 1]
		} else {
			set ::array_streams_fd_rx(${stream_index}) [$::array_streams_dst(${stream_index}) rpopen $iperf_name $server_param -u -e -fm -i $::perfint -w $::array_streams_iperf_tcpwin_dst(${stream_index}) -p $::curr_iperf_port -P 1]
		}

		fconfigure $::array_streams_fd_rx(${stream_index}) -blocking 0
		fileevent $::array_streams_fd_rx(${stream_index}) readable {set ::p2p_utils_reading READY}

		# insert "RX_" and "TX_" at the beginning of the iperf id name in order to differentiate the RX and TX data
		set ::array_streams_fdname_rx(${stream_index}) "RX_$stream_index"
		set ::array_streams_fdname_tx(${stream_index}) "TX_$stream_index"

		UTF::Message INFO "" "Stream $stream_cnt $stream_index - Started iperf server for $::array_streams_type(${stream_index}) $::array_streams_tos(${stream_index}) $::array_streams_direction(${stream_index}) - fdname=$::array_streams_fdname_rx(${stream_index}) fd=$::array_streams_fd_rx(${stream_index})"

		incr ::curr_iperf_port
	}

	# reset the iperf starting port #
	set ::curr_iperf_port $::iperf_starting_port
	UTF::Sleep .2
}

proc p2p::close_iperf_traffic {} {

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:close_iperf_traffic***************************"

	# iperf rpopen process is on the UTF machine

	foreach stream_index $::streams_name_list {

		if {[info exists ::array_streams_fd_rx(${stream_index})]} {
			set name $::array_streams_fdname_rx(${stream_index})
			if {$name != ""} {
				set fd $::array_streams_fd_rx(${stream_index})
				set catch_resp [catch {close $fd} catch_msg]
				UTF::Message INFO "" "close $fd catch_msg=$catch_msg"
			}
		}

		if {[info exists ::array_streams_fd_tx(${stream_index})]} {
			set name $::array_streams_fdname_tx(${stream_index})
			if {$name != ""} {
				set fd $::array_streams_fd_tx(${stream_index})
				set catch_resp [catch {close $fd} catch_msg]
				UTF::Message INFO "" "close $fd catch_msg=$catch_msg"
			}
		}
	}
}

proc p2p::stop_iperf_traffic {} {

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:stop_iperf_traffic***************************"

	# iperf rpopen process is on the UTF machine

	foreach stream_index $::streams_name_list {

		if {$::array_streams_type(${stream_index}) == "BT"} {
			# no iperf for BT
			continue
		}

		set name $::array_streams_fdname_rx(${stream_index})
		set fd $::array_streams_fd_rx(${stream_index})

		set catch_resp [catch {set iperf_endpoint_pid [pid $fd]} catch_msg]
		UTF::Message INFO "" "set iperf_endpoint_pid catch_msg=$catch_msg"

		if {$catch_resp != 0} {
			# failed to get pid
			UTF::Message INFO "" "stop_iperf_traffic name=$name fd=$fd pid=None (must be exited already)"  
		} else {	
			UTF::Message INFO "" "stop_iperf_traffic name=$name fd=$fd pid=$iperf_endpoint_pid"  

			UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
			set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "stop_iperf_traffic\
					did not terminate iperf_endpoint_pid=$iperf_endpoint_pid: $catch_msg"
				if {![regexp -nocase "No such process" $catch_msg]} {
					error "Iperf did not stop"
				}
			}
		}
	}
}

proc p2p::awdl_macos_link_activate {} {

	# sample shell command to kill dns-sd
	# while true; do awdl_status=$(apple80211 -awdl | grep "awdl is enabled"); if [ -n "$awdl_status" ]; then killall dns-sd 2> /dev/null;sleep 1; else break; fi;done

	UTF::Message INFO "" "************************Func:awdl_macos_link_activate***************************"

	set gc_wlan [lindex $::list_gc_wlan_objects 0]

	foreach STA "$gc_wlan $::go_wlan" {
		set catch_resp [catch "$STA rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
		if {$catch_resp != 0} {
			UTF::Message INFO "" "$STA: AWDL is not enabled"
		}

		set catch_resp [catch "$STA rexec killall dns-sd" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		if {$STA == $gc_wlan} {
			set awdl_peer_macaddr [regexp -inline {ether\s+(\S+)} [$STA rexec ifconfig awdl0 ether]]
			UTF::Message INFO "" "awdl_peer_macaddr=$awdl_peer_macaddr"
			regexp -nocase {\{ether\s+(\S+)\}} $awdl_peer_macaddr - awdl_peer_macaddr
			set awdl_peer_macaddr [string trim $awdl_peer_macaddr]
			set awdl_peer_macaddr [string toupper $awdl_peer_macaddr]
			UTF::Message INFO "" "$STA: AWDL Peer mac address is $awdl_peer_macaddr"
		} else {
			set time_ms1 [clock clicks -milliseconds]
		}

		$STA rpopen dns-sd -includeAWDL -B _test local

		if {$STA == $::go_wlan} {

			UTF::Sleep .01

			set loop_cnt 0

			while {1} {
				set catch_resp [catch "$STA rexec apple80211 -awdl_peers" catch_msg]
				if {[string first $awdl_peer_macaddr $catch_msg] != -1} {
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg='$catch_msg'"
					UTF::Message INFO "" "DUT $STA found AWDL Peer $awdl_peer_macaddr"
					break
				}

				UTF::Sleep .01

				incr loop_cnt
				if {$loop_cnt > 500} {
					UTF::Message INFO "" "DUT $STA did not find AWDL Peer $awdl_peer_macaddr"

					foreach STA_name "$gc_wlan $::go_wlan" {
						$STA_name rexec ifconfig -a
						set catch_resp [catch "$STA_name rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						set catch_resp [catch "$STA_name rexec ps -ef | grep \"dns-sd\"" catch_msg]					
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					}

					incr ::error_cnt
					error "$STA: DUT did not find AWDL Peer $awdl_peer_macaddr. Halting tests!"				
				}
			}

			set time_ms2 [clock clicks -milliseconds]
			UTF::Message INFO "" "time_ms2=$time_ms2"
			set diff_time_ms [expr {$time_ms2 - $time_ms1}]
			UTF::Message INFO "" "diff_time_ms=$diff_time_ms"
		} else {
			UTF::Sleep 5
			set catch_resp [catch "$STA rexec ps -ef | grep \"dns-sd\"" catch_msg]					
			UTF::Message INFO "" "ps -ef dns-sd catch_msg=$catch_msg"
		}
	}
}

proc p2p::awdl_discovery_time {} {
	# access option array
	upvar {} {}

	# sample shell command to kill dns-sd
	# while true; do awdl_status=$(apple80211 -awdl | grep "awdl is enabled"); if [ -n "$awdl_status" ]; then killall dns-sd 2> /dev/null;sleep 1; else break; fi;done

	UTF::Try "$::test_type: AWDL Discovery Time" {
		UTF::Message INFO "" "************************Func:awdl_discovery_time***************************"

		set gc_wlan [lindex $::list_gc_wlan_objects 0]

		foreach STA "$gc_wlan $::go_wlan" {
			set catch_resp [catch "$STA rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
			if {$catch_resp == 0} {
				# awdl is enabled
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				incr ::error_cnt
				error "$STA: AWDL is enabled by default. Halting tests!"				
			} else {
				UTF::Message INFO "" "$STA: AWDL is not enabled by default."
			}

			set catch_resp [catch "$STA rexec killall dns-sd" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			
			if {$STA == $gc_wlan} {
				set awdl_peer_macaddr [regexp -inline {ether\s+(\S+)} [$STA rexec ifconfig awdl0 ether]]
				UTF::Message INFO "" "awdl_peer_macaddr=$awdl_peer_macaddr"
				regexp -nocase {\{ether\s+(\S+)\}} $awdl_peer_macaddr - awdl_peer_macaddr
				set awdl_peer_macaddr [string trim $awdl_peer_macaddr]
				set awdl_peer_macaddr [string toupper $awdl_peer_macaddr]
				UTF::Message INFO "" "$STA: AWDL Peer mac address is $awdl_peer_macaddr"
			} else {
				set time_ms1 [clock clicks -milliseconds]
			}
			
			$STA rpopen dns-sd -includeAWDL -B _test local

			if {$STA == $::go_wlan} {

				UTF::Sleep .01
				
				set loop_cnt 0

				while {1} {
					set catch_resp [catch "$STA rexec apple80211 -awdl_peers" catch_msg]
					if {[string first $awdl_peer_macaddr $catch_msg] != -1} {
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg='$catch_msg'"
						UTF::Message INFO "" "DUT $STA found AWDL Peer $awdl_peer_macaddr"
						break
					}

					UTF::Sleep .01
					
					incr loop_cnt
					if {$loop_cnt > 500} {
						UTF::Message INFO "" "DUT $STA did not find AWDL Peer $awdl_peer_macaddr"
						
						foreach STA_name "$gc_wlan $::go_wlan" {
							$STA_name rexec ifconfig -a
							set catch_resp [catch "$STA_name rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
							UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
							set catch_resp [catch "$STA_name rexec ps -ef | grep \"dns-sd\"" catch_msg]					
							UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						}
						
						incr ::error_cnt
						error "$STA: DUT did not find AWDL Peer $awdl_peer_macaddr. Halting tests!"				
					}
				}

				set time_ms2 [clock clicks -milliseconds]
				UTF::Message INFO "" "time_ms2=$time_ms2"
				set diff_time_ms [expr {$time_ms2 - $time_ms1}]
				UTF::Message INFO "" "diff_time_ms=$diff_time_ms"
				set ret_val [format "%.7f" $diff_time_ms]
				set discovery_time [format "%.2f" $diff_time_ms]
				if {$::kpi_test_flag} {
					$::kpi_base_db set "discovery_time" "$discovery_time"
				}
				set keys "$::key_base2 AWDL_Discovery"
				set html_results [UTF::Test::memchart $ret_val -key $keys  -title "AWDL Discovery Time" -units "ms"]				
				return $html_results
			} else {
				UTF::Sleep 5
				set catch_resp [catch "$STA rexec ps -ef | grep \"dns-sd\"" catch_msg]					
				UTF::Message INFO "" "ps -ef dns-sd catch_msg=$catch_msg"
			}
		}
	}
}

proc p2p::stop_all_server_streams {} {

	if {$::bt_only_flag} {
		return
	}

	UTF::Message INFO "" "************************Func:stop_all_server_streams***************************"

	if {$::p2p_load_flag} {
		p2p::stop_iperf_server $::go_wlan
	}
	foreach sta_wlan_index $::list_gc_wlan_objects {
		p2p::stop_iperf_server $sta_wlan_index
	}
	if {$::tg_wlan != ""} {
		# Not Direct P2P
		p2p::stop_iperf_server $::tg_wlan
	}
	if {$::soft_ap_flag} {
		# include the UTF controller
		p2p::stop_iperf_server lan
	}	
}

proc p2p::stop_iperf_server {server_name} {

	UTF::Message INFO "" "************************Func:stop_iperf_server $server_name***************************"

	#UTF::Message INFO "" "-----------------------------------------------"
	#UTF::Message INFO "" "$server_name rexec ps -ef"
	#set ::catch_resp [catch "$server_name rexec ps -ef" ::catch_msg]
	#UTF::Message INFO "" "-----------------------------------------------"

	set iperf_name $::array_sta_iperf_name(${server_name})

	UTF::Message INFO "" "$server_name rexec ps -ef | grep $iperf_name -s"
	set ::catch_resp [catch "$server_name rexec ps -ef | grep \"$iperf_name -s\"" ::catch_msg]
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
	UTF::Message INFO "" "-----------------------------------------------"

	set tmp [split $::catch_msg "\n"]
	set iperf_server_pid 0

	foreach line $tmp {
		if {![regexp {grep|python} $line]} {

			UTF::Message INFO "" "--->: $line"
			# test to see if iperf server is running
			set iperf_server_pid 0
			catch {
				regexp {([A-Za-z0-9._-]+)\s+([0-9]+)\s+} $line match owner iperf_server_pid
				UTF::Message INFO "" "Iperf server is ruuning. pid=$iperf_server_pid owner=$owner"
			}

			if {$iperf_server_pid > 0} {
				# found the iperf process. Kill it
				UTF::Message INFO "" "$server_name rexec kill -9 $iperf_server_pid"  
				set ::catch_resp [catch "$server_name rexec kill -9 $iperf_server_pid" ::catch_msg]
				UTF::Sleep 3
				if {$::catch_resp != 0} {
					UTF::Message ERROR "" "stop_iperf_server\
						did not terminate iperf_server_pid=$iperf_server_pid: $::catch_msg"
					if {![regexp -nocase "No such process" $::catch_msg]} {
						incr ::error_cnt
						UTF::Message INFO "" "::error_cnt=$::error_cnt"
						error "Iperf did not terminate"
					}
				}
			}
		}
	}
}

proc p2p::check_iperf_version {machine} {

	UTF::Message INFO "" "************************Func:check_iperf_version $machine***************************"

	UTF::Message INFO "" "$machine cget -iperf"
	set iperf_name [$machine cget -iperf]

	if {$iperf_name == ""} {
		set iperf_name "iperf"
	}

	# get the current iperf version
	UTF::Message INFO "" "$machine rexec which $iperf_name"
	set ::catch_resp [catch "$machine rexec which $iperf_name" ::catch_msg]
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
	UTF::Message INFO "" "$machine rexec $iperf_name -v"
	set ::catch_resp [catch "$machine rexec $iperf_name -v" ::catch_msg]
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
	set catch_resp2 [catch "$machine rexec ls -l /usr/local/bin/iperf*" catch_msg2]
	UTF::Message INFO "" "-----------------------------------------------"

	set	iperf_ver "BLANK"
	regexp -nocase {iperf version\s+(\S+)\s+} $::catch_msg - iperf_ver

	UTF::Message INFO "" "iperf_name=$iperf_name"
	UTF::Message INFO "" "iperf_ver=$iperf_ver"

	set ::array_sta_iperf_name(${machine}) $iperf_name
	set ::array_sta_iperf_ver(${machine}) $iperf_ver

	UTF::Message INFO "" " "

	set host_type [$machine hostis]
	UTF::Message INFO "" "$machine host_type=$host_type"
	
	if {$host_type == "MacOS"} {
		UTF::Message INFO "" "======================stop MacOS iperf server service========================="
		UTF::Message INFO "" "$machine rexec sudo launchctl unload /System/Library/LaunchDaemons/iperf.plist"
		set ::catch_resp [catch "$machine rexec sudo launchctl unload /System/Library/LaunchDaemons/iperf.plist" ::catch_msg]
		UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
		UTF::Message INFO "" "$machine rexec sudo launchctl list /System/Library/LaunchDaemons/iperf.plist"
		set ::catch_resp [catch "$machine rexec sudo launchctl list /System/Library/LaunchDaemons/iperf.plist" ::catch_msg]
		UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
		if {$::catch_resp == 0} {
			incr ::error_cnt
			error "iperf.plist service is still running"
		}
	} else {	
		UTF::Message INFO "" "======================stop TCP iperf server service========================="
		UTF::Message INFO "" "$machine rexec chkconfig --level 2345 iperf off"
		set ::catch_resp [catch "$machine rexec chkconfig --level 2345 iperf off" ::catch_msg]
		UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
		UTF::Message INFO "" "$machine rexec service iperf stop"
		set ::catch_resp [catch "$machine rexec service iperf stop" ::catch_msg]
		UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
		UTF::Sleep 3

		UTF::Message INFO "" "---------------------iperf status--------------------------"
		UTF::Message INFO "" "$machine rexec service iperf status"
		set ::catch_resp [catch "$machine rexec service iperf status" ::catch_msg]
		UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
		UTF::Message INFO "" "-----------------------------------------------"

		if {[regexp -nocase {.*active \(running\).*} $::catch_msg]} {
			UTF::Message INFO "" "Iperf server service is still running for $machine"
			set ::iperf_server_err $machine
		} else {
			UTF::Message INFO "" "Iperf server service is not running"
		}
	}
	
	return $iperf_ver
}

proc p2p::setup_multicore {} {
	# access option array
	upvar {} {}

	if {$(multicore_mode) == 0} {
		set multicore_state "Off"
	} else {
		set multicore_state "On"
	}

	if {$::soft_ap_flag == 1} {
		set soft_ap_host_type [$::wlan_ap hostis]
	} else {
		set soft_ap_host_type ""
	}

	foreach STA "$::list_gc_wlan_objects $::go_wlan $::wlan_ap" {

		if {$STA == "" || ($STA == $::wlan_ap && $::soft_ap_flag == 0)} {
			continue
		}

		if {$STA == $::go_wlan} {
			set sta_host_type $::array_sta_host_type(${::go_wlan})
		} elseif {$STA == $::wlan_ap} {
			set sta_host_type $soft_ap_host_type
		} else {
			set sta_host_type $::array_sta_host_type(${STA})
		}
	
		if {$sta_host_type == "MacOS"} {
			continue
		}

		UTF::Try "$STA: Multicore $multicore_state" {

			# cd /sys/devices/system/cpu
			# echo 0 > cpu1/online
			# echo 0 > cpu2/online
			# echo 0 > cpu3/online

			set multicore_set_flag 0
			for {set cpu_cnt 1} {$cpu_cnt <= 3} {incr cpu_cnt} {
				set catch_resp [catch "$STA cat /sys/devices/system/cpu/cpu$cpu_cnt/online" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

				if {$catch_resp == 1} {
					# failed
					set multicore_set_flag 1
					continue
				}

				if {$(multicore_mode) == 0 && $catch_msg == "1"} {
					set multicore_set_flag 1
					continue
				}
				if {$(multicore_mode) == 1 && $catch_msg == "0"} {
					set multicore_set_flag 1
					continue
				}
			}

			if {$multicore_set_flag == 0} {
				return "Multicore is already $multicore_state"
			}
			
			if {$(multicore_mode) == 0} {
				UTF::Message LOG "" "Turn off multicore"
				set catch_resp [catch "$STA ls /root/multicore_off" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp == 0} {
					UTF::Message LOG "" "Found '/root/multicore_off' on '$STA'"
				} else {
					UTF::Message LOG "" "Create missing '/root/multicore_off' on '$STA'"
					$STA echo "\"cd /sys/devices/system/cpu ; echo 0 > cpu1/online ; echo 0 > cpu2/online ; echo 0 > cpu3/online\" >> /root/multicore_off"
					$STA chmod +x /root/multicore_off
				}

				set catch_resp [catch "$STA rexec /root/multicore_off" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 5
			} else {
				UTF::Message LOG "" "Turn on multicore by rebooting the STA $STA"
				$STA power off
				UTF::Sleep 5
				$STA power on
				UTF::Sleep 40
			}
		}
	}
}

proc p2p::setup_mac_radio_on {} {
	# access option array
	upvar {} {}

	set mac_flag 0

	foreach STA "$::list_sta_wlan_objects" {

		if {$STA == $::go_wlan} {
			set sta_host_type $::array_sta_host_type(${::go_wlan})
		} else {
			set sta_host_type $::array_sta_host_type(${STA})
		}
	
		if {$sta_host_type != "MacOS"} {
			continue
		}

		set mac_flag 1
		UTF::Try "$STA: MacOS Radio On" {
			catch {$STA attngrp attn 0}
			$STA rexec networksetup -setairportpower [$STA cget -device] on
		}
	}
	
	if {$mac_flag && $::wlan_ap != ""} {
		UTF::Try "$::wlan_ap: Set AP ATTN 0" {
			catch {$::wlan_ap attngrp attn 0}
			return ""
		}
	}
	
	UTF::Sleep 1
}

proc p2p::setup_mpc {} {
	# access option array
	upvar {} {}
	
	UTF::Try "Setup MPC=$::mpc_mode" {

		UTF::Message INFO "" "************************Func:setup_mpc***************************"

		foreach sta $::list_sta_wlan_objects {
			$sta wl down
			UTF::Sleep 2
			set catch_resp [catch {$sta wl mpc $::mpc_mode} catch_msg]
			UTF::Sleep 2
			set catch_resp [catch {$sta wl mpc} catch_msg]
			$sta wl up
			UTF::Sleep 2
		}

		return ""
	}
}

proc p2p::setup_rsdb {} {
	# access option array
	upvar {} {}
	
	UTF::Try "Setup RSDB=$::rsdb_mode" {

		UTF::Message INFO "" "************************Func:setup_rsdb***************************"

		foreach sta $::list_sta_wlan_objects {
			$sta wl down
			UTF::Sleep 2
			set catch_resp [catch {$sta wl rsdb_mode $::rsdb_mode} catch_msg]
			UTF::Sleep 2
			set catch_resp [catch {$sta wl rsdb_mode} catch_msg]
			$sta wl up
			UTF::Sleep 2
		}

		return ""
	}
}


proc p2p::enable_ntp {} {

	if {$::bt_only_flag} {
		return
	}
	
	UTF::Try "Enable NTP" {
	
		UTF::Message INFO "" "************************Func:enable_ntp***************************"

		#########################################
		# Enable NTP
		#########################################

		set ntp_pass_flag 1

		if {$::tg_wlan != ""} {
			# Not Direct P2P
			set objects "$::tg_wlan $::list_sta_wlan_objects"
		} else {
			set objects $::list_sta_wlan_objects
		}

		if {[string first "lan " $objects] == -1} {
			# include the UTF controller
			set objects "lan $objects"
		}
		
		foreach object $objects {
			UTF::Try "$object: NTP" {
				set ::catch_resp [catch "$object rexec systemctl enable ntpd.service" ::catch_msg]
				UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
				set ::catch_resp [catch "$object rexec systemctl start ntpd.service" ::catch_msg]
				UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
				return ""
			}
		}
	}
}

proc p2p::check_ntp {} {

	if {$::bt_only_flag} {
		return
	}
	
	UTF::Try "Check NTP" {
	
		UTF::Message INFO "" "************************Func:check_ntp***************************"

		#########################################
		# see if NTP is running
		#########################################

		set ntp_pass_flag 1

		if {$::tg_wlan != ""} {
			# Not Direct P2P
			set objects "$::tg_wlan $::list_sta_wlan_objects"
		} else {
			set objects $::list_sta_wlan_objects
		}

		if {[string first "lan " $objects] == -1} {
			# include the UTF controller
			set objects "lan $objects"
		}
		
		foreach object $objects {
			UTF::Try "$object: NTP" {

				set rc_msg ""
				for {set cnt 1} {$cnt <= 2} {incr cnt} {
					set ::catch_resp [catch "$object rexec systemctl status ntpd.service" ::catch_msg]
					#UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
					UTF::Message INFO "" "-----------------------------------------------"

					set ntp_enabled_status ""
					regexp {ntpd.service;\s+(\S+)} $::catch_msg match ntp_enabled_status  
					UTF::Message INFO "" "ntp_enabled_status=$ntp_enabled_status"

					set ntp_running_status ""
					regexp {Active:\s+(\S+)} $::catch_msg match ntp_running_status  
					UTF::Message INFO "" "ntp_running_status=$ntp_running_status"

					if {$ntp_enabled_status == "enabled" || $ntp_running_status == "inactive"} {
						set rc_msg "(NTP was stopped)"
					} elseif {$ntp_running_status == "" || $ntp_running_status != "active"} {
						set ntp_pass_flag 0
						error $ntp_running_status
					}
					
					if {$cnt == 1} {
						# NTP is running. Sync the clock now
						set ::catch_resp [catch "$object rexec ntpq -p" ::catch_msg]
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec cat /var/lib/ntp/drift" ::catch_msg]
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec systemctl stop ntpd.service" ::catch_msg]
						UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec ntpdate 10.16.16.12" ::catch_msg]
						UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec systemctl start ntpd.service" ::catch_msg]
						UTF::Message INFO "" "catch_resp='$::catch_resp' catch_msg='$::catch_msg'"
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec ntpq -p" ::catch_msg]
						UTF::Message INFO "" "-----------------------------------------------"
						set ::catch_resp [catch "$object rexec cat /var/lib/ntp/drift" ::catch_msg]
						UTF::Message INFO "" "-----------------------------------------------"
					}
				}
				
				return "$ntp_running_status $rc_msg"
			}
		}
		
		if {!$ntp_pass_flag} {
			error "NTP not running"
		}
	}
}

proc p2p::setup_iperfs {} {

	if {$::bt_only_flag} {
		return
	}

	set iperf_failed_flag 0
	
	UTF::Try "Setup Iperf" {
	
		UTF::Message INFO "" "************************Func:setup_iperfs***************************"

		#########################################
		# Setup TCP Window Size
		#########################################
		p2p::setup_tcp_window_size

		#########################################
		# see if iperf is installed
		#########################################

		set iperf_pass_flag 1
		set last_iperf_ver ""

		if {$::tg_wlan != ""} {
			# Not Direct P2P
			set objects "$::tg_wlan $::list_sta_wlan_objects"
		} else {
			set objects $::list_sta_wlan_objects
		}

		if {[string first "lan " $objects] == -1} {
			# include the UTF controller
			set objects "lan $objects"
		}
				
		foreach object $objects {
			UTF::Try "$object: Iperf Version" {
				set rc [p2p::check_iperf_version $object]
				if {$last_iperf_ver == ""} {
					set last_iperf_ver $rc
				}
				if {$last_iperf_ver != $rc} {
					UTF::Message WARN ""  "Iperf versions '$last_iperf_ver' and '$rc' are not the same"
					set iperf_pass_flag 0
				}
				return $rc
			}
		}

		#########################################
		# Stop all server streams
		#########################################
		p2p::stop_all_server_streams

		if {!$iperf_pass_flag} {
			error "Iperf Version Mismatch"
		}

		if {$::iperf_server_err != ""} {
			error "Iperf server service is still running for $::iperf_server_err"
		}
		
		if {$iperf_failed_flag} {
			error "Could not stop TCP iperf server"
		}
	}
}

proc p2p::get_awdl_chan {chan} {

	set chan_list "1 0x1001,2 0x1002,3 0x1003,4 0x1004,5 0x1005,6 0x1006,7 0x1007,8 0x1008,9 0x1009,10 0x100a,11 0x100b,5u 0x1903,\
		6u 0x1904,7u 0x1905,8u 0x1906,9u 0x1907,10u 0x1908,11u 0x1909,1l 0x1803,2l 0x1804,3l 0x1805,4l 0x1806,5l 0x1807,\
		6l 0x1808,7l 0x1809,36 0xd024,40 0xd028,44 0xd02c,48 0xd030,52 0xd034,56 0xd038,60 0xd03c,64 0xd040,100 0xd064,\
		104 0xd068,108 0xd06c,112 0xd070,116 0xd074,132 0xd084,136 0xd088,140 0xd08c,144 0xd090,149 0xd095,153 0xd099,\
		157 0xd09d,161 0xd0a1,165 0xd0a5,40u 0xd926,48u 0xd92e,56u 0xd936,64u 0xd93e,104u 0xd966,112u 0xd96e,136u 0xd986,\
		144u 0xd98e,153u 0xd997,161u 0xd99f,36l 0xd826,44l 0xd82e,52l 0xd836,60l 0xd83e,100l 0xd866,108l 0xd86e,\
		132l 0xd886,140l 0xd88e,149l 0xd897,157l 0xd89f,36/80 0xe02a,52/80 0xe03a,100/80 0xe06a,132/80 0xe08a,\
		149/80 0xe09b,40/80 0xe12a,56/80 0xe13a,104/80 0xe16a,136/80 0xe18a,153/80 0xe19b,44/80 0xe22a,60/80 0xe23a,\
		108/80 0xe26a,140/80 0xe28a,157/80 0xe29b,48/80 0xe32a,64/80 0xe33a,112/80 0xe36a,144/80 0xe38a,161/80 0xe39b"

	set chan_list [split $chan_list ","]

	foreach chan_items "$chan_list" {

		set chan_items [string trim $chan_items]

		foreach {channel channel_spec} $chan_items {

			if {$channel == $chan} {

				regsub {0x} $channel_spec "" var_chan
				return $var_chan
			}
		}
	}

	incr ::error_cnt
	UTF::Message INFO "" "***Fail. Invalid '$chan' Channel. Do not continue the test."
	set ::halt_test_err "Invalid $chan Channel"
	error "Invalid $chan Channel. Halting tests!"
}

proc p2p::free_memory_after_p2p_assoc {} {
	# access option array
	upvar {} {}

	foreach s "$::list_sta_wlan_objects" {
		if {[$s rte_available]} {
			UTF::Try "$s: Free Memory After $::p2p_display_str Assoc (K)" {
				# retry is needed due to issues with NPC serial port
				for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
					set catch_resp [catch "$s freekb" catch_msg]
					UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						break
					}
				}

				if {$catch_resp == 1} {
					error $catch_msg							
				}

				set ret_val [format "%.7f" $catch_msg]
				set branch [$s branchname]
				UTF::Test::memchart $ret_val -failonlow -key [list $branch $s $::p2p_display_str assocfree] -units kb -title "$::p2p_display_str Assoc Free"
			}
		}
	}
}

proc p2p::setup_awdl {} {
	# access option array
	upvar {} {}

	# currently only one STA/Slave is supported
	set gc_wlan_index [lindex $::list_gc_wlan_objects 0]

	if {$::array_sta_host_type(${::go_wlan}) == "MacOS"} {
		UTF::Try "$::test_type: Setup AWDL: CH=$::p2p_chan" {
			UTF::Message INFO "" "************************MacOS AWDL DUT Setup***************************"
			#kevin
			UTF::Message INFO "" "AWDL channel = $::p2p_chan"
			#$::go_wlan rexec apple80211 -awdl_secondary_master_channel=$::p2p_chan
			#$::go_wlan rexec apple80211 -awdl_master_channel=$::p2p_chan
			$::go_wlan rexec apple80211 -awdl_master_channel
			$::go_wlan rexec apple80211 -awdl_secondary_master_channel
			$::go_wlan rexec ifconfig -a
			UTF::Message INFO "" "************************MacOS AWDL Peer Setup***************************"
			$gc_wlan_index rexec apple80211 -awdl_master_channel
			$gc_wlan_index rexec apple80211 -awdl_secondary_master_channel
			$gc_wlan_index rexec ifconfig -a

			set ::array_sta_p2p_active_flag(${gc_wlan_index}) 1
			set ::array_sta_p2p_disassociated_flag(${gc_wlan_index}) 0
			UTF::Message INFO "" "wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${gc_wlan_index})"
			UTF::Message INFO "" "p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${gc_wlan_index})"

			# chanspec for AWDL
			set ::chanspec_p2p $::p2p_chan

			return $::p2p_chan
		}
		
		return
	}

	########################################################
	# 1) trunk WL may not support the AWDL
	# 2) you must do "dhd -i eth0 dma_ring_indices 3" before FW download.
	# 	Use "-postinstall {dhd -i eth0 dma_ring_indices 3}" in the UTF config.
	# 3) Use 'event' to confirm awdl is hopping on both channels:
	#	dhd -i eth1 msglevel +event
	#	wl event_msgs 0xf000000000000000000000000
	########################################################

	UTF::Try "$::test_type: Setup AWDL: CH=$::p2p_chan" {

		UTF::Message INFO "" "************************Func:setup_awdl***************************"

		set awdl_bssid "00:ff:22:33:44:ff"
		set awdl_bssid [string toupper $awdl_bssid]
		
		# awdl_chan_seq Examples:
		#	AWDL=149/80 (e09b)		Infra=None
		#		0xe09be09be09b00000000000000000000e09be09be09b00000000000000000000
		#	16 slots with awdl channels 149/80 and no infra slot
		#		0xe09be09be09be09be09be09be09be09be09be09be09be09be09be09be09be09b
		#	AWDL=149/80 (e09b)		Infra=36/80 (e02a)
		#		0xe09be09be09be02ae02ae02ae02ae02ae09be09be09be02ae02ae02ae02ae02a
		#	AWDL=149/80 (e09b)		Infra=11 (100b)
		#		0xe09be09be09b100b100b100b100b100be09be09be09b100b100b100b100b100b

		set idle_chan "0000"
		
		# remove the 'l','u', and '/80' to get the control channel
		set awdl_control_chan [regexp -inline {\d+} $::p2p_chan]
		
		set awdl_chan [p2p::get_awdl_chan $::p2p_chan]
		UTF::Message INFO "" "::p2p_chan='$::p2p_chan' -> awdl_chan='$awdl_chan' & awdl_control_chan='$awdl_control_chan'"

		UTF::Message INFO "" "::test_type='$::test_type' -> (p2p_connection_first)='$(p2p_connection_first)'"

		if {$(p2p_connection_first) == 1} {
			# p2p_connection_first
			# later on, AP assoc fails if there is no idle slots. Idle slots is needed for scan and association.
			# Note: idle slots causes throughput drops
			set awdl_wlan_chan [p2p::get_awdl_chan $::wlan_chan]
			#set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" $awdl_chan $awdl_chan $idle_chan $idle_chan $idle_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_chan $awdl_chan $idle_chan $idle_chan $idle_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan]
			set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" $awdl_chan $awdl_chan $awdl_chan $idle_chan $idle_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_chan $awdl_chan $awdl_chan $idle_chan $idle_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan]
			UTF::Message INFO "" "AWDL Connection First - str_awdl_chan_seq='$str_awdl_chan_seq'"
			set wlan_chan $::p2p_chan
		} elseif {[string first "Direct" $::test_type] != -1} {
			# AWDL Only - do not use idle slots since it causes throughput drops
			set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan $awdl_chan]
			UTF::Message INFO "" "AWDL Only str_awdl_chan_seq='$str_awdl_chan_seq'"
			set wlan_chan $::p2p_chan
		} else {
			# AWDL+Infra
			set awdl_wlan_chan [p2p::get_awdl_chan $::wlan_chan]
			UTF::Message INFO "" "::wlan_chan='$::wlan_chan' -> awdl_wlan_chan='$awdl_wlan_chan'"
			set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" $awdl_chan $awdl_chan $awdl_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_chan $awdl_chan $awdl_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan]

			#set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" \
			#		$awdl_chan $awdl_chan $awdl_chan $awdl_wlan_chan \
			#		$awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan \
			#		$awdl_chan $awdl_chan $awdl_chan $awdl_chan \
			#		$awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan]

			#set str_awdl_chan_seq [format "0x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s" \
			#		$awdl_chan $awdl_chan $awdl_wlan_chan $awdl_wlan_chan \
			#		$idle_chan $idle_chan $idle_chan $idle_chan \
			#		$idle_chan $awdl_chan $awdl_chan $awdl_chan \
			#		$awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan $awdl_wlan_chan]
			
			UTF::Message INFO "" "AWDL+Infra str_awdl_chan_seq='$str_awdl_chan_seq'"
			set wlan_chan $::wlan_chan
		}
		
		UTF::Message INFO "" "------------------------------MASTER-----------------------------------"
		# setup IP WLAN GO (MASTER)
		set ::array_sta_wlan_macaddr(${::go_wlan}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})]]
		UTF::Message INFO "" "::array_sta_wlan_macaddr(${::go_wlan})=$::array_sta_wlan_macaddr(${::go_wlan})"
		$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) $::array_sta_wlan_ip(${::go_wlan}) netmask 255.255.255.0 up

		UTF::Sleep 1

		$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up

		UTF::Sleep 1

		# Set awdl link MAC addresses
		$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) awdl_if -C 2 $awdl_bssid up
		UTF::Sleep 1

		# setup IP P2P GO (MASTER)
		UTF::Message LOG "" "DUT with higher MAC address '39' is assumed as master role"
		set go_macaddr "02:90:4C:C6:13:39"
		set go_macaddr [string toupper $go_macaddr]
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) hw ether $go_macaddr
		UTF::Sleep 1
		set ::array_sta_p2p_macaddr(${::go_wlan}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})]]
		set ::array_sta_p2p_macaddr(${::go_wlan}) [string toupper $::array_sta_p2p_macaddr(${::go_wlan})]
		UTF::Message INFO "" "::array_sta_p2p_macaddr(${::go_wlan})=$::array_sta_p2p_macaddr(${::go_wlan})"
		if {$::array_sta_p2p_macaddr(${::go_wlan}) != $go_macaddr} {
			error "::array_sta_p2p_macaddr(${::go_wlan})=$::array_sta_p2p_macaddr(${::go_wlan}) instead of $go_macaddr. Halting tests!"
		}
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) $::array_sta_p2p_ip(${::go_wlan}) netmask 255.255.255.0 up

		$::go_wlan rexec ifconfig -a
	
		UTF::Message INFO "" "------------------------------SLAVE-----------------------------------"
		# setup IP WLAN GC (SLAVE)
		set ::array_sta_wlan_macaddr(${gc_wlan_index}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})]]
		UTF::Message INFO "" "::array_sta_wlan_macaddr(${gc_wlan_index})=$::array_sta_wlan_macaddr(${gc_wlan_index})"
		$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) $::array_sta_wlan_ip(${gc_wlan_index}) netmask 255.255.255.0 up

		UTF::Sleep 1

		$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) up
		
		UTF::Sleep 1

		# Set awdl link MAC addresses
		$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) awdl_if -C 2 $awdl_bssid up
		UTF::Sleep 1

		# setup IP P2P GC (SLAVE)
		UTF::Message LOG "" "DUT with lower MAC address '37' is assumed as slave role"
		set gc_macaddr "02:90:4C:C6:13:37"
		set gc_macaddr [string toupper $gc_macaddr]
		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) hw ether $gc_macaddr
		UTF::Sleep 1
		set ::array_sta_p2p_macaddr(${gc_wlan_index}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})]]
		set ::array_sta_p2p_macaddr(${gc_wlan_index}) [string toupper $::array_sta_p2p_macaddr(${gc_wlan_index})]
		UTF::Message INFO "" "::array_sta_p2p_macaddr(${gc_wlan_index})=$::array_sta_p2p_macaddr(${gc_wlan_index})"
		if {$::array_sta_p2p_macaddr(${gc_wlan_index}) != $gc_macaddr} {
			error "::array_sta_p2p_macaddr(${gc_wlan_index})=$::array_sta_p2p_macaddr(${gc_wlan_index}) instead of $gc_macaddr. Halting tests!"
		}
		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) $::array_sta_p2p_ip(${gc_wlan_index}) netmask 255.255.255.0 up

		$gc_wlan_index rexec ifconfig -a

		UTF::Message INFO "" "------------------------------MASTER & SLAVE-----------------------------------"

		foreach STA "$::go_wlan $gc_wlan_index" {
			$STA wl -i $::array_sta_p2p_ifname(${STA}) up
			$STA wl -i $::array_sta_p2p_ifname(${STA}) bss up
			UTF::Sleep 1
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_config 3
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_af_hdr ff:ff:ff:ff:ff:88 0x7f010203
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_pktlifetime 10
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_sync_params 110 16 16 10 16 $awdl_control_chan		
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_payload 0x5566779900888899fefe
			UTF::Sleep 1
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_awbcnoffset 0
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_maxnomaster 8
			# encoding=2 for 80/40/20 MHz
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_chan_seq 2 3 0 0xffff $str_awdl_chan_seq
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_chan_seq
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_oob_af_auto $awdl_bssid ff:ff:ff:ff:ff:88 0 10 7 20 6 3 65535 5000 1122334455667788
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_election_tree 0 0 1 -50 0 -90 -90 -90 1 1 16 0 0
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_election_metric 1
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_af_rssi -80
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_extcounts 3 0 0 0
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_presencemode 4
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_aftxmode 3
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_osoc_chan $awdl_control_chan
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl 1
			UTF::Sleep 2
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_presencemode
		}

		UTF::Message INFO "" "----------------------------------------------------------------------"

		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) awdl_peer_op add $::array_sta_p2p_macaddr(${gc_wlan_index}) 1 0x2d1a7f1017ffff000000000000000000000000000000000000000000bf0c3258810ffaff0000faff0000
		# no delay should be here otherwise both sides could miss each other
		$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) awdl_peer_op add $::array_sta_p2p_macaddr(${::go_wlan}) 1 0x2d1a7f1017ffff000000000000000000000000000000000000000000bf0c3258810ffaff0000faff0000
		UTF::Sleep 5

		UTF::Message INFO "" "**************Must ping AWDL of AP+STA*****************************"
		if {$::ap_connect == "GO"} {
			set catch_resp [catch {$gc_wlan_index rexec ping -c 3 $::array_sta_p2p_ip(${::go_wlan})} catch_msg]
		} else {
			set catch_resp [catch {$::go_wlan rexec ping -c 3 $::array_sta_p2p_ip(${gc_wlan_index})} catch_msg]
		}

		foreach STA "$::go_wlan $gc_wlan_index" {
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_peer_op
			UTF::Sleep 1
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_opmode
			$STA wl -i $::array_sta_p2p_ifname(${STA}) awdl_stats
			$STA wl -i $::array_sta_p2p_ifname(${STA}) status 
			$STA rexec ifconfig -a
		}
		
		UTF::Sleep 1
		
		set ::array_sta_p2p_active_flag(${gc_wlan_index}) 1
		set ::array_sta_p2p_disassociated_flag(${gc_wlan_index}) 0
		UTF::Message INFO "" "wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${gc_wlan_index})"
		UTF::Message INFO "" "p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${gc_wlan_index})"

		# chanspec for AWDL
		set ::chanspec_p2p $::p2p_chan
		
		return $::p2p_chan
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "AWDL_panic" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	} else {
		# check for other error
		if {$::errorCode != "NONE"} {
			set lines [split $::errorInfo "\n"]
			set line [lindex $lines 0]
			set ::panic_msg "($line)"
			UTF::Message INFO "AWDL_error" "::errorCode=$::errorCode"
			UTF::Message INFO "AWDL_error" "::errorInfo=$::errorInfo"
			incr ::error_cnt
		}
	}
}

proc p2p::mac_apple80211_create_go {} {

	UTF::Message INFO "" "************************Func:mac_apple80211_create_go***************************"

	UTF::Message INFO "" "::array_sta_p2p_macaddr(${::go_wlan})=$::array_sta_p2p_macaddr(${::go_wlan})"

	set ::catch_resp [catch {		

		UTF::Message INFO "" "$::go_wlan $::apple_tool -vif_create=p2p_go,$::array_sta_p2p_macaddr(${::go_wlan})"	
		set rc [$::go_wlan $::apple_tool -vif_create=p2p_go,$::array_sta_p2p_macaddr(${::go_wlan})]
		UTF::Sleep 1

		# the p2p is created
		regexp -nocase {Created (.*)} $rc match ::array_sta_p2p_ifname(${::go_wlan})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${::go_wlan})' is created"

		UTF::Message INFO "" "$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -p2p_go_default_ies=on"
		$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -p2p_go_default_ies=on
		UTF::Sleep 1

		UTF::Message INFO "" "$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -ie_add=pb,5,dd0017f205"
		$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -ie_add=pb,5,dd0017f205
		UTF::Sleep 1

		set tmp_chan $::p2p_chan
		# channels with "l" must be passed as "+" and "u" must be passed as "-"
		set Index [string last "u" $tmp_chan]
		if {$Index >= 0} {
			set tmp_chan [string replace $tmp_chan $Index end "-"]
			UTF::Message INFO "" "p2p_chan=$tmp_chan"
		}
		set Index [string last "l" $tmp_chan]
		if {$Index >= 0} {
			set tmp_chan [string replace $tmp_chan $Index end "+"]
			UTF::Message INFO "" "p2p_chan=$tmp_chan"
		}
				
		UTF::Message INFO "" "$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -p2p_go_conf=$::p2p_ssid,$tmp_chan,on,off"
		$::go_wlan $::apple_tool $::array_sta_p2p_ifname(${::go_wlan}) -p2p_go_conf=$::p2p_ssid,$tmp_chan,on,off
		UTF::Sleep 1

		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) $::array_sta_p2p_ip(${::go_wlan}) netmask 255.255.255.0
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) up
		UTF::Sleep 2
		
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})
		
		# Mountain Lion OS does not allow to change mtu for P2P interface
		#$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) mtu 1500
		#$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})
		
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::mac_wl_create_go {} {

	UTF::Message INFO "" "************************Func:mac_wl_create_go***************************"

	set ::catch_resp [catch {
	
		$::go_wlan wl p2p_ifadd $::array_sta_p2p_macaddr(${::go_wlan}) go $::p2p_chan
		UTF::Sleep 1

		# get the new P2P interface name
		set rc [$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})]
		regexp -nocase { (.*)} $rc match ::array_sta_p2p_ifname(${::go_wlan})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${::go_wlan})' is created"
	
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) $::array_sta_p2p_ip(${::go_wlan}) netmask 255.255.255.0
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) up
		UTF::Sleep 2
		
		regsub -all {:} $::array_sta_p2p_macaddr(${::go_wlan}) "" go_p2p_macaddr_strip
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) add_ie 1 18 00:17:f2 050202000009030600$go_p2p_macaddr_strip
		set tmp "0502020000090d1d00$go_p2p_macaddr_strip"
		append tmp "008000010050f2040001001011000854657374204d6163" 
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) add_ie 2 41 00:17:f2 $tmp

		if {$::p2p_security != "open"} {
			UTF::Message INFO "" "$::p2p_display_str security is not supported on Mac OS. $::p2p_display_str Open Security is used instead."
			set ::mac_p2p_security_flag 1
			UTF::Message ERROR "" "***Failed. $::p2p_display_str security is not supported on Mac OS."
			error "$::p2p_display_str security is not supported on Mac OS"
		}

		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) ssid $::p2p_ssid
		UTF::Sleep 1
		
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})

		# Mountain Lion OS does not allow to change mtu for P2P interface
		#$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) mtu 1500
		#$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})
		
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::create_go {} {

	UTF::Message INFO "" "************************Func:create_go***************************"

	set ::catch_resp [catch {
	
		$::go_wlan wl p2p_ifadd $::array_sta_p2p_macaddr(${::go_wlan}) go $::p2p_chan

		# get the new P2P interface name
		set rc [$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})]
		regexp -nocase { (.*)} $rc match ::array_sta_p2p_ifname(${::go_wlan})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${::go_wlan})' is created"
		
		$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) $::array_sta_p2p_ip(${::go_wlan}) netmask 255.255.255.0 up
		
		regsub -all {:} $::array_sta_p2p_macaddr(${::go_wlan}) "" go_p2p_macaddr_strip
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) add_ie 1 18 50:6F:9A 090202000409030600$go_p2p_macaddr_strip
		set tmp "0902020004090D1900$go_p2p_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) add_ie 2 41 50:6F:9A $tmp

		if {$::p2p_security != "open"} {
			# AES=4, TKIP=8
			$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) wsec 4
			$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) set_pmk 12345678
			# WPA2-PSK auth needs to be 0x80
			# this can be done also by doing "join $::p2p_ssid imode bss amode wpa2psk" instead of "ssid $::p2p_ssid"
			# command and the driver will set wpa_auth to 0x80 automatically
			$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) wpa_auth 0x80
		}
		
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) ssid $::p2p_ssid
		UTF::Sleep 2
		$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) bss up
		UTF::Sleep 2
		
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::setup_nan2 {} {
	UTF::Message INFO "" "************************Func:setup_nan2***************************"

	set ::nan_base_cluster_id ""	

	set gc_wlan_index [lindex $::list_gc_wlan_objects 0]

	UTF::Try "$::test_type: Setup NAN: CH=$::p2p_chan" {
		p2p::setup_nan_master $::go_wlan
		p2p::setup_nan_slave $gc_wlan_index
	}
}

proc p2p::setup_nan_master {STA} {
	UTF::Message INFO "" "************************Func:setup_nan_master***************************"

	UTF::Try "$STA: Setup NAN Master: CH=$::p2p_chan" {

		UTF::Message INFO "" "Setup $::p2p_display_str $::go_display_str"

		UTF::Message INFO "" "MASTER: macaddr=$::array_sta_wlan_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

		set rc [p2p::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $STA "nan enable 1"]
		set rc [p2p::run_wl_cmd $STA "nan band auto"]
		set rc [p2p::run_wl_cmd $STA "nan chan $::p2p_chan"]
		#set rc [p2p::run_wl_cmd $STA "nan chan 6"]
		set rc [p2p::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [p2p::run_wl_cmd $STA "nan election_metrics master 100"]
		set rc [p2p::run_wl_cmd $STA "nan join -start"]
		set rc [p2p::run_wl_cmd $STA "nan dp_autoconn 3"]
		UTF::Message INFO "" "10 sec delay is needed for the master start"
		UTF::Sleep 20

		$STA rexec ifconfig $::array_sta_wlan_ifname(${STA}) $::array_sta_wlan_ip(${STA}) netmask 255.255.255.0 up
		$STA rexec ifconfig $::array_sta_p2p_ifname(${STA}) $::array_sta_p2p_ip(${STA}) netmask 255.255.255.0 up
		$STA rexec ifconfig -a
		
		UTF::Sleep 1

		set ::array_sta_p2p_macaddr(${STA}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$STA rexec ifconfig $::array_sta_p2p_ifname(${STA})]]
		set ::array_sta_p2p_macaddr(${STA}) [string toupper $::array_sta_p2p_macaddr(${STA})]
		UTF::Message INFO "" "::array_sta_p2p_macaddr(${STA})=$::array_sta_p2p_macaddr(${STA})"

		set catch_resp [catch {$STA rexec dhd -i $::array_sta_apsta_ifname(${STA}) cons mu} catch_msg]
		set rc [p2p::run_wl_cmd $STA "nan avail 3 entry 1 bitmap 10000000"]
		set rc [p2p::run_wl_cmd $STA "nan avail 1 entry 1 bitmap 10011001 chanspec 6/20"]

		set rc [p2p::run_wl_cmd $STA "nan dump rssi"]
		set rc [p2p::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		# master cluster_id is random value base_cluster_id plus ":00:00"
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set ::nan_base_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]
		UTF::Message INFO "" "::nan_base_cluster_id=$::nan_base_cluster_id"
		
		if {$cluster_id != "$::nan_base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$::nan_base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: anchor-master} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): anchor-master\}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role != "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			incr ::error_cnt
			error "Bad Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check master_rank
		###########################
		# master_rank is STA mac address plus ":xx:xx"
		regexp -nocase {master_rank:.*?\n(.*)\n.*amr:} $rc - master_rank
		UTF::Message INFO "" "master_rank='$master_rank'"
		regexp -nocase {:(.*)} $master_rank - master_rank
		set master_rank [string trim $master_rank]
		regsub -all { } $master_rank ":" master_rank
		set master_rank [string toupper $master_rank]
		# remove the end ":xx:xx"
		set master_rank [string replace $master_rank 17 end ""]
		UTF::Message INFO "" "master_rank=$master_rank"
		set base_mac_address $master_rank

		# NAN macaddr starts with 02
		set ::array_sta_p2p_macaddr(${STA}) [string replace $::array_sta_wlan_macaddr(${STA}) 1 1 "2"]

		if {$master_rank != $::array_sta_p2p_macaddr(${STA})} {
			# failed
			UTF::Message INFO "" "master_rank is '$master_rank' instead of '$::array_sta_p2p_macaddr(${STA})'"
			incr ::error_cnt
			error "Bad master_rank"
		}
		
		return ""
	}

	if {$::error_cnt > 0} {
		error "html: Halting tests!"
	}
}

proc p2p::setup_nan_slave {STA} {
	UTF::Message INFO "" "************************Func:setup_nan_slave***************************"

	UTF::Try "$STA: Setup NAN Slave" {
	
		UTF::Message INFO "" "PEER: macaddr=$::array_sta_wlan_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

		set rc [p2p::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $STA "nan enable 1"]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set rc [p2p::run_wl_cmd $STA "nan band auto"]
		set rc [p2p::run_wl_cmd $STA "nan chan $::p2p_chan"]
		#set rc [p2p::run_wl_cmd $STA "nan chan 6"]
		set rc [p2p::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [p2p::run_wl_cmd $STA "nan election_metrics master 10"]
		set rc [p2p::run_wl_cmd $STA "nan join -start"]
		set rc [p2p::run_wl_cmd $STA "nan dp_autoconn 3"]
		
		UTF::Message INFO "" "20 sec delay is mandatory to sync with Master"
		UTF::Sleep 20

		$STA rexec ifconfig $::array_sta_wlan_ifname(${STA}) $::array_sta_wlan_ip(${STA}) netmask 255.255.255.0 up
		$STA rexec ifconfig $::array_sta_p2p_ifname(${STA}) $::array_sta_p2p_ip(${STA}) netmask 255.255.255.0 up
		$STA rexec ifconfig -a

		UTF::Sleep 1

		set ::array_sta_p2p_macaddr(${STA}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} [$STA rexec ifconfig $::array_sta_p2p_ifname(${STA})]]
		set ::array_sta_p2p_macaddr(${STA}) [string toupper $::array_sta_p2p_macaddr(${STA})]
		UTF::Message INFO "" "::array_sta_p2p_macaddr(${STA})=$::array_sta_p2p_macaddr(${STA})"

		set catch_resp [catch {$STA rexec dhd -i $::array_sta_apsta_ifname(${STA}) cons mu} catch_msg]
		set rc [p2p::run_wl_cmd $STA "nan avail 3 entry 1 bitmap 10000000"]
		set rc [p2p::run_wl_cmd $STA "nan avail 1 entry 1 bitmap 10011111 chanspec 6/20"]

		set rc [p2p::run_wl_cmd $STA "nan dump rssi"]
		set rc [p2p::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set non_master_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]

		if {$::nan_base_cluster_id != $non_master_cluster_id} {
			# failed
			UTF::Message INFO "" "Non Master Cluster ID is '$non_master_cluster_id' instead of '$::nan_base_cluster_id'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}
		
		if {$cluster_id != "$::nan_base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$::nan_base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: non-master-non-sync} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): non-master-non-sync\}} $role - role
		UTF::Message INFO "" "role=$role"
		if {$role == ""} {
			# Role is not "non-master-non-sync"
			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
		}
		
		# device can take master role 3 if the rssi threshold is hit
		if {$role != "1" && $role != "2" && $role != "3"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$::go_wlan rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role is '$role' instead of '1' for 'non-master-non-sync', '2' for 'non-master-sync',  or '3' for 'master'"
			error "Bad Non Master Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check amr
		###########################
		# amr is STA mac address plus ":xx:xx"
		regexp -nocase {amr:\n(.*)\n.*hop_count:} $rc - amr
		UTF::Message INFO "" "amr='$amr'"
		regexp -nocase {:(.*)} $amr - amr
		set amr [string trim $amr]
		regsub -all { } $amr ":" amr
		set amr [string toupper $amr]
		# remove the end ":xx:xx"
		set amr [string replace $amr 17 end ""]
		UTF::Message INFO "" "amr=$amr"

		if {$amr != $::array_sta_p2p_macaddr(${::go_wlan})} {
			# failed
			UTF::Message INFO "" "amr is '$amr' instead of '$::array_sta_p2p_macaddr(${master_sta})'"
			error "Bad Non Master amr"
		}

		if {$role == "1"} {
			return "Non-Master-Non-Sync"
		} elseif {$role == "2"} {
			return "Non-Master-Sync"
		} elseif {$role == "3"} {
			return "Master"
		}
	}
}

proc p2p::setup_go {} {

	UTF::Message INFO "" "************************Func:setup_go***************************"

	UTF::Try "$::test_type: Setup $::p2p_display_str $::go_display_str: CH=$::p2p_chan" {

		UTF::Message INFO "" "Setup $::p2p_display_str $::go_display_str"

		set ::p2p_cleanup_flag 1
		
		if {$::array_sta_host_type(${::go_wlan}) == "MacOS"} {
			if {$::use_wl_for_mac} {
				p2p::mac_wl_create_go
			} else {
				p2p::mac_apple80211_create_go
			}
		} else {
			p2p::create_go
		}

		if {$::catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Setup GO failed."
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $::catch_msg
		}
		
		# Confirm chanspec
		set temp [$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) chanspec]
		regexp {(\S+) } $temp match go_chan
		
		if {$::p2p_chan != $go_chan} {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "GO chan is $go_chan instead of $::p2p_chan" 
		}		
	}
}

proc p2p::mac_apple80211_create_gc {gc_wlan_index} {

	UTF::Message INFO "" "************************Func:mac_apple80211_create_gc***************************"

	UTF::Message INFO "" "::array_sta_p2p_macaddr(${gc_wlan_index})=$::array_sta_p2p_macaddr(${gc_wlan_index})"

	set ::catch_resp [catch {		

		UTF::Message INFO "" "$gc_wlan_index $::apple_tool -vif_create=p2p_cli,$::array_sta_p2p_macaddr(${gc_wlan_index})"
		set rc [$gc_wlan_index $::apple_tool -vif_create=p2p_cli,$::array_sta_p2p_macaddr(${gc_wlan_index})]
		UTF::Sleep 1

		# the p2p is created
		regexp -nocase {Created (.*)} $rc match ::array_sta_p2p_ifname(${gc_wlan_index})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${gc_wlan_index})' is created"

		UTF::Message INFO "" "$gc_wlan_index $::apple_tool $::array_sta_p2p_ifname(${gc_wlan_index}) -p2p_cli_default_ies=on"
		$gc_wlan_index $::apple_tool $::array_sta_p2p_ifname(${gc_wlan_index}) -p2p_cli_default_ies=on
		UTF::Sleep 1

		UTF::Message INFO "" "$gc_wlan_index $::apple_tool $::array_sta_p2p_ifname(${gc_wlan_index}) -ie_add=PA,5,dd0017f205"
		$gc_wlan_index $::apple_tool $::array_sta_p2p_ifname(${gc_wlan_index}) -ie_add=PA,5,dd0017f205
		UTF::Sleep 1

		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) $::array_sta_p2p_ip(${gc_wlan_index}) netmask 255.255.255.0			
		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) up			
		UTF::Sleep 2

		$gc_wlan_index rexec ifconfig -a
		
		# Mountain Lion OS does not allow to change mtu for P2P interface
		#$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) mtu 1500
		#$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})
		
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::mac_wl_create_gc {gc_wlan_index} {

	UTF::Message INFO "" "************************Func:mac_wl_create_gc***************************"

	set ::catch_resp [catch {
	
		$gc_wlan_index wl p2p_ifadd $::array_sta_p2p_macaddr(${gc_wlan_index}) client $::p2p_chan

		# get the new P2P interface name
		set rc [$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})]
		regexp -nocase { (.*)} $rc match ::array_sta_p2p_ifname(${gc_wlan_index})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${gc_wlan_index})' is created"

		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) $::array_sta_p2p_ip(${gc_wlan_index}) netmask 255.255.255.0			
		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) up			
		
		$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) add_ie 48 9 00:17:f2 050202000000

		if {$::p2p_security != "open"} {
			UTF::Message INFO "" "$::p2p_display_str security is not supported on Mac OS. $::p2p_display_str Open Security is used instead."
			set ::mac_p2p_security_flag 1
		}

		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) infra 1}

		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})
		
		UTF::Message INFO "" "-------------------------------------------------------------"
		$gc_wlan_index rexec ifconfig -a
		
		# Mountain Lion OS does not allow to change mtu for P2P interface
		#$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) mtu 1500
		#$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})
		
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::create_gc {gc_wlan_index} {

	UTF::Message INFO "" "************************Func:create_gc***************************"

	set ::catch_resp [catch {		
		$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) $::array_sta_wlan_ip(${gc_wlan_index}) netmask 255.255.255.0 up
		
		$gc_wlan_index wl up
		
		$gc_wlan_index wl p2p_ifadd $::array_sta_p2p_macaddr(${gc_wlan_index}) client $::p2p_chan

		# get the new P2P interface name
		set rc [$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})]
		regexp -nocase { (.*)} $rc match ::array_sta_p2p_ifname(${gc_wlan_index})
		UTF::Message INFO "" "p2p interface '$::array_sta_p2p_ifname(${gc_wlan_index})' is created"
		
		$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) $::array_sta_p2p_ip(${gc_wlan_index}) netmask 255.255.255.0 up
		
		$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) add_ie 0x10 14 50:6F:9A 090202000400060200000B
		regsub -all {:} $::array_sta_p2p_macaddr(${gc_wlan_index}) "" gc_p2p_macaddr_strip
		set tmp "0902020004000D1900$gc_p2p_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) add_ie 2 41 50:6F:9A $tmp
		$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) add_ie 0x20 41 50:6F:9A $tmp

		if {$::p2p_security != "open"} {
			# AES=4, TKIP=8
			$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) wsec 4
			$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) sup_wpa 1
			$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) set_pmk 12345678
		}

		# must set infra=1 or use "imode bss" with the P2P join command
		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) infra 1}
		
		UTF::Message INFO "" "-------------------------------------------------------------"
		$::go_wlan rexec ifconfig -a
		$gc_wlan_index rexec ifconfig -a
	} ::catch_msg]
	
	UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"
}

proc p2p::setup_gc {} {

	foreach gc_wlan_index $::list_gc_wlan_objects {

		UTF::Try "$::test_type: Setup $::p2p_display_str $::gc_display_str" {

			UTF::Message INFO "" "************************Func:setup_gc $gc_wlan_index***************************"

			UTF::Message INFO "" "Setup $::p2p_display_str $::gc_display_str"

			if {$::array_sta_host_type(${gc_wlan_index}) == "MacOS"} {
				if {$::use_wl_for_mac} {
					p2p::mac_wl_create_gc $gc_wlan_index
				} else {
					p2p::mac_apple80211_create_gc $gc_wlan_index
				}
			} else {
				p2p::create_gc $gc_wlan_index
			}

			if {$::catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. Setup GC failed."
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error $::catch_msg
			}
		}
	}
}

proc p2p::mac_apple80211_p2p_remove {} {

	UTF::Message INFO "" "************************Func:mac_apple80211_p2p_remove***************************"

	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a

	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) disassoc}
		UTF::Sleep 2
	}
	catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) disassoc}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) disassoc}
		UTF::Sleep 2
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) delete}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) delete}
	UTF::Sleep 2

	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index $::apple_tool -vif_delete=$::array_sta_p2p_ifname(${gc_wlan_index})}
		UTF::Sleep 2
	}
	catch {$::go_wlan $::apple_tool -vif_delete=$::array_sta_p2p_ifname(${::go_wlan})}
	UTF::Sleep 2

	UTF::Message INFO "" "**********************************"
	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a
}

proc p2p::mac_wl_p2p_remove {} {

	UTF::Message INFO "" "************************Func:mac_wl_p2p_remove***************************"

	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a

	UTF::Message INFO "" "$::p2p_display_str Clean up for mac"

	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) disassoc}
		UTF::Sleep 2
	}
	catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) disassoc}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) disassoc}
		UTF::Sleep 2
		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})}
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})} 

	foreach gc_wlan_index $::list_gc_wlan_objects {
		set ::catch_resp [catch {$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})} ::catch_msg]
		if {[string first "Not Found" $::catch_msg] == -1} {
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) del_ie 16 9 00:17:f2 050202000000}
			UTF::Sleep 2
		}
	}

	set ::catch_resp [catch {$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})} ::catch_msg]
	if {[string first "Not Found" $::catch_msg] == -1} {
		regsub -all {:} $::array_sta_p2p_macaddr(${::go_wlan}) "" go_p2p_macaddr_strip
		set tmp "0502020000090d1d00$go_p2p_macaddr_strip"
		append tmp "008000010050f2040001001011000854657374204d6163" 	
		catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) del_ie 2 41 00:17:f2 $tmp}
		UTF::Sleep 2
		catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) del_ie 1 18 00:17:f2 050202000009030600$go_p2p_macaddr_strip}
		UTF::Sleep 2
	}

	foreach gc_wlan_index $::list_gc_wlan_objects {
		set ::catch_resp [catch {$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})} ::catch_msg]
		if {[string first "Not Found" $::catch_msg] == -1} {
			catch {$gc_wlan_index wl p2p_ifdel $::array_sta_p2p_macaddr(${gc_wlan_index})}
			UTF::Sleep 2
		}
	}

	set ::catch_resp [catch {$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})} ::catch_msg]
	if {[string first "Not Found" $::catch_msg] == -1} {
		catch {$::go_wlan wl p2p_ifdel $::array_sta_p2p_macaddr(${::go_wlan})}
		UTF::Sleep 2
	}

	UTF::Sleep 4
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})}
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})} 

	UTF::Message INFO "" "**********************************"
	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a
}

proc p2p::p2p_remove {} {
	
	UTF::Message INFO "" "************************Func:p2p_remove***************************"

	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a

	foreach gc_wlan_index $::list_gc_wlan_objects {
		if {$::nan2_flag} {
			UTF::Message INFO "" "NAN Clean up for Linux needs 'wl nan dp_dataend 1 0' commnad"
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) nan dp_dataend 1 0}
			UTF::Message INFO "" "NAN Clean up for Linux needs 'wl nan enable 0' commnad"
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) nan enable 0}
		} elseif {$::awdl_flag} {
			UTF::Message INFO "" "AWDL Clean up for Linux needs 'wl awdl 0' commnad"
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) awdl 0}
		} else {
			UTF::Message INFO "" "P2P Clean up for Linux needs 'wl disassoc' commnad"
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) disassoc}
		}
		UTF::Sleep 2
	}
	catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) disassoc}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) disassoc}
		UTF::Sleep 2
		catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})} 

	foreach gc_wlan_index $::list_gc_wlan_objects {
		set ::catch_resp [catch {$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})} ::catch_msg]
		if {[string first "Not Found" $::catch_msg] == -1} {
			regsub -all {:} $::array_sta_p2p_macaddr(${gc_wlan_index}) "" gc_p2p_macaddr_strip
			set tmp "0902020004000D1900$gc_p2p_macaddr_strip"
			append tmp "000400010050F204000600101100045032502D0E010000" 
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) del_ie 0x20 41 50:6F:9A $tmp}
			UTF::Sleep 2
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) del_ie 2 41 50:6F:9A $tmp}
			UTF::Sleep 2
			catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) del_ie 0x10 14 50:6F:9A 090202000400060200000B}
			UTF::Sleep 2
		}
	}

	set ::catch_resp [catch {$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})} ::catch_msg]
	if {[string first "Not Found" $::catch_msg] == -1} {
		regsub -all {:} $::array_sta_p2p_macaddr(${::go_wlan}) "" go_p2p_macaddr_strip
		set tmp "0902020004090D1900$go_p2p_macaddr_strip"
		append tmp "000400010050F204000600101100045032502D0E010000" 
		catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) del_ie 2 41 50:6F:9A $tmp}
		UTF::Sleep 2
		catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) del_ie 1 18 50:6F:9A 090202000409030600$go_p2p_macaddr_strip}
		UTF::Sleep 2
	}

	foreach gc_wlan_index $::list_gc_wlan_objects {
		set ::catch_resp [catch {$gc_wlan_index wl p2p_if $::array_sta_p2p_macaddr(${gc_wlan_index})} ::catch_msg]
		if {[string first "Not Found" $::catch_msg] == -1} {
			catch {$gc_wlan_index wl p2p_ifdel $::array_sta_p2p_macaddr(${gc_wlan_index})}
			UTF::Sleep 2
		}
	}

	set ::catch_resp [catch {$::go_wlan wl p2p_if $::array_sta_p2p_macaddr(${::go_wlan})} ::catch_msg]
	if {[string first "Not Found" $::catch_msg] == -1} {
		catch {$::go_wlan wl p2p_ifdel $::array_sta_p2p_macaddr(${::go_wlan})}
		UTF::Sleep 2
	}

	UTF::Sleep 4
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})} 
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) down}
		UTF::Sleep 2
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) down}
	UTF::Sleep 2
	foreach gc_wlan_index $::list_gc_wlan_objects {
		catch {$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})}
	}
	catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})} 

	UTF::Message INFO "" "**********************************"
	foreach gc_wlan_index $::list_gc_wlan_objects {
		$gc_wlan_index rexec ifconfig -a
	}
	$::go_wlan rexec ifconfig -a
}

proc p2p::p2p_cleanup {} {
	
	UTF::Message INFO "" "************************Func:p2p_cleanup***************************"
	
	# all GCs with the same OS is supported
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	if {$::array_sta_host_type(${sta_wlan_index}) == "MacOS"} {
		if {$::awdl_flag} {
			UTF::Message INFO "" "MacOS AWDL is created by OS, therefore nothing to cleanup"
		} elseif {$::use_wl_for_mac} {
			UTF::Message INFO "" "$::p2p_display_str Clean up for mac when wl commands are used"
			p2p::mac_wl_p2p_remove
		} else {
			UTF::Message INFO "" "$::p2p_display_str Clean up for mac when apple80211 commands are used"
			p2p::mac_apple80211_p2p_remove
		}
	} else {
		UTF::Message INFO "" "$::p2p_display_str Clean up for non mac (Linux)"
		p2p::p2p_remove
	}

	foreach gc_wlan_index $::list_gc_wlan_objects {
		set ::array_sta_p2p_active_flag(${gc_wlan_index}) 0
	}
	set ::p2p_cleanup_flag 0
	
	return ""
}

proc p2p::setup_opp_ps {} {

	UTF::Message INFO "" "************************Func:setup_opp_ps***************************"

	UTF::Try "$::test_type: Setup OppPS with CTWindow $::OppPS_CTWindow" {

		UTF::Message INFO "" "Setup OppPS with CTWindow=$::OppPS_CTWindow"

		set ::catch_resp [catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) p2p_ops 1 $::OppPS_CTWindow} ::catch_msg]

		if {$::catch_resp == 0} {
			return $::catch_msg
		} else {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $::catch_msg
		}
	}
}

proc p2p::setup_noa {} {

	UTF::Message INFO "" "************************Func:setup_noa***************************"

	UTF::Try "$::test_type: Setup NoA (Notice of Absence)" {

		UTF::Message INFO "" "Setup NoA (Notice of Absence)"

		set ::catch_resp [catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) p2p_noa $::NoA_Param} ::catch_msg]

		if {$::catch_resp == 0} {
			return $::catch_msg
		} else {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $::catch_msg
		}
	}
}

proc p2p::create_ap_connection {} {
	# access option array
	upvar {} {}

	set ::ap_str ""

	UTF::Message INFO "" "************************Func:create_ap_connection***************************"

	if { [string first "Direct" $::test_type] == -1 } {

		# for SameChan and MultiChan only

		#####################################################
		##### Current Measurement before AP association #####
		#####################################################
		if {$::agilent_obj != ""} {

			UTF::Try "DTIM Interval Measurement (AP Not Associated)" {
				foreach STA $::list_sta_wlan_objects {
					catch {$STA wl dtim}
					catch {$STA wl PM}
				}

				set ::cct_key "DTIM AP Not Associated"
				p2p::measure_dtim_interval					
				return "html: $::current_results"
			}

			UTF::Try "Current Measurement (AP Not Associated)" {
				set ::cct_key "AP Not Associated"
				p2p::measure_idle_current					
				return "html: $::current_results"
			}
		}

		#####################################################
		##############   GC or GO joins AP   ################
		#####################################################
		p2p::gc_or_go_join_ap

		# check for panic, trap, assert message
		if {[info exists ::UTF::panic]} {
			set ::panic_msg "($::UTF::panic)"
			UTF::Message INFO "H" "::UTF::panic=$::panic_msg"
			incr ::error_cnt
		}

		#####################################################
		# Free memory after AP association
		foreach s "$::list_sta_wlan_objects" {
			if {[$s rte_available]} {
				if {$::soft_ap_flag == 1} {
					set tmp_ap "SoftAP"
				} else {
					set tmp_ap "AP"
				}
				
				UTF::Try "$s: Free Memory After $tmp_ap Assoc (K)" {
					# retry is needed due to issues with NPC serial port
					for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
						set catch_resp [catch "$s freekb" catch_msg]
						UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
						if {$catch_resp == 0} {
							break
						}
					}

					if {$catch_resp == 1} {
						error $catch_msg							
					}

					set ret_val [format "%.7f" $catch_msg]
					set branch [$s branchname]
					UTF::Test::memchart $ret_val -failonlow -key [list $branch $s $tmp_ap assocfree] -units kb -title "$tmp_ap Assoc Free"
				}
			}
		}
		#####################################################

		if {$::error_cnt > 0} {
			p2p::connection_test
		}
	}
}

proc p2p::gc_or_go_join_ap {} {
	# access option array
	upvar {} {}

	if {$::soft_ap_flag == 1} {
		set tmp_ap "SoftAP"
	} else {
		set tmp_ap "AP"
	}

	if {$::ap_connect == "GO"} {
		# only GO connects to the AP
		set list_connect_objects $::go_wlan
	} else {
		# all STAs or GCs connect to the AP
		set list_connect_objects $::list_gc_wlan_objects
	}

	foreach sta_wlan_index $list_connect_objects {

		UTF::Try "$sta_wlan_index: $::str_ap_connect Join $tmp_ap: CH=$::wlan_chan" {

			UTF::Message INFO "" "************************Func:gc_or_go_join_ap***************************"

			set ::ap_str "$::ap_connect\APCh=$::wlan_chan "
			set ::key_base2 "$::key_base [string trim $::ap_str]"

			UTF::Message INFO "" "-----------------------------------------------------------------------------------------------"

			# initialize
			set ::array_sta_wlan_active_flag(${sta_wlan_index}) 0
			set ::array_sta_wlan_disassociated_flag(${sta_wlan_index}) 1

			set ::catch_resp [catch "UTF::Test::ConnectAPSTA $::wlan_ap $sta_wlan_index" ::catch_msg]
			if {$::catch_resp != 0} {
				# sometimes for b band, we need more time to associate. continue to see if it is associated

				for {set retry_cnt 0} {$retry_cnt <= 5} {incr retry_cnt} {
					UTF::Message INFO "" "UTF::Test::ConnectAPSTA issue '$::catch_msg' - wait more time to associate"
					if {$retry_cnt == 2} {
						# still not associated. Try to join again
						catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) disassoc}
						UTF::Sleep 5
						catch "UTF::Test::ConnectAPSTA $::wlan_ap $sta_wlan_index"
					}
					UTF::Sleep 5
					set ::catch_resp [catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) bssid} ::catch_msg]
					if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
						continue
					}

					break
				}
			}

			if {$::ap_connect == "GO"} {
				set ifname $::array_sta_wlan_ifname(${::go_wlan})
				set ip $::array_sta_wlan_ip(${::go_wlan})
				set host_type $::array_sta_host_type(${::go_wlan})
			} else {
				set ifname $::array_sta_wlan_ifname(${sta_wlan_index})
				set ip $::array_sta_wlan_ip(${sta_wlan_index})
				set host_type $::array_sta_host_type(${sta_wlan_index})
			}

			$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) assoc

			set ::catch_resp [catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) bssid} ::catch_msg]
			if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
				incr ::error_cnt	
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error $::catch_msg
			}

			if {$host_type != "MacOS"} {
				set sta_wlan_ip ""
				regexp {inet (\d+\.\d+\.\d+\.\d+)} [$sta_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${sta_wlan_index})] match sta_wlan_ip
				#regexp {inet addr:(\d+\.\d+\.\d+\.\d+)}
				UTF::Message INFO "" "sta_wlan_ip=$sta_wlan_ip"
				if {$sta_wlan_ip == ""} {
					regexp {inet addr:(\d+\.\d+\.\d+\.\d+)} [$sta_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${sta_wlan_index})] match sta_wlan_ip
					UTF::Message INFO "" "sta_wlan_ip=$sta_wlan_ip"
				}

				if {$sta_wlan_ip != $ip} {
					$sta_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${sta_wlan_index}) $ip
					UTF::Sleep 2
				}
			}

			UTF::Sleep 15

			UTF::Message INFO "" "-------------------rssinoise Test-----------------------"
			set rssinoise_err ""
			set catch_resp [catch "UTF::Test::rssinoise $::wlan_ap $sta_wlan_index" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message INFO "" "***Failed. catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				set rssinoise_err "$catch_msg"
			}

			UTF::Message INFO "" "--------------------------------------------------------"

			# Confirm AP chanspec
			set temp [$::wlan_ap wl chanspec]
			regexp {(\S+) } $temp match wlan_chan

			if {$::wlan_chan != $wlan_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "AP chan is $wlan_chan instead of $::wlan_chan" 
			}		

			set ::chanspec_wlan ""
			UTF::Message INFO "" "A - cleared ::chanspec_wlan"

			# Confirm STA chanspec
			set temp [$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) chanspec]
			regexp {(\S+) } $temp match joined_chan

			if {$::wlan_chan != $joined_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "$::str_ap_connect joined AP chan is $joined_chan instead of $::wlan_chan" 
			}

			set ::chanspec_wlan $joined_chan
			UTF::Message INFO "" "D - ::chanspec_wlan=$::chanspec_wlan"
			set temp $::chanspec_wlan

			set ::array_sta_wlan_active_flag(${sta_wlan_index}) 1
			set ::array_sta_wlan_disassociated_flag(${sta_wlan_index}) 0

			if {$rssinoise_err != ""} {
				UTF::Message INFO "" "***Failed. rssinoise test gave error '$rssinoise_err'"
				error "$temp ($rssinoise_err)"
			}

			return $temp
		}
		
		if {$(11mc)} {
			break
		}
	}
}

proc p2p::gc_join_go {gc_wlan_index retry_cnt rvr_flag} {
	# access option array
	upvar {} {}

	if {$rvr_flag == 1} {
		set tmp_str "$::p2p_display_str Reassociate"
	} else {
		if {$retry_cnt == 0} {
			set tmp_str "$::test_type: $::gc_display_str Join $::go_display_str"
		} else {
			set tmp_str "$::test_type: $::gc_display_str Join $::go_display_str (Retry $retry_cnt)"
		}
	}
	
	UTF::Try "$tmp_str" {

		UTF::Message INFO "" "************************Func:gc_join_go***************************"

		if {$retry_cnt > 2} {
			UTF::Message INFO "" "--------------------------DEBUG START-----------------------------------"
			$::go_wlan rexec ifconfig -a
			UTF::Message INFO "" "-------------------------------------------------------------"
			$gc_wlan_index rexec ifconfig -a
			UTF::Message INFO "" "-------------------------------------------------------------"
			$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scan
			UTF::Sleep 7
			$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scanresults
			UTF::Message INFO "" "--------------------------DEBUG END-----------------------------------"
		}

		set ::chanspec_p2p ""
		
		if {$::nan2_flag} {
			set STA $::go_wlan
			set peer_sta [lindex $::list_gc_wlan_objects 0]
			set peer_macaddr $::array_sta_p2p_macaddr(${peer_sta})
			set rc [p2p::run_wl_cmd $STA "nan dp_req ucast pub_id 1 peer_mac $peer_macaddr svc_spec_info \"abcdef12345678\" qos 4 255 6 10 confirm"]
			set p2p_associated_flag 1
		} elseif {$::awdl_flag == 0} {
			if {$::array_sta_host_type(${::go_wlan}) == "MacOS" && $::use_wl_for_mac == 0} {
				# do not join using passive assoc scan
				set join_param ""
			} else {
				set join_param "-p"
			}

			UTF::Message INFO "" "Associate"

			if {$::p2p_security != "open"} {
				$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) join $::p2p_ssid $join_param imode bss amode wpa2psk
			} else {
				$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) join $::p2p_ssid $join_param
			}

			set p2p_associated_flag 0
			for {set retry_cnt 0} {$retry_cnt < 6} {incr retry_cnt} {
				UTF::Sleep 5
				set ::catch_resp [catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) bssid} ::catch_msg]
				if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
					continue
				} else {
					$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) assoc
					set p2p_associated_flag 1
					break
				}
			}

			if {$p2p_associated_flag == 0} {
				UTF::Message INFO "" "----------------------------------------------"
				UTF::Message INFO "" "Associate again"
				catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scan}
				UTF::Sleep 10
				catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scanresults}

				if {$::p2p_security != "open" && $::mac_p2p_security_flag == 0} {
					# for Linux only since mac does not support P2P security
					$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) join $::p2p_ssid $join_param imode bss amode wpa2psk
				} else {
					$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) join $::p2p_ssid $join_param
				}

				UTF::Sleep 10
				$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) assoc

				set ::catch_resp [catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) bssid} ::catch_msg]
				if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
					if {$rvr_flag == 1} {
						error "html: <font color=\"red\"><b>$::p2p_display_str is NOT associated</b></font>"
					}
					incr ::error_cnt
					UTF::Message INFO "" "::error_cnt=$::error_cnt"
					if {$rvr_flag == 1} {
						error "$::catch_msg"
					} else {
						error "$::catch_msg - Retry"
					}
				}
			}

			UTF::Sleep 10
		}
		
		set catch_resp [catch "p2p::ping 1 $gc_wlan_index" catch_msg]
		if {$catch_resp != 0} {
			# failed
			set ::catch_resp [catch {$gc_wlan_index ping $::array_sta_p2p_ip(${::go_wlan})} ::catch_msg]
			UTF::Message INFO "" "catch_resp=$::catch_resp catch_msg=$::catch_msg"

			if {[string first "No IP" $::catch_msg] != -1 || [string first "0 packet received" $::catch_msg] != -1 || [string first "No route" $::catch_msg] != -1 || [string first "ping failed" $::catch_msg] != -1} {
				if {$rvr_flag == 1} {
					error "html: <font color=\"red\"><b>$::p2p_display_str ping failed</b></font>"
				}
				
				UTF::Message INFO "" "---------------------------Debug dump for GC and GO Status-------------------------------------------"
				set catch_resp [catch {$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) status} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				set catch_resp [catch {$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) status} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Message INFO "" "----------------------------------------------------------------------"

				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "$::catch_msg - Retry"
			}
		}

		# Confirm chanspec
		# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
		for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
			set temp [$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) chanspec]
			regexp {(\S+) } $temp match gc_chan
			if {($::awdl_flag == 0 && $::nan2_flag == 0) || $::chanspec_p2p == $gc_chan} {
				break
			} else {
				UTF::Message INFO "" "$::p2p_display_str chan is $gc_chan instead of $::chanspec_p2p. Retry $retry_cnt"
			}
		}

		if {$::p2p_chan != $gc_chan} {
			if {!$::nan2_flag} {
				###########################
				# for debugging:
				$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scan
				UTF::Sleep 7
				$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) scanresults
				$gc_wlan_index scan
				UTF::Sleep 7
				$gc_wlan_index scanresults
				###########################	
			}
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "GO chan $::p2p_chan != GC chan $gc_chan" 
		}

		set ::chanspec_p2p $gc_chan

		if {$::p2p_security != "open" || $::wlan_security != "open"} {

			if {$::mac_p2p_security_flag == 1} {
				UTF::Message INFO "" "$::p2p_display_str security is not supported on Mac OS. $::p2p_display_str Open Security is used instead."
				append temp "&nbsp;&nbsp;<blink><font color=\"red\"><b>Open Security</b></font></blink>"
			} else {
				UTF::Message INFO "" "$::p2p_display_str security is $::p2p_security on Linux OS"
				append temp "&nbsp;&nbsp;<font color=\"blue\"><b>$::p2p_security Security</b></font>"
			}
		}
		
		set ::array_sta_p2p_active_flag(${gc_wlan_index}) 1
		set ::array_sta_p2p_disassociated_flag(${gc_wlan_index}) 0
		UTF::Message INFO "" "wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${gc_wlan_index})"
		UTF::Message INFO "" "p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${gc_wlan_index})"

		if {$p2p_associated_flag == 0} {
			error "html: <font color=\"red\"><b>Forced scan after 30 sec to associate</b></font>"
		}

		return "html: $temp"
	}

	p2p::free_memory_after_p2p_assoc
}

proc p2p::setup_ap_radio_channel {ap ap_chan} {
	# access option array
	upvar {} {}

	set AP2G [lindex $ap 0]
	set AP5G [lindex $ap end]
	UTF::Message LOG "" "AP2G=$AP2G" 		
	UTF::Message LOG "" "AP5G=$AP5G"		

	set ::wlan_chan $ap_chan
	set ::wlan_ap $AP2G

	if {$::soft_ap_flag == 0} {
		#---------------------------------------------------
		#----------------    5G or 2.4G AP    --------------
		#---------------------------------------------------
		if {[$AP2G band $::wlan_chan] eq "b"} {
			set ::wlan_ap $AP2G
		} else {
			set ::wlan_ap $AP5G
		}

		set title "$::wlan_ap: Setup AP Channel $::wlan_chan"
	} else {
		set title "$::wlan_ap: Setup SoftAP Channel $::wlan_chan"
	}
	
	UTF::Try "$title" {
									   
		UTF::Message INFO "" "************************Func:setup_ap_radio_channel***************************"

		UTF::Message LOG "" "::ap_connect='$::str_ap_connect' ::test_type='$::test_type' ::wlan_ap='$::wlan_ap' ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'"

		set wlan_band [$AP2G band $::wlan_chan]
		set p2p_band [$AP2G band $::p2p_chan]
		UTF::Message LOG "" "wlan_band=$wlan_band p2p_band=$p2p_band" 		

		if {$::wlan_only_flag == 0 && [string first "SameChan" $::test_type] == -1} {
			if {$wlan_band == $p2p_band} {
				# if AP and P2P channels are different, then this is a Same-Band test
				set ::test_type "SameBand"

				# check for same channel with different bandwidth
				if {$::wlan_chan != $::p2p_chan} {
					# remove the 'l','u', and '/80' to get the control channel
					set wlan_control_chan [regexp -inline {\d+} $::wlan_chan]
					set p2p_control_chan [regexp -inline {\d+} $::p2p_chan]
					
					if {$wlan_control_chan == $p2p_control_chan} {
						set ::test_type "SameChanDiffBW"
					}
				}
			} else {
				# if AP and P2P channels are different, then this is a MultiBand test
				set ::test_type "MultiBand"
			}
			
			UTF::Message LOG "" "::test_type='$::test_type'" 		
		}

		set ::p2p_chan_index [expr {$::p2p_chan_index + 1}]

		if {$::soft_ap_flag == 0} {
	
			UTF::Message INFO "" "=============================================================================="
			UTF::Message INFO "" "=============================Real AP Radio Setup=============================="
			UTF::Message INFO "" "=============================================================================="
			
			if {$AP2G == $AP5G} {
				UTF::Message INFO "" "AP has only 1 radio"
				set ap_wlname "0"
			} else {
				UTF::Message INFO "" "AP has 2 radio"
				# Get the correct wlN prefix for the Src AP
				set ap_wlname [$::wlan_ap wlname]
				regsub -all {[a-zA-Z]} $ap_wlname "" ap_wlname
			}

			UTF::Message INFO "" "ap_wlname=$ap_wlname"

			#####################################################
			# Turn off all AP radios
			#####################################################

			catch {$::wlan_ap nvram set wl0_radio=0}
			catch {$::wlan_ap nvram set wl1_radio=0}

			#####################################################
			# Turn on the correct AP radio
			#####################################################
			$::wlan_ap nvram set wl$ap_wlname\_radio=1

			$::wlan_ap nvram commit
			UTF::Sleep 1
			$::wlan_ap restart
			UTF::Sleep 5
			
			UTF::Message INFO "" "=============================================================================="
		}

		if {$ap == $(ap)} {				
			set ::roaming_src_ap $::wlan_ap
			set ::list_ap_objects [lreplace $::list_ap_objects 0 0 $::wlan_ap]				
		} else {
			set ::roaming_dst_ap $::wlan_ap
			set ::list_ap_objects [lreplace $::list_ap_objects 1 1 $::wlan_ap]							
		}
		UTF::Message LOG "" "::list_ap_objects=$::list_ap_objects"

		UTF::Message INFO "" "=============================================================================="
		UTF::Message INFO "" "==============================AP Channel Setup================================"
		UTF::Message INFO "" "=============================================================================="
		
		# With CSA, when we switch channels on the AP we can do so using a channel switch announcement.  
		# This is faster on the AP side, as it doesn’t need a down/up, and faster on the STA side since 
		# the STA gets told when to switch instead of having to roam scan.
		UTF::Test::APChanspec $::wlan_ap $::wlan_chan -usecsa 1
		UTF::Sleep 5

		UTF::Message INFO "" "--------------------------------------------------------"

		# Confirm AP chanspec
		set temp [$::wlan_ap wl chanspec]
		regexp {(\S+) } $temp match wlan_chan
		
		if {$::wlan_chan != $wlan_chan} {
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error "AP chan is $wlan_chan instead of $::wlan_chan" 
		}		

		foreach sta_wlan_index $::list_sta_wlan_objects {
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && $::array_sta_wlan_disassociated_flag(${sta_wlan_index}) == 0} {
				set ::chanspec_wlan ""
				UTF::Message INFO "" "G - cleared ::chanspec_wlan"

				# Confirm STA chanspec
				set temp [$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) chanspec]
				regexp {(\S+) } $temp match joined_chan

				if {$::wlan_chan != $joined_chan} {
					incr ::error_cnt
					UTF::Message INFO "" "::error_cnt=$::error_cnt"
					error "$::str_ap_connect joined AP chan is $joined_chan instead of $::wlan_chan" 
				}

				set ::chanspec_wlan $joined_chan
				UTF::Message INFO "" "H - ::chanspec_wlan=$::chanspec_wlan"
				set temp $::chanspec_wlan
			}
		}

		return ""
	}
}

proc p2p::setup_go_apsta {} {

	if {$::array_sta_host_type(${::go_wlan}) == "MacOS" && $::awdl_flag} {
		UTF::Message INFO "" "OSX AWDL is created by OS, therefore nothing to do for apsta"
		return
	}

	if {$::nan2_flag} {
		UTF::Message INFO "" "NAN2 does not need apsta setting"
		return
	}

	if {$::awdl_flag} {
		UTF::Try "$::test_type: Setup AWDL Master apsta" {
			UTF::Message LOG "" "Linux AWDL"

			set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) down
			UTF::Sleep 1
			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) apsta 1
			#
			catch {$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) ap 0}
			# for AWDL: mpc = 0
			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) mpc 0
			#
			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
			UTF::Sleep 3

			UTF::Message LOG "" "---------------------------------------------------"

			$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) down
			UTF::Sleep 1
			catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) ap 0}
			# for AWDL: mpc = 0
			$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) mpc 0
			#
			$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) up
			UTF::Sleep 3
		}
		return
	}

	UTF::Try "$::test_type: Setup P2P GO apsta" {

		UTF::Message INFO "" "************************Func:setup_go_apsta***************************"

		foreach gc_wlan_index $::list_gc_wlan_objects {
			$gc_wlan_index rexec ifconfig -a
		}
		if {$::p2p_load_flag} {
			$::go_wlan rexec ifconfig -a
		}
	
		if {$::array_sta_host_type(${::go_wlan}) == "MacOS" && !$::awdl_flag} {
			foreach gc_wlan_index $::list_gc_wlan_objects {
				catch {$gc_wlan_index rexec ifconfig awdl0 down}
				UTF::Sleep 1
			}
			catch {$::go_wlan rexec ifconfig awdl0 down}
			UTF::Sleep 1
		}

		set p2p_cleanup_flag 0
		foreach gc_wlan_index $::list_gc_wlan_objects {		
			if {$::array_sta_p2p_active_flag(${gc_wlan_index}) == 1 || $::p2p_cleanup_flag == 1} {
				set p2p_cleanup_flag 1
			}
		}
		
		if {$p2p_cleanup_flag == 1} {
			#####################################################
			##############      P2P Cleanup      ################
			#####################################################
			p2p::p2p_cleanup
		}

		UTF::Message INFO "" "Setup P2P GO apsta"

		if {$::array_sta_host_type(${::go_wlan}) == "MacOS"} {
			set ::catch_resp [catch {		
				$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) up
				UTF::Sleep 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
				UTF::Sleep 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) down
				UTF::Sleep 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) apsta 1
				UTF::Sleep 3
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
				UTF::Sleep 4
			} ::catch_msg]
			
			if {!$::awdl_flag} {
				foreach gc_wlan_index $::list_gc_wlan_objects {
					catch {$gc_wlan_index rexec ifconfig awdl0 down}
					UTF::Sleep 1
				}
				catch {$::go_wlan rexec ifconfig awdl0 down}
				UTF::Sleep 1
			}			
		} else {
			set ::catch_resp [catch {		
				$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) up
				UTF::Sleep 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) down
				UTF::Sleep 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) apsta 1
				$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
				UTF::Sleep 4
			} ::catch_msg]
		}

		if {$::catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Setup GO apsta failed."
			incr ::error_cnt
			UTF::Message INFO "" "::error_cnt=$::error_cnt"
			error $::catch_msg
		}

		if {$::array_sta_host_type(${::go_wlan}) == "DHD" || $::array_sta_host_type(${::go_wlan}) == "Linux" || $::array_sta_host_type(${::go_wlan}) == "Panda"} {
			UTF::Message INFO "" "Bring up GO WLAN interface $::array_sta_wlan_ip(${::go_wlan})"
			$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) $::array_sta_wlan_ip(${::go_wlan}) netmask 255.255.255.0
			$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) up
			$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})
			UTF::Sleep 2
			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
		}
		foreach gc_wlan_index $::list_gc_wlan_objects {
			if {$::array_sta_host_type(${gc_wlan_index}) == "DHD"} {
				UTF::Message INFO "" "Bring up GC WLAN interface $::array_sta_wlan_ip(${gc_wlan_index})"
				$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) $::array_sta_wlan_ip(${gc_wlan_index}) netmask 255.255.255.0
				$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) up
				$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})
				UTF::Sleep 2
				$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) up
			}
		}
		
		##################################################################
		# WARNING For Mac:
		# Do not do: sudo ifconfig en1 ip otherwise you might see
		# 	WLAN->LAN ping/throughput issue
		# Instead do:
		#	Setup the macs if as static
		#	Do not define "configure -ipaddr" in the UTF config
		#	Do not do "ifconfig en1 ip"
		##################################################################
		
		if {$::array_sta_host_type(${::go_wlan}) == "MacOS"} {
			UTF::Message INFO "" "Bring up MacOS GO WLAN interface $::array_sta_wlan_ip(${::go_wlan})"
			#$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) $::array_sta_wlan_ip(${::go_wlan}) netmask 255.255.255.0
			$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan}) up
			$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})
			UTF::Sleep 2
			$::go_wlan wl -i $::array_sta_wlan_ifname(${::go_wlan}) up
		}
		foreach gc_wlan_index $::list_gc_wlan_objects {
			if {$::array_sta_host_type(${gc_wlan_index}) == "MacOS"} {
				UTF::Message INFO "" "Bring up MacOS GC WLAN interface $::array_sta_wlan_ip(${gc_wlan_index})"
				#$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) $::array_sta_wlan_ip(${gc_wlan_index}) netmask 255.255.255.0
				$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index}) up
				$gc_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${gc_wlan_index})
				UTF::Sleep 2
				$gc_wlan_index wl -i $::array_sta_wlan_ifname(${gc_wlan_index}) up
			}
		}
	}
}

proc p2p::connection_test {} {
	# access option array
	upvar {} {}

	if {$::p2p_load_flag && $::array_sta_host_type(${::go_wlan}) == "MacOS" && $::awdl_flag} {
		# For AWDL OSX
		UTF::Try "Connection Test" {
			UTF::Message INFO "" "************************Func:connection_test***************************"

			set gc_wlan [lindex $::list_gc_wlan_objects 0]

			foreach STA "$gc_wlan $::go_wlan" {
				$STA rexec ifconfig -a
				set catch_resp [catch "$STA rexec apple80211 -awdl | grep -i \"awdl is enabled\"" catch_msg]
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				set catch_resp [catch "$STA rexec ps -ef | grep \"dns-sd\"" catch_msg]					
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			}

			set catch_resp [catch "p2p::ping_test" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		}
		
		return		
	}

	# For Non AWDL MacOS
	
	set ::err_msg ""
	
	UTF::Try "Connection Test" {
		UTF::Message INFO "" "************************Func:connection_test***************************"

		p2p::setup_list_active_interface_objects

		UTF::Message INFO "" "-------------------endpoint-----------------------"
		catch {$::tg_wlan rexec ifconfig -a}
		foreach sta_wlan_index $::list_sta_wlan_objects {
			if {$sta_wlan_index == $::go_wlan} {
				UTF::Message INFO "" "---------------------GO $sta_wlan_index---------------------"
			} else {
				UTF::Message INFO "" "---------------------STA $sta_wlan_index---------------------"
			}
			catch {$sta_wlan_index rexec ifconfig -a}
		}

		set go_flag 0
		foreach sta_wlan_index $::list_sta_wlan_objects {
			if {$sta_wlan_index == $::go_wlan} {
				UTF::Message INFO "" "==================================GO $sta_wlan_index========================================"
			} else {
				UTF::Message INFO "" "==================================STA $sta_wlan_index========================================"
			}
			
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && [string first "Direct" $::test_type] == -1} {
				UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check WLAN association----------------------------"
				set ::catch_resp [catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) bssid} ::catch_msg]
				if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
					set ::array_sta_wlan_disassociated_flag(${sta_wlan_index}) 1
					if {![regexp -nocase {WLAN is NOT associated} $::err_msg]} {
						set ::err_msg [concat $::err_msg "(WLAN is NOT associated)"]
					}
					UTF::Message ERROR "" "$::err_msg"
				} else {
					UTF::Message INFO "" "PASS. WLAN is associated"

					UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check WLAN channel----------------------------"
					set temp [$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) chanspec]
					regexp {(\S+) } $temp match joined_chan

					if {$::chanspec_wlan != $joined_chan} {
							set ::err_msg [concat $::err_msg "($::str_ap_connect joined AP chan is $joined_chan instead of $::chanspec_wlan)"]
							UTF::Message ERROR "" "$::err_msg"
					} else {
						UTF::Message INFO "" "PASS. $::wlan_display_str channel is $::chanspec_wlan"
					}
				}
			}

			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::p2p_load_flag} {
				UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check $::p2p_display_str association----------------------------"
				set ::catch_resp [catch {$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) bssid} ::catch_msg]
				if {[string first "Not Associated" $::catch_msg] != -1 || [string first "00:00:00:00:00:00" $::catch_msg] != -1} {
					set ::array_sta_p2p_disassociated_flag(${sta_wlan_index}) 1
					if {![regexp -nocase {$::p2p_display_str is NOT associated} $::err_msg]} {
						set ::err_msg [concat $::err_msg "($::p2p_display_str is NOT associated)"]
					}
					UTF::Message ERROR "" "$::err_msg"
				} else {
					UTF::Message INFO "" "PASS. $::p2p_display_str is associated"

					UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check $::p2p_display_str channel----------------------------"
					# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
					for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
						set temp [$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) chanspec]
						regexp {(\S+) } $temp match gc_chan
						if {($::awdl_flag == 0 && $::nan2_flag == 0) || $::chanspec_p2p == $gc_chan} {
							break
						} else {
							UTF::Message INFO "" "$::p2p_display_str chan is $gc_chan instead of $::chanspec_p2p. Retry $retry_cnt"
						}
					}

					if {$::chanspec_p2p != $gc_chan} {
						set ::err_msg [concat $::err_msg "($::p2p_display_str chan is $gc_chan instead of $::chanspec_p2p)"]
						UTF::Message ERROR "" "$::err_msg"
					} else {
						UTF::Message INFO "" "PASS. $::p2p_display_str channel is $::chanspec_p2p"
					}
				}
			}

			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && [string first "Direct" $::test_type] == -1} {
				UTF::Message INFO "" "=========================================================================="
				UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check WLAN----------------------------"
				$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) status
				if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
					catch {
						$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) scan
						UTF::Sleep 7
						$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) scanresults
					}
				}
			}

			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::p2p_load_flag} {
				UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check $::p2p_display_str----------------------------"
				# For AWDL, there is channel switching between AP & AWDL, therefore retry is needed to catch that AWDL channel
				for {set retry_cnt 1} {$retry_cnt <= 10} {incr retry_cnt} {
					set catch_resp [catch {$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) status} catch_msg]
					if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) != 0} {
						break
					}
					regexp {Channel: (\S+)} $catch_msg match gc_chan
					UTF::Message INFO "" "gc_chan=$gc_chan"
					if {($::awdl_flag == 0 && $::nan2_flag == 0) || $::chanspec_p2p == $gc_chan} {
						break
					} else {
						UTF::Message INFO "" "$::p2p_display_str chan is $gc_chan instead of $::chanspec_p2p. Retry $retry_cnt"
					}
				}
				# For AWDL, scan is not valid
				if {$::awdl_flag == 0 && $::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
					catch {
						$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) scan
						UTF::Sleep 7
						$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) scanresults
					}
				}
			}
			
			UTF::Message INFO "" "=========================================================================="
			UTF::Message INFO "" "----------------------------STA $sta_wlan_index Check ifconfig----------------------------"
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::p2p_load_flag} {
				catch {$sta_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${sta_wlan_index})}
				UTF::Sleep 1
			}
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
				catch {$sta_wlan_index rexec ifconfig $::array_sta_wlan_ifname(${sta_wlan_index})}
				UTF::Sleep 1
			}
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::p2p_load_flag && $go_flag == 0} {
				set go_flag 1
				catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})}
				UTF::Sleep 1
				if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
					catch {$::go_wlan rexec ifconfig $::array_sta_wlan_ifname(${::go_wlan})}
					UTF::Sleep 1
				}
			}
		}

		UTF::Message INFO "" "=========================================================================="
		UTF::Message INFO "" "----------------------------Check ping----------------------------"
		set catch_resp [catch "p2p::ping_test" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			if {$::err_msg == ""} {
				set ::err_msg "$catch_msg"
			} else {
				set ::err_msg [concat $::err_msg "$catch_msg"]
			}
			UTF::Message ERROR "" "$::err_msg"
		}
		
		if {$::err_msg == ""} {
			if {$catch_msg != ""} {
				return "html: <font color=\"blue\"><b>$catch_msg</b></font>"
			}
			return ""
		} else {
			error "html: <font color=\"red\"><b>$::err_msg</b></font>"
		}
	}
}

proc p2p::start_pre_throughputs {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:start_pre_throughputs***************************"

	set wlan_active_flag 0
	set p2p_active_flag 0
	set wlan_disassociated_flag 0
	set p2p_disassociated_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
			set wlan_disassociated_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is disassociated"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
		if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
			set p2p_disassociated_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is disassociated"
		}
	}

	UTF::Message INFO "" "wlan_active_flag=$wlan_active_flag wlan_disassociated_flag=$wlan_disassociated_flag"
	UTF::Message INFO "" "p2p_active_flag=$p2p_active_flag p2p_disassociated_flag=$p2p_disassociated_flag"

	set stream_cnt 0
	foreach stream_index $::streams_name_list {

		incr stream_cnt

		if {$::array_streams_type(${stream_index}) == "BT"} {
			UTF::Message INFO "" "stream_index='$stream_index'. Skipping BT"
			continue
		}

		if {$::array_streams_type(${stream_index}) == "WLAN" && $wlan_active_flag == 1 && $wlan_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${stream_index}) 1
			UTF::Message INFO "" "WLAN is disassociated. Skip running iperf."
			continue
		}

		if {$::array_streams_type(${stream_index}) == "P2P" && $p2p_active_flag == 1 && $p2p_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${stream_index}) 1
			UTF::Message INFO "" "$::p2p_display_str is disassociated. Skip running iperf."
			continue
		}

		if {$stream_cnt == 1} {
			if {$wlan_active_flag == 1 && !($::awdl_flag && $::use_wl_for_mac == 0)} {
				foreach STA $::list_sta_wlan_objects {
					UTF::Message INFO "" "************************STA=$STA***************************"
					set catch_resp [catch {$STA wl PM} catch_msg]
					# check for panic, trap, assert message
					if {[info exists ::UTF::panic]} {
						set ::panic_msg "($::UTF::panic)"
						UTF::Message INFO "J" "::UTF::panic=$::panic_msg"
						set ::halt_test_err $::panic_msg
						incr ::error_cnt
						error "$::panic_msg. Halting tests!"
					} elseif {[regexp -nocase {driver adapter not found} $catch_msg] || [regexp -nocase {is not a valid wl driver} $catch_msg]} {
						incr ::error_cnt
						UTF::Message INFO "" "***Fail. Driver is crashed. Do not continue the test."
						set ::halt_test_err $catch_msg
						# set flag to dump socram and FW
						set ::debug2_flag 1
						error "$catch_msg. Halting tests!"
					}				
					if {$catch_msg != $(pm_mode)} {
#Kevin
#						error "WLAN PM mode is not $(pm_mode)" 
					}
				}
			}
			if {$p2p_active_flag == 1} {
				# P2P PM mode is not for GO
				foreach STA $::list_gc_wlan_objects {
					UTF::Message INFO "" "************************STA=$STA***************************"
					set catch_resp [catch {$STA wl -i $::array_sta_p2p_ifname(${STA}) PM} catch_msg]
					if {$(pm_mode) != "" && $catch_msg != $(pm_mode)} {
						if {$::awdl_flag && $::use_wl_for_mac == 0} {
							UTF::Message WARN "" "$::p2p_display_str PM mode is not $(pm_mode)"
						} else {
							error "$::p2p_display_str PM mode is not $(pm_mode)" 
						}
					}
				}
			}
		}

		UTF::Message INFO "" "$::array_streams_src(${stream_index}) $::array_streams_type(${stream_index}) $::array_streams_direction(${stream_index}):"

		set macos_ipv6_flag 0
		if {$::array_streams_src_host_type(${stream_index}) == "MacOS"} {
			if {$::use_wl_for_mac == 0} {
				set macos_ipv6_flag 1
				set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
				UTF::Message INFO "" "$stream_sta_obj: MacOS AWDL client"
			}
		}

		# "-t 2" is needed because there is TCP slow start with P2P throughput with APCh=36/80 P2PCh=11u

		set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
		set iperf_name $::array_sta_iperf_name(${stream_sta_obj})

		if {$::array_streams_tos(${stream_index}) == "TCP"} {
			if {$::array_streams_type(${stream_index}) == "P2P" && $macos_ipv6_flag} {
				set ::array_streams_fd_tx(${stream_index}) [$::array_streams_src(${stream_index}) rpopen $iperf_name -V -A -c $::array_streams_dst_ipv6_macaddr(${stream_index}) -w $::array_streams_iperf_tcpwin_src(${stream_index}) -t 2 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
			} else {
				set ::array_streams_fd_tx(${stream_index}) [$::array_streams_src(${stream_index}) rpopen $iperf_name -c $::array_streams_dst_ip(${stream_index}) -e -w $::array_streams_iperf_tcpwin_src(${stream_index}) -t 2 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
			}
		} else {
			# "-b 400M" is picked to flood the port to avoid slow start. Doing Video test at 20M is not good enough to flood the port
			if {$::array_streams_type(${stream_index}) == "P2P" && $macos_ipv6_flag} {
				set ::array_streams_fd_tx(${stream_index}) [$::array_streams_src(${stream_index}) rpopen $iperf_name -V -A -c $::array_streams_dst_ipv6_macaddr(${stream_index}) -u -w $::array_streams_iperf_tcpwin_src(${stream_index}) -b 400M -t 2 -fm -i $::perfint -p $::curr_iperf_port]
			} else {
				set ::array_streams_fd_tx(${stream_index}) [$::array_streams_src(${stream_index}) rpopen $iperf_name -c $::array_streams_dst_ip(${stream_index}) -u -e -w $::array_streams_iperf_tcpwin_src(${stream_index}) -b 400M -t 2 -fm -i $::perfint -p $::curr_iperf_port]
			}
		}
		fconfigure $::array_streams_fd_tx(${stream_index}) -blocking 0
		fileevent $::array_streams_fd_tx(${stream_index}) readable {set ::p2p_utils_reading READY}
		
		incr ::curr_iperf_port
	}

	set stream_ids [p2p::get_stream_ids]
	
	if {$stream_ids != ""} {
		# using 5 sec timeout. If data is ready sooner, then it will not wait this long and comes back immediately
		p2p::collect_rpopen_data 5 $stream_ids resp1 "" resp2

		p2p::close_iperf_traffic
	}
}

proc p2p::get_stream_ids {} {

	set stream_ids ""
	foreach stream_index $::streams_name_list {
		catch {append stream_ids "$::array_streams_fdname_tx(${stream_index}) $::array_streams_fd_tx(${stream_index}) $::array_streams_fdname_rx(${stream_index}) $::array_streams_fd_rx(${stream_index}) "}
	}
	
	set stream_ids [string trim $stream_ids]

	return $stream_ids
}

proc p2p::start_all_client_streams {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:start_all_client_streams***************************"

	set wlan_active_flag 0
	set p2p_active_flag 0
	set wlan_disassociated_flag 0
	set p2p_disassociated_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
			set wlan_disassociated_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is disassociated"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
		if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
			set p2p_disassociated_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is disassociated"
		}
	}

	UTF::Message INFO "" "wlan_active_flag=$wlan_active_flag wlan_disassociated_flag=$wlan_disassociated_flag"
	UTF::Message INFO "" "p2p_active_flag=$p2p_active_flag p2p_disassociated_flag=$p2p_disassociated_flag"

	if {$::bt_test_flag} {
		#####################################################
		##########   Start BT iTune wav Play    #############
		#####################################################
		p2p::bt_itune_play
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}
	}

	set ::streams_total_error ""
	catch {unset ::array_streams_error}

	foreach stream_index $::streams_name_list {

		#####################################################
		##########     Run Stream Throughput    #############
		#####################################################
		UTF::Message INFO "" "************************************************throughput stream_cnt=$::array_streams_iperf_cnt(${stream_index})***************************************************"

		set ::array_streams_error(${stream_index}) ""

		set ::curr_stream_time 		$::array_streams_time_duration(${stream_index})
		set ::curr_udp_packet_size 	$::array_streams_udp_packet_size(${stream_index}) 
		set ::curr_udp_bandwidth 	$::array_streams_udp_bandwidth(${stream_index})

		UTF::Message INFO "" "::array_streams_type(${stream_index})=$::array_streams_type(${stream_index})"
		UTF::Message INFO "" "::array_streams_direction(${stream_index})=$::array_streams_direction(${stream_index})"
		UTF::Message INFO "" "::array_streams_tos(${stream_index})=$::array_streams_tos(${stream_index})"
		UTF::Message INFO "" "::array_streams_start_time(${stream_index})=$::array_streams_start_time(${stream_index})"
		UTF::Message INFO "" "::array_streams_time_duration(${stream_index})=$::array_streams_time_duration(${stream_index})"
		UTF::Message INFO "" "::array_streams_src(${stream_index})=$::array_streams_src(${stream_index})"
		UTF::Message INFO "" "::array_streams_src_host_type(${stream_index})=$::array_streams_src_host_type(${stream_index})"
		UTF::Message INFO "" "::array_streams_src_ifname(${stream_index})=$::array_streams_src_ifname(${stream_index})"
		UTF::Message INFO "" "::array_streams_src_ip(${stream_index})=$::array_streams_src_ip(${stream_index})"
		UTF::Message INFO "" "::array_streams_src_ipv6_macaddr(${stream_index})=$::array_streams_src_ipv6_macaddr(${stream_index})"
		UTF::Message INFO "" "::array_streams_dst(${stream_index})=$::array_streams_dst(${stream_index})"
		UTF::Message INFO "" "::array_streams_dst_host_type(${stream_index})=$::array_streams_dst_host_type(${stream_index})"
		UTF::Message INFO "" "::array_streams_dst_ifname(${stream_index})=$::array_streams_dst_ifname(${stream_index})"
		UTF::Message INFO "" "::array_streams_dst_ip(${stream_index})=$::array_streams_dst_ip(${stream_index})"
		UTF::Message INFO "" "::array_streams_dst_ipv6_macaddr(${stream_index})=$::array_streams_dst_ipv6_macaddr(${stream_index})"		
		UTF::Message INFO "" "::array_streams_iperf_tos(${stream_index})=$::array_streams_iperf_tos(${stream_index})"
		UTF::Message INFO "" "::array_streams_throughput_scale(${stream_index})=$::array_streams_throughput_scale(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_packet_size(${stream_index})=$::array_streams_udp_packet_size(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_bandwidth(${stream_index})=$::array_streams_udp_bandwidth(${stream_index})"
		UTF::Message INFO "" "::array_streams_iperf_tcpwin_src(${stream_index})=$::array_streams_iperf_tcpwin_src(${stream_index})"
		UTF::Message INFO "" "::array_streams_file_name(${stream_index})='$::array_streams_file_name(${stream_index})'"
		UTF::Message INFO "" "::array_streams_plot_name_lt(${stream_index})='$::array_streams_plot_name_lt(${stream_index})'"
		UTF::Message INFO "" "::array_streams_plot_name_pt(${stream_index})='$::array_streams_plot_name_pt(${stream_index})'"
		UTF::Message INFO "" "::array_streams_plot_minmax_name_lt(${stream_index})='$::array_streams_plot_minmax_name_lt(${stream_index})'"
		UTF::Message INFO "" "================================================================"

		if {!$(no_wl_dump) && $::array_streams_iperf_cnt(${stream_index}) == 1 && $::pktq_stats_flag == 1} {
			UTF::Message INFO "" "************************QoS pktq_stats (reset values before running first stream)***************************"
			foreach STA "$::list_active_interface_objects" {
				catch {$STA wl pktq_stats}
			}
		}
		UTF::Message INFO "" "****************************************************************"				

		# delay before starting stream?
		if {$::array_streams_iperf_cnt(${stream_index}) == 1 && $::array_streams_start_time(${stream_index}) > 0} {
			# this is the 1st stream delay
			set delay_stream_secs $::array_streams_start_time(${stream_index})		
			UTF::Message INFO "" "stream delay=$::array_streams_start_time(${stream_index})"
			UTF::Sleep $delay_stream_secs		
		} elseif {$::array_streams_iperf_cnt(${stream_index}) > 1 && $::array_streams_start_time(${stream_index}) > 0} {
			# this is not the 1st stream delay.
			# delay is from the 1st stream. subtract time past since 1st stream.

			# find the first stream time
			set first_stream_name [lindex $::streams_name_list 0]
			UTF::Message INFO "" "first_stream_name=$first_stream_name"
			set first_stream_time_secs $::array_streams_start_stream_time_secs($first_stream_name)
			UTF::Message INFO "" "first_stream_time_secs=$first_stream_time_secs"

			set curr_time_secs [clock clicks -milliseconds]
			set curr_time_secs [format "%2.3f" [expr {$curr_time_secs / 1000.0}]]
			set time_elapsed_secs [expr {$curr_time_secs - $first_stream_time_secs}]
			UTF::Message INFO "" "curr_time_secs - first_stream_time_secs=time_elapsed_secs =>> $curr_time_secs - $first_stream_time_secs=$time_elapsed_secs"
			set delay_stream_secs [expr {$::array_streams_start_time(${stream_index}) - $time_elapsed_secs}]
			set delay_stream_secs [format "%2.3f" $delay_stream_secs]
			UTF::Message INFO "" "::array_streams_start_time(${stream_index}) - time_elapsed_secs=delay_stream_secs =>> $::array_streams_start_time(${stream_index}) - $time_elapsed_secs=$delay_stream_secs"
			UTF::Message INFO "" "actual stream delay=$delay_stream_secs"
			UTF::Sleep $delay_stream_secs		
		}

		# how long all streams will run?
		if {[expr {$::array_streams_start_time(${stream_index}) + $::array_streams_time_duration(${stream_index})}] > $::qos_streams_total_time} {
			UTF::Message INFO "" "::array_streams_start_time(${stream_index}) + ::array_streams_time_duration(${stream_index}) > ::qos_streams_total_time"
			UTF::Message INFO "" "$::array_streams_start_time(${stream_index}) + $::array_streams_time_duration(${stream_index}) > $::qos_streams_total_time"
			set ::qos_streams_total_time [expr {$::array_streams_start_time(${stream_index}) + $::array_streams_time_duration(${stream_index})}]
			UTF::Message INFO "" "qos_streams_total_time=$::qos_streams_total_time"
		} else {
			UTF::Message INFO "" "::array_streams_start_time(${stream_index}) + ::array_streams_time_duration(${stream_index}) <= ::qos_streams_total_time"
			UTF::Message INFO "" "$::array_streams_start_time(${stream_index}) + $::array_streams_time_duration(${stream_index}) <= $::qos_streams_total_time"
		}

		UTF::Message INFO "" "Start the iperf"

		# Timestamp of the current stream iperf starting is put here because of "disconnect" and stream getting
		# skipped still needs a timestamp
		set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
		set parts [split $time_ms "."]
		set round_down [lindex $parts 0]
		set fraction [lindex $parts 1]
		set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
		set current_time "$current_time.$fraction"
		UTF::Message INFO "" "timestamp1=$current_time"
		set ::array_streams_start_stream_time_secs(${stream_index}) "$time_ms"
		UTF::Message INFO "" "::array_streams_start_stream_time_secs(${stream_index})=$::array_streams_start_stream_time_secs(${stream_index})"

		if {$::array_streams_type(${stream_index}) == "WLAN" && $wlan_active_flag == 1 && $wlan_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${stream_index}) 1
			UTF::Message INFO "" "Skip WLAN iperf since it is disassociated"
			continue
		}

		if {$::array_streams_type(${stream_index}) == "P2P" && $p2p_active_flag == 1 && $p2p_disassociated_flag == 1} {
			set ::array_streams_throughput_skipped_flag(${stream_index}) 1
			UTF::Message INFO "" "Skip $::p2p_display_str iperf since it is disassociated"
			continue
		}

		if {$::array_streams_type(${stream_index}) == "BT"} {
			p2p::bt_start_throughput_measurement $::array_streams_src(${stream_index}) $stream_index $::array_streams_time_duration(${stream_index})
		} else {		
			set ::catch_resp [catch {p2p::start_traffic $::array_streams_src(${stream_index}) $::array_streams_dst(${stream_index}) $::array_streams_dst_ip(${stream_index}) $stream_index $::array_streams_tos(${stream_index}) $::array_streams_iperf_tos(${stream_index}) $::array_streams_throughput_scale(${stream_index}) $::array_streams_iperf_tcpwin_src(${stream_index})} ::catch_msg]
			if {$::catch_resp != 0} {
				UTF::Message INFO "" "***Failed. catch_resp=$::catch_resp catch_msg=$::catch_msg"
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
			}
		}
	}
	
	if {$::error_cnt > 0} {

		UTF::Message INFO "" "start_all_client_streams failed"

		UTF::Message INFO "" "************************post_perf_hook***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		p2p::process_perf_hook post_perf_hook 0 0

		set ::connection_test_flag 1

		error "Start iperf clients failed"							
	} elseif {!$(no_wl_dump)} {
		set ::iperf_running_flag 1
		
		UTF::Message LOG "" "init the beacon rate vars"

		foreach STA "$::list_active_interface_objects" {

			foreach sta_wlan_index $::list_sta_wlan_objects {
				if {[string compare $STA $sta_wlan_index] == 0} {
					set str_interface "$::array_sta_wlan_ifname(${sta_wlan_index})"
					break
				} elseif {[string compare $STA $::array_sta_p2p(${sta_wlan_index})] == 0} {
					set str_interface "$::array_sta_p2p_ifname(${sta_wlan_index})"
					break
				}
			}

			set catch_resp [catch {$STA wl -i $str_interface counters} catch_msg]
			if {$catch_resp == 0} {
				set bcnrate ""
				regexp {rxbeaconmbss\s([0-9]+)} $catch_msg - bcnrate
				if {$bcnrate != ""} {
					set time_ms [clock clicks -milliseconds]
					set ::array_streams_last_BeaconRate_time(${STA}) $time_ms
					set ::array_streams_last_BeaconRate(${STA}) $bcnrate
					UTF::Message INFO "" "Time -> '$::array_streams_last_BeaconRate_time(${STA})=$::array_streams_last_BeaconRate_time(${STA}) ms'"
					UTF::Message INFO "" "Beacons -> '$::array_streams_last_BeaconRate(${STA})=$::array_streams_last_BeaconRate(${STA})'"
				} else {
					UTF::Message LOG "" "Error: bcnrate is not found in '$catch_msg'. Continue"
				}
			}
		}
	}
}

proc p2p::perf_hook_remove_duplicates {items} {

	if {$::roaming_test_flag || $::scan_test_flag || $::escan_test_flag} {
		# Do not use scansuppress for Roaming test or the Scan/eScan test
		UTF::Message INFO "" "Do not use scansuppress"
		regsub -all -nocase {\{\s*\S+\s+wl\s+scansuppress\s+1\s*\}} $items "" items
	}
				
	set items [string trim $items]
	regsub -all { {2,}} $items { } items 

	while { 1 } {
	
		set repeat_flag 0

		# check for duplicates
		foreach item $items {

			set idxs [lsearch -exact -all $items $item]
			
			if {[llength $idxs] > 1} {
				UTF::Message INFO "" "Found duplicate item for '$item'"
				# remove the 1st duplicate item
				set idx [lindex $idxs 0]
				set items [lreplace $items $idx $idx ""]	
				# remove empty element
				regsub -all {\{\}} $items "" items
				regsub -all { {2,}} $items { } items 
				set items [string trim $items]
				set repeat_flag 1
			}
		}
		
		if {$repeat_flag == 0} {
			break
		}
	}

	return $items
}

proc p2p::setup_perf_hook {} {

	UTF::Message INFO "" "************************Func:setup_perf_hook***************************"

	if {$::p2p_load_flag && $::array_sta_host_type(${::go_wlan}) == "MacOS" && $::awdl_flag} {
		# skip for AWDL OSX
		return
	}
	
	set test_pre_perf_sta "{%S wl ampdu_clear_dump}"
	set test_pre_perf_ap "{%S wl ampdu_clear_dump}"
	set test_post_perf_sta "{%S wl dump ampdu} {%S wl rate} {%S wl assoc} {%S wl rssi} {%S wl nrate} {%S wl counters}"
	if {$::roaming_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl bssid}"]
	} else {
		set test_pre_perf_sta [concat $test_pre_perf_sta " {%S wl roam_trigger -100 all}"]
	}
	if {$::scan_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl scan}"]
	}
	if {$::escan_test_flag} {
		set test_post_perf_sta [concat $test_post_perf_sta " {%S wl wl_escanresults}"]
	}
	set test_post_perf_ap "{%S wl dump ampdu} {%S wl sta_info} {%S wl rate} {%S wl rssi} {%S wl nrate} {%S wl counters}"

	# add the above test script pre and post commands to the beginning of config pre_perf_hook and post_perf_hook

	UTF::Message INFO "" "-----AP PRE------"
	foreach item $::list_ap_objects {
		set value [$item cget -pre_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item pre_perf_hook='$value'"

		set value [concat $test_pre_perf_ap $value]
		set value [p2p::perf_hook_remove_duplicates $value]
		$item configure -pre_perf_hook $value
		
		set value [$item cget -pre_perf_hook]
		UTF::Message INFO "" "After:  $item pre_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----STA PRE------"
	foreach item "$::list_existing_interface_objects" {
		set value [$item cget -pre_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item pre_perf_hook='$value'"

		set value [concat $test_pre_perf_sta $value]
		set value [p2p::perf_hook_remove_duplicates $value]
		$item configure -pre_perf_hook $value
		
		set value [$item cget -pre_perf_hook]
		UTF::Message INFO "" "After:  $item pre_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----AP POST------"
	foreach item $::list_ap_objects {
		set value [$item cget -post_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item post_perf_hook='$value'"

		set value [concat $test_post_perf_ap $value]
		set value [p2p::perf_hook_remove_duplicates $value]
		$item configure -post_perf_hook $value
		
		set value [$item cget -post_perf_hook]
		UTF::Message INFO "" "After:  $item post_perf_hook='$value'"
	}

	UTF::Message INFO "" "-----STA POST------"
	foreach item "$::list_existing_interface_objects" {
		set value [$item cget -post_perf_hook]
		if {$value == ""} {
			break
		}
		UTF::Message INFO "" "Before: $item post_perf_hook='$value'"
		
		set value [concat $test_post_perf_sta $value]
		set value [p2p::perf_hook_remove_duplicates $value]
		$item configure -post_perf_hook $value
		
		set value [$item cget -post_perf_hook]
		UTF::Message INFO "" "After:  $item post_perf_hook='$value'"
	}
}

proc p2p::parse_nrate {msg} {

	set nrate ""
	set nss ""
	set legacy_rate ""

	# samples:
	# mcs index 1 stf mode 0 fixed
	# vht mcs 9 Nss 3 Tx Exp 0 ldpc sgi auto

	if {[regexp {mcs\s*index\s*(\d+)} $msg - nrate]} {
		UTF::Message INFO "" "mcs nrate = $nrate"
	} elseif {[regexp {legacy\s*rate\s*(\d+)} $msg - nrate]} {
		UTF::Message INFO "" "legacy rate = $nrate"
    	set nrate "legacy $nrate"
    } elseif {[regexp -nocase {vht\s*mcs\s*(\d+)\s*Nss\s*(\d+)} $msg - nrate nss]} {
    	set nrate "$nss\x$nrate"
		UTF::Message INFO "" "vht rate = $nrate"
	}
	
	# put braket around the value otherwise "0x3" will become "3"
	set nrate "\[$nrate\]"
	
	return $nrate
}

proc p2p::graph_map_nrate {msg} {

	set new_nrate ""
	set nrate ""
	set nss ""

	# remove the brakets around the nrate value
	regsub -all {\[} $msg "" msg
	regsub -all {\]} $msg "" msg
	
	if {[regexp -nocase {(\d+)x(\d+)} $msg - nss nrate]} {
		# vht rate
		set new_nrate [expr {[expr {[expr {$nss - 1}] * 10}] + $nrate + 24}]
		UTF::Message INFO "" "vht nrate $nss\x$nrate -> $new_nrate"
	} elseif {[regexp {legacy (\d+)} $msg - legacy_rate]} {

		switch $legacy_rate {

			54 {
				set new_nrate "-1"
			}

			48 {
				set new_nrate "-2"
			}

			36 {
				set new_nrate "-3"
			}

			24 {
				set new_nrate "-4"
			}

			18 {
				set new_nrate "-5"
			}

			12 {
				set new_nrate "-6"
			}

			11 {
				set new_nrate "-7"
			}

			9 {
				set new_nrate "-8"
			}

			6 {
				set new_nrate "-9"
			}

			5.5 {
				set new_nrate "-10"
			}

			2 {
				set new_nrate "-11"
			}

			1 {
				set new_nrate "-12"
			}
		}

		# legacy rate
		UTF::Message INFO "" "legacy rate $legacy_rate -> $new_nrate"

    } else {
		set new_nrate $msg
		UTF::Message INFO "" "rate $msg -> $new_nrate"
	}

	return $new_nrate
}

proc p2p::process_perf_hook {perf_hook throughput_flag write_flag} {
	# access option array
	upvar {} {}

	if {$perf_hook == "pre_perf_hook"} {

		if {$::rvr_test_flag == 0} {
			set ::saved_hook_start_timestamp ""
			UTF::Message INFO "" "Cleared ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"
		}
		
		###################################################################
		# Initialize CSV Throughput Variables
		###################################################################
		p2p::array_init_csv_data 0 1

	} elseif {$perf_hook == "post_perf_hook"} {
		###################################################################
		# Initialize CSV Data Variables
		###################################################################
		p2p::array_init_csv_data 1 0

		set time_ms [clock clicks -milliseconds]
		UTF::Message INFO "" "time_ms=$time_ms"

		if {$::saved_hook_start_timestamp == ""} {
			set ::saved_hook_start_timestamp $time_ms
			UTF::Message INFO "" "Set ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"
		}

		set diff_timestamp_ms [expr {$time_ms - $::saved_hook_start_timestamp}]
		set diff_timestamp_sec [format "%2.0f" [expr {$diff_timestamp_ms / 1000.0}]]
		set ::csv_data_BaseTime [clock format [expr {$::base_timestamp_tick + $diff_timestamp_sec}] -format "%M:%S"]
		
		set time_sec [format "%2.3f" [expr {$time_ms / 1000.0}]]
		UTF::Message INFO "" "time_sec=$time_sec"
		set parts [split $time_sec "."]
		set round_down [lindex $parts 0]
		UTF::Message INFO "" "time_sec round_down=$round_down"
		set fraction [lindex $parts 1]
		UTF::Message INFO "" "time_sec fraction=$fraction"

		set timestamp [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
		set timestamp "$timestamp.$fraction"

		set ::csv_data_Time "\[$timestamp\]"
		
		UTF::Message INFO "" "------------------------------$timestamp-----------------------------------"
	}

	UTF::Message INFO "" "============================================================================================================"
	UTF::Message INFO "" "************************Func:process_perf_hook***************************"

	UTF::Message INFO "" "perf_hook=$perf_hook throughput_flag=$throughput_flag"

	foreach target "$::wlan_ap $::list_existing_interface_objects" {
		UTF::Message INFO "" "##############################target=$target###################################"

		set wlan_active_flag 0
		set p2p_active_flag 0
		set wlan_disassociated_flag 0
		set p2p_disassociated_flag 0
		foreach sta_wlan_index $::list_sta_wlan_objects {
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
				set wlan_active_flag 1
				UTF::Message INFO "" "$sta_wlan_index WLAN is active"
			}
			if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
				set wlan_disassociated_flag 1
				UTF::Message INFO "" "$sta_wlan_index WLAN is disassociated"
			}
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
				set p2p_active_flag 1
				UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
			}
			if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
				set p2p_disassociated_flag 1
				UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is disassociated"
			}
		}

		UTF::Message INFO "" "wlan_active_flag=$wlan_active_flag wlan_disassociated_flag=$wlan_disassociated_flag"
		UTF::Message INFO "" "p2p_active_flag=$p2p_active_flag p2p_disassociated_flag=$p2p_disassociated_flag"

		set str_interface ""
		set wlan_sta_flag 0
		set p2p_sta_flag 0
		set curr_sta_wlan_index -1		
		if {[string compare $target $::wlan_ap] != 0} {
			foreach sta_wlan_index $::list_sta_wlan_objects {
				if {[string compare $target $sta_wlan_index] == 0} {
					#UTF::Message INFO "" "WLAN STA $target"
					set wlan_sta_flag 1
					set str_interface "-i $::array_sta_wlan_ifname(${sta_wlan_index})"
					UTF::Message INFO "" "wlan_ifname(${sta_wlan_index})=$str_interface wlan_sta_flag=$wlan_sta_flag p2p_sta_flag=$p2p_sta_flag"
					set curr_sta_wlan_index $sta_wlan_index
					break
				} elseif {[string compare $target $::array_sta_p2p(${sta_wlan_index})] == 0} {
					#UTF::Message INFO "" "$::p2p_display_str STA $target"
					set p2p_sta_flag 1
					set str_interface "-i $::array_sta_p2p_ifname(${sta_wlan_index})"
					UTF::Message INFO "" "p2p_ifname(${sta_wlan_index})=$str_interface wlan_sta_flag=$wlan_sta_flag p2p_sta_flag=$p2p_sta_flag"
					set curr_sta_wlan_index $sta_wlan_index
					break
				}
			}
		}

		if {$wlan_active_flag == 0 && $wlan_sta_flag == 1} {
			UTF::Message INFO "" "WLAN is not active. Skip WLAN STA."
			continue
		}
		if {$p2p_active_flag == 0 && $p2p_sta_flag == 1} {
			UTF::Message INFO "" "$::p2p_display_str is not active. Skip $::p2p_display_str STA."
			continue
		}

		if {[string compare $target $::wlan_ap] == 0 && $wlan_active_flag == 0} {
			UTF::Message INFO "" "WLAN is not active. Skip."
			continue
		}
		if {[string compare $target $::go_wlan] == 0 && $p2p_active_flag == 0} {
			UTF::Message INFO "" "$::p2p_display_str is not active and we must Skip commands for GO."
			continue
		}
			
		if {$target == $::wlan_ap || $target == $::roaming_src_ap || $target == $::roaming_dst_ap} {
			set target_type "Ap"
		} else {
			set target_type "Sta"
		}

		foreach cmd [$target cget -$perf_hook] {
			UTF::Message INFO "" "------------------------------cmd=$cmd-----------------------------------"

			# check for panic, trap, assert message
			if {[info exists ::UTF::panic]} {
				set ::panic_msg "($::UTF::panic)"
				UTF::Message INFO "G" "::UTF::panic=$::panic_msg"
				set ::test_error_flag 1
				incr ::error_cnt
				error "$::panic_msg"
			}

			if {$cmd == "pktq_stats"} {
				UTF::Message INFO "" "pktq_stats command is being used"
				set ::pktq_stats_flag 1
			}

			if {$throughput_flag && ([regexp {wl dump ampdu} $cmd] || [regexp {wl dump amsdu} $cmd] || [regexp {wl counters} $cmd])} {
				if {$(no_ampdu_dump)} {
					UTF::Message INFO "" "Throughput is running. Skip command '$cmd' to avoid RX throughput drop."
					continue
				}
			}

			if {$throughput_flag && ([regexp {wl dump phycal} $cmd] || [regexp {wl phy_cal_disable} $cmd] || [regexp {wl scansuppress} $cmd])} {
				UTF::Message INFO "" "Throughput is running. Skip command '$cmd'."
				continue
			}

			if {$target_type == "Ap" && ($cmd == "%S wl rssi" || $cmd == "%S wl sta_info")} {
			
				set str_macaddr ""
				set save_cmd $cmd
				foreach sta_wlan_index $::list_sta_wlan_objects {
				
					if {$sta_wlan_index == $::go_wlan && $::ap_connect == "GC"} {
						# do these commands for GO only when AP is connected to it
						continue
					}

					set str_macaddr $::array_sta_wlan_macaddr(${sta_wlan_index})
					set cmd [concat $save_cmd " $str_macaddr"]
					UTF::Message INFO "" "new cmd=$cmd"

					# send the command
					set catch_resp [catch [string map [list %S $target] $cmd] ret]

					if {$catch_resp != 0 || $ret == "N/A"} {
						UTF::Message ERROR "$target" "catch_msg=$ret"
						continue
					}

					if {[regexp {wl rssi} $cmd]} {
						if {[regexp -nocase {([\d\-]+)} $ret - rssi]} {
							set ::csv_data_StaApRssi(${sta_wlan_index}) $rssi
						}
					} elseif {[regexp {wl sta_info} $cmd]} {
						p2p::process_ap_stainfo ${sta_wlan_index} $ret
					}
				}

				continue
			}

			if {$cmd == "%S wl assoc"} {
				if {$wlan_active_flag == 1} {
					if {[string compare $target $::go_wlan] == 0 && $::ap_connect == "GC"} {
						UTF::Message INFO "" "$target WLAN is active but it is connected to GO. we must Skip this 'wl assoc' command."
						continue
					}
					if {[lsearch -exact $::list_gc_wlan_objects $target] >= 0 && $::ap_connect == "GO"} {
						UTF::Message INFO "" "$target WLAN is active but it is connected to GC. we must Skip this 'wl assoc' command."
						continue
					}
				}
				if {$p2p_active_flag == 1 && [string compare $target $::array_sta_p2p(${::go_wlan})] == 0} {
					UTF::Message INFO "" "$::p2p_display_str is active but we must Skip 'wl assoc' command for GO."
					continue
				}
			}

			# add the interface name for non-ap
			regsub { wl } $cmd " wl $str_interface " new_cmd
			UTF::Message INFO "" "cmd=$new_cmd"
			
			# send the command
    		set catch_resp [catch [string map [list %S $target] $new_cmd] ret]

			if {$catch_resp != 0 || $ret == "N/A"} {
				UTF::Message ERROR "$target" "catch_msg=$ret"

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "I" "::UTF::panic=$::panic_msg"
					set ::halt_test_err $::panic_msg
					incr ::error_cnt
					error "$::panic_msg. Halting tests!"
				} elseif {[regexp -nocase {driver adapter not found} $ret] || [regexp -nocase {is not a valid wl driver} $ret]} {
					incr ::error_cnt
					UTF::Message INFO "" "***Fail. Driver is crashed. Do not continue the test."
					set ::halt_test_err $ret
					# set flag to dump socram and FW
					set ::debug2_flag 1
					error "$ret. Halting tests!"
				}				
				continue
			}

			if {$cmd == "%S wl dump ampdu"} {
				p2p::process_ampdu_data $target_type $target $ret
				continue
			}				

			if {[regexp {wl rssi} $cmd]} {
				if {[regexp -nocase {([\d\-]+)} $ret - rssi]} {
					if {[lsearch -exact $::list_gc_wlan_objects $target] >= 0 && $wlan_disassociated_flag == 1} {
						# GC disassociated
						set ::csv_data_${target_type}Rssi(${target}) "" 
					} else {
						set ::csv_data_${target_type}Rssi(${target}) $rssi 
					}
				}
				continue
			} elseif {$cmd == "%S wl bssid"} {
				set ::csv_data_${target_type}Bssid(${target}) [regexp -inline -all {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $ret]
				continue
			} elseif {$cmd == "%S wl rate"} {
				if {[regexp -nocase {([\.\d]+)\s*Mbps} $ret - rate]} {
					set ::csv_data_${target_type}TxRate(${target}) $rate 
				}
				continue
			} elseif {$cmd == "%S wl nrate"} {
				set nrate [p2p::parse_nrate $ret]
				set ::csv_data_${target_type}McsRate(${target}) $nrate
				continue
			} elseif {$::iperf_running_flag && [regexp {wl counters} $cmd] && $target_type != "Ap"} {
				# number of beacons is about 10 / sec when throughput is running
				# number of beacons is about 3 / sec when idle
				
				# here the beacon information is gathered for non-idle case
				
				set bcnrate 0
				regexp {rxbeaconmbss\s([0-9]+)} $ret - bcnrate
				
				set time_ms [clock clicks -milliseconds]

				if {[info exists ::array_streams_last_BeaconRate(${target})]} {
					set bcntime [expr {$time_ms - $::array_streams_last_BeaconRate_time(${target})}]
					set tmp_bcnrate [expr {$bcnrate - $::array_streams_last_BeaconRate(${target})}]
					set BeaconRate [format "%2.3f" [expr {$tmp_bcnrate * 1000.0 / $bcntime}]]
					if {$BeaconRate < 0} {
						set BeaconRate 0
					}
					set ::csv_data_${target_type}BeaconRate(${target}) $BeaconRate
					UTF::Message INFO "" "Time -> '$time_ms - $::array_streams_last_BeaconRate_time(${target})=$bcntime ms'"
					UTF::Message INFO "" "Beacons -> '$bcnrate - $::array_streams_last_BeaconRate(${target})=$tmp_bcnrate'"
					UTF::Message INFO "" "BeaconRate='($tmp_bcnrate * 1000) / $bcntime=$BeaconRate'"
				}
				
				set ::array_streams_last_BeaconRate_time(${target}) $time_ms
				set ::array_streams_last_BeaconRate(${target}) $bcnrate
				
				continue
			}
			
			# get STA state
			if {$cmd == "%S wl assoc"} {
				if {[regexp -nocase {not.*associated} $ret]} {
					set ::csv_data_StaState(${target}) "ROAMING"
					if {$wlan_active_flag == 1 && $wlan_sta_flag == 1} {
						if {$::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							UTF::Message ERROR "" "***Failed. WLAN disassociated."
							append ::streams_total_error "(WLAN disassociated)"
							p2p::check_sta_wlan_association $curr_sta_wlan_index
						}	
					} else {
						if {$::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							UTF::Message ERROR "" "***Failed. $::p2p_display_str disassociated."
							append ::streams_total_error "($::p2p_display_str disassociated)"
							p2p::check_sta_p2p_association $curr_sta_wlan_index
						}
					}
				} elseif {[regexp -nocase {BSSID:\s*00:00:00:00:00:00} $ret]} {
					set ::csv_data_StaState(${target}) "ASSOCIATED"
					if {$wlan_active_flag == 1 && $wlan_sta_flag == 1} {
						if {$::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							UTF::Message INFO "" "WLAN reassociated."
							append ::streams_total_error "(WLAN reassociated)"
							p2p::check_sta_wlan_association $curr_sta_wlan_index
						}	
					} else {
						if {$::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							UTF::Message INFO "" "$::p2p_display_str reassociated."
							append ::streams_total_error "($::p2p_display_str reassociated)"
							p2p::check_sta_p2p_association $curr_sta_wlan_index
						}
					}
				} elseif {[regexp -nocase {BSSID:\s*[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}} $ret]} {
					set ::csv_data_StaState(${target}) "ASSOCIATED BEACONS"
					if {$wlan_active_flag == 1 && $wlan_sta_flag == 1} {
						if {$::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index}) > 0} {
							p2p::check_sta_wlan_association $curr_sta_wlan_index
						}	
					} else {
						if {$::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index}) > 0} {
							p2p::check_sta_p2p_association $curr_sta_wlan_index
						}
					}
				} else {
					set ::csv_data_StaState(${target}) ""
					if {$wlan_active_flag == 1 && $wlan_sta_flag == 1} {
						if {$::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							p2p::check_sta_wlan_association $curr_sta_wlan_index
						}	
					} else {
						if {$::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index}) == 0} {
							p2p::check_sta_p2p_association $curr_sta_wlan_index
						}
					}
				}
				if {$wlan_active_flag == 1 && $wlan_sta_flag == 1} {
					UTF::Message INFO "" "State: ::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index})=$::array_sta_wlan_disassociated_flag(${curr_sta_wlan_index})"
				} else {
					UTF::Message INFO "" "State: ::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index})=$::array_sta_p2p_disassociated_flag(${curr_sta_wlan_index})"
				}
				continue
			}			
		}
	}

	if {$write_flag && $perf_hook == "post_perf_hook"} {
		#####################################################
		#########  Write Data Result to CVS File  ###########
		#####################################################
		p2p::array_write_csv_data 1 0
	}

	UTF::Message INFO "" "****************************************************************"
}

proc p2p::check_sta_wlan_association {sta_wlan_index} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:check_sta_wlan_association***************************"

	if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
		UTF::Message INFO "" "----------------------------Check WLAN association----------------------------"
		UTF::Sleep $(perftime)
		set catch_resp [catch {$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) bssid} catch_msg]
		if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
			UTF::Message ERROR "" "WLAN is NOT associated"
			incr ::array_sta_wlan_disassociated_flag(${sta_wlan_index})
			set ::chanspec_wlan ""
			UTF::Message INFO "" "B - cleared ::chanspec_wlan"
			UTF::Message INFO "" "incr wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${sta_wlan_index})"
		} else {
			UTF::Message INFO "" "WLAN is associated"
			set ::array_sta_wlan_disassociated_flag(${sta_wlan_index}) 0
			set temp [$sta_wlan_index wl -i $::array_sta_wlan_ifname(${sta_wlan_index}) chanspec]
			regexp {(\S+) } $temp match ::chanspec_wlan
			UTF::Message INFO "" "C - ::chanspec_wlan=$::chanspec_wlan"
			UTF::Message INFO "" "clear wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${sta_wlan_index})"
		}
	}
}

proc p2p::check_sta_p2p_association {sta_wlan_index} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:check_sta_p2p_association***************************"

	if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
		UTF::Message INFO "" "----------------------------Check $::p2p_display_str association----------------------------"
		UTF::Sleep $(perftime)
		set catch_resp [catch {$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) bssid} catch_msg]
		if {[string first "Not Associated" $catch_msg] != -1 || [string first "00:00:00:00:00:00" $catch_msg] != -1} {
			UTF::Message ERROR "" "$::p2p_display_str is NOT associated"
			incr ::array_sta_p2p_disassociated_flag(${sta_wlan_index})
			set ::chanspec_p2p ""	
			UTF::Message INFO "" "incr p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"
		} else {
			UTF::Message INFO "" "$::p2p_display_str is associated"
			set ::array_sta_p2p_disassociated_flag(${sta_wlan_index}) 0
			set temp [$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) chanspec]
			regexp {(\S+) } $temp match ::chanspec_p2p
			UTF::Message INFO "" "clear p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"
		}
	}
}

proc p2p::process_ap_stainfo {target results} {

	UTF::Message INFO "" "************************Func:process_ap_stainfo***************************"
	
	# Get StaApTxRateStaInfo
	if {[regexp -nocase {last\s*tx\s*pkt:\s*(\d+)\s*kbps} $results - rate]} {
		# convert kbps to Mbps
		set ::csv_data_StaApTxRateStaInfo(${target}) [expr {double($rate) / 1000.0}]
	}

	# Get StaApRxRate
	# "rate of last rx pkt: 24000 kbps"
	if {[regexp -nocase {last\s*rx\s*pkt:\s*(\d+)\s*kbps} $results - rate]} {
		# convert kbps to Mbps
		set ::csv_data_StaApRxRate(${target}) [expr {double($rate) / 1000.0}]
	}

	# Get StaApIdleTime
	if {[regexp -nocase {idle\s*(\d+)\s*seconds} $results - time]} {
		set ::csv_data_StaApIdleTime(${target}) $time 
	}

	# Get StaApConnectTime
	if {[regexp -nocase {in\s*network\s*(\d+)\s*seconds} $results - time]} {
		set ::csv_data_StaApConnectTime(${target}) $time 
	}

	# Get StaApState
	if {[regexp -nocase {state:\s*(.*)flags} $results - state]} {
		set state [string trim $state]
		set state [string toupper $state]
		set ::csv_data_StaApState(${target}) $state 
	}

	# Get StaApTxPkts
	if {[regexp -nocase {tx\s*total\s*pkts:\s*(\d+)} $results - pkts]} {
		set ::csv_data_StaApTxPkts(${target}) $pkts 
	}

	# Get StaApTxFailures
	if {[regexp -nocase {tx\s*failures:\s*(\d+)} $results - count]} {
		set ::csv_data_StaApTxFailures(${target}) $count 
	}
}

proc p2p::ampdu_data_cleanup {ampdu_data per_flag} {

	regsub -all {\n} $ampdu_data "" ampdu_data
	regsub -all {:} $ampdu_data "" ampdu_data
	if {$per_flag} {
		# for PER, extract the percentage values
		regsub -all {\d+\(} $ampdu_data "" ampdu_data
		regsub -all {%\)} $ampdu_data "" ampdu_data
	} else {
		# for non PER, extract the values
		regsub -all {\(\d+%\)} $ampdu_data "" ampdu_data
	}
	regsub -all {[a-zA-Z]} $ampdu_data "" ampdu_data
	regsub -all {\s+} $ampdu_data " " ampdu_data
	set ampdu_data [string trim $ampdu_data]
	
	return $ampdu_data
}

proc p2p::process_ampdu_data {target_type target ampdu_data} {

	# target_type is Ap or Sta
	
	set var "csv_data_${target_type}"

	# data are 1 line or more
	# avoid "00:90:4c:18:60:58: max_pdu 48 release 48" which could be anywhere
	
    #RX MCS :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  7(1%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  14(2%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  21(3%)
    #       :  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  0(0%)  28(4%)
    
    regexp -nocase {RX\s*MCS(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxMcs(${target})
	set ::${var}RxMcs(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}RxMcs(${target})}] 0]
	UTF::Message INFO "" "::${var}RxMcs(${target})=[expr \${::${var}RxMcs(${target})}]"
    regexp -nocase {TX\s*MCS(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxMcs(${target})
	set ::${var}TxMcs(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}TxMcs(${target})}] 0]
	UTF::Message INFO "" "::${var}TxMcs(${target})=[expr \${::${var}TxMcs(${target})}]"
	
	#MPDUdens:  49 (1%) 223 (4%)  37 (0%)  38 (0%)  32 (0%)  49 (1%)  46 (0%)  52 (1%)
	#	 :  45 (0%)  49 (1%)  53 (1%)  55 (1%)  48 (0%)  50 (1%)  33 (0%)  37 (0%)
	#	 :  32 (0%)  34 (0%)  27 (0%)  44 (0%)  30 (0%)  36 (0%)  32 (0%)  36 (0%)
	#	 :  41 (0%)  38 (0%)  32 (0%)  47 (0%)  46 (0%)  41 (0%)  35 (0%)  29 (0%)
	#	 :  46 (0%)  39 (0%)  34 (0%)  42 (0%)  35 (0%)  44 (0%)  49 (1%)  23 (0%)
	#	 :  21 (0%)  25 (0%)  29 (0%)  28 (0%)  29 (0%)  35 (0%)  36 (0%) 2838 (58%)

	regexp -nocase {MPDUdens(\s*:(\s*\d+\s*\(\d+%\)\s*){1,}){1,}} $ampdu_data ::${var}MpduDensity(${target})
	set ::${var}MpduDensity(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}MpduDensity(${target})}] 0]
	UTF::Message INFO "" "::${var}MpduDensity(${target})=[expr \${::${var}MpduDensity(${target})}]"

    regexp -nocase {RX\s*MCS\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxMcsSgi(${target})
    set ::${var}RxMcsSgi(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}RxMcsSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}RxMcsSgi(${target})=[expr \${::${var}RxMcsSgi(${target})}]"
    regexp -nocase {TX\s*MCS\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxMcsSgi(${target})
	set ::${var}TxMcsSgi(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}TxMcsSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}TxMcsSgi(${target})=[expr \${::${var}TxMcsSgi(${target})}]"
    regexp -nocase {MCS\s*PER(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}McsPer(${target})
	set ::${var}McsPer(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}McsPer(${target})}] 1]
	UTF::Message INFO "" "::${var}McsPer(${target})=[expr \${::${var}McsPer(${target})}]"
    regexp -nocase {RX\s*VHT(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxVht(${target})
	set ::${var}RxVht(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}RxVht(${target})}] 0]
	UTF::Message INFO "" "::${var}RxVht(${target})=[expr \${::${var}RxVht(${target})}]"
	regexp -nocase {TX\s*VHT(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxVht(${target})
	set ::${var}TxVht(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}TxVht(${target})}] 0]
	UTF::Message INFO "" "::${var}TxVht(${target})=[expr \${::${var}TxVht(${target})}]"
	regexp -nocase {RX\s*VHT\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}RxVhtSgi(${target})
	set ::${var}RxVhtSgi(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}RxVhtSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}RxVhtSgi(${target})=[expr \${::${var}RxVhtSgi(${target})}]"
    regexp -nocase {TX\s*VHT\s*SGI(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}TxVhtSgi(${target})
	set ::${var}TxVhtSgi(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}TxVhtSgi(${target})}] 0]
	UTF::Message INFO "" "::${var}TxVhtSgi(${target})=[expr \${::${var}TxVhtSgi(${target})}]"
    regexp -nocase {VHT\s*PER(\s*:(\s*\d+\s*\(\d+%\)\s*){8,}){1,}} $ampdu_data ::${var}VhtPer(${target})
	set ::${var}VhtPer(${target}) [p2p::ampdu_data_cleanup [expr \${::${var}VhtPer(${target})}] 1]
	UTF::Message INFO "" "::${var}VhtPer(${target})=[expr \${::${var}VhtPer(${target})}]"
}

proc p2p::create_test_set_streams_graphs {fb_display} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_test_set_streams_graphs***************************"

	set final_html_results ""

	#####################################################
	## For each stream                                 ##
	## Create new ControlChart object & graphics file  ##
	#####################################################
	foreach stream_index $::streams_name_list {

		UTF::Message INFO "" "=============================Process Stream Result===================================="

		set stream_report_name $::array_streams_report_name(${stream_index})

		UTF::Message INFO "" "stream_index=$stream_index"
		UTF::Message INFO "" "stream_report_name=$stream_report_name"
		UTF::Message INFO "" "::array_streams_type(${stream_index})=$::array_streams_type(${stream_index})"
		UTF::Message INFO "" "::array_streams_tos(${stream_index})=$::array_streams_tos(${stream_index})"
		UTF::Message INFO "" "::array_streams_iperf_cnt(${stream_index})=$::array_streams_iperf_cnt(${stream_index})"
		UTF::Message INFO "" "::array_streams_throughput(${stream_index})=$::array_streams_throughput(${stream_index})"
		UTF::Message INFO "" "::array_streams_tcp_rtt(${stream_index})=$::array_streams_tcp_rtt(${stream_index})"
		UTF::Message INFO "" "::array_streams_tcp_writes(${stream_index})=$::array_streams_tcp_writes(${stream_index})"
		UTF::Message INFO "" "::array_streams_tcp_errors(${stream_index})=$::array_streams_tcp_errors(${stream_index})"
		UTF::Message INFO "" "::array_streams_tcp_retries(${stream_index})=$::array_streams_tcp_retries(${stream_index})"
		UTF::Message INFO "" "::array_streams_tcp_used_memory(${stream_index})=$::array_streams_tcp_used_memory(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_latency_avg(${stream_index})=$::array_streams_udp_latency_avg(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_latency_min(${stream_index})=$::array_streams_udp_latency_min(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_latency_max(${stream_index})=$::array_streams_udp_latency_max(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_latency_stdev(${stream_index})=$::array_streams_udp_latency_stdev(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_jitter(${stream_index})=$::array_streams_udp_jitter(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_lost_packets(${stream_index})=$::array_streams_udp_lost_packets(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${stream_index})=$::array_streams_udp_out_of_order_packets(${stream_index})"
		UTF::Message INFO "" "::array_streams_udp_pps(${stream_index})=$::array_streams_udp_pps(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_rtt(${stream_index})=$::array_streams_controlchart_tcp_rtt(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_retries(${stream_index})=$::array_streams_controlchart_tcp_retries(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_tcp_used_memory(${stream_index})=$::array_streams_controlchart_tcp_used_memory(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_latency(${stream_index})=$::array_streams_controlchart_udp_latency(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_jitter(${stream_index})=$::array_streams_controlchart_udp_jitter(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets(${stream_index})=$::array_streams_controlchart_udp_lost_packets(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_out_of_order_packets(${stream_index})=$::array_streams_controlchart_udp_out_of_order_packets(${stream_index})"
		UTF::Message INFO "" "::array_streams_controlchart_udp_pps(${stream_index})=$::array_streams_controlchart_udp_pps(${stream_index})"

		set html_results ""

		#####################################################
		## Control Charts
		#####################################################
		set ::p2p::cc_error ""

		if {$::array_streams_type(${stream_index}) == "BT"} {
			set final_ckey "$::ckey A=$::curr_attn_value BT$::array_streams_iperf_cnt(${stream_index})"
		} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
			set final_ckey "$::ckey A=$::curr_attn_value PT$::array_streams_iperf_cnt(${stream_index})"
		} else {
			set final_ckey "$::ckey A=$::curr_attn_value WT$::array_streams_iperf_cnt(${stream_index})"
		}
		UTF::Message INFO "" "$::array_streams_type(${stream_index}) KEY=$final_ckey"

		UTF::Message INFO "" "#############################Control Chart Throughput####################################"
		# example: set html_results "<b>VI-P2P:GC<-GO</b>&nbsp;&nbsp;<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAANCAMAAADG8S11AAABIFBMVEX///++vr6g/yB8/0DNwLDB/8Ggts3w//DNt57//8D//4D/wMD/oHD/oGD/oED/gECAgACAYP+AYMCAQICAQBSAFBSAFABVay+QUEDdoN2UANPugu7/pQCggCD19dy4hgu9t2vw5ozplnr6gHL/RQDwgID/f1D/FJMAztH/AP8A//+HzusAAM0AAIAZGXAAAIsAAP8ui1ciiyIA/38AZAAA/wD/1wCv7u7/tsHu3YLg///wVfCt2OaQ7pDwMjL////l5eXMzMzAwMCzs7OZmZl/f39mZmZNTU0zMzMaGhoAAABA4ND//wClKip//9T/gP9AgACLAAAwYIDAgP8AgED/wCBBaeHIyADAQAAA7u7AAP8AgP8AwAD/AACgoKAAAAB3sO+0AAAAAXRSTlMAQObYZgAAAExJREFUKJFjYICCWIZYEGBAg+hCuEAsDKBpRhPCr5cIgMMErBBTAA3EUAAo104awB30dNWOPxXg1I6SIMixHiVBkqWdUBrCpRcjBQIAmV9ohnWheeUAAAAASUVORK5CYII=\" alt=\"data\" /> <a href=\"DIN07T48RC50%20P2PQoS%20%20%2050%20open%20open%204359-GOd35%204359-PGO%204359-GOd35%204359-PGO%202%203%201%20%200%200%20\[VIP-GC1GO\]%20A=0%20PT1.png\">19.23 \[19.69 - 19.75\], range 0.10 \[0.07\] LOW</a>"
		if {$::array_streams_type(${stream_index}) == "BT"} {
			set y_label_unit "Kbps"		
			set y_label "BT Throughput"
		} elseif {$::array_streams_type(${stream_index}) == "P2P"} { 
			set y_label_unit "Mbps"		
			set y_label "$::p2p_display_str Throughput"
		} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
			set y_label_unit "Mbps"		
			set y_label "$::wlan_display_str Throughput"
		}
		UTF::Message INFO "" "p2p::control_chart '$stream_report_name' '$::array_streams_controlchart_throughput(${stream_index})' '$final_ckey' '$y_label' '$y_label_unit' 1"
		set html_results [p2p::control_chart "$stream_report_name" $::array_streams_controlchart_throughput(${stream_index}) $final_ckey "$y_label" "$y_label_unit" 1]

		set throughput 0
		set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results match throughput throughput_min throughput_max]

		if {$result == 1 && $throughput >= 0 && $::array_streams_throughput_skipped_flag(${stream_index}) != 1} {
		
			if {$::rvr_test_flag == 1} {
				if {$::array_streams_type(${stream_index}) == "BT"} {
					set stream_sta_obj $(bt_root_sta)
				} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
					# always P2P GC interface
					set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
				} else {
					if {$::ap_connect == "GC"} {
						set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					} elseif {$::ap_connect == "GO"} {
						set stream_sta_obj $::go_wlan
					} else {
						# just WLAN
						set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					}
				}
				set ::csv_data_StaThroughput(${stream_sta_obj})(${stream_index}) $throughput
				set ::csv_data_StaThroughputMin(${stream_sta_obj})(${stream_index}) $throughput_min
				set ::csv_data_StaThroughputMax(${stream_sta_obj})(${stream_index}) $throughput_max
			}

			if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			
				# TCP Stream
				
				set html_results_tcp_rtt ""
				if {$::array_streams_tcp_rtt(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PR$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WR$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) RTT KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart RTT####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str RTT"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str RTT"
					}
					UTF::Message INFO "" "p2p::control_chart 'RTT' '$::array_streams_controlchart_tcp_rtt(${stream_index})' '$final_ckey' '$y_label' 'ms' 0"
					set html_results_tcp_rtt [p2p::control_chart "RTT" $::array_streams_controlchart_tcp_rtt(${stream_index}) $final_ckey "$y_label" "ms" 0]

					# tcp_rtt of zero and low are OK
					regsub { ZERO} $html_results_tcp_rtt { OK} html_results_tcp_rtt
					regsub { LOW} $html_results_tcp_rtt { OK} html_results_tcp_rtt

					set tcp_rtt ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_rtt match tcp_rtt tcp_rtt_min tcp_rtt_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaTCPRTT(${stream_sta_obj})(${stream_index}) $tcp_rtt
					}

					UTF::Message INFO "" "tcp_rtt=$tcp_rtt"

					set tcp_rtt_err_cnt 0
					foreach stream_tcp_rtt $::array_streams_tcp_rtt(${stream_index}) {
						if {$stream_tcp_rtt >= 300} {
							incr tcp_rtt_err_cnt
						}
					}

					set rc [p2p::max_range $tcp_rtt_err_cnt]
					UTF::Message INFO "" "tcp_rtt_err_cnt=$tcp_rtt_err_cnt rc=$rc"

					# tcp_rtt of 300 ms or more is not acceptable
					if {$tcp_rtt == "" || $tcp_rtt >= 300 || $tcp_rtt_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_rtt_err_cnt RTT >= 300 ms"
						append ::array_streams_error(${stream_index}) "($tcp_rtt_err_cnt RTT > $rc)"
					}
				}

				set html_results_tcp_retries ""
				if {$::array_streams_tcp_retries(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PRe$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WRe$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) Retries KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart Retries####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str Retries"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str Retries"
					}
					UTF::Message INFO "" "p2p::control_chart 'Retries' '$::array_streams_controlchart_tcp_retries(${stream_index})' '$final_ckey' '$y_label' 'Cnt' 0"
					set html_results_tcp_retries [p2p::control_chart "Retries" $::array_streams_controlchart_tcp_retries(${stream_index}) $final_ckey "$y_label" "Cnt" 0]

					# tcp_retries of zero and low are OK
					regsub { ZERO} $html_results_tcp_retries { OK} html_results_tcp_retries
					regsub { LOW} $html_results_tcp_retries { OK} html_results_tcp_retries

					set tcp_retries ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_retries match tcp_retries tcp_retries_min tcp_retries_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaTCPRetries(${stream_sta_obj})(${stream_index}) $tcp_retries
					}

					UTF::Message INFO "" "tcp_retries=$tcp_retries"

					set tcp_retries_err_cnt 0
					foreach stream_tcp_retries $::array_streams_tcp_retries(${stream_index}) {
						if {$stream_tcp_retries >= 30} {
							incr tcp_retries_err_cnt
						}
					}

					set rc [p2p::max_range $tcp_retries_err_cnt]
					UTF::Message INFO "" "tcp_retries_err_cnt=$tcp_retries_err_cnt rc=$rc"

					# tcp_retries of 30 or more is not acceptable
					if {$tcp_retries == "" || $tcp_retries >= 30 || $tcp_retries_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_retries_err_cnt Retries >= 30"
						append ::array_streams_error(${stream_index}) "($tcp_retries_err_cnt Retries > $rc)"
					}
				}

				set html_results_tcp_used_memory ""
				if {$::array_streams_tcp_used_memory(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PU$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WU$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) Used Memory KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart Used Memory####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str Used Memory"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str Used Memory"
					}
					UTF::Message INFO "" "p2p::control_chart 'Used Memory' '$::array_streams_controlchart_tcp_used_memory(${stream_index})' '$final_ckey' '$y_label' 'K' 0"
					set html_results_tcp_used_memory [p2p::control_chart "Used Memory" $::array_streams_controlchart_tcp_used_memory(${stream_index}) $final_ckey "$y_label" "K" 0]

					# tcp_used_memory of zero and low are OK
					regsub { ZERO} $html_results_tcp_used_memory { OK} html_results_tcp_used_memory
					regsub { LOW} $html_results_tcp_used_memory { OK} html_results_tcp_used_memory

					set tcp_used_memory ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_tcp_used_memory match tcp_used_memory tcp_used_memory_min tcp_used_memory_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaTCPUsedMemory(${stream_sta_obj})(${stream_index}) $tcp_used_memory
					}

					UTF::Message INFO "" "tcp_used_memory=$tcp_used_memory"

					set tcp_used_memory_err_cnt 0
					foreach stream_tcp_used_memory $::array_streams_tcp_used_memory(${stream_index}) {
						if {$stream_tcp_used_memory >= 500} {
							incr tcp_used_memory_err_cnt
						}
					}

					set rc [p2p::max_range $tcp_used_memory_err_cnt]
					UTF::Message INFO "" "tcp_used_memory_err_cnt=$tcp_used_memory_err_cnt rc=$rc"

					# tcp_used_memory of 500k or more is not acceptable
					if {$tcp_used_memory == "" || $tcp_used_memory >= 500 || $tcp_used_memory_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$tcp_used_memory_err_cnt Used Memory >= 500K"
						append ::array_streams_error(${stream_index}) "($tcp_used_memory_err_cnt Used Memory > $rc)"
					}
				}

				append html_results " $html_results_tcp_rtt $html_results_tcp_retries $html_results_tcp_used_memory"

			} elseif {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			
				# UDP Stream

				# check the UDP throughput value to be close to udp_bandwidth
				# throughput needs to be within 10% of the bandwidth
				
				set iperf_bandwidth 0
				regexp {^([-+]?[0-9]*\.?[0-9]+)(.)} $::array_streams_udp_bandwidth(${stream_index}) match iperf_bandwidth scale
				
				set tmp [expr {$iperf_bandwidth * 0.1}]
				if {$tmp > 0} {
					set tmp_iperf_bandwidth [expr {$iperf_bandwidth - $tmp}]
				}
				
				UTF::Message INFO "" "throughput='$throughput' iperf_bandwidth='$iperf_bandwidth' tmp_iperf_bandwidth='$tmp_iperf_bandwidth'"
				if {$::rvr_test_flag == 0 && $::roaming_test_flag == 0 && $::failover_test_flag == 0 && $throughput < $tmp_iperf_bandwidth} {
					# error
					UTF::Message ERROR "" "Throughput is $throughput and it is lower than UDP bandwidth of $::array_streams_udp_bandwidth(${stream_index})"
					append ::array_streams_error(${stream_index}) "(Throughput < $::array_streams_udp_bandwidth(${stream_index}))"
				}

				set html_results_udp_latency ""
				if {$::array_streams_udp_latency_avg(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PL$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WL$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) Latency KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart Latency####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str Latency"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str Latency"
					}
					UTF::Message INFO "" "p2p::control_chart 'Latency' '$::array_streams_controlchart_udp_latency(${stream_index})' '$final_ckey' '$y_label' 'ms' 0"
					set html_results_udp_latency [p2p::control_chart "Latency" $::array_streams_controlchart_udp_latency(${stream_index}) $final_ckey "$y_label" "ms" 0]

					# udp_latency of zero and low are OK
					regsub { ZERO} $html_results_udp_latency { OK} html_results_udp_latency
					regsub { LOW} $html_results_udp_latency { OK} html_results_udp_latency

					set udp_latency ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_latency match udp_latency udp_latency_min udp_latency_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaUDPLatency(${stream_sta_obj})(${stream_index}) $udp_latency
					}

					UTF::Message INFO "" "udp_latency=$udp_latency"

					set udp_latency_err_cnt 0
					foreach stream_udp_latency $::array_streams_udp_latency_avg(${stream_index}) {
						if {$stream_udp_latency >= 5} {
							incr udp_latency_err_cnt
						}
					}

					set rc [p2p::max_range $udp_latency_err_cnt]
					UTF::Message INFO "" "udp_latency_err_cnt=$udp_latency_err_cnt rc=$rc"

					# udp_latency of 5 ms or more is not acceptable
					if {$udp_latency == "" || $udp_latency >= 5 || $udp_latency_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$udp_latency_err_cnt Latency >= 5 ms"
						append ::array_streams_error(${stream_index}) "($udp_latency_err_cnt Latency > $rc)"
					}
				}
				
				set html_results_udp_jitter ""
				if {$::array_streams_udp_jitter(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PJ$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WJ$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) Jitter KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart Jitter####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str Jitter"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str Jitter"
					}
					UTF::Message INFO "" "p2p::control_chart 'Jitter' '$::array_streams_controlchart_udp_jitter(${stream_index})' '$final_ckey' '$y_label' 'ms' 0"
					set html_results_udp_jitter [p2p::control_chart "Jitter" $::array_streams_controlchart_udp_jitter(${stream_index}) $final_ckey "$y_label" "ms" 0]

					# udp_jitter of zero and low are OK
					regsub { ZERO} $html_results_udp_jitter { OK} html_results_udp_jitter
					regsub { LOW} $html_results_udp_jitter { OK} html_results_udp_jitter

					set udp_jitter ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_jitter match udp_jitter udp_jitter_min udp_jitter_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaUDPJitter(${stream_sta_obj})(${stream_index}) $udp_jitter
						set ::csv_data_StaUDPJitterMin(${stream_sta_obj})(${stream_index}) $udp_jitter_min
						set ::csv_data_StaUDPJitterMax(${stream_sta_obj})(${stream_index}) $udp_jitter_max
					}

					UTF::Message INFO "" "udp_jitter=$udp_jitter"
					
					set udp_jitter_err_cnt 0
					foreach stream_udp_jitter $::array_streams_udp_jitter(${stream_index}) {
						if {$stream_udp_jitter >= 1} {
							incr udp_jitter_err_cnt
						}
					}

					set rc [p2p::max_range $udp_jitter_err_cnt]
					UTF::Message INFO "" "udp_jitter_err_cnt=$udp_jitter_err_cnt rc=$rc"

					# Jitter of 1 ms or more is not acceptable for the UDP
					if {$udp_jitter == "" || $udp_jitter >= 1 || $udp_jitter_err_cnt > 0} {
						# error
						UTF::Message ERROR "" "$udp_jitter_err_cnt Jitter >= 1 ms"
						append ::array_streams_error(${stream_index}) "($udp_jitter_err_cnt Jitter > $rc)"
					}
				}

				set html_results_udp_lost_packets ""
				if {$::array_streams_udp_lost_packets(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value PPL$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WPL$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) Lost Packets KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart Lost Packets####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str Lost Packets"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str Lost Packets"
					}
					UTF::Message INFO "" "p2p::control_chart 'Lost Packets' '$::array_streams_controlchart_udp_lost_packets(${stream_index})' '$final_ckey' '$y_label' 'Packets' 0"
					set html_results_udp_lost_packets [p2p::control_chart "Lost Packets" $::array_streams_controlchart_udp_lost_packets(${stream_index}) $final_ckey "$y_label" "Packets" 0]

					# packet loss with zero or low are OK
					regsub { ZERO} $html_results_udp_lost_packets { OK} html_results_udp_lost_packets
					regsub { LOW} $html_results_udp_lost_packets { OK} html_results_udp_lost_packets

					set udp_lost_packets ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_lost_packets match udp_lost_packets udp_lost_packets_min udp_lost_packets_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaUDPLostPackets(${stream_sta_obj})(${stream_index}) $udp_lost_packets
						set ::csv_data_StaUDPLostPacketsMin(${stream_sta_obj})(${stream_index}) $udp_lost_packets_min
						set ::csv_data_StaUDPLostPacketsMax(${stream_sta_obj})(${stream_index}) $udp_lost_packets_max
					}

					UTF::Message INFO "" "udp_lost_packets=$udp_lost_packets"
					set udp_lost_packets [format "%2.0f" $udp_lost_packets]
					set rc [p2p::max_range $udp_lost_packets]
					UTF::Message INFO "" "udp_lost_packets=$udp_lost_packets rc=$rc"

					# packet loss of more than 0 is not acceptable for the UDP
					if {$udp_lost_packets == "" || $udp_lost_packets > 0} {
						# error
						append ::array_streams_error(${stream_index}) "($udp_lost_packets Lost Packets > $rc)"
					}
				}

				set html_results_udp_out_of_order_packets ""
				if {$::array_streams_udp_out_of_order_packets(${stream_index}) != ""} {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						set final_ckey "$::ckey A=$::curr_attn_value POP$::array_streams_iperf_cnt(${stream_index})"
					} else {
						set final_ckey "$::ckey A=$::curr_attn_value WOP$::array_streams_iperf_cnt(${stream_index})"
					}
					UTF::Message INFO "" "$::array_streams_type(${stream_index}) out-of-order Packets KEY=$final_ckey"

					UTF::Message INFO "" "#############################Control Chart out-of-order####################################"
					if {$::array_streams_type(${stream_index}) == "P2P"} { 
						set y_label "$::p2p_display_str out-of-order Packets"
					} elseif {$::array_streams_type(${stream_index}) == "WLAN"} { 
						set y_label "$::wlan_display_str out-of-order Packets"
					}
					UTF::Message INFO "" "p2p::control_chart 'out-of-order Packets' '$::array_streams_controlchart_udp_out_of_order_packets(${stream_index})' '$final_ckey' '$y_label' 'Packets' 0"
					set html_results_udp_out_of_order_packets [p2p::control_chart "out-of-order Packets" $::array_streams_controlchart_udp_out_of_order_packets(${stream_index}) $final_ckey "$y_label" "Packets" 0]

					# out-of-order Packets of zero or low are OK
					regsub { ZERO} $html_results_udp_out_of_order_packets { OK} html_results_udp_out_of_order_packets
					regsub { LOW} $html_results_udp_out_of_order_packets { OK} html_results_udp_out_of_order_packets

					set udp_out_of_order_packets ""
					set result [regexp {.*.> *?([-+]?\d+\.\d+) *?\[([-+]?\d+\.\d+) *?- *?([-+]?\d+\.\d+)], *?range *?.*} $html_results_udp_out_of_order_packets match udp_out_of_order_packets udp_out_of_order_packets_min udp_out_of_order_packets_max]

					if {$::rvr_test_flag == 1 && $result == 1} {
						if {$::array_streams_type(${stream_index}) == "BT"} {
							set stream_sta_obj $(bt_root_sta)
						} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
							# always P2P GC interface
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
						} else {
							if {$::ap_connect == "GC"} {
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							} elseif {$::ap_connect == "GO"} {
								set stream_sta_obj $::go_wlan
							} else {
								# just WLAN
								set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
							}
						}
						set ::csv_data_StaUDPOutofOrderPackets(${stream_sta_obj})(${stream_index}) $udp_out_of_order_packets
						set ::csv_data_StaUDPOutofOrderPacketsMin(${stream_sta_obj})(${stream_index}) $udp_out_of_order_packets_min
						set ::csv_data_StaUDPOutofOrderPacketsMax(${stream_sta_obj})(${stream_index}) $udp_out_of_order_packets_max
					}

					UTF::Message INFO "" "udp_out_of_order_packets=$udp_out_of_order_packets"
					set udp_out_of_order_packets [format "%2.0f" $udp_out_of_order_packets]
					set rc [p2p::max_range $udp_out_of_order_packets]
					UTF::Message INFO "" "udp_out_of_order_packets=$udp_out_of_order_packets rc=$rc"

					# More than 0 out-of-order Packets is not acceptable for the UDP
					if {$udp_out_of_order_packets == "" || $udp_out_of_order_packets > 0} {
						# error
						append ::array_streams_error(${stream_index}) "($udp_out_of_order_packets out-of-order Packets > $rc)"
					}
				}

				append html_results " $html_results_udp_latency $html_results_udp_jitter $html_results_udp_lost_packets $html_results_udp_out_of_order_packets"
			}			
		} else {
			set wlan_active_flag 0
			set p2p_active_flag 0
			set wlan_disassociated_flag 0
			set p2p_disassociated_flag 0
			foreach sta_wlan_index $::list_sta_wlan_objects {
				if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
					set wlan_active_flag 1
					UTF::Message INFO "" "$sta_wlan_index WLAN is active"
				}
				if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
					set wlan_disassociated_flag 1
					UTF::Message INFO "" "$sta_wlan_index WLAN is disassociated"
				}
				if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
					set p2p_active_flag 1
					UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
				}
				if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
					set p2p_disassociated_flag 1
					UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is disassociated"
				}
			}

			set tmp_msg ""

			if {$wlan_active_flag == 1 && $wlan_disassociated_flag > 0} {
				set tmp_msg [concat $tmp_msg "WLAN is NOT associated. "]
			}

			if {$p2p_active_flag == 1 && $p2p_disassociated_flag > 0} {
				set tmp_msg [concat $tmp_msg "$::p2p_display_str is NOT associated. "]
			}

			if {$::array_streams_throughput_skipped_flag(${stream_index}) == 1} {
				set tmp_msg [concat $tmp_msg "Skip running iperf."]
			}

			if {$tmp_msg == ""} {
				set tmp_msg "(All Data Missing)"
			}
			
			set html_results "<font color=\"red\"><b>$stream_index $tmp_msg</b></font>"
			set ::p2p::cc_error ""
			set ::test_error_flag 1
		}

		if {$::p2p::cc_error != ""} {
			set ::array_streams_error(${stream_index}) "$::p2p::cc_error$::array_streams_error(${stream_index})"
			set ::p2p::cc_error ""
		}
		
		UTF::Message INFO "" "$::array_streams_type(${stream_index}) ::array_streams_error(${stream_index})=$::array_streams_error(${stream_index})"
		if {$::array_streams_error(${stream_index}) != ""} {
			# html conversion 
			set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::array_streams_error(${stream_index})]
			append html_results "&nbsp;&nbsp;<font color=\"red\"><b>$tmp</b></font>"
			set ::test_error_flag 1
		}

		if {$(run_qos) || $::multi_sta_flag == 1} {
			append html_results "<br>"
		} else {
			append html_results "&nbsp;&nbsp;"
		}

		append final_html_results $html_results
	}

	#####################################################
	## throughput time plot graph for this group of streams
	#####################################################
	if {$::rvr_test_flag == 1} {
		set html_results_plot ""
	} else {
		set testnum [p2p::get_testnum]
		regsub -all {.} $testnum "_" $testnum
		set html_results_plot "<a href=\"GraphsData/$testnum.StaThroughput.htm\">Graphs</a>&nbsp;&nbsp;<a href=\"GraphsData/$testnum.StaThroughput.htm\"><img src=\"GraphsData/$testnum.StaThroughput_sm.png\"></a>"
	}

	#####################################################
	## current measurement time plot graph for this group of streams
	#####################################################
	set html_results_current ""
	if {$::agilent_obj != ""} {
		if {$::current_results == ""} {
			append html_results_current "&nbsp;&nbsp;<blink><font color=\"red\"><b>'No Current Data'</b></font></blink>"
			set ::test_error_flag 1
		} else {
			set html_results_current "<br>$::current_results"
		}					
	}

	#####################################################
	## Report
	#####################################################
	set report_html_results "$final_html_results$html_results_plot$html_results_current"

	UTF::Message INFO "" "streams_total_error=$::streams_total_error"
	if {$::streams_total_error != ""} {
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::streams_total_error]
		append report_html_results "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
		set error_flag 1
	}

	if {$::debug_flag == 1} {
		UTF::Try "DEBUG DUMP" {
			$sta_wlan_index wl dump stats dma phystate
			$sta_wlan_index wl status
		}
	}

	if {$::kpi_test_flag} {
		p2p::kpi_dump_xml_data
	}

	return $report_html_results	
}

proc p2p::run_rvr_test {fb_display} {
	# access option array
	upvar {} {}

	#####################################################
	#######         Create CSV Data File        #########
	#####################################################
	p2p::setup_csv_header

	UTF::Message INFO "" "************************Func:run_rvr_test***************************"

	set ::saved_hook_start_timestamp ""
	UTF::Message INFO "" "Cleared ::saved_hook_start_timestamp=$::saved_hook_start_timestamp"

	set ::panic_msg ""
	set rvr_error_flag 0
	set ::gnuplot_xtic_label ""
	set ::gnuplot_x_max_rvr_val ""
	set attn_up_start ""
	set attn_up_end ""
	set attn_down_new_start ""
	set attn_down_start ""
	set attn_down_end ""
	set ::curr_attn_incr 0
	set rvr_loop_cnt 0

	if {$(attn_type) == 1} {
		set attn_range $(rvr_wlan_attn_range)
		set attn_disp_type "WLAN"
	} elseif {$(attn_type) == 2} {
		set attn_range $(rvr_p2p_attn_range)
		set attn_disp_type "P2P"
	} elseif {$(attn_type) == 3} {
		set attn_range "0-90 90-0"
		set attn_disp_type "WLAN&P2P"
	}

	UTF::Message LOG "" "attn_range=$attn_range"

	UTF::Message LOG "" "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"

	set attn_direction_changed_flag 0
	set attn_adjustment_value 0

	foreach attn_element $attn_range {

		# for range "x-y": 
		if {[regexp {([0-9]+)\-([0-9]+)} $attn_element match range1 range2]} {
			if {$range1 <= $range2} {
				set attn_up_start $range1
				set attn_up_end $range2
				set attn_val $attn_up_start
				set max_loop_cnt [expr {$attn_up_end - $attn_up_start + $::rvr_attn_incr}]
				set attn_direction up
				set attn_adjustment_value 0
			} else {
				set attn_down_start $range1
				set attn_down_end $range2

				if {$attn_down_new_start != ""} {
					UTF::Message LOG "" "attn_down_new_start=$attn_down_new_start"
					set attn_down_start $attn_down_new_start
				}
				
				set attn_val $attn_down_start
				set max_loop_cnt [expr {$attn_down_start - $attn_down_end + $::rvr_attn_incr}]
				set attn_direction down
				set attn_direction_changed_flag 1
				set attn_adjustment_value 0
			}
		} else {
			# for single value
			if {[regexp {^[+-]?[0-9]+$} $attn_element]} {
				set attn_val $attn_element
				set max_loop_cnt 1
				set attn_direction up
			}
		}

		if {$::curr_attn_value == $attn_val} {
			# this is a repeat attn since we changes direction. Skip this attn
			
			UTF::Message LOG "" "skip attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"

			set max_loop_cnt [expr {$max_loop_cnt - 1}]
			
			if {$attn_direction == "up"} {
				set attn_val [expr {$attn_val + $::rvr_attn_incr}]
			} else {
				set attn_val [expr {$attn_val - $::rvr_attn_incr}]
			}
		}

		UTF::Message LOG "" "===================================================================="
		set j 0
		while {$j < $max_loop_cnt} {

			# this block is done here so the report shows P2P assoc on the report and not under the attn steps
			foreach sta_wlan_index $::list_sta_wlan_objects {
				UTF::Message LOG "" "RvR $::p2p_display_str Re-Assoc: ::array_sta_p2p_active_flag(${sta_wlan_index})=$::array_sta_p2p_active_flag(${sta_wlan_index}) ::array_sta_p2p_disassociated_flag(${sta_wlan_index})=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"
				# ::array_sta_p2p_disassociated_flag > 0 must try to re-assoc
				if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
					UTF::Message LOG "" "-------------------------------------------RvR $::p2p_display_str Re-Assoc-------------------------------------------"
					p2p::gc_join_go $sta_wlan_index 0 1
				}
			}
		
			UTF::Try "$attn_disp_type Attn $attn_val" {

				foreach sta_wlan_index $::list_sta_wlan_objects {
					if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && $::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
						UTF::Message LOG "" "-------------------------------------------RvR WLAN Assoc Check-------------------------------------------"
						p2p::check_sta_wlan_association $sta_wlan_index
					}

					# ::array_sta_p2p_disassociated_flag > 0 must try to re-assoc
					if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
						UTF::Message LOG "" "-------------------------------------------RvR $::p2p_display_str Assoc Check-------------------------------------------"
						p2p::check_sta_p2p_association $sta_wlan_index
					}
				}

				UTF::Message LOG "" "attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"

				if {$(attn_type) == 1 || $(attn_type) == 3} {
					set catch_resp [catch {$::rvr_wlan_attngrp attn $attn_val} catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "Attenuator failed at $attn_val"
						error "Attenuator failed at $attn_val"							
					}
				} 
				
				if {$(attn_type) == 2 || $(attn_type) == 3} {
					set catch_resp [catch {$::rvr_p2p_attngrp attn $attn_val} catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "Attenuator failed at $attn_val"
						error "Attenuator failed at $attn_val"							
					}
				}

				if {$::curr_attn_value == -1} {
					set ::curr_attn_incr $::rvr_attn_incr
				} else {
					set ::curr_attn_incr [expr {abs($attn_val - $::curr_attn_value)}]
				}
				
				set ::curr_attn_value $attn_val

				UTF::Sleep .1

				#####################################################
				#######        Attn n - Run This test       #########
				#####################################################
				incr rvr_loop_cnt
				set html_results [p2p::run_test $fb_display $rvr_loop_cnt]

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "B" "::UTF::panic=$::panic_msg"
					set rvr_error_flag 1
					break
				}

				if {$::test_error_flag == 0} {
					return "html: $html_results"
				} else {
					set rvr_error_flag 1
					error "html: $html_results"
				}
				# end of UTF::Try "$::test_type
			}

			# check for panic, trap, assert message
			if {[info exists ::UTF::panic] || $::panic_msg != ""} {
				if {$::panic_msg == ""} {
					set ::panic_msg "($::UTF::panic)"
				}
				UTF::Message INFO "C" "::UTF::panic=$::panic_msg"
				set rvr_error_flag 1
				incr ::error_cnt
				error "$::panic_msg"
			}

			if {$::error_cnt > 0} {
				error "html: $::halt_test_err"
			}

			set up_direction_break_flag 0
			if {$attn_direction == "up"} {				
				foreach gc_wlan_index $::list_sta_wlan_objects {

					UTF::Message INFO "" "wlan_disassociated_flag=$::array_sta_wlan_disassociated_flag(${gc_wlan_index})"
					UTF::Message INFO "" "p2p_disassociated_flag=$::array_sta_p2p_disassociated_flag(${gc_wlan_index})"

					if {$(attn_type) == 1 && $::array_sta_wlan_disassociated_flag(${gc_wlan_index}) >= 3} {
						UTF::Message INFO "" "WLAN is disconnected for the past 3 steps for STA $gc_wlan_index. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}

					if {$(attn_type) == 2 && $::array_sta_p2p_disassociated_flag(${gc_wlan_index}) >= 3} {
						UTF::Message INFO "" "$::p2p_display_str is disconnected for the past 3 steps for STA $gc_wlan_index. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}

					if {$(attn_type) == 3 && $::array_sta_wlan_disassociated_flag(${gc_wlan_index}) >= 3 && $::array_sta_p2p_disassociated_flag(${gc_wlan_index}) >= 3} {
						UTF::Message INFO "" "WLAN & $::p2p_display_str are disconnected for the past 3 steps for STA $gc_wlan_index. Skip the rest of UP attenuation"
						set up_direction_break_flag 1
						break
					}
				}
				
				if {$up_direction_break_flag == 1} {
					set attn_up_end $attn_val
					set attn_down_new_start $attn_val
				}
			}

			if {[expr {[expr {$attn_val + 1}] % 10}] == 1 || ($attn_direction == "up" && $attn_val == $attn_up_end)} {
				if {$::curr_gnuplot_data_line_cnt > 0 && $::gnuplot_xtic_label != ""} {
					set ::gnuplot_xtic_label "$::gnuplot_xtic_label,"
				}
				set graph_attn_val [expr {$attn_val + $::testbed_path_loss}]
				set tmp_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $attn_adjustment_value}]
				set ::gnuplot_xtic_label "$::gnuplot_xtic_label\'$graph_attn_val\' $tmp_gnuplot_data_line_cnt"
				set ::gnuplot_x_max_rvr_val $tmp_gnuplot_data_line_cnt
				UTF::Message INFO "" "xtic $graph_attn_val $tmp_gnuplot_data_line_cnt attn_val=$attn_val loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
			}

			if {$attn_direction == "up"} {				
				if {$up_direction_break_flag == 1} {
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}

				# when rvr_attn_incr>=2, do not skip the highest up attn
				if {$attn_val != $attn_up_end && [expr {$attn_val + $::rvr_attn_incr}] > $attn_up_end} {
					# start the down attn from this value otherwise odd number with rvr_attn_incr=2 could skip the "% 10" condition 
					set attn_down_new_start $attn_val
					set attn_val $attn_up_end
				} else {		
					set attn_val [expr {$attn_val + $::rvr_attn_incr}]
				}
				
				if {$attn_val > $attn_up_end} {
					UTF::Message INFO "" "attn up break out. attn_val=$attn_val attn_up_end=$attn_up_end loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}
			} else {
				set attn_val [expr {$attn_val - $::rvr_attn_incr}]
				
				if {$attn_val < $attn_down_end} {
					UTF::Message INFO "" "attn down break out. attn_val=$attn_val attn_down_end=$attn_down_end loop_cnt=$j max_loop_cnt=$max_loop_cnt attn_direction=$attn_direction"
					set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]
					break
				}
			}

			set ::curr_gnuplot_data_line_cnt [expr {$::curr_gnuplot_data_line_cnt + $::curr_attn_incr}]

			set j [expr {$j + $::rvr_attn_incr}]
		}
	}

	# check for panic, trap, assert message
	set panic_err ""
	if {$::panic_msg != ""} {
		# failed
		UTF::Message INFO "D" "::UTF::panic=$::panic_msg"
		set rvr_error_flag 1
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $::panic_msg]
		set panic_err "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
	}

	#####################################################
	#######         Create Summary Graphs       #########
	#####################################################
	set graph_err ""
	set rvr_img ""
	set ::throughput_png_file ""
	set catch_resp [catch {p2p::create_summary_graphs} catch_msg]
	if {$catch_resp != 0} {
		# failed
        UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set rvr_error_flag 1
		# html conversion 
		set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $catch_msg]
		set graph_err "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
	} else {
		set testnum [p2p::get_testnum]
		regsub -all {.} $testnum "_" $testnum
		set rvr_img "<br><p><a href=\"GraphsData/$testnum.StaThroughput.htm\"><img src=\"$::throughput_png_file\" alt=\"\" width=\"720\" height=\"480\" border=\"0\"></a></p>"
	}
	
	if {$rvr_error_flag == 0} {
		return "$rvr_img"
	} else {
		set ::test_error_flag 1
		return "<font color=\"red\"><b>RvR Test Failed</b></font>$panic_err$graph_err$rvr_img"
	}
}

proc p2p::run_test {fb_display rvr_loop_cnt} {
	# access option array
	upvar {} {}

	catch {unset ::array_streams_last_BeaconRate_time}
	catch {unset ::array_streams_last_BeaconRate}
	catch {unset ::array_streams_error}

	set ::iperf_running_flag 0
	set ::test_error_flag 0
	set ::qos_streams_total_time 0
	set ::rvr_zero_throughput_flag 0

	set run_test_flag 0

	if {$::bt_only_flag} {
		set run_test_flag 1
	}

	UTF::Message INFO "" "************************Func:run_test***************************"

	UTF::Message INFO "" "::streams_report_fullname='$::streams_report_fullname'"
	UTF::Message INFO "" "::streams_name_list='$::streams_name_list'"
	UTF::Message INFO "" "----------------------------------------------------------------"

	#UTF::Message INFO "" "delete all the results data arrays"
	p2p::array_setup_results_data "" 1 0

	foreach stream_index $::streams_name_list {
		#UTF::Message INFO "" "create results data arrays"
		p2p::array_setup_results_data $stream_index 0 1
	}

	foreach sta_wlan_index $::list_sta_wlan_objects {
	
		UTF::Message INFO "" "++++++++++++++++++++++++++++++++++STA $sta_wlan_index++++++++++++++++++++++++++++++++++++++++++++"

		if {$::rvr_test_flag == 0} {
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && $::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
				#####################################################
				#######      Check STA WLAN Association     #########
				#####################################################
				p2p::check_sta_wlan_association $sta_wlan_index
			}
			UTF::Message INFO "" "::array_sta_wlan_active_flag(${sta_wlan_index})=$::array_sta_wlan_active_flag(${sta_wlan_index}) ::array_sta_wlan_disassociated_flag(${sta_wlan_index})=$::array_sta_wlan_disassociated_flag(${sta_wlan_index})"
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
				#####################################################
				#######       Check STA P2P Association     #########
				#####################################################
				p2p::check_sta_p2p_association $sta_wlan_index
			}
			UTF::Message INFO "" "::array_sta_p2p_active_flag(${sta_wlan_index})=$::array_sta_p2p_active_flag(${sta_wlan_index}) ::array_sta_p2p_disassociated_flag(${sta_wlan_index})=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"
		}
		
		# check for WLAN throughput test to be run
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			if {$::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
				UTF::Message INFO "" "WLAN is disassociated"

				# mark all the streams for this GC with throughput_skipped_flag
				foreach stream_index $::streams_name_list {
					if {$::array_streams_type(${stream_index}) == "WLAN"} {
						if {$::ap_connect == "GC"} {
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
						} elseif {$::ap_connect == "GO"} {
							set stream_sta_obj $::go_wlan
						} else {
							# just WLAN
							set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
						}

						if {$stream_sta_obj == $sta_wlan_index} {
							UTF::Message INFO "" "::array_streams_throughput_skipped_flag(${stream_index})=1 for WLAN STA $sta_wlan_index"
							set ::array_streams_throughput_skipped_flag(${stream_index}) 1
						}
					}
				}
			} else {
				# WLAN test needs to run
				UTF::Message INFO "" "WLAN run_test_flag=1"
				set run_test_flag 1
			}
		}

		# check for P2P throughput test to be run
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			if {$::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
				UTF::Message INFO "" "$::p2p_display_str is disassociated"

				# mark all the P2P streams for this GC with throughput_skipped_flag
				foreach stream_index $::streams_name_list {
					if {$::array_streams_type(${stream_index}) == "P2P"} {
						# always P2P GC interface
						set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
						if {$stream_sta_obj == $sta_wlan_index} {
							UTF::Message INFO "" "::array_streams_throughput_skipped_flag(${stream_index})=1 for $::p2p_display_str STA $sta_wlan_index"
							set ::array_streams_throughput_skipped_flag(${stream_index}) 1
						}
					}
				}
			} else {
				# P2P test needs to run
				UTF::Message INFO "" "$::p2p_display_str run_test_flag=1"
				set run_test_flag 1
			}
		}
	}
	
	if {$run_test_flag == 1} {
		#####################################################
		##############     Start Sniffer     ################
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			set ::sniffer_filename "sniffer_ch$::sniffer_channel.pcap"
			regsub {\/} $::sniffer_filename "_" ::sniffer_filename

			UTF::Message INFO "" "###########################Start Sniffer######################################"
			set catch_resp [catch {$::sniffer_object start "tshark -i prism0 -w /tmp/$::sniffer_filename"} catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

			if {$catch_resp == 0} {
				set ::sniffer_start_time_secs [clock seconds]
				set sniffer_timestamp [clock format $::sniffer_start_time_secs -format "%H:%M:%S"]
				UTF::Message INFO "" "###########################Sniffer Started @ '$sniffer_timestamp'######################################"
				set ::sniffer_process_id $catch_msg
				set ::sniffer_started_flag 1
			} else {
				set ::test_error_flag 1
				UTF::Message LOG "" "***Failed. Sniffer did not start."
				append ::streams_total_error "(Sniffer did not start)"
			}
		}

		#########################################
		# Stop all server streams
		#########################################
		p2p::close_iperf_traffic
		p2p::stop_iperf_traffic
		p2p::stop_all_server_streams

		if {$::p2p_load_flag && $::array_sta_host_type(${::go_wlan}) == "MacOS" && $::awdl_flag} {
			# Only for OSX AWDL (Not Linux AWDL)
			#########################################
			# MacOS AWDL Link Activation
			#########################################
			p2p::awdl_macos_link_activate
			UTF::Sleep 5
		}

		#########################################
		# Start all iperf servers
		#########################################
		p2p::start_all_server_streams
UTF::Sleep 5
		UTF::Message INFO "" "************************pre_perf_hook***************************"
		#########################################
		# Process pre_perf_hook
		#########################################
		p2p::process_perf_hook pre_perf_hook 0 0

		if {($::rvr_test_flag == 1 && $rvr_loop_cnt == 1) || $::rvr_test_flag == 0} {
		
			# run Pre-Throughputs only for non-RvR test or the 1st step of the RvR test
			# Do not run Pre-Throughputs for MacOS AWDL tests, since it causes issue some times
			
			if {!($::p2p_load_flag && $::array_sta_host_type(${::go_wlan}) == "MacOS" && $::awdl_flag)} {
				#####################################################
				#### Start Pre-Throughputs for this test Streams ####
				#####################################################
				p2p::start_pre_throughputs

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					return "panic"
				}

				#########################################
				# Stop all server streams
				#########################################
				p2p::close_iperf_traffic
				p2p::stop_iperf_traffic
				p2p::stop_all_server_streams

				#########################################
				# Start all server streams
				#########################################
				p2p::start_all_server_streams
			}
		} else {
UTF::Sleep 5
		}
		
		#####################################################
		#######       Start This test Streams       #########
		#####################################################
		p2p::start_all_client_streams

		#####################################################
		#######     Process Test Streams Result     #########
		#####################################################
		p2p::process_test_set_streams_results
	} else {
		UTF::Message INFO "" "Skipped running iperf."
		
		#########################################
		# Process post_perf_hook
		#########################################
		p2p::process_perf_hook post_perf_hook 0 1
	}

	#####################################################
	#######      Create Test Streams Graphs     #########
	#####################################################
	if {$::rvr_zero_throughput_flag == 1 || $run_test_flag == 0} {

		set wlan_disassociated_flag 0
		set p2p_disassociated_flag 0
		foreach sta_wlan_index $::list_sta_wlan_objects {
			UTF::Message INFO "" "++++++++++++++++++++++++++++++++++STA $sta_wlan_index++++++++++++++++++++++++++++++++++++++++++++"
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && $::array_sta_wlan_disassociated_flag(${sta_wlan_index}) >= 1} {
				set wlan_disassociated_flag 1
			}
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::array_sta_p2p_disassociated_flag(${sta_wlan_index}) >= 1} {
				set p2p_disassociated_flag 1
			}
		}

		set assoc_msg ""
		
		if {$wlan_disassociated_flag == 1} {
			set assoc_msg [concat $assoc_msg "WLAN is NOT associated. "]
		}
		
		if {$p2p_disassociated_flag == 1} {
			set assoc_msg [concat $assoc_msg "$::p2p_display_str is NOT associated. "]
		}

		if {$run_test_flag == 0} {
			set assoc_msg [concat $assoc_msg "Skip running iperf."]
		} else {
			set assoc_msg [concat $assoc_msg "No Throughput."]
		}

		set rc "<font color=\"red\"><b>$assoc_msg</b></font>"
	} else {
		set rc [p2p::create_test_set_streams_graphs $fb_display]
	}

	#####################################################
	######  Write Throughput Result to CVS File  ########
	#####################################################
	if {$::rvr_test_flag == 1} {
		p2p::array_write_csv_data 0 1
	}

	UTF::Message INFO "" "#################################################################"

	return $rc
}

proc p2p::run_all_tests {fb_display fb} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_all_tests***************************"

	UTF::Message INFO "" "::all_tests='$::all_tests'"

	set gc_cnt [llength $::list_gc_wlan_objects]

	UTF::Message INFO "" "------------------------loop 1 ::all_tests='$::all_tests'---------------------------"

	foreach streams_org_test_name $::all_tests {

		UTF::Message INFO "" "streams_org_test_name='$streams_org_test_name'"

		catch {unset ::streams_report_fullname}
		set ::streams_report_fullname {}

		set ::multi_sta_flag 0
		set ::bt_test_flag 0

		# streams_name_list is used to index stream arrays and it must be unique
		# e.g. streams_name_list={P2P:GC->GO WLAN:GC<-LAN}
		catch {unset ::streams_name_list}
		set ::streams_name_list {}

		if {$(run_qos)} {
			##########################
			# QoS
			##########################
			set streams_new_test_name $streams_org_test_name
			UTF::Message INFO "" "Simultaneous QoS iperf streams to run='$streams_new_test_name'"
		} else {
			##########################
			# NON QoS
			##########################
			# For DirectP2P, skip all the WLAN tests
			if {($(ap) == "" || [string first "Direct" $::test_type] != -1) && [regexp -nocase {WLAN:} $streams_org_test_name]} {
				continue
			}

			# For WLAN ONLY tests, skip all the P2P tests
			if {$::wlan_only_flag && [regexp -nocase {P2P:} $streams_org_test_name]} {
				continue
			}

			# For no tx tests, skip all the downstream tests
			if {$(notx) && [regexp -nocase {:RX} $streams_org_test_name]} {
				continue
			}
			# For no rx tests, skip all the upstream tests
			if {$(norx) && [regexp -nocase {:TX} $streams_org_test_name]} {
				continue
			}
			# For no bidrectional tests, skip all the bidrectional tests
			if {$(nobi) && [regexp -nocase {:BI} $streams_org_test_name]} {
				continue
			}

			UTF::Message INFO "" "Simultaneous $::p2p_display_str iperf streams to run='$streams_org_test_name'"

			# insert traffic type and time to run

			set streams_new_test_name [split $streams_org_test_name "]"]

			set tmp_streams_test_name ""

			foreach stream_name $streams_new_test_name {

				regsub -all {:} $stream_name " " stream_name

				foreach {stream_type stream_direction} $stream_name {
					append tmp_streams_test_name "$stream_type\:$(tests_tos)\:$stream_direction\:0\:$(perftime)\]"
				}
			}

			set streams_new_test_name $tmp_streams_test_name
			UTF::Message INFO "" "New Simultaneous $::p2p_display_str iperf streams to run='$streams_new_test_name'"
		}

		# remove the '[' and break the test group into individual iperf streams
		regsub -all {\[} $streams_new_test_name "" streams_new_test_name
		regsub -all {\]} $streams_new_test_name " " streams_new_test_name
		set streams_new_test_name [string trim $streams_new_test_name]

		set streams_new_test_name [split $streams_new_test_name " "]

		# if AP connected to GO, then sta_no is 0 only
		# if AP connected to GCs, then sta_no is 1,2,...		

		# STA number is a part of the data structure and if it is missing then it must be added
		set insert_default_sta_no_flag 0
		foreach stream_name $streams_new_test_name {
			# if sta_no is not passed (the string starts with (WLAN|P2P|BT), then default sta is added for all the GCs
			if {[string first "WLAN" $stream_name] == 0 || [string first "P2P" $stream_name] == 0 || [string first "BT" $stream_name] == 0} {
				set insert_default_sta_no_flag 1
				break
			}
		}
		if {$insert_default_sta_no_flag == 1} {
			UTF::Message INFO "" "Default STA is added in"

			set tmp_streams_test_name ""

			foreach stream_name $streams_new_test_name {

				if {[string first "WLAN" $stream_name] == 0 && $::ap_connect == "GO"} {
					append tmp_streams_test_name "0:$stream_name "
				} else {
					set tmp_cnt 0
					foreach gc_wlan_index $::list_gc_wlan_objects {
						incr tmp_cnt
						append tmp_streams_test_name "$tmp_cnt\:$stream_name "
					}
				}
			}
			
			set streams_new_test_name [string trim $tmp_streams_test_name]
			UTF::Message INFO "" "streams_new_test_name='$streams_new_test_name'"
		}

		# check for bidirectional traffic
		if {[regexp -nocase {:BI:} $streams_new_test_name]} {

			UTF::Message INFO "" "Expand bidirectional stream"

			set streams_new_test_name [split $streams_new_test_name " "]

			set tmp_streams_test_name ""

			foreach stream_name $streams_new_test_name {

				regsub -all {:} $stream_name " " stream_name

				foreach {stream_gc_index stream_type stream_tos stream_direction stream_start_time stream_time_duration} $stream_name {
					if {$stream_direction == "BI"} {
						append tmp_streams_test_name "$stream_gc_index\:$stream_type\:$stream_tos\:BIRX\:$stream_start_time\:$stream_time_duration "
						append tmp_streams_test_name "$stream_gc_index\:$stream_type\:$stream_tos\:BITX\:$stream_start_time\:$stream_time_duration "
					} else {
						append tmp_streams_test_name "$stream_gc_index\:$stream_type\:$stream_tos\:$stream_direction\:$stream_start_time\:$stream_time_duration "
					}
				}
			}

			# e.g. expanded streams_new_test_name="WLAN:VI:BIRX:0:30 WLAN:VI:BITX:0:30 P2P:VI:BIRX:0:30 P2P:VI:BITX:0:30"
			set streams_new_test_name [string trim $tmp_streams_test_name]
			UTF::Message INFO "" "streams_new_test_name='$streams_new_test_name'"
		}

		set streams_new_test_name [split $streams_new_test_name " "]
		set streams_test_name_cnt [llength $streams_new_test_name]

		###############################################################
		######### Build the Report label for group streams ############
		###############################################################

		UTF::Message INFO "" "------------------------loop 2 streams_new_test_name='$streams_new_test_name'---------------------------"

		set stream_cnt 0
		foreach stream_tmp_test_name $streams_new_test_name {

			incr stream_cnt

			regsub -all {:} $stream_tmp_test_name " " stream_tmp_test_name

			UTF::Message INFO "" "------------------------loop 3 stream_tmp_test_name='$stream_tmp_test_name'---------------------------"
			
			foreach {stream_gc_index stream_type stream_tos stream_direction stream_start_time stream_time_duration} $stream_tmp_test_name {

				if {$(aibss)} {
					set sta_cnt [expr {$stream_gc_index - 1}]
					if {$sta_cnt == 0} {
						set endpoint_sta_index 1
					} elseif {$sta_cnt == 1} {
						set endpoint_sta_index 2
					} elseif {$sta_cnt == 2} {
						set endpoint_sta_index 0
					}

					set ::tg_wlan [lindex $::list_gc_wlan_objects $endpoint_sta_index]
					set ::tg_wlan_ifname $::array_sta_wlan_ifname(${::tg_wlan})
					set ::tg_wlan_ip $::array_sta_wlan_ip(${::tg_wlan})
				}
				
				if {$stream_type == "WLAN" && $::ap_connect == "GO"} {
					set curr_wlan $::go_wlan
					set curr_wlan_host_type $::array_sta_host_type(${::go_wlan})
					set curr_wlan_ifname $::array_sta_wlan_ifname(${::go_wlan})
					set curr_wlan_ip $::array_sta_wlan_ip(${::go_wlan})
					set curr_wlan_ipv6_macaddr $::array_sta_wlan_ipv6_macaddr(${::go_wlan})
				} else {
					set curr_wlan [lindex $::list_gc_wlan_objects [expr {$stream_gc_index - 1}]]
					set curr_wlan_host_type $::array_sta_host_type(${curr_wlan})
					set curr_wlan_ifname $::array_sta_wlan_ifname(${curr_wlan})
					set curr_wlan_ip $::array_sta_wlan_ip(${curr_wlan})
					set curr_wlan_ipv6_macaddr $::array_sta_wlan_ipv6_macaddr(${curr_wlan})
				}

				set stream_type [string toupper $stream_type]
				set stream_tos [string toupper $stream_tos]
				set stream_direction [string toupper $stream_direction]

				if {$stream_type == "BT"} {
					
					if {$stream_tos != "A2DP"} {
						incr ::error_cnt
						error "ERROR: 'BT protocol in 'qos_tests' is '$stream_tos' instead of A2DP. Halting tests!" 
					}
					
					set ::bt_test_flag 1
					UTF::Message INFO "" "::bt_test_flag=$::bt_test_flag"
					set stream_direction ""
					set stream_iperf_tos ""
					set stream_throughput_scale ""
					set iperf_bandwidth ""
					set stream_udp_packet_size ""
					set stream_udp_bandwidth ""
				} else {
					switch $stream_tos {
						BK {
							# BK=001->0x20 or 010->0x40 
							set stream_iperf_tos "0x20"
							set stream_throughput_scale "m"
							if {$stream_type == "WLAN"} {
								set stream_udp_packet_size 	$(wlan_packet_size_BK) 
								set stream_udp_bandwidth 	$(wlan_bandwidth_BK)
							} else {
								set stream_udp_packet_size 	$(p2p_packet_size_BK) 
								set stream_udp_bandwidth 	$(p2p_bandwidth_BK)
							}
						}

						BE {
							# BE=000->0x00 or 011->0x60 
							set stream_iperf_tos "0"
							set stream_throughput_scale "m"
							if {$stream_type == "WLAN"} {
								set stream_udp_packet_size 	$(wlan_packet_size_BE) 
								set stream_udp_bandwidth 	$(wlan_bandwidth_BE)
							} else {
								set stream_udp_packet_size 	$(p2p_packet_size_BE) 
								set stream_udp_bandwidth 	$(p2p_bandwidth_BE)
							}
						}

						VI {
							# VI=100->0x80 or 101->0xA0 
							set stream_iperf_tos "0x80"
							set stream_throughput_scale "m"
							if {$stream_type == "WLAN"} {
								set stream_udp_packet_size 	$(wlan_packet_size_VI) 
								set stream_udp_bandwidth 	$(wlan_bandwidth_VI)
							} else {
								set stream_udp_packet_size 	$(p2p_packet_size_VI) 
								set stream_udp_bandwidth 	$(p2p_bandwidth_VI)
							}
						}				

						VO {
							# VO=110->0xC0 or 111->0xE0 
							set stream_iperf_tos "0xc0"
							set stream_throughput_scale "k"
							if {$stream_type == "WLAN"} {
								set stream_udp_packet_size 	$(wlan_packet_size_VO) 
								set stream_udp_bandwidth 	$(wlan_bandwidth_VO)
							} else {
								set stream_udp_packet_size 	$(p2p_packet_size_VO) 
								set stream_udp_bandwidth 	$(p2p_bandwidth_VO)
							}

							if {[regexp {M} $stream_udp_bandwidth]} {
								set stream_throughput_scale "m"
							}
						}

						default {
							# TCP -> BE=000->0x00 or 011->0x60 
							set stream_iperf_tos "0"
							set stream_throughput_scale "m"
							if {$stream_type == "WLAN"} {
								set stream_udp_packet_size 	$(wlan_packet_size_BE) 
								set stream_udp_bandwidth 	$(wlan_bandwidth_BE)
							} else {
								set stream_udp_packet_size 	$(p2p_packet_size_BE) 
								set stream_udp_bandwidth 	$(p2p_bandwidth_BE)
							}
						}
					}

					if {[regexp {BI} $stream_direction]} {
						regexp {^([-+]?[0-9]*\.?[0-9]+)(.)} $stream_udp_bandwidth match iperf_bandwidth scale
						set iperf_bandwidth [expr {$iperf_bandwidth / 2.0}]
						set stream_udp_bandwidth "$iperf_bandwidth$scale"
					}
				}

				if {$stream_type == "BT"} {
					# Speaker<-STA/BT
					UTF::Message INFO "" "BT Stream"			
					set stream_src $(bt_root_sta)
					set stream_src_host_type $::array_sta_host_type(${(bt_root_sta)})
					set stream_src_ifname $::array_sta_wlan_ifname(${(bt_root_sta)})
					set stream_src_ip $::array_sta_wlan_ip(${(bt_root_sta)})
					set stream_src_ipv6_macaddr $::array_sta_wlan_ipv6_macaddr(${(bt_root_sta)})
					set stream_dst ""
					set stream_dst_host_type ""
					set stream_dst_ifname ""
					set stream_dst_ip ""
					set stream_dst_ipv6_macaddr ""

					set stream_iperf_tcpwin_dst ""

					set stream_new_test_name "BT"

					set stream_plot_name_lt 4
					set stream_plot_name_pt 9
					set stream_plot_minmax_name_lt 4
				} else {
					if {$stream_direction == "RX" || $stream_direction == "BIRX"} {
						if {$stream_type == "P2P"} {
							# GC<-GO
							set stream_src $::array_sta_p2p(${::go_wlan})
							set stream_src_host_type $::array_sta_host_type(${::go_wlan})
							set stream_src_ifname $::array_sta_p2p_ifname(${::go_wlan})
							set stream_src_ip $::array_sta_p2p_ip(${::go_wlan})
							set stream_src_ipv6_macaddr $::array_sta_p2p_ipv6_macaddr(${::go_wlan})
							set stream_dst $::array_sta_p2p(${curr_wlan})
							set stream_dst_host_type $::array_sta_host_type(${curr_wlan})
							set stream_dst_ifname $::array_sta_p2p_ifname(${curr_wlan})
							set stream_dst_ip $::array_sta_p2p_ip(${curr_wlan})
							set stream_dst_ipv6_macaddr $::array_sta_p2p_ipv6_macaddr(${curr_wlan})

							set p2p_dir_display [lindex $::p2p_dir_display_list 1]
							if {$(run_qos) || $stream_tos != "TCP"} {
								set stream_new_test_name "$stream_tos\-$::p2p_display_str\:$p2p_dir_display"
							} else {
								set stream_new_test_name "$::p2p_display_str\:$p2p_dir_display"
							}
							set stream_plot_name_lt 13
							set stream_plot_name_pt 11
							set stream_plot_minmax_name_lt 13
						} else {
							# WLAN<-LAN
							set stream_src $::tg_wlan
							set stream_src_host_type $::tg_wlan_host_type
							set stream_src_ifname $::tg_wlan_ifname
							set stream_src_ip $::tg_wlan_ip
							set stream_src_ipv6_macaddr $::tg_wlan_ipv6_macaddr
							set stream_dst $curr_wlan
							set stream_dst_host_type $curr_wlan_host_type
							set stream_dst_ifname $curr_wlan_ifname
							set stream_dst_ip $curr_wlan_ip
							set stream_dst_ipv6_macaddr $curr_wlan_ipv6_macaddr

							set wlan_dir_display [lindex $::wlan_dir_display_list 1]
							if {$(run_qos) || $stream_tos != "TCP"} {
								set stream_new_test_name "$stream_tos\-$::wlan_display_str\:$wlan_dir_display"
							} else {
								set stream_new_test_name "$::wlan_display_str\:$wlan_dir_display"
							}
							set stream_plot_name_lt 1
							set stream_plot_name_pt 11
							set stream_plot_minmax_name_lt 1
						}
					} elseif {$stream_direction == "TX" || $stream_direction == "BITX"} {
						if {$stream_type == "P2P"} {
							# GC->GO
							set stream_src $::array_sta_p2p(${curr_wlan})
							set stream_src_host_type $::array_sta_host_type(${curr_wlan})
							set stream_src_ifname $::array_sta_p2p_ifname(${curr_wlan})
							set stream_src_ip $::array_sta_p2p_ip(${curr_wlan})
							set stream_src_ipv6_macaddr $::array_sta_p2p_ipv6_macaddr(${curr_wlan})
							set stream_dst $::array_sta_p2p(${::go_wlan})
							set stream_dst_host_type $::array_sta_host_type(${::go_wlan})
							set stream_dst_ifname $::array_sta_p2p_ifname(${::go_wlan})
							set stream_dst_ip $::array_sta_p2p_ip(${::go_wlan})
							set stream_dst_ipv6_macaddr $::array_sta_p2p_ipv6_macaddr(${::go_wlan})

							set p2p_dir_display [lindex $::p2p_dir_display_list 2]
							if {$(run_qos) || $stream_tos != "TCP"} {
								set stream_new_test_name "$stream_tos\-$::p2p_display_str\:$p2p_dir_display"
							} else {
								set stream_new_test_name "$::p2p_display_str\:$p2p_dir_display"
							}
							set stream_plot_name_lt 5
							set stream_plot_name_pt 9
							set stream_plot_minmax_name_lt 5
						} else {
							# WLAN->LAN
							set stream_src $curr_wlan
							set stream_src_host_type $curr_wlan_host_type
							set stream_src_ifname $curr_wlan_ifname
							set stream_src_ip $curr_wlan_ip
							set stream_src_ipv6_macaddr $curr_wlan_ipv6_macaddr
							set stream_dst $::tg_wlan
							set stream_dst_host_type $::tg_wlan_host_type
							set stream_dst_ifname $::tg_wlan_ifname
							set stream_dst_ip $::tg_wlan_ip
							set stream_dst_ipv6_macaddr $::tg_wlan_ipv6_macaddr

							set wlan_dir_display [lindex $::wlan_dir_display_list 2]
							if {$(run_qos) || $stream_tos != "TCP"} {
								set stream_new_test_name "$stream_tos\-$::wlan_display_str\:$wlan_dir_display"
							} else {
								set stream_new_test_name "$::wlan_display_str\:$wlan_dir_display"
							}
							set stream_plot_name_lt 3
							set stream_plot_name_pt 9
							set stream_plot_minmax_name_lt 3
						}
					}
				}

				# if we have multiple GCs and more than 1 stream, then insert STA number at the beginning of the plot name
				if {$gc_cnt > 1 && $streams_test_name_cnt > 1} {
					set stream_new_test_name "$stream_gc_index\:$stream_new_test_name"
					set ::multi_sta_flag 1
				}

				set stream_report_name $stream_new_test_name

				##########################################################################################
				#	Important Note:
				#	DUT and GC are the same machine, but when doing iperf for WLAN and P2P from the 
				#	same machine, we need different	names, so iperf results can be differentiated 
				#	between WLAN and P2P. Therefore iperf stream name is appended with stream count at 
				#	the beginning to resolve this issue.
				# 	Also, stream count at the beginning causes unique array index, otherwise the QoS
				#   test streams will have the same array index and overwrite data.
				##########################################################################################
				set stream_new_test_name "$stream_cnt\:$stream_new_test_name"

				# Format: e.g. "2:1:WLAN:STA<-LAN" stream number is 2, STA number is 1
				#regexp -nocase {(^\d+):(\d+):(\S+)} $stream_new_test_name - stream_no stream_sta_no stream_name
				#UTF::Message INFO "" "stream_no=$stream_no stream_sta_no=$stream_sta_no stream_name=$stream_name"

				if {$stream_direction != "BIRX"} {					

					set stream_report_fullname $stream_report_name
					
					if {$stream_direction == "BITX"} {
						# replace "->" with "<>"
						regsub -all {\->} $stream_report_fullname "<>" stream_report_fullname
						UTF::Message INFO "" "Bi-directional stream_report_name '$stream_report_name' is replaced with '$stream_report_fullname'"
					}
					
					if {$::streams_report_fullname != ""} {
						append ::streams_report_fullname "\]\[$stream_report_fullname"
					} else {
						set ::streams_report_fullname "\[$stream_report_fullname"
					}
				}

				set stream_iperf_tcpwin_src [$stream_src cget -tcpwindow]
				if {$stream_dst != ""} {
					# Non BT
					set stream_iperf_tcpwin_dst [$stream_dst cget -tcpwindow]
				}
				
				if {$stream_cnt == 1} {
					UTF::Message INFO "" "delete all the test data arrays"
					p2p::array_setup_test_data "" 1 0
				}
				
				lappend ::streams_name_list "$stream_new_test_name"
				set stream_index $stream_new_test_name

				UTF::Message INFO "" "create the test data arrays"
				p2p::array_setup_test_data $stream_index 0 1
				
				# all data saved in arrays as string
				set stream_sta_no [lsearch -exact $::list_sta_wlan_objects $curr_wlan]
				incr stream_sta_no
				UTF::Message INFO "" "::list_sta_wlan_objects='$::list_sta_wlan_objects' curr_wlan='$curr_wlan' stream_sta_no='$stream_sta_no'"

				set ::array_streams_sta_index_no(${stream_index}) "$stream_sta_no"
				set ::array_streams_type(${stream_index}) "$stream_type"
				set ::array_streams_tos(${stream_index}) "$stream_tos"
				set ::array_streams_direction(${stream_index}) "$stream_direction"
				if {$::roaming_test_flag} {
					if {$stream_start_time != "" || $stream_time_duration != ""} {
						error "qos_tests paramter for roaming should not have 'stream_start_time' and 'stream_time_duration'"
					}
					
					set stream_start_time 0
					set stream_time_duration $::qos_streams_total_time
				} else {
					if {$stream_start_time == "" || $stream_time_duration == ""} {
						error "qos_tests paramters for 'stream_start_time' and/or 'stream_time_duration' are blank"
					}
				}
				set ::array_streams_start_time(${stream_index}) "$stream_start_time"
				set ::array_streams_time_duration(${stream_index}) "$stream_time_duration"
				set ::array_streams_report_name(${stream_index}) "$stream_report_name"

				regsub -all {:} $stream_new_test_name "-" stream_file_name
				regsub -all {<\-} $stream_file_name "RX" stream_file_name
				regsub -all {\->} $stream_file_name "TX" stream_file_name
				regsub -all {<>} $stream_file_name "BI" stream_file_name
				set ::array_streams_file_name(${stream_index}) "$stream_file_name"

				set ::array_streams_plot_name_lt(${stream_index}) "$stream_plot_name_lt"
				set ::array_streams_plot_name_pt(${stream_index}) "$stream_plot_name_pt"
				set ::array_streams_plot_minmax_name_lt(${stream_index}) "$stream_plot_minmax_name_lt"

				set ::array_streams_iperf_cnt(${stream_index}) "$stream_cnt"
				
				set ::array_streams_src(${stream_index}) "$stream_src"
				set ::array_streams_src_host_type(${stream_index}) "$stream_src_host_type"
				set ::array_streams_src_ifname(${stream_index}) "$stream_src_ifname"
				set ::array_streams_src_ip(${stream_index}) "$stream_src_ip"
				set ::array_streams_src_ipv6_macaddr(${stream_index}) "$stream_src_ipv6_macaddr"
				
				set ::array_streams_dst(${stream_index}) "$stream_dst"
				set ::array_streams_dst_host_type(${stream_index}) "$stream_dst_host_type"
				set ::array_streams_dst_ifname(${stream_index}) "$stream_dst_ifname"
				set ::array_streams_dst_ip(${stream_index}) "$stream_dst_ip"
				set ::array_streams_dst_ipv6_macaddr(${stream_index}) "$stream_dst_ipv6_macaddr"
				
				set ::array_streams_iperf_tcpwin_src(${stream_index}) "$stream_iperf_tcpwin_src"					
				set ::array_streams_iperf_tcpwin_dst(${stream_index}) "$stream_iperf_tcpwin_dst"					
				set ::array_streams_iperf_tos(${stream_index}) "$stream_iperf_tos"
				set ::array_streams_throughput_scale(${stream_index}) "$stream_throughput_scale"
				set ::array_streams_udp_packet_size(${stream_index}) "$stream_udp_packet_size"
				set ::array_streams_udp_bandwidth(${stream_index}) "$stream_udp_bandwidth"
			}

			UTF::Message INFO "" "------------------------loop 3 done---------------------------"
		}

		UTF::Message INFO "" "------------------------loop 2 done---------------------------"

		append ::streams_report_fullname "\]"

		p2p::setup_list_active_interface_objects
		set ::list_existing_interface_objects $::list_active_interface_objects
		
		#########################################
		# setup_perf_hook
		#########################################
		p2p::setup_perf_hook

		#####################################################
		###   Change plot colors, if there is a repeat    ###
		#####################################################
		set replace_lt_flag 0
		foreach stream_index1 $::streams_name_list {
			set base_lt $::array_streams_plot_name_lt($stream_index1)

			set repeat_cnt 0
			foreach stream_index2 $::streams_name_list {
				set compare_lt $::array_streams_plot_name_lt($stream_index2)
				if {$base_lt == $compare_lt} {
					incr repeat_cnt
					if {$repeat_cnt > 1} {
						UTF::Message INFO "" "Found repeated plot_name_lt $base_lt"
						set replace_lt_flag 1
						break
					}
				}
			}
			
			if {$replace_lt_flag} {
				break
			}
		}

		if {$replace_lt_flag} {
			set lt_index 0
			foreach stream_index $::streams_name_list {
				UTF::Message INFO "" "Org ::array_streams_plot_name_lt(${stream_index})='$::array_streams_plot_name_lt(${stream_index})'"
				incr lt_index
				set ::array_streams_plot_name_lt(${stream_index}) $lt_index
				UTF::Message INFO "" "New ::array_streams_plot_name_lt(${stream_index})='$::array_streams_plot_name_lt(${stream_index})'"
			}
		}

		# Examples of the data:
		# ::all_tests='{[WLAN:VI:BI:0:30][P2P:VI:BI:0:30]}'
		# streams_org_test_name='[WLAN:VI:BI:0:30][P2P:VI:BI:0:30]'
		# streams_new_test_name='1:WLAN:VI:BIRX:0:30 1:WLAN:VI:BITX:0:30 1:P2P:VI:BIRX:0:30 1:P2P:VI:BITX:0:30'
		# ::streams_name_list='1:VI-WLAN:(STA+GC)<-LAN 2:VI-WLAN:(STA+GC)->LAN 3:VI-P2P:GC<-GO 4:VI-P2P:GC->GO'
		# ::streams_report_fullname='[VI-WLAN:(STA+GC)<>LAN][VI-P2P:GC<>GO]'

		UTF::Message INFO "" "============================================***************Info2***************============================================"
		UTF::Message INFO "" "::all_tests='$::all_tests'"
		UTF::Message INFO "" "streams_org_test_name='$streams_org_test_name'"
		UTF::Message INFO "" "streams_new_test_name='$streams_new_test_name'"
		UTF::Message INFO "" "::streams_name_list='$::streams_name_list'"
		UTF::Message INFO "" "::streams_report_fullname='$::streams_report_fullname'"
		UTF::Message LOG "" "::list_ap_objects=$::list_ap_objects"	
		UTF::Message LOG "" "::list_possible_interface_objects=$::list_possible_interface_objects"	
		UTF::Message LOG "" "::list_existing_interface_objects=$::list_existing_interface_objects"	
		UTF::Message LOG "" "::list_active_interface_objects=$::list_active_interface_objects"
		UTF::Message LOG "" "::list_sta_wlan_objects=$::list_sta_wlan_objects"
		UTF::Message LOG "" "::list_gc_wlan_objects=$::list_gc_wlan_objects"		
		UTF::Message INFO "" "============================================"
		
		#####################################################
		######### Report label for group streams ############
		#####################################################

		if {$(run_qos)} {
			set report_label "$::test_type: $fb_display$::streams_report_fullname"
			set ::graph_label_test "$::test_type: $fb_display"
		} else {
			if {$::wlan_only_flag == 1} {
				set p2p_tmp_str ""				
			} else {
				set p2p_tmp_str "P2PCh=$::p2p_chan"
			}

			if {$::test_type == "SameChan" && $::wlan_chan == $::p2p_chan} {
				set report_label "$::test_type: $::str_ap_connect\APCh=P2PCh=$::wlan_chan: $fb_display$::streams_report_fullname"
				set ::graph_label_test "$::test_type: $::str_ap_connect\APCh=P2PCh=$::wlan_chan: $fb_display"
				UTF::Message INFO "" "SameChan: report_label='$report_label' graph_label_test='$graph_label_test'"
			} else {
				set report_label "$::test_type: $::ap_str$p2p_tmp_str: $fb_display$::streams_report_fullname"
				set ::graph_label_test "$::test_type: $::ap_str$p2p_tmp_str: $fb_display"
				UTF::Message INFO "" "Non-SameChan: report_label='$report_label' graph_label_test='$graph_label_test'"
			}
		}

		#####################################################
		####### control chart key for group streams #########
		#####################################################
		set ::ckey "$::key_base2 $::p2p_chan $(qos_ampdu_mode) $fb"
		set streams_all_key ""
		regsub -all { } $::streams_report_fullname "" streams_all_key
		regsub -all {\-WLAN} $streams_all_key "W" streams_all_key
		regsub -all {\-P2P} $streams_all_key "P" streams_all_key
		regsub -all {\->} $streams_all_key "2" streams_all_key
		regsub -all {<\-} $streams_all_key "3" streams_all_key
		regsub -all {<>} $streams_all_key "1" streams_all_key
		regsub -all {:} $streams_all_key "-" streams_all_key
		set ::ckey "$::ckey $::curr_udp_bandwidth $::curr_udp_packet_size $streams_all_key"

		if {$::agilent_obj != ""} {

			UTF::Try "DTIM Interval Measurement (No Traffic)" {
				UTF::Message INFO "" "15 sec delay to make sure we are idle and the previous test is done with sending packets"  
				UTF::Sleep 15
				foreach STA $::list_sta_wlan_objects {
					catch {$STA wl dtim}
					catch {$STA wl PM}
				}

				set ::cct_key "DTIM No Traffic"
				p2p::measure_dtim_interval					
				return "html: $::current_results"
			}
		
			UTF::Try "Current Measurement (No Traffic)" {
				foreach STA "$::list_active_interface_objects" {
					catch {$STA wl dtim}
					catch {$STA wl PM}
				}
				set ::cct_key "No Traffic"
				p2p::measure_idle_current

				set current_results $::current_results

				UTF::Message INFO "" "**********************************************************************************************"
				UTF::Message INFO "" "**********************Setup instrument for the measurement with traffic***********************"
				p2p::setup_current_measurement_with_traffic

				return "html: $current_results"
			}
		}

		#####################################################
		#######     Setup Sniffer for Non-Roaming    ########
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			UTF::Try "Setup Sniffer Channel $::sniffer_channel" {
				$::sniffer_object setupSniffer $::sniffer_channel
			}
		}

		#########################################
		# PCAP Dump Start
		#########################################
		if {$::macos_pcap_debug_flag} {
			p2p::macos_pcap_debug_dump_start 0
		}

		if {$::rvr_test_flag == 0} {
			#####################################################
			#######          Non RvR or Roaming         #########
			#####################################################

			UTF::Try "$report_label" {
				#####################################################
				#######         Create CSV Data File        #########
				#####################################################
				p2p::setup_csv_header

				#####################################################
				#######             Run This test           #########
				#####################################################
				set ::curr_attn_value 0
				set html_results [p2p::run_test $fb_display 0]

				# check for panic, trap, assert message
				if {[info exists ::UTF::panic]} {
					set ::panic_msg "($::UTF::panic)"
					UTF::Message INFO "A" "::UTF::panic=$::panic_msg"
					set ::test_error_flag 1
				}

				#####################################################
				#######         Create Summary Graphs       #########
				#####################################################
				set graph_err ""
				set catch_resp [catch {p2p::create_summary_graphs} catch_msg]
				if {$catch_resp != 0} {
					# failed
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					set ::test_error_flag 1
					# html conversion 
					set tmp [string map {< "&lt;" > "&gt;" & "&amp;"} $catch_msg]
					append html_results "&nbsp;&nbsp;<blink><font color=\"red\"><b>$tmp</b></font></blink>"
				} else {
					set html_results "$html_results"				
				}

				if {$::roaming_test_flag == 1} {
					set ::roaming_html_results $html_results				
					UTF::Message LOG "" "Saved roaming html_results='$::roaming_html_results'"
				}

				if {$::test_error_flag == 0} {
					return "html: $html_results"
				} else {
					error "html: $html_results"
				}
			}
		} else {
			#####################################################
			#######                 RvR                 #########
			#####################################################

			if {$(attn_type) == 1} {
				set ::attn_type_label "RvR-WLAN: "
			} elseif {$(attn_type) == 2} {
				if {$::nan2_flag} {
					set ::attn_type_label "RvR-NAN: "
				} elseif {$::awdl_flag} {
					set ::attn_type_label "RvR-AWDL: "
				} else {		
					set ::attn_type_label "RvR-P2P: "
				}
			} elseif {$(attn_type) == 3} {
				if {$::nan2_flag} {
					set ::attn_type_label "RvR-WLAN&NAN: "
				} elseif {$::awdl_flag} {
					set ::attn_type_label "RvR-WLAN&AWDL: "
				} else {				
					set ::attn_type_label "RvR-WLAN&P2P: "
				}
			}

			set test_title "$::attn_type_label$report_label"
			set ::graph_label_test "$::attn_type_label$::graph_label_test"

			UTF::Try "$test_title" {
				#####################################################
				#######           Run This RvR test         #########
				#####################################################
				set ::curr_attn_value -1
				set rvr_html_results [p2p::run_rvr_test $fb_display]

				if {$::test_error_flag == 0} {
					return "html: $rvr_html_results"
				} else {
					error "html: $rvr_html_results"
				}
			}
		}

		# check for panic, trap, assert message
		if {[info exists ::UTF::panic]} {
			set ::panic_msg "($::UTF::panic)"
			UTF::Message INFO "E" "::UTF::panic=$::panic_msg"
			set ::test_error_flag 1
		}

		#########################################
		# PCAP Dump Stop
		#########################################
		if {$::macos_pcap_debug_flag} {
			p2p::macos_pcap_debug_dump_stop
		}

		p2p::get_dhd_memory_dump

		if {$::connection_test_flag == 1} {
			set ::connection_test_flag 0
			UTF::Message INFO "" "connection_test after each test"
			p2p::connection_test
		}

		p2p::get_dhd_memory_dump

		#####################################################
		##############    Get Sniffer Data   ################
		#####################################################
		if {$::roaming_test_flag == 0 && $::sniffer_object != ""} {
			if {$::sniffer_started_flag} {
				$::sniffer_object stop $::sniffer_process_id
				set ::sniffer_started_flag 0
				UTF::Message INFO "" "###########################Sniffer Stopped After Throughput Run######################################"
			}
		
			p2p::get_sniffer_data
		}

		if {$::panic_msg != "" || [info exists ::UTF::panic]} {
			UTF::Message INFO "" "Break due to ::panic_msg=$::panic_msg"
			break
		}

		if {$::error_cnt > 0 && $::halt_test_err != ""} {
			break
		}

		if {$(quick_exit)} {

			UTF::Try "Debug Info" {
				foreach interface_object $::list_existing_interface_objects {
					catch {$interface_object wl out}
					UTF::Message INFO "" "ooooooooooooooooooooooooooooooooooooooooooooooooooo"
				}
			}

			exit
		}

		if {$::bt_test_flag} {
			#####################################################
			##########    Stop BT iTune wav Play    #############
			#####################################################
			p2p::bt_itune_stop
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}
		
		# end of foreach streams_org_test_name - one group of simultaneous streams finished. Go to next group
	}

	UTF::Message INFO "" "------------------------loop 1 done---------------------------"

	if {$::agilent_obj != ""} {

		UTF::Try "DTIM Interval Measurement (No Traffic)" {
			UTF::Message INFO "" "15 sec delay to make sure we are idle and the previous test is done with sending packets"  
			UTF::Sleep 15
			foreach STA $::list_sta_wlan_objects {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}

			set ::cct_key "DTIM No Traffic"
			p2p::measure_dtim_interval					
			return "html: $::current_results"
		}
		
		UTF::Try "Current Measurement (No Traffic)" {
			foreach STA "$::list_active_interface_objects" {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}
			set ::cct_key "No Traffic"
			p2p::measure_idle_current					
			return "html: $::current_results"
		}
	}
}

proc p2p::process_all_tests {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:process_all_tests***************************"

	if {$(fb0) && $(fb1)} {
		set frameburst_list "1 0"
	} elseif {$(fb0)} {
		set frameburst_list "0"
	} elseif {$(fb1)} {
		set frameburst_list "1"
	} else {
		set frameburst_list "BLANK"
	}
	
	if {$(aibss)} {
		set ::wlan_dir_display_list "None STA<-STA STA->STA STA<>STA"
	} elseif {$::wlan_only_flag == 1} {
		set ::wlan_dir_display_list "None STA<-LAN STA->LAN STA<>LAN"
	} else {
		set ::wlan_dir_display_list "None $::str_ap_connect\<-LAN $::str_ap_connect\->LAN $::str_ap_connect\<>LAN"
	}
	#set ::wlan_dir_list "nowlan tg2dut dut2tg wlanbid"

	if {$::awdl_flag && $::use_wl_for_mac == 0} {
		set ::p2p_dir_display_list "None AWDL<-PEER AWDL->PEER AWDL<>PEER"
	} elseif {$::awdl_flag || $::nan2_flag} {
		set ::p2p_dir_display_list "None Slv<-Mst Slv->Mst Slv<>Mst"
	} else {
		set ::p2p_dir_display_list "None GC<-GO GC->GO GC<>GO"
	}
	#set ::p2p_dir_list "nop2p go2gc gc2go p2pbid"

	#####################################################################
	# For with and without frameburst
	#####################################################################
	UTF::Message LOG "" "4##########################################################################################################"
	UTF::Message LOG "" "4##### foreach frameburst_list=$frameburst_list"
	UTF::Message LOG "" "4##########################################################################################################"
	foreach fb $frameburst_list {

		UTF::Message LOG "" "4=========================================================================================================="
		UTF::Message LOG "" "--->Process frameburst='$fb'"
		UTF::Message LOG "" "4=========================================================================================================="

		if {$frameburst_list != "BLANK"} {
			UTF::Try "Frameburst $fb" {
				UTF::Message INFO "" "Set the frameburst"
				if {$::p2p_load_flag} {
					$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) frameburst $fb
					$::go_wlan wl -i $::array_sta_p2p_ifname(${::go_wlan}) frameburst
					foreach gc_wlan_index $::list_gc_wlan_objects {
						$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) frameburst $fb
						$gc_wlan_index wl -i $::array_sta_p2p_ifname(${gc_wlan_index}) frameburst
					}
					$::go_wlan wl frameburst $fb
					$::go_wlan wl frameburst
				}

				foreach gc_wlan_index $::list_gc_wlan_objects {
					$gc_wlan_index wl frameburst $fb
					$gc_wlan_index wl frameburst
				}

				if {$::wlan_ap != ""} {
					$::wlan_ap wl frameburst $fb
					$::wlan_ap wl frameburst
				}
				
				return ""
			}
		}

		if {$fb == 1} {
			set fb_display "FB=1: "
		} elseif {$fb == 0} {
			set fb_display "FB=0: "
		} else {
			set fb_display ""
			set fb ""
		}

		#####################################################
		#######            Run All Tests            #########
		#####################################################
		p2p::run_all_tests $fb_display $fb
		
		# end of foreach fb
		UTF::Message LOG "" "4 done frameburst='$fb'=========================================================================================================="
	}
	
	UTF::Message LOG "" "4 done foreach fb##########################################################################################################"
}

proc p2p::round_control_chart_stream_data {stream_data_list} {
	
	UTF::Message INFO "" "************************round_control_chart_stream_data***************************"

	set new_control_chart_data ""
	
	foreach data $stream_data_list {
		set new_data [expr {round($data)}]
		set new_control_chart_data [concat $new_control_chart_data $new_data]
	}
	
	return $new_control_chart_data
}

proc p2p::total_control_chart_stream_data {stream_data_list} {
	
	UTF::Message INFO "" "************************total_control_chart_stream_data***************************"

	set total_control_chart_data 0
	
	foreach data $stream_data_list {
		set total_control_chart_data [expr {$total_control_chart_data + $data}]
	}
	
	return $total_control_chart_data
}

proc p2p::build_control_chart_stream_data {stream_data_list} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************build_control_chart_stream_data***************************"

	set stream_data_cnt [llength $stream_data_list]
	UTF::Message INFO "" "stream_data_cnt=$stream_data_cnt"

	# max UTF control chart sample size is 25
	set utf_control_chart_sample_size 25
	set new_control_chart_data ""
	# if we have more data samples, then we need to integrate them
	if {$stream_data_cnt > $utf_control_chart_sample_size} {

		UTF::Message INFO "" "More than 25 data sample. Integrate them to 3 data sample"
		
		# How many data values needs to be averaged/integrated?

		# change the utf control chart scale
		set utf_control_chart_sample_size 3
		
		set average_data_cnt [expr {$stream_data_cnt / $utf_control_chart_sample_size}]
		UTF::Message INFO "" "average_data_cnt=$average_data_cnt"
		
		# math::integrate requires min 5 data points. It must be even number
		# average_data_cnt is at least 5 since we have more than 25 samples
		
		# is average_data_cnt even?
		if {[expr {$average_data_cnt % 2}] == 1} {
			set average_data_cnt [expr {$average_data_cnt - 1}]
			UTF::Message INFO "" "use even number average_data_cnt=$average_data_cnt"
		}
		
		UTF::Message INFO "" "================"

		set group_data_cnt 0
		set group_data_list ""
		foreach data [split $stream_data_list " "] {
			#UTF::Message INFO "" "data=$data"
			set group_data_list [concat $group_data_list "$group_data_cnt $data"]
			incr group_data_cnt
			#UTF::Message INFO "" "group_data_cnt=$group_data_cnt"

			if {$group_data_cnt == $average_data_cnt} {
				UTF::Message INFO "" "group_data_list=$group_data_list"
				set tmp [lindex [::math::integrate $group_data_list] 0]
				set integrated_data [format %0.1f [expr {$tmp / $average_data_cnt}]]
				UTF::Message INFO "" "integrated_data=$integrated_data"
				UTF::Message INFO "" "group_data_cnt=$group_data_cnt"
				set new_control_chart_data [concat $new_control_chart_data $integrated_data]
				UTF::Message INFO "" "new_control_chart_data=$new_control_chart_data"
				UTF::Message INFO "" "================"
				if {[llength $new_control_chart_data] == $utf_control_chart_sample_size} {
					break
				}
				set group_data_cnt 0
				set group_data_list ""
			}
		}
	} else {
		set new_control_chart_data $stream_data_list
	}
	
	return $new_control_chart_data
}

proc p2p::process_test_set_streams_results {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:process_test_set_streams_results***************************"

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	
	if {$::agilent_obj != ""} {
		UTF::Message INFO "" "Get Agilent Current"
		set current_measure_start_time_secs [clock seconds]

		UTF::Message INFO "" "wait $(current_wait_sec) for the iperf to run, before Agilent starts reading the current data"
		UTF::Sleep $(current_wait_sec)
		
		set ::cct_key "With Traffic"
		p2p::measure_current_with_traffic					

		set current_measure_time_elapsed_secs [expr {[clock seconds] - $current_measure_start_time_secs}]
		UTF::Message INFO "" "current_measure_time_elapsed_secs=$current_measure_time_elapsed_secs"
		
		set timeout_sec [expr {round([expr {$::qos_streams_total_time + 1 - $current_measure_time_elapsed_secs}])}]	
		UTF::Message INFO "" "time left=$timeout_sec"
		
		if {$timeout_sec < 0} {
			set timeout_sec 1
			UTF::Message INFO "" "time left=$timeout_sec"
		}
	} else {
		set timeout_sec [expr {$::qos_streams_total_time}]
	}

	if {$::roaming_test_flag} {
		#####################################################
		#######               Roaming               #########
		#####################################################

		UTF::Message INFO "" "========================Roaming==========================="

		# sniffer stages:
		# 	0 = start
		# 	1 = started
		# 	2 = wait
		# 	3 = stop
		# 	4 = stopped
		# 	5 = move sniffer data
		set sniffer_stage 0

		set pid_sniffer 0		
		set ::roamed_flag 0

		# for raoming, the first GC is only used
		set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

		set hook_start_time_secs [clock seconds]

		set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_pcap_file ".pcap"
		set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_csv_file ".csv"

		# Start roaming attenuation

		set src_ap_attn_val $::roaming_src_ap_attn_start
		set dst_ap_attn_val $::roaming_dst_ap_attn_start

		for {set loop_cnt 0} {$loop_cnt < $::roaming_max_loop_cnt} {incr loop_cnt} {

			set hook_start_time_ms [clock clicks -milliseconds]
			UTF::Message INFO "" "hook_start_time_ms=$hook_start_time_ms"
		
			if {!$::failover_test_flag} {

				# set smooth roaming attenuation
				$::roaming_src_ap_attn_group attn $src_ap_attn_val
				$::roaming_dst_ap_attn_group attn $dst_ap_attn_val
			} else {
				# set failover roaming attenuation
				switch $loop_cnt {
					0 {
						$::roaming_src_ap_attn_group attn $src_ap_attn_val
						$::roaming_dst_ap_attn_group attn $::max_attn
					}

					3 {
						# from AP goes away suddenly
						$::roaming_src_ap_attn_group attn $::max_attn
						$::roaming_dst_ap_attn_group attn $dst_ap_attn_val
					}
				}
			}

			set bssid ""
			set rssi ""
			set catch_resp [catch "$sta_wlan_index wl rssi" rssi]
			set catch_resp [catch "$sta_wlan_index wl bssid" bssid]

			# current_time
			set time_ms [format "%2.3f" [expr {[clock clicks -milliseconds] / 1000.0}]]
			set parts [split $time_ms "."]
			set round_down [lindex $parts 0]
			set fraction [lindex $parts 1]
			set current_time [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
			set current_time "$current_time.$fraction"
			# ---------------

			UTF::Message LOG "" "================== current_time=$current_time loop_cnt=$loop_cnt src_ap_attn_val=$src_ap_attn_val dst_ap_attn_val=$dst_ap_attn_val rssi=$rssi bssid=$bssid ======================="

			if {$::roamed_flag == 0 && $bssid == $::roaming_dst_ap_mac} {
				UTF::Message LOG "" "***********************************************************************************"
				UTF::Message LOG "" "************************************ ROAMED ***************************************"
				UTF::Message LOG "" "***********************************************************************************"

				set ::roamed_flag 1
				set ::wlan_ap [lindex $::list_ap_objects 1]
				UTF::Message LOG "" "::wlan_ap=$::wlan_ap"

				if {!$::failover_test_flag} {

					# for smooth roaming only, estimate the sniffer start value

					set start_val [expr {int($src_ap_attn_val) - 3}]

					UTF::Message LOG "" "Actual sniffer start attenuation value = $start_val"
					UTF::Message LOG "" "Parameter sniffer start attenuation value = $::roaming_sniffer_start_attn"
					if {$::roaming_sniffer_start_attn == ""} {
						set ::roaming_sniffer_start_attn $start_val
					}
				}

				if {$sniffer_stage == 0} {
					UTF::Message ERROR "" "***Failed. Roamed but sniffer is not started."
					set ::roaming_sniffer_failed_flag 1
					set ::roaming_sniffer_failed_msg "Roamed but sniffer is not started"
				}
			}

			if {($::failover_test_flag && $loop_cnt == $sniffer_failover_start_cnt) || ((!$::failover_test_flag) && $sniffer_stage == 0 && $::roaming_sniffer_start_attn != "" && $src_ap_attn_val >= $::roaming_sniffer_start_attn)} {

				UTF::Message LOG "" "*************************** Roaming Start Sniffer *****************************"

				# sniffer started
				set sniffer_stage 1

				set catch_resp [catch {$::sniffer_object startRoamCmdline "/root/bin/tshark_cmd_line"} catch_msg]
				if {$catch_resp != 0} {
					UTF::Message LOG "" "***Failed. Sniffer did not start"
					set pid_sniffer 0
					set ::roaming_sniffer_failed_flag 1
					set ::roaming_sniffer_failed_msg "Sniffer did not start"
				} else {
					UTF::Message LOG "" "PASS. Sniffer is started"
					set pid_sniffer $catch_msg
				}
				catch {$::sniffer_object ls -la /root/bin/$roaming_sniffer_pcap_file}
			} else {
				UTF::Message INFO "" "--------------------------------SNIFFER DEBUG----------------------------------"  
				if {$pid_sniffer > 0} {
					if {$sniffer_stage == 1 || $sniffer_stage == 2 || $sniffer_stage == 3} {

						set catch_resp [catch "exec ps -ef | grep \"iperf\"" catch_msg]					
						UTF::Message INFO "" "ps -ef catch_msg=$catch_msg"

						#set catch_resp [catch "$::sniffer_object rexec ps -ef" catch_msg]
						#UTF::Message INFO "" "$::sniffer_object ps -ef catch_msg=$catch_msg"

						set catch_resp [catch "$::sniffer_object rexec ps $pid_sniffer" catch_msg]
						UTF::Message INFO "" "$::sniffer_object ps tshark catch_msg=$catch_msg"

						if {[regexp -nocase "tshark" $catch_msg]} {
							UTF::Message INFO "" "Sniffer is collecting data"  
						} else {
							UTF::Message INFO "" "Sniffer is NOT running"  
							set ::roaming_sniffer_failed_flag 1
							set ::roaming_sniffer_failed_msg "Sniffer is NOT running"
						}

						catch {$::sniffer_object ls -la /root/bin/$roaming_sniffer_pcap_file}

						$::sniffer_object wl ver
					}
				}
				UTF::Message INFO "" "-----------------------------------------------------------------------"  

				# stop the sniffer if it is not already stopped
				if {$sniffer_stage != 3} {

					# stop the sniffer when we are roamed
					if {$bssid == $::roaming_dst_ap_mac} {

						#************************************ ROAMED ***************************************"

						if {$sniffer_stage == 1} {
							# sniffer wait
							set sniffer_stage 2
							UTF::Message LOG "" "******************* sniffer_stage == 2 (Roamed, wait 1 step) *********************"
						} elseif {$sniffer_stage == 2} {
							# sniffer wait
							set sniffer_stage 3
							UTF::Message LOG "" "******************* sniffer_stage == 3 (Roamed, wait 1 step) *********************"
						} elseif {$sniffer_stage == 3} {
							# sniffer stop
							set sniffer_stage 4
							# only stop the sniffer. do not bring over sniffer file since it takes time
							catch {$::sniffer_object stopall}

							UTF::Message LOG "" "******************* sniffer_stage == 4 (Stopped Sniffer) *********************"
						}
					}
				} else {
					# roaming / sniffer is done
					# do not break from the loop, otherwise the graphs x-axis will not be right
				}
			}

			#########################################
			# Process post_perf_hook
			#########################################
			p2p::process_perf_hook post_perf_hook 1 1
			
			UTF::Message INFO "" "---------------------------------------------------------------"

			if {!$::failover_test_flag} {

				# attenuation changes will only happen for smooth roaming

				if {$src_ap_attn_val < $::roaming_src_ap_attn_end} {
					incr src_ap_attn_val
				}

				if {$dst_ap_attn_val > $::roaming_dst_ap_attn_end} {
					set dst_ap_attn_val [expr {$dst_ap_attn_val - 1}]
				}

				if {$dst_ap_attn_val < 0} {
					set dst_ap_attn_val 0
				}

				if {[expr {$loop_cnt + 1}] == $::roaming_max_loop_cnt && $::roamed_flag == 0} {
					# still not roamed and this is the end of the loop
					# rssi values are not exact calculations, therefore increase the loop count

					if {$loop_cnt < 40} {
						set loop_cnt [expr {$loop_cnt + 5}]
					}
				}
			}

			set hook_time_elapsed_ms [expr {[clock clicks -milliseconds] - $hook_start_time_ms}]
			UTF::Message INFO "" "hook_time_elapsed_ms=$hook_time_elapsed_ms"

			set dwell_time_ms [expr {$::roaming_dwell_time_sec * 1000.0}]
			
			set dwell_time_left_ms [expr {$dwell_time_ms - $hook_time_elapsed_ms}]	

			if {$dwell_time_left_ms < 0} {
				set dwell_time_left_ms 0
				UTF::Message INFO "" "NEW dwell_time_left_ms=$dwell_time_left_ms"
			}

			set dwell_time_left_ms [format "%2.3f" [expr {$dwell_time_left_ms / 1000.0}]]
			UTF::Message INFO "" "dwell_time_left_ms=$dwell_time_left_ms"

			UTF::Sleep $dwell_time_left_ms
		}

		# stop the sniffer if still running
		if {$sniffer_stage == 1 || $sniffer_stage == 2 || $sniffer_stage == 3 || $sniffer_stage == 4} {
			UTF::Message LOG "" "******************* exit sniffer *********************"
			# sniffer stopped
			set sniffer_stage 5
			p2p::roaming_stop_sniffer
			UTF::Message LOG "" "******************* sniffer_stage == 5 (Moved Sniffer Data) *********************"
		}

		set hook_time_elapsed_secs [expr {[clock seconds] - $hook_start_time_secs}]
		UTF::Message INFO "" "hook_time_elapsed_secs=$hook_time_elapsed_secs"

		set timeout_sec [expr {round([expr {$::qos_streams_total_time + 1 - $hook_time_elapsed_secs}])}]	
		UTF::Message INFO "" "time left=$timeout_sec"

		if {$timeout_sec < 1} {
			set timeout_sec 1
		}

		UTF::Message INFO "" "************************last post_perf_hook***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		p2p::process_perf_hook post_perf_hook 0 0
		
	} else {
		#####################################################
		#######  Non Roaming (RvR and regular test) #########
		#####################################################

		set rsdb_switch_test_stage 0
		set hook_start_time_secs [clock seconds]

		set get_cpu_stat_flag 1

		while {1} {
			set time1_ms [clock clicks -milliseconds]

			set timestamp [clock format [clock seconds] -format "%H:%M:%S"]

			UTF::Message INFO "" "------------------------$timestamp---------------------------"

			if {$(no_wl_dump)} {
				UTF::Message INFO "" "Do not dump any wl data while running throughput"
				break
			}
			
			#########################################
			# Process post_perf_hook
			#########################################
			# for regular test, run post_perf_hook here
			# for rvr test, run post_perf_hook at the end in orfer to have correct AP mpdu values
			if {$::rvr_test_flag == 0} {
				p2p::process_perf_hook post_perf_hook 1 1
			}

			UTF::Message INFO "" "---------------------------------------------------------------"

			#####################################################
			##############      Stop Sniffer     ################
			#####################################################
			if {$::sniffer_started_flag} {
				set sniffer_time_elapsed_secs [expr {[clock seconds] - $::sniffer_start_time_secs}]
				if {$sniffer_time_elapsed_secs >= $::sniffer_capture_time_sec} {
					$::sniffer_object stop $::sniffer_process_id
					set sniffer_timestamp [clock format [clock seconds] -format "%H:%M:%S"]
					UTF::Message INFO "" "###########################Sniffer Stopped @ '$sniffer_timestamp'######################################"
					set ::sniffer_started_flag 0
				}
			}

			set time2_ms [clock clicks -milliseconds]
			set loop_time_ms [expr {$time2_ms - $time1_ms}]
			# it could takes up to 5 sec for all the post_perf_hook commands to process.
			# make sure that we at least stayed in the loop for 2 sec
			if {$loop_time_ms < 2000} {
				set delay_ms [format "%2.3f" [expr {[expr {2000.0 - $loop_time_ms}] / 1000.0}]]
				UTF::Sleep $delay_ms
			}

			set hook_time_elapsed_secs [expr {[clock seconds] - $hook_start_time_secs}]
			UTF::Message INFO "" "hook_time_elapsed_secs=$hook_time_elapsed_secs"

			if {$get_cpu_stat_flag == 1 && $hook_time_elapsed_secs > 10} {
				# dump CPU stat after 10 sec.
				foreach sta_wlan_index $::list_sta_wlan_objects {
					UTF::Message INFO "" "###########################$sta_wlan_index mpstat -P ALL######################################"
					set get_cpu_stat_flag 0
					set catch_resp [catch {$sta_wlan_index mpstat -P ALL} catch_msg]
				}
			}

			set timeout_sec [expr {round([expr {$::qos_streams_total_time + 1 - $hook_time_elapsed_secs}])}]	
			UTF::Message INFO "" "time left=$timeout_sec"

			if {$timeout_sec <= 3} {
				if {$timeout_sec < 1} {
					set timeout_sec 1
				}
				UTF::Message INFO "" "time left=$timeout_sec"
				break
			}

			if {$::rvr_test_flag == 1} {
				# for RvR test, we need to run the post_perf_hook only once
				break
			}

			if {$::rsdb_switch_test_flag} {
				if {$::ap_connect == "GO"} {
					set object $::go_wlan
					set object_ifname $::array_sta_wlan_ifname(${::go_wlan})
				} else {
					# for this special rsdb_switch_test, the first GC is only used
					set sta_wlan_index [lindex $::list_gc_wlan_objects 0]
					set object $sta_wlan_index
					set object_ifname $::array_sta_wlan_ifname(${sta_wlan_index})
				}
				if {$hook_time_elapsed_secs > 120 && $rsdb_switch_test_stage == 0} {
					UTF::Message INFO "" "###########################rsdb_switch_test######################################"
					UTF::Message INFO "" "rsdb_switch_test_stage=$rsdb_switch_test_stage"					
					#set catch_resp [catch {$object wl rsdb_mode} catch_msg]
					#UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"	
					set nrate [p2p::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "1x9"} {
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 1x9 instead of $nrate"
						set ::test_error_flag 1
						append ::streams_total_error "(rsdb_switch nrate != 1x9)"
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=1x9"					
					}
					set rsdb_switch_test_stage 1
					set catch_resp [catch {$object wl rsdb_switch} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					UTF::Sleep 5
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set nrate [p2p::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "2x9"} {
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 2x9 instead of $nrate"
						set ::test_error_flag 1
						append ::streams_total_error "(rsdb_switch nrate != 2x9)"
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=2x9"					
					}
				}
				if {$hook_time_elapsed_secs > 240 && $rsdb_switch_test_stage == 1} {
					UTF::Message INFO "" "###########################rsdb_switch_test######################################"
					UTF::Message INFO "" "rsdb_switch_test_stage=$rsdb_switch_test_stage"					
					set rsdb_switch_test_stage 2
					set catch_resp [catch {$object wl rsdb_switch} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					UTF::Sleep 5
					set catch_resp [catch {$object wl -i $object_ifname nrate} catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"					
					set nrate [p2p::parse_nrate $catch_msg]
					regsub -all {\[} $nrate "" nrate
					regsub -all {\]} $nrate "" nrate
					UTF::Message INFO "" "nrate=$nrate"
					if {$nrate != "1x9"} {
						UTF::Message ERROR "" "***Failed. rsdb_switch - expected nrate of 1x9 instead of $nrate"
						set ::test_error_flag 1
						append ::streams_total_error "(rsdb_switch nrate != 1x9)"
					} else {
						UTF::Message INFO "" "Pass. rsdb_switch nrate=1x9"					
					}
				}
			}
		}
	}

	set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	UTF::Message INFO "" "timestamp2=$timestamp"
	
	UTF::Message INFO "" "###########################THROUGHPUT DATA######################################"
	set stream_ids [p2p::get_stream_ids]
	if {$stream_ids != ""} {
		# using ::qos_streams_total_time sec timeout. If data is ready sooner, then it will not wait this long and comes back immediately
		# if we transmit data for n sec and there are stalls, then the receiver data could be for much longer time than n sec
		# Added 10 sec extra pad for BT since there was no pad time and it was returning no data
		set wait_time [expr $::qos_streams_total_time + 10]
		p2p::collect_rpopen_data $wait_time $stream_ids resp1 "" resp2
	}

	set ::iperf_running_flag 0

	set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	UTF::Message INFO "" "timestamp3=$timestamp"

	if {!$(no_wl_dump) && $::rvr_test_flag == 1} {
		UTF::Message INFO "" "************************last post_perf_hook for RvR to write the data and enable scanning for re-assoc***************************"
		p2p::process_perf_hook post_perf_hook 0 1
	} elseif {!$(no_wl_dump) && $::roaming_test_flag == 0} {
		# For regular and RvR tests:
		# For non-RvR to have uniform x-axis time interval, do not save this post data. 
		# MUST run it in order to enable scanning otherwise P2P cannot re-associate
		UTF::Message INFO "" "************************last post_perf_hook (without saving) to enable scanning for re-assoc***************************"
		#########################################
		# Process post_perf_hook
		#########################################
		p2p::process_perf_hook post_perf_hook 0 0
	}

	set tot_throughputs ""
	set throughput_scale ""
	set any_throughput_data_flag 0
	set bt_throughput_cnt 0

	# find the first stream time
	set first_stream_name [lindex $::streams_name_list 0]
	UTF::Message INFO "" "first_stream_name=$first_stream_name"
	set first_stream_time_secs $::array_streams_start_stream_time_secs($first_stream_name)
	UTF::Message INFO "" "first_stream_time_secs=$first_stream_time_secs"

	# Notice:
	# UDP latency data for throughput stalls are "-/-/-/-" which needs to be converted to zeros
	# 10:48:34 RX_4:VI-AWDL:AWDL->PEER [  3] 7.00-8.00 sec  0.00 MBytes  0.00 Mbits/sec   0.000 ms    0/    0 (0%) -/-/-/- ms    0 pps
	
	UTF::Message INFO "" "###########################THROUGHPUT DATA with Info######################################"
	foreach line $resp1 {
		UTF::Message INFO "" "$line"
	}
	UTF::Message INFO "" "#################################################################"
	
	# get samples for the control chart
	# take all the data from P2P and WLAN and put them in the correct host arry
	#	array(4360-P2P-GC)
	#	array(4360-P2P-GO)
	#	array(4360-WLAN-GC)
	#	array(lan)
	foreach line $resp1 {
		set time ""
		set stream_index 0
		set interval_start_time ""
		set interval_end_time ""
		set throughput 0
		set throughput_scale ""
		
		set tcp_writes ""
		set tcp_errors ""
		set tcp_retries ""
		set tcp_used_memory ""
		set tcp_used_memory_scale ""
		set tcp_rtt ""
		 
		set udp_jitter ""
		set udp_lost_packets ""
		set udp_packet_total ""
		set udp_lost_packets_percent ""
		set udp_latency_avg ""
		set udp_latency_min ""
		set udp_latency_max ""
		set udp_latency_stdev ""
		set udp_pps ""
		set out_of_order_packets 0

		set bt_throughput_flag 0

		UTF::Message INFO "" "$line"

		# For TX lines:
		# 	Process tx totals
		#	For TCP, process 'TCP retries', 'memory consumed for the traffic in Kilobytes', and 'RTT in microseconds'
		# Skip the rest of the TX data since we process the RX lines
		
		if {[regexp " TX_" $line]} {
			#17:22:22 TX_1:VI-WLAN:(STA+GO)<-LAN [  3]  0.0-300.0 sec   715 MBytes  20.0 Mbits/sec
			#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         udp_jitter                 udp_packet_loss        /     udp_packet_total              udp_lost_packets_percent
			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+).*\(([-+]?[0-9]*\.?[0-9]+)%\)} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets udp_packet_total udp_lost_packets_percent]
			if {$rc == 0} {
				# lost_packets_percent could be a string and not a value

				set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+).*\((\S+)%\)} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets udp_packet_total udp_lost_packets_percent]
				if {$rc != 0} {
					# set the lost_packets_percent to max value
					set lost_packets_percent 100
				} else {
					# try for a TCP response:
					# 16:27:08 TX_4:TCP-AWDL:AWDL->PEER [ ID] Interval        Transfer    Bandwidth       Write/Err  Rtry    Cwnd/RTT
					# 16:27:08 TX_4:TCP-AWDL:AWDL->PEER [  3] 0.00-1.00 sec  7.52 MBytes  63.0 Mbits/sec  962/0          6      347K/421875 us
					#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         Write               /         Err                      Rtry                      Cwnd         Cwnd_scale /           RTT
					set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?([-+]?[0-9]*\.?[0-9]+) +?([-+]?[0-9]*\.?[0-9]+) *?(.) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?us} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale tcp_writes tcp_errors tcp_retries tcp_used_memory tcp_used_memory_scale tcp_rtt]
				}
			}

			if {$rc == 0} {continue}

			# remove the "TX_" from the beginning
			set stream_index [string replace $stream_index 0 2 ""]

			UTF::Message LOG "" "TX: stream_index=$stream_index interval_start_time=$interval_start_time interval_end_time=$interval_end_time Throughput=$throughput throughput_scale=$throughput_scale tcp_writes=$tcp_writes tcp_errors=$tcp_errors tcp_retries=$tcp_retries tcp_used_memory=$tcp_used_memory tcp_used_memory_scale=$tcp_used_memory_scale tcp_rtt=$tcp_rtt"

			if {[expr {$interval_end_time - $interval_start_time}] > $::perfint} {
				# end of iperf msg shows totals
				UTF::Message INFO "" "TX Total: $line"
				set ::array_streams_tx_stream_time_secs(${stream_index}) $interval_end_time
			} else {
				# For TCP, save the TCP data

				# check for bad stall data
				if {$tcp_rtt < 0} {
					UTF::Message INFO "" "changing bad tcp_rtt=$tcp_rtt to zero"
					set tcp_rtt "0" 
				}
				if {$tcp_writes < 0} {
					UTF::Message INFO "" "changing bad tcp_writes=$tcp_writes to zero"
					set tcp_writes "0" 
				}
				if {$tcp_errors < 0} {
					UTF::Message INFO "" "changing bad tcp_errors=$tcp_errors to zero"
					set tcp_errors "0" 
				}
				if {$tcp_retries < 0} {
					UTF::Message INFO "" "changing bad tcp_retries=$tcp_retries to zero"
					set tcp_retries "0" 
				}
				if {$tcp_used_memory < 0} {
					UTF::Message INFO "" "changing bad tcp_used_memory=$tcp_used_memory to zero"
					set tcp_used_memory "0" 
				}
				
				# convert RTT from us to ms
				set tcp_rtt_ms [format "%2.3f" [expr {$tcp_rtt / 1000.0}]]
				
				append ::array_streams_tcp_rtt(${stream_index}) "$tcp_rtt_ms "
				append ::array_streams_tcp_writes(${stream_index}) "$tcp_writes "
				append ::array_streams_tcp_errors(${stream_index}) "$tcp_errors "
				append ::array_streams_tcp_retries(${stream_index}) "$tcp_retries "
				append ::array_streams_tcp_used_memory(${stream_index}) "$tcp_used_memory "
			}
			
			continue
		}

		if {[regexp "datagrams received out-of-order" $line]} {
		
			# "11:45:20  LOG   lan-S1     [  3]  0.0- 1.0 sec  436 datagrams received out-of-order"
			#                ------------time--------  host       interval_start_time        interval_end_time          out_of_order_packets
			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec *?([-+]?[0-9]*\.?[0-9]+).*out-of-order} $line match time stream_index interval_start_time interval_end_time out_of_order_packets]
			if {$rc != 0} {
				# remove the "RX_" from the beginning
				set stream_index [string replace $stream_index 0 2 ""]
		
				UTF::Message INFO "" "RX OOO: stream_index=$stream_index interval_start_time=$interval_start_time interval_end_time=$interval_end_time out-of-order=$out_of_order_packets"

				# skip more than 1 sec intervals (totals at the end of iperf)
				
				if {[expr {$interval_end_time - $interval_start_time}] <= $::perfint} {

					# removed the last data in the array_out_of_order_packets and replace it with this
					# out_of_order_packets value
					set out_of_order_data_cnt [llength $::array_streams_udp_out_of_order_packets(${stream_index})]
					set ::array_streams_udp_out_of_order_packets(${stream_index}) [lrange $::array_streams_udp_out_of_order_packets(${stream_index}) 0 [expr {$out_of_order_data_cnt - 2}]]
					set ::array_streams_udp_out_of_order_packets(${stream_index}) "$::array_streams_udp_out_of_order_packets(${stream_index}) $out_of_order_packets"

					UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${stream_index})=$::array_streams_udp_out_of_order_packets(${stream_index})"
				} else {
					# end of iperf msg shows total out-of-order packets for this stream
					# 17:32:34  LOG   lan-S3     [  3]  0.0-15.0 sec  282 datagrams received out-of-order
					UTF::Message INFO "" "RX OOO Total: $line"					
					set ::array_streams_rx_stream_time_secs(${stream_index}) $interval_end_time
				}
			}
			
			continue
		}

		# 1st try for a UDP response:
		# set line "15:16:43 lan-Stream2 \[  3\]  8.5- 9.0 sec  24.2 MBytes   203 Mbits/sec   0.057 ms    3/17229 (1%)"
		# 18:01:36 4360-P2P-GO [ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams
		# "13:33:04 4335-P2P-GO [  3]  7.0- 8.0 sec  3.34 MBytes  28.0 Mbits/sec   1.756 ms    3/ 2385 (0.13%)"
		# "08:00:16 4335-P2P-GC [  3]  1.0- 2.0 sec  0.00 KBytes  0.00 Kbits/sec  16.087 ms    0/    0 (NaN%)"
		# "08:00:56 lan [  3]  3.0- 4.0 sec  0.00 KBytes  0.00 Kbits/sec  23.278 ms    0/    0 (nan%)"
		#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale         udp_jitter                   udp_packet_loss      /     udp_packet_total         udp_lost_packets_percent        udp_latency_avg      /      udp_latency_min       /      udp_latency_max       /     udp_latency_stdev      ms           udp_pps          pps
		set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?\(([-+]?[0-9]*\.?[0-9]+)%\) +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) +?pps} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets udp_packet_total udp_lost_packets_percent udp_latency_avg udp_latency_min udp_latency_max udp_latency_stdev udp_pps]
		if {$rc == 0} {
			# lost_packets_percent could be a string and not a value

			set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec +?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?\((\S+)%\) +?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) *?/ *?([-+]?[0-9]*\.?[0-9]+) +?ms +?([-+]?[0-9]*\.?[0-9]+) +?pps} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale udp_jitter udp_lost_packets udp_packet_total udp_lost_packets_percent udp_latency_avg udp_latency_min udp_latency_max udp_latency_stdev udp_pps]
			if {$rc != 0} {
				# set the lost_packets_percent to max value
				set lost_packets_percent 100
			} else {
				# try for a TCP response:
				# 17:01:01  LOG   lan-S1     [ ID] Interval       Transfer     Bandwidth
				# 17:01:01  LOG   lan-S1     [  3]  0.0- 1.0 sec  70.2 MBytes   589 Mbits/sec
				#                ------------time--------  host       interval_start_time        interval_end_time                       throughput               scale 
				set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+).* +?([-+]?[0-9]*\.?[0-9]+)- *?([-+]?[0-9]*\.?[0-9]+) sec .*Bytes +?([-+]?[0-9]*\.?[0-9]+) +?(.)bits/sec} $line match time stream_index interval_start_time interval_end_time throughput throughput_scale]

				if {$rc == 0} {
					# try for a BT response:
					# 11:08:41  INFO             11:08:41 RX_1:BT Throughput = 248 kb/s 
					set rc [regexp {([0-9]+\:[0-9]+\:[0-9]+) +?(\S+) +?Throughput = +?([-+]?[0-9]*\.?[0-9]+) +?(.)b/s} $line match time stream_index throughput throughput_scale]
					if {$rc != 0} {
						set bt_throughput_flag 1
						
						set interval_start_time $bt_throughput_cnt
						set interval_end_time [expr $bt_throughput_cnt + 1]
						
						incr bt_throughput_cnt
					}
				}
			}
		}

		if {$rc == 0} {continue}

		# remove the "RX_" from the beginning
		set stream_index [string replace $stream_index 0 2 ""]
		
		UTF::Message LOG "" "RX: stream_index=$stream_index interval_start_time=$interval_start_time interval_end_time=$interval_end_time Throughput=$throughput throughput_scale=$throughput_scale udp_jitter=$udp_jitter udp_lost_packets=$udp_lost_packets udp_packet_total=$udp_packet_total udp_lost_packets_percent=$udp_lost_packets_percent udp_latency_avg=$udp_latency_avg udp_latency_min=$udp_latency_min udp_latency_max=$udp_latency_max udp_latency_stdev=$udp_latency_stdev udp_pps=$udp_pps"

		if {$bt_throughput_flag == 0} {
			# in very rare situation, the throughput could become bogus number
			if {$throughput > 10000 || $interval_start_time == $interval_end_time} {
				if {![regexp {Bogus throughput} $::array_streams_error(${stream_index})]} {
					append ::array_streams_error(${stream_index}) "(Bogus throughput)"
				}
				UTF::Message LOG "" "Throughput bogus number $throughput is replaced with -5"
				set throughput "-5"
			}
		}

		# figure out the correct time for this throughput
		set new_stream_time_secs [expr {$interval_start_time + $::array_streams_start_stream_time_secs(${stream_index}) - $first_stream_time_secs}]
		set new_stream_time_secs [format "%2.3f" $new_stream_time_secs]
		set new_stream_time_secs_round [expr {round($new_stream_time_secs)}]
		set new_time [clock format [expr {$::base_timestamp_tick + $new_stream_time_secs_round}] -format "%M:%S"]
		UTF::Message INFO "" "$stream_index time=$new_time"
		UTF::Message INFO "" "$interval_start_time + ($::array_streams_start_stream_time_secs(${stream_index}) - $first_stream_time_secs)=$new_stream_time_secs     round=$new_stream_time_secs_round     time=$new_time"
		if {$interval_start_time != $new_stream_time_secs_round} {
			UTF::Message INFO "" "Old Time=$interval_start_time New Time=$new_stream_time_secs_round"
		}

		# put the throughput value in the right bucket

		set any_throughput_data_flag 1

		if {[expr {$interval_end_time - $interval_start_time}] <= $::perfint} {

			append ::array_streams_throughput(${stream_index}) "$new_time $throughput "
			set ::array_streams_last_throughput_timestamp(${stream_index}) "$new_time"

			if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {

				# if iperf displays udp_lost_packets_percent as '(-nan%)', then change it to zero
				if {![regexp {([0-9]+)} $udp_lost_packets_percent]} {
					set udp_lost_packets_percent "0"
				}
			
				# check for bad stall data
				if {$udp_latency_avg < 0} {
					UTF::Message INFO "" "changing bad udp_latency_avg='$udp_latency_avg' to zero"
					set udp_latency_avg "0" 
				}
				if {$udp_latency_min < 0} {
					UTF::Message INFO "" "changing bad udp_latency_min='$udp_latency_min' to zero"
					set udp_latency_min "0" 
				}
				if {$udp_latency_max < 0} {
					UTF::Message INFO "" "changing bad udp_latency_max='$udp_latency_max' to zero"
					set udp_latency_max "0" 
				}
				if {$udp_latency_stdev < 0} {
					UTF::Message INFO "" "changing bad udp_latency_stdev='$udp_latency_stdev' to zero"
					set udp_latency_stdev "0" 
				}
				if {$udp_jitter < 0} {
					UTF::Message INFO "" "changing bad udp_jitter='$udp_jitter' to zero"
					set udp_jitter "0" 
				}
				if {$udp_lost_packets < 0} {
					UTF::Message INFO "" "changing bad udp_lost_packets='$udp_lost_packets' to zero"
					set udp_lost_packets "0" 
				}
				if {$udp_packet_total < 0} {
					UTF::Message INFO "" "changing bad udp_packet_total='$udp_packet_total' to zero"
					set udp_packet_total "0" 
				}
				if {$udp_lost_packets_percent < 0} {
					UTF::Message INFO "" "changing bad udp_lost_packets_percent='$udp_lost_packets_percent' to zero"
					set udp_lost_packets_percent "0" 
				}
				if {$udp_pps < 0} {
					UTF::Message INFO "" "changing bad udp_pps='$udp_pps' to zero"
					set udp_pps "0" 
				}

				append ::array_streams_udp_latency_avg(${stream_index}) "$udp_latency_avg "
				append ::array_streams_udp_latency_min(${stream_index}) "$udp_latency_min "
				append ::array_streams_udp_latency_max(${stream_index}) "$udp_latency_max "
				append ::array_streams_udp_latency_stdev(${stream_index}) "$udp_latency_stdev "
				append ::array_streams_udp_jitter(${stream_index}) "$udp_jitter "
				append ::array_streams_udp_lost_packets(${stream_index}) "$udp_lost_packets "
				append ::array_streams_udp_packet_total(${stream_index}) "$udp_packet_total "
				append ::array_streams_udp_lost_packets_percent(${stream_index}) "$udp_lost_packets_percent "
				append ::array_streams_udp_pps(${stream_index}) "$udp_pps "

				# insert a temp value of 0 for the out_of_order_packets value till the next data is read and this value gets adjusted
				append ::array_streams_udp_out_of_order_packets(${stream_index}) "0 "
			}			
		} else {
			UTF::Message INFO "" "interval_start_time=$interval_start_time current_interval_start_time=$interval_start_time"
			UTF::Message INFO "" "Do not save this data due to timestamp showing the total time"
			UTF::Message INFO "" "RX Total - $line"					
			set ::array_streams_rx_stream_time_secs(${stream_index}) $interval_end_time
		}
		
		UTF::Message INFO "" "---"
	}

	if {$any_throughput_data_flag == 0} {
		if {$::rvr_test_flag == 1} {
			UTF::Message LOG "" "RvR Test hit zero Throughput"
			UTF::Message INFO "" "****************************************************************"
			set ::rvr_zero_throughput_flag 1
			return "No Throughput Data"
		} else {
			UTF::Message LOG "" "***Failed. All Throughput data arrays are empty"
			UTF::Message INFO "" "****************************************************************"
			set ::connection_test_flag 1
			set ::test_error_flag 1
			error "html: <font color=\"red\"><b>No Throughput Data</b></font>"
		}
	}

	UTF::Message INFO "" "#############################check/fix stream missing data####################################"

	foreach stream_index $::streams_name_list {

		UTF::Message INFO "" "::array_streams_time_duration(${stream_index})=$::array_streams_time_duration(${stream_index})"

		# calculate the number of data samples expected
		# if a stream stoped early then report it as error
		set tmp [expr {$::array_streams_time_duration(${stream_index}) / $::perfint}]
		# leave one sample room
		set expected_throughput_data_cnt [expr {$tmp - 1}]
		UTF::Message INFO "" "expected_throughput_data_cnt = $expected_throughput_data_cnt"

		set actual_throughput_data_cnt [llength $::array_streams_throughput(${stream_index})]
		# devide by 2 to remove the timestamp
		set actual_throughput_data_cnt [expr {$actual_throughput_data_cnt / 2.0}]
		UTF::Message INFO "" "actual_throughput_data_cnt for $stream_index = $actual_throughput_data_cnt"

		if {$actual_throughput_data_cnt < $expected_throughput_data_cnt} {

			set ::test_error_flag 1
			set ::connection_test_flag 1

			if {$::array_streams_throughput(${stream_index}) == ""} {
				if {$::array_streams_throughput_skipped_flag(${stream_index}) == 1} {
					UTF::Message LOG "" "All throughput data is missing for $stream_index since iperf was skipped for this stream"
				} else {
					UTF::Message LOG "" "***Failed. All throughput data is missing for $stream_index"
					append ::array_streams_error(${stream_index}) "(All data missing)"
				}
			} else {
				UTF::Message LOG "" "***Failed. Some throughput data is missing for $stream_index"
				UTF::Message INFO "" "::array_streams_throughput(${stream_index})=$::array_streams_throughput(${stream_index})"
				append ::array_streams_error(${stream_index}) "(Some data missing)"
			}

			UTF::Message INFO "" "#############################insert dummy data for missing data####################################"

			# add '-5' in data for missing throughput value
			# for UDP, do not add dummy data for missing jitter and packet loss data

			set data_missing_cnt [expr {$expected_throughput_data_cnt - $actual_throughput_data_cnt}]
			UTF::Message LOG "" "add dummy '-5' throughput data $data_missing_cnt times"			
			
			for {set cnt 0} {$cnt < $data_missing_cnt} {incr cnt} {
				if {$::array_streams_last_throughput_timestamp(${stream_index}) == ""} {
					# no data
					set last_time_tick [clock scan "00:00:00"]
					set new_time_tick [expr {$last_time_tick - $::base_timestamp_tick + $::array_streams_start_time(${stream_index})}]
				} else {
					set last_time_timestamp "00:$::array_streams_last_throughput_timestamp(${stream_index})"
					set last_time_tick [clock scan $last_time_timestamp]
					set new_time_tick [expr {$last_time_tick - $::base_timestamp_tick + $::perfint}]
				}
				set new_timestamp [clock format $new_time_tick -format "%M:%S"]
				append ::array_streams_throughput(${stream_index}) "$new_timestamp -5 "
				set ::array_streams_last_throughput_timestamp(${stream_index}) "$new_timestamp"
			}
		}

		UTF::Message INFO "" "-----------------All the data for the stream ($::array_streams_iperf_cnt(${stream_index})) $stream_index---------------------"
    	set ::array_streams_start_stream_time_secs(${stream_index}) [string trim $::array_streams_start_stream_time_secs(${stream_index})]
		UTF::Message INFO "" "::array_streams_start_stream_time_secs(${stream_index})=$::array_streams_start_stream_time_secs(${stream_index})"
    	set ::array_streams_throughput(${stream_index}) [string trim $::array_streams_throughput(${stream_index})]
		UTF::Message INFO "" "::array_streams_throughput(${stream_index})=$::array_streams_throughput(${stream_index})"

		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
    		set ::array_streams_tcp_rtt(${stream_index}) [string trim $::array_streams_tcp_rtt(${stream_index})]
			UTF::Message INFO "" "::array_streams_tcp_rtt(${stream_index})=$::array_streams_tcp_rtt(${stream_index})"
    		set ::array_streams_tcp_writes(${stream_index}) [string trim $::array_streams_tcp_writes(${stream_index})]
			UTF::Message INFO "" "::array_streams_tcp_writes(${stream_index})=$::array_streams_tcp_writes(${stream_index})"
    		set ::array_streams_tcp_errors(${stream_index}) [string trim $::array_streams_tcp_errors(${stream_index})]
			UTF::Message INFO "" "::array_streams_tcp_errors(${stream_index})=$::array_streams_tcp_errors(${stream_index})"
    		set ::array_streams_tcp_retries(${stream_index}) [string trim $::array_streams_tcp_retries(${stream_index})]
			UTF::Message INFO "" "::array_streams_tcp_retries(${stream_index})=$::array_streams_tcp_retries(${stream_index})"
    		set ::array_streams_tcp_used_memory(${stream_index}) [string trim $::array_streams_tcp_used_memory(${stream_index})]
			UTF::Message INFO "" "::array_streams_tcp_used_memory(${stream_index})=$::array_streams_tcp_used_memory(${stream_index})"
		}
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
    		set ::array_streams_udp_latency_avg(${stream_index}) [string trim $::array_streams_udp_latency_avg(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_latency_avg(${stream_index})=$::array_streams_udp_latency_avg(${stream_index})"
    		set ::array_streams_udp_jitter(${stream_index}) [string trim $::array_streams_udp_jitter(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_jitter(${stream_index})=$::array_streams_udp_jitter(${stream_index})"
    		set ::array_streams_udp_lost_packets(${stream_index}) [string trim $::array_streams_udp_lost_packets(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_lost_packets(${stream_index})=$::array_streams_udp_lost_packets(${stream_index})"
    		set ::array_streams_udp_packet_total(${stream_index}) [string trim $::array_streams_udp_packet_total(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_packet_total(${stream_index})=$::array_streams_udp_packet_total(${stream_index})"
    		set ::array_streams_udp_lost_packets_percent(${stream_index}) [string trim $::array_streams_udp_lost_packets_percent(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_lost_packets_percent(${stream_index})=$::array_streams_udp_lost_packets_percent(${stream_index})"
    		set ::array_streams_udp_out_of_order_packets(${stream_index}) [string trim $::array_streams_udp_out_of_order_packets(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_out_of_order_packets(${stream_index})=$::array_streams_udp_out_of_order_packets(${stream_index})"
    		set ::array_streams_udp_pps(${stream_index}) [string trim $::array_streams_udp_pps(${stream_index})]
			UTF::Message INFO "" "::array_streams_udp_pps(${stream_index})=$::array_streams_udp_pps(${stream_index})"
		}
		UTF::Message INFO "" "---------------------------------------------------------------------------------------------------"
		
		UTF::Message INFO "" "************************          control chart throughput           ***************************"

		# strip the timestamp from the throughput values
		set throughput_index 0
		foreach throughput_value $::array_streams_throughput(${stream_index}) {
			incr throughput_index
			if {[expr {$throughput_index % 2}] == 0} {
				# even number data is the throughput value
				append ::array_streams_controlchart_throughput(${stream_index}) "$throughput_value "
			}
		}

		UTF::Message INFO "" "::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"

		# replace bad throughput of '-5' with '0' for the control chart
		if {[regexp {\-5} $::array_streams_controlchart_throughput(${stream_index})]} {
			UTF::Message INFO "" "org ::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"
			UTF::Message INFO "" "Replacing '-5' with '0'"
			regsub -all {\-5} $::array_streams_controlchart_throughput(${stream_index}) "0" ::array_streams_controlchart_throughput(${stream_index})
			UTF::Message INFO "" "new ::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"
		}

    	set ::array_streams_controlchart_throughput(${stream_index}) [string trim $::array_streams_controlchart_throughput(${stream_index})]
		set ::array_streams_controlchart_throughput(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_controlchart_throughput(${stream_index})]
		UTF::Message INFO "" "::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"

		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {

			UTF::Message INFO "" "************************            control chart tcp_rtt             ***************************"
			set ::array_streams_controlchart_tcp_rtt(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_tcp_rtt(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_rtt(${stream_index})=$::array_streams_controlchart_tcp_rtt(${stream_index})"

			UTF::Message INFO "" "************************            control chart tcp_retries             ***************************"
			set ::array_streams_controlchart_tcp_retries(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_tcp_retries(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_retries(${stream_index})=$::array_streams_controlchart_tcp_retries(${stream_index})"
			
			UTF::Message INFO "" "************************            control chart tcp_used_memory             ***************************"
			set ::array_streams_controlchart_tcp_used_memory(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_tcp_used_memory(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_tcp_used_memory(${stream_index})=$::array_streams_controlchart_tcp_used_memory(${stream_index})"
		}
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {

			UTF::Message INFO "" "************************            control chart udp_latency           ***************************"
			set ::array_streams_controlchart_udp_latency(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_udp_latency_avg(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_latency(${stream_index})=$::array_streams_controlchart_udp_latency(${stream_index})"

			UTF::Message INFO "" "************************            control chart udp_jitter             ***************************"
			set ::array_streams_controlchart_udp_jitter(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_udp_jitter(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_jitter(${stream_index})=$::array_streams_controlchart_udp_jitter(${stream_index})"
			
			UTF::Message INFO "" "************************         control chart udp_lost_packets         ***************************"
			set ::array_streams_controlchart_udp_lost_packets(${stream_index}) [p2p::total_control_chart_stream_data $::array_streams_udp_lost_packets(${stream_index})]
			set ::array_streams_controlchart_udp_lost_packets(${stream_index}) [p2p::round_control_chart_stream_data $::array_streams_controlchart_udp_lost_packets(${stream_index})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_udp_lost_packets(${stream_index}) " $::array_streams_controlchart_udp_lost_packets(${stream_index}) $::array_streams_controlchart_udp_lost_packets(${stream_index})"
			UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets(${stream_index})=$::array_streams_controlchart_udp_lost_packets(${stream_index})"
			
			UTF::Message INFO "" "************************         control chart udp_packet_total        ***************************"
			set ::array_streams_controlchart_udp_packet_total(${stream_index}) [p2p::total_control_chart_stream_data $::array_streams_udp_packet_total(${stream_index})]
			set ::array_streams_controlchart_udp_packet_total(${stream_index}) [p2p::round_control_chart_stream_data $::array_streams_controlchart_udp_packet_total(${stream_index})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_udp_packet_total(${stream_index}) " $::array_streams_controlchart_udp_packet_total(${stream_index}) $::array_streams_controlchart_udp_packet_total(${stream_index})"
			UTF::Message INFO "" "::array_streams_controlchart_udp_packet_total(${stream_index})=$::array_streams_controlchart_udp_packet_total(${stream_index})"
			
			UTF::Message INFO "" "************************      control chart udp_lost_packets_percent     ***************************"
			set ::array_streams_controlchart_udp_lost_packets_percent(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_udp_lost_packets_percent(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_lost_packets_percent(${stream_index})=$::array_streams_controlchart_udp_lost_packets_percent(${stream_index})"
			
			UTF::Message INFO "" "************************     control chart udp_out_of_order_packets      ***************************"
			set ::array_streams_controlchart_udp_out_of_order_packets(${stream_index}) [p2p::total_control_chart_stream_data $::array_streams_udp_out_of_order_packets(${stream_index})]
			set ::array_streams_controlchart_udp_out_of_order_packets(${stream_index}) [p2p::round_control_chart_stream_data $::array_streams_controlchart_udp_out_of_order_packets(${stream_index})]
			# the results is one number and that is not enough for control chart. Duplicate it to 3 numbers
			append ::array_streams_controlchart_udp_out_of_order_packets(${stream_index}) " $::array_streams_controlchart_udp_out_of_order_packets(${stream_index}) $::array_streams_controlchart_udp_out_of_order_packets(${stream_index})"
			UTF::Message INFO "" "::array_streams_controlchart_udp_out_of_order_packets(${stream_index})=$::array_streams_controlchart_udp_out_of_order_packets(${stream_index})"

			UTF::Message INFO "" "************************            control chart udp_pps           ***************************"
			set ::array_streams_controlchart_udp_pps(${stream_index}) [p2p::build_control_chart_stream_data $::array_streams_udp_pps(${stream_index})]
			UTF::Message INFO "" "::array_streams_controlchart_udp_pps(${stream_index})=$::array_streams_controlchart_udp_pps(${stream_index})"
		}
	}

	UTF::Message INFO "" "#############################find zero throughput data count####################################"

	foreach stream_index $::streams_name_list {

		set zero_throughput_cnt 0
		set stall_throughput_cnt 0
		set died_stream_flag 0
		set died_throughput_check_flag 0
		set died_throughput_cnt 0
		set throughput_index 0

		foreach throughput_value $::array_streams_throughput(${stream_index}) {

			incr throughput_index
			if {[expr {$throughput_index % 2}] == 0} {
				# even number data is the throughput value

				if {$throughput_value == 0} {
					UTF::Message INFO "" "   Item $throughput_index - ZERO"
					incr zero_throughput_cnt
					incr stall_throughput_cnt

					if {$stall_throughput_cnt > 1} {
						UTF::Message INFO "" "back to back ZERO throughput is detected. This is a stall count $stall_throughput_cnt."
					}
				} elseif {$throughput_value < 0} {
					UTF::Message INFO "" "   Item $throughput_index - Data=$throughput_value - DIED"
					if {$died_throughput_check_flag == 1} {
						incr died_throughput_cnt
					}					
				} else {
					set stall_throughput_cnt 0
					set died_throughput_check_flag 1
					set died_throughput_cnt 0
				}
			}
		}
		
		# if there is no throughput for more than 3 sec at the end, then the stream must of died
		if {$died_throughput_cnt > 2} {
			set died_stream_flag 1
			UTF::Message INFO "" "died_throughput_cnt=$died_throughput_cnt"
		}
	
		if {$zero_throughput_cnt > 0 || $died_stream_flag == 1} {

			set tmp ""
			if {$zero_throughput_cnt > 0} {
				if {$zero_throughput_cnt == 1} {
					set tmp "1 zero throughput"
				} else {
					set tmp "$zero_throughput_cnt zeros throughput"
					if {$stall_throughput_cnt > 0} {
						if {$stall_throughput_cnt == 1} {
							set tmp2 "second"
						} else {
							set tmp2 "seconds"
						}
						append tmp " with $stall_throughput_cnt $tmp2 STALL"
					}
				}
			}

			if {$died_stream_flag == 1} {
				if {$tmp != ""} {
					append tmp " "
				}
				append tmp "DIED"
			}

			set ::test_error_flag 1
			UTF::Message LOG "" "***Failed. $tmp for stream $stream_index"
			append ::array_streams_error(${stream_index}) "($tmp)"
		}

		# check to see if the rx took longer than tx

		UTF::Message INFO "" "::array_streams_tx_stream_time_secs(${stream_index})=$::array_streams_tx_stream_time_secs(${stream_index})"					
		UTF::Message INFO "" "::array_streams_rx_stream_time_secs(${stream_index})=$::array_streams_rx_stream_time_secs(${stream_index})"

		if {$::array_streams_tx_stream_time_secs(${stream_index}) != "" && $::array_streams_rx_stream_time_secs(${stream_index}) == ""} {
			UTF::Message INFO "" "$stream_index is missing RX time"
			append ::array_streams_error(${stream_index}) "(Check RX time)"
		} elseif {$::array_streams_tx_stream_time_secs(${stream_index}) != "" && $::array_streams_rx_stream_time_secs(${stream_index}) != ""} {
			set extra_time [format "%2.1f" [expr $::array_streams_rx_stream_time_secs(${stream_index}) - $::array_streams_tx_stream_time_secs(${stream_index})]]
			
			if {$extra_time > 0.5} {
				UTF::Message INFO "" "$stream_index took $extra_time sec longer"
				append ::array_streams_error(${stream_index}) "(RX took $extra_time sec longer)"
			}
		}
	}

	UTF::Message INFO "" "###########################SAVED DATA######################################"

	set tmp [llength $::array_streams_type(${stream_index})]
	UTF::Message INFO "" "size=$tmp - ::array_streams_type(${stream_index})=$::array_streams_type(${stream_index})"
	set tmp [llength $::array_streams_tos(${stream_index})]
	UTF::Message INFO "" "size=$tmp - ::array_streams_tos(${stream_index})=$::array_streams_tos(${stream_index})"
	set tmp [llength $::array_streams_time_duration(${stream_index})]
	UTF::Message INFO "" "size=$tmp - ::array_streams_time_duration(${stream_index})=$::array_streams_time_duration(${stream_index})"
	set tmp [llength $::streams_name_list]
	UTF::Message INFO "" "size=$tmp - ::streams_name_list=$::streams_name_list"


	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_throughput(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_throughput(${stream_index})=$::array_streams_throughput(${stream_index})"
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_tcp_rtt(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_rtt(${stream_index})=$::array_streams_tcp_rtt(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_tcp_writes(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_writes(${stream_index})=$::array_streams_tcp_writes(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_tcp_errors(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_errors(${stream_index})=$::array_streams_tcp_errors(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_tcp_retries(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_retries(${stream_index})=$::array_streams_tcp_retries(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_tcp_used_memory(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_tcp_used_memory(${stream_index})=$::array_streams_tcp_used_memory(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_latency_avg(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_avg(${stream_index})=$::array_streams_udp_latency_avg(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_latency_min(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_min(${stream_index})=$::array_streams_udp_latency_min(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_latency_max(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_max(${stream_index})=$::array_streams_udp_latency_max(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_latency_stdev(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_latency_stdev(${stream_index})=$::array_streams_udp_latency_stdev(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_jitter(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_jitter(${stream_index})=$::array_streams_udp_jitter(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_lost_packets(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_lost_packets(${stream_index})=$::array_streams_udp_lost_packets(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_packet_total(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_packet_total(${stream_index})=$::array_streams_udp_packet_total(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_lost_packets_percent(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_lost_packets_percent(${stream_index})=$::array_streams_udp_lost_packets_percent(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_out_of_order_packets(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_out_of_order_packets(${stream_index})=$::array_streams_udp_out_of_order_packets(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			set len [llength $::array_streams_udp_pps(${stream_index})]
			UTF::Message INFO "" "Len=$len - ::array_streams_udp_pps(${stream_index})=$::array_streams_udp_pps(${stream_index})"
		}
	}
	UTF::Message INFO "" "============================================================="
	UTF::Message INFO "" "For Control Charts:"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_throughput(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_throughput(${stream_index})=$::array_streams_controlchart_throughput(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_latency(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_latency(${stream_index})=$::array_streams_controlchart_udp_latency(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_jitter(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_jitter(${stream_index})=$::array_streams_controlchart_udp_jitter(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_lost_packets(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_lost_packets(${stream_index})=$::array_streams_controlchart_udp_lost_packets(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_packet_total(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_packet_total(${stream_index})=$::array_streams_controlchart_udp_packet_total(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_lost_packets_percent(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_lost_packets_percent(${stream_index})=$::array_streams_controlchart_udp_lost_packets_percent(${stream_index})"
	}
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_out_of_order_packets(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_out_of_order_packets(${stream_index})=$::array_streams_controlchart_udp_out_of_order_packets(${stream_index})"
	}	
	UTF::Message INFO "" "-------------------------------------------------------------"
	foreach stream_index $::streams_name_list {
		set len [llength $::array_streams_controlchart_udp_pps(${stream_index})]
		UTF::Message INFO "" "Len=$len - ::array_streams_controlchart_udp_pps(${stream_index})=$::array_streams_controlchart_udp_pps(${stream_index})"
	}
	UTF::Message INFO "" "============================================================="
	
	if {$::rvr_test_flag == 0} {

		foreach stream_index $::streams_name_list {
		
			set array_for_csv_throughput(${stream_index}) ""
			
			set base_time [lindex $::array_streams_throughput(${stream_index}) 0]
			if {$base_time != "00:00"} {
				UTF::Message INFO "" "###########################insert filler BLANK data for CSV if stream data did not start from time 00:00 (e.g. QoS stream)######################################"

				set new_base_time "00:00"
				set new_str_list "$new_base_time BLANK "
				set new_str_udp_list "BLANK "
				while {1} {
					set new_base_time "00:$new_base_time"
					set new_base_time_tick [clock scan $new_base_time]
					set diff_timestamp_tick [expr {$new_base_time_tick - $::base_timestamp_tick + $::perfint}]
					set new_base_time [clock format $diff_timestamp_tick -format "%M:%S"]
					#UTF::Message INFO "" "new_base_time=$new_base_time"
					if {$new_base_time == $base_time} {
						break
					}
					append new_str_list "$new_base_time BLANK "
					append new_str_udp_list "BLANK "
				}
				
    			set new_str_list [string trim $new_str_list]
    			set new_str_udp_list [string trim $new_str_udp_list]
				UTF::Message INFO "" "Stream $stream_index starting time is $base_time instead of 00:00. Adding fillers '$new_str_list'"
				
				set array_for_csv_throughput(${stream_index}) "$new_str_list $::array_streams_throughput(${stream_index})"
				if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
					set array_for_csv_tcp_rtt(${stream_index}) "$new_str_udp_list $::array_streams_tcp_rtt(${stream_index})"
					set array_for_csv_tcp_writes(${stream_index}) "$new_str_udp_list $::array_streams_tcp_writes(${stream_index})"
					set array_for_csv_tcp_errors(${stream_index}) "$new_str_udp_list $::array_streams_tcp_errors(${stream_index})"
					set array_for_csv_tcp_retries(${stream_index}) "$new_str_udp_list $::array_streams_tcp_retries(${stream_index})"
					set array_for_csv_tcp_used_memory(${stream_index}) "$new_str_udp_list $::array_streams_tcp_used_memory(${stream_index})"
				}
				if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
					set array_for_csv_udp_latency(${stream_index}) "$new_str_udp_list $::array_streams_udp_latency_avg(${stream_index})"
					set array_for_csv_jitter(${stream_index}) "$new_str_udp_list $::array_streams_udp_jitter(${stream_index})"
					set array_for_csv_udp_lost_packets(${stream_index}) "$new_str_udp_list $::array_streams_udp_lost_packets(${stream_index})"
					set array_for_csv_udp_out_of_order_packets(${stream_index}) "$new_str_udp_list $::array_streams_udp_out_of_order_packets(${stream_index})"
					set array_for_csv_udp_pps(${stream_index}) "$new_str_udp_list $::array_streams_udp_pps(${stream_index})"
				}
			} else {
				set array_for_csv_throughput(${stream_index}) "$::array_streams_throughput(${stream_index})"
				if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
					set array_for_csv_tcp_rtt(${stream_index}) "$::array_streams_tcp_rtt(${stream_index})"
					set array_for_csv_tcp_writes(${stream_index}) "$::array_streams_tcp_writes(${stream_index})"
					set array_for_csv_tcp_errors(${stream_index}) "$::array_streams_tcp_errors(${stream_index})"
					set array_for_csv_tcp_retries(${stream_index}) "$::array_streams_tcp_retries(${stream_index})"
					set array_for_csv_tcp_used_memory(${stream_index}) "$::array_streams_tcp_used_memory(${stream_index})"
				}
				if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
					set array_for_csv_udp_latency(${stream_index}) "$::array_streams_udp_latency_avg(${stream_index})"
					set array_for_csv_jitter(${stream_index}) "$::array_streams_udp_jitter(${stream_index})"
					set array_for_csv_udp_lost_packets(${stream_index}) "$::array_streams_udp_lost_packets(${stream_index})"
					set array_for_csv_udp_out_of_order_packets(${stream_index}) "$::array_streams_udp_out_of_order_packets(${stream_index})"
					set array_for_csv_udp_pps(${stream_index}) "$::array_streams_udp_pps(${stream_index})"
				}
			}
		}

		UTF::Message INFO "" "###########################Write Throughput Data to CSV######################################"
		
		# find the stream with the most data points
		set stream_throughput_list_len 0
		foreach stream_index $::streams_name_list {
			set len [llength $array_for_csv_throughput(${stream_index})]
			UTF::Message INFO "" "length array_for_csv_throughput(${stream_index})=$len"
			if {$stream_throughput_list_len < $len} {
				set stream_throughput_list_len $len
			}
		}

		# 1st stream starting time
		set first_stream_name [lindex $::streams_name_list 0]
		set parts [split $::array_streams_start_stream_time_secs(${first_stream_name}) "."]
		set base_round_down [lindex $parts 0]
		set base_fraction [lindex $parts 1]
		set timestamp [clock format [expr {round($base_round_down)}] -format "%H:%M:%S"]
		set timestamp "$timestamp.$base_fraction"

		set stream_index_num 0
		
		for {set throughput_index 0} {$throughput_index < $stream_throughput_list_len} {incr throughput_index; incr throughput_index; incr stream_index_num} {

			###################################################################
			# Initialize CSV Throughput Variables
			###################################################################
			p2p::array_init_csv_data 0 1

			foreach stream_index $::streams_name_list {

				set len [llength $array_for_csv_throughput(${stream_index})]

				if {$throughput_index >= $len} {
					# if this stream array is shorter then the rest, then we need to skip this index 
					UTF::Message INFO "" "stream_index=$stream_index len $len is shorter than $throughput_index. skip this."
					continue
				}

				if {$::array_streams_type(${stream_index}) == "BT"} {
						set stream_sta_obj $(bt_root_sta)
				} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
					# always P2P GC interface
					set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
				} else {
					if {$::ap_connect == "GC"} {
						set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					} elseif {$::ap_connect == "GO"} {
						set stream_sta_obj $::go_wlan
					} else {
						# just WLAN
						set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
					}
				}

				if {$::csv_data_BaseTime == ""} {

					set ::csv_data_BaseTime [lindex $array_for_csv_throughput(${stream_index}) $throughput_index]
					
					# add the hour before converting
					set new_base_timestamp "00:$::csv_data_BaseTime"
					set new_base_timestamp_tick [clock scan $new_base_timestamp]
					set diff_timestamp_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
					set round_down [expr {$diff_timestamp_tick + $base_round_down}]
					set timestamp [clock format [expr {round($round_down)}] -format "%H:%M:%S"]
					set timestamp "$timestamp.$base_fraction"

					set ::csv_data_Time "\[$timestamp\]"
				}

				set data [lindex $array_for_csv_throughput(${stream_index}) [expr {$throughput_index + 1}]]

				if {$data != "BLANK"} {
				
					set ::csv_data_StaThroughput(${stream_sta_obj})(${stream_index}) $data
					# there are no min and max throughput info for each iperf data results
					set ::csv_data_StaThroughputMin(${stream_sta_obj})(${stream_index}) ""
					set ::csv_data_StaThroughputMax(${stream_sta_obj})(${stream_index}) ""

					if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
						set ::csv_data_StaTCPRTT(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_tcp_rtt(${stream_index}) $stream_index_num]
						set ::csv_data_StaTCPWrites(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_tcp_writes(${stream_index}) $stream_index_num]
						set ::csv_data_StaTCPErrors(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_tcp_errors(${stream_index}) $stream_index_num]
						set ::csv_data_StaTCPRetries(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_tcp_retries(${stream_index}) $stream_index_num]
						set ::csv_data_StaTCPUsedMemory(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_tcp_used_memory(${stream_index}) $stream_index_num]
					}
					if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {

						set data_jitter [lindex $array_for_csv_jitter(${stream_index}) $stream_index_num]
						if {$data_jitter != "BLANK"} {
							set ::csv_data_StaUDPLatency(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_udp_latency(${stream_index}) $stream_index_num]
							set ::csv_data_StaUDPJitter(${stream_sta_obj})(${stream_index}) $data_jitter
							set ::csv_data_StaUDPJitterMin(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPJitterMax(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPLostPackets(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_udp_lost_packets(${stream_index}) $stream_index_num]
							set ::csv_data_StaUDPLostPacketsMin(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPLostPacketsMax(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPOutofOrderPackets(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_udp_out_of_order_packets(${stream_index}) $stream_index_num]
							set ::csv_data_StaUDPOutofOrderPacketsMin(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPOutofOrderPacketsMax(${stream_sta_obj})(${stream_index}) ""
							set ::csv_data_StaUDPPPS(${stream_sta_obj})(${stream_index}) [lindex $array_for_csv_udp_pps(${stream_index}) $stream_index_num]
						}
					}
				}
			}

			#####################################################
			######  Write Throughput Result to CVS File  ########
			#####################################################
			p2p::array_write_csv_data 0 1		
		}
	}
}

proc p2p::setup_cct {} {
	# access option array
	upvar {} {}

	if {$::agilent_obj != ""} {

		UTF::Try "DTIM Interval Measurement (WLAN UP)" {
			foreach STA $::list_sta_wlan_objects {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}

			set ::cct_key "DTIM WLAN UP"
			p2p::measure_dtim_interval					
			return "html: $::current_results"
		}
		
		UTF::Try "Current Measurement (WLAN UP)" {

			foreach STA $::list_sta_wlan_objects {
				catch {$STA wl dtim}
				catch {$STA wl PM}
			}

			set ::cct_key "WLAN UP"
			p2p::measure_idle_current					
			return "html: $::current_results"
		}
	
		UTF::Try "Setup CCT" {
			UTF::Message INFO "" "************************Func:setup_cct***************************"

			set cct_interface_list $::list_active_interface_objects
			
			if {$cct_interface_list == ""} {
				set cct_interface_list $::list_possible_interface_objects
			}
			
			foreach STA "$cct_interface_list" {
				catch {$STA wl phy_watchdog}
#				catch {$STA wl phy_watchdog 0}
#				UTF::Sleep 1
#				catch {$STA wl phy_watchdog}

				catch {$STA wl pm2_sleep_ret}
#				catch {$STA wl pm2_sleep_ret 20}
#				UTF::Sleep 1
#				catch {$STA wl pm2_sleep_ret}

				catch {$STA wl frameburst}
				catch {$STA wl mpc}
				catch {$STA wl scansuppress}
			}
		}
	}
}

proc p2p::measure_idle_current {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_idle_current***************************"
	
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port $(current_sample_time) $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	p2p::process_current_data
}

proc p2p::measure_dtim_interval {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_dtim_interval***************************"

	# current_measure_time = current_sample_time * current_sample_points -> 40E-6 * 50000 = 2 seconds
	
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port "40E-6" $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	p2p::process_current_data
}

proc p2p::setup_current_measurement_with_traffic {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:setup_current_measurement_with_traffic***************************"
		
	set ::current_results ""
	set ::current_actual_sample_time [$::agilent_obj setup_current_trigger $::agilent_port $(current_sample_time) $(current_sample_points) $(current_offset_points) $(current_range) $(current_trigger)]
	UTF::Message LOG "" "::current_actual_sample_time=$::current_actual_sample_time"
}

proc p2p::measure_current_with_traffic {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:measure_current_with_traffic***************************"
	
	set rc [$::agilent_obj force_current_trigger $::agilent_port]
	
	# must wait till the data in ready in Agilent buffer
	UTF::Sleep $::current_measure_time
	UTF::Sleep 1
	
	p2p::process_current_data
}

proc p2p::process_current_data {} {

	UTF::Message INFO "" "************************Func:process_current_data***************************"
		
	set current_high_value [$::agilent_obj get_current_trigger_data_high_value ""]
	if {$current_high_value == ""} {
		set current_high_value 0
	}
	set current_high_value [format "%2.8f" [expr {$current_high_value * 1000.0}]]
	set current_floor_value [$::agilent_obj get_current_trigger_data_low_value ""]
	if {$current_floor_value == ""} {
		set current_floor_value 0
	}
	set current_floor_value [format "%2.8f" [expr {$current_floor_value * 1000.0}]]

	set rc [$::agilent_obj get_current_trigger_data ""]
	set current_values [split $rc ","]

	####################################################################

	set final_ckey "$::ckey A=$::curr_attn_value current_floor_value $::cct_key"
	UTF::Message INFO "" "KEY=$final_ckey"
	
	set current_results_low_value [p2p::control_chart "Floor Value" $current_floor_value $final_ckey "Current" "mA" 0]

	# current of zero and low are OK
	regsub { ZERO} $current_results_low_value { OK} current_results_low_value
	regsub { LOW} $current_results_low_value { OK} current_results_low_value

	set final_ckey "$::ckey A=$::curr_attn_value current_high_value $::cct_key"
	UTF::Message INFO "" "KEY=$final_ckey"
	
	set current_results_high_value [p2p::control_chart "High Value" $current_high_value $final_ckey "Current" "mA" 0]

	# current of zero and low are OK
	regsub { ZERO} $current_results_high_value { OK} current_results_high_value
	regsub { LOW} $current_results_high_value { OK} current_results_high_value

	####################################################################
	
	# genrate the gnu_data file which has the current vs time data
	
    set logdir [file nativename [file dir $UTF::Logfile]]
    set testnum [file tail $UTF::Logfile]
    set testnum [file rootname $testnum]
    set testnum [string trim $testnum]
	
	set gnu_data_fd [open "${logdir}/${testnum}_current.gnu_data" w]
	set line_cnt 0
	
	foreach value $current_values {

		incr line_cnt

		#UTF::Message LOG "" "(line=$line_cnt)(value=$value)"

		# current in mA (default Agilent is A)
		set value [expr {$value * 1000.0}]

		# x-axis (time) starts from 0 and it is in ms. y-axis (current) is in mA
		puts $gnu_data_fd [format "%2.3f %2.8f" [expr {[expr {$line_cnt - 1}] * $::current_actual_sample_time * 1000.0}] $value]
	}
	close $gnu_data_fd

	UTF::Message LOG "" "===================================================================="
	UTF::Message LOG "" "Graph the results:"

	set gpc_fd [open "${logdir}/${testnum}.gnu_plot" w]

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}_canvas.html\""
	puts $gpc_fd "set terminal canvas standalone mousing size 1024,768 jsdir \"http://www.sj.broadcom.com/projects/hnd_sig_ext4/rmcmahon/gnuplotfiles\""
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set label \"\" at graph 0.1, graph 0.9"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lw 2 lt 1 title \"\""

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}.png\""
	puts $gpc_fd "set terminal png size 640,480"
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set label \"\" at graph 0.1, graph 0.9"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lw 2 lt 1 title \"\""

	puts $gpc_fd "reset; unset multiplot"
	puts $gpc_fd "set output \"${logdir}/${testnum}_sm.png\""
	puts $gpc_fd "set terminal png transparent size 62,13"
	puts $gpc_fd "set tmargin 0; set bmargin 0"
	puts $gpc_fd "set lmargin 0; set rmargin 0.15"
	puts $gpc_fd "set nokey"
	puts $gpc_fd "set grid"
	puts $gpc_fd "set format y \"%0.1s%c\""
	puts $gpc_fd "set autoscale fix"
	puts $gpc_fd "set yrange \[0:*\]"
	puts $gpc_fd "set size 1.0,1.0"
	puts $gpc_fd "set origin 0,0.0"
	puts $gpc_fd "set title \"$testnum - Current over Time\""
	puts $gpc_fd "set xlabel \"Time (ms)\""
	puts $gpc_fd "set ylabel \"Current (mA)\""
	puts $gpc_fd "unset xtics; unset ytics; unset key; unset xlabel; unset ylabel; unset border; unset grid; unset yzeroaxis; unset xzeroaxis; unset title; set lmargin 0; set rmargin 0; set tmargin 0; set bmargin 0"
	puts $gpc_fd "plot \"${logdir}/${testnum}_current.gnu_data\" index 0 using 1:2 with lines lt 1"

	close $gpc_fd

	set rc [catch "exec $::UTF::Gnuplot ${logdir}/${testnum}.gnu_plot" result]

	########################################

	set ::current_results ""
    append ::current_results "<a href=\"${logdir}/${testnum}_canvas.html\"><b>Current Plot</b></a>&nbsp;&nbsp;<img src=\"${testnum}_sm.png\" alt=\"${testnum}_sm.png\" id=\"img_test_result\" border=\"0\">"
	append ::current_results "&nbsp;&nbsp;$current_results_low_value&nbsp;&nbsp;$current_results_high_value"
	UTF::Message LOG "" "::current_results=$::current_results"
}

proc p2p::setup_list_active_interface_objects {} {

	UTF::Message INFO "" "************************Func:setup_list_active_interface_objects***************************"

	set active_interfaces $::list_possible_interface_objects

	foreach sta_wlan_index $::list_sta_wlan_objects {
		UTF::Message INFO "" "-----------------------------sta_wlan_index=$sta_wlan_index------------------------------------------"
		UTF::Message INFO "" "::array_sta_wlan_active_flag(${sta_wlan_index})=$::array_sta_wlan_active_flag(${sta_wlan_index}) ::array_sta_wlan_disassociated_flag(${sta_wlan_index})=$::array_sta_wlan_disassociated_flag(${sta_wlan_index})"
		UTF::Message INFO "" "::array_sta_p2p_active_flag(${sta_wlan_index})=$::array_sta_p2p_active_flag(${sta_wlan_index}) ::array_sta_p2p_disassociated_flag(${sta_wlan_index})=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"

		UTF::Message INFO "" "sta_wlan=$sta_wlan_index"
		UTF::Message INFO "" "::array_sta_p2p(${sta_wlan_index})=$::array_sta_p2p(${sta_wlan_index})"

		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 0} {
			if {[string compare $sta_wlan_index $::go_wlan] == 0} {
				if {$::ap_connect == "GC"} {
					#UTF::Message INFO "" "Inactive WLAN for GO when AP is connected to GC. Removing WLAN '$::go_wlan'"
					set idx [lsearch -exact $active_interfaces $::go_wlan]
					set active_interfaces [lreplace $active_interfaces $idx $idx ""]							
				}
			} else {
				if {$::ap_connect == "GO"} {
					#UTF::Message INFO "" "Inactive WLAN for GC when AP is connected to GO. Removing WLAN '$sta_wlan_index'"
					set idx [lsearch -exact $active_interfaces $sta_wlan_index]
					set active_interfaces [lreplace $active_interfaces $idx $idx ""]							
				}
			}
		}

		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 0} {
			#UTF::Message INFO "" "Removing $::p2p_display_str $::array_sta_p2p(${sta_wlan_index})"
			set idx [lsearch -exact $active_interfaces $::array_sta_p2p(${sta_wlan_index})]
			set active_interfaces [lreplace $active_interfaces $idx $idx ""]							
		}
	}

	regsub -all {\{} $active_interfaces "" active_interfaces
	regsub -all {\}} $active_interfaces "" active_interfaces
	regsub -all { {2,}} $active_interfaces { } active_interfaces 
	set ::list_active_interface_objects [string trim $active_interfaces]
}

proc p2p::setup_csv_header {} {
	# access option array
	upvar {} {}

	UTF::Message LOG "Before" "::ap_connect='$::str_ap_connect' ::test_type='$::test_type' ::wlan_ap='$::wlan_ap' ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'"

	UTF::Message INFO "" "************************Func:setup_csv_header***************************"

	catch {file mkdir "$::logdir/GraphsData"}

	set csv_columns_ap_title "ApTxRate,ApMcsRate,ApMpduDensity,ApRxMcs,ApTxMcs,ApRxMcsSgi,ApTxMcsSgi,ApMcsPer,ApRxVht,ApTxVht,ApRxVhtSgi,ApTxVhtSgi,ApVhtPer"
	set csv_columns_sta_title "StaApRssi,StaApTxRateStaInfo,StaApRxRate,StaApIdleTime,StaApConnectTime,StaApState,StaApTxPkts,StaApTxFailures,StaState,StaTxRate,StaMcsRate,StaRssi,StaMpduDensity,StaRxMcs,StaTxMcs,StaRxMcsSgi,StaTxMcsSgi,StaMcsPer,StaRxVht,StaTxVht,StaRxVhtSgi,StaTxVhtSgi,StaVhtPer,StaBeaconRate"
	if {$::roaming_test_flag} {
		set csv_columns_sta_title [concat $csv_columns_sta_title ",StaBssid"]
	}
	set csv_columns_sta_throughput_title "StaThroughput,StaThroughputMin,StaThroughputMax,StaTCPRTT,StaTCPWrites,StaTCPErrors,StaTCPRetries,StaTCPUsedMemory,StaUDPLatency,StaUDPJitter,StaUDPJitterMin,StaUDPJitterMax,StaUDPLostPackets,StaUDPLostPacketsMin,StaUDPLostPacketsMax,StaUDPOutofOrderPackets,StaUDPOutofOrderPacketsMin,StaUDPOutofOrderPacketsMax,StaUDPPPS"

	regsub -all {\s} $csv_columns_ap_title "" csv_columns_ap_title
	regsub -all {\s} $csv_columns_sta_title "" csv_columns_sta_title
	regsub -all {\s} $csv_columns_sta_throughput_title "" csv_columns_sta_throughput_title

	set csv_columns_ap_title [split $csv_columns_ap_title ","]
	set csv_columns_sta_title [split $csv_columns_sta_title ","]
	set csv_columns_sta_throughput_title [split $csv_columns_sta_throughput_title ","]

	set output_str_ap ""
	
	set wlan_active_flag 0
	set p2p_active_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
	}

	if {$::wlan_ap != "" && $wlan_active_flag == 1} {
		set cnt 0

		foreach AP "$::list_ap_objects" {
			#UTF::Message INFO "" "##############################AP=$AP###################################"

			foreach column_ap "$csv_columns_ap_title" {
				if {$cnt > 0} {
					set output_str_ap [concat $output_str_ap ","]
				}

				set output_str_ap [concat $output_str_ap "${column_ap}(${AP})"] 
				incr cnt
			}

			regsub -all {\s} $output_str_ap "" output_str_ap
		}

		#UTF::Message INFO "" "output_str_ap='$output_str_ap'"
	}

	set tcp_flag 0
	set udp_flag 0
	foreach stream_index $::streams_name_list {
		if {$::array_streams_tos(${stream_index}) == "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			# this stream is a TCP
			set tcp_flag 1
		}
		if {$::array_streams_tos(${stream_index}) != "TCP" && $::array_streams_type(${stream_index}) != "BT"} {
			# this stream is a UDP
			set udp_flag 1
		}
	}

	set output_str_sta ""
	set output_str_sta_throughput ""
	set cnt 0
	set cnt_throughput 0

	foreach STA "$::list_existing_interface_objects" {
		#UTF::Message INFO "" "##############################STA=$STA###################################"
		#UTF::Message INFO "" "output_str_sta=$output_str_sta"
		#UTF::Message INFO "" "output_str_sta_throughput=$output_str_sta_throughput"

		set wlan_sta_flag 0
		set p2p_sta_flag 0
		set interface_sta_no 0
		set tmp_sta_no 0
		foreach sta_wlan_index $::list_sta_wlan_objects {
			incr tmp_sta_no
			if {[string compare $STA $sta_wlan_index] == 0} {
				set wlan_sta_flag 1
				set interface_sta_no $tmp_sta_no
				#UTF::Message INFO "" "WLAN STA='$STA' sta_no='$interface_sta_no'"
				break
			} elseif {[string compare $STA $::array_sta_p2p(${sta_wlan_index})] == 0} {
				set p2p_sta_flag 1
				set interface_sta_no $tmp_sta_no
				#UTF::Message INFO "" "$::p2p_display_str STA='$STA' sta_no='$interface_sta_no'"
				break
			}
		}

		foreach column_sta "$csv_columns_sta_title" {
			if {$cnt > 0} {
				set output_str_sta [concat $output_str_sta ","]
			}

			set output_str_sta [concat $output_str_sta "${column_sta}(${STA})"] 
			incr cnt
		}

		foreach stream_index $::streams_name_list {

			#UTF::Message INFO "" "stream_index=$stream_index"

			if {$::array_streams_sta_index_no(${stream_index}) != $interface_sta_no} {			
				#UTF::Message INFO "" "Skip stream $stream_index with STA number $::array_streams_sta_index_no(${stream_index}) since it does not belong to STA number $interface_sta_no (${STA})"
				continue
			}

			foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

				if {[regexp {StaThroughput} $column_sta_throughput]} {

					if {$::rvr_test_flag == 0} {
						# min max vaule is only for RvR
						if {[regexp {StaThroughputMin} $column_sta_throughput] || [regexp {StaThroughputMax} $column_sta_throughput]} {
							continue
						}
					}

					set var "csv_data_${column_sta_throughput}"
					if {$cnt_throughput > 0} {
						set output_str_sta_throughput [concat $output_str_sta_throughput ","]
					}

					if {$::array_streams_type(${stream_index}) == "BT"} {
						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}($(bt_root_sta))(${stream_index})"] 
					} else {
						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"]
					}
					incr cnt_throughput
				}
			}
		}

		if {$tcp_flag} {
			# TCP Writes
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPWrites} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP Errors
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPErrors} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP Retries
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPRetries} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP UsedMemory
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPUsedMemory} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# TCP RTT
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaTCPRTT} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}
		}
		
		if {$udp_flag} {
			# UDP Latency
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPLatency} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP Jitter
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPJitter} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPJitterMin} $column_sta_throughput] || [regexp {StaUDPJitterMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP LostPackets
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPLostPackets} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPLostPacketsMin} $column_sta_throughput] || [regexp {StaUDPLostPacketsMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP OutofOrderPackets
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPOutofOrderPackets} $column_sta_throughput]} {

						if {$::rvr_test_flag == 0} {
							# min max vaule is only for RvR
							if {[regexp {StaUDPOutofOrderPacketsMin} $column_sta_throughput] || [regexp {StaUDPOutofOrderPacketsMax} $column_sta_throughput]} {
								continue
							}
						}

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}

			# UDP PPS
			foreach stream_index $::streams_name_list {

				foreach column_sta_throughput "$csv_columns_sta_throughput_title" {

					if {[regexp {StaUDPPPS} $column_sta_throughput]} {

						set var "csv_data_${column_sta_throughput}"
						if {$cnt_throughput > 0} {
							set output_str_sta_throughput [concat $output_str_sta_throughput ","]
						}

						set output_str_sta_throughput [concat $output_str_sta_throughput "${column_sta_throughput}(${STA})(${stream_index})"] 
						incr cnt_throughput
					}
				}
			}
		}
	}

	regsub -all {\s} $output_str_sta "" output_str_sta
	#UTF::Message INFO "" "output_str_sta='$output_str_sta'"
	regsub -all {\s} $output_str_sta_throughput "" output_str_sta_throughput
	#UTF::Message INFO "" "output_str_sta_throughput='$output_str_sta_throughput'"

	set testnum [p2p::get_testnum]
	regsub -all {.} $testnum "_" $testnum
	set filename_data "$testnum\.test_data"
	set ::curr_csv_data_file "${filename_data}.csv"
	set ::curr_csv_data_fullname "$::logdir/GraphsData/${filename_data}.csv"
	set filename_throughput "$testnum\.test_throughput_data"
	set ::curr_csv_throughput_data_file "${filename_throughput}.csv"
	set ::curr_csv_throughput_data_fullname "$::logdir/GraphsData/${filename_throughput}.csv"
	set ::curr_gnuplot_data_line_cnt 0
	#UTF::Message INFO "" "::curr_csv_data_fullname='$::curr_csv_data_fullname'"
	set csv_data_fd [open "$::curr_csv_data_fullname" w 0644]
	puts $csv_data_fd "$::graph_label_test$::streams_report_fullname"
	#UTF::Message INFO "" "::curr_csv_throughput_data_fullname='$::curr_csv_throughput_data_fullname'"
	set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" w 0644]
	puts $csv_throughput_fd "$::graph_label_test$::streams_report_fullname"

	set ::csv_columns_throughput_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_sta_throughput"
	if {$output_str_ap != ""} {
		set ::csv_columns_data_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_ap,$output_str_sta"
	} else {
		set ::csv_columns_data_list "Time,BaseTime,Attenuation,AttenuationIncr,GnuplotCnt,$output_str_sta"
	}
	puts $csv_data_fd $::csv_columns_data_list
	close $csv_data_fd
	puts $csv_throughput_fd $::csv_columns_throughput_list
	close $csv_throughput_fd

	#UTF::Message INFO "" "::csv_columns_data_list='$::csv_columns_data_list'"
	set ::csv_columns_data_list [split $::csv_columns_data_list ","]

	#UTF::Message INFO "" "::csv_columns_throughput_list='$::csv_columns_throughput_list'"
	set ::csv_columns_throughput_list [split $::csv_columns_throughput_list ","]

	#return "<a href=\"GraphsData/${filename_data}.csv\"><b>\{CSV Data\}</b></a>&nbsp;&nbsp;<a href=\"GraphsData/${filename_throughput}.csv\"><b>\{CSV Throughput\}</b></a>"
}

proc p2p::array_init_csv_data {data_flag throughput_data_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:array_init_csv_data $data_flag $throughput_data_flag***************************"

	if {$data_flag} {
		foreach column "$::csv_columns_data_list" {
			set var "csv_data_${column}"
			catch {array unset ::${var}}
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}

	if {$throughput_data_flag} {
		foreach column_throughput "$::csv_columns_throughput_list" {
			set var "csv_data_${column_throughput}"
			catch {array unset ::${var}}
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc p2p::array_write_csv_data {data_flag throughput_data_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:array_write_csv_data $data_flag $throughput_data_flag***************************"

	set ::csv_data_Attenuation $::curr_attn_value
	set ::csv_data_AttenuationIncr $::curr_attn_incr
	set ::csv_data_GnuplotCnt $::curr_gnuplot_data_line_cnt

	if {$data_flag} {
		set output_str_data ""
		set cnt 0

		foreach column "$::csv_columns_data_list" {
			if {$cnt > 0} {
				set output_str_data [concat $output_str_data ", "]
			}

			set var "csv_data_${column}"
			set output_str_data [concat $output_str_data [expr \${::${var}}]]
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			incr cnt
		}
		
		set csv_data_fd [open "$::curr_csv_data_fullname" a 0644]
		puts $csv_data_fd $output_str_data
		close $csv_data_fd
		
		set ::last_csv_data_BaseTime $::csv_data_BaseTime
	}

	if {$throughput_data_flag} {
		set output_str_throughput ""
		set cnt_throughput 0

		foreach column_throughput "$::csv_columns_throughput_list" {
			if {$cnt_throughput > 0} {
				set output_str_throughput [concat $output_str_throughput ", "]
			}

			set var "csv_data_${column_throughput}"
			set output_str_throughput [concat $output_str_throughput [expr \${::${var}}]]
			UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
			incr cnt_throughput
		}
		
		set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" a 0644]
		puts $csv_throughput_fd $output_str_throughput
		close $csv_throughput_fd

		set ::last_csv_throughput_data_BaseTime $::csv_data_BaseTime
	}
}

proc p2p::array_setup_sta_data {sta_wlan_index delete_flag create_flag} {

	UTF::Message INFO "" "************************Func:array_setup_sta_data sta_wlan_index=$sta_wlan_index delete_flag=$delete_flag create_flag=$create_flag***************************"

	set stream_sta_data_name_list "wlan_active_flag,wlan_disassociated_flag,p2p_active_flag,p2p_disassociated_flag,host_type,lan_ip,wlan_ifname,wlan_macaddr,wlan_ip,iperf_name,iperf_ver,wlan_tcpdump_pid,wlan_tcpdump_filename,wlan_drvlog_pid,wlan_drvlog_filename,p2p,p2p_ifname,p2p_macaddr,p2p_ipv6_macaddr,p2p_ip,p2p_tcpdump_pid,p2p_tcpdump_filename,p2p_drvlog_pid,p2p_drvlog_filename"
	set stream_sta_data_name_list [split $stream_sta_data_name_list ","]

	foreach data_name "$stream_sta_data_name_list" {
		if {$delete_flag} {
			set var_del "array_sta_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			set var "array_sta_${data_name}(${sta_wlan_index})"
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc p2p::array_setup_test_data {stream_index delete_flag create_flag} {

	UTF::Message INFO "" "************************Func:array_setup_test_data stream_index=$stream_index delete_flag=$delete_flag create_flag=$create_flag***************************"
	
	set stream_test_data_name_list "sta_index_no,type,tos,direction,start_time,time_duration,report_name,file_name,plot_name_lt,plot_name_pt,plot_minmax_name_lt,cnt,src,src_ifname,dst,dst_ip,iperf_tcpwin_src,iperf_tcpwin_dst,iperf_tos,throughput_scale,udp_packet_size,udp_bandwidth,fd_rx,fdname_rx,fd_tx,fdname_tx"
	set stream_test_data_name_list [split $stream_test_data_name_list ","]
	
	foreach data_name "$stream_test_data_name_list" {
		if {$delete_flag} {
			set var_del "array_streams_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			set var "array_streams_${data_name}(${stream_index})"
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}
}

proc p2p::array_setup_results_data {stream_index delete_flag create_flag} {

	UTF::Message INFO "" "************************Func:array_setup_results_data stream_index=$stream_index delete_flag=$delete_flag create_flag=$create_flag***************************"

	set stream_results_data_name_list "throughput_skipped_flag,start_stream_time_secs,tx_stream_time_secs,rx_stream_time_secs,throughput,tcp_writes,tcp_errors,tcp_retries,tcp_used_memory,tcp_rtt,udp_latency_avg,udp_latency_min,udp_latency_max,udp_latency_stdev,udp_jitter,udp_lost_packets,udp_packet_total,udp_lost_packets_percent,udp_out_of_order_packets,udp_pps,controlchart_throughput,controlchart_tcp_retries,controlchart_tcp_used_memory,controlchart_tcp_rtt,controlchart_udp_latency,controlchart_udp_jitter,controlchart_udp_lost_packets,controlchart_udp_packet_total,controlchart_udp_lost_packets_percent,controlchart_udp_out_of_order_packets,controlchart_udp_pps,last_throughput_timestamp"
	set stream_results_data_name_list [split $stream_results_data_name_list ","]
	
	foreach data_name "$stream_results_data_name_list" {
		if {$delete_flag} {
			set var_del "array_streams_${data_name}"
			catch {array unset ::${var_del}}
			#UTF::Message INFO "" "deleted ::${var_del}"
		}

		if {$create_flag} {
			set var "array_streams_${data_name}(${stream_index})"
			set ::${var} "" 
			#UTF::Message INFO "" "::${var}=[expr \${::${var}}]"
		}
	}	
}

proc p2p::p2p_associate {} {
	
	UTF::Message INFO "" "************************Func:p2p_associate***************************"

	if {$::array_sta_host_type(${::go_wlan}) == "MacOS" && $::use_wl_for_mac == 0} {
		# do not join using passive assoc scan
		set join_param ""
	} else {
		set join_param "-p"
	}
		
	UTF::Sleep 10
	$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) scan
	UTF::Sleep 10
	if {$::p2p_security != "open"} {
		$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) join $::p2p_ssid $join_param imode bss amode wpa2psk
	} else {
		$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) join $::p2p_ssid $join_param
	}
	UTF::Sleep 10
	$sta_wlan_index wl -i $::array_sta_p2p_ifname(${sta_wlan_index}) assoc

	$sta_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${sta_wlan_index})
	UTF::Sleep 1
	$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})
	UTF::Sleep 1
}

proc p2p::ping {p2p_flag sta_wlan_index} {
	# access option array
	upvar {} {}
	upvar packet_loss_flag packet_loss_flag	
	upvar ping_error ping_error

	UTF::Message INFO "" "************************Func:ping***************************"
	
	if {$p2p_flag} {
		UTF::Message INFO "" "------------------------$::p2p_display_str Ping---------------------------"
		set type "$::p2p_display_str"
	} else {
		UTF::Message INFO "" "------------------------$::wlan_display_str Ping---------------------------"
		set type "$::wlan_display_str"
	}

	if {$(pm_mode) == 0} {
		set max_ping_time_ms 5
	} elseif {$(pm_mode) == 1} { 
		set max_ping_time_ms 250
	} else {
		set max_ping_time_ms 10
	}
	
	set rc 0
	set mac_ipv6_flag 0

	for {set loop_cnt 1} {$loop_cnt <= 2} {incr loop_cnt} {

	    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
		UTF::Message INFO "" "Start Time=$timestamp"

		
		if {$loop_cnt == 1} {
			if {$p2p_flag && $::use_wl_for_mac == 0 && $::array_sta_host_type(${::go_wlan}) == "MacOS"} {
				UTF::Message INFO "" "************************IPV6***************************"
				UTF::Message INFO "" "$::p2p_display_str $::go_display_str $::array_sta_p2p(${::go_wlan}) ping $::p2p_display_str $::gc_display_str $::array_sta_p2p(${sta_wlan_index})"
				set catch_resp [catch {$::go_wlan ping6 -c $::ping_count -I $::array_sta_p2p_ifname(${::go_wlan}) $::array_sta_p2p_ipv6_macaddr(${sta_wlan_index})} catch_msg]
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				set mac_ipv6_flag 1
			} else {			
				if {$p2p_flag} {
					catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})}
					UTF::Message INFO "" "$::p2p_display_str $::go_display_str $::array_sta_p2p(${::go_wlan}) ping $::p2p_display_str $::gc_display_str $::array_sta_p2p(${sta_wlan_index})"
					set catch_resp [catch "$::go_wlan rexec ping -c $::ping_count $::array_sta_p2p_ip(${sta_wlan_index})" catch_msg]
					catch {$::go_wlan rexec ifconfig $::array_sta_p2p_ifname(${::go_wlan})}
				} else {
					UTF::Message INFO "" "$::wlan_display_str STA $sta_wlan_index ping $::wlan_display_str endpoint $::tg_wlan with IP $::tg_wlan_ip"
					set catch_resp [catch "$sta_wlan_index rexec ping -c $::ping_count $::tg_wlan_ip" catch_msg]
				}
			}
		} else {
			if {$p2p_flag && $::use_wl_for_mac == 0 && $::array_sta_host_type(${sta_wlan_index}) == "MacOS"} {
				UTF::Message INFO "" "************************IPV6***************************"
				UTF::Message INFO "" "$::p2p_display_str $::gc_display_str $sta_wlan_index ping $::p2p_display_str $::go_display_str $::array_sta_p2p(${::go_wlan})"
				set catch_resp [catch {$sta_wlan_index ping6 -c $::ping_count -I $::array_sta_p2p_ifname(${sta_wlan_index}) $::array_sta_p2p_ipv6_macaddr(${::go_wlan})} catch_msg]
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				set mac_ipv6_flag 1
			} else {			
				if {$p2p_flag} {
					catch {$sta_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${sta_wlan_index})}
					UTF::Message INFO "" "$::p2p_display_str $::gc_display_str $sta_wlan_index ping $::p2p_display_str $::go_display_str $::array_sta_p2p(${::go_wlan})"
					set catch_resp [catch "$sta_wlan_index rexec ping -c $::ping_count $::array_sta_p2p_ip(${::go_wlan})" catch_msg]
					catch {$sta_wlan_index rexec ifconfig $::array_sta_p2p_ifname(${sta_wlan_index})}
				} else {
					if {$::soft_ap_flag == 0} {
						UTF::Message INFO "" "$::wlan_display_str endpoint $::tg_wlan ping $::wlan_display_str STA $sta_wlan_index with IP $::array_sta_wlan_ip(${sta_wlan_index})"
					} else {
						UTF::Message INFO "" "$::wlan_display_str SoftAP $::tg_wlan ping $::wlan_display_str STA $sta_wlan_index with IP $::array_sta_wlan_ip(${sta_wlan_index})"
					}
					set catch_resp [catch "$::tg_wlan rexec ping -c $::ping_count $::array_sta_wlan_ip(${sta_wlan_index})" catch_msg]
				}
			}
		}
		
	    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
		UTF::Message INFO "" "End Time=$timestamp"
		
		if {$catch_resp != 0} {
			# failed
			set rc -1
			UTF::Message ERROR "" "***Failed. $catch_msg"
		} else {
			set lines [split $catch_msg "\n"]

			set ping_cnt 0
			foreach line $lines {
				set time ""
				if {$mac_ipv6_flag} {
					# mac: "16 bytes from fe80::a811:78ff:fe97:d896%awdl0, icmp_seq=0 hlim=64 time=1.207 ms"
					regexp -nocase {hlim=.* time=([-+]?[0-9]*\.?[0-9]+) +?ms} $line - time
				} else {
					# Linux: "64 bytes from 192.168.1.234: icmp_seq=1 ttl=64 time=0.025 ms"
					regexp -nocase {ttl=.* time=([-+]?[0-9]*\.?[0-9]+) +?ms} $line - time
				}
				if {$time != ""} {
					incr ping_cnt
					if {$time > $max_ping_time_ms} {
						# failed
						UTF::Message WARN "" "Ping time $time ms is more than $max_ping_time_ms ms"
						if {$ping_cnt == 1} {
							UTF::Message INFO "" "Skipping the 1st ping long time"
						} else {
							if {$ping_error == "" || $time > $ping_error} {
								set ping_error $time
							}
						}
					}
				}
			}

			if {$ping_cnt != $::ping_count} {
				# failed
				set rc -1
				UTF::Message ERROR "" "***Failed. Packet Loss. Received $ping_cnt pings instead of $::ping_count"
				set packet_loss_flag 1	
			}
		}
		
		UTF::Message INFO "" "------------------------------"
	}

	if {$rc != 0} {
		error "$type Ping Failed"
	}
}

proc p2p::ping_test {} {
	# access option array
	upvar {} {}
	set packet_loss_flag 0	
	set ping_error ""
	set p2p_packet_loss_flag 0	
	set p2p_ping_error ""
	set wlan_packet_loss_flag 0	
	set wlan_ping_error ""

	set rc 0

	set sta_cnt 0	
	foreach sta_wlan_index $::list_sta_wlan_objects {

		UTF::Message INFO "" "************************Func:ping_test STA=$sta_wlan_index***************************"
	
		# P2P
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1 && $::p2p_load_flag} {
			set catch_msg ""
			for {set retry_cnt 1} {$retry_cnt <= 5} {incr retry_cnt} {
				set packet_loss_flag 0	
				set ping_error ""
				set catch_resp [catch {p2p::ping 1 $sta_wlan_index} catch_msg]
				if {$catch_resp == 0} {
					# if there is no packet error and ping time issue is retied 3 times, then done
					if {$ping_error < 100 || $retry_cnt >= 3} {
						break
					}
				}
				UTF::Message LOG "" "ping_test retry $retry_cnt for $::p2p_display_str"
			}

			set p2p_ping_error $ping_error
			set p2p_packet_loss_flag $packet_loss_flag
			if {$catch_resp != 0} {
				# failed
				set rc -3
				UTF::Message ERROR "P1" "***Failed. $catch_msg"
			}
		} else {
			UTF::Message LOG "" "$sta_wlan_index: No $::p2p_display_str - Skip the $::p2p_display_str ping test"
		}

		# WLAN
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1 && [string first "Direct" $::test_type] == -1} {

			if {$::nan_ping_flag || $(aibss)} {

				if {$sta_cnt == 0} {
					set endpoint_sta_index 1
				} elseif {$sta_cnt == 1} {
					set endpoint_sta_index 2
				} elseif {$sta_cnt == 2} {
					set endpoint_sta_index 0
				}
				
				set ::tg_wlan [lindex $::list_sta_wlan_objects $endpoint_sta_index]
				set ::tg_wlan_ifname $::array_sta_wlan_ifname(${::tg_wlan})
				set ::tg_wlan_ip $::array_sta_wlan_ip(${::tg_wlan})
			}

			for {set retry_cnt 1} {$retry_cnt <= 5} {incr retry_cnt} {
				set packet_loss_flag 0	
				set ping_error ""
				set catch_resp [catch {p2p::ping 0 $sta_wlan_index} catch_msg]
				if {$catch_resp == 0} {
					# if there is no packet error and ping time issue is retied 3 times, then done
					if {$ping_error < 100 || $retry_cnt >= 3} {
						break
					}
				}
				UTF::Message LOG "" "ping_test retry $retry_cnt for $::wlan_display_str"
			}

			set wlan_ping_error $ping_error
			set wlan_packet_loss_flag $packet_loss_flag
			if {$catch_resp != 0} {
				# failed
				set rc -3
				UTF::Message ERROR "P2" "***Failed. $catch_msg"
			}
		} else {
			UTF::Message LOG "" "$sta_wlan_index: No $::wlan_display_str - Skip the $::wlan_display_str ping test"
		}
	}

	set ping_error $p2p_ping_error
	if {$wlan_ping_error > $ping_error} {
		set ping_error $wlan_ping_error
	}

	# temp workaround - do not report ping time error of less than 100 ms
	if {$ping_error < 100} {
		set ping_error ""
	}
	
	if {$ping_error != ""} {
		if {$(pm_mode) == 0} {
			set max_ping_time_ms 5
		} elseif {$(pm_mode) == 1} { 
			set max_ping_time_ms 250
		} else {
			set max_ping_time_ms 10
		}

		if {$ping_error > 1} {
			UTF::Message INFO "" "Rounding ping time $ping_error"
			set ping_error [expr {round($ping_error)}]
		}
		
		set ping_error "(Ping time $ping_error ms is more than $max_ping_time_ms ms)"
		# failed
		if {$rc == 0} {
			# for roaming test, do not report ping time error since the top nested report line will show
			# this error instead of the roaming graph results
			if {$::roaming_test_flag} {
				UTF::Message INFO "" "Roaming test: Do not report error for ping time"
			} else {
				set rc -1
			}
		}
	}
	
	if {$rc == 0} {
		if {$ping_error == ""} {
			return ""
		} else {
			return $ping_error
		}
	} else {
		set err_str ""
		if {$rc == -3} {
			append err_str "(Ping Failed)"
		}
		if {$p2p_packet_loss_flag} {
			append err_str "($::p2p_display_str Packet Loss)"
		}
		if {$wlan_packet_loss_flag} {
			append err_str "($::wlan_display_str Packet Loss)"
		}
		if {$ping_error != ""} {
			append err_str "$ping_error"
		}
		
		error "$err_str"
	}
}

proc p2p::setup_tcp_window_size {} {

	UTF::Message INFO "" "************************Func:setup_tcp_window_size***************************"

	UTF::Message INFO "" "::tg_wlan=$::tg_wlan"
	UTF::Message INFO "" "::list_sta_wlan_objects=$::list_sta_wlan_objects"

	foreach item "$::tg_wlan $::list_sta_wlan_objects" {

		set type [$item hostis]
		set tcp_window_size [$item cget -tcpwindow]

		UTF::Message INFO "" "item=$item type=$type tcp_window_size=$tcp_window_size"

		if {$::soft_ap_flag == 0 && $item == $::tg_wlan} {
			UTF::Message INFO "" "No tcp_window_size for real AP $::tg_wlan"
			continue
		}

		if {$type == "Linux" || $type == "DHD" || $type == "Panda"} {

			# tcptune 

			if {$tcp_window_size == "auto" || $tcp_window_size == ""} {
				if {$tcp_window_size == "auto"} {
					UTF::Message ERROR "" "***Failed. tcpwindow parameter for $item cannot be 'auto' in the config file."
				} else {
					UTF::Message ERROR "" "***Failed. tcpwindow parameter for $item is missing in the config file."
				}
				incr ::error_cnt
				error "Bad tcpwindow parameter for $item"
			}
		
			# tcptune will adjust the window size
			set resp [$item tcptune $tcp_window_size]

			UTF::Message INFO "" "machine=$item tcptune tcp_window_size=$tcp_window_size"	
		}	
	}
}

proc p2p::setup_vars {} {

	UTF::Message INFO "" "************************Func:setup_vars***************************"

	UTF::Message INFO "" "++++++++++++++++++++++++++++++++++Endpoint Fedora++++++++++++++++++++++++++++++++++++++++++++"

	set macaddr ""
	set ::tg_lan_ip ""
	set ::tg_wlan_ip ""
	set ::tg_wlan_ipv6_macaddr ""
	set ::tg_wlan_ifname ""
	set ::tg_wlan_host_type ""
	
	if {$::tg_wlan != ""} {
		# Not Direct P2P
		set ::tg_wlan_macaddr [$::tg_wlan macaddr]
		set ::tg_wlan_macaddr [string toupper $::tg_wlan_macaddr]
		UTF::Message INFO "" "::tg_wlan_macaddr=$::tg_wlan_macaddr"

		# '-lan_ip' gives you the corp ip address
		set ::tg_lan_ip [$::tg_wlan cget -lan_ip]
		
		# '-ipaddr' gives you the 192 ip address
		# do not use "cget -ipaddr" because it could return "dhcp"
		#set ::tg_wlan_ip [$::tg_wlan cget -ipaddr]
		set ::tg_wlan_ip [$::tg_wlan ipaddr]
		UTF::Message INFO "" "::tg_wlan_ip=$::tg_wlan_ip"

		set s1 [$::tg_wlan cget -sta]
		#::tg_wlan should match [lindex $s1 0]
		set ::tg_wlan_ifname [lindex $s1 1]	
		set ::array_sta_wlan_ifname(${::tg_wlan}) $::tg_wlan_ifname
		set ::tg_wlan_host_type [$::tg_wlan hostis]
		regexp {inet6\s+(\S+)} [$::tg_wlan rexec ifconfig $::tg_wlan_ifname] match ::tg_wlan_ipv6_macaddr
	}
		
	foreach STA "$::go_wlan $::list_gc_wlan_objects" {

		if {$STA == "$::go_wlan" && $::p2p_load_flag} {
			#########################################
			# 1st Validation for GC & GO Mac Addresses
			#########################################
			p2p::validate1_mac_addr

			UTF::Message INFO "" "++++++++++++++++++++++++++++++++++GO $STA++++++++++++++++++++++++++++++++++++++++++++"
		} else {
			UTF::Message INFO "" "++++++++++++++++++++++++++++++++++GC $STA++++++++++++++++++++++++++++++++++++++++++++"
		}

		set macaddr ""
		# First get the macaddr from the UTF config
		if {$::array_sta_host_type(${STA}) != "MacOS"} {
			regexp {macaddr=(\S+)} [$STA cget -nvram_add] match macaddr
			
			if {$macaddr != ""} {
				UTF::Message INFO "" "'STA=$STA' 'nvram_add UTF Param=$macaddr"
				# STA mac_address and nvram_add value must match, otherwise the nvram_add param should be removed from the config file
				set sta_macaddr [$STA macaddr]
				set sta_macaddr [string toupper $sta_macaddr]
				set macaddr [string toupper $macaddr]
				if {$macaddr != $sta_macaddr} {				
					UTF::Message INFO "" "STA $STA with mac address $sta_macaddr does not match UTF config nvram_add $macaddr. Remove it from UTF config."
					error "$STA: Remove UTF config nvram_add $macaddr. Halting tests!"
				}				
			}
		}

		if {$macaddr == ""} {
			# Second, get the macaddr from the machine
			set macaddr [$STA macaddr]
			set macaddr [string toupper $macaddr]
		}

		set ::array_sta_wlan_macaddr(${STA}) $macaddr
		# wlan and p2p ip are not set yet. get the values from the config file
		set catch_resp [catch {$STA cget -ipaddr} ::array_sta_wlan_ip(${STA})]
		if {$::array_sta_wlan_ip(${STA}) == "" || $::array_sta_wlan_ip(${STA}) == "dhcp"} {			
			error "$STA WLAN IP is missing in UTF config file. Halting tests!"
		}

		set ::array_sta_wlan_ipv6_macaddr(${STA}) ""
		regexp {inet6\s+(\S+)} [$STA rexec ifconfig $::array_sta_wlan_ifname(${STA})] match ::array_sta_wlan_ipv6_macaddr(${STA})
		UTF::Message INFO "" "::array_sta_wlan_ipv6_macaddr(${STA})=$::array_sta_wlan_ipv6_macaddr(${STA})"

		if {$::p2p_load_flag} {
			set catch_resp [catch {$::array_sta_p2p(${STA}) cget -ipaddr} catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"	
			if {$catch_resp == 1 || $catch_msg == "dhcp"} {
				UTF::Try "UTF Config File" {
					error "$::array_sta_p2p(${STA}) $::p2p_display_str IP is missing in UTF config file"
				}
			} else {
				set ::array_sta_p2p_ip(${STA}) $catch_msg
			}
			if {$::array_sta_p2p_ip(${STA}) == ""} {			
				UTF::Sleep 5
				regexp {inet6\s+(\S+)} [$STA rexec ifconfig $::array_sta_wlan_ifname(${STA})] match ::array_sta_wlan_ipv6_macaddr(${STA})
				error "$::array_sta_p2p(${STA}) $::p2p_display_str IP is missing in UTF config file. Halting tests!"
			}
		}

		set ::array_sta_lan_ip(${STA}) [$STA cget -lan_ip]
		set ::array_sta_p2p_ipv6_macaddr(${STA}) ""

		if {$::array_sta_host_type(${STA}) == "MacOS"} {
			
			if {$::p2p_load_flag} {
				if {$::awdl_flag || $::nan2_flag} {
					if {$::array_sta_p2p_ifname(${STA}) != "awdl0"} {
						error "$STA AWDL interface name is not awdl0 in UTF config file. Halting tests!"
					}

					regexp {ether\s+(\S+)} [$STA rexec ifconfig $::array_sta_p2p_ifname(${STA})] match ::array_sta_p2p_macaddr(${STA})
					UTF::Message INFO "" "::array_sta_p2p_macaddr(${STA})=$::array_sta_p2p_macaddr(${STA})"

					# get the ipv6 mac addresses
					regexp {inet6\s+(\S+)} [$STA rexec ifconfig $::array_sta_p2p_ifname(${STA})] match ::array_sta_p2p_ipv6_macaddr(${STA})
					UTF::Message INFO "" "::array_sta_p2p_ipv6_macaddr(${STA})=$::array_sta_p2p_ipv6_macaddr(${STA})"

					if {$::array_sta_p2p_ipv6_macaddr(${STA}) == ""} {
						UTF::Sleep 5
						regexp {inet6\s+(\S+)} [$STA rexec ifconfig $::array_sta_p2p_ifname(${STA})] match ::array_sta_p2p_ipv6_macaddr(${STA})
						error "$STA AWDL interface - ipv6 is not found. Halting tests!"					
					}
				} else {
					if {$::array_sta_p2p_ifname(${STA}) != "p2p0"} {
						error "$STA $::p2p_display_str interface name is not p2p0 in UTF config file. Halting tests!"
					}

					# mac starts from p2p1 (p2p0 is reserved)
					set ::array_sta_p2p_ifname(${STA}) "p2p1"

					set p2p0_macaddr ""
					regexp {ether\s+(\S+)} [$STA rexec ifconfig p2p0] match p2p0_macaddr
					UTF::Message INFO "" "p2p0_macaddr=$p2p0_macaddr"
					set ::array_sta_p2p_macaddr(${STA}) [string replace $p2p0_macaddr 0 0 "1"]

					UTF::Message INFO "" "::array_sta_p2p_macaddr(${STA})=$::array_sta_p2p_macaddr(${STA})"
				}
			}

			# Disable P2P Firewall
			$STA rexec "/usr/libexec/airportd prefs P2PFirewall=NO"
		} else {
			set ::array_sta_p2p_macaddr(${STA}) [string replace $::array_sta_wlan_macaddr(${STA}) 0 0 "1"]
			UTF::Message INFO "" "::array_sta_p2p_macaddr(${STA})=$::array_sta_p2p_macaddr(${STA})"
		}
	}

	UTF::Message INFO "" "============================================***************Info***************============================================"
	UTF::Message LOG "" "::list_ap_objects=$::list_ap_objects"	
	UTF::Message LOG "" "::list_possible_interface_objects=$::list_possible_interface_objects"	
	UTF::Message LOG "" "::list_existing_interface_objects=$::list_existing_interface_objects"	
	UTF::Message LOG "" "::list_active_interface_objects=$::list_active_interface_objects"	
	UTF::Message INFO "" "============================================"
	UTF::Message LOG "" "AP=$::wlan_ap"	
	if {$::tg_wlan != ""} {
		UTF::Message LOG "" "UTF Endpoint=$::tg_wlan IP=$::tg_wlan_ip ifname=$::tg_wlan_ifname macaddr=$::tg_wlan_macaddr" 
	}
	UTF::Message INFO "" "============================================"

	foreach sta_wlan_index $::list_gc_wlan_objects {
		UTF::Message LOG "" "GC WLAN $sta_wlan_index"	
		UTF::Message LOG "" "gc_wlan=$sta_wlan_index IP=$::array_sta_wlan_ip(${sta_wlan_index}) ifname=$::array_sta_wlan_ifname(${sta_wlan_index}) macaddr=$::array_sta_wlan_macaddr(${sta_wlan_index})" 
	}
	UTF::Message INFO "" "============================================"
	
	if {$::p2p_load_flag} {
		foreach sta_wlan_index $::list_gc_wlan_objects {
			UTF::Message LOG "" "GC $::p2p_display_str $sta_wlan_index"	
			UTF::Message LOG "" "gc_p2p=$::array_sta_p2p(${sta_wlan_index}) IP=$::array_sta_p2p_ip(${sta_wlan_index}) ifname=$::array_sta_p2p_ifname(${sta_wlan_index})" 
		}
		UTF::Message INFO "" "============================================"
		UTF::Message LOG "" "GO"	
		UTF::Message LOG "" "go_wlan=$::go_wlan IP=$::array_sta_wlan_ip(${::go_wlan}) ifname=$::array_sta_wlan_ifname(${::go_wlan}) macaddr=$::array_sta_wlan_macaddr(${::go_wlan})" 
		UTF::Message LOG "" "go_p2p=$::array_sta_p2p(${::go_wlan}) IP=$::array_sta_p2p_ip(${::go_wlan}) ifname=$::array_sta_p2p_ifname(${::go_wlan})" 
		UTF::Message LOG "" "p2p_chan_list=$::p2p_chan_list" 		
		UTF::Message INFO "" "============================================"
	}
	UTF::Message LOG "" "wlan_chan_list=$::wlan_chan_list" 		
	UTF::Message LOG "" "ap_connect_list=$::ap_connect_list" 		
	UTF::Message LOG "" "curr_udp_bandwidth=$::curr_udp_bandwidth" 		
	UTF::Message LOG "" "curr_udp_packet_size=$::curr_udp_packet_size" 		
	UTF::Message INFO "" "-------------------endpoint-----------------------"
	catch {$::tg_wlan rexec ifconfig -a}
	UTF::Message INFO "" "---------------------STA---------------------"
	foreach sta_wlan_index $::list_gc_wlan_objects {
		catch {$sta_wlan_index rexec ifconfig -a}
	}
	if {$::p2p_load_flag} {
		UTF::Message INFO "" "-------------------GO-----------------------"
		catch {$::go_wlan rexec ifconfig -a}

		UTF::Message INFO "" "=============================================================================="

		#########################################
		# 2nd Validation for GC & GO Mac Addresses
		#########################################
		p2p::validate2_mac_addr
	}
}

proc p2p::validate1_mac_addr {} {

	UTF::Message INFO "" "************************Func:validate1_mac_addr***************************"

	set otp_err_flag 0
	set nvram_add_err_flag 0

	# build a list of all mac addresses
	set list_mac_addresses ""
	
	set go_macaddr [$::go_wlan macaddr]
	set go_macaddr [string toupper $go_macaddr]
	append list_mac_addresses "$go_macaddr "
	
	foreach sta_wlan_index $::list_gc_wlan_objects {
		set gc_macaddr [$sta_wlan_index macaddr]
		set gc_macaddr [string toupper $gc_macaddr]
		append list_mac_addresses "$gc_macaddr "
	}

	set list_mac_addresses [string trim $list_mac_addresses]

	# check for duplicate mac addresses
	foreach mac_address $list_mac_addresses {
		set mac_address_index_first [string first $mac_address $list_mac_addresses]
		set mac_address_index_last  [string last  $mac_address $list_mac_addresses]
	
		if {$mac_address_index_first != $mac_address_index_last} {
			set otp_err_flag 1
			UTF::Message INFO "" "Found duplicate Mac addresses for '$mac_address' in '$list_mac_addresses'"
			break
		}
	}

	if {$otp_err_flag == 1} {
		UTF::Message INFO "" "Found OTP programming issue"

		# to fix otp issue, all STAs must have 'nvram_add' parameter in the config file
		foreach sta_index $::list_sta_wlan_objects {
			set sta_macaddr ""
			regexp {macaddr=(\S+)} [$sta_index cget -nvram_add] match sta_macaddr
			if {$sta_macaddr == ""} {
				set nvram_add_err_flag 1
				UTF::Message ERROR "" "***Failed. OTP programming issue. STA $sta_index is missing 'nvram_add' parameter in the UTF config file"
			}
		}
		
		if {$nvram_add_err_flag == 1} {
			error "OTP programming issue. 'nvram_add' parameter missing in config file. Halting tests!"
		}
	}
}

proc p2p::validate2_mac_addr {} {

	UTF::Message INFO "" "************************Func:validate2_mac_addr***************************"

	# look for duplicate mac address
	set otp_err_flag 0

	# if UTF config macaddr does not match the [STA macaddr], then there is OTP programming issue
	set tmp [$::go_wlan macaddr]
	set tmp [string toupper $tmp]
	if {$tmp != $::array_sta_wlan_macaddr(${::go_wlan})} {
		set otp_err_flag 1
		UTF::Message INFO "" "Found OTP programming issue"
		UTF::Message INFO "" "go_wlan macaddr = $tmp instead of $::array_sta_wlan_macaddr(${::go_wlan})"
	}
	
	foreach sta_wlan_index $::list_gc_wlan_objects {

		# if UTF config macaddr does not match the [STA macaddr], then there is OTP programming issue
		set tmp [$sta_wlan_index macaddr]
		set tmp [string toupper $tmp]
		if {$tmp != $::array_sta_wlan_macaddr(${sta_wlan_index})} {
			set otp_err_flag 1
			UTF::Message INFO "" "Found OTP programming issue"
			UTF::Message INFO "" "GC sta_wlan_index macaddr = $tmp instead of $::array_sta_wlan_macaddr(${sta_wlan_index})"
			break
		}
	}

	if {$otp_err_flag == 1} {

		UTF::Try "Fix Mac Addresses" {

			foreach sta_index $::list_sta_wlan_objects {
				UTF::Message INFO "" "************************OTP Programming Issue************************"

				regexp {macaddr=(\S+)} [$sta_index cget -nvram_add] match macaddr
				set macaddr [string toupper $macaddr]
				if {$sta_index == $::go_wlan} {
					set ifname $::array_sta_wlan_ifname(${::go_wlan})
				} else {
					set ifname $::array_sta_wlan_ifname(${sta_index})
				}
				
				$sta_index rexec ifconfig $::array_sta_wlan_ifname(${sta_index}) hw ether $macaddr
				UTF::Sleep 1
				set tmp [$sta_index rexec ifconfig $::array_sta_wlan_ifname(${sta_index})]
				set new_macaddr ""
				regexp {Ethernet\s+HWaddr\s+(\S+)} $tmp match new_macaddr
				if {$new_macaddr == ""} {
					regexp {ether\s+(\S+)} $tmp match new_macaddr
				}
				if {$new_macaddr == ""} {
					incr ::error_cnt
					error "macaddr is blank. Halting tests!"
				}
				set new_macaddr [string toupper $new_macaddr]

				if {$sta_index == $::go_wlan} {
					set ::array_sta_wlan_macaddr(${::go_wlan}) $new_macaddr
					UTF::Message INFO "" "::array_sta_wlan_macaddr(${::go_wlan})=$::array_sta_wlan_macaddr(${::go_wlan})"
				} else {
					set ::array_sta_wlan_macaddr(${sta_index}) $new_macaddr
					UTF::Message INFO "" "::array_sta_wlan_macaddr(${sta_index})=$::array_sta_wlan_macaddr(${sta_index})"
				}
				
				if {$new_macaddr != $macaddr} {
					incr ::error_cnt
					error "$sta_index macaddr=$new_macaddr instead of $macaddr. Halting tests!"
				}
			}
				
			return "OTP Programming Issue"
		}
	}
}

proc p2p::channel_switch_time {STA STA_ifname title} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:channel_switch_time***************************"

	set branch [$STA branchname]
	set Channelswitch_value ""
	set Bandswitch_value ""

	UTF::Try "$STA: $title Channel Switch Time" {

		set catch_resp [catch "$STA wl -i $STA_ifname dump chanswitch" dump]

		if {$catch_resp != 0} {
			UTF::Message INFO $STA "$dump"
			set Bandswitch_value "N/A"
			if {[regexp {Unsupported} $dump]} {
				return "N/A"
			} else {
				return "$dump"
			}
		}
		if {![regexp {(Channelswitch: .*? Samples)} $dump - chan]} {
			UTF::Message INFO $STA "No channelswitch information"
			set Bandswitch_value "N/A"
			return "N/A"
		}

		# channel switch value
		# wlc_set_chanspec: Channelswitch: Avg 3.178 Millisecs, 8 Samples

		if {[regexp {Channelswitch: Avg (\d+\.\d+)} $dump match Channelswitch_value]} {
			UTF::Message INFO "" "Channelswitch=$Channelswitch_value"
		}

		# band switch value
		#wlc_set_chanspec: Bandswitch: Avg 5.229 Millisecs, 5 Samples
		if {[regexp {Bandswitch: Avg (\d+\.\d+)} $dump match Bandswitch_value]} {
			UTF::Message INFO "" "Bandswitch=$Bandswitch_value"
		} else {
			UTF::Message INFO $STA "No bandswitch information"
			set Bandswitch_value "N/A"
		}

		if {$Channelswitch_value == "" || $Channelswitch_value == "N/A"} {
			return "N/A"
		}

		set key [concat $branch chanswitch $STA]
		set html_results [p2p::control_chart "" $Channelswitch_value $key "Channel Switch Time" "ms" 0]
		# zero and low are OK
		regsub { ZERO} $html_results { OK} html_results
		regsub { LOW} $html_results { OK} html_results
		return "html: $html_results"
	}
	
	UTF::Try "$STA: $title Band Switch Time" {

		if {$Bandswitch_value == "" || $Bandswitch_value == "N/A"} {
			return "N/A"
		}

		set key [concat $branch bandswitch $STA]
		set html_results [p2p::control_chart "" $Bandswitch_value $key "Band Switch Time" "ms" 0]
		regsub { ZERO} $html_results { OK} html_results
		regsub { LOW} $html_results { OK} html_results
		return "html: $html_results"
	}
}	

proc p2p::get_beacon_rate {} {

	UTF::Message INFO "" "************************Func:get_beacon_rate***************************"

	# Default driver bi=100 ms, therfore we should see 10 beacons/sec
	if {$::wlan_ap != ""} {
		catch {$::wlan_ap wl bi}
	}
	
	if {$::ap_connect == "GO"} {
		set gc_wlan_index $::go_wlan
		set station_ifname $::array_sta_wlan_ifname(${::go_wlan})

		catch {$gc_wlan_index wl PM}
		catch {$gc_wlan_index wl bi}

		set output [$gc_wlan_index wl -i $station_ifname counters rxbeaconmbss]
		regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate1
		UTF::Sleep 10
		set output [$gc_wlan_index wl -i $station_ifname counters rxbeaconmbss]
		regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate2
		set go_bcnrate [format "%2.1f" [expr {[expr {$bcnrate2 - $bcnrate1}] / 10.0}]]

		UTF::Message INFO "" "GO rxbeaconmbss=($bcnrate2 - $bcnrate1) / 10 sec=$go_bcnrate"
		UTF::Message INFO "" "GO BeaconRxRate: ${go_bcnrate}/s"
	}

	foreach gc_wlan_index $::list_gc_wlan_objects {

		set station_ifname $::array_sta_wlan_ifname(${gc_wlan_index})

		UTF::Try "$gc_wlan_index: Get Beacon Rate" {

			catch {$gc_wlan_index wl PM}

			set output [$gc_wlan_index wl -i $station_ifname counters rxbeaconmbss]
			regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate1
			UTF::Sleep 10
			set output [$gc_wlan_index wl -i $station_ifname counters rxbeaconmbss]
			regexp {rxbeaconmbss\s([0-9]+)} $output - bcnrate2
			set bcnrate [format "%2.1f" [expr {[expr {$bcnrate2 - $bcnrate1}] / 10.0}]]

			UTF::Message INFO "" "rxbeaconmbss=($bcnrate2 - $bcnrate1) / 10 sec=$bcnrate"
			UTF::Message INFO "" "BeaconRxRate: ${bcnrate}/s"

			if {$::ap_connect == "GO"} {
				set total_bcnrate [expr {$go_bcnrate + $bcnrate}]
				UTF::Message INFO "" "Total BeaconRxRate: ($go_bcnrate + $bcnrate)=$total_bcnrate"
			} else {
				set total_bcnrate $bcnrate
			}

			set final_ckey "$::ckey BeaconRate"
			set total_bcnrate "$total_bcnrate $total_bcnrate $total_bcnrate"
			set html_results [p2p::control_chart "" $total_bcnrate $final_ckey "Beacons" "Sec" 0]
			return "html: $html_results"
		}
    }
}

proc p2p::change_beacon_interval {new_bi} {

	UTF::Message INFO "" "************************Func:change_beacon_interval***************************"

	UTF::Try "$::wlan_ap: Change Beacon Interval to $new_bi" {

		$::wlan_ap wl bi
		$::wlan_ap wl bi $new_bi
		$::wlan_ap wl down
		UTF::Sleep 2
		$::wlan_ap wl up
		UTF::Sleep 5
		$::wlan_ap wl bi
	}
}

proc p2p::get_dhd_memory_dump {} {
	# access option array
	upvar {} {}

	foreach STA "$::list_gc_wlan_objects $::go_wlan" {

		UTF::Message LOG "" "STA=$STA"

		if {$STA == $::go_wlan} {
			set sta_host_type $::array_sta_host_type(${::go_wlan})
		} else {
			UTF::Message LOG "" "::array_sta_host_type(${STA})"
			UTF::Message LOG "" "$::array_sta_host_type(${STA})"
			set sta_host_type $::array_sta_host_type(${STA})
		}

		UTF::Message LOG "" "sta_host_type=$sta_host_type"

		if {$sta_host_type == "DHD"} {

			UTF::Message INFO "" "************************Func:get_dhd_memory_dump***************************"

			# If the dump was triggered by messages from DHD, the dump is called dongle_dhd.dmp
			# If the dump was triggered by sdio errors, the dump is called dongle_sderr.dmp
			# If the dump was triggered by FW messages, the dump is called dongle.dmp
			
			foreach dmp_name "dongle_dhd dongle_sderr dongle" {

				UTF::Message LOG "" "Check for file /root/$dmp_name\.dmp"
				set catch_resp [catch "$STA rexec ls -la /root/$dmp_name\.dmp" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp == 0} {

					UTF::Try "$STA: DHD Memory Dump" {
						set testnum [p2p::get_testnum]
						set test_dir [file dirname $UTF::Logfile]

						UTF::Message INFO "" "$STA copyfrom /root/$dmp_name\.dmp $test_dir/$testnum.$STA.$dmp_name\.dmp"
						set catch_resp [catch "$STA copyfrom /root/$dmp_name\.dmp $test_dir/$testnum.$STA.$dmp_name\.dmp" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: scp catch_msg=$catch_msg"
						} else {
							set catch_resp [catch "exec ls -la $test_dir/$testnum.$STA.$dmp_name\.dmp" catch_msg]
							UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

							UTF::Message INFO "" "$STA rm -f /root/$dmp_name\.dmp"
							set catch_resp [catch "$STA rm -f /root/$dmp_name\.dmp" catch_msg]

							if {$catch_resp != 0} {
							   error "ERROR: rm catch_msg=$catch_msg"
							}
						}

						UTF::Message INFO "" "PASS. Captured File: $testnum.$STA.$dmp_name\.dmp"
						UTF::Message INFO "" "========================================================================================================="

						if {![file exists "$test_dir/rtecdc.exe"]} {
							# copying rtecdc.exe to the report location
							set catch_resp [catch "$STA rexec readlink /root/hndrte-exe.lnk" catch_msg]			
							UTF::Message INFO "" "$STA copyfrom $catch_msg $test_dir"
							set catch_resp [catch "$STA copyfrom $catch_msg $test_dir" catch_msg]
						}
						
						error "Captured File: $testnum.$STA.$dmp_name\.dmp"
					}
				}
			}
			
			UTF::Message LOG "" "Check for file /soc_ram.bin"
			set catch_resp [catch "$STA rexec ls -la /soc_ram.bin" catch_msg]
        	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} {

				UTF::Try "$STA: DHD 'soc_ram.bin' Dump" {
					set testnum [p2p::get_testnum]
					set test_dir [file dirname $UTF::Logfile]

					UTF::Message INFO "" "$STA copyfrom /soc_ram.bin $test_dir/$testnum.$STA.soc_ram.bin"
					set catch_resp [catch "$STA copyfrom /soc_ram.bin $test_dir/$testnum.$STA.soc_ram.bin" catch_msg]

					if {$catch_resp != 0} {
					   error "ERROR: scp catch_msg=$catch_msg"
					} else {
						set catch_resp [catch "exec ls -la $test_dir/$testnum.$STA.soc_ram.bin" catch_msg]
						UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						
						UTF::Message INFO "" "$STA rm -f /soc_ram.bin"
						set catch_resp [catch "$STA rm -f /soc_ram.bin" catch_msg]

						if {$catch_resp != 0} {
						   error "ERROR: rm catch_msg=$catch_msg"
						}
					}

					UTF::Message INFO "" "PASS. Captured File: $testnum.$STA.soc_ram.bin"
					UTF::Message INFO "" "========================================================================================================="
					error "Captured File: $testnum.$STA.soc_ram.bin"
				}
			}
		}
	}
	
	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "F" "::UTF::panic=$::panic_msg"
		set ::test_error_flag 1
	}
}

proc p2p::get_dhd_socram_dump {} {
	# access option array
	upvar {} {}

	foreach STA "$::list_gc_wlan_objects $::go_wlan" {

		UTF::Message LOG "" "STA=$STA"

		if {$STA == $::go_wlan} {
			set sta_host_type $::array_sta_host_type(${::go_wlan})
		} else {
			UTF::Message LOG "" "::array_sta_host_type(${STA})"
			UTF::Message LOG "" "$::array_sta_host_type(${STA})"
			set sta_host_type $::array_sta_host_type(${STA})
		}

		UTF::Message LOG "" "sta_host_type=$sta_host_type"

		if {$sta_host_type == "DHD"} {

			UTF::Message INFO "" "************************Func:get_dhd_socram_dump***************************"
			
			if {$::debug2_flag == 1} {
				UTF::Try "$STA: Socram and FW Image Dump" {
					set testnum [p2p::get_testnum]
					set test_dir [file dirname $UTF::Logfile]

					if {![file exists "$test_dir/rtecdc.exe"]} {
						# copying rtecdc.exe to the report location
						set catch_resp [catch "$STA rexec readlink /root/hndrte-exe.lnk" catch_msg]			
						UTF::Message INFO "" "$STA copyfrom $catch_msg $test_dir"
						set catch_resp [catch "$STA copyfrom $catch_msg $test_dir" catch_msg]
					}
					
					$STA dhd -i $::array_sta_wlan_ifname(${STA}) upload socram.bin
					UTF::Message INFO "" "$STA copyfrom /root/socram.bin $test_dir/$testnum.$STA.socram.bin"
					set catch_resp [catch "$STA copyfrom /root/socram.bin $test_dir/$testnum.$STA.socram.bin" catch_msg]
						
					UTF::Message INFO "" "$STA rm -f /root/socram.bin"
					set catch_resp [catch "$STA rm -f /root/socram.bin" catch_msg]
					
					return ""
				}
			}			
		}
	}
}

proc p2p::get_sniffer_data {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:get_sniffer_data***************************"

	UTF::Try "Sniffer Data for Channel $::sniffer_channel" {

		catch {$::sniffer_object rexec ifconfig -a}
		UTF::Message INFO "" "------------------------------------------"

		UTF::Message LOG "" "Check for sniffer file /tmp/$::sniffer_filename"
		set catch_resp [catch "$::sniffer_object rexec ls -la /tmp/$::sniffer_filename" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp == 0} {

			set testnum [p2p::get_testnum]
			set test_dir [file dirname $UTF::Logfile]

			UTF::Message INFO "" "$::sniffer_object copyfrom /tmp/$::sniffer_filename $test_dir/$testnum.$::sniffer_filename"
			set catch_resp [catch "$::sniffer_object copyfrom /tmp/$::sniffer_filename $test_dir/$testnum.$::sniffer_filename" catch_msg]

			if {$catch_resp != 0} {
			   error "ERROR: scp catch_msg=$catch_msg"
			} else {
				catch "exec chmod 755 $test_dir/$testnum.$::sniffer_filename"
				set catch_resp [catch "exec ls -la $test_dir/$testnum.$::sniffer_filename" catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

				UTF::Message INFO "" "$::sniffer_object rm -f /tmp/$::sniffer_filename"
				set catch_resp [catch "$::sniffer_object rm -f /tmp/$::sniffer_filename" catch_msg]

				if {$catch_resp != 0} {
				   error "ERROR: rm catch_msg=$catch_msg"
				}
			}

			UTF::Message INFO "" "PASS. Captured Sniffer File: $test_dir/$testnum.$::sniffer_filename"
			return "html: <a href=\"$test_dir/$testnum.$::sniffer_filename\">{Sniffer pcap File}</a>"
		} else {
			error "/tmp/$::sniffer_filename missing on $::sniffer_object"
		}
	}
}

proc p2p::unload_sta_driver {} {
	# access option array
	upvar {} {}

	UTF::Try "Running Processes" {

		foreach STA $::list_sta_wlan_objects {

			UTF::Try "$STA" {
				UTF::Message INFO "" "Dumping Running Processes to catch 'fork' issue"
				set catch_resp [catch "$STA ps -ef f" catch_msg]
				UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Message INFO "" "-----------------------------------------------"
			}

			catch {$STA deinit}
		}

		if {$::tg_wlan != ""} {
			set skip_tg_wlan_flag 0
			foreach STA $::list_sta_wlan_objects {
				if {$::tg_wlan == $STA} {
					set skip_tg_wlan_flag 1
					break
				}
			}
			
			if {$skip_tg_wlan_flag == 0} {
				if {$::soft_ap_flag == 1} {
					UTF::Try "SoftAP: $::tg_wlan" {
						set catch_resp [catch "$::tg_wlan ps -ef f" catch_msg]
						UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
						UTF::Message INFO "" "-----------------------------------------------"
					}
				}
				UTF::Try "Endpoint: $::tg_wlan" {
					set catch_resp [catch "exec ps -ef f" catch_msg]
					UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Message INFO "" "-----------------------------------------------"
				}
			}
		}
	}
	
	UTF::Message INFO "" "************************Func:unload_sta_driver***************************"

	UTF::Try "Unload Driver" {

		# 1st cleanup the P2P interface
		foreach sta_wlan_index $::list_gc_wlan_objects {
			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
				UTF::Try "$::p2p_display_str Cleanup" {
					p2p::p2p_cleanup
				}
			}
		}

		foreach STA $::list_sta_wlan_objects {

			UTF::Try "$STA" {
				$STA unload
			}

			catch {$STA deinit}
		}
	}
}

proc p2p::create_summary_graphs_link {} {

	UTF::Message INFO "" "************************Func:create_summary_graphs_link***************************"

	set testnum [p2p::get_testnum]
	regsub -all {.} $testnum "_" $testnum

	set ::graphs_all_list ""

	set wlan_active_flag 0
	set p2p_active_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
	}

	# both TCP and UDP graphs are processed
	foreach graph_name "$::throughput_graphs_name_list" {
		lappend ::graphs_all_list "${graph_name}"
	}
	
	foreach object "$::list_existing_interface_objects $::list_ap_objects" {

		if {$object == $::wlan_ap || $object == $::roaming_src_ap || $object == $::roaming_dst_ap} {
			set object_type "Ap"
			set ap_flag 1
		} else {
			set object_type "Sta"
			set ap_flag 0
		}

		set ampdu_heatmap_flag 0
		if {$ap_flag == 1 && $wlan_active_flag == 1} {
			# AP with WLAN active - ampdu_heatmap graphs are needed
			set ampdu_heatmap_flag 1
		}

		if {[lsearch -exact $::list_gc_wlan_objects $object] >= 0 || [string compare $object $::go_wlan] == 0} {
			if {$wlan_active_flag == 1} {
				# WLAN STA with WLAN active - ampdu_heatmap graphs are needed
				set ampdu_heatmap_flag 1
			}
			if {$::p2p_load_flag && ([string compare $object $::array_sta_p2p(${object})] == 0 || [string compare $object $::array_sta_p2p(${::go_wlan})] == 0) && $p2p_active_flag == 1 && $wlan_active_flag == 0} {
				# P2P STA with P2P active - ampdu_heatmap graphs are needed
				set ampdu_heatmap_flag 1
			}
		}

		if {$ampdu_heatmap_flag} {
			set graphs_list "$::graphs_name_list $::ampdu_heatmap_graphs_name_list"
		} else {
			set graphs_list "$::graphs_name_list"
		}

		foreach graph_name $graphs_list {

			if {[string first $object_type $graph_name] == 0} {
				lappend ::graphs_all_list "${graph_name}(${object})"
			}
		}
	}
	
	lappend ::graphs_all_list $::other_graphs_name_list
	regsub -all {\{} $::graphs_all_list "" ::graphs_all_list
	regsub -all {\}} $::graphs_all_list "" ::graphs_all_list
	# do not sort, so throughput graph is first	
	#set ::graphs_all_list [lsort $::graphs_all_list]
	UTF::Message INFO "" "::graphs_all_list=$::graphs_all_list"
	
	foreach graph_name $::graphs_all_list {

		if {$graph_name == "CSVThroughput" || $graph_name == "CSVData" || $graph_name == "MainReport"} {
			continue
		}

		set htmFile [open $::logdir/GraphsData/$testnum.${graph_name}.htm w 0644]
		puts $htmFile {<?xml version="1.0" encoding="utf-8"?>}
		puts $htmFile {<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">}
		puts $htmFile {<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">}
		puts $htmFile ""
		puts $htmFile "<head>"
		puts $htmFile "<title></title>"
		puts $htmFile "<style>"
		puts $htmFile ""
		puts $htmFile "p.small \{line-height:70%;\}"
		puts $htmFile "p.medium \{line-height:90%;\}"
		puts $htmFile "</style>"
		puts $htmFile "</head>"
		puts $htmFile ""
		puts $htmFile "<body>"
		puts $htmFile "<p class=\"small\">"
		puts $htmFile ""

		puts $htmFile "<font size=\"2\" color=\"blue\">"

		foreach sta_graph_name $::throughput_graphs_name_list {
			if {[string first "Sta" $sta_graph_name] == 0} {
				set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
				set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}.png"
				if {[file exists "$png_file"]} {
					puts $htmFile "<a href=\"$testnum.${sta_graph_name}.htm\">{$sta_graph_name_short}</a>"	
				} else {
					puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
				}
			}
		}
		foreach other_graph_name $::other_graphs_name_list {
			if {$other_graph_name == "MainReport"} {
				puts $htmFile "<a href=\"../summary.html\">{MainReport}</a>"		
			} elseif {$other_graph_name == "CSVThroughput"} {
				puts $htmFile "<a href=\"$::curr_csv_throughput_data_file\">{CSV Throughput}</a>"		
			} elseif {$other_graph_name == "CSVData"} {
				puts $htmFile "<a href=\"$::curr_csv_data_file\">{CSV Data}</a>"		
			} else {
				puts $htmFile "<a href=\"$testnum.$other_graph_name.htm\">{$other_graph_name}</a>"		
			}
		}
		puts $htmFile "</font><br>"
		puts $htmFile "<br>"
		puts $htmFile ""
		
		foreach STA "$::list_existing_interface_objects" {

			set wlan_sta_flag 0
			set p2p_sta_flag 0
			foreach sta_wlan_index $::list_sta_wlan_objects {
				if {[string compare $STA $sta_wlan_index] == 0} {
					#UTF::Message INFO "" "WLAN STA $STA"
					set wlan_sta_flag 1
				}
				if {$::p2p_load_flag && [string compare $STA $::array_sta_p2p(${sta_wlan_index})] == 0} {
					#UTF::Message INFO "" "$::p2p_display_str STA $STA"
					set p2p_sta_flag 1
				}
			}
		
			if {$::wlan_only_flag} {
				# one STA only
				set sta_str "STA"
			} elseif {$::p2p_load_flag && [string compare $STA $::array_sta_p2p(${::go_wlan})] == 0} {
				set sta_str "$::p2p_display_str $::go_display_str"
			} elseif {$::p2p_load_flag && [string compare $STA $::go_wlan] == 0} {
				set sta_str "$::wlan_display_str $::go_display_str"
			} elseif {$p2p_sta_flag == 1} {
				set sta_str "$::p2p_display_str $::gc_display_str"
			} else {
				set sta_str "$::wlan_display_str $::gc_display_str"
			}
		
			puts $htmFile "<font size=\"2\" color=\"black\"><b>$sta_str </b></font>"
			puts $htmFile "<font size=\"2\" color=\"red\"><b>$STA</b></font>"
			puts $htmFile "<font size=\"2\" color=\"black\"><b> Graphs: </b></font>"
			puts $htmFile "<font size=\"2\" color=\"blue\">"
			foreach sta_graph_name $::graphs_name_list {
				if {$p2p_sta_flag == 1} {
					if {$sta_graph_name == "StaApConnectTime" || $sta_graph_name == "StaApRssi"} {
						UTF::Message INFO "" "For P2P, skip graphing $sta_graph_name"
						continue
					}
				}
					
				if {[string first "Sta" $sta_graph_name] == 0} {
					set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
					if {!([string first "StaThroughput" $sta_graph_name] == 0 || [string first "StaTCPWrites" $sta_graph_name] == 0 || [string first "StaTCPErrors" $sta_graph_name] == 0 || [string first "StaTCPRetries" $sta_graph_name] == 0 || [string first "StaTCPUsedMemory" $sta_graph_name] == 0 || [string first "StaTCPRTT" $sta_graph_name] == 0 \
					      || [string first "StaUDPLatency" $sta_graph_name] == 0 || [string first "StaUDPJitter" $sta_graph_name] == 0 || [string first "StaUDPLostPackets" $sta_graph_name] == 0 || [string first "StaUDPOutofOrderPackets" $sta_graph_name] == 0 || [string first "StaUDPPPS" $sta_graph_name] == 0)} {
						set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}(${STA}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${sta_graph_name}(${STA}).htm\">{$sta_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
						}
					}
				}
			}
			puts $htmFile "</font><br>"
			puts $htmFile ""

			set ampdu_heatmap_flag 0
			if {[lsearch -exact $::list_gc_wlan_objects $STA] >= 0 || [string compare $STA $::go_wlan] == 0} {
				if {$wlan_active_flag == 1} {
					# WLAN STA with WLAN active - ampdu_heatmap graphs are needed
					set ampdu_heatmap_flag 1
				}
				if {$::p2p_load_flag && ([string compare $STA $::array_sta_p2p(${STA})] == 0 || [string compare $STA $::array_sta_p2p(${::go_wlan})] == 0) && $p2p_active_flag == 1 && $wlan_active_flag == 0} {
					# P2P STA with P2P active - ampdu_heatmap graphs are needed
					set ampdu_heatmap_flag 1
				}
			}

			if {$ampdu_heatmap_flag} {
				set tmp_str "$sta_str $STA Graphs: "
				regsub -all {.} $tmp_str {\&nbsp;\&nbsp;} tmp_str

				puts $htmFile "<font size=\"2\" color=\"black\"><b>$tmp_str</b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach sta_graph_name $::ampdu_heatmap_graphs_name_list {
					if {[string first "Sta" $sta_graph_name] == 0} {
						set sta_graph_name_short [string replace $sta_graph_name 0 2 ""]
						set png_file "$::logdir/GraphsData/$testnum.${sta_graph_name}(${STA}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${sta_graph_name}(${STA}).htm\">{$sta_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$sta_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""
			}
		}

		if {$::wlan_ap != "" && $wlan_active_flag == 1} {
			foreach AP "$::list_ap_objects" {
				puts $htmFile "<font size=\"2\" color=\"black\"><b>AP </b></font>"
				puts $htmFile "<font size=\"2\" color=\"red\"><b>$AP</b></font>"
				puts $htmFile "<font size=\"2\" color=\"black\"><b> Graphs: </b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach ap_graph_name $::graphs_name_list {
					if {[string first "Ap" $ap_graph_name] == 0} {
						set ap_graph_name_short [string replace $ap_graph_name 0 1 ""]
						set png_file "$::logdir/GraphsData/$testnum.${ap_graph_name}(${AP}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${ap_graph_name}(${AP}).htm\">{$ap_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$ap_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""

				set tmp_str "AP $AP Graphs: "
				regsub -all {.} $tmp_str {\&nbsp;\&nbsp;} tmp_str

				puts $htmFile "<font size=\"2\" color=\"black\"><b>$tmp_str</b></font>"
				puts $htmFile "<font size=\"2\" color=\"blue\">"
				foreach ap_graph_name $::ampdu_heatmap_graphs_name_list {
					if {[string first "Ap" $ap_graph_name] == 0} {
						set ap_graph_name_short [string replace $ap_graph_name 0 1 ""]
						set png_file "$::logdir/GraphsData/$testnum.${ap_graph_name}(${AP}).png"
						if {[file exists "$png_file"]} {
							puts $htmFile "<a href=\"$testnum.${ap_graph_name}(${AP}).htm\">{$ap_graph_name_short}</a>"	
						} else {
							puts $htmFile "<a><font color=\"grey\">{$ap_graph_name_short}</font></a>"	
						}
					}
				}
				puts $htmFile "</font><br>"
				puts $htmFile ""
			}
		}
				
		puts $htmFile "</p>"
		
		puts $htmFile "<p class=\"medium\">"

		if {$::roaming_test_flag} {
			puts $htmFile "<font size=\"4\" color=\"orange\"><b>$::roaming_test_title</b></font><br>"
		}

		puts $htmFile "<font size=\"4\" color=\"orange\"><b>$::graph_label_test$::streams_report_fullname</b></font><br>"
		puts $htmFile "<font size=\"4\" color=\"orange\"><b>$graph_name Summary Graph</b></font><br>"
		puts $htmFile "</p>"
		puts $htmFile "<table border=\"0\">"
		if {$graph_name == "AllGraphs"} {
			foreach graph_all_name $::graphs_all_list {
				if {[string first "Ap" $graph_all_name] == 0 && $wlan_active_flag == 0} {
					continue
				}
				if {[string first "Ap" $graph_all_name] == 0 || [string first "Sta" $graph_all_name] == 0 } {
					set png_file "$::logdir/GraphsData/$testnum.$graph_all_name.png"
					if {[file exists "$png_file"]} {
						puts $htmFile "<tr><td>$graph_all_name</td><td><img src=\"$png_file\" alt=\"\" width=\"$::graph_max_width\" height=\"::graph_max_height\" border=\"0\"></td></tr>"
					} else {
						puts $htmFile "<tr><td>$graph_all_name</td><td><font color=\"red\">N/A</font></td></tr>"
					}
				}
			}
		} else {			
			puts $htmFile "<td><img src=\"$::logdir/GraphsData/$testnum.${graph_name}.png\" alt=\"\" width=\"$::graph_max_width\" height=\"$::graph_max_height\" border=\"0\"></td>"
		}
		puts $htmFile "</table>"
		puts $htmFile ""
		puts $htmFile "</body>"
		puts $htmFile "</HTML>"
		close $htmFile
	}

	return "<a href=\"GraphsData/$testnum.StaThroughput.htm\"><b>\{Graph Summaries\}</b></a>"
}

proc find_csv_column_index {column_title all_columns_list} {

	UTF::Message INFO "" "************************Func:find_csv_column_index***************************"

	set index [lsearch -exact $all_columns_list $column_title]
	if {$index >= 0} {
		UTF::Message LOG "" "column_title=$column_title index=$index"
	} else {
		UTF::Message LOG "" "CSV column title $column_title is not found"
	}
	
	return $index
}

proc p2p::create_summary_graphs {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_summary_graphs***************************"

	set wlan_active_flag 0
	set p2p_active_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
	}
	
	UTF::Message INFO "" "::last_csv_data_BaseTime=$::last_csv_data_BaseTime ::last_csv_throughput_data_BaseTime=$::last_csv_throughput_data_BaseTime"
	if {$::last_csv_data_BaseTime == ""} {
		# there must be no data in the 'test_data.csv' file
		# this get hit with BT only thoughput test and AWDL MacOS
		set ::last_csv_data_BaseTime $::last_csv_throughput_data_BaseTime
	}
	if {$::last_csv_throughput_data_BaseTime == ""} {
		UTF::Message ERROR "" "***Failed. ::last_csv_throughput_data_BaseTime is BLANK"
		error "Graphing failed"	
	}
	set last_csv_data_BaseTime "00:$::last_csv_data_BaseTime"
	set last_csv_data_BaseTime_tick [clock scan $last_csv_data_BaseTime]
	set last_csv_throughput_data_BaseTime "00:$::last_csv_throughput_data_BaseTime"
	set last_csv_throughput_data_BaseTime_tick [clock scan $last_csv_throughput_data_BaseTime]
	UTF::Message INFO "" "last_csv_data_BaseTime_tick=$last_csv_data_BaseTime_tick last_csv_throughput_data_BaseTime_tick=$last_csv_throughput_data_BaseTime_tick"
	
	if {$last_csv_data_BaseTime_tick > $last_csv_throughput_data_BaseTime_tick} {
		set ::gnuplot_x_max_time_val $::last_csv_data_BaseTime
	} else {
		set ::gnuplot_x_max_time_val $::last_csv_throughput_data_BaseTime
	}
	UTF::Message INFO "" "::gnuplot_x_max_time_val=$::gnuplot_x_max_time_val"
	
	####################

	if {$::bt_load_flag} {
		if {$::bt_only_flag} {
			set tmp_throughput_label "BT Throughput (Kbps)"
		} else {
			if {$::wlan_load_flag && $::p2p_load_flag} {
				set tmp_throughput_label "Throughputs (Infra & AWDL (Mbps))(BT (Kbps))"
			} elseif {$::wlan_load_flag} {
				set tmp_throughput_label "Throughputs (Infra (Mbps))(BT (Kbps))"
			} elseif {$::p2p_load_flag} {
				set tmp_throughput_label "Throughputs (AWDL (Mbps))(BT (Kbps))"
			}
		}
	} else {
		set tmp_throughput_label "Throughput (Mbps)"
	}
	
	set ::throughput_graphs_name_label_list "$tmp_throughput_label,TCP RTT (ms),TCP Writes,TCP Errors,TCP Retries,TCP Used Memory (k),UDP Latency (ms),UDP Jitter (ms),UDP Lost Packets,UDP OOO Packets,UDP PPS (pps)"
	set ::throughput_graphs_name_list "StaThroughput StaTCPRTT StaTCPWrites StaTCPErrors StaTCPRetries StaTCPUsedMemory StaUDPLatency StaUDPJitter StaUDPLostPackets StaUDPOutofOrderPackets StaUDPPPS"

	set ::graphs_name_label_list "MCS Rate (Index #),Rate (Mbps),RSSI (dB),Beacons/Sec,Connect Time (Seconds),RSSI (dB),MCS Rate (Index #),Rate (Mbps)"
	set ::graphs_name_list "StaMcsRate StaTxRate StaRssi StaBeaconRate StaApConnectTime StaApRssi ApMcsRate ApTxRate"

	set ::ampdu_heatmap_graphs_name_label_list "MPDU Density,MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),PER,VHT Rate,VHT Rate,VHT Rate,VHT Rate,PER,MPDU Density,MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),MCS Rate (Index #),PER,VHT Rate,VHT Rate,VHT Rate,VHT Rate,PER"
	set ::ampdu_heatmap_graphs_name_list "StaMpduDensity StaRxMcs StaTxMcs StaRxMcsSgi StaTxMcsSgi StaMcsPer StaRxVht StaTxVht StaRxVhtSgi StaTxVhtSgi StaVhtPer ApMpduDensity ApRxMcs ApTxMcs ApRxMcsSgi ApTxMcsSgi ApMcsPer ApRxVht ApTxVht ApRxVhtSgi ApTxVhtSgi ApVhtPer"

	set ::other_graphs_name_list "CSVThroughput CSVData AllGraphs MainReport"

	set ::throughput_graphs_name_label_list [split $::throughput_graphs_name_label_list ","]
	set ::graphs_name_label_list [split $::graphs_name_label_list ","]
	set ::ampdu_heatmap_graphs_name_label_list [split $::ampdu_heatmap_graphs_name_label_list ","]

	UTF::Message INFO "" "::list_existing_interface_objects=$::list_existing_interface_objects ::streams_name_list=$::streams_name_list"

	# both TCP and UDP graphs are processed
	foreach graph_name $::throughput_graphs_name_list graph_name_label $::throughput_graphs_name_label_list {
		p2p::create_2d_summary_graphs $graph_name $graph_name_label
	}
	
	foreach graph_name $::graphs_name_list graph_name_label $::graphs_name_label_list {
		if {[string first "Ap" $graph_name] == 0} {
			if {$wlan_active_flag == 0} {
				continue
			}
			set object_list "$::list_ap_objects"
		} else {
			set object_list "$::list_existing_interface_objects"
		}

		# if direct P2P test, then skip StaApConnectTime and StaApRssi graphs
		if {$::tg_wlan == ""} {
			if {$graph_name == "StaApConnectTime" || $graph_name == "StaApRssi"} {
				UTF::Message INFO "" "For Direct P2P, skip graphing $graph_name"
				continue
			}
		}
		
		foreach object $object_list {
			UTF::Message INFO "" "##############################object=$object###################################"
			p2p::create_2d_summary_graphs "${graph_name}(${object})" $graph_name_label
		}
	}

	foreach graph_name $::ampdu_heatmap_graphs_name_list graph_name_label $::ampdu_heatmap_graphs_name_label_list {
		if {[string first "Ap" $graph_name] == 0} {
			if {$wlan_active_flag == 0} {
				continue
			}
			set object_list "$::list_ap_objects"
		} else {
			set object_list "$::list_existing_interface_objects"
		}

		foreach object $object_list {

			# ampdu 3D graphs for P2P is the same as WLAN
			set ampdu_heatmap_flag 0
			if {$object == $::wlan_ap || $object == $::roaming_src_ap || $object == $::roaming_dst_ap} {
				set ampdu_heatmap_flag 1
			}
			if {[lsearch -exact $::list_gc_wlan_objects $object] >= 0 || [string compare $object $::go_wlan] == 0} {
				if {$wlan_active_flag == 1} {
					# WLAN STA with WLAN active - ampdu_heatmap graphs are needed
					set ampdu_heatmap_flag 1
				}
				if {$::p2p_load_flag && ([string compare $object $::array_sta_p2p(${object})] == 0 || [string compare $object $::array_sta_p2p(${::go_wlan})] == 0) && $p2p_active_flag == 1 && $wlan_active_flag == 0} {
					# P2P STA with P2P active - ampdu_heatmap graphs are needed
					set ampdu_heatmap_flag 1
				}
			}

			if {$ampdu_heatmap_flag == 0} {
				continue
			}
			UTF::Message INFO "" "##############################object=$object###################################"
			set new_graph_name "${graph_name}(${object})"
			p2p::create_3d_summary_graphs $new_graph_name $graph_name_label
		}
	}
	
	#####################################################
	#######     Create Summary Graphs Link      #########
	#####################################################
	set graph_summaries_link [p2p::create_summary_graphs_link]

	return $graph_summaries_link
}

proc p2p::create_2d_summary_graphs {graph_name graph_ylabel} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:create_2d_summary_graphs $graph_name***************************"

	set wlan_active_flag 0
	set p2p_active_flag 0
	foreach sta_wlan_index $::list_sta_wlan_objects {
		if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
			set wlan_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index WLAN is active"
		}
		if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
			set p2p_active_flag 1
			UTF::Message INFO "" "$sta_wlan_index $::p2p_display_str is active"
		}
	}

	UTF::Message INFO "" "wlan_active_flag=$wlan_active_flag"
	UTF::Message INFO "" "p2p_active_flag=$p2p_active_flag"

	set csv_header_line_cnt 2
		
	###################################################################
	# genrate the gnu_data file
	###################################################################

	set rate_flag 0
	set nrate_flag 0
	set rssi_flag 0
	set graph_special_flag 0
	set graph_throughput_flag 0

	if {[regexp {StaThroughput} $graph_name] || [regexp {StaTCPWrites} $graph_name] || [regexp {StaTCPErrors} $graph_name] || [regexp {StaTCPRetries} $graph_name] || [regexp {StaTCPUsedMemory} $graph_name] || [regexp {StaTCPRTT} $graph_name] || [regexp {StaUDPLatency} $graph_name] || [regexp {StaUDPJitter} $graph_name] || [regexp {StaUDPLostPackets} $graph_name] || [regexp {StaUDPOutofOrderPackets} $graph_name] || [regexp {StaUDPPPS} $graph_name]} {
		set graph_special_flag 1
		if {[regexp {StaThroughput} $graph_name]} {
			set graph_throughput_flag 1
		}
	}

	if {$::rvr_test_flag == 0} {
		set csv_index_BaseTime [find_csv_column_index "BaseTime" $::csv_columns_data_list]
	} else {
		set csv_index_GnuplotCnt [find_csv_column_index "GnuplotCnt" $::csv_columns_data_list]
	}

	if {$graph_special_flag} {

		# graph_name(4354e-FC19-DUTx)(WLAN:STA<-LAN)
		#             sta_wlan_index   stream_index

		foreach stream_index $::streams_name_list {

			if {$::array_streams_type(${stream_index}) == "BT"} {
				set stream_sta_obj $(bt_root_sta)
			} elseif {$::array_streams_type(${stream_index}) == "P2P"} {
				# always P2P GC interface
				set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
				set stream_sta_obj "$::array_sta_p2p(${stream_sta_obj})"
			} else {
				if {$::ap_connect == "GC"} {
					set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
				} elseif {$::ap_connect == "GO"} {
					set stream_sta_obj $::go_wlan
				} else {
					# just WLAN
					set stream_sta_obj [lindex $::list_sta_wlan_objects [expr {$::array_streams_sta_index_no(${stream_index}) - 1}]]
				}
			}

			set var "${graph_name}(${stream_sta_obj})(${stream_index})"

			set array_csv_index(${stream_index}) [find_csv_column_index "${var}" $::csv_columns_throughput_list]		
			if {$array_csv_index(${stream_index}) == -1} {
				UTF::Message INFO "" "CSV column title ${var} is not found. Skip this column"
				return
			}
			if {$::graphs_with_min_max} {
				set array_csv_index_min(${stream_index}) [find_csv_column_index "${graph_name}Min(${stream_sta_obj})(${stream_index})" $::csv_columns_throughput_list]
				set array_csv_index_max(${stream_index}) [find_csv_column_index "${graph_name}Max(${stream_sta_obj})(${stream_index})" $::csv_columns_throughput_list]
			} else {
				# use reg throughput as max
				set array_csv_index_max(${stream_index}) $array_csv_index(${stream_index})
			}
		}
		
		# read the csv data to figure out max_value

		set csv_throughput_fd [open "$::curr_csv_throughput_data_fullname" r]

		set max_value 0
		set csv_curr_line_no 0

		while {[gets $csv_throughput_fd line]>=0} { 
			incr csv_curr_line_no

			# skip csv header
			if {$csv_curr_line_no <= $csv_header_line_cnt} {
				continue
			}

			set columns [split $line ","]
			
			foreach stream_index $::streams_name_list {
			
				set array_data_max(${stream_index}) "[lindex $columns $array_csv_index_max(${stream_index})]"
				set array_data_max(${stream_index}) [string trim $array_data_max(${stream_index})]

				if {$array_data_max(${stream_index}) > $max_value} {
					set max_value $array_data_max(${stream_index})
				}
			}
		}
		
		close $csv_throughput_fd
		
		UTF::Message INFO "" "max_value=$max_value"

		if {[expr {round($max_value)}] < 40} {
			set max_value 40
			UTF::Message INFO "" "max_value adjusted to $max_value"
		}
	} else {
		set csv_index [find_csv_column_index $graph_name  $::csv_columns_data_list]

		if {$csv_index == -1} {
			UTF::Message INFO "" "CSV column title $graph_name is not found. Skip this column"
			return
		}

		if {[regexp {ApTxRate} $graph_name] || [regexp {StaTxRate} $graph_name]} {
			set rate_flag 1
		}

		if {[regexp {ApMcsRate} $graph_name] || [regexp {StaMcsRate} $graph_name]} {
			set nrate_flag 1
		}
		
		if {[regexp {ApRssi} $graph_name] || [regexp {StaRssi} $graph_name]} {
			set rssi_flag 1
		}
	}

	UTF::Message INFO "" "========================2D graph_name=$graph_name==========================="

	###################################################################
	# genrate the gnu_data file
	###################################################################

	regsub -all {:} $graph_name "-" graph_file_name
	regsub -all {\->} $graph_file_name "TX" graph_file_name
	regsub -all {<\-} $graph_file_name "RX" graph_file_name
	regsub -all {<>} $graph_file_name "BI" graph_file_name

	set testnum [p2p::get_testnum]
	regsub -all {.} $testnum "_" $testnum

	if {$graph_special_flag == 1} {
		foreach stream_index $::streams_name_list {

			set idx $::array_streams_file_name(${stream_index})
			set filename "$testnum\.${graph_file_name}(${idx})"
			set gnu_data_filename(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
			set gnu_data_fd(${idx}) [open "$gnu_data_filename(${idx})" w 0644]
			UTF::Message INFO "" "========================2D gnu_data_filename(${idx})=$gnu_data_filename(${idx})==========================="
			UTF::Message INFO "" "gnu_data_fd(${idx})=$gnu_data_fd(${idx})"

			if {$::graphs_with_min_max} {
				set filename "$testnum\.${graph_file_name}Min(${idx})"
				set gnu_data_filename_min(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_min_fd(${idx}) [open "$gnu_data_filename_min(${idx})" w 0644]
				UTF::Message INFO "" "========================2D gnu_data_filename_min(${idx})=$gnu_data_filename_min(${idx})==========================="

				set filename "$testnum\.${graph_file_name}Max(${idx})"
				set gnu_data_filename_max(${idx}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_max_fd(${idx}) [open "$gnu_data_filename_max(${idx})" w 0644]
				UTF::Message INFO "" "========================2D gnu_data_filename_max(${idx})=$gnu_data_filename_max(${idx})==========================="
			}
		}
	} else {
		set filename "$testnum\.${graph_file_name}"
		set gnu_data_filename "$::logdir/GraphsData/${filename}.gnu_data"
		set gnu_data_fd [open "$gnu_data_filename" w 0644]
		UTF::Message INFO "" "========================2D gnu_data_filename=$gnu_data_filename==========================="
	}

	###################################################################
	# genrate the gnu_data files for ap_state, wlan_state, p2p_state
	###################################################################

	set wlan_active_flag 0
	set p2p_active_flag 0

	if {$graph_special_flag == 1 && $graph_throughput_flag == 1} {
		set sta_no 0
		foreach sta_wlan_index $::list_sta_wlan_objects {
			incr sta_no
			UTF::Message INFO "" "-----------------------------------STATE($sta_wlan_index) sta_no=$sta_no----------------------------------------------"

			if {[expr {round($max_value)}] > 500} {
				set base_sta_graph_assoc_val 20
				UTF::Message INFO "" "500 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 20]
						UTF::Message INFO "" "500 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 6}]
				set sta_graph_assoc_val_wlan [expr {$base_sta_graph_assoc_val + 3}]
				set sta_graph_assoc_val_p2p  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 100} {
				set base_sta_graph_assoc_val 10
				UTF::Message INFO "" "100 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 10]
						UTF::Message INFO "" "100 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 4}]
				set sta_graph_assoc_val_wlan [expr {$base_sta_graph_assoc_val + 2}]
				set sta_graph_assoc_val_p2p  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 50} {
				set base_sta_graph_assoc_val 4
				UTF::Message INFO "" "50 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 6]
						UTF::Message INFO "" "50 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 4}]
				set sta_graph_assoc_val_wlan [expr {$base_sta_graph_assoc_val + 2}]
				set sta_graph_assoc_val_p2p  $base_sta_graph_assoc_val
			} elseif {[expr {round($max_value)}] > 10} {
				set base_sta_graph_assoc_val 1
				UTF::Message INFO "" "10 base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 2]
						UTF::Message INFO "" "10 sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + 1}]
				set sta_graph_assoc_val_wlan [expr {$base_sta_graph_assoc_val + .5}]
				set sta_graph_assoc_val_p2p  $base_sta_graph_assoc_val
			} else {
				set base_sta_graph_assoc_val .5
				UTF::Message INFO "" "base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
				if {$sta_no > 1} {
					for {set sta_cnt 1} {$sta_cnt < $sta_no} {incr sta_cnt} {
						set base_sta_graph_assoc_val [expr $base_sta_graph_assoc_val + 1]
						UTF::Message INFO "" "sta_no=$sta_no base_sta_graph_assoc_val=$base_sta_graph_assoc_val"
					}
				}
				set sta_graph_assoc_val_ap   [expr {$base_sta_graph_assoc_val + .4}]
				set sta_graph_assoc_val_wlan [expr {$base_sta_graph_assoc_val + .2}]
				set sta_graph_assoc_val_p2p  $base_sta_graph_assoc_val
			}
			UTF::Message INFO "" "sta_graph_assoc_val_ap=$sta_graph_assoc_val_ap"
			UTF::Message INFO "" "sta_graph_assoc_val_wlan=$sta_graph_assoc_val_wlan"
			UTF::Message INFO "" "sta_graph_assoc_val_p2p=$sta_graph_assoc_val_p2p"

			set wlan_active_flag 0
			set p2p_active_flag 0
			UTF::Message INFO "" "::array_sta_wlan_active_flag(${sta_wlan_index})=$::array_sta_wlan_active_flag(${sta_wlan_index}) ::array_sta_wlan_disassociated_flag(${sta_wlan_index})=$::array_sta_wlan_disassociated_flag(${sta_wlan_index})"
			UTF::Message INFO "" "::array_sta_p2p_active_flag(${sta_wlan_index})=$::array_sta_p2p_active_flag(${sta_wlan_index}) ::array_sta_p2p_disassociated_flag(${sta_wlan_index})=$::array_sta_p2p_disassociated_flag(${sta_wlan_index})"

			UTF::Message INFO "" "sta_wlan=$sta_wlan_index"
			UTF::Message INFO "" "::array_sta_p2p(${sta_wlan_index})=$::array_sta_p2p(${sta_wlan_index})"

			if {$sta_wlan_index == $::go_wlan && $::ap_connect != "GO"} {
				UTF::Message INFO "" "Skipping ::go_wlan when AP is not connected to GO"
				continue
			}
			
			if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
				set wlan_active_flag 1
				if {$::ap_connect == "GO"} {
					set csv_index_StaState_wlan [find_csv_column_index "StaState($::go_wlan)" $::csv_columns_data_list]
				} else {
					set csv_index_StaState_wlan [find_csv_column_index "StaState($sta_wlan_index)" $::csv_columns_data_list]
				}

				set filename "$testnum\.${graph_file_name}WLANState(${sta_wlan_index})"
				set gnu_data_filename_sta_state_wlan(${sta_wlan_index}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_wlan_fd(${sta_wlan_index}) [open "$gnu_data_filename_sta_state_wlan(${sta_wlan_index})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_wlan(${sta_wlan_index})=$gnu_data_filename_sta_state_wlan(${sta_wlan_index})==========================="
			}

			if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
				set p2p_active_flag 1
				set csv_index_StaState_p2p [find_csv_column_index "StaState($::array_sta_p2p(${sta_wlan_index}))" $::csv_columns_data_list]

				set filename "$testnum\.${graph_file_name}P2PState(${sta_wlan_index})"
				set gnu_data_filename_sta_state_p2p(${sta_wlan_index}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_p2p_fd(${sta_wlan_index}) [open "$gnu_data_filename_sta_state_p2p(${sta_wlan_index})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_p2p(${sta_wlan_index})=$gnu_data_filename_sta_state_p2p(${sta_wlan_index})==========================="
			}

			if {$::wlan_ap != "" && $wlan_active_flag == 1} {
				if {$::ap_connect == "GO"} {
					set csv_index_StaState_ap [find_csv_column_index "StaApState(${::go_wlan})" $::csv_columns_data_list]
				} else {
					set csv_index_StaState_ap [find_csv_column_index "StaApState(${sta_wlan_index})" $::csv_columns_data_list]
				}

				set filename "$testnum\.${graph_file_name}APState(${sta_wlan_index})"
				set gnu_data_filename_sta_state_ap(${sta_wlan_index}) "$::logdir/GraphsData/${filename}.gnu_data"
				set gnu_data_sta_state_ap_fd(${sta_wlan_index}) [open "$gnu_data_filename_sta_state_ap(${sta_wlan_index})" w 0644]
				UTF::Message INFO "" "========================gnu_file_state_ap(${sta_wlan_index})=$gnu_data_filename_sta_state_ap(${sta_wlan_index})==========================="
			}

			set csv_fd [open "$::curr_csv_data_fullname" r]

			set csv_curr_line_no 0

			while {[gets $csv_fd line]>=0} { 
				incr csv_curr_line_no

				# skip csv header
				if {$csv_curr_line_no <= $csv_header_line_cnt} {
					continue
				}

				set columns_data [split $line ","]

				if {$::rvr_test_flag == 0} {
					set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
				} else {
					set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
				}

				if {$wlan_active_flag == 1} {
					set data_StaState_wlan "[lindex $columns_data $csv_index_StaState_wlan]"
					set data_StaState_wlan [string trim $data_StaState_wlan]
					switch $data_StaState_wlan {
						ROAMING {
							set StaAssocBeacon_wlan 0
						}

						ASSOCIATED {
							set StaAssocBeacon_wlan [expr {$sta_graph_assoc_val_wlan / 2.0}]
						}

						"ASSOCIATED BEACONS" {
							set StaAssocBeacon_wlan $sta_graph_assoc_val_wlan
						}

						default {
							set StaAssocBeacon_wlan ""
						}
					}

					UTF::Message INFO "" "StaState_wlan='$data_StaState_wlan' -> StaAssocBeacon_wlan=$StaAssocBeacon_wlan"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_wlan_fd(${sta_wlan_index}) "$tmp $StaAssocBeacon_wlan"
				}

				if {$p2p_active_flag == 1} {
					set data_StaState_p2p "[lindex $columns_data $csv_index_StaState_p2p]"
					set data_StaState_p2p [string trim $data_StaState_p2p]
					switch $data_StaState_p2p {
						ROAMING {
							set StaAssocBeacon_p2p 0
						}

						ASSOCIATED {
							set StaAssocBeacon_p2p [expr {$sta_graph_assoc_val_p2p / 2.0}]
						}

						"ASSOCIATED BEACONS" {
							set StaAssocBeacon_p2p $sta_graph_assoc_val_p2p
						}

						default {
							set StaAssocBeacon_p2p ""
						}
					}

					UTF::Message INFO "" "StaState_p2p='$data_StaState_p2p' -> StaAssocBeacon_p2p=$StaAssocBeacon_p2p"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_p2p_fd(${sta_wlan_index}) "$tmp $StaAssocBeacon_p2p"
				}

				if {$::wlan_ap != "" && $wlan_active_flag == 1} {
					set data_StaState_ap "[lindex $columns_data $csv_index_StaState_ap]"
					set data_StaState_ap [string trim $data_StaState_ap]

					# figure out the StaAssocAuthen_ap
					if {[regexp -nocase {ASSOCIATED} $data_StaState_ap] && [regexp {AUTHENTICATED} $data_StaState_ap]} {
						set StaAssocAuthen_ap $sta_graph_assoc_val_ap
					} elseif {$data_StaState_ap != ""} {
						set StaAssocAuthen_ap [expr {$sta_graph_assoc_val_ap / 2.0}]
					} else {
						set StaAssocAuthen_ap 0
					}

					UTF::Message INFO "" "StaState_ap='$data_StaState_ap' -> StaAssocAuthen_ap=$StaAssocAuthen_ap"

					if {$::rvr_test_flag == 0} {
						set tmp $BaseTime
					} else {
						set tmp $gnuplot_line_no
					}

					puts $gnu_data_sta_state_ap_fd(${sta_wlan_index}) "$tmp $StaAssocAuthen_ap"
				}
			}

			if {$wlan_active_flag == 1} {
				close $gnu_data_sta_state_wlan_fd(${sta_wlan_index})
			}

			if {$p2p_active_flag == 1} {
				close $gnu_data_sta_state_p2p_fd(${sta_wlan_index})
			}

			if {$::wlan_ap != "" && $wlan_active_flag == 1} {
				close $gnu_data_sta_state_ap_fd(${sta_wlan_index})
			}

			close $csv_fd
		}
	}
	
	###################################################################
	# genrate the gnu_data files for throughput and others
	###################################################################

	if {$graph_special_flag == 1} {
		set csv_fd [open "$::curr_csv_throughput_data_fullname" r]
	} else {
		set csv_fd [open "$::curr_csv_data_fullname" r]
	}
	
	set max_val 0
	set min_val 99999
	set csv_curr_line_no 0
	set bigest_nrate_data 0
	set found_data_flag 0

	while {[gets $csv_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns_data [split $line ","]

		if {$::rvr_test_flag == 0} {
			set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
		} else {
			set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
		}

		if {$graph_special_flag == 1} {

			set found_data_flag 1
		
			foreach stream_index $::streams_name_list {
		
				set data(${stream_index}) ""
				if {$::graphs_with_min_max} {
					set data_min(${stream_index}) ""
					set data_max(${stream_index}) ""
				}
				
				set data(${stream_index}) "[lindex $columns_data $array_csv_index(${stream_index})]"
				set data(${stream_index}) [string trim $data(${stream_index})]
				if {$data(${stream_index}) == ""} {
					continue
				}
				if {$data(${stream_index}) == 0} {
					if {[regexp {StaTCPWrites} $graph_name] || [regexp {StaTCPErrors} $graph_name] || [regexp {StaTCPRetries} $graph_name] || [regexp {StaTCPUsedMemory} $graph_name] || [regexp {StaTCPRTT} $graph_name] || [regexp {StaUDPLatency} $graph_name] || [regexp {StaUDPJitter} $graph_name] || [regexp {StaUDPLostPackets} $graph_name] || [regexp {StaUDPOutofOrderPackets} $graph_name] || [regexp {StaUDPPPS} $graph_name]} {
						set data(${stream_index}) [format "%.2f" [expr {double(0.01)}]]
						UTF::Message INFO "" "Log graph - modified data=0 to $data(${stream_index})"
					}
				}
				if {$::graphs_with_min_max} {
					set data_min(${stream_index}) "[lindex $columns_data $array_csv_index_min(${stream_index})]"
					set data_min(${stream_index}) [string trim $data_min(${stream_index})]
					set data_max(${stream_index}) "[lindex $columns_data $array_csv_index_max(${stream_index})]"
					set data_max(${stream_index}) [string trim $data_max(${stream_index})]

					if {$data_max(${stream_index}) > $max_val} {
						set max_val $data_max(${stream_index})
					}
					if {$data_min(${stream_index}) < $min_val} {
						set min_val $data_min(${stream_index})
					}
				} else {
					if {$data(${stream_index}) > $max_val} {
						set max_val $data(${stream_index})
					}
					if {$data(${stream_index}) < $min_val} {
						set min_val $data(${stream_index})
					}
				}
			}

			foreach stream_index $::streams_name_list {

				# For RvR, to fix the graphs when there is no throughput (or jitter, lost packet, or ooo) value and pushing the graph to 0 x axis:
				# 	orginal data:   data   data   blank   blank   blank   blank   data   data
				# 	new data:       data   data     0     blank   blank     0     data   data
				
				set idx $::array_streams_file_name(${stream_index})

				if {$::rvr_test_flag == 1 && [info exists gnu_no_data_spc_flag(${idx})]} {
					if {$gnu_no_data_spc_flag(${idx}) == 1 && $data(${stream_index}) != ""} {
						# no throughput to throughput (RvR going back up) - force a zero data
						set zero_line_no [expr {$gnuplot_line_no - 1}]
						set tmp $zero_line_no
						puts $gnu_data_fd(${idx}) "$tmp 0"
					} elseif {$gnu_no_data_spc_flag(${idx}) == 0 && $data(${stream_index}) == ""} {
						# throughput to no throughput (RvR going down) - force a zero data
						puts $gnu_data_fd(${idx}) "$gnuplot_line_no 0"
					}
				}
				
				if {$data(${stream_index}) == ""} {
					set gnu_no_data_spc_flag(${idx}) 1
					continue
				}

				set gnu_no_data_spc_flag(${idx}) 0

				if {$::rvr_test_flag == 0} {
					set tmp $BaseTime
				} else {
					set tmp $gnuplot_line_no
				}
				
				# write the throughput data to gnu file
				puts $gnu_data_fd(${idx}) "$tmp $data(${stream_index})"
				if {$::graphs_with_min_max} {
					puts $gnu_data_min_fd(${idx}) "$tmp $data_min(${stream_index})"
					puts $gnu_data_max_fd(${idx}) "$tmp $data_max(${stream_index})"
				}
			}
		} else {
			set data "[lindex $columns_data $csv_index]"
			set data [string trim $data]

			if {$data == ""} {
				if {[regexp {ApConnectTime} $graph_name] || $rate_flag == 1 || $nrate_flag == 1} {
					set data 0
				}
			}

			if {$nrate_flag == 1} {
				set data [p2p::graph_map_nrate $data]

				if {$data > $bigest_nrate_data} {
					set bigest_nrate_data $data
				}
			}

			if {$data != "" && $data != "0.00"} {
				set found_data_flag 1
			}

			if {$::rvr_test_flag == 0} {
				set tmp $BaseTime
			} else {
				set tmp $gnuplot_line_no
			}

			if {$rssi_flag == 1} {
				# RSSI of 0 or blank are invalid
				if {$data != "" && $data != 0} {
					puts $gnu_data_fd "$tmp $data"			
				}
			} else {
				if {$data != ""} {
					puts $gnu_data_fd "$tmp $data"			
				}
			}

			if {$data != ""} {
				if {$data > $max_val} {
					set max_val $data
				}
				if {$data < $min_val} {
					set min_val $data
				}
			}
		}
	}

	close $csv_fd

	if {$graph_special_flag == 1} {
		foreach stream_index $::streams_name_list {
			set idx $::array_streams_file_name(${stream_index})
			close $gnu_data_fd(${idx})
			if {$::graphs_with_min_max} {
				close $gnu_data_min_fd(${idx})
				close $gnu_data_max_fd(${idx})
			}
		}
	} else {
		close $gnu_data_fd
	}
	UTF::Message INFO "" "end closed gnu_data"
	UTF::Message INFO "" "end closed csv"

	if {$found_data_flag == 0} {
		UTF::Message INFO "" "No data was found for column title $graph_name. Skip this graph"
		return
	}	

	if {$::graph_max_width == 0} {
		
		if {$::rvr_test_flag == 0} {
			# use 1280 for every minute of throughput

			set max_x_time $BaseTime
			# covert x axis time to secs
			# add the hour before converting
			set new_base_timestamp "00:$max_x_time"
			set new_base_timestamp_tick [clock scan $new_base_timestamp]
			set max_x_time_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
			UTF::Message INFO "" "max_x_time = $BaseTime = $max_x_time_tick"

			set ::graph_max_width [expr {round([expr {double([expr {$max_x_time_tick * 1280.0}]) / 60.0}])}]
			if {$::graph_max_width < 1280} {
				set ::graph_max_width 1280
			}
			set ::graph_max_height 720
		} else {
			set ::graph_max_width 900
			set ::graph_max_height 600
		}
	
		UTF::Message INFO "" "::graph_max_width=$::graph_max_width ::graph_max_height=$::graph_max_height"
	}

	UTF::Message INFO "" "max_val=$max_val min_val=$min_val"

	if {$max_val < 10} {
		set max_val 10
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,$max_val)"
		set ytics 1.0
	} elseif {$max_val < 20} {
		set max_val 20
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,$max_val)"
		set ytics 2.0
	} elseif {$max_val < 50} {
		set max_val 50
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,$max_val)"
		set ytics 5.0
	} elseif {$max_val < 100} {
		set max_val 100
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,$max_val)"
		set ytics 10.0
	} elseif {$max_val < 200} {
		set max_val 200
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,100,$max_val)"
		set ytics 20.0
	} elseif {$max_val < 500} {
		set max_val 500
		set max_val_log_ytics "set ytics ('0' 0.01,1,2,5,10,20,60,100,200,$max_val)"
		set ytics 50.0
	} elseif {$max_val < 1000} {
		set max_val 1000
		set max_val_log_ytics "set ytics ('0' 0.01,20,60,100,200,500,$max_val)"
		set ytics 100.0
	} elseif {$max_val < 2000} {
		set max_val 2000
		set max_val_log_ytics "set ytics ('0' 0.01,60,100,200,500,1000,$max_val)"
		set ytics 200.0
	} elseif {$max_val < 5000} {
		set max_val 5000
		set max_val_log_ytics "set ytics ('0' 0.01,100,200,500,1000,2000,$max_val)"
		set ytics 500.0
	} elseif {$max_val < 10000} {
		set max_val 10000
		set max_val_log_ytics "set ytics ('0' 0.01,100,200,500,1000,2000,$max_val)"
		set ytics 1000.0
	} elseif {$max_val < 20000} {
		set max_val 20000
		set max_val_log_ytics "set ytics ('0' 0.01,1000,2000,10000,$max_val)"
		set ytics 2000.0
	} elseif {$max_val < 50000} {
		set max_val 50000
		set max_val_log_ytics "set ytics ('0' 0.01,1000,2000,10000,20000,$max_val)"
		set ytics 5000.0
	} elseif {$max_val < 100000} {
		set max_val 100000
		set max_val_log_ytics "set ytics ('0' 0.01,10000,20000,50000,$max_val)"
		set ytics 10000.0
	} else {
		set max_val_log_ytics "set ytics ('0' 0.01,10000,20000,50000,100000,$max_val)"
		set ytics 10000.0
	}

	if {$min_val >= 0} {
		set min_val 0
	} elseif {$min_val < 10} {
		set min_val [expr {$min_val - 10}]
	} elseif {$min_val < 0} {
		set min_val -10
	}

	UTF::Message INFO "" "ytics=$ytics"

	set max_val_log_yrange "set yrange \[0.01:$max_val\]"

	regsub {ytics} $max_val_log_ytics {y2tics} max_val_log_y2tics
	regsub {yrange} $max_val_log_yrange {y2range} max_val_log_y2range

	UTF::Message INFO "" "new max_val=$max_val min_val=$min_val"

	###################################################################
	# genrate the gnu_plot file
	###################################################################
	set filename "$testnum\.${graph_file_name}"
	set gnu_plot_filename "$::logdir/GraphsData/${filename}.gnu_plot"
	set gnu_plot_fd [open "$gnu_plot_filename" w 0644]

	UTF::Message INFO "" "========================2D gnu_plot_filename=$gnu_plot_filename==========================="

	puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}.png\""
	set terminal_size "$::graph_max_width,$::graph_max_height"
	puts $gnu_plot_fd "set terminal png size $terminal_size notransparent font \"$::gnuplot_font\,$::gnuplot_font_size\""
	puts $gnu_plot_fd "set tmargin -1; set bmargin -1"
	puts $gnu_plot_fd "set lmargin -1; set rmargin -1"
	puts $gnu_plot_fd "set key outside spacing .9"
	
    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    puts $gnu_plot_fd "set title \"$::graph_label_test$::streams_report_fullname\\n$graph_name\\n($timestamp)\""

	puts $gnu_plot_fd "set ylabel '$graph_ylabel'"
	
	if {$graph_special_flag == 1 && $::rvr_test_flag == 0} {
		puts $gnu_plot_fd "set border"
		puts $gnu_plot_fd "set grid ytic"
		puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
		puts $gnu_plot_fd "set xdata time"
		puts $gnu_plot_fd "set timefmt '%M:%S'"
		# rotate 0 and 90 works. "-45" does not work
		puts $gnu_plot_fd "#set xtics rotate by 90"
		puts $gnu_plot_fd "set ytics  0,$ytics"
		puts $gnu_plot_fd "set yrange \[$min_val:$max_val\]"
		puts $gnu_plot_fd "set xrange \[0:\"$::gnuplot_x_max_time_val\"\]"

		if {$::curr_stream_time > 60} {
			#puts $gnu_plot_fd "set y2label ''"
			puts $gnu_plot_fd "set y2tics 0,$ytics"
			puts $gnu_plot_fd "set y2range \[$min_val:$max_val\]"
		}
	} else {
		puts $gnu_plot_fd "set grid"
		
		if {$::rvr_test_flag == 1} {
			puts $gnu_plot_fd "set xlabel 'Relative Path Loss (dB)'"
			puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
			puts $gnu_plot_fd "set xrange \[0:$::gnuplot_x_max_rvr_val\]"
		} else {
			puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
			puts $gnu_plot_fd "set xdata time"
			puts $gnu_plot_fd "set timefmt '%M:%S'"
			puts $gnu_plot_fd "set xrange \[0:\"$::gnuplot_x_max_time_val\"\]"
		}
	}

	if {$nrate_flag == 1} {
		if {$bigest_nrate_data > 23} {
			puts $gnu_plot_fd "set ytics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'1x0' 24,'1x1' 25,'1x2' 26,'1x3' 27,'1x4' 28,'1x5' 29,'1x6' 30,'1x7' 31,'1x8' 32,'1x9' 33,'2x0' 34,'2x1' 35,'2x2' 36,'2x3' 37,'2x4' 38,'2x5' 39,'2x6' 40,'2x7' 41,'2x8' 42,'2x9' 43,'3x0' 44,'3x1' 45,'3x2' 46,'3x3' 47,'3x4' 48,'3x5' 49,'3x6' 50,'3x7' 51,'3x8' 52,'3x9' 53,'auto' 54)"
			puts $gnu_plot_fd "set yrange \[-12:54\]"
			if {$::curr_stream_time > 60} {
				puts $gnu_plot_fd "set y2tics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'1x0' 24,'1x1' 25,'1x2' 26,'1x3' 27,'1x4' 28,'1x5' 29,'1x6' 30,'1x7' 31,'1x8' 32,'1x9' 33,'2x0' 34,'2x1' 35,'2x2' 36,'2x3' 37,'2x4' 38,'2x5' 39,'2x6' 40,'2x7' 41,'2x8' 42,'2x9' 43,'3x0' 44,'3x1' 45,'3x2' 46,'3x3' 47,'3x4' 48,'3x5' 49,'3x6' 50,'3x7' 51,'3x8' 52,'3x9' 53,'auto' 54)"
				puts $gnu_plot_fd "set y2range \[-12:54\]"
			}
			UTF::Message LOG "" "bigest_nrate_data=$bigest_nrate_data graph_highest_val=54"
		} else {
			puts $gnu_plot_fd "set ytics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'auto' 24)"
			puts $gnu_plot_fd "set yrange \[-12:24\]"
			if {$::curr_stream_time > 60} {
				puts $gnu_plot_fd "set y2tics ('(1)' -12,'(2)' -11,'(5.5)' -10,'(6)' -9,'(9)' -8,'(11)' -7,'(12)' -6,'(18)' -5,'(24)' -4,'(36)' -3,'(48)' -2,'(54)' -1,'0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15,'16' 16,'17' 17,'18' 18,'19' 19,'20' 20,'21' 21,'22' 22,'23' 23,'auto' 24)"
				puts $gnu_plot_fd "set y2range \[-12:24\]"
			}
			UTF::Message LOG "" "bigest_nrate_data=$bigest_nrate_data graph_highest_val=23"
		}
	} elseif {$graph_ylabel == "UDP Jitter (ms)" || $graph_ylabel == "UDP Latency (ms)"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "UDP Lost Packets"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "UDP OOO Packets"} {
		puts $gnu_plot_fd "set logscale y"
		puts $gnu_plot_fd "$max_val_log_ytics"
		puts $gnu_plot_fd "$max_val_log_yrange"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set logscale y2"
			puts $gnu_plot_fd "$max_val_log_y2tics"
			puts $gnu_plot_fd "$max_val_log_y2range"
		}
	} elseif {$graph_ylabel == "Connect Time (Seconds)"} {
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set y2tics"
		}
	} elseif {$graph_ylabel == "Rate (Mbps)"} {
		puts $gnu_plot_fd "set yrange \[0:1600\]"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set y2tics"
			puts $gnu_plot_fd "set y2range \[0:1600\]"
		}
	} elseif {$graph_ylabel == "RSSI (dB)"} {
		puts $gnu_plot_fd "set ytics('-100' -100,'-90' -90,'-80' -80,'-70' -70,'-60' -60,'-50' -50,'-40' -40,'-30' -30,'-20' -20,'-10' -10,'0' 0)"
		puts $gnu_plot_fd "set yrange \[-100:0\]"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set y2tics('-100' -100,'-90' -90,'-80' -80,'-70' -70,'-60' -60,'-50' -50,'-40' -40,'-30' -30,'-20' -20,'-10' -10,'0' 0)"
			puts $gnu_plot_fd "set y2range \[-100:0\]"
		}
	} elseif {$graph_ylabel == "Beacons/Sec"} {
		puts $gnu_plot_fd "set ytics('0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15)"
		puts $gnu_plot_fd "set yrange \[0:15\]"
		if {$::curr_stream_time > 60} {
			puts $gnu_plot_fd "set y2tics('0' 0,'1' 1,'2' 2,'3' 3,'4' 4,'5' 5,'6' 6,'7' 7,'8' 8,'9' 9,'10' 10,'11' 11,'12' 12,'13' 13,'14' 14,'15' 15)"
			puts $gnu_plot_fd "set y2range \[0:15\]"
		}
	}

	set object_name ""
	regexp {\s*\((.*)\)} $graph_name - object_name
	UTF::Message INFO "" "graph_name=$graph_name object_name=$object_name"

	if {$graph_special_flag == 1} {

		if {$graph_throughput_flag == 1} {
			set ::throughput_png_file "$::logdir/GraphsData/${filename}.png"
		}

		set out ""
		set out_sm ""
		set stream_cnt 0
		foreach stream_index $::streams_name_list {
			set stream_plot_minmax_name_lt $::array_streams_plot_minmax_name_lt(${stream_index})
			set stream_plot_name_lt $::array_streams_plot_name_lt(${stream_index})
			set stream_plot_name_pt $::array_streams_plot_name_pt(${stream_index})

			if {$stream_cnt > 0} {
				append out ", "
				append out_sm ", "
			}
			set idx $::array_streams_file_name(${stream_index})
			set stream_title $::array_streams_report_name(${stream_index})
			append out "\"$gnu_data_filename(${idx})\" using 1:2 title \"$stream_title\" with linespoints lt $stream_plot_name_lt lw 3 pt $stream_plot_name_pt ps 1"
			append out_sm "\"$gnu_data_filename(${idx})\" using 1:2 axes x1y1 with lines"
			if {$::graphs_with_min_max} {
				append out ", \"$gnu_data_filename_min(${idx})\" using 1:2 title \"Min $stream_title\" with linespoints lt $stream_plot_minmax_name_lt lw 1 pt 0 ps 0, "
				append out "\"$gnu_data_filename_max(${idx})\" using 1:2 title \"Max $stream_title\" with linespoints lt $stream_plot_minmax_name_lt lw 1 pt 0 ps 0"
			}
			
			incr stream_cnt
		}

		if {$graph_throughput_flag == 1} {
			set gc_tot [llength $::list_gc_wlan_objects]
			set lt_cnt 0
			
			set gc_cnt 0
			foreach sta_wlan_index $::list_sta_wlan_objects {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 1
				}
				
				if {$::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
					append out ", \"$gnu_data_filename_sta_state_wlan(${sta_wlan_index})\" using 1:2 title \"$tmp\WLAN Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
				}
			}
			
			set gc_cnt 0
			foreach sta_wlan_index $::list_sta_wlan_objects {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 13
				}
				
				if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
					append out ", \"$gnu_data_filename_sta_state_p2p(${sta_wlan_index})\" using 1:2 title \"$tmp$::p2p_display_str Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
				}
			}
			
			set gc_cnt 0
			foreach sta_wlan_index $::list_sta_wlan_objects {
				incr gc_cnt
				
				if {$gc_tot > 1} {
					set tmp "$gc_cnt:"
					incr lt_cnt
					set lt_param $lt_cnt
				} else {
					set tmp ""
					set lt_param 8
				}
				
				if {$::wlan_ap != "" && $::array_sta_wlan_active_flag(${sta_wlan_index}) == 1} {
					append out ", \"$gnu_data_filename_sta_state_ap(${sta_wlan_index})\" using 1:2 title \"$tmp\AP Association\" with linespoints lt $lt_param lw 1 pt 0 ps 0"
				}
			}
		}
		
		puts $gnu_plot_fd "plot $out"
	} else {
		puts $gnu_plot_fd "set style line 1 lt 1 lw 3 pt 7 ps 1"
		if {$::rvr_test_flag == 0} {
			puts $gnu_plot_fd "plot \"$::logdir/GraphsData/${filename}.gnu_data\" using 1:2 title \"$object_name\" with linespoints ls 1"
		} else {
			puts $gnu_plot_fd "plot \"$::logdir/GraphsData/${filename}.gnu_data\" title \"$object_name\" with linespoints ls 1"
		}
	}
	
	# for non-rvr throughput, create small graph also
	if {$graph_throughput_flag == 1 && $::rvr_test_flag == 0} {
		puts $gnu_plot_fd ""
		puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}_sm.png\""
		puts $gnu_plot_fd "set terminal png transparent size 62,13"
		puts $gnu_plot_fd "set tmargin 0; set bmargin 0"
		puts $gnu_plot_fd "set lmargin 0; set rmargin 0.15"
		puts $gnu_plot_fd "unset border"
		puts $gnu_plot_fd "unset key"
		puts $gnu_plot_fd "unset title"
		puts $gnu_plot_fd "unset xlabel"
		puts $gnu_plot_fd "unset ylabel"
		puts $gnu_plot_fd "unset y2label"
		puts $gnu_plot_fd "set xdata time"
		puts $gnu_plot_fd "set timefmt '%M:%S'"
		puts $gnu_plot_fd "unset xtics"
		puts $gnu_plot_fd "unset ytics"
		puts $gnu_plot_fd "unset y2tics"
		puts $gnu_plot_fd "set yrange \[$min_val:\]"
		puts $gnu_plot_fd "set y2range \[$min_val:\]"
		puts $gnu_plot_fd "unset grid"
		puts $gnu_plot_fd "plot $out_sm"
	}	
	
	close $gnu_plot_fd

	if {$graph_special_flag == 1} {
		foreach stream_index $::streams_name_list {
			set idx $::array_streams_file_name(${stream_index})
			unset array_csv_index_max(${stream_index})
			unset array_data_max(${stream_index})
			unset gnu_data_filename(${idx})
			unset gnu_data_fd(${idx})
			if {$::graphs_with_min_max} {
				unset array_csv_index_min(${stream_index})
				unset gnu_data_filename_min(${idx})
				unset gnu_data_min_fd(${idx})
				unset gnu_data_filename_max(${idx})
				unset gnu_data_max_fd(${idx})
				unset data_min(${stream_index})
				unset data_max(${stream_index})
			}
			unset data(${stream_index})
		}
	}
	
	set catch_resp [catch "exec $::UTF::Gnuplot $::logdir/GraphsData/${filename}.gnu_plot" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc p2p::create_3d_summary_graphs {graph_name graph_ylabel} {

	UTF::Message INFO "" "************************Func:create_3d_summary_graphs $graph_name***************************"

	if {$graph_ylabel == "PER"} {
		set graph_per_flag 1
	} else {
		set graph_per_flag 0
	}

	# graph_name = graph_name(AP/STA Object_name)
	regexp {\s*\((.*)\)} $graph_name - object_name

	if {[string first "Sta" $graph_name] == 0} {
		# graph_name starts with "Sta"
		set object_type "Sta"
	} elseif {[string first "Ap" $graph_name] == 0} {
		# graph_name starts with "Ap"
		set object_type "Ap"
	} else {
		UTF::Message ERROR "" "***Failed. graph_name $graph_name does not start with 'Ap' or 'Sta'."
		error "Bad graph_name $graph_name"
	}

	if {$graph_per_flag} {
		if {[string first "VhtPer" $graph_name] > 0} {
			set csv_index_tx [find_csv_column_index ${object_type}TxVht($object_name) $::csv_columns_data_list]
		} else {
			set csv_index_tx [find_csv_column_index ${object_type}TxMcs($object_name) $::csv_columns_data_list]
		}
	}

	set csv_header_line_cnt 2

	if {$::rvr_test_flag == 0} {
		set csv_index_BaseTime [find_csv_column_index "BaseTime" $::csv_columns_data_list]
	} else {
		set csv_index_GnuplotCnt [find_csv_column_index "GnuplotCnt" $::csv_columns_data_list]
	}

	set csv_index [find_csv_column_index $graph_name $::csv_columns_data_list]

	if {$csv_index == -1} {
		UTF::Message INFO "" "CSV column title $graph_name is not found. Skip this column"
		return
	}

	UTF::Message INFO "" "========================3D graph_name=$graph_name==========================="

	set csv_data_fd [open "$::curr_csv_data_fullname" r]

	# read the csv data to figure out gnuplot yrange->max_y

	set y_max 0
	set len_max 0
	set csv_curr_line_no 0

	while {[gets $csv_data_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns [split $line ","]
		set data "[lindex $columns $csv_index]"
		set data [string trim $data]
		set len [llength $data]

		if {[expr {$len - 1}] > $len_max} {
			set len_max $len
		}
	}

	set y_max [expr {$len_max - 0.5}]

	UTF::Message INFO "" "gnuplot yrange->y_max=$y_max"

	###################################################################
	# genrate the gnu_data file
	###################################################################

	set testnum [p2p::get_testnum]
	regsub -all {.} $testnum "_" $testnum
	set filename "$testnum\.${graph_name}"
	set gnu_data_filename "$::logdir/GraphsData/${filename}.gnu_data"
	set gnu_data_fd [open "$gnu_data_filename" w 0644]

	UTF::Message INFO "" "========================3D gnu_data_filename=$gnu_data_filename==========================="

	# do not init the ::gnuplot_xtic_label here since it is set in 2D graphs
	set gnuplot_xtic_max_range ""
	seek $csv_data_fd 0
	set csv_curr_line_no 0
	set z_min 99999
	set z_max 0
	set found_data_flag 0

	while {[gets $csv_data_fd line]>=0} { 
		incr csv_curr_line_no

		# skip csv header
		if {$csv_curr_line_no <= $csv_header_line_cnt} {
			continue
		}

		set columns_data [split $line ","]

		if {$::rvr_test_flag == 0} {
			set BaseTime "[lindex $columns_data $csv_index_BaseTime]"
			set BaseTime [string trim $BaseTime]
			# covert to secs and build xtics
			# add the hour before converting
			set new_base_timestamp "00:$BaseTime"
			set new_base_timestamp_tick [clock scan $new_base_timestamp]
			set BaseTime_tick [expr {$new_base_timestamp_tick - $::base_timestamp_tick}]
				
			if {$::gnuplot_xtic_label != ""} {
				set ::gnuplot_xtic_label "$::gnuplot_xtic_label,"
			}

			set ::gnuplot_xtic_label "$::gnuplot_xtic_label\'$BaseTime\' $BaseTime_tick"
			set gnuplot_xtic_max_range $BaseTime_tick
		} else {
			set gnuplot_line_no "[lindex $columns_data $csv_index_GnuplotCnt]"
		}

		set data "[lindex $columns_data $csv_index]"
		set data [string trim $data]
		if {$data != "" && $data != "0.00"} {
			set found_data_flag 1
		}
		set len [llength $data]
		# length of Y data must be max
		set diff_len [expr {$len_max - $len}]
		if {$diff_len != 0} {
			for {set cnt 0} {$cnt < $diff_len} {incr cnt} {
				if {$graph_per_flag} {
					lappend data "-1"
				} else {
					lappend data "0"
				}
			}
		}
		set data [string trim $data]
		set len [llength $data]

		if {$graph_per_flag} {
			# if AP/STA "TX MCS" and "MCS PER" are zero, then set the AP/STA "MCS PER" to "-1"
			# if AP/STA "TX VHT" and "VHT PER" are zero, then set the AP/STA "VHT PER" to "-1"
			
			set data_tx "[lindex $columns_data $csv_index_tx]"
			set data_tx [string trim $data_tx]
			UTF::Message INFO "" "==============================PER $csv_curr_line_no================================="

			UTF::Message INFO "" "PER: data_tx='$data_tx'"
			UTF::Message INFO "" "PER:    data='$data'"
			
			set new_per_list ""
			for {set cnt 0} {$cnt < $len} {incr cnt} {
				set tx_val [lindex $data_tx $cnt]
				set per_val [lindex $data $cnt]
				
				if {($tx_val == 0 || $tx_val == "") && ($per_val == 0 || $per_val == "" || $per_val == "-1")} {
					append new_per_list "-1 "
				} else {
					append new_per_list "$per_val "
				}
			}
			
			set data $new_per_list
			set data [string trim $data]
			
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "BaseTime=$BaseTime value='$data' len=$len"
			} else {
				UTF::Message LOG "" "gnuplot_line_no=$gnuplot_line_no value='$data' len=$len"
			}
		} else {
			set total_value 0
			foreach item "$data" {
				# leading zero mean 'octal' (or base 8), with only digits 0-7. 
				# use scan to covert it to decimal without the leading zero, otherwise you
				# could get error 'can't use invalid octal number as operand of "+" when using 'expr' command with invalid octal'
				scan $item %d item

				set total_value [expr {$total_value + $item}]
			}
			
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "BaseTime=$BaseTime value='$data' len=$len total_value=$total_value"
			} else {
				UTF::Message LOG "" "gnuplot_line_no=$gnuplot_line_no value='$data' len=$len total_value=$total_value"
			}
		}
		
		set y 0
		foreach item "$data" {
			# leading zero mean 'octal' (or base 8), with only digits 0-7. 
			# use scan to covert it to decimal without the leading zero, otherwise you
			# could get error 'can't use invalid octal number as operand of "+" when using 'expr' command with invalid octal'
			scan $item %d item

			if {$graph_per_flag} {
				set z $item
			} else {
				if {$total_value == 0} {
					set z 0
				} else {
					set z [expr {double([expr {$item * 100.0}]) / $total_value}]
					set z [format "%.2f" $z]
				}
			}
			if {$::rvr_test_flag == 0} {
				UTF::Message LOG "" "x=$BaseTime_tick y=$y z=$z"
				puts $gnu_data_fd "$BaseTime_tick $y $z"
			} else {
				UTF::Message LOG "" "x=$gnuplot_line_no y=$y z=$z"
				puts $gnu_data_fd "$gnuplot_line_no $y $z"
			}
			incr y

			if {$z > $z_max } {
				set z_max $z
			}
			if {$z < $z_min } {
				set z_min $z
			}
		}

		puts $gnu_data_fd ""
	}

	close $csv_data_fd
	close $gnu_data_fd
	UTF::Message INFO "" "end closed gnu_data"
	UTF::Message INFO "" "end closed csv"

	if {$found_data_flag == 0} {
		UTF::Message INFO "" "No data was found for column title $graph_name. Skip this graph"
		return
	}	

	if {$z_max < 0.001} {
		UTF::Message LOG "" "z_max=$z_max is forced to 0.001"
		set z_min 0.001
	}

	if {$z_max < 5} {
		UTF::Message LOG "" "z_max=$z_max is less than 5. z_min is forced to 0"
		set z_min 0
	} else {
		UTF::Message LOG "" "z_max=$z_max is forced to normal 100"
		set z_max 100
	}

	UTF::Message LOG "" "z_min=$z_min z_max=$z_max"

	###################################################################
	# genrate the gnu_plot file
	###################################################################
	set gnu_plot_filename "$::logdir/GraphsData/${filename}.gnu_plot"
	set gnu_plot_fd [open "$gnu_plot_filename" w 0644]

	UTF::Message INFO "" "========================3D gnu_plot_filename=$gnu_plot_filename==========================="

	puts $gnu_plot_fd "set output \"$::logdir/GraphsData/${filename}.png\""
	set terminal_size "$::graph_max_width,$::graph_max_height"
	puts $gnu_plot_fd "set terminal png size $terminal_size notransparent font \"$::gnuplot_font\,$::gnuplot_font_size\""
	puts $gnu_plot_fd "set tmargin -1; set bmargin -1"
	puts $gnu_plot_fd "set lmargin -1; set rmargin -1"
	puts $gnu_plot_fd "set grid"
	puts $gnu_plot_fd "unset key"

    set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
	# 3 line of title does not work with this type of graph and only the first two lines gets displayed
    puts $gnu_plot_fd "set title \"$::graph_label_test$::streams_report_fullname\\n$graph_name ($timestamp)\""
	
	puts $gnu_plot_fd "set ylabel '$graph_ylabel'"

	if {$::rvr_test_flag == 1} {
		puts $gnu_plot_fd "set xlabel 'Relative Path Loss (dB)'"
		puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
		puts $gnu_plot_fd "set xrange \[0:$::gnuplot_x_max_rvr_val\]"
	} else {
		puts $gnu_plot_fd "set xlabel 'Time (MM:SS)'"
		#puts $gnu_plot_fd "set xdata time"
		#puts $gnu_plot_fd "set timefmt '%M:%S'"
		puts $gnu_plot_fd "set xtics($::gnuplot_xtic_label)"
		# no xrange since we have xtics
	}

	if {[regexp -nocase {Vht} $graph_name]} {
		puts $gnu_plot_fd "set ytics('1x0' 0, '1x5' 5, '1x9' 9, '2x0' 10, '2x5' 15, '2x9' 19, '3x0' 20, '3x5' 25, '3x9' 29)"
	}
	puts $gnu_plot_fd "set style line 1 lt 1 lw 1 pt 0 ps 0"
	puts $gnu_plot_fd "set pm3d map corners2color c3"
	puts $gnu_plot_fd "set cbrange \[$z_min:$z_max\]"
	if {$graph_ylabel == "PER"} {
		set palette {(-1 "black", 0 "white", 50 "orange", 100 "red")}
	} else {
		set palette {(0 "black", 500 "blue", 10000 "red", 50000 "yellow", 90000 "white")}
	}
	puts $gnu_plot_fd "set palette defined $palette"	
	puts $gnu_plot_fd "set cblabel 'PerCent %'"
	puts $gnu_plot_fd "set yrange \[-0.5:$y_max\]"
	puts $gnu_plot_fd "splot \"$::logdir/GraphsData/${filename}.gnu_data\" title \"$object_name\" with image ls 1"
	puts $gnu_plot_fd "quit"

	close $gnu_plot_fd
	set catch_resp [catch "exec $::UTF::Gnuplot $::logdir/GraphsData/${filename}.gnu_plot" catch_msg]
	UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
}

proc p2p::max_range {val} {
	if {$val > 10000} {
		return 10000
	} elseif {$val > 1000} {
		return 1000
	} elseif {$val > 500} {
		return 500
	} elseif {$val > 100} {
		return 100
	} elseif {$val > 10} {
		return 10
	} else {
		return 0
	}
}

proc p2p::round_down {val rounder} {
	set nval [expr {floor([expr {$val * $rounder}]) / $rounder}]
	return $nval
}

proc p2p::round_up {val rounder} {
	set nval [expr {double([expr {$val * $rounder}]) / $rounder}]
	return $nval
}

proc format_number {num} {
  # number with 5 decimal places
  set num_dec5 [format "%.5f" $num]
  puts "\$num_dec5 = $num_dec5"
  set dec_point_pos [string first "." $num_dec5]
  puts "\$dec_point_pos = $dec_point_pos"
  # number with length of 8 characters
  if {$dec_point_pos < 7} {
    set num_len8 [string range $num_dec5 0 7]
    set result $num_len8
  } elseif {$dec_point_pos == 7 || $dec_point_pos == 8} {
    set num_len8 [string range $num_dec5 0 $dec_point_pos-1]
    set result $num_len8
  } else {
    puts "Number could not be formatted at 8 characters !"
    set result $num
  }
  puts "\$result = $result"
  return $result
}

proc p2p::roaming_setup_sniffer {} {
	# access option array
	upvar {} {}

	UTF::Try "Setup Sniffer" {
	
		UTF::Message INFO "" "************************Func:roaming_setup_sniffer***************************"

		set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_pcap_file ".pcap"
		set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
		append roaming_sniffer_csv_file ".csv"

		UTF::Message LOG "" "=====================Setup sniffer================================"
		$::sniffer_object setupSniffer $::roaming_channel
		$::sniffer_object wl ver
		catch {$::sniffer_object stopall}
		catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_pcap_file}
		catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_csv_file}
		catch {$::sniffer_object rm -f /root/bin/tshark_cmd_line}
		catch {$::sniffer_object rm -f /root/bin/tshark_cmd_line_parse}

		###############################################################
		# sniffer pcap file will be captured
		# after stopping the sniffer, it will be filtered and converted to csv file for parsing
		###############################################################

		set cmd_line "tshark -i radiotap0 -w /root/bin/$roaming_sniffer_pcap_file"
		set cmd_line_file "tshark_cmd_line"
		set fd [open "$::logdir/$cmd_line_file" w+]
		puts $fd "$cmd_line"
		close $fd
		UTF::Sleep 1
		UTF::Message LOG "" "chmod 777 $::logdir/$cmd_line_file"
		exec chmod 777 $::logdir/$cmd_line_file
		UTF::Sleep .5
		
		set sniff_ip [$::sniffer_object cget -lan_ip]

		# copy the file to sniffer /root/bin/tshark_cmd_line
		UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
		set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			# failed. create the /root/bin directory since it could be missing
			UTF::Message LOG "" "$::sniffer_object mkdir -p /root/bin"
			catch {$::sniffer_object mkdir -p /root/bin}

			set catch_resp [catch {$::sniffer_object mkdir -p /root/bin} catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. Could not create /root/bin on Sniffer. Please cleanup /root/bin location."
				error "Cleanup sniffer /root/bin"
			} else {
				UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
				set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			}
		}
		UTF::Message LOG "" "====================================================="

		set cmd_line_parse "tshark -2 -r /root/bin/$roaming_sniffer_pcap_file -Y \"(wlan.fc.type_subtype == 40 || wlan.fc.type_subtype == 11) && (wlan.bssid == $::roaming_src_ap_mac || wlan.bssid == $::roaming_dst_ap_mac)\" -E header=y -E separator=, -T fields -e frame.number -e frame.time_relative -e wlan.duration -e ip.src -e ip.dst -e wlan.ta -e wlan.ra -e frame.len -e wlan.fc.type_subtype -e wlan_mgt.ssid -e wlan.flags -e wlan.fc.retry -e radiotap.channel.freq -e wlan_mgt.ht.info.primarychannel -e radiotap.vht.bw -e radiotap.datarate -e radiotap.dbm_antsignal -e wlan.seq -e wlan.ba.bm -e wlan.bssid > /root/bin/$roaming_sniffer_csv_file"
		set cmd_line_file "tshark_cmd_line_parse"
		set fd [open "$::logdir/$cmd_line_file" w+]
		puts $fd "$cmd_line_parse"
		close $fd
		UTF::Sleep 1
		UTF::Message LOG "" "chmod 777 $::logdir/$cmd_line_file"
		exec chmod 777 $::logdir/$cmd_line_file
		UTF::Sleep .5

		# copy the file to sniffer /root/bin/tshark_cmd_line_parse
		UTF::Message LOG "" "scp -Bqr $::logdir/$cmd_line_file root@$sniff_ip:/root/bin/$cmd_line_file"
		set catch_resp [catch {exec scp -Bqr "$::logdir/$cmd_line_file" root@$sniff_ip:/root/bin/$cmd_line_file} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Could not copy '$cmd_line_file' to '/root/bin' on Sniffer."
			error "Failed to copy '$cmd_line_file' to '/root/bin' on Sniffer"
		}
	}
}

proc p2p::roaming_stop_sniffer {} {
	# access option array
	upvar {} {}
	
	UTF::Message INFO "" "************************Func:roaming_stop_sniffer***************************"

	# stop the sniffer
	catch {$::sniffer_object stopall}
	
	set sniff_ip [$::sniffer_object cget -lan_ip]

	set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_pcap_file ".pcap"
	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	###############################################################
	# sniffer pcap file is captured now. filter and convert to csv file for parsing
	###############################################################

	# sync call to generate the csv file
	catch "$::sniffer_object rexec /root/bin/tshark_cmd_line_parse"

	UTF::Message LOG "" "Check for sniffer csv file /root/bin/$roaming_sniffer_csv_file"
	set catch_resp [catch "$::sniffer_object rexec ls -la /root/bin/$roaming_sniffer_csv_file" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	if {$catch_resp != 0} {
		UTF::Message LOG "" "***Failed. Sniffer parsing did not work. $catch_msg"
		set ::roaming_sniffer_failed_flag 1
		set ::roaming_sniffer_failed_msg "Sniffer parsing did not work"
	} else {
		# copy over the sniffer file to the report location
		UTF::Message LOG "" "scp -Bqr root@$sniff_ip:/root/bin/$roaming_sniffer_csv_file $::logdir/$roaming_sniffer_csv_file"
		set catch_resp [catch {exec scp -Bqr root@$sniff_ip:/root/bin/$roaming_sniffer_csv_file "$::logdir/$roaming_sniffer_csv_file"} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		if {$catch_resp == 0} {
			# copied the file, now remove it from the sniffer
			catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_pcap_file}
			catch {$::sniffer_object rm -f /root/bin/$roaming_sniffer_csv_file}
		}
	}

	# clean up sniffer temp files
	catch {$::sniffer_object rm -f /tmp/ether*}
}

proc p2p::get_date_difference {start_datetime end_datetime} {

	set TimeDiff -1

	catch {
		regexp {(.*)\.(.*)} $start_datetime smatch start_date start_sec
		regexp {(.*)\.(.*)} $end_datetime lmatch end_date end_sec

		set start_num [clock scan $start_date]
		set start_num "$start_num\.$start_sec"
		set start_num [format "%.6f" $start_num]
		
		set end_num [clock scan $end_date]
		set end_num "$end_num\.$end_sec"
		set end_num [format "%.6f" $end_num]
		
		set TimeDiff [expr {$end_num - $start_num}]
		set TimeDiff [format "%.6f" $TimeDiff]
		UTF::Message INFO "" "\n$end_num - $start_num = $TimeDiff\n"
	}

	return $TimeDiff
}

proc p2p::roaming_parse_sniffer {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:roaming_parse_sniffer***************************"

	# for raoming, the first GC is only used
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set ::roam_time -1

	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	# downstream throughput
	set FromIP $::tg_wlan_ip
	set ToIP $::array_sta_wlan_ip(${sta_wlan_index})
	set FromBssid $::roaming_src_ap_mac
	set ToBssid $::roaming_dst_ap_mac

	set BeginRoamTimeStamp ""
	set EndRoamTimeStamp ""
	set offset 0

	set first_stream_name [lindex $::streams_name_list 0]

	UTF::Message INFO "" "\nsniffer_file: $::logdir/$roaming_sniffer_csv_file\nFromIP: $FromIP\nToIP: $ToIP\nFromBssid: $FromBssid\nToBssid: $ToBssid\n"

	if {$::array_streams_tos(${first_stream_name}) == "TCP"} {
		# for TCP look for a message with at least 1 byte
		set msg_len 1
	} else {
		# for UDP look for any length message
		set msg_len 0
	}

	set csv_fd [open $::logdir/$roaming_sniffer_csv_file]

	# find the Authentication in the trace
	# FC11 -> 2011-03-30 12:14:01.974201 Epigram_c5:00:34 -> Epigram_a6:00:30 IEEE 802.11 Authentication, SN=202, FN=0, Flags=........[Malformed Packet]  wlan.bssid == 00:90:4c:a6:00:30
	# FC15 -> 2014-09-29 14:35:01.648222 Broadcom_ee:b4:43 -> Epigram_0d:c0:d3 802.11 88 Authentication, SN=211, FN=0, Flags=........C  wlan.bssid == 00:90:4c:0d:c0:d3
	
	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************   Looking for Authentication    **************************"
	UTF::Message LOG "" "***********************************************************************************"

	# when 'wlan.fc.type_subtype == 11', that is the Authentication
	
	set csv_curr_line_no 0
	set csv_index_subtype -1
	set csv_index_ip_src -1
	set csv_index_ip_dst -1
	set csv_index_bssid -1
	set csv_index_msg_len -1
	set csv_index_msg_time -1
	while {[gets $csv_fd line] >= 0} {
		incr csv_curr_line_no
		set csv_columns_data [split $line ","]

		# find 'wlan.fc.type_subtype' in csv header
		if {$csv_curr_line_no == 1} {
			set csv_column_cnt 0
			foreach csv_column "$csv_columns_data" {
				if {$csv_column == "wlan.fc.type_subtype"} {
					set csv_index_subtype $csv_column_cnt
				} elseif {$csv_column == "ip.src"} {
					set csv_index_ip_src $csv_column_cnt
				} elseif {$csv_column == "ip.dst"} {
					set csv_index_ip_dst $csv_column_cnt
				} elseif {$csv_column == "wlan.bssid"} {
					set csv_index_bssid $csv_column_cnt
				} elseif {$csv_column == "frame.len"} {
					set csv_index_msg_len $csv_column_cnt
				} elseif {$csv_column == "frame.time_relative"} {
					set csv_index_msg_time $csv_column_cnt
				}
				incr csv_column_cnt
			}
			
			if {$csv_index_subtype == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'wlan.fc.type_subtype' in the sniffer csv hearder."
				error "subtype missing in the sniffer csv hearder"
			} elseif {$csv_index_ip_src == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'ip.src' in the sniffer csv hearder."
				error "ip.src missing in the sniffer csv hearder"
			} elseif {$csv_index_ip_dst == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'ip.dst' in the sniffer csv hearder."
				error "ip.dst missing in the sniffer csv hearder"
			} elseif {$csv_index_bssid == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'wlan.bssid' in the sniffer csv hearder."
				error "bssid missing in the sniffer csv hearder"
			} elseif {$csv_index_msg_len == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'frame.len' in the sniffer csv hearder."
				error "Msg length missing in the sniffer csv hearder"
			} elseif {$csv_index_msg_time == -1} {
				UTF::Message ERROR "" "***Failed. Could not find 'frame.time_relative' in the sniffer csv hearder."
				error "Msg time missing in the sniffer csv hearder"
			}

			continue
		}

		set csv_subtype [lindex $csv_columns_data $csv_index_subtype]

		if {$csv_subtype == 11} {
			UTF::Message INFO "" "'802.11 Authentication' $line"
			set offset [tell $csv_fd]
			break
		}
	}

	# TCP msg:
	#   DATE        TIME          IP FROM      ->     TO IP                                                                                                   Len=                                       wlan.bssid ==
	# 2014-10-24 11:46:39.321196 192.168.1.220 -> 192.168.1.236 TCP 3124 [TCP Out-Of-Order] [TCP Out-Of-Order] 53087 > 55001 [ACK] Seq=192407345 Ack=1 Win=46 Len=1448 TSval=4263696804 TSecr=186301512  wlan.bssid == 00:10:18:a9:36:35
	#                            DATE                      TIME                         IP FROM        ->      TO IP         ANY Len=    ANY wlan\.bssid ==
	# set result [regexp {([0-9]+\-[0-9]+\-[0-9]+ [0-9]+\:[0-9]+\:[0-9]+\.[0-9]+) (\d+\.\d+\.\d+\.\d+) -> (\d+\.\d+\.\d+\.\d+).* Len=(\d+).*wlan\.bssid == (.*:.*:.*:.*:.*:.*)} $line match dataTime from to len bssid]
	#
	# UDP Video msg:
	#   DATE        TIME          IP FROM      ->     TO IP     UDP length                                            wlan.bssid ==
	# 2014-10-24 12:13:44.735651 192.168.1.220 -> 192.168.1.236 UDP 1584 Source port: 35927  Destination port: 55005  wlan.bssid == 00:10:18:a9:36:35
	#                            DATE                      TIME                         IP FROM        ->      TO IP           UDP length ANY wlan\.bssid ==
	# set result [regexp {([0-9]+\-[0-9]+\-[0-9]+ [0-9]+\:[0-9]+\:[0-9]+\.[0-9]+) (\d+\.\d+\.\d+\.\d+) -> (\d+\.\d+\.\d+\.\d+) UDP (\d+).*wlan\.bssid == (.*:.*:.*:.*:.*:.*)} $line match dataTime from to len bssid]

	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************	Looking for 'BEGIN' Raoming	**************************"
	UTF::Message LOG "" "************************	Last downstream msg with $FromIP -> $ToIP  &  AP1 $FromBssid  & msg length of $msg_len or more"
	UTF::Message LOG "" "***********************************************************************************"

	# start from about 30 lines before the Authentication line 
	set BiginOffset [expr {$offset - 20000}]

	if {$BiginOffset < 0} {
		set BiginOffset 0
	}

	seek $csv_fd $BiginOffset

	set save_begin_roam_line ""
	set ap2_msg_cnt 0
	set cnt 0

	while {[gets $csv_fd line] >= 0} {

		set csv_columns_data [split $line ","]
		set csv_ip_src [lindex $csv_columns_data $csv_index_ip_src]
		set csv_ip_dst [lindex $csv_columns_data $csv_index_ip_dst]
		set csv_bssid [lindex $csv_columns_data $csv_index_bssid]
		set csv_msg_len [lindex $csv_columns_data $csv_index_msg_len]

		set csv_bssid [string toupper $csv_bssid]

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $ToBssid} {
			# AP2 msg
			incr ap2_msg_cnt
			if {$ap2_msg_cnt > 20} {
				# Done, since it is AP2 msgs now
				break
			}
		}

		UTF::Message INFO "" "$line"

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $FromBssid && $csv_msg_len >= $msg_len} {  
			set BeginRoamTimeStamp [lindex $csv_columns_data $csv_index_msg_time]
			set save_begin_roam_line $line
			incr cnt
			UTF::Message INFO "" "Begin Roam Data Count $cnt: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
			set ap2_msg_cnt 0
		} else {
			UTF::Message INFO "" "SKIP: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
		}
	}

	if {$save_begin_roam_line == ""} {
		UTF::Message ERROR "" "\n\n\nBegin roam time is not found"
		return "Roam begin time not found"
	}

	UTF::Message LOG "" "-----------------------------------------------------------------------------------"
	UTF::Message INFO "" "Begin roam: $save_begin_roam_line"
	UTF::Message LOG "" "-----------------------------------------------------------------------------------"

	# For 'END' Raoming voice and non-voice, look for any length message
	set msg_len 0

	UTF::Message LOG "" "\n\n\n***********************************************************************************"
	UTF::Message LOG "" "************************	Looking for 'END' Raoming	**************************"
	UTF::Message LOG "" "************************	1st downstream msg with $FromIP -> $ToIP  &  AP2 $ToBssid  & msg length of $msg_len or more"
	UTF::Message LOG "" "***********************************************************************************"

	# start from about 10 lines before the Authentication line 
	set BiginOffset [expr {$offset - 5000}]

	if {$BiginOffset < 0} {
		set BiginOffset 0
	}

	seek $csv_fd $BiginOffset

	set save_end_roam_line ""
	set cnt 0
	set skip_flag 1

	while {[gets $csv_fd line] >= 0} {

		# skip lines till save_begin_roam_line is found
		if {$skip_flag == 1} {
			if {$line == $save_begin_roam_line} {
				set skip_flag 0
			} else {
				continue
			}
		}

		UTF::Message INFO "" "$line"

		set csv_columns_data [split $line ","]
		set csv_ip_src [lindex $csv_columns_data $csv_index_ip_src]
		set csv_ip_dst [lindex $csv_columns_data $csv_index_ip_dst]
		set csv_bssid [lindex $csv_columns_data $csv_index_bssid]
		set csv_msg_len [lindex $csv_columns_data $csv_index_msg_len]

		set csv_bssid [string toupper $csv_bssid]

		if {$csv_ip_src == $FromIP && $csv_ip_dst == $ToIP && $csv_bssid == $ToBssid && $csv_msg_len >= $msg_len} {
			set EndRoamTimeStamp [lindex $csv_columns_data $csv_index_msg_time]
			set save_end_roam_line $line
			incr cnt
			UTF::Message INFO "" "End Roam Data Count $cnt: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
			break
		} else {
			UTF::Message INFO "" "SKIP: $csv_msg_len $csv_ip_src -> $csv_ip_dst	$csv_bssid"
		}
	}

	if {$save_end_roam_line == ""} {
		UTF::Message ERROR "" "\n\n\nEnd roam time is not found"
		return "Roam end time not found"
	}

	UTF::Message LOG "" "-----------------------------------------------------------------------------------"
	UTF::Message INFO "" "End roam: $save_end_roam_line"
	UTF::Message LOG "" "-----------------------------------------------------------------------------------\n\n\n"

	close $csv_fd

	UTF::Message INFO "" "\nRoam end at:   $EndRoamTimeStamp\nRoam begin at: $BeginRoamTimeStamp\n"
	set roam_time [expr {$EndRoamTimeStamp - $BeginRoamTimeStamp}]
	set roam_time [expr {round([expr {$roam_time * 1000.0}])}]
	UTF::Message INFO "" "Roam Time=$roam_time ms"
	set ::roam_time $roam_time
	
	return ""
}

proc p2p::get_roaming_time {test_type} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:get_roaming_time***************************"

	# for raoming, the first GC is only used
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
	append roaming_sniffer_csv_file ".csv"

	if {$::failover_test_flag} {
		set title "$test_type - Failover Roam Time"
		set roaming_type "Failover"
	} else {
		set title "$test_type - Smooth Roam Time"
		set roaming_type "Smooth"
	}

	# parse the sniffer file and calculate roaming time

	UTF::Try "$title (ms)" {

		set rc [p2p::roaming_parse_sniffer]
		
		if {$::roam_time == -1 || $rc != ""} {

			UTF::Message ERROR "" "Roam time calculation failed"

			# Add a web link to the sniffer file
			UTF::Try "Link to sniffer file $roaming_sniffer_csv_file" {
				return "html: <a href=\"$::logdir/$roaming_sniffer_csv_file\">$roaming_sniffer_csv_file</a>"
			}

			incr ::error_cnt

			if {$rc != ""} {
				error $rc
			} else {
				error "Roam time not found"
			}
		} else {
			UTF::Message INFO "" "Roam time calculation successfull."

			UTF::Try "Delete sniffer file" {
				set roaming_sniffer_pcap_file "$::roaming_sniffer_file_name"
				append roaming_sniffer_pcap_file ".pcap"
				set roaming_sniffer_csv_file "$::roaming_sniffer_file_name"
				append roaming_sniffer_csv_file ".csv"

				UTF::Message INFO "" "Deleting the sniffer file $::logdir/$roaming_sniffer_csv_file"

				set catch_resp [catch {exec rm -f $::logdir/$roaming_sniffer_csv_file} catch_msg]
				UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				if {$catch_resp == 0} {
					set catch_resp [catch {exec rm -f $::logdir/$roaming_sniffer_pcap_file} catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
				}

				if {$catch_resp != 0} {
					UTF::Message ERROR "" "Delete sniffer file failed"
					error "Delete sniffer file failed"
				}

				return ""
			}
		}

		set keys "$::key_base2 $test_type $roaming_type roam_time"
		UTF::Message INFO "" "keys=$keys"

		# Create new ControlChart object & graphics file
		set html_results [p2p::control_chart "" $::roam_time $keys "Roam Time" "ms" 0]

		if {$::failover_test_flag == 1} {
			if {$::roam_time > 15000} {
				# error
				set ::roaming_error_flag 1
				append html_results " &nbsp;<font color=\"red\"><b>Roam Time > 15 sec</b></font>"
			}
		} else {
			if {$::roam_time > 40} {
				# error
				set ::roaming_error_flag 1
				append html_results " &nbsp;<font color=\"red\"><b>Roam Time > 40 ms</b></font>"
			}
		}

		if {$::roaming_error_flag == 1} {
			error "html: $html_results"
		} else {
			return "html: $html_results"
		}
	}

	if {$::error_cnt == 0 && $::failover_test_flag == 0} {

		UTF::Try "$test_type - Smooth Roam Delta (dB)" {

			set csv_data_fd [open "$::curr_csv_data_fullname" r]

			# read the csv data to figure out 'Roam Delta'

			set y_max 0
			set len_max 0
			set csv_curr_line_no 0
			set csv_header_line_cnt 2
			set last_rssi_value ""
			set ::roam_delta_value ""
			
			set csv_index_bssid [find_csv_column_index "StaBssid($sta_wlan_index)" $::csv_columns_data_list]
			set csv_index_rssi [find_csv_column_index "StaRssi($sta_wlan_index)" $::csv_columns_data_list]

			while {[gets $csv_data_fd line]>=0} { 
				incr csv_curr_line_no

				# skip csv header
				if {$csv_curr_line_no <= $csv_header_line_cnt} {
					continue
				}

				set columns [split $line ","]
				set bssid "[lindex $columns $csv_index_bssid]"
				set bssid [string trim $bssid]
				set rssi "[lindex $columns $csv_index_rssi]"

				if {$bssid == $::roaming_src_ap_mac} {
					set last_rssi_value $rssi
				}
				if {$bssid == $::roaming_dst_ap_mac} {
					set ::roam_delta_value [expr {abs([expr {$rssi - $last_rssi_value}])}]
					UTF::Message LOG "" "::roam_delta_value = ($rssi) - ($last_rssi_value) = $::roam_delta_value"
					break
				}
			}

			set keys "$::key_base2 $test_type $roaming_type roam_delta"
			UTF::Message INFO "" "keys=$keys"

			# Create new ControlChart object & graphics file
			set html_results [p2p::control_chart "" $::roam_delta_value $keys "Roam Delta" "dB" 0]

			if {$::roaming_error_flag == 1} {
				error "html: $html_results"
			} else {
				return "html: $html_results"
			}
		}
	}	
}

proc p2p::roaming_calculate_attn_values {} {
	# access option array
	upvar {} {}

	# for raoming, the first GC is only used
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set iperf_name $::array_sta_iperf_name(${sta_wlan_index})

	set tmp_roam_trig_value 0
	set tmp_roaming_delta ""
	set tmp_src_ap_ssid ""
	set tmp_dst_ap_ssid ""

	UTF::Message INFO "" "************************Func:roaming_calculate_attn_values***************************"

	UTF::Try "Calculate Attn Values" {
		UTF::Message INFO "" "src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap STA=$sta_wlan_index"

		set ::roaming_dwell_time_sec 3

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5

		###############################################			
		# Calculate attenuator values for the src_ap (going away)
		# Find attenuation at tmp_roam_trig_value - This is ::roaming_src_ap_attn_end value
		# ::roaming_src_ap_attn_start = ::roaming_src_ap_attn_end - attn cnt tmp_roaming_delta
		###############################################			

		for {set j 1} {$j <= 3} {incr j} {
				UTF::Message INFO "" "Associate $::roaming_src_ap $sta_wlan_index Try: $j"  
			UTF::Message INFO "" "Disassociate $sta_wlan_index"  
			catch {$sta_wlan_index wl disassoc}
			UTF::Sleep 2
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_wlan_index" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			UTF::Message LOG "" "-----------------------------------------------"
			if {$catch_resp == 0} { 
				break
			}
		}

		set catch_resp [catch "$sta_wlan_index wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$::roaming_src_ap_mac != "" && $::roaming_src_ap_mac != $catch_msg} {
				# ::roaming_src_ap_mac is config file did not match the read AP mac address
				UTF::Message INFO "" "AP Mac Id Mismatch. ::roaming_src_ap_macConfig=$::roaming_src_ap_mac APMac=$catch_msg"
			}

			set ::roaming_src_ap_mac $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac from association"  
		}

		set catch_resp [catch "$::roaming_src_ap wl ssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$tmp_src_ap_ssid != "" && $tmp_src_ap_ssid != $catch_msg} {
				# tmp_src_ap_ssid is config file did not match the read AP ssid
				UTF::Message ERROR "" "***Failed. Mismatch. tmp_src_ap_ssid=$tmp_src_ap_ssid Assoc_APssid=$catch_msg"
				error "$::roaming_src_ap SSID mismatch"
			}

			set tmp_src_ap_ssid $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with AP ssid=$tmp_src_ap_ssid"  
		}

		set catch_resp [catch "$sta_wlan_index wl roam_trigger $::roaming_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_wlan_index wl roam_trigger $::roaming_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			# roam_trigger is 0xffb5(-75)
			regexp {roam_trigger is .*\((-[0-9]+)\)} $catch_msg match tmp_roam_trig_value
			UTF::Message INFO "" "tmp_roam_trig_value=$tmp_roam_trig_value"
		}

		set catch_resp [catch "$sta_wlan_index wl roam_delta $::roaming_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_wlan_index wl roam_delta $::roaming_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			# roam_delta is 0x0014(20)
			regexp {roam_delta is .*\(([0-9]+)\)} $catch_msg match tmp_roaming_delta
			UTF::Message INFO "" "tmp_roaming_delta=$tmp_roaming_delta"
		}

		# Start downstream iperf traffic
		UTF::Message INFO "" "A - calculate_attn_values - Start the iperf"

		set fd_rx [$sta_wlan_index rpopen $iperf_name -s -fm -i $::perfint -p $::curr_iperf_port -l 8k -P 1]
		set stream_ids "iperf $fd_rx"
		set catch_resp [catch {set iperf_endpoint_pid [pid $fd_rx]} catch_msg]
		set fd_tx [$::tg_wlan rpopen iperf -c $::array_sta_wlan_ip(${sta_wlan_index}) -t 120 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
		fconfigure $fd_tx -blocking 0
		fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		UTF::Sleep .5
		incr ::curr_iperf_port

		set attn_val 0

		while { 1 } {

			$::roaming_src_ap_attn_group attn $attn_val
			UTF::Sleep $::roaming_dwell_time_sec

			set catch_resp [catch "$sta_wlan_index wl rssi" catch_msg]

			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. $catch_msg"
				error $catch_msg
			} else {
				set rssi [expr {int($catch_msg)}]

				UTF::Message INFO "" "-> attn_val=$attn_val rssi=$rssi"  
			}

			if {$attn_val > 100} {
				break
			}

			# break if rssi greater than tmp_roam_trig_value 
			if {[expr {int($rssi)}] < [expr {int($tmp_roam_trig_value) + int(-4)}]} {
				break
			}

			if {$attn_val == 0} {
				set attn_val [expr {int($tmp_roam_trig_value) - int($rssi)}]
				set attn_val [expr {abs(int($attn_val))}]
			} else {
				set attn_val [expr {$attn_val + 2}]
			}
		}

		set src_ap_roam_trigger_attn [expr {$attn_val - 1}]
		UTF::Message INFO "" "1 src_ap_roam_trigger_attn=$src_ap_roam_trigger_attn"

		if {!$::failover_test_flag} {
			UTF::Message LOG "" "*************************** Smooth Roaming *****************************"

			UTF::Message INFO "" "2 src_ap_roam_trigger_attn=$src_ap_roam_trigger_attn"

			# src_ap start = src_ap_roam_trigger_attn - tmp_roaming_delta(20dB)
			# src_ap end	= src_ap_roam_trigger_attn
			set ::roaming_src_ap_attn_start [expr {$src_ap_roam_trigger_attn - $tmp_roaming_delta - 1}]
			if {int($::roaming_src_ap_attn_start) < 0} {
				set ::roaming_src_ap_attn_start 0
			}
			if {$::roaming_src_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_start"
				}
		
				set ::roaming_src_ap_attn_start $::max_attn
			}
			set ::roaming_src_ap_attn_end [expr {$src_ap_roam_trigger_attn + 1}]
			if {$::roaming_src_ap_attn_end > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_end."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_end"
				}

				set ::roaming_src_ap_attn_end $::max_attn
			}
			
			set ::roaming_sniffer_start_attn [expr {$src_ap_roam_trigger_attn - 4}]
		} else {
			UTF::Message LOG "" "*************************** Failover Roaming *****************************"

			set ::roaming_src_ap_attn_start [expr {$src_ap_roam_trigger_attn - 35}]
			if {$::roaming_src_ap_attn_start < 0} {
				set ::roaming_src_ap_attn_start 0
			}
			if {$::roaming_src_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_src_ap_attn_start"
				}

				set ::roaming_src_ap_attn_start $::max_attn
			}
			set ::roaming_src_ap_attn_end $::roaming_src_ap_attn_start
		}

		UTF::Message INFO "" "src_ap Start=$::roaming_src_ap_attn_start"
		UTF::Message INFO "" "src_ap End  =$::roaming_src_ap_attn_end"

		UTF::Message INFO "" "Stop the iperf traffic"
		UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
		set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		UTF::Message LOG "" "--------------------------------------------------------------------------"
		
		###############################################			
		# Calculate attenuator values for the dst_ap
		# Find attenuation at (tmp_roam_trig_value - tmp_roaming_delta) - This is ::roaming_dst_ap_attn_end value
		# ::roaming_dst_ap_attn_start = ::roaming_dst_ap_attn_end - attn cnt src ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_wlan_index"  
		catch {$sta_wlan_index wl disassoc}

		$::roaming_src_ap_attn_group attn $::max_attn
		$::roaming_dst_ap_attn_group attn 0
		UTF::Sleep 5

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "Disassociate $sta_wlan_index"  
			catch {$sta_wlan_index wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_dst_ap $sta_wlan_index Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_dst_ap $sta_wlan_index" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			UTF::Message LOG "" "-----------------------------------------------"
			if {$catch_resp == 0} { 
				break
			}
		}

		set catch_resp [catch "$sta_wlan_index wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$::roaming_dst_ap_mac != "" && $::roaming_dst_ap_mac != $catch_msg} {
				# ::roaming_dst_ap_mac is config file did not match the read AP mac address
				UTF::Message INFO "" "AP Mac Id Mismatch. ::roaming_dst_ap_macConfig=$::roaming_dst_ap_mac APMac=$catch_msg"
			}

			set ::roaming_dst_ap_mac $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac from association"  
		}

		set catch_resp [catch "$::roaming_dst_ap wl ssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			error $catch_msg
		} else {
			if {$tmp_dst_ap_ssid != "" && $tmp_dst_ap_ssid != $catch_msg} {
				# tmp_dst_ap_ssid is config file did not match the read AP ssid
				UTF::Message ERROR "" "***Failed. Mismatch. tmp_dst_ap_ssidConfig=$tmp_dst_ap_ssid APssid=$catch_msg"
				error "$::roaming_dst_ap SSID mismatch"
			}

			set tmp_dst_ap_ssid $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with AP ssid=$tmp_dst_ap_ssid"  
		}

		# Start downstream iperf traffic
		UTF::Message INFO "" "B - calculate_attn_values - Start the iperf"

		set fd_rx [$sta_wlan_index rpopen $iperf_name -s -fm -i $::perfint -p $::curr_iperf_port -l 8k -P 1]
		set stream_ids "iperf $fd_rx"
		set catch_resp [catch {set iperf_endpoint_pid [pid $fd_rx]} catch_msg]
		set fd_tx [$::tg_wlan rpopen iperf -c $::array_sta_wlan_ip(${sta_wlan_index}) -t 120 -fm -i $::perfint -p $::curr_iperf_port -l 8k]
		fconfigure $fd_tx -blocking 0
		fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		UTF::Sleep .5
		incr ::curr_iperf_port

		set attn_val 0

		while { 1 } {

			$::roaming_dst_ap_attn_group attn $attn_val
			UTF::Sleep $::roaming_dwell_time_sec

			set catch_resp [catch "$sta_wlan_index wl rssi" catch_msg]

			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. $catch_msg"
				error $catch_msg
			} else {
				set rssi [expr {int($catch_msg)}]

				UTF::Message INFO "" "-> attn_val=$attn_val rssi=$rssi"  
			}

			if {$attn_val > 100} {
				break
			}

			# break if rssi greater than tmp_roam_trig_value - tmp_roaming_delta
			if {[expr {int($rssi)}] < [expr {int($tmp_roam_trig_value) + int($tmp_roaming_delta)}]} {
				UTF::Message INFO "" "rssi < tmp_roam_trig_value + tmp_roaming_delta"  
				UTF::Message INFO "" "$rssi < $tmp_roam_trig_value + $tmp_roaming_delta"  
				UTF::Message INFO "" "done"  
				break
			}

			if {$attn_val == 0} {
				UTF::Message INFO "" "attn_val is 0"  
				UTF::Message INFO "" "attn_val = tmp_roam_trig_value - rssi + tmp_roaming_delta"  
				set attn_val [expr {int($tmp_roam_trig_value) - int($rssi) + int($tmp_roaming_delta)}]
				set attn_val [expr {abs(int($attn_val))}]
				UTF::Message INFO "" "$attn_val = $tmp_roam_trig_value - $rssi + $tmp_roaming_delta"  
			} else {
				UTF::Message INFO "" "attn_val=$attn_val + 2"  
				set attn_val [expr {$attn_val + 2}]
			}
		}

		if {$attn_val < 0} {
			set attn_val 0
		}

		if {!$::failover_test_flag} {
			UTF::Message LOG "" "*************************** Smooth Roaming *****************************"

			set ::roaming_dst_ap_attn_start [expr {$attn_val + int([expr {$tmp_roaming_delta / 2.0}])}]
			set ::roaming_dst_ap_attn_end 0
			
			if {$::roaming_dst_ap_attn_start < 0} {
				set ::roaming_dst_ap_attn_start 0
			}
			if {$::roaming_dst_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_start"
				}

				set ::roaming_dst_ap_attn_start $::max_attn
			}
			if {$::roaming_dst_ap_attn_end < 0} {
				set ::roaming_dst_ap_attn_end 0
			}
			if {$::roaming_dst_ap_attn_end > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_end."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_end"
				}

				set ::roaming_dst_ap_attn_end $::max_attn
			}
			
			set ret_str "Attn: src_ap=$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end dst_ap=$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end sniffer_start=$::roaming_sniffer_start_attn"
		} else {
			UTF::Message LOG "" "*************************** Failover Roaming *****************************"

			#set ::roaming_dst_ap_attn_start [expr {$attn_val + int($tmp_roaming_delta) - 10.0}]
			set ::roaming_dst_ap_attn_start $::roaming_src_ap_attn_start
			if {$::roaming_dst_ap_attn_start < 0} {
				set ::roaming_dst_ap_attn_start 0
			}
			if {$::roaming_dst_ap_attn_start > $::max_attn} {
				if {$::max_attn < 90} {
					UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
					incr ::error_cnt
					error "Attenuator does not support $::roaming_dst_ap_attn_start"
				}

				set ::roaming_dst_ap_attn_start $::max_attn
			}
			set ::roaming_dst_ap_attn_end $::roaming_dst_ap_attn_start
			set ret_str "Attn: src_ap=$::roaming_src_ap_attn_start dst_ap=$::roaming_dst_ap_attn_start"
		}

		UTF::Message INFO "" "dst_ap Start=$::roaming_dst_ap_attn_start"
		UTF::Message INFO "" "dst_ap End  =$::roaming_dst_ap_attn_end"

		UTF::Message INFO "" "Stop the iperf traffic"
		UTF::Message INFO "" "exec kill -9 $iperf_endpoint_pid"  
		set catch_resp [catch "exec kill -9 $iperf_endpoint_pid" catch_msg]
		UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		UTF::Message LOG "" "--------------------------------------------------------------------------"

		return $ret_str
	}
}

proc p2p::get_roaming_macid_values {} {
	# access option array
	upvar {} {}

	# for raoming, the first GC is only used
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set tmp2_roam_trig_value 0
	set ::roam_trigger_value ""
	set ::roam_delta_value ""

	UTF::Try "Check Mac IDs" {
		UTF::Message INFO "" "************************Func:get_roaming_macid_values***************************"
		UTF::Message INFO "" "src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap STA=$sta_wlan_index"

		UTF::Message INFO "" "--------------------------------src_ap------------------------------------"  

		###############################################			
		# src_ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_wlan_index"  
		catch {$sta_wlan_index wl disassoc}
		UTF::Sleep 2

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5

		# set the roaming ssid for bath APs		
		foreach ap "$::roaming_src_ap $::roaming_dst_ap" {
			set SSID ""
			if {$::soft_ap_flag == 0} {
				# AP
				set wlname [$ap wlname]

				catch {$ap nvram set ${wlname}_ssid=$::roaming_test_ssid}
				$ap nvram commit
				$ap restart
				UTF::Sleep 10

				$ap configure -ssid $::roaming_test_ssid

				catch {$ap nvram get ${wlname}_ssid} SSID
			} else {
				# SoftAP
				catch "$ap wl ssid $::roaming_test_ssid"
				set catch_resp [catch "$ap wl ssid" SSID]
			}
			
			if {$SSID != $::roaming_test_ssid} {
				set tmp "SSID for $ap is '$SSID' instead of '$::roaming_test_ssid'"
				UTF::Message ERROR "" "***Failed. $tmp"
				incr ::error_cnt
				error $tmp
			}
		}

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_wlan_index"  
			catch {$sta_wlan_index wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_src_ap $sta_wlan_index Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_wlan_index" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		set src_ap_bssid ""
		set catch_resp [catch "$::roaming_src_ap wl bssid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set src_ap_bssid $catch_msg
			UTF::Message LOG "" "src_ap_bssid=$src_ap_bssid"
		}
		
		set catch_resp [catch "$sta_wlan_index wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set ::roaming_src_ap_mac $catch_msg
			UTF::Message INFO "" "src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac from association"  

			if {$::roaming_src_ap_mac == "" || $::roaming_src_ap_mac != $src_ap_bssid} {
				# ::roaming_src_ap_mac is config file did not match the read AP mac address
				UTF::Message ERROR "" "***Failed. Source AP association problem. AP BSSID '$src_ap_bssid' != STA BSSID '$::roaming_src_ap_mac'"
				incr ::error_cnt
				error "Source AP BSSID mismatch"
			}
		}

		set ap_band [$::roaming_src_ap band $::roaming_channel]
		
		set catch_resp [catch "$sta_wlan_index wl roam_trigger $ap_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_wlan_index wl roam_trigger $ap_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		}
		
		# roam_trigger is 0xffb5(-75)
		regexp {roam_trigger is .*\((-[0-9]+)\)} $catch_msg match tmp2_roam_trig_value
		UTF::Message INFO "" "tmp2_roam_trig_value=$tmp2_roam_trig_value"

		if {$::roam_trigger_value == ""} {
			set ::roam_trigger_value $tmp2_roam_trig_value
		} else {
			if {$tmp2_roam_trig_value != $::roam_trigger_value} {
				UTF::Message ERROR "" "***Failed. STA roam_trigger is $tmp2_roam_trig_value instead of $::roam_trigger_value"
				incr ::error_cnt
				error "STA roam_trigger is $tmp2_roam_trig_value instead of $::roam_trigger_value"
			}
		}

		set catch_resp [catch "$sta_wlan_index wl roam_delta $ap_band" catch_msg]
		if {$catch_resp != 0} {
			UTF::Sleep 2
			set catch_resp [catch "$sta_wlan_index wl roam_delta $ap_band" catch_msg]
		}
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			# roam_delta is 0x0014(20)
			regexp {roam_delta is .*\(([0-9]+)\)} $catch_msg match ::roam_delta_value
		}

		set rc "Default roam_trigger=$tmp2_roam_trig_value, roam_delta=$::roam_delta_value"
		
		UTF::Message INFO "" "--------------------------------dst_ap------------------------------------"  
		###############################################			
		# dst_ap
		###############################################			

		UTF::Message INFO "" "Disassociate $sta_wlan_index"  
		catch {$sta_wlan_index wl disassoc}

		$::roaming_src_ap_attn_group attn $::max_attn
		$::roaming_dst_ap_attn_group attn 0
		UTF::Sleep 5

		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_wlan_index"  
			catch {$sta_wlan_index wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_dst_ap $sta_wlan_index Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_dst_ap $sta_wlan_index" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		set dst_ap_bssid ""
		set catch_resp [catch "$::roaming_dst_ap wl bssid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set dst_ap_bssid $catch_msg
			UTF::Message LOG "" "dst_ap_bssid=$dst_ap_bssid"
		}

		set catch_resp [catch "$sta_wlan_index wl bssid" catch_msg]

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. $catch_msg"
			incr ::error_cnt
			error $catch_msg
		} else {
			set ::roaming_dst_ap_mac $catch_msg
			UTF::Message INFO "" "dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac from association"  

			if {$::roaming_dst_ap_mac == "" || $::roaming_dst_ap_mac != $dst_ap_bssid} {
				# ::roaming_dst_ap_mac is config file did not match the read AP mac address
				UTF::Message ERROR "" "***Failed. Source AP association problem. AP BSSID '$dst_ap_bssid' != STA BSSID '$::roaming_dst_ap_mac'"
				incr ::error_cnt
				error "Destination AP BSSID mismatch"
			}
		}

		$::roaming_dst_ap_attn_group attn $::max_attn
		$::roaming_src_ap_attn_group attn 0
		UTF::Sleep 5
		
		for {set j 1} {$j <= 3} {incr j} {
			UTF::Message INFO "" "----------------------------------------------------"  
			UTF::Message INFO "" "Disassociate $sta_wlan_index"  
			catch {$sta_wlan_index wl disassoc}
			UTF::Sleep 2
			UTF::Message INFO "" "Associate $::roaming_src_ap $sta_wlan_index Try: $j"  
			set catch_resp [catch "UTF::Test::ConnectAPSTA $::roaming_src_ap $sta_wlan_index" catch_msg]
			UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
			if {$catch_resp == 0} { 
				break
			}
		}

		regexp {^(\d+)\-(\d+)$} $::roaming_src_ap_attn - ::roaming_src_ap_attn_start ::roaming_src_ap_attn_end
		regexp {^(\d+)\-(\d+)$} $::roaming_dst_ap_attn - ::roaming_dst_ap_attn_start ::roaming_dst_ap_attn_end
		if {$::roaming_src_ap_attn_start < 0} {
			set ::roaming_src_ap_attn_start 0
		}
		if {$::roaming_src_ap_attn_start > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_start."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_src_ap_attn_start"
			}
		
			set ::roaming_src_ap_attn_start $::max_attn
		}
		if {$::roaming_src_ap_attn_end < 0} {
			set ::roaming_src_ap_attn_end 0
		}
		if {$::roaming_src_ap_attn_end > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_src_ap_attn_end."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_src_ap_attn_end"
			}
		
			set ::roaming_src_ap_attn_end $::max_attn
		}
		if {$::roaming_dst_ap_attn_start < 0} {
			set ::roaming_dst_ap_attn_start 0
		}
		if {$::roaming_dst_ap_attn_start > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_start."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_dst_ap_attn_start"
			}
		
			set ::roaming_dst_ap_attn_start $::max_attn
		}
		if {$::roaming_dst_ap_attn_end < 0} {
			set ::roaming_dst_ap_attn_end 0
		}
		if {$::roaming_dst_ap_attn_end > $::max_attn} {
			if {$::max_attn < 90} {
				UTF::Message ERROR "" "***Failed. Attenuator max is $::max_attn, but need to set it to $::roaming_dst_ap_attn_end."
				incr ::error_cnt
				error "Attenuator does not support $::roaming_dst_ap_attn_end"
			}
		
			set ::roaming_dst_ap_attn_end $::max_attn
		}
		UTF::Message LOG "" "::roaming_src_ap_attn_start=$::roaming_src_ap_attn_start ::roaming_src_ap_attn_end=$::roaming_src_ap_attn_end"
		UTF::Message LOG "" "::roaming_dst_ap_attn_start=$::roaming_dst_ap_attn_start ::roaming_dst_ap_attn_end=$::roaming_dst_ap_attn_end"
		UTF::Message LOG "" "Attn: src_ap=$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end dst_ap=$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end"
		UTF::Message INFO "" "::roam_trigger_value=$::roam_trigger_value"
		UTF::Message INFO "" "::roam_delta_value=$::roam_delta_value"

		if {$::failover_test_flag} {
			set ::roaming_dwell_time_sec 5
			set ::roaming_max_loop_cnt 8
			set ::qos_streams_total_time [expr {$::roaming_dwell_time_sec * $::roaming_max_loop_cnt}]
			UTF::Message LOG "" "Failover ::qos_streams_total_time=$::qos_streams_total_time"
		} else {
			set ::roaming_dwell_time_sec 3
			set ::roaming_max_loop_cnt [expr {$::roaming_src_ap_attn_end - $::roaming_src_ap_attn_start + 1}]
			set ::qos_streams_total_time [expr {$::roaming_dwell_time_sec * $::roaming_max_loop_cnt}]
			UTF::Message LOG "" "Smooth ::qos_streams_total_time=$::qos_streams_total_time"
		}

		UTF::Message LOG "" "::roaming_max_loop_cnt=$::roaming_max_loop_cnt"
		UTF::Message LOG "" "::roaming_src_ap_mac=$::roaming_src_ap_mac"
		UTF::Message LOG "" "::roaming_dst_ap_mac=$::roaming_dst_ap_mac"

		return $rc
	}
}

proc p2p::process_all_roaming_tests {} {
	# access option array
	upvar {} {}
	
	UTF::Message INFO "" "************************Func:process_all_roaming_tests***************************"

	# for raoming, the first GC is only used
	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set tests_type_list ""
	set tests_channel_list ""
	if {!$(no5G80roaming)} {	
		append tests_type_list "5G80 "
		append tests_channel_list "36/80 "
	}
	if {!$(no5G40roaming)} {
		append tests_type_list "5G40 "
		append tests_channel_list "36l "
	}
	if {!$(no5G20roaming)} {
		append tests_type_list "5G20 "
		append tests_channel_list "36 "
	}
	if {!$(no2G40roaming)} {
		append tests_type_list "2G40 "
		append tests_channel_list "11u "
	}
	if {!$(no2G20roaming)} {
		append tests_type_list "2G20 "
		append tests_channel_list "3 "
	}

	set tests_type_list [string trim $tests_type_list]
	set tests_channel_list [string trim $tests_channel_list]

	UTF::Message LOG "" "tests_type_list='$tests_type_list' tests_channel_list='$tests_channel_list'"

	foreach test_type $tests_type_list ::roaming_channel $tests_channel_list {
		set var "roam_${test_type}_src_ap_attn"
		set ::roaming_src_ap_attn $(${var})
		set var "roam_${test_type}_dst_ap_attn"
		set ::roaming_dst_ap_attn  $(${var})		
		set var "roam_${test_type}_sniffer_start_attn"
		set ::roaming_sniffer_start_attn $(${var})
		set var "roam_${test_type}_roam_trigger_value"
		set ::roam_trigger_value $(${var})

		UTF::Message LOG "" "test_type='$test_type' ::roaming_channel='$::roaming_channel' ::roaming_src_ap_attn=$::roaming_src_ap_attn ::roaming_dst_ap_attn=$::roaming_dst_ap_attn ::roaming_sniffer_start_attn=$::roaming_sniffer_start_attn ::roam_trigger_value=$::roam_trigger_value"

		set ::error_cnt 0
		
		if {$::roam_trigger_value != ""} {
			set catch_resp [catch "$sta_wlan_index wl roam_trigger $::roam_trigger_value all" catch_msg]
			if {$catch_resp != 0} {
				UTF::Message ERROR "" "***Failed. 'wl roam_trigger $::roam_trigger_value all' $catch_msg"
				incr ::error_cnt
				error "'wl roam_trigger $::roam_trigger_value all' $catch_msg"
			}
		}

		set ::wlan_ap [lindex $::list_ap_objects 0]
		UTF::Message LOG "" "::wlan_ap=$::wlan_ap"
		
		if {[regexp {/80$} $::roaming_channel]} {
			set ::roaming_cap "80"
		} else {
			if {[regexp {[ul]$} $::roaming_channel]} {
				set ::roaming_cap "40"
			} else {
				set ::roaming_cap "20"
			}
		}

		set tmp_roaming_channel ""
		regsub -all -nocase {\/} $::roaming_channel "_" tmp_roaming_channel

		if {!$(nosmoothroaming)} {

			set ::roaming_test_title "$test_type - Smooth Roaming"
			
			UTF::Try "$::roaming_test_title" {

				set ::failover_test_flag 0

				p2p::setup_ap_radio_channel $(roam_src_ap) $::roaming_channel
				p2p::setup_ap_radio_channel $(roam_dst_ap) $::roaming_channel

				if {$::roaming_src_ap == "" || $::roaming_dst_ap == ""} {
					UTF::Message ERROR "" "***Failed. setup_ap_radio_channel issue."
					incr ::error_cnt
					error "Setup AP radio failed"
				}

				set ::roaming_src_ap_attn_group [$::roaming_src_ap cget -attngrp]
				set ::roaming_dst_ap_attn_group [$::roaming_dst_ap cget -attngrp]
				UTF::Message LOG "" "::roaming_src_ap_attn_group=$::roaming_src_ap_attn_group ::roaming_dst_ap_attn_group=$::roaming_dst_ap_attn_group"

				if {$::roaming_src_ap_attn_group == "" || $::roaming_dst_ap_attn_group == ""} {
					error "AP attenuation group is missing"
				}

				$::roaming_dst_ap_attn_group attn $::max_attn
				$::roaming_src_ap_attn_group attn 0
				UTF::Sleep 5

				set ::wlan_ap $::roaming_src_ap
				p2p::gc_or_go_join_ap
				p2p::connection_test
				
				if {$::soft_ap_flag == 0} {
					# AP - get macaddr from AP nvram since the UTF config might be missing it
					set ::roaming_src_ap_mac [$::roaming_src_ap nvram get macaddr]
				} else {
					# SoftAP
					set ::roaming_src_ap_mac [$::roaming_src_ap macaddr]
				}
				
				set ::roaming_src_ap_mac [string toupper $::roaming_src_ap_mac]
				UTF::Message INFO "" "INFO: src_ap=$::roaming_src_ap with macaddr=$::roaming_src_ap_mac" 

				if {$::roaming_src_ap_mac == ""} {
					UTF::Message ERROR "" "***Failed. ::roaming_src_ap_mac=$::roaming_src_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_src_ap_mac=$::roaming_src_ap_mac. Check config file"
				}

				if {$::soft_ap_flag == 0} {
					# AP - get macaddr from AP nvram since the UTF config might be missing it
					set ::roaming_dst_ap_mac [$::roaming_dst_ap nvram get macaddr]
				} else {
					# SoftAP
					set ::roaming_dst_ap_mac [$::roaming_dst_ap macaddr]
				}
				
				set ::roaming_dst_ap_mac [string toupper $::roaming_dst_ap_mac]
				UTF::Message INFO "" "INFO: dst_ap=$::roaming_dst_ap with macaddr=$::roaming_dst_ap_mac"  

				if {$::roaming_dst_ap_mac == ""} {
					UTF::Message ERROR "" "***Failed. ::roaming_dst_ap_mac=$::roaming_dst_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_dst_ap_mac=$::roaming_dst_ap_mac. Check config file"
				}

				if {$::roaming_src_ap_mac == $::roaming_dst_ap_mac} {
					UTF::Message ERROR "" "***Failed. ::roaming_src_ap_mac=::roaming_dst_ap_mac=$::roaming_src_ap_mac. Check config file"
					incr ::error_cnt
					error "::roaming_src_ap_mac=::roaming_dst_ap_mac=$::roaming_src_ap_mac. Check config file"
				}

				set ::roaming_band [$::roaming_src_ap band $::roaming_channel]
				
				UTF::Message INFO "" "chan=$::roaming_channel band=$::roaming_band cap=$::roaming_cap src_ap=$::roaming_src_ap dst_ap=$::roaming_dst_ap"
				
				if {$(roam_estimate_attn)} {
					UTF::Message LOG "" "*************************** Estimate Smooth Roaming Attn *****************************"

					if {$::roaming_src_ap_attn != "" || $::roaming_dst_ap_attn != "" || $::roaming_sniffer_start_attn != ""} {
						incr ::error_cnt
						error "ERROR: parameters src_ap_attn, dst_ap_attn, and sniffer_start_attn must be blank when using roam_estimate_attn parameter. Halting tests!"
					}

					set catch_resp [catch "p2p::roaming_calculate_attn_values" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}
					
					UTF::Message LOG "" "*********************** Display estimated attenuation vaules ***********************"
					UTF::Message LOG "" "Estimate: Add params -roam_${test_type}\_src_ap\_attn \"$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end\" -roam_${test_type}\_dst_ap\_attn \"$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end\" -roam_${test_type}\_sniffer\_start_attn $::roaming_sniffer_start_attn"
					error "Estimate: Add params -roam_${test_type}\_src_ap\_attn \"$::roaming_src_ap_attn_start\-$::roaming_src_ap_attn_end\" -roam_${test_type}\_dst_ap\_attn \"$::roaming_dst_ap_attn_start\-$::roaming_dst_ap_attn_end\" -roam_${test_type}\_sniffer\_start_attn $::roaming_sniffer_start_attn"					
				} else {
					UTF::Message LOG "" "*************************** Smooth Roaming Test *****************************"
					
					set catch_resp [catch "p2p::get_roaming_macid_values" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}
					
					if {$::error_cnt > 0} {
						UTF::Message ERROR "" "***Failed. Roaming failed."
						error "Roaming failed"
					}
					
					set testnum [p2p::get_testnum]
					set ::roaming_sniffer_file_name "$testnum.sniffer_$test_type\_$tmp_roaming_channel\_smooth_roaming"
					set catch_resp [catch "p2p::roaming_setup_sniffer" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}

					set catch_resp [catch "p2p::process_all_tests" catch_msg]
					if {$catch_resp != 0} {
						UTF::Message ERROR "" "***Failed. $catch_msg"
						incr ::error_cnt
						error $catch_msg
					}

					if {$::roamed_flag == 0} {
						incr ::error_cnt
						error "Did not roam"
					}

					if {$::roaming_sniffer_failed_flag == 1} {
						set ::roaming_sniffer_failed_flag 0
						incr ::error_cnt
						error $::roaming_sniffer_failed_msg
					}
				
					# return the test line with graph link
					return "html: $::roaming_html_results"
				}
			}

			if {![info exists ::streams_name_list]} {
				UTF::Message ERROR "" "***Failed. Roaming test block exited unexpectedly."
				incr ::error_cnt
			}

			if {$::error_cnt == 0 && $(roam_estimate_attn) == 0} {
				p2p::get_roaming_time $test_type
			}

			if {$::error_cnt > 0} {
				p2p::connection_test
			}
		}

		if {!$(roam_estimate_attn) && !$(nofailoverroaming)} {
			UTF::Message LOG "" "*************************** Failover Roaming Test *****************************"
			set ::failover_test_flag 1

			set ::roaming_test_title "$test_type - Failover Roaming"
			
			UTF::Try "$::roaming_test_title" {

				set testnum [p2p::get_testnum]
				set ::roaming_sniffer_file_name "$testnum.sniffer_$test_type\_$tmp_roaming_channel\_failover_roaming"
				p2p::roaming_setup_sniffer
			}
		}
	}
}

#################################################################################

proc p2p::bt_setup {} {
	# access option array
	upvar {} {}

	if {![regexp -nocase {BT:} $(qos_tests)]} {
		# no BT stream to run for the tests
		return
	}

	UTF::Try "BT Setup" {
	
		UTF::Message INFO "" "************************Func:bt_setup***************************"

		set catch_resp [catch "$(bt_root_sta) rexec applebt --listPairedDevices" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		set paired_bt_dev_type ""
		set paired_bt_mac_id ""

		if {$catch_resp == 0} {
			set lines [split $catch_msg "\n"]

			set paired_bt_dev_type ""
			foreach line $lines {
				UTF::Message LOG "" "line='$line'"

				if {[regexp -nocase {.* Name: +?(.*?)} $line match bt_dev_name]} {
					UTF::Message INFO "" "bt_dev_name=$bt_dev_name"
				}
				if {[regexp -nocase {.* Bluetooth device address: +?([0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})} $line match paired_bt_mac_id]} {
					UTF::Message INFO "" "paired_bt_mac_id=$paired_bt_mac_id"
				}
				if {[regexp -nocase {.* Device Type: +?(.*?)} $line match paired_bt_dev_type]} {
					UTF::Message INFO "" "paired_bt_dev_type=$paired_bt_dev_type"
				}

				if {$paired_bt_dev_type == "Loudspeaker"} {
					UTF::Message INFO "" "Found paired speaker $paired_bt_mac_id"

					# BT Speaker Disconnect
					set catch_resp [catch "$(bt_root_sta) rexec applebt --disconnectAll" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep 1				

					# BT off
					set catch_resp [catch "$(bt_root_sta) rexec applebt --setPowerState 0" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					UTF::Sleep 3				

					# BT on
					set catch_resp [catch "$(bt_root_sta) rexec applebt --setPowerState 1" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

					# More than 10 sec delay is needed otherwise BT connect will fail
					UTF::Sleep 15				

					# BT Speaker Connect
					set catch_resp [catch "$(bt_root_sta) rexec applebt --connect $paired_bt_mac_id" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

					# BT Paired Devices
					set catch_resp [catch "$(bt_root_sta) rexec applebt --listPairedDevices" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					
					break
				}
			}
		}
		
		if {$paired_bt_dev_type != "Loudspeaker" || $paired_bt_mac_id == ""} {
			incr ::error_cnt
			error "BT Paired Loudspeaker not Found"			
		}

		UTF::Message LOG "" "Check to make sure BT Speaker is connected"

		# BT Connected Devices
		set catch_resp [catch "$(bt_root_sta) rexec applebt --listConnectedDevices" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"

		set connected_bt_dev_type ""
		set connected_bt_mac_id ""

		if {$catch_resp == 0} {
			set lines [split $catch_msg "\n"]

			set connected_bt_dev_type ""
			foreach line $lines {
				UTF::Message LOG "" "line='$line'"

				if {[regexp -nocase {.* Name: +?(.*?)} $line match bt_dev_name]} {
					UTF::Message INFO "" "bt_dev_name=$bt_dev_name"
				}
				if {[regexp -nocase {.* Bluetooth device address: +?([0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})} $line match connected_bt_mac_id]} {
					UTF::Message INFO "" "connected_bt_mac_id=$connected_bt_mac_id"
				}
				if {[regexp -nocase {.* Device Type: +?(.*?)} $line match connected_bt_dev_type]} {
					UTF::Message INFO "" "connected_bt_dev_type=$connected_bt_dev_type"
				}

				if {$connected_bt_dev_type == "Loudspeaker"} {
					UTF::Message INFO "" "Found connected speaker $connected_bt_mac_id"
					break
				}
			}
		}

		if {$connected_bt_dev_type != "Loudspeaker" || $connected_bt_mac_id == ""} {
			incr ::error_cnt
			error "BT Connected Loudspeaker not Found"			
		}

		if {$paired_bt_mac_id != $connected_bt_mac_id} {
			incr ::error_cnt
			error "BT Paired Loudspeaker $paired_bt_mac_id is not the same as Connected Loudspeaker $connected_bt_mac_id"			
		}
		
		return "BT Loudspeaker $connected_bt_mac_id"
	}
}

proc p2p::bt_itune_stop {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:bt_itune_stop***************************"

	set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	set itune_pid ""
	regexp -nocase {PID:\s+(\S+)} $catch_msg - itune_pid
	if {$itune_pid != ""} {
		set catch_resp [catch "$(bt_root_sta) rexec kill -9 $itune_pid" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	}

	# 3 sec min delay is needed here for iTume process to stop
	UTF::Sleep 4				

	for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_msg == "Inactive audio"} {
			break
		}
		UTF::Sleep 5				
		UTF::Message LOG "" "retry cnt=$retry_cnt - applebt --isActiveAudioDevice"
	}
	
	if {$catch_msg != "Inactive audio"} {
		incr ::error_cnt
		error "Active BT iTune audio"			
	}
	
	return
}

proc p2p::bt_itune_play {} {
	# access option array
	upvar {} {}

	# sometimes the wav file does not start playing, therefore retry is added
	
	for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
	
		p2p::bt_itune_stop

		UTF::Message INFO "" "************************Func:bt_itune_play***************************"

		# playFileIniTunes cannot be run as root and it needs to run as 'user'
		set catch_resp [catch {$(bt_user_sta) rpopen applebt --playFileIniTunes $(bt_wav_file)} catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set timestamp [clock format [clock seconds] -format "%H:%M:%S"]
		UTF::Message INFO "" "------------------------$timestamp---------------------------"
		set fd $catch_msg
		fconfigure $fd -blocking 0
		fileevent $fd readable {set ::p2p_utils_reading READY}

		# 3 sec min delay is needed here for iTume process to come up
		UTF::Sleep 4				

		for {set retry2_cnt 0} {$retry2_cnt < 5} {incr retry2_cnt} {
			set catch_resp2 [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg2]
			UTF::Message LOG "" "catch_resp2=$catch_resp2 catch_msg2=$catch_msg2 retry2_cnt=$retry2_cnt"
			if {$catch_msg2 != "Inactive audio"} {
				break
			}
			UTF::Message LOG "" "ps -ef | grep playFileIniTunes"
			set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
			UTF::Sleep 4
			
			if {$retry2_cnt == 3} {
				p2p::bt_setup
			}
		}

		if {$catch_msg2 == "Inactive audio"} {
			set inactive_audio_flag 1
			continue
		} else {
			set inactive_audio_flag 0
		}

		set catch_resp [catch "$(bt_root_sta) rexec applebt --checkPID iTunes" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		set itune_pid ""
		regexp -nocase {PID:\s+(\S+)} $catch_msg - itune_pid
		if {$itune_pid == ""} {
			incr ::error_cnt
			error "BT iTune PID is not found"			
		}

		UTF::Message LOG "" "ps -ef | grep playFileIniTunes"
		set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
		set catch_resp2 [catch {set fd_pid [pid $fd]} catch_msg2]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg fd_pid=$fd_pid"
		# iTune should be running now. The endpoint fsh command to lunch "rpopen applebt --playFileIniTunes"
		# is not needed to be active, therefore it is killed here
		set catch_resp [catch "exec kill -9 $fd_pid" catch_msg]
		UTF::Message INFO "" "kill catch_msg=$catch_msg"
		UTF::Sleep .1
		set catch_resp [catch "exec ps -ef | grep playFileIniTunes" catch_msg]					
		UTF::Message INFO "" "ps -ef catch_msg=$catch_msg"

		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_msg != "Inactive audio"} {
			set inactive_audio_flag 0
			break
		}
		UTF::Sleep 5				
		set inactive_audio_flag 1
		UTF::Message LOG "" "retry cnt=$retry_cnt - applebt --isActiveAudioDevice"
	}
	
	if {$inactive_audio_flag} {
		UTF::Sleep 5				
		set catch_resp [catch "$(bt_root_sta) rexec applebt --isActiveAudioDevice" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"		
		incr ::error_cnt
		error "Inactive BT iTune audio"			
	}
	
	return 
}

proc p2p::bt_start_throughput_measurement {STA stream_index audio_throughput_time} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:bt_start_throughput_measurement $audio_throughput_time***************************"

	set catch_resp [catch {$STA rpopen applebt --A2DPBitRate $audio_throughput_time} catch_msg]
	UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	set ::array_streams_fd_rx(${stream_index}) $catch_msg
	set ::array_streams_fdname_rx(${stream_index}) "RX_$stream_index"
	fconfigure $::array_streams_fd_rx(${stream_index}) -blocking 0
	fileevent $::array_streams_fd_rx(${stream_index}) readable {set ::p2p_utils_reading READY}

	set ::array_streams_fd_tx(${stream_index}) ""
	set ::array_streams_fdname_tx(${stream_index}) ""
}

#################################################################################

proc p2p::run_wl_cmd {STA cmd} {
	#set catch_resp [catch {$STA wl -i $::array_sta_wlan_ifname(${STA}) $cmd} catch_msg]
	set catch_resp [catch {$STA wl $cmd} catch_msg]
	#UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
	if {$catch_resp == 1} {
		UTF::Message INFO "" "***Fail. $catch_msg"
		incr ::error_cnt
		error $catch_msg
	}
	
	return $catch_msg
}

proc p2p::nan_extra_setup {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan_extra_setup***************************"

	UTF::Try "NAN SW Reload" {

		# unload all STAs first
		UTF::Try "Unload STAs" {
			foreach STA $::list_sta_wlan_objects {
				set catch_resp [catch {$STA rexec rmmod dhd} catch_msg]
			}
			UTF::Sleep 1
		}

		foreach STA $::list_sta_wlan_objects {
			UTF::Try "$STA: reload" {
				set catch_resp [catch {$STA rexec insmod /root/dhd.ko} catch_msg]
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec dhd -i eth0 download /root/rtecdc.bin /root/nvram.txt} catch_msg]
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec ifconfig eth0 up} catch_msg]
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec wl clmload 0 /root/rtecdc.clmb} catch_msg]
				UTF::Sleep 3
				set catch_resp [catch {$STA rexec wl vht_features} catch_msg]
				set catch_resp [catch {$STA rexec wl vht_features 7} catch_msg]
				set catch_resp [catch {$STA rexec wl vht_features} catch_msg]
				set catch_resp [catch {$STA rexec wl bands} catch_msg]
				set catch_resp [catch {$STA rexec wl channels} catch_msg]
				return ""
			}
		}
	}
}

proc p2p::nan_anchor_master_setup {master_sta} {
	# access option array
	upvar {} {}
	upvar base_cluster_id base_cluster_id
	upvar base_mac_address base_mac_address

	UTF::Message INFO "" "************************Func:nan_anchor_master_setup $master_sta***************************"

	set STA $master_sta

	UTF::Try "$STA: NAN Anchor-Master Setup" {
		UTF::Message INFO "" "MASTER: macaddr=$::array_sta_wlan_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 3
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
		set catch_resp [catch {$STA rexec wl up} catch_msg]
		UTF::Sleep 3

		if {$(nan_msch_collect)} {
			set rc [p2p::run_wl_cmd $STA "msch_collect 1"]
		}
		set rc [p2p::run_wl_cmd $STA "nan enable 1"]
		set rc [p2p::run_wl_cmd $STA "nan band auto"]
		set rc [p2p::run_wl_cmd $STA "nan chan 6"]
		set rc [p2p::run_wl_cmd $STA "nan chan 44"]
		set rc [p2p::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [p2p::run_wl_cmd $STA "nan election_metrics master 100"]
		set rc [p2p::run_wl_cmd $STA "nan join -start"]
		UTF::Message INFO "" "10 sec delay is needed for the master start"
		UTF::Sleep 20

		set rc [p2p::run_wl_cmd $STA "nan dump rssi"]
		set rc [p2p::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		# master cluster_id is random value base_cluster_id plus ":00:00"
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set base_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]
		UTF::Message INFO "" "base_cluster_id=$base_cluster_id"
		
		if {$cluster_id != "$base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: anchor-master} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): anchor-master\}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role != "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			incr ::error_cnt
			error "Bad Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check master_rank
		###########################
		# master_rank is STA mac address plus ":xx:xx"
		regexp -nocase {master_rank:.*?\n(.*)\n.*amr:} $rc - master_rank
		UTF::Message INFO "" "master_rank='$master_rank'"
		regexp -nocase {:(.*)} $master_rank - master_rank
		set master_rank [string trim $master_rank]
		regsub -all { } $master_rank ":" master_rank
		set master_rank [string toupper $master_rank]
		# remove the end ":xx:xx"
		set master_rank [string replace $master_rank 17 end ""]
		UTF::Message INFO "" "master_rank=$master_rank"
		set base_mac_address $master_rank
		
		# NAN macaddr starts with 02
		set ::array_sta_p2p_macaddr(${STA}) [string replace $::array_sta_wlan_macaddr(${STA}) 1 1 "2"]

		if {$master_rank != $::array_sta_p2p_macaddr(${STA})} {
			# failed
			UTF::Message INFO "" "master_rank is '$master_rank' instead of '$::array_sta_p2p_macaddr(${STA})'"
			incr ::error_cnt
			error "Bad master_rank"
		}
	}

	if {$::error_cnt > 0} {
		error "html: Halting tests!"
	}
}

proc p2p::nan_non_master_setup {master_sta non_master_sta} {
	# access option array
	upvar {} {}
	upvar base_cluster_id base_cluster_id

	UTF::Message INFO "" "************************Func:nan_non_master_setup $master_sta $non_master_sta***************************"

	set STA $non_master_sta

	UTF::Try "$STA: NAN Non-Master Setup" {
		UTF::Message INFO "" "PEER: macaddr=$::array_sta_wlan_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]

		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 3
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
		set catch_resp [catch {$STA rexec wl up} catch_msg]
		UTF::Sleep 3

		if {$(nan_msch_collect)} {
			set rc [p2p::run_wl_cmd $STA "msch_collect 1"]
		}
		set rc [p2p::run_wl_cmd $STA "nan enable 1"]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set rc [p2p::run_wl_cmd $STA "nan band auto"]
		set rc [p2p::run_wl_cmd $STA "nan chan 6"]
		set rc [p2p::run_wl_cmd $STA "nan chan 44"]
		set rc [p2p::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [p2p::run_wl_cmd $STA "nan election_metrics master 10"]
		set rc [p2p::run_wl_cmd $STA "nan join -start"]
		
		UTF::Message INFO "" "20 sec delay is mandatory to sync with AM"
		UTF::Sleep 20

		set rc [p2p::run_wl_cmd $STA "nan dump rssi"]
		set rc [p2p::run_wl_cmd $STA "nan status"]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set non_master_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]

		if {$base_cluster_id != $non_master_cluster_id} {
			# failed
			UTF::Message INFO "" "Non Master Cluster ID is '$non_master_cluster_id' instead of '$base_cluster_id'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}
		
		if {$cluster_id != "$base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$base_cluster_id:00:00'"
			incr ::error_cnt
			error "Bad Non Master Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: non-master-non-sync} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): non-master-non-sync\}} $role - role
		UTF::Message INFO "" "role=$role"
		if {$role == ""} {
			# Role is not "non-master-non-sync"
			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
		}
		
		# device can take master role 3 if the rssi threshold is hit
		if {$role != "1" && $role != "2" && $role != "3"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role is '$role' instead of '1' for 'non-master-non-sync', '2' for 'non-master-sync',  or '3' for 'master'"
			error "Bad Non Master Role"
		}

		#set rc "> enabled:1\n> inited:1\n> joined:1\n> cluster_id: 50:6f:9a:01:00:00\n> chanspec\[0\]:6 0x1006\n> chanspec\[1\]:44 0xd02c\n> role 4: anchor-master\n> master_rank::\n  0000: 00 10 18 ee e4 2e 00 00 \n> amr:\n  0000: 00 10 18 ee e4 2e 00 00 \n> hop_count:0\n> ambtt:0x0"

		###########################
		# check amr
		###########################
		# amr is STA mac address plus ":xx:xx"
		regexp -nocase {amr:\n(.*)\n.*hop_count:} $rc - amr
		UTF::Message INFO "" "amr='$amr'"
		regexp -nocase {:(.*)} $amr - amr
		set amr [string trim $amr]
		regsub -all { } $amr ":" amr
		set amr [string toupper $amr]
		# remove the end ":xx:xx"
		set amr [string replace $amr 17 end ""]
		UTF::Message INFO "" "amr=$amr"

		if {$amr != $::array_sta_p2p_macaddr(${master_sta})} {
			# failed
			UTF::Message INFO "" "amr is '$amr' instead of '$::array_sta_p2p_macaddr(${master_sta})'"
			error "Bad Non Master amr"
		}

		if {$role == "1"} {
			return "Non-Master-Non-Sync"
		} elseif {$role == "2"} {
			return "Non-Master-Sync"
		} elseif {$role == "3"} {
			return "Master"
		}
	}
}

proc p2p::nan_non_master_cluster_merge {master_sta non_master_sta merge_sta} {
	# access option array
	upvar {} {}
	upvar base_cluster_id base_cluster_id
	upvar base_mac_address base_mac_address

	UTF::Message INFO "" "************************Func:nan_non_master_cluster_merge $master_sta $non_master_sta $merge_sta***************************"

	set STA $merge_sta

	UTF::Try "$STA: NAN Non-Master Cluster Merge" {
		UTF::Message INFO "" "2nd Peer: macaddr=$::array_sta_wlan_macaddr(${STA})"
		set catch_resp [catch {$STA rexec wl cur_etheraddr} catch_msg]
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]
		set catch_resp [catch {$master_sta rexec wl nan clear stats} catch_msg]
		set catch_resp [catch {$non_master_sta rexec wl nan clear stats} catch_msg]
		#UTF::Message INFO "" "Merge STA $STA does not have nan enabled yet, therefore 'wl nan' is not supported yet"
		#set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]

		set catch_resp [catch {$STA rexec wl down} catch_msg]
		UTF::Sleep 3
		set catch_resp [catch {$STA rexec dhd -i eth0 dconpoll 50} catch_msg]
		set catch_resp [catch {$STA rexec dhd -i eth0 version} catch_msg]
		set catch_resp [catch {$STA rexec wl mpc 0} catch_msg]
		set catch_resp [catch {$STA rexec wl PM 0} catch_msg]
		set catch_resp [catch {$STA rexec wl up} catch_msg]
		UTF::Sleep 3

		set rc [p2p::run_wl_cmd $STA "nan enable 1"]
		set rc [p2p::run_wl_cmd $STA "nan band auto"]
		set rc [p2p::run_wl_cmd $STA "nan chan 6"]
		set rc [p2p::run_wl_cmd $STA "nan chan 44"]
		set rc [p2p::run_wl_cmd $STA "nan warm_up_time 10"]
		set rc [p2p::run_wl_cmd $STA "nan election_metrics master 250"]
		set rc [p2p::run_wl_cmd $STA "nan cluster_id $base_cluster_id:00:00"]
		set rc [p2p::run_wl_cmd $STA "nan join $base_cluster_id:00:00 -start"]
		UTF::Message INFO "" "20 sec delay is mandatory for cluster merge"
		UTF::Sleep 20

		p2p::run_wl_cmd $master_sta "nan dump rssi"
		p2p::run_wl_cmd $master_sta "nan status"
		set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
		#
		p2p::run_wl_cmd $non_master_sta "nan dump rssi"
		p2p::run_wl_cmd $non_master_sta "nan status"
		set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
		#
		set rc [p2p::run_wl_cmd $STA "nan dump rssi"]
		set rc [p2p::run_wl_cmd $STA "nan status"]
		set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		###########################
		# check cluster_id
		###########################
		set cluster_id [regexp -inline {cluster_id: [0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $rc]
		UTF::Message INFO "" "cluster_id=$cluster_id"
		regexp -nocase {\{cluster_id: (\S+)\}} $cluster_id - cluster_id
		UTF::Message INFO "" "cluster_id=$cluster_id"
		set tmp_base_cluster_id [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $cluster_id]

		if {$base_cluster_id != $tmp_base_cluster_id} {
			# failed
			UTF::Message INFO "" "Base Cluster ID is '$tmp_base_cluster_id' instead of '$base_cluster_id'"
			error "Bad Base Cluster ID"
		}
		
		if {$cluster_id != "$base_cluster_id:00:00"} {
			# failed
			UTF::Message INFO "" "Cluster ID is '$cluster_id' instead of '$base_cluster_id:00:00'"
			error "Bad Cluster ID"
		}

		###########################
		# check role
		###########################
		set role [regexp -inline {role [0-9]: anchor-master} $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): anchor-master\}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role != "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			set role [regexp -inline {role [0-9]:} $rc]
			regexp -nocase {\{role (\d+):\}} $role - role
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			error "Bad Role"
		}

		###########################
		# check master_rank
		###########################
		# master_rank is STA mac address plus ":xx:xx"
		regexp -nocase {master_rank:.*?\n(.*)\n.*amr:} $rc - master_rank
		UTF::Message INFO "" "master_rank='$master_rank'"
		regexp -nocase {:(.*)} $master_rank - master_rank
		set master_rank [string trim $master_rank]
		regsub -all { } $master_rank ":" master_rank
		set master_rank [string toupper $master_rank]
		# remove the end ":xx:xx"
		set master_rank [string replace $master_rank 17 end ""]
		UTF::Message INFO "" "master_rank=$master_rank"
		set base_mac_address $master_rank

		if {$master_rank != $::array_sta_p2p_macaddr(${STA})} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "master_rank is '$master_rank' instead of '$::array_sta_p2p_macaddr(${STA})'"
			error "Bad master_rank"
		}
		
		UTF::Message INFO "" "========================================Check Master ($master_sta) role========================================"
		set rc [p2p::run_wl_cmd $master_sta "nan status"]
		set role [regexp -inline {role [0-9]: } $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): \}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role == "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role for Master ($master_sta) cannot be '4' (anchor-master)"
			error "Bad Role"
		}

		UTF::Message INFO "" "========================================Check Non Master ($non_master_sta) role========================================"
		set rc [p2p::run_wl_cmd $non_master_sta "nan status"]
		set role [regexp -inline {role [0-9]: } $rc]
		UTF::Message INFO "" "role=$role"
		regexp -nocase {\{role (\d+): \}} $role - role
		UTF::Message INFO "" "role=$role"

		if {$role == "4"} {
			# failed
			UTF::Message LOG "" "-------------------------------------DEBUG Start--------------------------------------------------"
			set catch_resp [catch {$master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$non_master_sta rexec wl nan dump stats} catch_msg]
			set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
			UTF::Message LOG "" "-------------------------------------DEBUG End----------------------------------------------------"

			UTF::Message INFO "" "Role for Non Master ($non_master_sta) cannot be '4' (anchor-master)"
			error "Bad Role"
		}		
	}
}

proc p2p::nan_publish_and_subscribe {master_sta non_master_sta sta_subscribe sta_publish} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan_publish_and_subscribe***************************"

	UTF::Try "NAN Publish and Subscribe" {
		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta

		set rc [p2p::run_wl_cmd $sta_publish "nan publish 1 name org.wifi.nan.test flags 0x1000"]
		UTF::Sleep 3
		set rc [p2p::run_wl_cmd $sta_subscribe "nan subscribe 1 name org.wifi.nan.test"]
		UTF::Sleep 20

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$sta_publish rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$sta_subscribe rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		set rc [p2p::run_wl_cmd $sta_publish "nan publish 1"]
		###########################
		# get publisher instance id
		###########################
		set publisher_instance_id ""
		regexp -nocase {Instance ID:(.*?)\n} $rc - publisher_instance_id
		set publisher_instance_id [string trim $publisher_instance_id]
		UTF::Message INFO "" "publisher_instance_id='$publisher_instance_id'"
		###########################
		# get publisher service hash
		###########################
		set publisher_service_hash ""
		regexp -nocase {Service hash:\n(.*?)\n} $rc - publisher_service_hash
		regsub {0000:} $publisher_service_hash {} publisher_service_hash
		set publisher_service_hash [string trim $publisher_service_hash]
		UTF::Message INFO "" "publisher_service_hash='$publisher_service_hash'"

#kevin - temp calls
set rc [p2p::run_wl_cmd $sta_subscribe "nan publish_list"]
set rc [p2p::run_wl_cmd $sta_subscribe "nan subscribe_list"]
return
		set rc [p2p::run_wl_cmd $sta_subscribe "nan disc_results"]

		#set rc "Disc results:\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\ninstance id: 0x1\npeer instance id: 0x1\nService hash:\n  0000: 24 12 01 08 12 06\npeer mac: 00:10:18:ee:e4:2a\n"

		###########################
		# check subscriber instance id
		###########################
		set subscriber_instance_id ""
		regexp -nocase {instance id: (.*?)\npeer} $rc - subscriber_instance_id
		set subscriber_instance_id [string trim $subscriber_instance_id]
		UTF::Message INFO "" "subscriber_instance_id='$subscriber_instance_id'"

		set catch_resp [catch {$sta_publish rexec wl nan status} catch_msg]
		set catch_resp [catch {$sta_subscribe rexec wl nan status} catch_msg]
		set catch_resp [catch {$sta_publish rexec wl nan dump stats} catch_msg]
		set catch_resp [catch {$sta_subscribe rexec wl nan dump stats} catch_msg]

		if {$subscriber_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "subscriber instance id is '$subscriber_instance_id' instead of '0x1'"
			error "Bad subscriber instance id"
		}

		if {$publisher_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "publisher instance id is '$publisher_instance_id' instead of '0x1'"
			error "Bad publisher instance id"
		}
		
		###########################
		# check subscriber peer instance id
		###########################
		set subscriber_peer_instance_id ""
		regexp -nocase {peer instance id: (.*?)\nService hash} $rc - subscriber_peer_instance_id
		set subscriber_peer_instance_id [string trim $subscriber_peer_instance_id]
		UTF::Message INFO "" "subscriber_peer_instance_id='$subscriber_peer_instance_id'"

		if {$subscriber_peer_instance_id != "0x1"} {
			# failed
			UTF::Message INFO "" "subscriber peer instance id is '$subscriber_peer_instance_id' instead of '0x1'"
			error "Bad subscriber peer instance id"
		}

		###########################
		# check subscriber service hash
		###########################
		set subscriber_service_hash ""
		regexp -nocase {Service hash:\n (.*?)\n} $rc - subscriber_service_hash
		regsub {0000:} $subscriber_service_hash {} subscriber_service_hash
		set subscriber_service_hash [string trim $subscriber_service_hash]
		UTF::Message INFO "" "subscriber_service_hash='$subscriber_service_hash'"

		if {$subscriber_service_hash != $publisher_service_hash} {
			# failed
			UTF::Message INFO "" "Subscriber service hash is '$subscriber_service_hash' instead of '$publisher_service_hash'"
			error "Bad subscriber service hash"
		}
		
		###########################
		# check subscriber peer mac
		###########################
		set subscriber_peer_mac ""
		# peer mac is STA mac address of STA publish ($sta_publish in this case)
		regexp -nocase {.*peer mac: (.*)\n} $rc - subscriber_peer_mac
		set subscriber_peer_mac [string trim $subscriber_peer_mac]
		set subscriber_peer_mac [string toupper $subscriber_peer_mac]
		UTF::Message INFO "" "subscriber_peer_mac='$subscriber_peer_mac'"

		if {$subscriber_peer_mac != $::array_sta_wlan_macaddr(${sta_publish})} {
			# failed
			UTF::Message INFO "" "Subscriber peer mac address is '$subscriber_peer_mac' instead of '$::array_sta_wlan_macaddr(${sta_publish})'"
			error "Bad subscriber peer mac address"
		}
	}
}

proc p2p::nan_check_dwskips_value {msg expected_dwskips_value} {

	if {$expected_dwskips_value == 0} {
		UTF::Message INFO "" "========================check dwskips is 0==========================="
	} else {
		UTF::Message INFO "" "========================check dwskips is less than $expected_dwskips_value==========================="
	}

	set dwskips_value [p2p::nan_get_dwskips $msg]

	if {$expected_dwskips_value == 0 && $dwskips_value > 0} {
		# failed
		UTF::Message ERROR "" "dwskips is $dwskips_value instead of 0"
		error "dwskips is not zero"
	}

	if {$dwskips_value > $expected_dwskips_value} {
		# failed
		UTF::Message ERROR "" "dwskips $dwskips_value is more than $expected_dwskips_value"
		error "dwskips is high $dwskips_value"
	}
}

proc p2p::nan_sta_infra_scan {STA sta_role_anchor_master_flag} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan_sta_infra_scan $STA $sta_role_anchor_master_flag***************************"

	if {$sta_role_anchor_master_flag} {
		set role_name "Anchor-Master"
	} else {
		set role_name "Non-Master"
	}

	UTF::Try "NAN $role_name STA Infra Scan" {

		if {$::wlan_ap == ""} {
			# failed
			incr ::error_cnt
			error "No AP found"
		}

		set catch_resp [catch "$::wlan_ap wl ssid" ap_ssid]
		set catch_resp [catch "$::wlan_ap wl bssid" ap_bssid]
		set ap_bssid [string toupper $ap_bssid]
		UTF::Message INFO "" "ap_ssid='$ap_ssid'"
		UTF::Message INFO "" "ap_bssid='$ap_bssid'"
		
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		
		# retry is needed for "wl scan" since sometimes it give "Not Ready"
		for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
			set catch_resp [catch {$STA rexec wl scan} catch_msg]
			if {$catch_resp == 0} {
				break
			} else {
				# scan failed
				UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
				UTF::Sleep 3
			}
		}

		if {$catch_resp != 0} {
			UTF::Message ERROR "" "***Failed. Scan Failed. $catch_msg."
			error "Scan Failed. $catch_msg"
		}
		
		UTF::Sleep 12
		set catch_resp [catch {$STA rexec wl scanresults} catch_msg]
		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl scanresults | grep SSID} sta_scan_ssid]
		set all_sta_ssids [split $sta_scan_ssid "\n"]
		UTF::Message INFO "" "all_sta_ssids='$all_sta_ssids'"

		set pass_ssid_flag 0
		foreach sta_ssid $all_sta_ssids {
			regexp {SSID: \"(\S+)\"} $sta_ssid match sta_ssid
			if {$sta_ssid == $ap_ssid} {
				UTF::Message INFO "" "sta_ssid $sta_ssid = ap_ssid $ap_ssid"
				set pass_ssid_flag 1
				break
			}
		}

		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl scanresults | grep BSSID} sta_scan_bssid]
		set all_sta_bssids [split $sta_scan_bssid "\n"]
		UTF::Message INFO "" "all_sta_bssids='$all_sta_bssids'"

		set pass_bssid_flag 0
		foreach sta_bssid $all_sta_bssids {
			set sta_bssid [regexp -inline {[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}} $sta_bssid]
			set sta_bssid [string toupper $sta_bssid]
			if {$sta_bssid == $ap_bssid} {
				UTF::Message INFO "" "sta_bssid $sta_bssid = ap_bssid $ap_bssid"
				set pass_bssid_flag 1
				break
			}
		}

		UTF::Message INFO "" "************************"

		set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]
		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set catch_resp [catch {$STA rexec wl scan DUMMY} catch_msg]
		set catch_resp [catch {$STA rexec wl nan dump stats} catch_msg]

		if {$pass_ssid_flag == 0 || $pass_bssid_flag == 0} {
			# failed
			UTF::Message ERROR "" "AP SSID $ap_ssid $ap_bssid did not match any STA scan SSID"
			error "Scan Failed"
		}
		
		set msg_dump_status [p2p::run_wl_cmd $STA "nan status"]		
		p2p::nan_check_role $msg_dump_status $sta_role_anchor_master_flag
		set catch_resp [catch {$STA rexec wl nan dump stats} msg_dump_stats]
		p2p::nan_check_dwskips_value $msg_dump_stats 0
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	}	
}

proc p2p::nan_sta_infra_assoc {STA sta_role_anchor_master_flag ap_chan} {
	# access option array
	upvar {} {}

	if {$sta_role_anchor_master_flag} {
		set role_name "Anchor-Master"
	} else {
		set role_name "Non-Master"
	}
	
	UTF::Try "NAN $role_name + STA $STA Assoc Infra chan $ap_chan" {
		UTF::Message INFO "" "************************Func:nan_sta_infra_assoc $STA $sta_role_anchor_master_flag $ap_chan***************************"

		set catch_resp [catch {$STA rexec wl nan clear stats} catch_msg]
		set ::wlan_chan $ap_chan
		p2p::setup_ap_radio_channel $(ap) $::wlan_chan
		UTF::Message INFO "" "\n\nIf ConnectAPSTA fails with wpa_state=SCANNING instead of wpa_state=ASSOCIATING, it means the STA does not see the AP and it is a NAN FW issue\n\n"
		set catch_resp [catch "UTF::Test::ConnectAPSTA $::wlan_ap $STA" catch_msg]
		UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		if {$catch_resp != 0} {
			error $catch_msg
		}
		
		UTF::Message INFO "" "20 sec delay after assoc is mandatory to sync with AM"
		UTF::Sleep 20

		nan_check_sta_infra_assoc_chan $STA $::wlan_chan

		set msg_dump_status [p2p::run_wl_cmd $STA "nan status"]		
		p2p::nan_check_role $msg_dump_status $sta_role_anchor_master_flag
		set catch_resp [catch {$STA rexec wl nan dump stats} msg_dump_stats]
		p2p::nan_check_dwskips_value $msg_dump_stats 20
	}
	
	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Asoc" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	}	
}

proc p2p::nan_get_dwskips {msg} {
	#set rc "DWSlots: 262 	DiscBcnSlots: 944	AnchorMasterRecExp: 0	BcnTpltUpd: 14\nBcnTx : 1206	SyncBcnTx: 262	DiscBcnTx: 944	BcnRx: 16	SDFTx: 0	SDFRx: 0\nAnchorMaster: 1	Master: 0	NonMasterSync: 0	NonMasterNonSync: 0\nUnschTx: 0	BcnTxErr: 0	SyncBcnTxMiss: 0	SyncBcnTxtimeErr: 0\nMschRegErr: 0	WrongChCB: 0	DWEarlyCB: 128	DWLateCB: 0	DWSkips: 19	DiscBcnSkips: 494\nMrgScan: 10	MrgScanRej: 9	JoinScanRej: 0	ScanRes: 0	NanEnab: 1	NanDisab: 0\n"
	set dwskips_value [regexp -inline {DWSkips:\s+(\d+)\s+DiscBcnSkips} $msg]
	UTF::Message INFO "" "dwskips_value=$dwskips_value"
	regexp -nocase {\{DWSkips:\s+(\d+)\s+DiscBcnSkips\}} $dwskips_value - dwskips_value
	UTF::Message INFO "" "dwskips_value=$dwskips_value"
	return $dwskips_value
}

proc p2p::nan_check_role {msg sta_role_anchor_master_flag} {

	set role_failed_flag 0

	set role [regexp -inline {role [0-9]:} $msg]
	regexp -nocase {\{role (\d+):\}} $role - role

	if {$sta_role_anchor_master_flag} {
		if {$role != 4} {
			set role_failed_flag 1
		}
	} else {
		if {$role != "1" && $role != "2" && $role != "3"} {
			set role_failed_flag 1
		}
	}

	UTF::Message INFO "" "role=$role"

	if {$role_failed_flag} {
		# failed
		if {$sta_role_anchor_master_flag} {
			UTF::Message INFO "" "Role is '$role' instead of '4' for anchor-master"
			error "Bad Anchor-Master Role"
		} else {
			UTF::Message INFO "" "Role is '$role' instead of '1' for 'non-master-non-sync', '2' for 'non-master-sync',  or '3' for 'master'"
			error "Bad Non Master Role"
		}
	} else {
		return 0
	}
}

proc p2p::nan_check_amr {msg amr_val} {
	# amr is STA mac address plus ":xx:xx"
	set amr ""
	regexp -nocase {amr:\n(.*)\n.*hop_count:} $msg - amr
	if {$amr == ""} {
		UTF::Message INFO "kevin" "msg='$msg'"
	}
	UTF::Message INFO "" "amr='$amr'"
	regexp -nocase {:(.*)} $amr - amr
	set amr [string trim $amr]
	regsub -all { } $amr ":" amr
	set amr [string toupper $amr]
	# remove the end ":xx:xx"
	set amr [string replace $amr 17 end ""]
	UTF::Message INFO "" "amr=$amr"

	if {$amr != $amr_val} {
		# failed
		UTF::Message INFO "" "amr is '$amr' instead of '$amr_val'"
		error "Bad amr"
	} else {
		return 0
	}
}

proc p2p::nan_check_sta_infra_assoc_chan {sta sta_expected_chan} {
	set catch_resp [catch {$sta wl status} catch_msg]
	set sta_chan ""
	regexp {Channel: (\S+)} $catch_msg match sta_chan
	UTF::Message INFO "" "sta_chan=$sta_chan"
	if {$sta_expected_chan != $sta_chan} {
		UTF::Message ERROR "" "***Fail. $::wlan_display_str chan is $sta_chan instead of $sta_expected_chan."
		error "Bad STA Channel"
	} else {
		return 0
	}
}

proc p2p::nan_cluster_merge {master_sta non_master_sta merge_sta} {
	# access option array
	upvar {} {}
	upvar base_cluster_id base_cluster_id
	upvar base_mac_address base_mac_address

	UTF::Try "NAN Cluster Merge" {
		UTF::Message INFO "" "************************Func:nan_cluster_merge***************************"

		# 3 STAs needed
		set nan_sta_cnt [llength $::list_sta_wlan_objects]
		if {$nan_sta_cnt != 3} {
			UTF::Message INFO "" "NAN Cluster Merge requires 3 STAs instead of '$::list_sta_wlan_objects'"
			error "NAN Cluster Merge requires 3 STAs instead of '$::list_sta_wlan_objects'" 
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_non_master_cluster_merge $master_sta $non_master_sta $merge_sta
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		error "Halting tests!"
	}
}

proc p2p::nan_infra_scan {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN Infra Scan" {
		UTF::Message INFO "" "************************Func:nan_infra_scan***************************"

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_scan $master_sta 1
		p2p::nan_sta_infra_scan $non_master_sta 0
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	}	
}

proc p2p::nan_infra_assoc {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra" {
		UTF::Message INFO "" "************************Func:nan_infra_assoc***************************"

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $master_sta 1 6
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $master_sta 1 11
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $master_sta 1 44
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $master_sta 1 36
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $non_master_sta 0 6
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $non_master_sta 0 11
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $non_master_sta 0 44
		UTF::Try "Check AM $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $non_master_sta 0 36
		UTF::Try "Check AM $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	#if {$::error_cnt > 0} {
	#	error "Halting tests!"
	#}	
}

proc p2p::nan_sta_infra_assoc_ping_scan {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Ping Scan" {
		UTF::Message INFO "" "************************Func:nan_sta_infra_assoc_ping_scan***************************"

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta

		p2p::nan_sta_infra_assoc $master_sta 1 44
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
		p2p::nan_sta_infra_assoc $non_master_sta 0 11
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}

		catch {unset array_ping_pid}
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Start STA $STA Ping------------------------"
			UTF::Message INFO "" "$STA rpopen ping $::tg_wlan_ip"  
			set fd_tx [$STA rpopen ping $::tg_wlan_ip]
			set catch_resp [catch {set array_ping_pid(${STA}) [pid $fd_tx]} catch_msg]
			fconfigure $fd_tx -blocking 0
			fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		}

		p2p::nan_sta_infra_scan $master_sta 1
		p2p::nan_sta_infra_scan $non_master_sta 0

		# validate Role
		set msg_master_status [p2p::run_wl_cmd $master_sta "nan status"]		
		set msg_non_master_status [p2p::run_wl_cmd $non_master_sta "nan status"]
		p2p::nan_check_role $msg_master_status 1
		p2p::nan_check_role $msg_non_master_status 0
		# validate AMR
		p2p::nan_check_amr $msg_non_master_status $::array_sta_p2p_macaddr(${master_sta})
		
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Stop STA $STA Ping------------------------"
			UTF::Message INFO "" "exec kill -9 $array_ping_pid(${STA})"  
			set catch_resp [catch "exec kill -9 $array_ping_pid(${STA})" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		}
		catch {unset array_ping_pid}
		
		return ""
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	} else {
		return ""
	}
}

proc p2p::nan_infra_assoc_roam {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Roam" {
		UTF::Message INFO "" "************************Func:nan_infra_assoc_roam***************************"

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta

		p2p::nan_sta_infra_assoc $master_sta 1 11
		p2p::nan_sta_infra_assoc $non_master_sta 0 11
		
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}

		# change the AP channel
		set ::wlan_chan 1
		p2p::setup_ap_radio_channel $(ap) $::wlan_chan
		UTF::Sleep 5
		
		UTF::Try "Validate STA Channel $::wlan_chan" {
			nan_check_sta_infra_assoc_chan $master_sta $::wlan_chan
			nan_check_sta_infra_assoc_chan $non_master_sta $::wlan_chan
		}
		
		UTF::Try "Check Master $master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 1
			return ""
		}
		UTF::Try "Check Non-Master $non_master_sta Role" {
			set msg_dump_status [p2p::run_wl_cmd $non_master_sta "nan status"]		
			p2p::nan_check_role $msg_dump_status 0
			return ""
		}
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	}	
}

proc p2p::nan_sta_infra_assoc_role_change {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Try "NAN + STA Assoc Infra Role Change" {
		UTF::Message INFO "" "************************Func:nan_sta_infra_assoc_role_change***************************"

		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta

		p2p::nan_sta_infra_assoc $master_sta 1 44
		p2p::nan_sta_infra_assoc $non_master_sta 0 44
		
		catch {unset array_ping_pid}
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Start STA $STA Ping------------------------"
			UTF::Message INFO "" "$STA rpopen ping $::tg_wlan_ip"  
			set fd_tx [$STA rpopen ping $::tg_wlan_ip]
			set catch_resp [catch {set array_ping_pid(${STA}) [pid $fd_tx]} catch_msg]
			fconfigure $fd_tx -blocking 0
			fileevent $fd_tx readable {set ::p2p_utils_reading READY}
		}

		p2p::nan_sta_infra_scan $master_sta 1
		p2p::nan_sta_infra_scan $non_master_sta 0

		# validate Role
		set msg_master_status [p2p::run_wl_cmd $master_sta "nan status"]		
		set msg_non_master_status [p2p::run_wl_cmd $non_master_sta "nan status"]
		p2p::nan_check_role $msg_master_status 1
		p2p::nan_check_role $msg_non_master_status 0
		# validate AMR
		p2p::nan_check_amr $msg_non_master_status $::array_sta_p2p_macaddr(${master_sta})
		
		UTF::Message INFO "" "change role: non-master to master"
		set rc [p2p::run_wl_cmd $non_master_sta "nan election_metrics master 127"]
		UTF::Message INFO "" "20 sec delay is mandatory to sync"
		UTF::Sleep 20

		set rc [p2p::run_wl_cmd $master_sta "nan dump rssi"]
		set rc [p2p::run_wl_cmd $non_master_sta "nan dump rssi"]

		# validate Role
		set msg_master_status [p2p::run_wl_cmd $non_master_sta "nan status"]
		set msg_non_master_status [p2p::run_wl_cmd $master_sta "nan status"]
		p2p::nan_check_role $msg_master_status 1
		p2p::nan_check_role $msg_non_master_status 0
		
#kevin fix		
		# validate AMR
		p2p::nan_check_amr $msg_non_master_status $::array_sta_p2p_macaddr(${master_sta})
		
		
		
		foreach STA "$master_sta $non_master_sta" {
			UTF::Message INFO "" "------------------------Stop STA $STA Ping------------------------"
			UTF::Message INFO "" "exec kill -9 $array_ping_pid(${STA})"  
			set catch_resp [catch "exec kill -9 $array_ping_pid(${STA})" catch_msg]
			UTF::Message INFO "" "catch_resp=$catch_resp catch_msg=$catch_msg"
		}
		catch {unset array_ping_pid}
		
		return ""
	}

	# check for panic, trap, assert message
	if {[info exists ::UTF::panic]} {
		set ::panic_msg "($::UTF::panic)"
		UTF::Message INFO "NAN_Scan" "::UTF::panic=$::panic_msg"
		incr ::error_cnt
	}
	
	if {$::error_cnt > 0} {
		error "Halting tests!"
	} else {
		return ""
	}
}

proc p2p::nan_setup_again {master_sta non_master_sta} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:nan_setup_again***************************"

	UTF::Try "NAN Setup Again" {
		p2p::nan_extra_setup
		p2p::nan_anchor_master_setup $master_sta
		p2p::nan_non_master_setup $master_sta $non_master_sta
	}
}

proc p2p::run_nan_test {} {
	# access option array
	upvar {} {}
	set base_cluster_id ""
	set base_mac_address ""

	UTF::Message INFO "" "************************Func:run_nan_test***************************"

	set STA1 [lindex $::list_sta_wlan_objects 0]
	set STA2 [lindex $::list_sta_wlan_objects 1]
	set STA3 [lindex $::list_sta_wlan_objects 2]

	# NAN macaddr starts with 02
	set ::array_sta_p2p_macaddr(${STA1}) [string replace $::array_sta_wlan_macaddr(${STA1}) 1 1 "2"]
	set ::array_sta_p2p_macaddr(${STA2}) [string replace $::array_sta_wlan_macaddr(${STA2}) 1 1 "2"]
	if {$STA3 != ""} {
		set ::array_sta_p2p_macaddr(${STA3}) [string replace $::array_sta_wlan_macaddr(${STA3}) 1 1 "2"]
	}

	set rc [p2p::nan_cluster_merge $STA1 $STA2 $STA3]
	set rc [p2p::nan_publish_and_subscribe $STA1 $STA2 $STA1 $STA2]
	UTF::Message INFO "" "3************************rc='$rc' ::error_cnt='$::error_cnt'***************************"
	set ::error_cnt 0
	set rc [p2p::nan_infra_scan $STA1 $STA2]
	UTF::Message INFO "" "4************************rc='$rc' ::error_cnt='$::error_cnt'***************************"
	set rc [p2p::nan_infra_assoc $STA1 $STA2]
	set rc [p2p::nan_sta_infra_assoc_ping_scan $STA1 $STA2]
	set rc [p2p::nan_infra_assoc_roam $STA1 $STA2]
	set rc [p2p::nan_sta_infra_assoc_role_change $STA1 $STA2]
}

proc p2p::run_aibss_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_aibss_test***************************"

	#####################################################################################################################

	foreach STA $::list_sta_wlan_objects {	

		UTF::Try "$STA: AIBSS Setup Chan $::wlan_chan" {
			UTF::Message INFO "" "macaddr=$::array_sta_wlan_macaddr(${STA})"
			UTF::Message INFO "" "WLAN ipaddr=$::array_sta_wlan_ip(${STA})"
			set catch_resp [catch {$STA rexec dmesg -C} catch_msg]
			set rc [p2p::run_wl_cmd $STA "down"]
			UTF::Sleep .5
			set rc [p2p::run_wl_cmd $STA "aibss 1"]
			UTF::Sleep .5
			set rc [p2p::run_wl_cmd $STA "PM $(pm_mode)"]
			set rc [p2p::run_wl_cmd $STA "atim 10"]
			set rc [p2p::run_wl_cmd $STA "aibss_ps 1"]
			set rc [p2p::run_wl_cmd $STA "chanspec $::wlan_chan"]
			set rc [p2p::run_wl_cmd $STA "aibss_bcn_force_config 500,5000,5000"]
			set rc [p2p::run_wl_cmd $STA "scansuppress 0"]
			set rc [p2p::run_wl_cmd $STA "up"]
			UTF::Sleep 1
			set desired_bssid [string replace $::array_sta_wlan_macaddr(${STA}) 0 1 "02"]
			set rc [p2p::run_wl_cmd $STA "desired_bssid $desired_bssid"]
			set rc [p2p::run_wl_cmd $STA "join UTFOxygenSetup imode ibss"]
			UTF::Sleep 1
			$STA rexec ifconfig $::array_sta_wlan_ifname(${STA}) $::array_sta_wlan_ip(${STA}) up
			UTF::Sleep 1

			UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
			set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
			UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

			# Note after loading firmware and executing aibss activation commands DUT will not go to sleep for 25 sec (by design)
			UTF::Sleep 25

			set rc1 [p2p::run_wl_cmd $STA "pm_dur"]
			UTF::Sleep 2
			set rc2 [p2p::run_wl_cmd $STA "pm_dur"]
			regexp -nocase {([\.\d]+)\s*} $rc1 - rc1
			regexp -nocase {([\.\d]+)\s*} $rc2 - rc2

			set ps_sleep_duration [expr $rc2 - $rc1]
			UTF::Message LOG "" "ps_sleep_duration=$ps_sleep_duration ms"

			set ::chanspec_wlan ""
			UTF::Message INFO "" "E - cleared ::chanspec_wlan"

			# Confirm STA chanspec
			set temp [$STA wl -i $::array_sta_wlan_ifname(${STA}) chanspec]
			regexp {(\S+) } $temp match joined_chan

			if {$::wlan_chan != $joined_chan} {
				incr ::error_cnt
				UTF::Message INFO "" "::error_cnt=$::error_cnt"
				error "AIBSS joined chan is $joined_chan instead of $::wlan_chan" 
			}

			set ::chanspec_wlan $joined_chan
			UTF::Message INFO "" "F - ::chanspec_wlan=$::chanspec_wlan"

			set ::array_sta_wlan_active_flag(${STA}) 1
			set ::array_sta_wlan_disassociated_flag(${STA}) 0

			###########################
			# check PS sleep duration at the end since we want to continue the test
			###########################
			if {$ps_sleep_duration < 1300 && $(pm_mode) == 1} {
				# failed
				UTF::Message INFO "" "PS sleep duration '$ps_sleep_duration' is lower than 1.5 sec"
				error "Low PS sleep duration"
			}
			
			return ""
		}
	}	
}

proc p2p::run_11mc_test {} {
	# access option array
	upvar {} {}

	UTF::Message INFO "" "************************Func:run_11mc_test***************************"

	UTF::Try "11mc AP-STA Test" {

		UTF::Message INFO "" "================================================================="
		# 1st STA is the Target (AP)
		set AP [lindex $::list_sta_wlan_objects 0]
		UTF::Message INFO "" "Target (AP) $AP"

		set rc [p2p::run_wl_cmd $AP "country US/0"]
		UTF::Sleep 1				
		set rc [p2p::run_wl_cmd $AP "ap 1"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $AP "vht_features 3"]
		UTF::Sleep 1				
		set rc [p2p::run_wl_cmd $AP "chanspec $(ap_chan)"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $AP "up"]
		UTF::Sleep 1
		$AP rexec ifconfig $::array_sta_wlan_ifname(${AP}) $::array_sta_wlan_ip(${AP}) up
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $AP "ssid ssid_11mc"]
		UTF::Sleep 1
		set catch_resp [catch {$AP rexec dmesg -C} catch_msg]
		set rc [p2p::run_wl_cmd $AP "proxd ftm enable"]
		UTF::Sleep 1
		set catch_resp [catch {$AP rexec dhd -i eth0 dconpoll 1} catch_msg]
		UTF::Sleep 1
		$AP rexec ifconfig
		set rc [p2p::run_wl_cmd $AP "assoc"]
		set ap_bssid [p2p::run_wl_cmd $AP "bssid"]
		set ap_bssid [string toupper $ap_bssid]
		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$AP rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

		UTF::Message INFO "" "================================================================="
		# 2nd STA is the Initiator (STA)
		set STA [lindex $::list_sta_wlan_objects 1]
		UTF::Message INFO "" "Initiator (STA) Setup"

		set rc [p2p::run_wl_cmd $STA "up"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $STA "mpc 0"]
		UTF::Sleep 1
		set rc [p2p::run_wl_cmd $STA "chanspec $(ap_chan)"]
		UTF::Sleep 1
		$STA rexec ifconfig $::array_sta_wlan_ifname(${STA}) $::array_sta_wlan_ip(${STA}) up
		UTF::Sleep 1
		set catch_resp [catch {$STA rexec dmesg -C} catch_msg]
		set rc [p2p::run_wl_cmd $STA "proxd ftm enable"]
		UTF::Sleep 1
		$STA rexec ifconfig

		set avg_dist_list ""

		for {set loop_cnt 1} {$loop_cnt <= 10} {incr loop_cnt} {
			UTF::Message INFO "" "========================================loop_cnt=$loop_cnt========================================"
			set error_flag 0

			set catch_resp [catch {p2p::run_wl_cmd $STA "proxd ftm 1 delete"} catch_msg]
			UTF::Sleep 1
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 config options +initiator"]
			UTF::Sleep 1
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 config chanspec $(ap_chan)"]
			UTF::Sleep 1
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 config peer $ap_bssid"]
			UTF::Sleep 1
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 info"]
			UTF::Sleep 1
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 start"]
			UTF::Sleep 3
			set rc [p2p::run_wl_cmd $STA "proxd ftm 1 result"]

			#set rc "> rtt result:\n>	sessionId=1, flags=0x0008\(''\), peer=00:10:18:EE:E7:FC\n>	session state=9\(ended\), status=0\(OK\)\n>	burst_duration: 10525us\n>	avg_dist=8.6875m, burst_num=1, valid_measure_cnt=5 num_ftm=6\n>	avg_rtt sample: rssi=-48 rtt=33894ns std_deviation =9.9 ratespec=0x02030010\n"

			set status [regexp -inline {status=[-+]?\d+.*burst_duration} $rc]
			UTF::Message INFO "" "status=$status"
			regexp -nocase {\{status=([-+]?\d+).*burst_duration\}} $status - status
			UTF::Message INFO "" "status=$status"

			if {$status != "0"} {
				# failed
				set status [regexp -inline {status=[-+]?\d+} $rc]
				regexp -nocase {\{status=([-+]?\d+)\}} $status - status
				UTF::Message INFO "" "Status is '$status' instead of '0'"
#				incr ::error_cnt
#				error "Bad Status"
				set error_flag 1
			}

			set avg_dist [regexp -inline {avg_dist=[-+]?[0-9]*\.?[0-9]+m, burst_num} $rc]
			UTF::Message INFO "" "avg_dist=$avg_dist"
			regexp -nocase {\{avg_dist=([-+]?[0-9]*\.?[0-9]+)m, burst_num\}} $avg_dist - avg_dist
			UTF::Message INFO "" "avg_dist=$avg_dist"

			if {$avg_dist < 0 || $avg_dist > 10} {
				# failed
				set status [regexp -inline {status=[0-9]} $rc]
				regexp -nocase {\{status=(\d+)\}} $status - status
				UTF::Message INFO "" "Average Distance '$avg_dist' is not between 0 to 10 meter"
#				incr ::error_cnt
#				error "Bad Average Distance"
				set error_flag 1
			}

			if {$error_flag == 0} {
				lappend avg_dist_list $avg_dist
			}
			
			UTF::Sleep 5
		}

		UTF::Message INFO "" "=================================================================================================="

		UTF::Message LOG "" "begin111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
		set catch_resp [catch {$STA rexec dmesg -T} catch_msg]
		UTF::Message LOG "" "end11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
	
		UTF::Message INFO "" "avg_dist_list='$avg_dist_list'"
		if {$avg_dist_list == ""} {
			error "No valid average distance value"
		}
		
		set keys "$::key_base2 11mc AP-STA Average Distance"
		set html_results [p2p::control_chart "" $avg_dist_list $keys "Average Distance" "m" 0]

		if {$error_flag} {
			error "html: $html_results"
		} else {
			return "html: $html_results"
		}
	}

	#####################################################################################################################
}


#################################################################################
#################################################################################
#                                  M A I N
#################################################################################
#################################################################################
UTF::Test P2PQoSNightly {args} {
	global env

	# Basic command line option processing. Options are stored in the
	# unnamed array $()
	UTF::Getopts "$::p2p_getopts" "$::p2p_help"

	set today [join [clock format [clock seconds] -format "%Y %N %e"] .]

	# If necessary, override the config file log directory setting.
	if {$(logdir) != ""} {
		set UTF::SummaryDir $(logdir)
		UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
	}

	if {$(nocache)} {
		set ::UTF::ControlChart::readonly 1
		set ::UTF::MemChart::readonly 1
	}

	if {$(debug_flag)} {
		set ::debug_flag 1
	} else {
		set ::debug_flag 0
	}

	if {$(debug2_flag)} {
		set ::debug2_flag 1
	} else {
		set ::debug2_flag 0
	}

	if {$(use_wl_for_mac)} {
		set ::use_wl_for_mac 1
	} else {
		set ::use_wl_for_mac 0
	}

	if {$(awdl)} {
		set ::awdl_flag 1
	} else {
		set ::awdl_flag 0
	}

	if {$(nan2)} {
		set ::nan2_flag 1
	} else {
		set ::nan2_flag 0
	}

	if {$(kpi_flag)} {
		set ::kpi_test_flag 1
	} else {
		set ::kpi_test_flag 0
	}
	
	if {$(macos_pcap_flag)} {
		set ::macos_pcap_debug_flag 1
	} else {
		set ::macos_pcap_debug_flag 0
	}

	if {$(scan_flag)} {
		set ::scan_test_flag 1
	} else {
		set ::scan_test_flag 0
	}

	if {$(escan_flag)} {
		set ::escan_test_flag 1
	} else {
		set ::escan_test_flag 0
	}

	set ::wlan_security $(wlan_security)
	if {$(p2p_security)} {
		set ::p2p_security "wpa2psk"
	} else {
		set ::p2p_security "open"
	}	

	if {$(graphs_with_min_max)} {
		set ::graphs_with_min_max 1
	} else {
		set ::graphs_with_min_max 0
	}	

	set ::vsdb_mode $(vsdb_mode)	
	set ::vsdb_bw_percentage $(vsdb_bw_percentage)

	set ::rsdb_mode $(rsdb_mode)	

	if {$(rsdb_switch_test)} {
		set ::rsdb_switch_test_flag 1
	} else {
		set ::rsdb_switch_test_flag 0
	}	

	set ::mpc_mode $(mpc_mode)	

	set ::wlan_chan_list $(ap_chan)
	set ::p2p_chan_list $(p2p_chan)
	if {$(ap_connect) == ""} {
		# default is to run tests for both GC and GO connected to AP
		set ::ap_connect_list "GC GO"
	} else {
		set ::ap_connect_list $(ap_connect)
	}
	set ::OppPS_CTWindow $(OppPS_CTWindow)
	set ::NoA_Param $(NoA_Param)

	if {$(nan)} {
		set ::ap_connect_list "NAN"
	} elseif {$(aibss)} {
		set ::ap_connect_list "AIBSS"
	} elseif {$(11mc)} {
		set ::ap_connect_list "11mc"
	}

	if {$(aibss)} {
		set ::wlan_display_str "AIBSS"
	} elseif {$(11mc)} {
		set ::wlan_display_str "11mc"
	} else {
		if {$::awdl_flag || $::nan2_flag} {
			set ::wlan_display_str "Infra"
		} else {
			set ::wlan_display_str "WLAN"
		}
	}

	if {$::awdl_flag && $::use_wl_for_mac == 0} {
		set ::p2p_display_str "AWDL"
		set ::go_display_str "DUT"
		set ::gc_display_str "AWDL Peer"
	} elseif {$::awdl_flag} {
		set ::p2p_display_str "AWDL"
		set ::go_display_str "Master"
		set ::gc_display_str "Slave"
	} elseif {$::nan2_flag} {
		set ::p2p_display_str "NAN"
		set ::go_display_str "Master"
		set ::gc_display_str "Slave"
	} else {
		set ::p2p_display_str "P2P"
		set ::go_display_str "GO"
		set ::gc_display_str "GC"
	}

	set ::base_timestamp_tick [clock scan "00:00:00"]
	UTF::Message INFO "" "::base_timestamp_tick=$::base_timestamp_tick"

	if {$(roam_src_ap) != "" && $(roam_dst_ap) != ""} {
		UTF::Message INFO "" "Roaming test"
		set (ap) $(roam_src_ap)
		set ::roaming_test_flag 1
		set (ap_chan) "36l"
		set (p2p_chan) "3"

		if {$(sniffer) == ""} {
			error "Sniffer parameter is missing. Halting tests!"
		}
	}

	if {$(sniffer) != ""} {
		set ::sniffer_object $(sniffer)

		set linuxver [$::sniffer_object rexec uname -r]
		if {![string match -nocase "*FC15*" $linuxver] && ![string match -nocase "*FC19*" $linuxver]} {
			error "Invalid Sniffer OS. Only FC15 or FC19 with BRCM wireshark is supported. Halting tests!"
		} else {
			if {[string match -nocase "*FC19*" $linuxver]} {
				UTF::Message INFO "" "Sniffer is FC19"
			} else {
				UTF::Message INFO "" "Sniffer is FC15"
			}
		}
		
		if {$::roaming_test_flag == 0} {
			if {$(sniffer_channel) == ""} {
				error "ERROR: parameters sniffer_channel is blank. Halting tests!"
			}
			if {$(sniffer_capture_time_sec) == ""} {
				error "ERROR: parameters sniffer_capture_time_sec is blank. Halting tests!"
			}

			set ::sniffer_channel $(sniffer_channel)
			set ::sniffer_capture_time_sec $(sniffer_capture_time_sec)
		}
    }

	if {$(sta) == "" && $(nos) == 1 && $(nom) == 1} {
		UTF::Message INFO "" "Direct $::p2p_display_str test does not need an AP"
		set (ap) ""
	}

	# validate the NAN (Neighbor Awareness Networking) flag
	if {$(nan)} {
		if {$(sta_gc) != "" || $(sta_go) != ""} {
			error "ERROR: either set parameter '-nan' or parameters '-sta_gc' '-sta_go'. Halting tests!"
		}
		if {$(run_qos)} {
			error "ERROR: either set parameter '-nan' or '-run_qos'. Halting tests!"
		}
		
		# 3 STAs needed
		set nan_sta_cnt [llength $(sta)]
		if {$nan_sta_cnt != 3} {
			UTF::Message WARN "" "NAN testing could require 3 STAs instead of '$(sta)'"
		}
	}

	# validate the AIBSS (Custom IBSS) flag
	if {$(aibss)} {
		if {$(ap) != ""} {
			error "ERROR: either set parameter '-aibss' or '-ap'. Halting tests!"
		}
		if {$(sta_gc) != "" || $(sta_go) != ""} {
			error "ERROR: either set parameter '-aibss' or parameters '-sta_gc' '-sta_go'. Halting tests!"
		}
		
		# 3 STAs needed
		set aibss_sta_cnt [llength $(sta)]
		if {$aibss_sta_cnt != 3} {
			error "ERROR: AIBSS testing requires 3 STAs instead of '$(sta)'. Halting tests!"
		}
	}
	
	if {$(ap) != ""} {

		if {$(ap) eq "" || [llength $(ap)] > 2} { 
		   error "-ap should be one band-selectable device, or a '2g 5g' pair" 
		}
	
		set ::wlan_ap [lindex $(ap) 0]

		set host_type [$::wlan_ap hostis]
		UTF::Message INFO "" "AP host_type=$host_type"
		if {$host_type == "Router"} {		
			UTF::Message INFO "" "$::wlan_ap: Real AP Mode"
		} else {
			set ::soft_ap_flag 1
			UTF::Message INFO "" "$::wlan_ap: SoftAP Mode"
		}
		
		if {$::roaming_test_flag} {
			set ap2 [lindex $(roam_dst_ap) 0]
			set ::list_ap_objects "$::wlan_ap $ap2"

			set host_type [$ap2 hostis]
			UTF::Message INFO "" "AP2 host_type=$host_type"
			set soft_ap2_flag 0
			if {$host_type == "Router"} {		
				UTF::Message INFO "" "$ap2: Real AP Mode"
			} else {
				if {[$ap2 cget -ap] == 1} {
					set soft_ap2_flag 1
					UTF::Message INFO "" "$ap2: SoftAP Mode"
				} else {
					error "ERROR: $ap2 is SoftAP but '-ap' parameter is missing for it. Halting tests!" 
				}
			}
			
			if {$::soft_ap_flag != $soft_ap2_flag} {
		   		error "ERROR: Both APs must be the same type (real AP or Soft AP). Halting tests!" 
			}
		} else {
			set ::list_ap_objects $::wlan_ap
		}
	}

	if {$(sta) != "" && ($(sta_gc) != "" || $(sta_go) != "")} {
		error "ERROR: either set parameter '-sta' or parameters '-sta_gc' '-sta_go'. Halting tests!"
	}

	if {$(sta_go) == "" && $(ap_connect) != ""} {
		error "ERROR: parameter '-ap_connect' can only be used with parameter '-sta_go'. Halting tests!"
	}

	UTF::Message INFO "" "*************************************************"
	UTF::Message INFO "" "wlan_only_flag:	(ap) != '' && (sta) != '' && (sta_gc) == '' && (sta_go) == '' && (bt_user_sta) == ''"
	UTF::Message INFO "" "               	$(ap) != '' && $(sta) != '' && $(sta_gc) == '' && $(sta_go) == '' && $(bt_user_sta) == ''"
	UTF::Message INFO "" "*************************************************"
	UTF::Message INFO "" "p2p_only_flag:	(ap) == '' && (sta) == '' && (sta_gc) != '' && (sta_go) != '' && (bt_user_sta) == ''"
	UTF::Message INFO "" "               	$(ap) == '' && $(sta) == '' && $(sta_gc) != '' && $(sta_go) != '' && $(bt_user_sta) == ''"
	UTF::Message INFO "" "*************************************************"
	UTF::Message INFO "" "bt_only_flag:		(ap) == '' && (sta) != '' && (sta_gc) == '' && (sta_go) == '' && (bt_user_sta) != ''"
	UTF::Message INFO "" "               	$(ap) == '' && $(sta) != '' && $(sta_gc) == '' && $(sta_go) == '' && $(bt_user_sta) != ''"
	UTF::Message INFO "" "*************************************************"

	##################################### WLAN ############################################

	if {$(ap) != "" && $(sta) != "" && $(sta_gc) == "" && $(sta_go) == "" && $(bt_user_sta) == ""} {
		if {[regexp {BT:} $(qos_tests)] || [regexp {P2P:} $(qos_tests)]} {
			error "ERROR: This is WLAN only test but 'qos_tests' parameter also shows BT or P2P. Halting tests!" 
		}
	
		set ::wlan_only_flag 1		
	} else {
		set ::wlan_only_flag 0
	}

	UTF::Message INFO "" "::wlan_only_flag=$::wlan_only_flag"

	if {!$(11mc) && [regexp {WLAN:} $(qos_tests)] && $(ap) == ""} {
		error "ERROR: 'ap' parameter is missing but 'qos_tests' parameter shows WLAN. Halting tests!" 
	}

	if {$(ap) != ""} {
		set ::wlan_load_flag 1
	} else {
		set ::wlan_load_flag 0
		set ::wlan_chan_list ""
	}

	##################################### P2P ############################################

	if {$(ap) == "" && $(sta) == "" && $(sta_gc) != "" && $(sta_go) != "" && $(bt_user_sta) == ""} {
		if {[regexp {BT:} $(qos_tests)] || [regexp {WLAN:} $(qos_tests)]} {
			error "ERROR: This is P2P only test but 'qos_tests' parameter also shows BT or WLAN. Halting tests!" 
		}
	
		set ::p2p_only_flag 1		
	} else {
		set ::p2p_only_flag 0
	}

	if {[regexp {P2P:} $(qos_tests)] && ($(sta_gc) == "" || $(sta_go) == "")} {
		error "ERROR: sta_gc or sta_go parameters are missing. Halting tests!"
	}

	if {$(sta_gc) != "" && $(sta_go) != ""} {
		if {[string compare $(sta_gc) $(sta_go)] == 0} {
			error "ERROR: sta_gc and sta_go parameters are the same. Halting tests!"
		}
		
		set ::p2p_load_flag 1
	} else {
		set ::p2p_load_flag 0
		set ::p2p_chan_list ""
	}

	##################################### BT ############################################

	if {($(bt_user_sta) != "" && $(bt_root_sta) == "") || ($(bt_user_sta) == "" && $(bt_root_sta) != "")} {
		error "ERROR: Both 'bt_user_sta' & 'bt_root_sta' parameters needs to be set for BT. Halting tests!" 
	}

	if {$(bt_user_sta) != "" && ![regexp {BT:} $(qos_tests)]} {
		error "ERROR: 'bt_user_sta' parameter is used but 'qos_tests' parameter does not shows BT. Halting tests!" 
	}

	if {$(ap) == "" && $(sta) == "" && $(sta_gc) == "" && $(sta_go) == "" && $(bt_user_sta) != ""} {
		if {[regexp {WLAN:} $(qos_tests)] || [regexp {P2P:} $(qos_tests)]} {
			error "ERROR: This is BT only test but 'qos_tests' parameter also shows WLAN or P2P. Halting tests!" 
		}
	
		set ::bt_only_flag 1
		set (sta) $(bt_root_sta)
		set (ap_chan) ""
		set (p2p_chan) "BT"
		set ::wlan_chan_list $(ap_chan)
		set ::p2p_chan_list $(p2p_chan)
		set ::ap_connect_list "BT"
	} else {
		set ::bt_only_flag 0
	}

	if {($(sta) != "" || $(sta_gc) != "") && $(bt_user_sta) != "" && [regexp {BT:} $(qos_tests)]} {
		set ::bt_load_flag 1
	} else {
		set ::bt_load_flag 0
	}

	#################################################################################

	UTF::Message INFO "" "::wlan_load_flag=$::wlan_load_flag ::p2p_load_flag=$::p2p_load_flag ::bt_load_flag=$::bt_load_flag"
	UTF::Message INFO "" "::wlan_only_flag=$::wlan_only_flag ::p2p_only_flag=$::p2p_only_flag ::bt_only_flag=$::bt_only_flag"

	# (sta) = (sta_gc)
	if {$(sta) == ""} {
		set (sta) $(sta_gc)
	} elseif {$(sta_gc) == ""} {
		set (sta_gc) $(sta)
	}

	if {$::p2p_load_flag} {
		set ::go_wlan $(sta_go)
		set ::list_sta_wlan_objects "$(sta_gc) $::go_wlan"
		set ::list_gc_wlan_objects $(sta_gc)
	} else {
		set ::list_sta_wlan_objects $(sta_gc)
		set ::list_gc_wlan_objects $(sta_gc)
		set ::list_possible_interface_objects $(sta_gc)
	}

	UTF::Message INFO "" "delete all the STAs data arrays"
	p2p::array_setup_sta_data "" 1 0

	foreach sta_wlan_a_index $::list_sta_wlan_objects {
		UTF::Message INFO "" "create STA $sta_wlan_a_index data arrays"
		p2p::array_setup_sta_data $sta_wlan_a_index 0 1
	}
	
	if {$::p2p_load_flag} {
		# P2P STA GO (group owner)
		set temp [$::go_wlan cget -sta]
		set ::array_sta_p2p(${::go_wlan}) [lindex $temp 2]
		if {$::array_sta_p2p(${::go_wlan}) == ""} {
			# in case of clone, look for the main object
            set main_object [p2p::get_name $::go_wlan]
			set temp [$main_object cget -sta]
			set ::array_sta_p2p(${::go_wlan}) [lindex $temp 2]
			if {$::array_sta_p2p(${::go_wlan}) == ""} {			
				error "ERROR: $::go_wlan $::p2p_display_str interface is not defined in UTF config file. Halting tests!"
			}
		}
		set ::array_sta_host_type(${::go_wlan}) [$::go_wlan hostis]
		UTF::Message INFO "" "::array_sta_host_type(${::go_wlan})=$::array_sta_host_type(${::go_wlan})"
		set ::array_sta_wlan_ifname(${::go_wlan}) [lindex $temp 1]
		UTF::Message INFO "" "::array_sta_wlan_ifname(${::go_wlan})=$::array_sta_wlan_ifname(${::go_wlan})"
		set ::array_sta_p2p_ifname(${::go_wlan}) [lindex $temp 3]
		UTF::Message INFO "" "::array_sta_p2p_ifname(${::go_wlan})=$::array_sta_p2p_ifname(${::go_wlan})"						
		if {$::array_sta_p2p_ifname(${::go_wlan}) == ""} {
			error "ERROR: $::go_wlan $::p2p_display_str interface is not defined in UTF config file. Halting tests!"
		}
	}

	set list_gc_p2p_objects ""

	# P2P STA GC (group client)
	foreach sta_wlan_b_index $::list_gc_wlan_objects {
	
		set catch_resp [catch {$sta_wlan_b_index cget -sta} catch_msg]
		if {$catch_resp != 0} {
			# failed
        	UTF::Message LOG "" "$sta_wlan_b_index -sta -> catch_resp=$catch_resp catch_msg=$catch_msg"
			error "ERROR: Invalid object name '$sta_wlan_b_index'. Halting tests!"
        } else {
        	set temp $catch_msg
        	UTF::Message LOG "" "'$sta_wlan_b_index -sta'=$temp"
        }

		set ::array_sta_host_type(${sta_wlan_b_index}) [$sta_wlan_b_index hostis]
		UTF::Message INFO "" "::array_sta_host_type(${sta_wlan_b_index})=$::array_sta_host_type(${sta_wlan_b_index})"
		set ::array_sta_wlan_ifname(${sta_wlan_b_index}) [lindex $temp 1]
		UTF::Message INFO "" "::array_sta_wlan_ifname(${sta_wlan_b_index})=$::array_sta_wlan_ifname(${sta_wlan_b_index})"

		if {$::p2p_load_flag} {
			set gc_p2p [lindex $temp 2]
			if {$gc_p2p == ""} {
				# in case of clone, look for the main object
				set main_object [p2p::get_name $sta_wlan_b_index]
				set temp [$main_object cget -sta]
				set gc_p2p [lindex $temp 2]
				if {$gc_p2p == ""} {			
					error "ERROR: $sta_wlan_b_index $::p2p_display_str interface is not defined in UTF config file. Halting tests!"
				}
			}

			set ::array_sta_p2p(${sta_wlan_b_index}) $gc_p2p
			set ::array_sta_p2p_ifname(${sta_wlan_b_index}) [lindex $temp 3]
			UTF::Message INFO "" "::array_sta_p2p_ifname(${sta_wlan_b_index})=$::array_sta_p2p_ifname(${sta_wlan_b_index})"
			if {$::array_sta_p2p_ifname(${sta_wlan_b_index}) == ""} {
				error "ERROR: $sta_wlan_b_index $::p2p_display_str interface is not defined in UTF config file. Halting tests!"
			}
			lappend list_gc_p2p_objects $gc_p2p
		}
	}

	if {$::p2p_load_flag} {
		# 1st WLAN and then P2P
		set ::list_possible_interface_objects "$::list_gc_wlan_objects $::go_wlan $list_gc_p2p_objects $::array_sta_p2p(${::go_wlan})"
	}

	UTF::Message INFO "" "::list_possible_interface_objects=$::list_possible_interface_objects"

	set ::list_active_interface_objects $::list_existing_interface_objects
	UTF::Message INFO "" "::list_active_interface_objects=$::list_active_interface_objects"

	if {$(attn_type) > 3} {
		error "ERROR: Invalid attenuation type parameter. Halting tests!"
	} elseif {$(attn_type) == 1 || $(attn_type) == 2 || $(attn_type) == 3} {
		# RvR test
		set ::rvr_test_flag 1
		UTF::Message LOG "" "RvR test with perftime of $(perftime)"

		if {$::wlan_load_flag} {
			set gc_wlan_object [lindex $::list_gc_wlan_objects 0]
			set ::rvr_wlan_attngrp [$gc_wlan_object cget -attngrp]
			UTF::Message LOG "" "STA $gc_wlan_object WLAN attenuation group is '$::rvr_wlan_attngrp'"
			if {$::rvr_wlan_attngrp == ""} {
				set ::rvr_wlan_attngrp [$::wlan_ap cget -attngrp]
				UTF::Message LOG "" "AP $::wlan_ap WLAN attenuation group is '$::rvr_wlan_attngrp'"
			}
			UTF::Message LOG "" "RvR WLAN attenuation group is '$::rvr_wlan_attngrp'"
			if {($(attn_type) == 1 || $(attn_type) == 3) && $::rvr_wlan_attngrp == ""} {
				error "ERROR: Invalid WLAN attenuation setup in the config file. Halting tests!"
			}
		}

		if {$::p2p_load_flag} {
			set gc_p2p_object [lindex $list_gc_p2p_objects 0]
			set ::rvr_p2p_attngrp [$gc_p2p_object cget -attngrp]
			UTF::Message LOG "" "RvR $::p2p_display_str attenuation group is '$::rvr_p2p_attngrp'"
			if {$(attn_type) > 1 && $::rvr_p2p_attngrp == ""} {
				error "ERROR: Invalid $::p2p_display_str attenuation setup in the config file. Halting tests!"
			}
		}
	}
		
	set ::tg_wlan ""
	if {$::soft_ap_flag == 1} {
		set ::tg_wlan $::wlan_ap
		UTF::Message INFO "" "SoftAP=$::tg_wlan"
		set ::array_sta_host_type(${::tg_wlan}) [$::tg_wlan hostis]
		UTF::Message INFO "" "::array_sta_host_type(${::tg_wlan})=$::array_sta_host_type(${::tg_wlan})"
	} elseif {$(ap) != ""} {
		# AP lanpeer for PSTA is different
		set ::tg_wlan [$::wlan_ap cget -lanpeer]
		UTF::Message LOG "" "::tg_wlan=$::tg_wlan"
        set logname [p2p::get_name $::tg_wlan]
		UTF::Message LOG "" "logname=$logname"

		if {$::tg_wlan == ""} {
			error "ERROR: AP lanpeer failed to find the UTF endpoint. Halting tests!"
		}
		
		set ::array_sta_host_type(${::tg_wlan}) [$::tg_wlan hostis]
		UTF::Message INFO "" "::array_sta_host_type(${::tg_wlan})=$::array_sta_host_type(${::tg_wlan})"
		set temp [$::tg_wlan cget -sta]
		UTF::Message INFO "" "$::tg_wlan cget -sta=$temp"
		set ::array_sta_wlan_ifname(${::tg_wlan}) [lindex $temp 1]
		UTF::Message INFO "" "::array_sta_wlan_ifname(${::tg_wlan})=$::array_sta_wlan_ifname(${::tg_wlan})"
	}

	set ::ping_count $(ping_count)
	set ::gnuplot_font $(gnuplot_font)
	set ::gnuplot_font_size $(gnuplot_font_size)
	set ::rvr_attn_incr $(rvr_attn_incr)
	set ::testbed_path_loss $(testbed_path_loss)
	
	set ::perfint $(perfint)

	set ::perfloop $(perfloop)
	set ::history $(history)

	if {$::wlan_only_flag} {
		set ::go_wlan ""
		set ::ap_connect_list "GC"
		set ::p2p_chan_list $::wlan_chan_list
		set (nod) 1
		set (nos) 1
		set (nom) 1
	}

	set wlan_chan_list_cnt [llength $::wlan_chan_list]
	set p2p_chan_list_cnt [llength $::p2p_chan_list]

	if {$(run_qos)} {
		if {$(ap) == ""} {
			# Dirrect P2P
			set (nod) 0
			set (nos) 1
			set (nom) 1
		} else {
			if {[string compare $::wlan_chan_list $::p2p_chan_list] == 0} {
				# same channel test
				set (nod) 1
				set (nos) 0
				set (nom) 1
			} else {
				# multi-channel test
				set (nod) 1
				set (nos) 1
				set (nom) 0
			}
		}
	}

	UTF::Message LOG "" "(nod)=$(nod) (nos)=$(nos) (nom)=$(nom)"
	UTF::Message LOG "" "::wlan_chan_list='$::wlan_chan_list'"
	UTF::Message LOG "" "::p2p_chan_list='$::p2p_chan_list'"
	
	if {!$(11mc) && ($(nos) == 0 || $(nom) == 0)} {
		# '-nos' and '-nom' parameters are not passed. It means run the same channel or multi-channel tests

		if {$(ap) == ""} {
			error "ERROR: AP parameter is not set for the multi-channel testing. Halting tests!"
		}

		if {$::p2p_load_flag && $wlan_chan_list_cnt != $p2p_chan_list_cnt} {
			error "ERROR: parameters ap_chan='$(ap_chan)' and p2p_chan='$(p2p_chan)' are not the same length. Halting tests!"
		}
	}

	if {$(measure_current_sta) != ""} {
		UTF::Message LOG "" "***Current Measurement Option***"
		
		# Get the Agilent object and port number
		set power_sta [$(measure_current_sta) cget -power_sta]
		set power_sta [string trim $power_sta]
		set fields [split $power_sta " "]
		set ::agilent_obj [lindex $fields 0]
		set ::agilent_port [lindex $fields 1]

		if {$::agilent_obj == "" || $::agilent_port == ""} {
			error "ERROR: Agilent setting and association with STA is not correct in the UTF config file. Halting tests!"
		}
		
		set ::voltage [$::agilent_obj cget -voltage]

		UTF::Message LOG "" "::agilent_obj=$::agilent_obj"
		UTF::Message LOG "" "::agilent_port=$::agilent_port"
		UTF::Message LOG "" "::voltage=$::voltage"
		
		# current_measure_time = current_sample_time * current_sample_points -> 100E-6 * 50000 = 5 seconds
		# current_measure_time = current_sample_time * current_sample_points -> 300E-6 * 50000 = 15 seconds
		set ::current_measure_time [expr {$(current_sample_time) * $(current_sample_points)}]
		UTF::Message LOG "" "::current_measure_time=$::current_measure_time"
	}

	##########################################################################################

	set sta_wlan_index [lindex $::list_gc_wlan_objects 0]

	set branch [$sta_wlan_index branchname]

	# Override default tags
	if {$(trx) ne ""} {
		foreach AP $::list_ap_objects {
			$AP configure -image $(trx) -date {}
		}
	} elseif {$(aptag) ne ""} {
		foreach AP $::list_ap_objects {
			$AP configure -tag $(aptag) -date {}
		}
	}
	if {$(apdate) ne "" && $(ap) ne ""} {
		foreach AP $::list_ap_objects {
			$AP configure -date $(apdate)
		}
	} else {
		set (apdate) $today
	}

	######################################################################
	##############    loading DHD and FW Private Image    ################
	##############    loading Specific DHD Date Image     ################
	######################################################################

	# Firmware loading rules:
	#	wl.ko for 43236 is the stadhd parameter -> 'stabin=rtecdc.bin.trx' and 'stadhd=wl.ko'
	#	wl.ko for 43224 is the stabin parameter -> 'stabin=wl.ko'

	if {$(nan)} {
		set sta_list $(sta)
	} else {
		set sta_list $::list_sta_wlan_objects
	}

	foreach sta $sta_list {
	
		set sta_host_type [$sta hostis]
		UTF::Message LOG "" "$sta host_type=$sta_host_type"

		# DHD
		if {$sta_host_type == "DHD" || $sta_host_type == "Panda"} {
			if {$(stadhd) ne ""} {
				$sta configure -dhd_image $(stadhd)
				UTF::Message LOG "" "$sta DHD ko image from -> $(stadhd)" 		
			}

			if {$(stadhddate) ne ""} {
				$sta configure -dhd_date $(stadhddate)
				UTF::Message LOG "" "$sta DHD ko dated image from -> $(stadhddate)" 		
			}
		}

		# FW
		if {$(stabin) ne ""} {
			$sta configure -image $(stabin) -date {}
			UTF::Message LOG "" "$sta FW image from -> $(stabin)" 
		}
	}

	######################################################################
	
	if {$(statag) ne ""} {
		foreach STA $::list_sta_wlan_objects {
			$STA configure -tag $(statag) -date {}
		}
	}
	
	if {$(stadate) ne ""} {
		foreach STA $::list_sta_wlan_objects {
			$STA configure -date $(stadate)
		}
		unset STA
	} else {
		set (stadate) $today
	}

	# Compact build list for title
	set build [UTF::BuildTitle $sta_wlan_index]

	if {$(title) eq ""} {
		if {[$STA hostis WinDHD Cygwin]} {
			set (title) [$STA host whatami]
		} elseif {[$STA hostis LMAC DHD]} {
			set (title) "Linux Dongle"
		} else {
			set (title) [$STA hostis]
		}

		if {[regexp {(\d+sd)} $::wlan_ap - c]} {
			append (title) " with $c AP"
		}
	}

    set test_name [file tail $::argv0]
    set test_name [file rootname $test_name]

	set tmp "$(title) "

	if {$::wlan_security != "open" || $::p2p_security != "open"} {
		append tmp "Security=$::wlan_security,$::p2p_security "
	}

	if {$(nan2)} {
		set tmp_custom_test "NAN2 "
	} elseif {$(nan)} {
		set tmp_custom_test "NAN "
	} elseif {$(aibss)} {
		set tmp_custom_test "AIBSS "
	} elseif {$(11mc)} {
		set tmp_custom_test "11mc "
	} else {
		set tmp_custom_test ""
	}

	if {$::agilent_obj != ""} {
		set tmp_current "Current Measurement "
	} else {
		set tmp_current ""
	}

	set tmp_rvr ""
	set tmp_roaming ""
	if {$::roaming_test_flag == 1} {
		if {![regexp -nocase {Roaming } $tmp]} {
			set tmp_roaming "Roaming "
		}
	} else {
		if {$(attn_type) == 1} {
			if {$::wlan_only_flag} {
				set tmp_rvr "WLAN Only RvR "
			} else {
				set tmp_rvr "WLAN RvR "
			}
		} elseif {$(attn_type) == 2} {
			set tmp_rvr "$::p2p_display_str RvR "
		} elseif {$(attn_type) == 3} {
			set tmp_rvr "WLAN&$::p2p_display_str RvR "
		}
	}

	if {$(pm_mode) != "" && !$(nan)} {
		set tmp_pm "PM=$(pm_mode) "
	} else {
		set tmp_pm ""
	}

	if {$::soft_ap_flag == 1} {
		set tmp_soft_ap "SoftAP "
	} else {
		set tmp_soft_ap ""
	}	

	if {$::mpc_mode != ""} {
		set tmp_mpc "MPC=$::mpc_mode "
	} else {
		set tmp_mpc ""
	}	

	if {$::rsdb_mode != ""} {
		set tmp_rsdb "RSDB=$::rsdb_mode "
	} else {
		set tmp_rsdb ""
	}	

	if {$(p2p_connection_first)} {
		if {$(awdl)} {
			set tmp_p2p_connection_first "AWDLConnectionFirst "
		} elseif {$(nan2)} {
			set tmp_p2p_connection_first "NANConnectionFirst "
		} elseif {$::p2p_load_flag} {
			set tmp_p2p_connection_first "P2PConnectionFirst "
		}
	} else {
		set tmp_p2p_connection_first ""
	}	

	append tmp "$tmp_custom_test$tmp_rvr$tmp_roaming$tmp_mpc$tmp_rsdb$tmp_p2p_connection_first$tmp_soft_ap$tmp_pm$tmp_current$test_name"
	
	set TITLE "UTF $tmp ($build)"	
	UTF::Message INFO "" $TITLE

	# $build is used in the title.  For private builds this will
	# indicate special images.

	# (branch) is used for comparison over time.  For private builds
	# this should be specified explicitly so the tests know which
	# branch to test.

	if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
		error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
	}
	unset build

	# Truncate build name for performance keys
	regsub {_.*} $(branch) {} (branch)

	UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {

		if {$::kpi_test_flag} {
			set ::UTF::__tryid "auto"
			UTF::Message INFO "" "Setup KPI Base XML data"  
			set ::kpi_base_db [UTF::KPI::KeyValue Base]
			# add the metascriptid, sessionid, and summaryurl to the KPI Base 
			UTF::Message INFO "" "$::kpi_base_db set -exclude 'metascriptid' meta sessionid '::UTF::SessionID' summaryurl 'UTF::Summary base']"  
			$::kpi_base_db set -exclude "metascriptid" meta sessionid "$::UTF::SessionID" summaryurl [$UTF::Summary base]
			
			if {$::tg_wlan == ""} {
				$::kpi_base_db set "test_type" "Direct"
			} else {
				$::kpi_base_db set "test_type" "Infra\+AWDL"
			}
		} else {
			set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]
		}

		set ::logdir [file dirname $UTF::Logfile]

		# Need gnuplot 4.2 or higher for image heatmaps.
		set ::gnu_ver [UTF::GnuplotVersion]
		if {$::gnu_ver < 4.2} {
			UTF::Message ERROR "" "gnuplot $::gnu_ver is installed instead of 4.2 or higher which is needed for image heatmaps"
			error "gnuplot $::gnu_ver is old. Halting tests!"
		}
		UTF::Message INFO "" "gnuplot version=$::gnu_ver"  

		if {$::agilent_obj != ""} {
			UTF::Try "Setup Agilent" {
				set rc [$::agilent_obj set_voltage $::agilent_port $::voltage]
				if {$rc != 0} {
					incr ::error_cnt
					error "Failed to set Agilent voltage"
				} else {
					UTF::Message INFO "" "Reboot STA $(measure_current_sta)"					
					$(measure_current_sta) power cycle
					UTF::Sleep 60
					UTF::Message INFO "" "Agilent RST is issued and STA $(measure_current_sta) is rebooted"					
					return "$::voltage V (STA $(measure_current_sta) is rebooted)"
				}				
			}
			
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}

		if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
			UTF::Try "Setup testbed" {
				if {$::wlan_ap != ""} {
					set catch_resp [catch "[$::wlan_ap cget -attngrp] attn 95" catch_msg]
					UTF::Message LOG "" "catch_resp=$catch_resp catch_msg=$catch_msg"
					if {$catch_resp == 0} {
						set ::max_attn 95
					} else {
						set ::max_attn 63
					}
				}
				UTF::Message LOG "" "::max_attn=$::max_attn"
				eval $::UTF::SetupTestBed
			}
		}

		#####################################################
		##############    Setup Multicore    ################
		#####################################################
		if {$(multicore_mode) != ""} {
			p2p::setup_multicore
		}

		#####################################################
		############    Setup Mac Radio On    ###############
		#####################################################
		p2p::setup_mac_radio_on

		if {$::wlan_ap != ""} {
		
			set ap_num 0
			foreach AP $::list_ap_objects {
				
		    	incr ap_num
				if {!$(noapload)} {
					UTF::Try "$AP: Find AP Image" {
						UTF::CheckImage $AP $(apdate) unknown
					}

					UTF::Try "$AP: Load Image" {
						if {[$AP hostis Router Vx BSDAP DSL Airport]} {
							if {[catch {$AP lan ifconfig [$AP lan cget -ipaddr]}]} {
								$AP lan ifconfig 192.168.1.50
							}
						}
						$AP load
					}

					UTF::ReportDriver $AP $(apdate)
					
				}  elseif {[$AP hostis Linux]} {
					UTF::Try "$AP: reload" {
						$AP reload
					}
				}

				if {!$(norestore)} {
					UTF::Try "$AP: Restore Defaults" {
						if {[$AP hostis Router Vx BSDAP DSL Airport]} {
							$AP restore_defaults
						} else {
							$AP services stop
							if {[info exists ::UTF::Use11h]} {
								catch {$AP wl msglevel +error +assoc +regulatory}
							} else {
								catch {$AP wl msglevel +error +assoc}
							}

							if {![$AP cget -nomimo_bw_cap]} {
								catch {$AP wl down}
								# Enable 40 in 2.4, if available.
								if {[catch {$AP wl bw_cap 2 -1}]} {
									$AP wl -u mimo_bw_cap 1
								}
								$AP wl up
								UTF::Sleep 1
							}
						}

						set what [$AP whatami]
						# Pull out chip info and replace whitespace to make it
						# easier for external parsers.
						regsub -all {\s+} [lreplace $what 0 0] {_} w

						if {$(noapload)} {
							$UTF::Summary header $AP $w
						} else {
							$UTF::Summary header_update 1 $w
						}

						$AP dbrecord REF

						if {$::kpi_test_flag} {
							$::kpi_base_db set "apheader$ap_num" "$w"
							array set db [$AP dbget]
							foreach item [array names db] {
								UTF::Message LOG "" "apheader$ap_num\_$item=$db($item)"
								$::kpi_base_db set "apheader$ap_num\_$item" "$db($item)"
							}
						}
						
						set what
					}
				}
			}

			#---------------------------------------------------
			#--------------    Setup AP Security   -------------
			#---------------------------------------------------
			if {$::wlan_security != "open" || $::soft_ap_flag == 1} {
				foreach AP $::list_ap_objects {
					UTF::Try "$AP security $::wlan_security" {
						UTF::Test::APConfigureSecurity $AP -security $::wlan_security
						set temp [$AP cget -security]

						UTF::Message INFO "" "Security is $temp"
						set temp "<font color=\"blue\"><b>$temp Security</b></font>"
						return "html: $temp"
					}
				}
			}
		} else {
			# Direct P2P with no AP
			if {$::kpi_test_flag} {
				$::kpi_base_db set "apheader" "N/A"
			}
		}
		
		# Load the STAs if required.		
		set sta_num 0
		foreach STA $::list_sta_wlan_objects {

		    incr sta_num
			if {$(branch) eq "auto"} {
				set branch [$STA branchname]
			} else {
				set branch $(branch)
			}

			# Find images
			if {!$(nostaload)} {
				UTF::Try "$STA Find STA Image" {
					UTF::CheckImage $STA $(stadate) unknown
				}
			}

			if {!$(nosetup)} {
				if {$(nostaload)} {
					if {!$(nostareload)} {
					
						# retry is needed since sometimes the STA load fails and a reboot is needed
						for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {

							set reboot_flag 0

							UTF::Try "$STA reload" {
								set catch_resp [catch {$STA reload} catch_msg]
								UTF::Message INFO "" "Reload STA catch_resp=$catch_resp catch_msg=$catch_msg"
								if {$catch_resp != 0} {
									set reboot_flag 1
									error "$catch_msg"
								} else {
									return "$catch_msg"
								}
							}

							if {$reboot_flag == 1} {
								UTF::Try "Issue - Reboot STA $STA" {
									UTF::Message INFO "" "=========================================================================="
									UTF::Message INFO "" "Reboot the STA $STA with issue before the exit, so the next test can run"
									$STA power off
									UTF::Sleep 5
									$STA power on
									UTF::Sleep 60
								}
							} else {
								break
							}
						}
					}
				} else {
					
					# retry is needed since sometimes the STA load fails and a reboot is needed
					for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {

						set reboot_flag 0

						UTF::Try "$STA load" {
							set catch_resp [catch {$STA load} catch_msg]
							UTF::Message INFO "" "Load STA catch_resp=$catch_resp catch_msg=$catch_msg"
							if {$catch_resp != 0} {
								set reboot_flag 1
								error "$catch_msg"
							} else {
								return "$catch_msg"
							}
						}
					
						if {$reboot_flag == 1} {
							UTF::Try "Issue - Reboot STA $STA" {
								UTF::Message INFO "" "=========================================================================="
								UTF::Message INFO "" "Reboot the STA $STA with issue before the exit, so the next test can run"
								$STA power off
								UTF::Sleep 5
								$STA power on
								UTF::Sleep 60
							}
						} else {
							break
						}
					}
					
					UTF::ReportDriver $STA $(stadate)
				}
				
				# VSDB (must be set on GC only)
				if {$::vsdb_mode != "" && [string compare $STA $sta_wlan_index] == 0} {
					UTF::Try "$STA Setup VSDB Mode $::vsdb_mode" {
						UTF::Message INFO "" "VSDB Setup"
						set ::catch_resp [catch "$STA wl PM ; $STA wl mpc ; $STA wl mchan ; $STA wl mchan_algo ; $STA wl mchan_bw" ::catch_msg]
						set ::catch_resp [catch "$STA wl mchan_algo $::vsdb_mode ; $STA wl mchan_bw $::vsdb_bw_percentage" ::catch_msg]
						if {$::catch_resp != 0} {
							incr ::error_cnt
							error "$::catch_msg"
						}
						set ::catch_resp [catch "$STA wl PM ; $STA wl mpc ; $STA wl mchan ; $STA wl mchan_algo ; $STA wl mchan_bw" ::catch_msg]
						return ""
					}
				}

				set sta_model ""
				set sta_osver ""
				UTF::Try "$STA defaults" {

					$STA services stop
					catch {$STA wl msglevel +error +assoc}
					if {![$STA cget -nomimo_bw_cap] && !$(nan)} {
						catch {$STA wl down}
						# Enable 40 in 2.4, if available.
						# Doesn't work for LMAC since LMAC is never "down"
						catch {$STA wl -u mimo_bw_cap 1}

						catch {$STA wl ampdu $(qos_ampdu_mode)}

						catch {$STA wl up}
						UTF::Sleep 1
					}

					$STA wl ver
					
					set what [$STA whatami]
					# Pull out chip info and replace whitespace to
					# make it easier for external parsers.
					regsub -all {\s+} [lreplace $what 0 0] {_} w

					if {$(nostaload)} {
						$UTF::Summary header $STA $w
					} else {
						$UTF::Summary header_update 1 $w
					}
					$STA dbrecord DUT

					if {$::kpi_test_flag} {
			    		$::kpi_base_db set "staheader$sta_num" "$w"
			    		
			    		# STA Model/OS
						set sta_osver [$STA os_version]
						catch {$STA lan rexec system_profiler -timeout 30 -detailLevel mini} output
						set sta_model "unknown"
						foreach line [split $output "\n"] {
							if {[regexp {Model Identifier:\s+(.*)} $line - sta_model]} {
								break
							}
						}
						UTF::Message LOG "" "staheader$sta_num\_modelID=$sta_model"
						$::kpi_base_db set "staheader$sta_num\_modelID" "$sta_model"
						UTF::Message LOG "" "staheader$sta_num\_os_version=$sta_osver"
						$::kpi_base_db set "staheader$sta_num\_os_version" "$sta_osver"
			    		
						array set db [$STA dbget]
						foreach item [array names db] {
							UTF::Message LOG "" "staheader$sta_num\_$item=$db($item)"
							$::kpi_base_db set "staheader$sta_num\_$item" "$db($item)"
						}
					}

					set what
				}

				if {$::kpi_test_flag} {
					UTF::Try "$STA Model/OS" {
						return ${sta_model}/${sta_osver}
					}
				}

				# for rte, you can do "$STA rte mu" to get the memory usage
				if {!$(nostaload) && [$STA rte_available]} {
					UTF::Try "$STA: Free Memory After Load (K)" {
						# retry is needed due to issues with NPC serial port
						for {set retry_cnt 0} {$retry_cnt < 3} {incr retry_cnt} {
							set catch_resp [catch "$STA freekb" catch_msg]
							UTF::Message LOG "" "retry_cnt=$retry_cnt catch_resp=$catch_resp catch_msg=$catch_msg"
							if {$catch_resp == 0} {
								break
							}
						}

						if {$catch_resp == 1} {
							error $catch_msg							
						}

						set ret_val [format "%.7f" $catch_msg]
						UTF::Test::memchart $ret_val -failonlow -key [list $branch $STA loadfree] -units kb -title "Load Free"
					}
				}
			}
		}

		# If there are any STA that didnt load, halt the script.
		# We must have all devices functioning properly in the test rig.
		if {$::error_cnt > 0} {
		
			#####################################################
			##############   Unload STA driver   ################
			#####################################################
			p2p::unload_sta_driver

			error "Halting tests!"
		}

		##################################################################
		#
		#	P2P tests start here
		#
		##################################################################

		#########################################
		# Check for existing DHD Memory Dump from previous tests
		#########################################
		p2p::get_dhd_memory_dump

		#########################################
		# Setup Variables
		#########################################
		p2p::setup_vars
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		if {$::debug_flag == 1} {
			UTF::Try "DEBUG ENABLE" {
				$sta_wlan_index wl assert_type 1
				$sta_wlan_index wl msglevel +assoc +apsta +ampdu
			}
		}

		#########################################
		# Setup MPC
		#########################################
		if {$::mpc_mode != ""} {
			p2p::setup_mpc
		}

		#########################################
		# Setup RSDB
		#########################################
		if {$::rsdb_mode != ""} {
			p2p::setup_rsdb
		}

		#########################################
		# Enable NTP
		#########################################
		if {$(enable_ntp)} {
			p2p::enable_ntp
			if {$::error_cnt > 0} {
				error "Halting tests!"
			}
		}
		
		#########################################
		# Check NTP
		#########################################
		p2p::check_ntp
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#########################################
		# Setup iperfs
		#########################################
		p2p::setup_iperfs
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#########################################
		# Setup BT
		#########################################
		p2p::bt_setup
		if {$::error_cnt > 0} {
			error "Halting tests!"
		}

		#####################################################
		################## Setup WLAN PM ####################
		#####################################################
		if {$(pm_mode) != "" && !$(nan)} {
			UTF::Try "Setup WLAN PM $(pm_mode)" {
			
				# WLAN PM mode should not be set on SoftAP
				
				foreach STA $::list_sta_wlan_objects {
					UTF::Message INFO "" "************************STA=$STA***************************"
					catch {$STA wl dtim}
					catch {$STA wl PM}
					catch {$STA wl PM $(pm_mode)}
					UTF::Sleep 3
					set catch_resp [catch {$STA wl PM} catch_msg]
					if {$catch_msg != $(pm_mode)} {
						error "PM mode is not $(pm_mode)"
					}
				}
				
				return "PM $(pm_mode)"
			}
		}

		set tmp ""
		if {$::p2p_load_flag} {
			set tmp "$::go_wlan $::array_sta_p2p(${::go_wlan})"
		}

		set ::key_base "$branch P2PQoS $::wlan_ap $::vsdb_mode $::vsdb_bw_percentage $::wlan_security $::p2p_security $tmp $sta_wlan_index $::array_sta_p2p(${sta_wlan_index}) $(pm_mode)"

		if {$::wlan_only_flag || $(nan) || $(aibss) || $(11mc)} {
			set test_type_list [lindex $::list_gc_wlan_objects 0]
		} else {
			#####################################################
			# Build the P2P/QoS test type (e.g. Direct,SameBand,MultiBand)
			#####################################################
			if {!$(nod)} {
				if {$(aibss)} {
					set test_type_list "AIBSS"
				} else {
					append test_type_list " Direct"
				}
			}
			if {!$(nos)} {
				append test_type_list " SameChan"
			}
			if {!$(nom)} {
				append test_type_list " MultiChan"
			}
			if {$(run_opp_ps)} {
				if {!$(nod)} {
					append test_type_list " OppPSDirect"
				}
				if {!$(nos)} {
					append test_type_list " OppPSSameChan"
				}
				if {!$(nom)} {
					append test_type_list " OppPSMultiChan"
				}
			}
			if {$(run_noa)} {
				if {!$(nod)} {
					append test_type_list " NoADirect"
				}
				if {!$(nos)} {
					append test_type_list " NoASameChan"
				}
				if {!$(nom)} {
					append test_type_list " NoAMultiChan"
				}
			}
			set test_type_list [string trim $test_type_list]
			UTF::Message LOG "" "test_type_list=$test_type_list"

			#####################################################
			# For GO or GC connection to AP
			#####################################################
			UTF::Message LOG "" "1##########################################################################################################"
			UTF::Message LOG "" "1##### foreach ::ap_connect_list='$::ap_connect_list'"
			UTF::Message LOG "" "1##########################################################################################################"
		}
		
		foreach ::ap_connect $::ap_connect_list {

			UTF::Message LOG "" "1=========================================================================================================="
			UTF::Message LOG "" "--->Process ::ap_connect='$::ap_connect'"
			UTF::Message LOG "" "1=========================================================================================================="

			if {$::wlan_only_flag == 1} {
				set ::str_ap_connect "STA"
			} else {
				if {$::awdl_flag && $::use_wl_for_mac == 0} {
					set ::str_ap_connect "DUT"
				} elseif {$::awdl_flag || $::nan2_flag} {
					if {$::ap_connect == "GO"} {
						set ::str_ap_connect "(STA+Master)"
					} else {
						set ::str_ap_connect "(STA+Slave)"
					}
				} else {
					set ::str_ap_connect "(STA+$::ap_connect)"
				}
			}

			##########################################################
			# For Direct, Same Channel, SameBand, MultiBand, OppsPS, NoA
			##########################################################
			UTF::Message LOG "" "2##########################################################################################################"
			UTF::Message LOG "" "2##### foreach test_type_list='$test_type_list'"
			UTF::Message LOG "" "2##########################################################################################################"
			foreach ::test_type $test_type_list {

				set ::p2p_chan_index 0

				UTF::Message LOG "" "2=========================================================================================================="
				UTF::Message LOG "" "--->Process ::test_type='$::test_type'"
				UTF::Message LOG "" "2=========================================================================================================="

				if { [string first "Direct" $::test_type] == 0 } {
					# for Direct P2P, there is no router connection, therefore
					# "::ap_connect" "GC" and "GO" is the same and we do not 
					# need to run it twice.					
					if {[lindex $::ap_connect_list 0] != $::ap_connect} {

						# this is the 2nd item in the ::ap_connect_list, therefore 
						# skip it for Direct P2P test
						UTF::Message LOG "" "Skip Direct $::p2p_display_str test this time since it is done previously"
						continue
					}
				}

				set ::key_base2 "$::key_base"
				set ::test_type $::test_type

				#####################################################
				# remove space,tab,CR and break all the tests to test groups
				#####################################################
				if {$(run_qos)} {
					regsub -all { } $(qos_tests) "" ::all_tests

					if {$(qos_p2p_traffic)} {
						regsub -all {WLAN:} $::all_tests "P2P:" ::all_tests
					}
				} else {
					regsub -all { } $(tests) "" ::all_tests
				}

				regsub -all {[\n]} $::all_tests "" ::all_tests
				regsub -all {[\r]} $::all_tests "" ::all_tests
				regsub -all {[\t]} $::all_tests "" ::all_tests
				regsub -all {'} $::all_tests "" ::all_tests
				regsub -all {"} $::all_tests "" ::all_tests
				regsub -all {\\} $::all_tests "" ::all_tests
				set ::all_tests [split $::all_tests "|"]
				# remove empty element
				regsub -all {\{\}} $::all_tests "" ::all_tests
				regsub -all { {2,}} $::all_tests { } ::all_tests 
				set ::all_tests [string trim $::all_tests]

				#####################################################
				# For all the P2P channels
				#####################################################
				UTF::Message LOG "" "3##########################################################################################################"
				UTF::Message LOG "" "3##### foreach ::wlan_chan_list='$::wlan_chan_list' ::p2p_chan_list='$::p2p_chan_list'"
				UTF::Message LOG "" "3##########################################################################################################"
				foreach ::wlan_chan $::wlan_chan_list ::p2p_chan $::p2p_chan_list {

					UTF::Message LOG "" "3 loop start=========================================================================================================="

					if {$::str_ap_connect == ""} {
						if {[info exists ::str_ap_connect_saved]} {
							set ::str_ap_connect $::str_ap_connect_saved
						}
					}
					if {$::wlan_ap == ""} {
						if {[info exists ::wlan_ap_saved]} {
							set ::wlan_ap $::wlan_ap_saved
						}
					}

					UTF::Message LOG "Before" "::ap_connect='$::str_ap_connect' ::test_type='$::test_type' ::wlan_ap='$::wlan_ap' ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'"

					if { [string first "Direct" $::test_type] != -1} {
						if { $::p2p_chan == ""} {
							UTF::Message LOG "" "::p2p_chan is BLANK. Skip" 		
							continue
						}

						# no wlan for Direct P2P
						set ::wlan_chan ""
						set ::str_ap_connect_saved $::str_ap_connect
						set ::str_ap_connect ""
						set ::wlan_ap_saved $::wlan_ap
						set ::wlan_ap ""
					} else {
						if {$::wlan_load_flag && $::wlan_chan == ""} {
							UTF::Message ERROR "" "***Failed. BLANK wlan_chan is invalid."
							error "BLANK wlan_chan is invalid."
						}
						if {$::p2p_load_flag && $::p2p_chan == ""} {
							UTF::Message ERROR "" "***Failed. BLANK p2p_chan is invalid."
							error "BLANK p2p_chan is invalid."
						}

						if { [string first "SameChan" $::test_type] == 0 } {
							# For same channel test, set P2P channel to AP channel
							set ::p2p_chan $::wlan_chan
							UTF::Message LOG "" "wlan_chan=p2p_chan=$::wlan_chan" 		
						}
					}

					UTF::Message LOG "After" "::ap_connect='$::str_ap_connect' ::test_type='$::test_type' ::wlan_ap='$::wlan_ap' ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'"
					
					set ::error_cnt 0
					foreach sta_wlan_d_index $::list_sta_wlan_objects {
						set ::array_sta_wlan_active_flag(${sta_wlan_d_index}) 0
						set ::array_sta_p2p_active_flag(${sta_wlan_d_index}) 0
						set ::array_sta_wlan_disassociated_flag(${sta_wlan_d_index}) 0
						set ::array_sta_p2p_disassociated_flag(${sta_wlan_d_index}) 0
					}

					UTF::Message LOG "" "3=========================================================================================================="
					UTF::Message LOG "" "--->Process ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'"
					UTF::Message LOG "" "3=========================================================================================================="

					#####################################################
					#############   get_dhd_memory_dump   ###############
					#####################################################
					p2p::get_dhd_memory_dump

					#####################################################
					################   Setup AP Radio   #################
					#####################################################
					if {$::roaming_test_flag == 0 && !$(nan)} {
						if { $(ap) != "" && [string first "Direct" $::test_type] == -1 } {
							p2p::setup_ap_radio_channel $(ap) $::wlan_chan

							if {$::error_cnt > 0} {
								continue
							}
						}
					}

					#####################################################
					################     Setup CCT      #################
					#####################################################
					p2p::setup_cct

					if {$::p2p_load_flag} {
						#####################################################
						################   Setup GO apsta   #################
						#####################################################
						p2p::setup_go_apsta

						if {$::error_cnt > 0} {
							continue
						}
					}

					if {$(ap) != "" && $::roaming_test_flag == 0 && !$(p2p_connection_first) && !$(nan)} {
						#####################################################
						############   Create AP Connection   ###############
						#####################################################
						p2p::create_ap_connection
						
						if {$::error_cnt > 0} {
							continue
						}
					}

					if {$::p2p_load_flag} {
						if {$::awdl_flag} {
							#########################################
							# Setup AWDL
							#########################################
							p2p::setup_awdl
							p2p::free_memory_after_p2p_assoc
							if {$::error_cnt > 0} {
								error "$::panic_msg. Halting tests!"
							}
							if {$::array_sta_host_type(${::go_wlan}) == "MacOS"} {
								#########################################
								# PCAP Dump Start
								#########################################
								if {$::macos_pcap_debug_flag} {
									p2p::macos_pcap_debug_dump_start 1
								}
								
								#########################################
								# Get AWDL Discovery Time
								#########################################
								p2p::awdl_discovery_time
								
								#########################################
								# PCAP Dump Stop
								#########################################
								if {$::macos_pcap_debug_flag} {
									p2p::macos_pcap_debug_dump_stop
								}
							}
						} elseif {$::nan2_flag} {
							#########################################
							# Setup NAN
							#########################################
							p2p::setup_nan2
							
							p2p::free_memory_after_p2p_assoc
							if {$::error_cnt > 0} {
								error "$::panic_msg. Halting tests!"
							}
						} else {
							#####################################################
							##############		Setup GO	   ################
							#####################################################
							p2p::setup_go

							if {$::error_cnt > 0} {
								continue
							}

							#####################################################
							##############		Setup GC	   ################
							#####################################################
							p2p::setup_gc

							if {$::error_cnt > 0} {
								continue
							}
						}

						if {[string first "OppPS" $::test_type] != -1} {

							#####################################################
							##############	  Setup OppPS		 ################
							#####################################################
							p2p::setup_opp_ps

						} elseif {[string first "NoA" $::test_type] != -1} {

							#####################################################
							##############	   Setup NoA	   ################
							#####################################################
							p2p::setup_noa
						}

						if {$::error_cnt > 0} {
							continue
						}

						#####################################################
						################### Setup P2P PM ####################
						#####################################################
						if {$(pm_mode) != "" && !($::awdl_flag && $::use_wl_for_mac == 0)} {
							UTF::Try "Setup $::p2p_display_str PM $(pm_mode)" {

								# P2P PM mode should not be set on GO
				
		   						set failed_flag 0 
								foreach STA "$::list_sta_wlan_objects" {
		   							set set_pm_flag 1 
									UTF::Message INFO "" "************************STA=$STA with $::p2p_display_str=$::array_sta_p2p(${STA})***************************"
									if {$STA == $::go_wlan} {
										UTF::Message INFO "" "GO PM mode should not be changed"
		   								set set_pm_flag 0 
									}
									catch {$STA wl -i $::array_sta_p2p_ifname(${STA}) dtim}
									catch {$STA wl -i $::array_sta_p2p_ifname(${STA}) PM}
									if {$set_pm_flag == 1} {
										catch {$STA wl -i $::array_sta_p2p_ifname(${STA}) PM $(pm_mode)}
										UTF::Sleep 3
										set catch_resp [catch {$STA wl -i $::array_sta_p2p_ifname(${STA}) PM} catch_msg]
										if {$catch_msg != $(pm_mode)} {
											set failed_flag 1 
										}
									}
								}
								if {$failed_flag} {
									error "PM mode is not $(pm_mode)" 
								}
								
								return "PM $(pm_mode)"
							}
						}

						if {!$::awdl_flag} {
							#####################################################
							##### Current Measurement before P2P association ####
							#####################################################
							if {$::agilent_obj != ""} {
								UTF::Try "Current Measurement ($::p2p_display_str Not Associated)" {
									set ::cct_key "$::p2p_display_str Not Associated"
									p2p::measure_idle_current					
									return "html: $::current_results"
								}
							}

							foreach gc_wlan_index $::list_gc_wlan_objects {
								#####################################################
								##############       GC Join GO      ################
								#####################################################
								# GC joining GO fails randomly, therefore
								# retry is added for now till this issue is fixed
								for {set retry_cnt 0} {$retry_cnt < 5} {incr retry_cnt} {

									UTF::Message INFO "" "p2p::gc_join_go $gc_wlan_index retry count $retry_cnt 0"

									set ::error_cnt 0
									p2p::gc_join_go $gc_wlan_index $retry_cnt 0

									if {$::error_cnt > 0} {
										UTF::Message INFO "" "***Failed. p2p::gc_join_go $gc_wlan_index retry count $retry_cnt failed"
										UTF::Sleep 5
										# retry
										continue
									}

									# passed
									break
								}
							}
						}

						if {$::error_cnt > 0} {
							continue
						}

						if {$(ap) != "" && $::roaming_test_flag == 0 && $(p2p_connection_first) && !$(nan)} {
							#####################################################
							############   Create AP Connection   ###############
							#####################################################
							p2p::create_ap_connection
							
							if {$::error_cnt > 0} {
								continue
							}
						}
					}

					if {$(nan)} {
						#####################################################
						################    Run NAN Test    #################
						#####################################################
						p2p::run_nan_test
						break
					} elseif {$(aibss)} {
						#####################################################
						################   Run AIBSS Test   #################
						#####################################################
						p2p::run_aibss_test
					} elseif {$(11mc)} {
						#####################################################
						###############    Run 11mc Test    #################
						#####################################################
						p2p::run_11mc_test
					}

					if {$(new_beacon_interval) != ""} {
						p2p::change_beacon_interval $(new_beacon_interval)
					}

					#####################################################
					##############    Connection Test    ################
					#####################################################
					if {$::roaming_test_flag == 0} {
						UTF::Message INFO "" "connection_test before the 1st test"
						p2p::connection_test
					}

					if {!$(nan) && !$(aibss) && !$(11mc)} {
						#####################################################
						##############    Process All Tests   ###############
						#####################################################
						if {$::roaming_test_flag == 0} {
							p2p::process_all_tests
						} else {
							p2p::process_all_roaming_tests
						}
					}

					#####################################################
					#############   Channel Switch Time   ###############
					#####################################################
					p2p::channel_switch_time $sta_wlan_index "$::array_sta_wlan_ifname(${sta_wlan_index})" "$::wlan_display_str $::gc_display_str"
					if {$::p2p_load_flag} {
						p2p::channel_switch_time $::go_wlan $::array_sta_wlan_ifname(${::go_wlan}) "$::wlan_display_str $::go_display_str"
					}

					catch {p2p::get_beacon_rate}
					
					if {$::array_sta_p2p_active_flag(${sta_wlan_index}) == 1} {
						UTF::Try "$::p2p_display_str Cleanup" {
							p2p::p2p_cleanup
						}
					}
					
					UTF::Message LOG "" "3 done channel ::wlan_chan='$::wlan_chan' ::p2p_chan='$::p2p_chan'=========================================================================================================="
					
					if {$::roaming_test_flag || $(nan) || $(aibss) || $(11mc)} {
						break
					}
				}
				
				UTF::Message LOG "" "3 done all channels##########################################################################################################"

				# end of foreach ::test_type
			}
			# end of foreach ::ap_connect
		}

		#####################################################
		#############   get_dhd_memory_dump   ###############
		#####################################################
		p2p::get_dhd_memory_dump

		#####################################################
		#################   Leak check   ####################
		#####################################################
		if {!$(nounload)} {
			foreach s "$::list_sta_wlan_objects $::list_ap_objects" {

				if {$s == ""} {
					continue
				}

				set host_type [$s hostis]
				UTF::Message LOG "" "host_type=$host_type"

				if {$host_type != "DHD"} {
					UTF::Message LOG "" "$s is not DHD host type"
					continue
				}

				if {$(ap) == "" || ([string first "Direct" $::test_type] != -1 && [string first $s $::list_ap_objects] != -1)} {
					# for direct P2P tests, AP radio is disabled and leak check is skipped
					continue
				}

				if {[string first $s $::list_ap_objects] != -1 && $::soft_ap_flag == 0} {
					if {![catch {$s wl assert_type} at]} {

						UTF::Try "$s: Leak check" {
							$s wl assert_type 1
							$s wl down
							$s wl up
							$s wl assert_type [lindex $at 0]
						}
					}
				} else {
					UTF::Try "$s: MaxMem in use" {
						UTF::Test::memchart [$s maxmem] -key [list $branch $s maxmem]
					}
				}
			}
		}

		#####################################################
		#############   get_dhd_socram_dump   ###############
		#####################################################
		p2p::get_dhd_socram_dump
		
		#####################################################
		##############   Unload STA driver   ################
		#####################################################
		if {!$(nounload)} {
		
			p2p::unload_sta_driver

			if {$::agilent_obj != ""} {
				UTF::Try "Current Measurement (No Driver)" {
					UTF::Sleep 2
					set ::cct_key "No Driver"
					p2p::measure_idle_current					
					return "html: $::current_results"
				}
			}
		}

		#####################################################
		#############   get_dhd_memory_dump   ###############
		#####################################################
		p2p::get_dhd_memory_dump

		PreservedReport

		if {!$(noposttesthook) && [info exists ::UTF::PostTestHook]} {
			UTF::Try "Post Test" {
				eval $::UTF::PostTestHook
			}
		}

	# End of code block for UTF::WrapSummary
	}
}
