#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for checking TSSI values
# $Id: 6343187ad70da60192791ea532dac088c486a953 $
# $Copyright Broadcom Corporation$
#

package require UTF

UTF::Test TSSI {STA args} {

    # The script should take the following parameters:
    UTF::Getopts {
	{txcore.arg "0x2" "which Tx core is enabled. This is a 3-bit \
	bitmask, so for example 0x1 implies only core 0 transmits, 0x3 \
	implies core 0 and core 1 will transmit etc."}
	{mcs.arg "7" "MCS value - for example 7 implies MCS 7"}

	{stf.arg "0" "Space Time Streams - 0 for SISO, \
	1 for CDD, 2 for STBC, 3 for SDM"}

	{nsts.arg "1" "number of space time streams and can take the
	value 1, 2 ,3"}

	{CDD_delay0.arg 0 "cyclic shift delay for core0"}
	{CDD_delay1.arg 512 "cyclic shift delay for core1"}
	{CDD_delay2.arg 8704 "cyclic shift delay for core2"}

	{num_pkts.arg "0" "number of packets to Tx. If this value is \
	0, it implies that pkts will be transmitted continuously. This \
	value is given directly to pkteng."}

	{chanspec.arg "36l" "which channel to use. For example the \
	value 36, implies 20MHz channel 36 and the value 36l implies \
	40MHz channel 36. This string will be given to wl chanspec \
	directly to set the channel"}
	{txbw.arg "4" "bandwidth value - 2 for 20MHz b/w and 4 for 40 MHz b/w"}

	{tssioff.arg "240" "offset in us from the start of pkt, where \
	the TSSI is sampled"}

	{samples.arg "20" "number of TSSI ADC values that should \
	be read from the PHY register"}

	{title.arg "title" "Title"}
    }

    regsub {/} "tssi_$STA.log" {.} UTF::Logfile

    set (CDD_delay0) [UTF::Numexpand $(CDD_delay0)]
    set (CDD_delay1) [UTF::Numexpand $(CDD_delay1)]
    set (CDD_delay2) [UTF::Numexpand $(CDD_delay2)]
    set (tssioff) [UTF::Numexpand $(tssioff)]

    set parm(chanspec) $(chanspec)
    set parm(txcore) $(txcore)
    set parm(mcs) $(mcs)
    set parm(stf) $(stf)
    set parm(nsts) $(nsts)
    set parm(title) $(title)

    # When the script starts up, it should init the chip to prevent
    # watchdog, Bluetooth coexistence etc. by doing the following:
    $STA wl mpc 0; # Make sure "up" really means "up"
    $STA wl phy_watchdog 0
    $STA wl btc_mode 0
    $STA wl scansuppress 1
    $STA wl phy_percal 1
    $STA wl phy_txpwrctrl 0;    # disables Tx powerctrl
    $STA wl phy_txpwrindex 25 30 25;   # set Tx power to 14 dBm

    # Then it should set the channel and band and then do a PHY
    # calibration as follows:
    $STA wl down
    $STA wl chanspec $(chanspec)
    $STA wl band [$STA band $(chanspec)]
    $STA wl up
    $STA wl phy_forcecal 1

    # After that it should set the pkt bandwidth, rate and core by
    # doing:
    $STA wl mimo_txbw $(txbw);   # for example: wl mimo_txbw 4  for 40 MHz b/w
    $STA wl nrate -m $(mcs) -s $(stf);    # for example: wl nrate -m7 -s1   for MCS 7, CDD
    $STA wl txcore -s $(nsts) -c $(txcore); # for example: wl txcore -s1 -c0x7  for transmitting CDD on all 3 cores

    UTF::forall \
	parm(tssioff) $(tssioff) \
	parm(CDD_delay0) $(CDD_delay0) \
	parm(CDD_delay1) $(CDD_delay1) \
	parm(CDD_delay2) $(CDD_delay2) \
	{

	    # Then it should set the TSSI offset time within the Tx
	    # frame by doing the following:
	    # Get the value of the register at offset 0x1e8
	    # Clear bits [7:0] of this value and put in the value
	    # passed in as argument.
	    # Write the modified value to phyreg by doing wl phyreg
	    # 0x1e8 <newval>
	    
	    if {$(nsts) == 1} {
		$STA wl phyreg 0xba $parm(CDD_delay0)
	    } elseif {$(nsts) == 2} {
		$STA wl phyreg 0xbb [format "0x%x" [expr {$parm(CDD_delay1) << 5 |
							  $parm(CDD_delay0)}]]
	    } else {
		# n_sts == 3
		$STA wl phyreg 0xbc [format "0x%x" [expr {$parm(CDD_delay2)<<10 |
							  $parm(CDD_delay1)<< 5 |
							  $parm(CDD_delay0)}]]
	    }

	    $STA wl phyreg 0x1e8 \
		[format "0x%x" [expr {([$STA wl phyreg 0x1e8] & ~0xff) | $parm(tssioff)}]]

	    # Then it should Tx pkt(s) by doing:

	    # Then in a for loop it should poll the TSSI for all 3 cores by doing:

	    for {set count 0} {$count < $(samples)} {incr count} {
		$STA wl pkteng_start \
		    00:11:22:33:44:55 tx 500 100 1 22:33:44:55:66:77

		for {set core 0} {$core < 3} {incr core} {
		    set ret [$STA wl phy_test_tssi $core]
		    UTF::XPASS $STA $ret \
			[concat [UTF::ParmStrip parm] core $core count $count]
		}
	    }

	}

    # We need to plot the TSSI for all 3 cores on the same plot. The
    # x-axis should be the pkt index for the 1st graph. For the second
    # graph, the x-axis is the TSSI offset delay.

}
