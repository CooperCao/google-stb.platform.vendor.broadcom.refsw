#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for aci nightly run
# $Id: 80391f6f0768af9c4e7a0293ba7147defc7ff1b1 $
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set wl_commands_help "\n\nBasic usage: Test/wl_commands.test <options>\
    \n\nThis Rate vs Range script will setup your testrig by loading the desired\
    \nbuilds, produce high level summary web pages and calls the script that does\
    \nthe lower level work, aci.test. The script aci.test is called for up to 4\
    \ndifferent channels. Each channel is tested for the upstream and downstream\
    \ntraffic directions.\

    \n\nYou can take complete control of the AP & STA initialization sequence by\
    \nspecifying the variables ::rvr_ap_init and ::rvr_sta_init in your config\
    \nfile. The defaults are defined in aci.test proc get_user_parms. Alternately,\
    \nlook in the RvR logfiles in the Setup AP & STA section to see the defaults.\
    \nFor SoftAP, you can specify the initialization in ::rvr_softap_init. SoftAP\
    \ndefaults to the values from ::rvr_sta_init.\
    \n\nSome people may have more complex initialization needs which depend on the\
    \nSTA talking to a real AP versus a SoftAP, and other variations. So this\
    \ninitialization variable heirarchy is available to allow customization\
    \nfor all devices in the testrig, as well as STA specific customizations:\
    \nFor STA to SoftAP ::rvr_sta_{STA}_to_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_softap_init ::rvr_sta_init\
    \nFor STA to AP     ::rvr_sta_{STA}_to_ap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_ap_init ::rvr_sta_init\
    \nFor SoftAP        ::rvr_sta_{STA}_am_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_softap_init ::rvr_sta_init\
    \nFor AP            ::rvr_ap_{AP}_init ::rvr_ap_init\
    \nIn the above variables, {STA} & {AP} mean the UTF STA name.\
    \nWhen the script looks for the initialization, the list is searched from left\
    \nto right, with the STA specific variable having the highest priority.\
    \nBecause the script knows which AP & STA you are using, and if you specified\
    \nthe -softap option or not, the script can locate and use the appropriate\
    \ninitialization variables without any additional user intervention.\
    \n\nIf you want to use the -warmup option, you can override the default 5Mb/s pass\
    \ncriteria by specifying:\
    \n    set ::rvr_warmup nn\
    \n    Set this parameter to 0 or -1 if you dont want a pass criteria.\
    \n\nTo keep tests from running away for hours at a time, the aci.test script has a\
    \ntime limit of 90 minutes for each rampdown/rampup test. If you want to override\
    \nthe default 90 minute per test timeout value, then specify:\
    \n    set ::rvr_overall_timeout_min mm\
    \n    Set this parameter to 0 or -1 for no timeout, unlimited test run time.\
    \n\nBy default the script will try 1 time to rejoin the AP and STA. This default\
    \ncan be changed in your config file:\
    \n    set ::rvr_rejoin_tries ii\
    \n    The minimum value for this parameter is 1.\
    \n\nBy default, the script will wait 10 seconds after a rejoin attempt. This\
    \ndefault can be changed in your config file:\
    \n    set ::rvr_rejoin_wait_sec jj\
    \n    The minimum value for this parameter is 5.\
    \n\nBy default, the script will perform 3 progressive recovery attempts during the\
    \ntests if things go wrong. This default can be changed in your config file:\
    \n    set ::recovery_max kk\
    \n    Set this parameter to 0 or -1 for no recovery actions.\
    \n\nBy default, the script will stop the rampdown portion of the test after 3\
    \nconsecutive attenuator steps with no beacons. This default can be changed in\
    \nyour config file:\
    \n    set ::rvr_rampdown_nobeacons bb\
    \n    Set this parameter to 0 or -1 to disable this feature.\
    \n\nThe optional -stopslowrampup algorithm is controlled by two parameters, whose\
    \ndefaults are 10 & 1 respectively. These defaults can be changed in your config file:\
    \n    set ::rvr_slowrampup_cnt cc\
    \n    set ::rvr_slowrampup_tput tt\
    \n\nThere may be times that a specific STA needs the router to do something\
    \nspecifically for that STA. You can add STA specific variables to set the\
    \nrouter nvram accordingly in your config file. Dont forget to turn these\
    \nsettings back for theSTAs.\
    \n    set ::mc351_4319USB_rtr_nvram {antswitch=3}\
    \n    set ::mc356_43326USB_rtr_nvram {antswitch=0}\
    \n\nAfter each occasional repeated error attenuator occurs, the attenuator\
    \nrecovery is attempted. If you choose to specify the variable shown below in\
    \nyour config file, your attenuator will be power cycled for you, and the\
    \ncommand retried after the power cycle:\
    \n    set ::rvr_attn_power \"mcxxwsy 1\"\
    \nAfter 3 repeated attenuator errors, the aci.test is halted. Should you\
    \nwish to alter the default 3 attenuator error limit, you may specify the\
    \nvariable shown below in your config file:\
    \n    set ::rvr_attn_max_errors N\
    \n    Set this parameter to 0 or -1 to allow unlimited errors to occur.\
    \n\nThe optional fastrampup test will test 10 samples at the final attenuator\
    \nvalue. You can alter this value by specifying ::rvr_fastrampup_cnt in your\
    \nconfig file. Variable ::rvr_fastrampup_tput controls the thruput at which\
    \nthe fastrampup is made, default is 1 Mb/s.\
    \n\nFor SoftAP tests, the RF wiring on the attenuator needs to be set up to\
    \nattenuate the RF path between the SoftAP and the STA being tested. Most\
    \ntestrigs need to be modified for this to work, as they tend to have a real\
    \nAP connected to the attenuator, not a SoftAP.\
    \n\nFor SoftAP tests, you need to ensure the SoftAP and STAs will get IP\
    \naddresses. A real AP has a built-in DHCP server. If the SoftAP is running\
    \non Linux, you can run dhcpd on the Linux host. You will still need to\
    \nconfigure a static IP address for the SoftAP itself. If the SoftAP does\
    \nnot provide dhcpd, then you must configure static IP addresses for the\
    \nSTA that will be tested. See examples in utfconf/pb4a.tcl & mc49.tcl.\
    \n\nThe AP connect time check looks for drops of 30 seconds or more as\
    \nan indicator of issues. The variable ::rvr_connect_time_drop can be used\
    \nto alter this threshold. Set to -1 to turn off this test.\
    \n\nTrenderrors looks at how many consecutive errors occur as well as total\
    \nerrors in the test. Initially most controlchart tests are shown as PASS,\
    \nexcept for major errors like assert or ping fail. Then, at the end of the\
    \ntests, the trend errors analysis is done and the overall PASS/FAIL criteria\
    \nis determined. Config file variable ::rvr_trend_error_length defaults to 6,\
    \nand is the minimum number of consecutive errors needed to trigger a trend\
    \nerror FAIL. Variable ::rvr_trend_error_max defaults to 18, and is the total\
    \nnumber of errors that can occur, consecutive or not, without causing a FAIL.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set wl_commands_getopts {
    {allhooks                  "Use all the perf_hooks, etc as is - currently the default"}
    {ap.arg "4717"             "AP name"}
    {bin.arg ""                "STA image, usefull for private build testing"}
    {branch.arg "auto"         "Branch override"}
    {date.arg ""               "depracated, please use rtrdate & stadate"}
    {downstreamonly            "RvR downstream only tests are done, dont do upstream tests"}
    {edithooks                 "Selectively edit the perf_hooks, etc for some test speedup"}
    {email.arg ""              "Email Address, defaults to your email address"}
    {fastrampup                "Do fast rampup only, saves test time"}
    {fb0                       "Use frameburst=0, currently the default"}
    {fb1                       "Use frameburst=1 for maximum throughput"}
    {keepgoing                 "No time limit for test, keep going no matter what"}
    {logdir.arg ""             "Log directory override"}
    {max.arg 1700              "Expected maximum througput, -1 means no checks done"}
    {min.arg 0                 "Expected minimum througput, -1 means no checks done"}
    {mingraphs                 "Produce minimum quantity of graphs"}
    {musta.arg ""              "Multi user mode. It loads up to 4 additional STAs"}
    {noapload                  "Don't load images"}
    {nobtreset                 "Don't reset BlueTooth devices. WARNING: can lead to low WLAN thruput!"}
    {nocache                   "Don't update performance cache"}
    {nochannels                "Does nothing, depracated"}
    {nocomposite               "Don't generate composite RvR graphs for each STA"}
    {nocompositemainpage       "Generate composite RvR graphs for each STA, but dont show them on the main web page"}
    {nocontrvr                 "Depracated"}
    {nocyclervr                "No cycle-based rvr tests, default is run the cycle-based rvr tests"}
    {nodbuxpost                "Dont post test info to dbux"}
    {nographs                  "Dont produce any graphs"}
    {nohistograms              "Do not produce histograms"}
    {nohooks                   "Dont use any perf_hooks, etc for maximum test speedup"}
    {noinit                    "Use the testbed as is, no initialization"}
    {nomalloc                  "Dont check the serial console for malloc failures"}
    {nopretest                 "Dont do short warmup test for each controlchart test, defaults on for udp"}
    {noredundant               "Dont execute redundant wl calls, test runs a bit faster"}
    {norestore                 "Don't reset AP to defaults"}
    {norvr                     "No rvr tests, default is run the rvr tests"}
    {nosetup                   "No loading of AP or STAs, no testbed setup"}
    {nosetuptestbed            "Don't run Setup Testbed hooks"}
     {nostaload                 "Don't load STA drivers"}
    {nostareload               "Don't even reload STA drivers (need -nostaload)"}
    {nostahighlevelsetup       "Let aci.test do all the STA setup."}
    {nosymmetry                "Dont run symmetry tests for rampdown / rampup tests"}
    {nounload                  "Don't unload driver after test"}
    {oemAttnRange.arg ""       "Cycle-based aci attenuation range for OEM AP, default: 20-75 75-20"}
    {oemband.arg ""            "When OEM AP broadcasts on both bands, used to choose the desired band: 2.4 or 5"}
    {pathloss.arg ""           "Known testbed path loss, in db, from AP to STA when variable attenuator is set to default"}
    {perfloop.arg 1            "Total performance test iterations for iperf controlchart tests"}
    {perfsize.arg 5            "Sample size for performance tests"}
    {perftime.arg 10           "Total time duration, in seconds, for performance tests"}
    {pingmax.arg ""            "Maximum times to try ping in RvR, default is 10"}
    {rampdownonly              "Dont do rampup portion of RvR tests, test time is halved"}
    {rampuponly                "Dont do rampdown portion of RvR tests, test time is halved"}
    {refreshaddralways         "Always do dhcp before each attenuator step change & iperf test"}
    {refreshaddrasneeded       "Do dhcp after reassociation for each attenuator step until dhcp succeeds once, then stop"}
    {restoreaponly             "Do not load or reload AP, just restore the AP NVRAM"}
    {rtrdate.arg ""            "Desired Router build date, format: yyyy.mm.dd"}
    {rtrtag.arg ""             "Router release tag"}
    {security.arg "open"       "Security used for tests"}
    {softap                    "AP is really a STA running softap code"}
    {sta.arg "Sta4321"         "sta name(s)"}
    {stadate.arg ""            "Desired STA build date, format: yyyy.mm.dd"}
    {stadhd.arg ""             "STA .ko linux DHD file, usefull for testing private builds"}
    {statag.arg ""             "STA release tag"}
    {stoponerror               "Stops test on first error, no progressive recovery done. Useful when developer want to see testrig in failed state."}
    {stopslowrampup            "Stop the rampup test if severe slow rejoin issues are detected"}
    {tag.arg ""                "depracated, please use rtrtag"}
    {test.arg "0"              "Test mode for script development, experts only, values: 0 1 2"}
    {timeout.arg ""            "Overall test timeout, in minutes, default is 90 min"}
    {title.arg "Rate vs Range Test" "Report title text"}
    {titleap                   "Use AP name in report & graph titles, default is STA name"}
    {trenderrors               "Show only trend errors, not 1 error per controlchart"}
    {trx.arg ""                "Router trx image, usefull for private build testing"}
    {udp.arg "0"               "udp test starting value in Mb/s, 0 means off, use tcp"}
    {udpopt.arg ""             "more options for iperf for udp tests"}
    {windhdbin.arg ""          "WinDHD dongle image file, usefull for testing private builds, in particular for BTAMP"}
    {window.arg 512k           "Window size for iperf tests, has major impact on throughput"}
	{chanspec.arg ""		   "Override perfchans"}
}

# Setup online help info.
UTF::setup_help $wl_commands_help $wl_commands_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

package require UTF
package require UTF::utils
package require UTF::Test::APConfigureSecurity
package require UTF::Test::ChannelSweep

###
### TIMA -  disabled duplicate package definition!
###
##package provide UTF::Test::wl_commands 2.0


#============== proc main_wl_commands ==============================
# Proc main_wl_commands does all the STA loading, setup and then
# calls aci1fidha.test foreach STA. Router is loaded elsewhere.
#
# NB: proc is uniquely named to avoid conflict with other scripts
# that have a proc main.
#====================================================================
proc main_wl_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts


	

    # Ensure each STA gets full initialization the first time thru aci1fidha.test
    set ::rvr_init_done 0

    # Find STA image if necessary.
    set id ""
    if {!$(nostaload) && !$(nosetup) && !$(noinit)} {
        UTF::Try "$STA Find STA Image" {
            set catch_resp [catch {$STA findimages} catch_msg]
            $STA configure -image $catch_msg ;# needed to update title tag numbers
            if {$catch_resp == 0} {
                return $catch_msg
            } else {
                error $catch_msg
            }
        }

        # Add report summary table row for STA.
        set id [UTF::get_build_id $catch_msg]
        set notes [UTF::get_build_notes $catch_msg]
        set status [UTF::get_build_status $catch_msg $catch_resp]
        set ::summaryinfo [UTF::update_report_add $::summaryinfo $STA $(bin) $(statag) $(stadate) $id $notes $status]

        # Halt tests if STA image not found.
        if {$catch_resp != 0} {
            UTF::Try "could not find $STA image" {
                error "halting $STA test"
            }
            return
        }
    }

    # Load/reload/setup STA if necessary
    if {!$(nosetup) && !$(noinit)} {
        if {$(nostaload)} {
            if {!$(nostareload)} {
                UTF::Try "$STA Reload" {
                 
                        # For WET test, this is an AP.
                        UTF::reload_rtr $STA
                    
                        UTF::reload_sta $STA
                    
                }
            }
        } else {
            UTF::Try "$STA Load" {
            
                  
             
                    UTF::load_sta_retry $STA
                
            }

            # Update the report header table with actual OS & hw versions.
            set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

            # Update report title with actual TAG numbers
            UTF::update_report_title $STA
        }

        # User may want to let the lower level aci1fidha.test do all the STA setup.
        if {!$(nostahighlevelsetup)} {
            UTF::Try "$STA Defaults" {
                
                    $STA services stop
                    catch {$STA wl msglevel +error +assoc}
                    catch {$STA wl down}
                    # Enable 40 in 2.4, if available.
                    catch {$STA wl mimo_bw_cap 1}
                    $STA wl up
                    UTF::Sleep 1
                    $STA wl ver
           
                set hw_ver [$STA chipname]
                regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
                return $hw_ver
            }
        }
    }

    # Determine which bands are supported by the STA.
    set catch_resp [catch "set sta_bands \[$STA wl bands\]" catch_msg]
    # set catch_resp 1 ;# test code
    if {$catch_resp != 0} {
        UTF::Try "could not get $STA bands" {
            error "halting $STA test: $catch_msg"
        }
        return
    }


    # Now get AP bands.
    if {$::is_oem_ap == 0} {
        set ap_bands [$Router wl bands]
    } else {
        set ap_bands ""
    }
    UTF::Message LOG $STA "sta_bands=$sta_bands ap_bands=$ap_bands"

    # aci1fidha.test needs branch name when it calls get_stream.
    lappend ::branch_list [$STA branchname]
    UTF::Message LOG $STA "updated branch_list=$::branch_list"

    # Check disk utilization of all STA to be tested.
    UTF::check_disk_usage "$Router $STA "

    # proc main_wl_commands test loop starts here.
    if {$(titleap)} {
        set focus $Router
    } else {
        set focus $STA
    }
    update_summaries ver $focus $(softap) $(titleap)
	
	
	
UTF::Try "2g_rate" {

UTF::Try "2g" {
	$STA wl 2g_rate
	$STA wl 2g_rate 6
    $STA wl 2g_rate
}
UTF::Try "auto" {
	$STA wl 2g_rate auto
	$STA wl 2g_rate
}
}


UTF::Try "a_rate" {

UTF::Try "arate" {
	$STA wl a_rate 9
	$STA wl a_rate
}


UTF::Try "auto" {
	$STA wl a_rate auto
	$STA wl a_rate
}
}

UTF::Try "5g_rate" {

UTF::Try "5g" {
	$STA wl 5g_rate auto 
	$STA wl 5g_rate
}	

UTF::Try "VHT" {
	$STA wl 5g_rate  -l -v 0x1
	$STA wl 5g_rate 
	$STA wl 5g_rate -l -v 9x2
	$STA wl 5g_rate	
	$STA wl 5g_rate -l -v 9
	$STA wl 5g_rate
}

UTF::Try "Bandwidth" {	
	$STA wl 5g_rate -v 9 -l -b 20
	$STA wl 5g_rate 
	$STA wl 5g_rate -v 9 -l -b 40
	$STA wl 5g_rate 
	$STA wl 5g_rate -v 9 -l -b 80
	$STA wl 5g_rate
}

UTF::Try "stbc" {
	$STA wl 5g_rate -v 9 -l -b 80 --stbc
	$STA wl 5g_rate
}

UTF::Try "sgi" {
	$STA wl 5g_rate -v 9 -l -b 80 --stbc -g
	$STA wl 5g_rate
}

}

UTF::Try "ack_ratio" {
	$STA wl ack_ratio
}

UTF::Try "addwep" {
	$STA wl addwep 0 fidha
	$STA wl keys
}

UTF::Try "remwep" {
	$STA wl rmwep 0 
	$STA wl keys
}

UTF::Try "ampdu" {
	$STA wl  ampdu
}

UTF::Try "ampdu_clear_dump" {
	$STA wl  ampdu_clear_ampdu
}


UTF::Try "ampdu_mpdu" {
	$STA wl ampdu_mpdu 
}


UTF::Try "protocol data unit" {
	$STA wl dump ampdu
}

UTF::Try "amsdu" {
	$STA wl  amsdu
}

UTF::Try "service data unit" {
	$STA wl dump amsdu
}

UTF::Try "antdiv" {
	$STA wl antdiv
}


UTF::Try "antgain" {
	$STA  wl down
	$STA  wl antgain ag0=7 ag1=5
	$STA  wl antgain
}

UTF::Try "accesspoint" {
 $STA  wl ap
}

UTF::Try "apsta" {
 $STA  wl apsta
}

UTF::Try "active state power management" {
 $STA  wl aspm
}

UTF::Try "assoc_retry_max" {
 $STA  wl assoc_retry_max 
}

UTF::Try "band" {
	$STA wl band
}

UTF::Try "band_range" {
	$STA wl band_range
}

UTF::Try "bands" {
	$STA wl bands
}

UTF::Try "bcnlenhist" {
 $STA  wl bcnlenhist  
}

UTF::Try "Beacon Interval" {
  $STA wl bi
}

UTF::Try "Boardflags" {
  $STA wl boardflags
}


UTF::Try "btc_mode" {
	$STA  wl btc_mode
}

UTF::Try "btc_params" {
	$STA  wl btc_params
}

UTF::Try "bus" {
 $STA  wl bus  
}

UTF::Try "bw_cap" {
	$STA  wl band auto  
	$STA  wl bw_cap 2g 
	$STA  wl bw_cap  5g
}


UTF::Try "cap" {
 $STA  wl cap  
}

UTF::Try "channel" {
$STA  wl channel
}

UTF::Try "channels" {
 $STA  wl channels
}

UTF::Try "chanspec" {
   $STA wl chanspec
}

UTF::Try "chanspecs" {
	$STA wl chanspecs
}

UTF::Try "cisdump" {
	$STA wl mpc 0
	$STA wl up
	$STA wl cisdump
}

UTF::Try "ciswrite" {
	$STA wl mpc 0
	$STA wl up
	$STA wl ciswrite
}


UTF::Try "$STA clock" {
  $STA  wl clk
}

UTF::Try "counters" {
  $STA  wl counters
}

UTF::Try "interference_override" {
 $STA  wl interference_override  
}

UTF::Try "interference" {
 $STA  wl interference  
}

#UTF::Try "encryption key" {
#$STA wl addwep 
#}


UTF::Try "Country" {
$STA wl country
}


UTF::Try "Country List" {
$STA wl country list
}

UTF::Try "crsuprs" {
$STA wl crsuprs
}



UTF::Try "current ethernet address" {
	$STA wl cur_etheraddr
}

UTF::Try "current power" {
		catch {$STA wl mpc 0}
		catch {$STA wl up}
		catch {$STA wl isup}
		catch $STA {wl clk}
		catch {$STA wl curpower}
	}

UTF::Try "curppr" {
	$STA wl curppr
}


UTF::Try "device path" {
		$STA wl devpath
}

UTF::Try "disable_percal" {
		$STA wl disable_percal
}

UTF::Try "disassoc" {
		$STA wl dissoc
}

UTF::Try "down" {
		$STA wl down
}


UTF::Try "dtim" {
		$STA wl dtim
}

UTF::Try "pcieinfo" {
	$STA wl dump pcieinfo 
}

UTF::Try "phyaci" {
	$STA wl dump phyaci 
}

UTF::Try "phycal" {
	$STA wl dump phycal  
}  	

#UTF::Try "phych4rpcal" {
#	$STA wl dump phych4rpcal    
#}

UTF::Try "rsdb" {
$STA wl dump rsdb 
}

UTF::Try "rssi" {
	$STA wl dump rssi       
}

UTF::Try "txbf" {
	$STA wl dump txbf 
}


UTF::Try "evm" {
	$STA wl mpc 0
	$STA wl up
	$STA wl clk 
	$STA wl band b
	$STA wl rate 5.5
	$STA wl chanspec 11
	$STA wl evm 11 5.5
} 




UTF::Try "fast_timer" {
	$STA wl fast_timer 
}


UTF::Try "fem" {
	$STA wl fem 
}

UTF::Try "fqacurcy" {
	$STA wl fqacurcy
}


UTF::Try "frameburst" {
	$STA wl frameburst
}

UTF::Try "getPaParamNameIdPair" {
	$STA wl getPaParamNameIdPair
}

UTF::Try "glacial_timer" {
	$STA wl glacial_timer
	catch {$STA wl glacial_timer=15000}
}

UTF::Try "gmode" {
	$STA wl gmode
}

UTF::Try "gmodeauto" {
	$STA wl gmode auto
}

UTF::Try "hw_rxchain " {
	$STA wl hw_rxchain 
}

UTF::Try "hw_txchain " {
	$STA wl hw_txchain 
}

UTF::Try "ibss_gmode" {
	$STA wl ibss_gmode
}

UTF::Try "iscan_s " {
	$STA wl iscan_s 
}

UTF::Try "iscanresults" {
	$STA wl iscanresults 
}

UTF::Try "isup" {
	$STA wl isup 
}

#UTF::Try "ldpc_cap" {
#$STA wl ldpc_cap
#}

UTF::Try "legacylink" {
	$STA wl legacylink
}


UTF::Try "list" {
	$STA wl list
}

UTF::Try "longpkt" {
	$STA wl mpc 0
	$STA wl up
	$STA wl longpkt
}

UTF::Try "longtrain" {
	$STA wl longtrain
}

UTF::Try "lrl" {
	$STA wl lrl
}

UTF::Try "manfinfo" {
	$STA wl manfinfo
}

UTF::Try "maxpower" {
	$STA wl maxpower
}

UTF::Try "mbss" {
	$STA wl mbss
}
 
UTF::Try "mimo_bw_cap" {
	$STA wl mimo_bw_cap 
}

UTF::Try "mimo_preamble" {
	$STA wl mimo_preamble  
}


UTF::Try "mimo_ss_stf" {
	$STA wl mimo_ss_stf
}

UTF::Try "mimo_txbw" {
	$STA wl mimo_txbw
}

UTF::Try "monitor" {
	$STA wl monitor
}

UTF::Try "mpc" {
	$STA wl mpc
}

UTF::Try "napping_mode" {
	$STA wl napping_mode
}

UTF::Try "nmode" {
	$STA wl nmode
}

UTF::Try "noise" {
	$STA wl noise
}

UTF::Try "nrate" {
	$STA wl nrate
}

UTF::Try "nvram_dump" {
	$STA wl nvram_dump
}

UTF::Try "nvram_source" {
	$STA wl nvram_source
} 

UTF::Try "obss_coex " {
	$STA wl obss_coex 
}

UTF::Try "otpdump " {
	$STA wl otpdump 
}

UTF::Try "otplock " {
	$STA wl otplock 
}

UTF::Try "otpw" {
	$STA wl otpw 
}

UTF::Try "out" {
	$STA wl mpc 0 
	$STA wl up
	$STA wl out
}

UTF::Try "patrim" {
	$STA wl patrim 
}

UTF::Try "pavars" {
	$STA wl pavars
}

UTF::Try "phy_activecal" {
	$STA wl phy_activecal
}

UTF::Try "phy_antsel" {
	$STA wl phy_antsel 
}

UTF::Try "phy_bphy_evm " {
	$STA wl phy_bphy_evm 
}

UTF::Try "phy_bphy_rfcs " {
	$STA wl phy_bphy_rfcs 
}

UTF::Try "phy_est_power" {
	$STA wl phy_est_power
}

UTF::Try "phy_fixed_noise" {
	$STA wl phy_fixed_noise
}

UTF::Try "phy_forcecal" {
	$STA wl phy_forcecal
}

UTF::Try "phy_forceimpbf" {
	$STA wl phy_forceimpbf
}

UTF::Try "phy_forcesteer" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_forcesteer 1
	$STA wl phy_forcesteer 
	$STA wl phy_forcesteer 0
	$STA wl phy_forcesteer 
}

UTF::Try "phy_idletssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_idletssi
}
 
UTF::Try "phy_percal" {
	$STA wl phy_percal 3  
} 


UTF::Try "phy_rssi_ant" {
	$STA wl phy_rssi_ant
}

UTF::Try "phy_rxant_config" {
	$STA wl phy_rxant_config
}

UTF::Try "phy_scraminit" {
	$STA wl phy_scraminit
}

UTF::Try "phy_setrptbl" {
	$STA wl phy_setrptbl
}


UTF::Try "phy_sromtempsense" {
	$STA wl phy_sromtempsense   
}

UTF::Try "phy_tempsense" {
	$STA wl phy_tempsense
}

UTF::Try "phy_test_idletssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_test_idletssi 2
}


UTF::Try "phy_test_tssi" {
	$STA wl mpc 0
	$STA wl up
	$STA wl phy_test_tssi 45
}

UTF::Try "phy_txant_config" {
	$STA wl phy_txant_config
}


UTF::Try "phy_txpwrctrl" {
	$STA wl phy_txpwrctrl 
}

UTF::Try "phy_txpwrindex" {
	$STA wl phy_txpwrindex 
}


UTF::Try "phy_txrx_chain" {
	$STA wl phy_txrx_chain 
}

UTF::Try "phy_watchdog" {
	$STA wl phy_watchdog
}


UTF::Try "phyreg" {
	$STA wl band a
	$STA wl band 
	$STA wl up
	$STA wl phyreg 1 a
	$STA wl band b
	$STA wl band
	$STA wl phyreg 1 b  
}

UTF::Try "phytype" {
	$STA wl phytype
}

UTF::Try "pktcnt" {
	$STA wl phycnt
}


UTF::Try "pkteng_maxlen" {
	$STA wl pkteng_maxlen
}

UTF::Try "pkteng_start" {
	$STA wl pkteng_start
}

UTF::Try "pkteng_stats" {
	$STA wl pkteng_stats
}

UTF::Try "pkteng_stop" {
	$STA wl up
	$STA wl pkteng_stop tx
}


UTF::Try "plltest" {
	$STA wl plltest
}


UTF::Try "pll_config" {
	$STA wl plltest_config
}


UTF::Try "plltest_delay" {
	$STA wl plltest_delay
}

UTF::Try "PM" {
	$STA wl PM
} 

UTF::Try "povars" {
	$STA wl povars
} 

UTF::Try "primary_key" {
	$STA wl primary_key 1
	$STA wl primary_key 
}




UTF::Try "promisc" {
	$STA wl promisc
} 

#UTF::Try "radioreg" {

#	$STA wl mpc 0
#	$STA wl up
#	$STA wl band a
#	$STA wl clk 
#	$STA wl radioreg 1 cr0
#}

UTF::Try "rate" {
	$STA wl rate
}

UTF::Try "rateset" {
	$STA wl rateset
}

UTF::Try "rdvar" {
	$STA wl rdvar 1
	$STA wl rdvar 
}

UTF::Try "restart" {
	$STA wl restart
}

UTF::Try "revinfo" {
	$STA wl revinfo
}


UTF::Try "rpcalvars" {
	$STA wl rpcalvars
}

UTF::Try "rsdb_corempc" {
	$STA wl rsdb_corempc 
}


UTF::Try "rsdb_mode" {
	$STA wl rsdb_mode 
}

UTF::Try "rssi" {
	$STA wl rssi 
}

UTF::Try "rtsthresh" {
	$STA wl rtsthresh 
}


UTF::Try "rxchain" {
	$STA wl rxchain 
}

UTF::Try "rxstreams" {
	$STA wl rxstreams	
}

UTF::Try "scan" {
	$STA  wl mpc 0
	$STA  wl up
	$STA  wl isup
	$STA wl scan
}

UTF::Try "scanresults" {
	$STA wl scanresults	
}

UTF::Try "scansuppress" {
	$STA wl scansuppress	
}


UTF::Try "seq_delay " {
	$STA wl seq_delay
}

UTF::Try "seq_start" {
	$STA wl seq_start
}

UTF::Try "seq_stop" {
	$STA wl seq_stop
}

UTF::Try "set_pmk" {
	$STA wl set_pmk
}

UTF::Try "sgi_rx" {
	$STA wl sgi_rx
}

UTF::Try "sgi_tx" {
	$STA wl sgi_tx
}

UTF::Try "shortslot_override" {
	$STA wl shortslot_override
}

UTF::Try "slow_timer" {
	$STA wl slow_timer
}


UTF::Try "snr" {
	$STA wl snr
}

UTF::Try "spatial_policy" {
	$STA wl spatial_policy
}

UTF::Try "spect" {
	$STA wl spect
}

UTF::Try "srcrc" {
	$STA wl srcrc
}


UTF::Try "srdump" {
	$STA wl srdump
}

UTF::Try "srl" {
	$STA wl srl
}

UTF::Try "srwrite" {
	$STA wl srwrite
}

UTF::Try "ssid" {
	$STA wl ssid
}

UTF::Try "status" {
	$STA wl status
}

UTF::Try "stbc_rx" {
	$STA wl stbc_rx
}

UTF::Try "stbc_tx" {
	$STA wl stbc_tx
}

UTF::Try "stf_ss_auto" {
	$STA wl stf_ss_auto
}

UTF::Try "subband_idx" {
	$STA wl subband_idx
}

UTF::Try "subband5Gver" {
	$STA wl subband5Gver
}

UTF::Try "sup_wpa" {
	$STA wl sup_wpa
}

UTF::Try "tempsense_disable" {
	$STA wl tempsense_disable
}

UTF::Try "tssi" {
	$STA wl mpc 0
	$STA wl up	
	$STA wl band a	
	$STA wl tssi
	$STA wl band b
	$STA wl tssi
}

UTF::Try "txant" {
	$STA wl txant
}

UTF::Try "txbf" {
	$STA wl txbf
}

UTF::Try "txbf_bfe_cap" {
	$STA wl txbf_bfe_cap
}

UTF::Try "txbf_bfr_cap" {
	$STA wl txbf_bfr_cap
}

UTF::Try "txbf_imp" {
	$STA wl txbf_imp
}

UTF::Try "txbf_timer" {
	$STA wl txbf_timer
}

UTF::Try "txchain" {
	$STA wl txchain
}

UTF::Try "txcore" {
	$STA wl txcore  
}

UTF::Try "txinstpwr" {
	$STA wl txinstpwr  
}


UTF::Try "txpwr1" {
	$STA wl txpwr1
}

UTF::Try "txstreams" {
	$STA wl txstreams
}

UTF::Try "ulb_mode" {
	$STA wl ulb_mode
}

UTF::Try "up" {
	$STA wl up
}



UTF::Try "ver" {
	$STA wl up
}

UTF::Try "vht_features" {
	$STA wl vht_features
}

UTF::Try "vhtmode" {
	$STA wl vhtmode
}

UTF::Try "wd_disable" {
	$STA wl wd_disable
}

UTF::Try "wowl" {
	$STA wl wowl
}

UTF::Try "wowl_activate" {
	$STA wl wowl_activate
}

UTF::Try "wowl_clear" {
	$STA wl wowl_clear
}

UTF::Try "wowl_dngldown" {
	$STA wl wowl_dngldown
}

UTF::Try "wpa_auth" {
	$STA wl wpa_auth
}

UTF::Try "wpa_cap" {
	$STA wl  wpa_cap
}


UTF::Try "wsec" {
	$STA wl  wsec
}

UTF::Try "wsec_test" {
	$STA wl up
	$STA wl wsec_test mic_error 0x0001 replay 0x0002 icv_error 0x0004 act_error 0x0008 disassoc_error 0x0010 deauth_error 0x0020
}




UTF::Try "$STA Channel Test 2g" {

	UTF::Try "$STA Channel 1" {
	$STA wl chanspec 1
	}
	UTF::Try "$STA Channel 2" {
	$STA wl chanspec 2
	}
	UTF::Try "$STA Channel 3" {
	$STA wl chanspec 3
	}
	UTF::Try "$STA Channel 4" {
	$STA wl chanspec 4
	}
	UTF::Try "$STA Channel 5" {
	$STA wl chanspec 5
	}
	UTF::Try "$STA Channel 6" {
	$STA wl chanspec 6
	}
	UTF::Try "$STA Channel 7" {
	$STA wl chanspec 7
	}
	UTF::Try "$STA Channel 8" {
	$STA wl chanspec 8
	}
	UTF::Try "$STA Channel 9" {
	$STA wl chanspec 9
	}
	UTF::Try "$STA Channel 10" {
	$STA wl chanspec 10
	}
	UTF::Try "$STA Channel 11" {
	$STA wl chanspec 11
	}
	
}
	
	

	
  
   
UTF::Try "$STA Channel Test 5g" {

	$STA wl band a

UTF::Try "$STA Channel 36" {
	$STA wl chanspec 36
	}
UTF::Try "$STA Channel 40" {
	$STA wl chanspec 40
	}
UTF::Try "$STA Channel 44" {
	$STA wl chanspec 44
	}
UTF::Try "$STA Channel 48" {
	$STA wl chanspec 48
	}
UTF::Try "$STA Channel 52" {
	$STA wl chanspec 52
	}
UTF::Try "$STA Channel 56" {
	$STA wl chanspec 56
	}
UTF::Try "$STA Channel 60" {
	$STA wl chanspec 60
	}
UTF::Try "$STA Channel 64" {
	$STA wl chanspec 64
	}
UTF::Try "$STA Channel 100" {
	$STA wl chanspec 100
	}
UTF::Try "$STA Channel 104" {
	$STA wl chanspec 104
	}
UTF::Try "$STA Channel 108" {
	$STA wl chanspec 108
	}
UTF::Try "$STA Channel 112" {
	$STA wl chanspec 112
	}
UTF::Try "$STA Channel 116" {
	$STA wl chanspec 116
	}
UTF::Try "$STA Channel 120" {
	$STA wl chanspec 120
	}
UTF::Try "$STA Channel 124" {
	$STA wl chanspec 124
	}
UTF::Try "$STA Channel 128" {
	$STA wl chanspec 128
	}
UTF::Try "$STA Channel 132" {
	$STA wl chanspec 132
	}
UTF::Try "$STA Channel 136" {
	$STA wl chanspec 136
	}
UTF::Try "$STA Channel 140" {
	$STA wl chanspec 140
	}
UTF::Try "$STA Channel 149" {
	$STA wl chanspec 149
	}
UTF::Try "$STA Channel 153" {
	$STA wl chanspec 153
	}
UTF::Try "$STA Channel 157" {
	$STA wl chanspec 157
	}
UTF::Try "$STA Channel 161" {
	$STA wl chanspec 161
	}
UTF::Try "$STA Channel 165" {
	$STA wl chanspec 165
	}

}






 

    
    # If requested, unload the driver.
    if {!$(nounload) && !$(noinit)} {
        UTF::Try "$STA: unload driver" {
            $STA unload
        }

	if {$(musta) != ""} {
	    foreach MUSTA $(musta) {
	    	UTF::Try "$MUSTA: unload driver" {
		    $MUSTA unload
		}
	    }
	}
    }
    catch {$STA deinit}

    if {$(musta) != ""} {
	foreach MUSTA $(musta) {
	    catch {$MUSTA deinit}
	}
    }






}





#============== proc setup_summaries ================================
# Proc setup_summaries initialize summary web pages and related 
# global variables.
#====================================================================
proc setup_summaries {AP STA titleap } {

    # Get testrig name
    UTF::setup_config_testrig


}

#============== proc update_summaries ===============================
# # Proc for updating summary web pages
#====================================================================
proc update_summaries {cmd args} {
    UTF::Message LOG $::localhost "update_summaries cmd=$cmd args=$args"
        
    # If necessary, log the device info on all summary files.
    # For cmd=ver, args are: device name, softap flag, titleap flag
    if {$cmd == "ver"} {
        set device [lindex $args 0]
        set softap [lindex $args 1]
        set titleap [lindex $args 2]

        # Get hardware info & clean it up.
        set hw_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set hw_ver "OEM"
        } else {
            set catch_resp [catch "set hw_ver \[$device whatami\]" catch_msg]
            if {[llength $hw_ver] > 1} {
                set hw_ver [lrange $hw_ver 1 end] ;# drop UTF object name
            }
        }
        regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification

        # Get host OS version
        set os_ver ""
        if {$titleap && $::is_oem_ap == 1} {
            set os_ver "OEM"
        } else {
            set catch_resp [catch "set os_ver \[UTF::check_host_os $device\]" catch_msg]
        }

        # Get driver software version
        set wl_ver ""
        if {$titleap} {
            if {$::is_oem_ap == 1} {
               set wl_ver "OEM"
            } else {
                if {$softap} {
                    # Soft AP
                    set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
                } else {
                    # Real AP
                    set catch_resp [catch "set wl_ver \[$device nvram get os_version\]" catch_msg]
                }
            }
        } else {
            # STA
            set catch_resp [catch "set wl_ver \[$device wl ver\]" catch_msg]
        }

        # Add device info to each summary page
        UTF::Message LOG $::localhost  "hw_ver=$hw_ver os_ver=$os_ver wl_ver=$wl_ver"
       
        return
    }

    # If necessary, close all the summary files

    # Code for cmd=start|end

}

#============== Main wl_commands test ===============================
UTF::Test wl_commands {args} {
      UTF::Getopts "$::wl_commands_getopts" "$::wl_commands_help"
	set ::loop1_counter 0

	



    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }


    # noinit implies nosetup. nosetup is for this script only.
    # noinit is passed to aci1fidha.test & has broader impact than nosetup.
    if {$(noinit)} {
        set (nosetup) 1
    }

    # Router could be a STA running softap code.
    set Router [lindex $(ap) 0]
    if {$(softap)} {
        # Dynamically set -ap flag so Router will be allowed to act as SoftAP.
        $Router configure -ap 1
    }
    set (softap) [UTF::is_softap $Router] ;# Is this a SoftAP?
    set ::is_oem_ap [UTF::is_oem_ap $Router] ;# Is this an OEM AP?
    # puts "(softap)=$(softap) ::is_oem_ap=$::is_oem_ap"

    set (sta) [string trim $(sta)]
    if {$(sta) == ""} {
        error "ERROR: Must specify at least one sta"
    }


	



    foreach STA $(sta) {
        # puts "STA=$STA"
    
            UTF::check_sta_type $STA $::sta_type_list

        if {$STA == $Router} {
            error "ERROR: Router=$Router EQ STA=$STA, need to use 2 different devices!"
        }
    }

    # If developer images were specified, they take precedance over tag & date.
    # Router options.
    foreach Router $(ap) {
    	if {$::is_oem_ap == 0} {
            if {$(trx) ne ""} {
            	$Router configure -image $(trx) -date {}
            } elseif {$(tag) != ""} {
            	# tag is depracated, prefer rtrtag.
             	$Router configure -tag $(tag) -date {}
            } elseif {$(rtrtag) != ""} {
            	$Router configure -tag $(rtrtag) -date {}
            }
    	}
    }

    # STA options
    foreach STA $(sta) {
        if {$(bin) != ""} {
            $STA configure -image $(bin) -date {}
        } elseif {$(statag) != ""} {
            $STA configure -tag $(statag) -date {}
        }

        # dhd_image option applies only to the DHD objects.
        if {$(stadhd) ne ""} {
            if {[UTF::check_host_type $STA DHD]} {
                $STA configure -dhd_image $(stadhd)
            }
        }
    
        # dongleimage option applies only to the WinDHD object.
        if {$(windhdbin) ne ""} {
            if {[UTF::check_host_type $STA WinDHD]} {
                $STA configure -dongleimage $(windhdbin)
            }
        }
    }

    # Depracated date will override newer rtrdate & stadate options.
    # Done for backwards comptibility.
    if {$(date) != ""} {
        set (rtrdate) $(date)
        set (stadate) $(date)
    }

    # Add optional dates.
    if {$(rtrdate) != "" && $::is_oem_ap == 0} {
	foreach Router $(ap) {
            $Router configure -date $(rtrdate)
    	}
    }
    if {$(stadate) != ""} {
        foreach item $(sta) {
            $item configure -date $(stadate)
        }
    }

    # Get build name for use in report email subject.
    # When multiple STA are tested, they USUALLY use the same build.
    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(sta) 0]
    }   
    if {[set build [$item cget -image]] eq ""} {
        set build [$item cget -tag]
    }
    if {$build eq "NIGHTLY"} {
        set build "TOT"
    }

    # (branch) is used for comparison over time. For private builds
    # this should be specified explicitly so the tests know which
    # branch to test. (branch) defaults to auto.
    if {$(branch) eq ""} {
        if {[regexp {/} $build]} {
            error "Unable to determine branch name from build.  Please specify -branch"
        }
        set (branch) $build
    }

    # Truncate branch name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # aci1fidha.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list $build
    }

    # This script may be nested inside another higher level script. In this
    # case, setup_testbed_info may have already been run. It is also possible
    # that the lists of devices has been pared down to reduce the items being
    # tested. So we need to be careful and not modify the preparations made
    # by the higher level script.
    if {[info exists ::endpoint_device_list] &&\
        [info exists ::lan_peer_sta_list] &&\
        [info exists ::wan_peer_sta_list]} {
        UTF::Message INFO "" "using existing setup_testbed_info"
        if {![info exists ::UTF::trailer_info]} {
            set ::UTF::trailer_info "<br>Missing testbed info!<br>"
        }
    } else {
        UTF::Message INFO "" "running setup_testbed_info"
        set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]
    }

    # Create empty summary table. If there is a higher level calling script,
    # UTF will keep the existing summary table & related object and ignore
    # this script.
    set ::summaryinfo [UTF::setup_report_table]
    append ::summaryinfo "</table>"

    set email_subject [UTF::setup_email_subject $(title)]
    UTF::Message INFO "$::localhost" "email_subject=$email_subject"

    # Main test report web page starts here.
    UTF::WrapSummary $UTF::SummaryDir $email_subject $::summaryinfo $(email) {

        set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

        # Add a web link to the test.log file
        UTF::Try "Link to test.log" {
            return "html: <a href=\"./test.log\">test.log</a>"
        }

	# For comparison test, add additional web link to composite graph page for quick access purpose
	# The empty .htm file will be symlinked to the real file later 



        # Setup testbed. Some users may turn off AP radios!!!
        if {!$(noinit) && !$(nosetup)} {
            UTF::setup_testbed
        }

        # UTF::Message LOG "" "pid=[pid]"

        # Set router text msg.
        if {$(softap)} {
            set msg "SoftAP"
        } else {
            set msg "Router"
        }

        # restoreaponly implies noapload
        if {$(restoreaponly)} {
            set (noapload) 1
        }

        # For AP and STA comparison tests 
        set ::saved_ResultsFilenames ""
        set ::file_appended 0
        set ::sta_counter 0
	set ::ap_counter 0

	


        foreach AP $(ap) {
	    UTF::Message LOG $::localhost "ap=$AP"
	    set Router $AP
	    # User may want testbed used as is.
            if {!$(noinit) && !$(nosetup) && $::is_oem_ap == 0} {
            	catch "$Router power on"
            	if {!$(noapload)} {
                    set catch_msg ""

                    UTF::Try "$Router Find $msg Image" {
                    	set catch_resp [catch {$Router findimages} catch_msg]
                    	$Router configure -image $catch_msg ;# needed for updating title
                    	if {$catch_resp == 0} {
                            return $catch_msg
                    	} else {
                            error $catch_msg
                    	}
                    }

                    # Add report summary table row for Router.
                    set id [UTF::get_build_id $catch_msg]
                    set notes [UTF::get_build_notes $catch_msg]
                    set status [UTF::get_build_status $catch_msg $catch_resp]
                    set ::summaryinfo [UTF::update_report_add $::summaryinfo $Router $(trx) $(rtrtag) $(rtrdate) $id $notes $status]

                    # Halt tests if AP image not found.
                    # Throwing error outside UTF::Try causes framework error.
                    if {$catch_resp != 0} {
                    	UTF::Try "Could not find $msg Image" {
                            error "Halting tests"
                    	}
                    	error "Halting tests"
                    }

                    UTF::Try "$Router Load $msg Image" {
                    	if {$(softap)} {
                            # SoftAP
                            set catch_resp [catch {UTF::load_sta_retry $Router} catch_msg]
                    	} else {
                            # RealAP, may skip restoring AP defaults.
                            if {$(norestore)} {
                            	set catch_resp [catch {UTF::load_rtr_retry $Router -norestore} catch_msg]
                            } else {
                            	set catch_resp [catch {UTF::load_rtr_retry $Router} catch_msg]
                            }
                        }
                        if {$catch_resp != 0} {
                            error $catch_msg
                    	}
                    	return "[$Router whatami] $catch_msg"
                    }

                    # Halt tests if AP not loaded. AP may have recovered or loaded OK on the retry.
                    # Throwing error outside UTF::Try causes framework error.
                    # set catch_resp 1 ;# test code
                    if {$catch_resp != 0 && ![string match -nocase "*try*pass:*" $catch_msg] &&\
                    	![regexp -nocase "removed.*rebooting" $catch_msg] &&\
                    	![regexp -nocase "devcon.*completed" $catch_msg] && \
                    	![regexp -nocase "recovered" $catch_msg]} {
                    	UTF::Try "Could not load $msg Image" {
                            UTF::Message LOG "$Router" "catch_resp=$catch_resp catch_msg=$catch_msg"
                            error "Halting tests"
                    	}
                        error "Halting tests"
                    }

                    # Update the report header table with actual OS & hw versions.
                    set ::summaryinfo [UTF::update_report_hwinfo $::summaryinfo]

                    # Update report title with actual TAG numbers
                    UTF::update_report_title $Router

            	} elseif {!$(restoreaponly)} {
                    # Reload the AP
                    UTF::Try "$Router Reload $msg" {
                    	if {$(softap)} {
                            UTF::reload_sta $Router
                    	} else {
                            UTF::reload_rtr $Router
                    	}
                    }
                } 

                # If router is not responding, halt the tests.
                # This command works for RealAP & SoftAP.
                set catch_resp [catch "set resp \[$Router wl ver\]" catch_msg]
                if {$catch_resp != 0} {
                    error "$Router not responding, Halting tests! $catch_msg"
            	}
            }

            # Show AP hardware, same as we do for STA.
            UTF::Try "$Router $msg Hardware" {
            	if {$::is_oem_ap == 0} {
                    set hw_ver [$Router chipname]
            	} else {
                    set hw_ver OEM
            	}
            	regsub -all {\s} $hw_ver "_" hw_ver ;# Rawleys specification
            	return $hw_ver
            }


            # Test each STA in list.
       
		# This is regular test and we loop through each STA.
            	foreach STA $(sta) {
            	    setup_summaries $Router $STA $(titleap) \
                    	
            	    # Call proc main_wl_commands for each STA
     	    	    main_wl_commands $Router $STA

	    	    incr ::sta_counter
            	}
	

	    incr ::ap_counter

            # Unload softap driver if necessary.
            if {$(softap) && !$(nounload) && !$(noinit)} {
            	UTF::Try "$Router: unload driver" {
                    $Router unload
                }
            }
	} ;# end of foreach AP
	#for the rate loop
	   incr ::loop1_counter
	}
	

set ::summaryinfo [UTF::update_report_testtime $::summaryinfo]
	# Posting to dbux
    	if {!$(nodbuxpost)} {
            UTF::Try "Post test info to dbux" {
            	if {$(bin) != ""} {
                    UTF::post_to_dbux $STA 1
            	} else {
                    UTF::post_to_dbux $STA 0
            	}
            }
        }

# Do optional post test analysis. The "" passes the unnamed options array.
UTF::do_post_test_analysis wl_commands.test ""
}


}
