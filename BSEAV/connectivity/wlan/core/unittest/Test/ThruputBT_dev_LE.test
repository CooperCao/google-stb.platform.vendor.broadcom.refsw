#!/bin/env utf
# -*-tcl-*-

# To get online help, type: Test/ThruputBT_dev_LE.test -h

# $Id: fd837008603dc685bff5a9e2231bc5979bf8d93d $
# $Copyright Broadcom Corporation$
#
# Incorporates code changes necessary for BLE support
# Profiles include BLE baseline, ACL/BLE coex, WLAN/BLE coex, and WLAN/ACL/BLE coex
# default perftime 10, perfsize 5

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set ::ThruputBT_dev_LE_help "\n\nBasic usage: Test/ThruputBT_dev_LE.test ble_dut ble_ref <options>\
	\n\nThis script does a thruput test on 2 BlueTooth LE enabled devices. Optionally, iperf\
	\ntraffic can be run concurrently between 2 WLAN devices. ble_dut & ble_ref\
	\nare the BLE object STA names defined in your config file.\
	\n\nprofile 0: runs only BLE traffic on the existing connection\
	\nprofile 1: runs only WLAN iperf traffic on the existing connection\
	\nprofile 2: runs both BLE & WLAN traffic on the existing connections\
	\nprofile 3: runs BLE & ACL coex traffic on the existing connections\
	\nprofile 4: runs BLE, ACL & WLAN triple coex traffic on the existing connections\
	\n\nvalid options are:\
	\n -utfconf path		Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set ::ThruputBT_dev_LE_getopts {
	{ble_dir.arg "bidirectional"		"BLE test direction: bidirectional dut2ref ref2dut"}
	{bt_dir.arg "bidirectional"			"BT test direction: bidirectional dut2ref ref2dut"}
	{bt_pkt.arg auto					"BT packet type for connection"}
	{bt_test.arg "acl"					"BT test type: acl, ble (type none is allowed for profile 1)"}
	{bt_slave_test.arg "0"				"BT master or slave test"}
	{btclone.arg ""						"btdev for BT traffic stream identification"}
	{btrefclone.arg ""					"refdev for BT traffic stream identification"}
	{handle_acl_master.arg ""			"ACL handle for existing bt_master connection, default is to use handle stored in object"}
	{handle_acl_slave.arg ""			"ACL handle for existing bt_slave connection, default is to use handle stored in object"}
	{handle_le_master.arg 64			"Handle for existing ble_master connection, default is to use handle stored in object"}
	{handle_le_slave.arg 64				"Handle for existing ble_slave connection, default is to use handle stored in object"}
	{history.arg 30						"Performance history samples to keep in perfcache data"}
	{key.arg ""							"Keys to keep perfcache data separated by test, sta, etc"}
	{perfint.arg 2						"Test interval in seconds for each test sample"}
	{perfloop.arg 1						"Total performance test iterations"}
	{perfsize.arg 5						"Number of samples stored in each entry of controlchart & perfcache file"}
	{perftime.arg 10					"Total time duration, in seconds, for each performance tests"}
	{profile.arg 2						"See above descriptions"}
	{title.arg ""						"Title text for time plot graph"}
	{window.arg 512k					"Tcp Window for iperf tests"}
	{wlan_dir.arg "bidirectional"		"WLAN test direction: bidirectional dut2tg tg2dut"}
	{wlan_dut.arg ""					"optional STA object name for WLAN DUT"}
	{wlan_tg.arg ""						"optional STA object name for WLAN traffic generator"}
	{wlan_relay.arg ""					"optional STA object name for WLAN DUT relay"}
}

# Setup online help info.
UTF::setup_help $::ThruputBT_dev_LE_help $::ThruputBT_dev_LE_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
	set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any
# additional code in this script.

# Load packages
package require UTF
package require UTF::ControlChart
package require UTF::utils
package require UTF::WinBT
package require UTF::Test::ConnectBTdevices

namespace eval ThruputBT_dev_LE {}
package provide UTF::Test::ThruputBT_dev_LE 2.0

#======================= Common procs for this test suite =====================

#======================= setup ================================================
# Setup routine for throughput tests.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# array1 is normally set to "" to access the unamed array of calling
# options parsed by the calling routine.
# Returns nothing, throws errors as needed.
#==============================================================================
proc ThruputBT_dev_LE::setup {ble_dut ble_ref bt_dut bt_ref array1} {
	upvar $array1 array2 ;# gives R/W access to array1

	# Check both BT STA's exist and are correct type
	UTF::check_sta_type $bt_dut WinBT
	UTF::check_sta_type $bt_ref WinBT
	
	# Check BT STAs are different
	if {$bt_dut == $bt_ref} {
		error "ThruputBT_dev_LE setup ERROR: bt_dut=$bt_dut MUST NOT be same as\
			bt_ref=$bt_ref!"
	}
	# same for BLE devices
	if {$ble_dut == $ble_ref} {
		error "ThruputBT_dev_LE setup ERROR: ble_dut=$ble_dut MUST NOT be same as\
			ble_ref=$ble_ref!"
	}

	UTF::Message DEBUG_LE "" "\n Entering ThruputBT_dev_LE::setup\n"
	
	# If either WLAN STA is specified, then they must both exist,
	# be the correct type and be different.
	set ::ThruputBT_dev_LE::wlan_dut $array2(wlan_dut)
	set ::ThruputBT_dev_LE::wlan_dut [string trim $::ThruputBT_dev_LE::wlan_dut]

	# HSIC case: when wlan_relay present in conf file
	set ::ThruputBT_dev_LE::wlan_relay $array2(wlan_relay)
	set ::ThruputBT_dev_LE::wlan_relay [string trim $::ThruputBT_dev_LE::wlan_relay]
	if { $::ThruputBT_dev_LE::wlan_relay != "" } {
		UTF::Message DEBUG "" "::ThruputBT_dev_LE::wlan_relay present: $::ThruputBT_dev_LE::wlan_relay"
	} else {
		UTF::Message DEBUG "" "::ThruputBT_dev_LE::wlan_relay not present."
	}

	set ::ThruputBT_dev_LE::wlan_tg $array2(wlan_tg)
	set ::ThruputBT_dev_LE::wlan_tg [string trim $::ThruputBT_dev_LE::wlan_tg]
	if {$::ThruputBT_dev_LE::wlan_dut != "" || $::ThruputBT_dev_LE::wlan_tg != ""} {
		if {$::ThruputBT_dev_LE::wlan_dut == "" || $::ThruputBT_dev_LE::wlan_tg == ""} {
			error "ThruputBT_dev_LE setup ERROR: When one WLAN device is specified,\
				they both must be specified, wlan_dut=$::ThruputBT_dev_LE::wlan_dut\
				wlan_tg=$::ThruputBT_dev_LE::wlan_tg"
		}
		UTF::check_sta_type $::ThruputBT_dev_LE::wlan_dut "$::coex_sta_type_list"
		UTF::check_sta_type $::ThruputBT_dev_LE::wlan_tg Linux
		if {$::ThruputBT_dev_LE::wlan_dut == $::ThruputBT_dev_LE::wlan_tg} {
			error "ThruputBT_dev_LE setup ERROR: wlan_dut=$::ThruputBT_dev_LE::wlan_dut MUST\
				NOT be same as wlan_tg=$::ThruputBT_dev_LE::wlan_tg!"
		}
	}

	# Validate the BT test direction.
	set ::ThruputBT_dev_LE::bt_dir $array2(bt_dir)
	set ::ThruputBT_dev_LE::bt_dir [string trim $::ThruputBT_dev_LE::bt_dir]
	set ::ThruputBT_dev_LE::bt_dir [string tolower $::ThruputBT_dev_LE::bt_dir]
	set bt_dir_list "bidirectional dut2ref ref2dut"
	set i [lsearch -exact $bt_dir_list $::ThruputBT_dev_LE::bt_dir]
	if {$i < 0} {
		error "ThruputBT_dev_LE setup ERROR: Invalid bt_dir=$::ThruputBT_dev_LE::bt_dir,\
			must be one of: $bt_dir_list"
	}
	# Same for BLE test direction.
	set ::ThruputBT_dev_LE::ble_dir $array2(ble_dir)
	set ::ThruputBT_dev_LE::ble_dir [string trim $::ThruputBT_dev_LE::ble_dir]
	set ::ThruputBT_dev_LE::ble_dir [string tolower $::ThruputBT_dev_LE::ble_dir]
	set ble_dir_list "bidirectional dut2ref ref2dut"
	set i [lsearch -exact $ble_dir_list $::ThruputBT_dev_LE::ble_dir]
	if {$i < 0} {
		error "ThruputBT_dev_LE setup ERROR: Invalid ble_dir=$::ThruputBT_dev_LE::ble_dir,\
			must be one of: $ble_dir_list"
	}

	# Validate the WLAN test direction.
	set ::ThruputBT_dev_LE::wlan_dir $array2(wlan_dir)
	set ::ThruputBT_dev_LE::wlan_dir [string trim $::ThruputBT_dev_LE::wlan_dir]
	set ::ThruputBT_dev_LE::wlan_dir [string tolower $::ThruputBT_dev_LE::wlan_dir]
	set wlan_dir_list "bidirectional dut2tg tg2dut"
	set i [lsearch -exact $wlan_dir_list $::ThruputBT_dev_LE::wlan_dir]
	if {$i < 0} {
		error "ThruputBT_dev_LE setup ERROR: Invalid wlan_dir=$::ThruputBT_dev_LE::wlan_dir,\
			must be one of: $wlan_dir_list"
	}

	# Set traffic script names based on test type.
	set ::ThruputBT_dev_LE::bt_test $array2(bt_test)
	set ::ThruputBT_dev_LE::bt_test [string trim $::ThruputBT_dev_LE::bt_test]
	set ::ThruputBT_dev_LE::bt_test [string tolower $::ThruputBT_dev_LE::bt_test]
	set ::ThruputBT_dev_LE::bt_slave_test $array2(bt_slave_test)

	UTF::Message DEBUG_LE "" "ThruputBT_dev_LE::bt_test value: $::ThruputBT_dev_LE::bt_test"

	# test devices, where given
	# # #	 set ::ThruputBT_dev_LE::btdev $array2(btclone)
	# # #	 set ::ThruputBT_dev_LE::refdev $array2(btrefclone)
	set ::ThruputBT_dev_LE::btdev $bt_dut
	set ::ThruputBT_dev_LE::refdev $bt_ref

	
	set ::ThruputBT_dev_LE::handle_dut ""
	set ::ThruputBT_dev_LE::handle_ref ""
	set ::ThruputBT_dev_LE::handle_le_dut ""
	set ::ThruputBT_dev_LE::handle_le_ref ""

	# switch statements replaced nested ifs for various bt_test values
	# No SCO/eSCO test support: 2070 boards are not intended for SCO tests
	switch $::ThruputBT_dev_LE::bt_test {
		"acl" {
			set ::ThruputBT_dev_LE::handle_acl_dut $array2(handle_acl_master)
			set ::ThruputBT_dev_LE::handle_dut $::ThruputBT_dev_LE::handle_acl_dut
			set ::ThruputBT_dev_LE::handle_acl_ref $array2(handle_acl_slave)
			set ::ThruputBT_dev_LE::handle_ref $::ThruputBT_dev_LE::handle_acl_ref

			set ::ThruputBT_dev_LE::tx_script common/ThroughputTxTest.pl
			set ::ThruputBT_dev_LE::rx_script common/ThroughputRxTest.pl

		}
		"ble" {
			set ::ThruputBT_dev_LE::handle_le_dut $array2(handle_le_master)
			set ::ThruputBT_dev_LE::handle_le_ref $array2(handle_le_slave)

			set ::ThruputBT_dev_LE::handle_acl_dut $array2(handle_acl_master)
			set ::ThruputBT_dev_LE::handle_dut $::ThruputBT_dev_LE::handle_acl_dut
			set ::ThruputBT_dev_LE::handle_acl_ref $array2(handle_acl_slave)
			set ::ThruputBT_dev_LE::handle_ref $::ThruputBT_dev_LE::handle_acl_ref

			set ::ThruputBT_dev_LE::tx_script common/LEThroughputTxTest.pl
			set ::ThruputBT_dev_LE::rx_script common/LEThroughputRxTest.pl
		}
		"none" {
			# UTF::Message INFO "" "Special case for WLAN test: bt_test is: $::ThruputBT_dev_LE::bt_test"
		}
		default {
			error "ThruputBT_dev_LE setup ERROR: Invalid test bt_test=$::ThruputBT_dev_LE::bt_test,\
				must be one of: acl ble"
		}
	}

# # #	 wlan test runs with no acl handles
	if { $::ThruputBT_dev_LE::bt_test != "none" } {
		if {$::ThruputBT_dev_LE::handle_dut == "" || $::ThruputBT_dev_LE::handle_ref == ""} {
			error "ThruputBT_dev_LE setup ERROR: handles must not be null,\
			handle_dut=$::ThruputBT_dev_LE::handle_dut handle_ref=$::ThruputBT_dev_LE::handle_ref"
		}
	}

	# More initialization & sanity checks on parameters.
	# Checks for \d+ ensure positive integers, so no need to convert to integer.
	set ::ThruputBT_dev_LE::acl_test_count 20000 ;# ACL test count is based on 20000/sec
	set ::ThruputBT_dev_LE::bt_comm_dut [$bt_dut cget -bt_comm]
	set ::ThruputBT_dev_LE::bt_comm_ref [$bt_ref cget -bt_comm]
	set ::ThruputBT_dev_LE::bt_pkt $array2(bt_pkt)
	set ::ThruputBT_dev_LE::current_error_list "" ;# error list for current interation
	if {![info exists ::ThruputBT_dev_LE::erp_cnt]} {
		# Counter is maintained over many test runs.
		set ::ThruputBT_dev_LE::erp_cnt 0
	}
	set ::ThruputBT_dev_LE::fatal_error "" ;# save first fatal error that occurs
	set ::ThruputBT_dev_LE::history $array2(history)
	if {![regexp {^\d+$} $::ThruputBT_dev_LE::history] || $::ThruputBT_dev_LE::history < 1} {
		set ::ThruputBT_dev_LE::history 30
		UTF::Message WARN "$::localhost" "setup history set to $::ThruputBT_dev_LE::history"
	}
	set ::ThruputBT_dev_LE::key $array2(key)
	set ::ThruputBT_dev_LE::need_erp no ;# request for error recovery procedure 
	set ::ThruputBT_dev_LE::perf_int $array2(perfint)
	if {![regexp {^\d+$} $::ThruputBT_dev_LE::perf_int] || $::ThruputBT_dev_LE::perf_int < 1} {
		set ::ThruputBT_dev_LE::perf_int 1 ;# avoids divide by 0 later on.
		UTF::Message WARN "$::localhost" "setup perf_int set to $::ThruputBT_dev_LE::perf_int"
	}
	set ::ThruputBT_dev_LE::perf_loop $array2(perfloop)
	if {![regexp {^\d+$} $::ThruputBT_dev_LE::perf_loop] || $::ThruputBT_dev_LE::perf_loop < 1} {
		set ::ThruputBT_dev_LE::perf_loop 1
		UTF::Message WARN "$::localhost" "setup perf_loop set to $::ThruputBT_dev_LE::perf_loop"
	}
	set ::ThruputBT_dev_LE::perf_size $array2(perfsize)
	if {![regexp {^\d+$} $::ThruputBT_dev_LE::perf_size]} {
		set ::ThruputBT_dev_LE::perf_size 5
		UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT_dev_LE::perf_size"
	}
	if {$::ThruputBT_dev_LE::perf_size > 25} {
		set ::ThruputBT_dev_LE::perf_size 25 ;# ControlChart object limits size
		UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT_dev_LE::perf_size"
	}
	if {$::ThruputBT_dev_LE::perf_size < 2} {
		set ::ThruputBT_dev_LE::perf_size 2 ;# avoids divide by 0 later on.
		UTF::Message WARN "$::localhost" "setup perf_size set to $::ThruputBT_dev_LE::perf_size"
	}
	set ::ThruputBT_dev_LE::perf_time $array2(perftime)
	if {![regexp {^\d+$} $::ThruputBT_dev_LE::perf_time]} {
		# changed perftime default to 10 from 30
		set ::ThruputBT_dev_LE::perf_time 10
		UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT_dev_LE::perf_time"
	}
	if {$::ThruputBT_dev_LE::perf_time > 100000} { 
		set ::ThruputBT_dev_LE::perf_time 100000 ;# prevent integer overflow later on
		UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT_dev_LE::perf_time"
	}
	if {$::ThruputBT_dev_LE::perf_time < 10} { 
		set ::ThruputBT_dev_LE::perf_time 10
		UTF::Message WARN "$::localhost" "setup perf_time set to $::ThruputBT_dev_LE::perf_time"
	}
	set ::ThruputBT_dev_LE::profile $array2(profile)
	set ::ThruputBT_dev_LE::running_error_list "" ;# error list for test with many iterations
	# Keep track of overall running worst time delay introduced by sockets.
	if {![info exists ::ThruputBT_dev_LE::running_max_socket_delay]} {
		set ::ThruputBT_dev_LE::running_max_socket_delay 0
		set ::ThruputBT_dev_LE::running_max_socket_timestamp ""
	}
	set ::ThruputBT_dev_LE::timer_cmds ""
	set ::ThruputBT_dev_LE::title $array2(title)
	set ::ThruputBT_dev_LE::window $array2(window)

	# Set history based on actual groups of samples that will
	# be generated across multiple iterations.
	set predicted_history [expr ($::ThruputBT_dev_LE::perf_time * $::ThruputBT_dev_LE::perf_loop)\
		/($::ThruputBT_dev_LE::perf_int * $::ThruputBT_dev_LE::perf_size)]
	# puts "predicted_history=$predicted_history"
	if {$predicted_history > $::ThruputBT_dev_LE::history} {
		set ::ThruputBT_dev_LE::history $predicted_history
		UTF::Message WARN "$::localhost" "setup for longer test run, history\
			set to $::ThruputBT_dev_LE::history"
	}

	if { $::ThruputBT_dev_LE::wlan_relay == "" } {
		UTF::Message INFO "" "DUT relay not defined."
		array unset array2 wlan_relay
		unset ::ThruputBT_dev_LE::wlan_relay
	}

	# For bt_test = n/a, profile must be 1, wlan only tests.
	if {$::ThruputBT_dev_LE::bt_test == "n/a" && $::ThruputBT_dev_LE::profile != 1} { 
		error "ThruputBT_dev_LE setup ERROR: for bt_test=n/a, profile must be 1"
	}

	# Set sample threshold for declaring a fatal error and invoking
	# error recovery procedure.
	set ::ThruputBT_dev_LE::sample_threshold [expr int(0.7 * $::ThruputBT_dev_LE::perf_size\
		 * $::ThruputBT_dev_LE::perf_loop)]
	if {$::ThruputBT_dev_LE::sample_threshold < 1} {
		set ::ThruputBT_dev_LE::sample_threshold 1
	}
	# puts "::ThruputBT_dev_LE::sample_threshold=$::ThruputBT_dev_LE::sample_threshold"

	# Clean out any time plot data from a previous run.
	set names [array names ::ThruputBT_dev_LE::time_plot_array]
	set names [lsort $names]
	# UTF::Message LOG "$::localhost" "time_plot_array names=$names"
	foreach name $names {
		unset ::ThruputBT_dev_LE::time_plot_array($name)
	}

	# Log the setup data.
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE bt_dut=$bt_dut\
		bt_ref=$bt_ref handle_dut=$::ThruputBT_dev_LE::handle_dut\
		handle_ref=$::ThruputBT_dev_LE::handle_ref bt_dir=$::ThruputBT_dev_LE::bt_dir\
		bt_test=$::ThruputBT_dev_LE::bt_test bt_pkt=$::ThruputBT_dev_LE::bt_pkt\
		profile=$::ThruputBT_dev_LE::profile perfint=$::ThruputBT_dev_LE::perf_int\
		perfloop=$::ThruputBT_dev_LE::perf_loop perfsize=$::ThruputBT_dev_LE::perf_size\
		perftime=$::ThruputBT_dev_LE::perf_time history=$::ThruputBT_dev_LE::history"
	if {$::ThruputBT_dev_LE::wlan_dut != ""} {
		set devList "ThruputBT_dev_LE wlan_dut=$::ThruputBT_dev_LE::wlan_dut\
			wlan_tg=$::ThruputBT_dev_LE::wlan_tg"
		set wDir "wlan_dir=$::ThruputBT_dev_LE::wlan_dir"
		# UTF::Message LOG "$::localhost" "ThruputBT_dev_LE wlan_dut=$::ThruputBT_dev_LE::wlan_dut\
		#	wlan_tg=$::ThruputBT_dev_LE::wlan_tg wlan_dir=$::ThruputBT_dev_LE::wlan_dir"
		if { [info exists ::ThruputBT_dev_LE::wlan_relay] } {
			append devList " wlan_relay=$::ThruputBT_dev_LE::wlan_relay"
		}
#		 UTF::Message LOG "$::localhost" "$devList $wDir"
		 UTF::Message DEBUG_LOG "$::localhost" "Showing devList and wDir: $devList $wDir"
	}

	# For all test profiles except 1, change the BT packet type on both BT devices.
	# Test profile 1 is for WLAN only tests, and there is no guarantee that a BT
	# connection is available to manipulate.

	if {$::ThruputBT_dev_LE::bt_test != "ble" || $::ThruputBT_dev_LE::profile >= 3} {
		# # # UTF::Message DEBUG_LE "" "**** This is non ble type ****"
		if {$::ThruputBT_dev_LE::profile != "1"} {

				### code change necessitated by new BT change: BT DUT only support packet definitions supported by BT Ref
				if {$::ThruputBT_dev_LE::bt_slave_test == 0} {

					### case: master mode --> change BTRef packet type before BTCohost	
					UTF::Message LOG "$::localhost" "Change packet type to $::ThruputBT_dev_LE::bt_pkt"
					$bt_ref change_bt_packet_type $::ThruputBT_dev_LE::handle_ref $::ThruputBT_dev_LE::bt_pkt
					$bt_dut change_bt_packet_type $::ThruputBT_dev_LE::handle_dut $::ThruputBT_dev_LE::bt_pkt   

				} else {

					UTF::Message LOG "$::localhost" "Change packet type to $::ThruputBT_dev_LE::bt_pkt"
					$bt_dut change_bt_packet_type $::ThruputBT_dev_LE::handle_dut $::ThruputBT_dev_LE::bt_pkt
					$bt_ref change_bt_packet_type $::ThruputBT_dev_LE::handle_ref $::ThruputBT_dev_LE::bt_pkt
					# # # UTF::Message DEBUG_LE "$::localhost" "**** End of changing packet type to $::ThruputBT_dev_LE::bt_pkt ****"
				}
		}

	} else {
		# # # skipped for BLE connections
		UTF::Message DEBUG_LE "" "**** This is ble type; skipping ChangeConnectionPacketType ****"

	}

	# # # UTF::Message DEBUG_LE "" "**** End of ThruputBT_dev_LE::setup block. ****"
	UTF::Message DEBUG_LE "" "**** End of ThruputBT_dev_LE::setup block. Wait 3 seconds before starting Throughput semaphores...****" ;# test to see if wait makes any difference
	UTF::Sleep 3
}

#======================= thruput_bt_traffic ===================================
# Routine starts up BT traffic between BT dut & BT ref.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Optional arg direction can be used to override the global direction setting.
# Returns hosts & file handles for parallel process started.
# Updates global variable timer_cmds
#==============================================================================
# added checks for BLE tests; removed iso and SCO/eSCO codes
proc ThruputBT_dev_LE::thruput_bt_traffic {bt_dut bt_ref {direction ""}} {

	UTF::Message DEBUG_LE "" "**** This is ThruputBT_dev_LE::thruput_bt_traffic block. ****"
	
	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_int]} {
		set ::ThruputBT_dev_LE::perf_int 2
	}
	if {![info exists ::ThruputBT_dev_LE::perf_time]} {
		set ::ThruputBT_dev_LE::perf_time 30
	}
	if {![info exists ::ThruputBT_dev_LE::acl_test_count]} {
		set ::ThruputBT_dev_LE::acl_test_count 1000
	}
	if {![info exists ::ThruputBT_dev_LE::tx_script]} {
		if { $::ThruputBT_dev_LE::bt_test == "ble" } {
			set ::ThruputBT_dev_LE::tx_script common/LEThroughputTxTest.pl
		} else {
			set ::ThruputBT_dev_LE::tx_script common/ThroughputTxTest.pl
		}
	}
	if {![info exists ::ThruputBT_dev_LE::rx_script]} {
		if { $::ThruputBT_dev_LE::bt_test == "ble" } {
			set ::ThruputBT_dev_LE::rx_script common/LEThroughputRxTest.pl
		} else {
			set ::ThruputBT_dev_LE::rx_script common/ThroughputRxTest.pl
		}
	}
	if {![info exists ::ThruputBT_dev_LE::bt_comm_ref]} {
		set ::ThruputBT_dev_LE::bt_comm_ref "usb0"
	}
	if {![info exists ::ThruputBT_dev_LE::bt_comm_dut]} {
		set ::ThruputBT_dev_LE::bt_comm_dut "com3@3000000"
	}
	if {![info exists ::ThruputBT_dev_LE::handle_ref]} {
		set ::ThruputBT_dev_LE::handle_ref 12
	}
	if {![info exists ::ThruputBT_dev_LE::handle_dut]} {
		set ::ThruputBT_dev_LE::handle_dut 12
	}

	if { $::ThruputBT_dev_LE::bt_test == "ble" } {

		if {![info exists ::ThruputBT_dev_LE::handle_le_master]} {
			# # # ble ref handle
			set ::ThruputBT_dev_LE::le_handle_master 64 
		}

		if {![info exists ::ThruputBT_dev_LE::handle_le_slave]} {
			# # # ble ref handle
			set ::ThruputBT_dev_LE::le_handle_slave 64
		}
		UTF::Message DEBUG_LE "" "**** Handle settings: le_handle_master: $::ThruputBT_dev_LE::le_handle_master, le_handle_slave: $::ThruputBT_dev_LE::le_handle_slave ****"
	}

	# On occasion, calling routine may wish to use a different
	# traffic direction than the default value. Most of the time
	# the default value is appropriate.
	set direction [string trim $direction]
	set direction [string tolower $direction]
	if {$direction == ""} {
		if {[info exists ::ThruputBT_dev_LE::bt_dir]} {
			set direction $::ThruputBT_dev_LE::bt_dir
		} else {
			set direction bidirectional
		}
	}
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_bt_traffic\
		bt_dut=$bt_dut bt_ref=$bt_ref direction=$direction"

	# Test count controls how long ACL tests run
	set count [expr int($::ThruputBT_dev_LE::perf_time * $::ThruputBT_dev_LE::acl_test_count)]
	set interval [expr int($::ThruputBT_dev_LE::perf_int * 1000)] ;# time in milliseconds

	# Start traffic for dut2ref or bidirectional.
	set results ""
	if {$direction == "dut2ref" || $direction == "bidirectional"} {
		UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_bt_traffic dut2ref"

		# Start up thruput scripts in parallel for test direction dut2ref
		# For each test started up, add another test to stop it in the list
		# of timer_cmds. Otherwise tests try to run for a default of 12.5 minutes.
		# When stopping the tests, it is crucial to stop the TX side first.
		# The semaphores are text strings used by the PERL routines on the
		# target PCs. There is no need to store them in TCL global variables.

		# Start the RX script first on ref.
		if {$::ThruputBT_dev_LE::bt_test == "acl" || $::ThruputBT_dev_LE::bt_test == "ble"} {

			if { $::ThruputBT_dev_LE::bt_test == "ble" } {
				set ::ThruputBT_dev_LE::rSem "LERefThroughputRxSemaphore"
				set ::ThruputBT_dev_LE::tSem "LEDutThroughputTxSemaphore"
			} else {
				set ::ThruputBT_dev_LE::rSem "RefThroughputRxSemaphore"
				set ::ThruputBT_dev_LE::tSem "DutThroughputTxSemaphore"
			}
			
			# no support for iso or SCO/eSCO tests

			### UTF::Message DEBUG_LE "" "**** non iso branch acl or ble block ****"
			if { $::ThruputBT_dev_LE::bt_test != "ble" } {
					UTF::Message DEBUG_LE "" "*** Non ble branch, ref handle: $::ThruputBT_dev_LE::handle_ref, DUT handle: $::ThruputBT_dev_LE::handle_dut ***"
				set fd_ref1 [$bt_ref run_perl_script $::ThruputBT_dev_LE::rx_script\
					$::ThruputBT_dev_LE::bt_comm_ref $::ThruputBT_dev_LE::handle_ref\
					$ThruputBT_dev_LE::rSem $count $interval -rpopen]
				# some delay is needed here
				UTF::Sleep 1
				set fd_dut1 [$bt_dut run_perl_script $::ThruputBT_dev_LE::tx_script\
					$::ThruputBT_dev_LE::bt_comm_dut $::ThruputBT_dev_LE::handle_dut\
					$::ThruputBT_dev_LE::tSem $count $interval -rpopen]
				UTF::Sleep 1
			} else {
				set fd_ref1 [$bt_ref run_perl_script $::ThruputBT_dev_LE::rx_script\
					$::ThruputBT_dev_LE::bt_comm_ref $::ThruputBT_dev_LE::handle_le_ref\
					$ThruputBT_dev_LE::rSem $count $interval -rpopen]
				# some delay is needed here
				UTF::Sleep 1
				set fd_dut1 [$bt_dut run_perl_script $::ThruputBT_dev_LE::tx_script\
					$::ThruputBT_dev_LE::bt_comm_dut $::ThruputBT_dev_LE::handle_le_dut\
					$::ThruputBT_dev_LE::tSem $count $interval -rpopen]
				UTF::Sleep 1
			}
		}

		# For the timer commands, stop TX first
		UTF::Message DEBUG_LE "" "**** timer_cmds ****"
		append ::ThruputBT_dev_LE::timer_cmds " $bt_dut run_perl_script\
			common/ReleaseSemaphore.pl $::ThruputBT_dev_LE::tSem ; after 1000 ;"
		append ::ThruputBT_dev_LE::timer_cmds " $bt_ref run_perl_script\
			common/ReleaseSemaphore.pl $::ThruputBT_dev_LE::rSem ;"

		# Add hosts & file handles to results
		append results " $bt_dut $fd_dut1 $bt_ref $fd_ref1"
	}

	# Start traffic for ref2dut or bidirectional.
	UTF::Message DEBUG_LE "" "**** ThruputBT_dev_LE::thruput_bt_traffic ref2dut or bidir starts here ****"

	if {$direction == "ref2dut" || $direction == "bidirectional"} {
		UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_bt_traffic ref2dut"

		# Start up thruput scripts in parallel for test direction dut2ref
		# For each test started up, add another test to stop it in the list
		# of timer_cmds. Otherwise tests try to run for a default of 12.5 minutes.
		# When stopping the tests, it is crucial to stop the TX side first.
		# The semaphores are text strings used by the PERL routines on the 
		# target PCs. There is no need to store them in TCL global variables.

		# For the timer commands, start the RX first on dut.
		if {$::ThruputBT_dev_LE::bt_test == "acl" || $::ThruputBT_dev_LE::bt_test == "ble"} {
			
		# set semaphore names in accordance with test type; replaces hardcoded names
			if { $::ThruputBT_dev_LE::bt_test == "ble" } {
				set ::ThruputBT_dev_LE::rSem "LEDutThroughputRxSemaphore"
				set ::ThruputBT_dev_LE::tSem "LERefThroughputTxSemaphore"
			} else {
				set ::ThruputBT_dev_LE::rSem "DutThroughputRxSemaphore"
				set ::ThruputBT_dev_LE::tSem "RefThroughputTxSemaphore"
			}

			# added cases for BLE
			if { $::ThruputBT_dev_LE::bt_test != "ble" } {
				set fd_dut2 [$bt_dut run_perl_script $::ThruputBT_dev_LE::rx_script\
					$::ThruputBT_dev_LE::bt_comm_dut $::ThruputBT_dev_LE::handle_dut\
					$::ThruputBT_dev_LE::rSem $count $interval -rpopen]
				# some delay is needed here
				UTF::Sleep 1
				set fd_ref2 [$bt_ref run_perl_script $::ThruputBT_dev_LE::tx_script\
					$::ThruputBT_dev_LE::bt_comm_ref $::ThruputBT_dev_LE::handle_ref\
					$::ThruputBT_dev_LE::tSem $count $interval -rpopen]
				UTF::Sleep 1
			} else {
				set fd_dut2 [$bt_dut run_perl_script $::ThruputBT_dev_LE::rx_script\
					$::ThruputBT_dev_LE::bt_comm_dut $::ThruputBT_dev_LE::handle_le_dut\
					$::ThruputBT_dev_LE::rSem $count $interval -rpopen]
				# some delay is needed here
				UTF::Sleep 1
				set fd_ref2 [$bt_ref run_perl_script $::ThruputBT_dev_LE::tx_script\
					$::ThruputBT_dev_LE::bt_comm_ref $::ThruputBT_dev_LE::handle_le_ref\
					$::ThruputBT_dev_LE::tSem $count $interval -rpopen]
				UTF::Sleep 1
			}

		}

		# For the timer commands, stop TX first
		UTF::Message DEBUG_LE "" "**** Sending command to execute thruput tests. ****"
		append ::ThruputBT_dev_LE::timer_cmds " $bt_ref run_perl_script common/ReleaseSemaphore.pl\
			$::ThruputBT_dev_LE::tSem ; after 1000 ;" 
		append ::ThruputBT_dev_LE::timer_cmds " $bt_dut run_perl_script common/ReleaseSemaphore.pl\
			$::ThruputBT_dev_LE::rSem ;"

		# Add the hosts & file handles to results
		append results " $bt_dut $fd_dut2 $bt_ref $fd_ref2"
	}

	# Thats it.
	return "$results"
}

#======================= thruput_test_stop_timer ==============================
# Routine sets timer to stop BT thruput tests.
# Calling arg delay_sec specifies how long to let the tests run, in seconds.
# Returns timer_id
#==============================================================================
proc ThruputBT_dev_LE::thruput_test_stop_timer {delay_sec} {

	set delay_ms [expr int($delay_sec * 1000)]
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_test_stop_timer\
		 delay_sec=$delay_sec delay_ms=$delay_ms\
		 ::ThruputBT_dev_LE::timer_cmds=$::ThruputBT_dev_LE::timer_cmds"

	# Start timer which will stop the running tests. The timer MUST expire 
	# in order to stop the tests.
	set timer_id [after $delay_ms $::ThruputBT_dev_LE::timer_cmds]
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_test_stop_timer\
		created timer_id=$timer_id"
	return "$timer_id"
}

#======================= thruput_wlan_traffic =================================
# Routine starts up WLAN traffic between WLAN dut & WLAN tg.
# Optional arg direction can be used to override the global direction setting.
# Returns hosts & file handles for parallel process started.
#==============================================================================
proc ThruputBT_dev_LE::thruput_wlan_traffic {{direction ""}} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::wlan_dut]} {
		set ::ThruputBT_dev_LE::wlan_dut cx020_4329SDIO
	}
	if {![info exists ::ThruputBT_dev_LE::wlan_tg]} {
		set ::ThruputBT_dev_LE::wlan_tg lan
	}
	if {![info exists ::ThruputBT_dev_LE::window]} {
		set ::ThruputBT_dev_LE::window 512k
	}
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_int]} {
		set ::ThruputBT_dev_LE::perf_int 2
	}
	if {![info exists ::ThruputBT_dev_LE::perf_time]} {
		set ::ThruputBT_dev_LE::perf_time 30
	}
	if {![info exists ::ThruputBT_dev_LE::wlan_dir]} {
		set ::ThruputBT_dev_LE::wlan_dir bidirectional
	}

	# Check wlan devices are defined.
	if {$::ThruputBT_dev_LE::wlan_dut == "" || $::ThruputBT_dev_LE::wlan_tg == ""} {
		error "ThruputBT_dev_LE thruput_wlan_dut2tg ERROR: WLAN device may not,\
			be null, wlan_dut=$::ThruputBT_dev_LE::wlan_dut wlan_tg=$::ThruputBT_dev_LE::wlan_tg"
	}

	# On occasion, calling routine may wish to use a different
	# traffic direction than the default value. Most of the time
	# the default value is appropriate.
	set direction [string trim $direction]
	set direction [string tolower $direction]
	if {$direction == ""} {
		if {[info exists ::ThruputBT_dev_LE::wlan_dir]} {
			set direction $::ThruputBT_dev_LE::wlan_dir
		} else {
			set direction bidirectional
		}
	}

	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::thruput_wlan_traffic\
		wlan_dut=$::ThruputBT_dev_LE::wlan_dut wlan_tg=$::ThruputBT_dev_LE::wlan_tg\
		direction=$direction"		

	# Tune the TCP windows on both machines. When the test has multiple
	# iterations, only do the tuning for the first iteration. Get & cache
	# the IP address of both devices.
	if {$::ThruputBT_dev_LE::perf_cnt == 1} {
		set itemList "$::ThruputBT_dev_LE::wlan_dut $::ThruputBT_dev_LE::wlan_tg"
		if { [info exists ::ThruputBT_dev_LE::wlan_relay] } {
			append itemList " $::ThruputBT_dev_LE::wlan_relay"
		}
		foreach item $itemList {
			set logname [UTF::get_name $item]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic\
				Tuning TCP"

			# Try to tune the device
			set resp [$item tcptune $::ThruputBT_dev_LE::window]

			# If the OS doesnt allow the TCP stack to be tuned, then we
			# apply the -w option to iperf. This typically only gets used
			# on Windows machines. Supposedly if we apply the -w option to
			# iperf on a Linux machine, the thruput will suffer greatly.
			if {$resp == 1 && $::ThruputBT_dev_LE::window ne 0} {
				set ::ThruputBT_dev_LE::wlan($item,opt) "-w $::ThruputBT_dev_LE::window"
			} else {
				set ::ThruputBT_dev_LE::wlan($item,opt) ""
			}

			# Get the device IP address.
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic\
				Getting IP"	
			set ::ThruputBT_dev_LE::wlan($item,ip) [$item ipaddr]
			# puts "item=$item logname=$logname wlan($item,opt)=$::ThruputBT_dev_LE::wlan($item,opt)\
			#	  wlan($item,ip)=$::ThruputBT_dev_LE::wlan($item,ip)"
			## ? UTF::Message DEBUG "" "item=$item logname=$logname wlan($item,opt)=$::ThruputBT_dev_LE::wlan($item,opt)\
			## ?   wlan($item,ip)=$::ThruputBT_dev_LE::wlan($item,ip)\n"
		}
	}

	# iperf is normally running as a service on all UTF machines, and is
	# supposed to be ready to accept in incoming iperf TCP connections at
	# all times.

	# Start wlan iperf traffic for dut2tg or bidirectional.
	# To get the data with a timestamp from the remote host, we use a
	# wrapper script, iperf_timestamps.tcl. 
	set results ""

	## ? UTF::Message DEBUG "" "\n$::ThruputBT_dev_LE::wlan_dut is type: [$::ThruputBT_dev_LE::wlan_dut hostis]\n"
	set wdut_type [$::ThruputBT_dev_LE::wlan_dut hostis]

	if {$direction == "dut2tg" || $direction == "bidirectional"} {

		if { $wdut_type != "HSIC" } {

			UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic non HSIC branch.\n"
			# Start iperf as parallel task via rpopen.
			set logname [UTF::get_name $::ThruputBT_dev_LE::wlan_dut]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic dut2tg"
			set fd_dut [$::ThruputBT_dev_LE::wlan_dut rpopen iperf_timestamps.tcl\
			-c $::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_tg,ip)\
			-i $::ThruputBT_dev_LE::perf_int -t $::ThruputBT_dev_LE::perf_time -fb\
			$::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_dut,opt)]

			# set rsltSrc $::ThruputBT_dev_LE::wlan_dut

		} else {

			## ? UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic HSIC branch. Using relay for iperf_timestamps.tcl\n"
			# Start iperf as parallel task via rpopen.
			set logname [UTF::get_name $::ThruputBT_dev_LE::wlan_dut]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic dut2tg"
			set fd_dut [$::ThruputBT_dev_LE::wlan_relay rpopen iperf_timestamps.tcl\
			-c $::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_tg,ip)\
			-i $::ThruputBT_dev_LE::perf_int -t $::ThruputBT_dev_LE::perf_time -fb\
			$::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_dut,opt)]

		}
		UTF::Sleep 1
		fconfigure $fd_dut -blocking 0
		fileevent $fd_dut readable {set ::utils_reading READY}

		# Add the host & file handle to results
		UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic created fd=$fd_dut"
		append results " $::ThruputBT_dev_LE::wlan_dut $fd_dut"
		
		# # ? UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic dut2tg results: $results\n"
		
	}

	# Start wlan iperf traffic for tg2dut or bidirectional.
	if {$direction == "tg2dut" || $direction == "bidirectional"} {

		if { $wdut_type != "HSIC" } {

			# Start iperf as parallel task via rpopen.
			set logname [UTF::get_name $::ThruputBT_dev_LE::wlan_tg]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic tg2dut"
			set fd_tg [$::ThruputBT_dev_LE::wlan_tg rpopen iperf_timestamps.tcl\
				-c $::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_dut,ip)\
				-i $::ThruputBT_dev_LE::perf_int -t $::ThruputBT_dev_LE::perf_time -fb\
				$::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_tg,opt)]

		} else {
			
			UTF::Message DEBUG "$logname" "This is thruput_wlan_traffic HSIC branch.\n"
			  
			set logname [UTF::get_name $::ThruputBT_dev_LE::wlan_tg]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic tg2dut HSIC branch"
			set fd_tg [$::ThruputBT_dev_LE::wlan_tg rpopen iperf_timestamps.tcl\
				-c $::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_dut,ip)\
				-i $::ThruputBT_dev_LE::perf_int -t $::ThruputBT_dev_LE::perf_time -fb\
			$::ThruputBT_dev_LE::wlan($::ThruputBT_dev_LE::wlan_tg,opt)]
		}
		UTF::Sleep 1
		fconfigure $fd_tg -blocking 0
		fileevent $fd_tg readable {set ::utils_reading READY}

		# Add the host & file handle to results
		UTF::Message LOG "$logname" "ThruputBT_dev_LE::thruput_bt_traffic created fd=$fd_tg"
		append results " $::ThruputBT_dev_LE::wlan_tg $fd_tg"
					 
		UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::thruput_wlan_traffic tg2dut results: $results"
	}

	# Thats it.
	return "$results"
}

#======================= test_profile0 ========================================
# Test profile 0: BT/BLE traffic only on an existing connection.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
# bt_dut/ble_dut and bt_ref/ble_ref resides in the same device
#==============================================================================
proc ThruputBT_dev_LE::test_profile0 {ble_dut ble_ref} {

	# Start BT tests.
	set fd_list [ThruputBT_dev_LE::thruput_bt_traffic $ble_dut $ble_ref $::ThruputBT_dev_LE::ble_dir]
#	 UTF::Message BLE_DEBUG "Profile0" "bt traffic file descriptor: $fd_list"
	UTF::Sleep 3

	# Start timer to stop the tests.
	set timer_id [ThruputBT_dev_LE::thruput_test_stop_timer $::ThruputBT_dev_LE::perf_time]

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	set timeout_sec [expr $::ThruputBT_dev_LE::perf_time + 20]
	UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
	## ? UTF::Message LOG "" "\n\n\nThruputBT_dev_LE::test_profile0 resp1=$resp1\n\n\n"
	
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile0 resp1=$resp1 resp2=$resp2\n\n\n"

	# If timer is still running, cancel it. Otherwise it may disrupt the
	# next test.
	after cancel $timer_id

	# Process results
	set results [ThruputBT_dev_LE::process_results [list $::ThruputBT_dev_LE::bt_test $::ThruputBT_dev_LE::ble_dir $ble_dut $ble_ref $resp1]]
	
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile0 results=$results\n\n\n"
	
	return "$results"
}

#======================= test_profile1 ========================================
# Test profile 1: WLAN iperf traffic only on an existing connection.
# Dummy calling args are ignored but are present to keep API consistent.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
proc ThruputBT_dev_LE::test_profile1 {args} {

	# Start WLAN iperf tests.
	set fd_list [ThruputBT_dev_LE::thruput_wlan_traffic]

	# WLAN doesnt need any extra timer to stop iperf tests.

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	set timeout_sec [expr $::ThruputBT_dev_LE::perf_time + 20]
	UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
	# UTF::Message LOG "" "\n\n\nThruputBT_dev_LE::test_profile1 resp1=$resp1\n\n\n"
	
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile1 resp1=$resp1 resp2=$resp2\n\n\n"

	# Process results
	set results [ThruputBT_dev_LE::process_results [list wlan $::ThruputBT_dev_LE::wlan_dir $::ThruputBT_dev_LE::wlan_dut $::ThruputBT_dev_LE::wlan_tg $resp1]]

	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile1 results=$results\n\n\n"

	return "$results"
}

#======================= test_profile2 ========================================
# Test profile 2: Concurrent WLAN and BT traffic on an existing connection
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
# Includes support for both WLAN/BT and WLAN/BLE
#==============================================================================
# Test profile 2: WLAN iperf traffic & BT traffic concurrently on existing connections
# Supports both BT (ACL) and BLE traffic streams

proc ThruputBT_dev_LE::test_profile2 {ble_dut ble_ref} {

	# Start BT tests first as they have a few seconds delay while
	# getting going.
	if { $::ThruputBT_dev_LE::bt_test != "ble" } {
		set bt_dut $ble_dut
		set bt_ref $ble_ref
		set fd_list [ThruputBT_dev_LE::thruput_bt_traffic $bt_dut $bt_ref]
	} else {
		set fd_list [ThruputBT_dev_LE::thruput_bt_traffic $ble_dut $ble_ref $::ThruputBT_dev_LE::ble_dir]
	}
	UTF::Sleep 1

	# Start WLAN iperf tests.
	append fd_list " [ThruputBT_dev_LE::thruput_wlan_traffic]"
	UTF::Sleep 1

	# Start timer to stop the BT tests. WLAN doesnt need any extra timer to
	# stop iperf tests.
	 set timer_id [ThruputBT_dev_LE::thruput_test_stop_timer $::ThruputBT_dev_LE::perf_time]

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	set timeout_sec [expr $::ThruputBT_dev_LE::perf_time + 20]
	UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
	# UTF::Message LOG "" "\n\n\nThruputBT_dev_LE::test_profile2 resp1=$resp1\n\n\n"
	
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile2 resp1=$resp1 resp2=$resp2\n\n\n"

	# If timer is still running, cancel it. Otherwise it may disrupt the
	# next test.
	after cancel $timer_id

	# Process results
	if { $::ThruputBT_dev_LE::bt_test == "ble" } {
		set results [ThruputBT_dev_LE::process_results\
			[list wlan $::ThruputBT_dev_LE::wlan_dir $::ThruputBT_dev_LE::wlan_dut $::ThruputBT_dev_LE::wlan_tg $resp1]\
			[list ble $::ThruputBT_dev_LE::ble_dir $ble_dut $ble_ref $resp1]]		
	} else {
		set results [ThruputBT_dev_LE::process_results\
			[list wlan $::ThruputBT_dev_LE::wlan_dir $::ThruputBT_dev_LE::wlan_dut $::ThruputBT_dev_LE::wlan_tg $resp1]\
			[list bt $::ThruputBT_dev_LE::bt_dir $bt_dut $bt_ref $resp1]]
	}

	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::test_profile2 results=$results\n\n\n" 

	return "$results"
}

#======================= test_profile3 ========================================
# Test profile 3: Concurrent BT and BLE traffic on an existing connection
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
# Test profile 3: BT/BLE concurrent traffic on existing connections

proc ThruputBT_dev_LE::test_profile3 {ble_dut ble_ref} {
	set bt_ref $::ThruputBT_dev_LE::refdev
	set bt_dut $::ThruputBT_dev_LE::btdev

	# Start BLE tests first as they have a few seconds delay while
	# getting going.
	set ::ThruputBT_dev_LE::bt_test "ble"
	set fd_list [ThruputBT_dev_LE::thruput_bt_traffic $ble_dut $ble_ref $::ThruputBT_dev_LE::ble_dir]
	UTF::Sleep 3

	# Start BT iperf tests.
	set ::ThruputBT_dev_LE::bt_test "acl"
	set ::ThruputBT_dev_LE::tx_script common/ThroughputTxTest.pl
	set ::ThruputBT_dev_LE::rx_script common/ThroughputRxTest.pl
	append fd_list " [ThruputBT_dev_LE::thruput_bt_traffic $bt_dut $bt_ref $::ThruputBT_dev_LE::bt_dir]"
	UTF::Sleep 3

	# Start timer to stop the BT tests. WLAN doesnt need any extra timer to
	# stop iperf tests.
	 set timer_id [ThruputBT_dev_LE::thruput_test_stop_timer $::ThruputBT_dev_LE::perf_time]

	# Collect data from parallel processes.
	set resp1 "" ;# "timed output"
	set resp2 "" ;# "untimed output"
	set timeout_sec [expr $::ThruputBT_dev_LE::perf_time + 20]
	UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
	# UTF::Message LOG "" "\n\n\nThruputBT_dev_LE::test_profile2 resp1=$resp1\n\n\n"

	## ? UTF::Message DEBUG_LOG_LE "" "\n\n\nThruputBT_dev_LE::test_profile3 resp1=$resp1 resp2=$resp2\n\n\n"

	# If timer is still running, cancel it. Otherwise it may disrupt the
	# next test.
	after cancel $timer_id

	# Process results
	set results [ThruputBT_dev_LE::process_results\
		[list ble $::ThruputBT_dev_LE::ble_dir $ble_dut $ble_ref $resp1]\
		[list bt $::ThruputBT_dev_LE::bt_dir $bt_dut $bt_ref $resp1]]

	## final results output: html formated contents
	## ? UTF::Message DEBUG_LOG_LE "" "\n\n\nThruputBT_dev_LE::test_profile3 results=$results\n\n\n" 

	return "$results"
}

#======================= test_profile4 ========================================
# Test profile 4: BT/BLE/WLAN Triple coex
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
# Test profile 4: BT/BLE/WLAN triple coex

proc ThruputBT_dev_LE::test_profile4 {ble_dut ble_ref} {

	set bt_ref $::ThruputBT_dev_LE::refdev
	set bt_dut $::ThruputBT_dev_LE::btdev

	# Start BLE tests first as they have a few seconds delay while
	# getting going.
	set ::ThruputBT_dev_LE::bt_test "ble"
	set fd_list [ThruputBT_dev_LE::thruput_bt_traffic $ble_dut $ble_ref $::ThruputBT_dev_LE::ble_dir]
	set ble_list $fd_list
	UTF::Message BLE_DEBUG "Profile4" "ble file descriptor: $ble_list"
	UTF::Sleep 1

	# Start BT iperf tests.
	set ::ThruputBT_dev_LE::bt_test "acl"
	set ::ThruputBT_dev_LE::tx_script common/ThroughputTxTest.pl
	set ::ThruputBT_dev_LE::rx_script common/ThroughputRxTest.pl
	append fd_list " [ThruputBT_dev_LE::thruput_bt_traffic $bt_dut $bt_ref $::ThruputBT_dev_LE::bt_dir]"
	UTF::Sleep 1

	# Start WLAN iperf tests.
	set wl_list [ThruputBT_dev_LE::thruput_wlan_traffic]
	UTF::Message BLE_DEBUG" "Profile4" "wlan file descriptor: $wl_list"
	append fd_list " [ThruputBT_dev_LE::thruput_wlan_traffic]"
	UTF::Sleep 1

	# Start timer to stop the BT tests. WLAN doesnt need any extra timer to
	# stop iperf tests.
	 set timer_id [ThruputBT_dev_LE::thruput_test_stop_timer $::ThruputBT_dev_LE::perf_time]

	# Collect data from parallel processes.
	set resp1 ""
	set resp2 ""
	set resp3 ""
	set timeout_sec [expr $::ThruputBT_dev_LE::perf_time + 20]
	UTF::collect_rpopen_data $timeout_sec "$fd_list" resp1 "" resp2
	# UTF::Message DEBUG_LOG "" "\n\n\nThruputBT_dev_LE::test_profile4 resp1=$resp1\n\n\n"

	## ? UTF::Message DEBUG_LE "" "\n\n\nThruputBT_dev_LE::test_profile4 resp1=$resp1 resp2=$resp2\n\n\n"

	# If timer is still running, cancel it. Otherwise it may disrupt the
	# next test.
	after cancel $timer_id

	# Process results
	set results [ThruputBT_dev_LE::process_results\
		[list wlan $::ThruputBT_dev_LE::wlan_dir $::ThruputBT_dev_LE::wlan_dut $::ThruputBT_dev_LE::wlan_tg $resp1]\
		[list ble $::ThruputBT_dev_LE::ble_dir $ble_dut $ble_ref $resp1]\
		[list bt $::ThruputBT_dev_LE::bt_dir $bt_dut $bt_ref $resp1]]

	## ? UTF::Message DEBUG_LE "" "\n\n\nThruputBT_dev_LE::test_profile4 results=$results\n\n\n" 

	return "$results"
}


#==============================================================================
# Test data for routine below.
set ::test_data "\
{17:02:59 host1 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: 300}\
{17:03:01 host1 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 301}\
{17:03:02 host1 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 302}
{17:03:03 host1 com33000000: Fri May  1 17:01:33 2009  RX current_Speed_KBit_Per_Second: 303}\
{17:03:05 host1 com33000000: Fri May  1 17:01:24 2009  RX current_Speed_KBit_Per_Second: 304}\
{17:03:07 host1 com33000000: Fri May  1 17:01:35 2009  RX current_Speed_KBit_Per_Second: 305}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
{17:03:08 host1 com33000000: Fri May  1 17:01:37 2009  RX current_Speed_KBit_Per_Second: 0.0}\
{17:03:09 host1 com33000000: Fri May  1 17:01:38 2009  RX current_Speed_KBit_Per_Second: -66}\
{17:02:59 host2 usb0: Fri May  1 17:01:30 2009 TX current_Speed_KBit_Per_Second: -1}\
{17:02:59 host2 usb0: Fri May  1 17:01:31 2009 TX current_Speed_KBit_Per_Second: 600}\
{17:02:59 host2 com33000000: Fri May  1 17:01:33 2009  TX current_Speed_KBit_Per_Second: 601}\
{17:03:01 host2 usb0: Fri May  1 17:01:32 2009 TX current_Speed_KBit_Per_Second: 602}\
{17:03:03 host2 com33000000: Fri May  1 17:01:34 2009  TX current_Speed_KBit_Per_Second: 603}\
{17:03:05 host2 com33000000: Fri May  1 17:01:35 2009  TX current_Speed_KBit_Per_Second: 604}\
{17:03:07 host2 com33000000: Fri May  1 17:01:36 2009  TX current_Speed_KBit_Per_Second: 605}\
{17:03:09 host2 com33000000: Fri May  1 17:01:37 2009  TX current_Speed_KBit_Per_Second: 606}\
{17:03:11 host2 com33000000: Fri May  1 17:01:38 2009  TX average_Speed_KBit_Per_Second: 607}\
{17:03:20 host1 RX Bit_Errors_Low => 123}\
{17:03:20 host1 RX Bit_Errors_High => 0}\
{17:03:20 host1 RX Dropped_Bytes_Low => 456}\
{17:03:20 host1 RX Dropped_Bytes_High => 0}\
{17:02:59 host2 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: -1}\
{17:02:59 host2 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 400}\
{17:03:01 host2 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 401}\
{17:03:02 host2 usb0: Fri May  1 17:01:33 2009 RX current_Speed_KBit_Per_Second: 402}\
{17:03:03 host2 usb0: Fri May  1 17:01:34 2009 RX current_Speed_KBit_Per_Second: 403}\
{17:03:04 host2 com33000000: Fri May  1 17:01:35 2009 RX current_Speed_KBit_Per_Second: 404}\
{sfsdfsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
{sfsbtsp: failed: event server 12345 ...}\
{222222fsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
{ fsdf sf BTSP: failed: aaaa bbbb cccc ddd w rwrwrw er w wer }"


# Test sequences for routine below.
# ThruputBT_dev_LE::get_BT_results host1 [list $::test_data] 0 rx
# ThruputBT_dev_LE::get_BT_results host2 [list $::test_data] 0 tx

#======================= get_BT_results =======================================
# Extracts thruput test results from collect_rpopen_data.
# Calling parms:
# host: name of host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)
#==============================================================================
proc ThruputBT_dev_LE::get_BT_results {host data_list samples type} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::sample_threshold]} {
		set ::ThruputBT_dev_LE::sample_threshold 3
	}
	
	# Get time correction delta for the target host
	set time_delta_sec [ThruputBT_dev_LE::get_remote_clock_delta $host]
	set logname [UTF::get_name $host]

	# Variables to track socket delays
	set ::ThruputBT_dev_LE::max_socket_delay 0
	set ::ThruputBT_dev_LE::max_socket_timestamp ""

	# The data_list is usually a nested list of data, which is
	# best processed by the double foreach loop below. This
	# avoids issues of processing strings with unmatched braces
	# or brackets.

	# Initially the perl scripts would send back text strings that
	# werent unique. You had to match a header line with the data 
	# result. This was very error prone. The perl scripts have now
	# been modified to send unique strings. So everything you need
	# is now contained within the line of text.
	# UTF::Message LOG "$logname" "\n\n\nThruputBT_dev_LE::get_BT_results host=$host\
	#	samples=$samples type=$type data_list=$data_list\n\n\n"
	set sample_list ""
	set host [string trim $host]
	set type [string trim $type]
	set type [string tolower $type]
	foreach item $data_list {
		# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results search for: $host $type ======================================================================"
		# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results\n\n\n\item=$item\n\n\n"
		foreach subitem $item {
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results subitem=$subitem"
			# Skip data not matching host & type. The data often has tabs,
			# which we convert to spaces.
			regsub -all {\011} $subitem " " subitem

			# There are some fatal errors that need to be flagged.
			# When a fatal error is found, we need to request the error
			# recovery procedure in order to continue testing. These errors 
			# usually dont have type RX/TX included. We save only the first
			# fatal error that we find, so as not to clutter up the web summary
			# page with repeated copies of a similar message. But we log all
			# fatal errors.
			if {[regexp -nocase {connection.*lost} $subitem] &&\
				![regexp -nocase {fsh} $subitem]} {
				set ::ThruputBT_dev_LE::need_erp yes
				set msg "connection lost (set $::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop)"
				UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results fatal error: $msg $subitem"
				if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
					$::ThruputBT_dev_LE::fatal_error == ""} {
					set ::ThruputBT_dev_LE::fatal_error "$msg"
				}
				continue
			}

			# There are other routine errors to watch for. Keep only the first
			# 3 words of failure string to minimize how much data gets shown
			# on the web page.
			if {[regexp -nocase {(BTSP:.*failed:\s+\S+\s+\S+\s+\S+)} $subitem - msg]} {
				UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results found: $subitem"
				lappend ::ThruputBT_dev_LE::current_error_list "$msg"
				lappend ::ThruputBT_dev_LE::running_error_list "$msg"
				continue
			}

			# Match the host name at start of the list pair, then match
			# on type rx or tx.
			# NB: Some strings, in particular the final error statistics, have
			# only a single space be the host and RX/TX, so you cant have regexp
			# asking for spaces around each parameter!
			if {![regexp -nocase " $host .*$type " $subitem]} {
				continue
			}
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results matched host $host $type: $subitem"

			# Get local & remote timestamps & current (not average!) thruput
			# data from results line. The regexp filters out the negative values.
			# NB: 0 or 0.0 is a legitimate value!
			if {[regexp -nocase {^([\d:]{8}).*\s([\d:]{8})\s.*current.*kbit_per_second:\s*([\.\d]+)}\
				$subitem - time1 time2 tput]} {
				set corrected_timestamp [ThruputBT_dev_LE::timestamp_correction BT $time1\
					$time2 $time_delta_sec]
				# NB: BlueTool reports thruput in Kb/s!
				set tput [expr double($tput) / 1000] ;# UTF likes numbers in Mb/s
				set tput [format "%6.6f" $tput]
				lappend sample_list $corrected_timestamp $tput
				
				## ? UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::get_BT_results found\
				## ?	 $type sample: time1=$time1 time2=$time2\
				## ?	 corrected=$corrected_timestamp tput=$tput subitem: $subitem"
					
				continue
			}

			# Look for other statistics at the end of the test run.
			# Show only the statistic type that failed, in order to minimize
			# the data shown on the web page.
			# added check for Delay Packets statistics check, if present
			if {[regexp -nocase {(bit_errors|dropped_bytes|delayed_packets).*\s(\d+)$} $subitem - msg stat]} {
				# UTF::Message LOG "$host" "ThruputBT_dev_LE::get_BT_results found stat:\
				#	  msg=$msg stat=$stat subitem: $subitem"
				# set stat 1 ;# test code
				if {$stat > 0} {
					lappend ::ThruputBT_dev_LE::current_error_list "$msg"
					lappend ::ThruputBT_dev_LE::running_error_list "$msg"
					UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results\
						found msg=$msg stat=$stat subitem=$subitem"
				}
				continue
			}
		}
	}

	# Log UTF delays
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results $type\
		max_socket_delay=$::ThruputBT_dev_LE::max_socket_delay seconds occured at:\
		$::ThruputBT_dev_LE::max_socket_timestamp"

	# Need to toss last sample which is delayed repeat of final sample?

	# Discard duplicate time samples. We seem to get duplicate messages
	# as the BlueTool tests shut down, so we toss them.
	# Burst of zero's does not happen any more, but we could get 0 throughput
	# which is valid and we should not remove them as duplicates
	#set sample_list [ThruputBT_dev_LE::remove_duplicate_samples $host BT $type $sample_list]

	# If necessary, drop some of the earlier samples.
	set sample_cnt [llength $sample_list]
	set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
	if {$samples > 0} {
		if {$sample_cnt < $samples} {
			UTF::Message WARN "$logname" "ThruputBT_dev_LE::get_BT_results Only\
				found $sample_cnt samples!"
		} else {
			set i [expr ($sample_cnt - $samples) * 2]
			set sample_list [lrange $sample_list $i end]
			set sample_cnt $samples
		}
	}

	UTF::Message LOG "$logname" "Full samples=$sample_list"

	# in coex testing sometimes after the test is stopped, the reciever still will
	# continue recieving messages that were backed up and this will cause 
	# "::ThruputBT_dev_LE::current_error_list=Bit_Errors Dropped_Bytes" because the extra rx
	# messages do not have a tx message, therefore we need to trim those first
	# by removing any samples above 35 
	if {$sample_cnt > $::ThruputBT_dev_LE::perf_size && $sample_cnt > 50} {
		# too many samples exist
		UTF::Message LOG "$logname" "Burst of RX messages - BT sample_cnt $sample_cnt is reduced to 35"
		set sample_list [lrange $sample_list 0 70]
		set sample_cnt 35
		UTF::Message LOG "$logname" "samples=$sample_list"
	}

	# we want 1 entry in the control chart per run
	# Since it is possible at the beginning and at the end of coex test, the wlan and bt are not running 
	# simultaneously, therefore strip the extra values from both begining and the end.
	if {$sample_cnt > $::ThruputBT_dev_LE::perf_size} {
		UTF::Message LOG "$logname" "BT sample_cnt $sample_cnt is reduced to perf_size $::ThruputBT_dev_LE::perf_size"
		set i [expr $sample_cnt - $::ThruputBT_dev_LE::perf_size]
		if {[expr ($i % 2)] == 1} {
			# odd number
			set i [expr ($i - 1)]
		}
		set sample_list [lrange $sample_list $i end]
		set sample_list [lrange $sample_list 0 [expr ($::ThruputBT_dev_LE::perf_size * 2) - 1]]
		set sample_cnt [llength $sample_list]
		set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
		UTF::Message LOG "$logname" "samples=$sample_list"
	}

	# Log the results
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results $type\
		cnt=$sample_cnt samples=$sample_list"

	# Too few RX samples is a good indicator of serious problems. Request 
	# the error recovery procedure in order to keep testing. We save only
	# the first fatal error. But we log all fatal errors.
	if {$sample_cnt < $::ThruputBT_dev_LE::sample_threshold && $type == "rx"} {
		set ::ThruputBT_dev_LE::need_erp yes
		set msg "$logname Only $sample_cnt $type samples, required\
			$::ThruputBT_dev_LE::sample_threshold (set $::ThruputBT_dev_LE::perf_cnt\
			of $::ThruputBT_dev_LE::perf_loop)"
		UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results fatal error: $msg"
		if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
			$::ThruputBT_dev_LE::fatal_error == ""} {
			set ::ThruputBT_dev_LE::fatal_error "$msg"
		}
	}

	# Return the results

	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::get_bt_results sample_list=$sample_list\n\n\n"

	return $sample_list
}


# # # #==============================================================================
# # # # Test data for routine below.
# # # set ::test_data "\
# # # {17:02:59 host1 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: 300}\
# # # {17:03:01 host1 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 301}\
# # # {17:03:02 host1 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 302}
# # # {17:03:03 host1 com33000000: Fri May  1 17:01:33 2009  RX current_Speed_KBit_Per_Second: 303}\
# # # {17:03:05 host1 com33000000: Fri May  1 17:01:24 2009  RX current_Speed_KBit_Per_Second: 304}\
# # # {17:03:07 host1 com33000000: Fri May  1 17:01:35 2009  RX current_Speed_KBit_Per_Second: 305}\
# # # {17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
# # # {17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
# # # {17:03:07 host1 com33000000: Fri May  1 17:01:36 2009  RX current_Speed_KBit_Per_Second: 306}\
# # # {17:03:08 host1 com33000000: Fri May  1 17:01:37 2009  RX current_Speed_KBit_Per_Second: 0.0}\
# # # {17:03:09 host1 com33000000: Fri May  1 17:01:38 2009  RX current_Speed_KBit_Per_Second: -66}\
# # # {17:02:59 host2 usb0: Fri May  1 17:01:30 2009 TX current_Speed_KBit_Per_Second: -1}\
# # # {17:02:59 host2 usb0: Fri May  1 17:01:31 2009 TX current_Speed_KBit_Per_Second: 600}\
# # # {17:02:59 host2 com33000000: Fri May  1 17:01:33 2009  TX current_Speed_KBit_Per_Second: 601}\
# # # {17:03:01 host2 usb0: Fri May  1 17:01:32 2009 TX current_Speed_KBit_Per_Second: 602}\
# # # {17:03:03 host2 com33000000: Fri May  1 17:01:34 2009  TX current_Speed_KBit_Per_Second: 603}\
# # # {17:03:05 host2 com33000000: Fri May  1 17:01:35 2009  TX current_Speed_KBit_Per_Second: 604}\
# # # {17:03:07 host2 com33000000: Fri May  1 17:01:36 2009  TX current_Speed_KBit_Per_Second: 605}\
# # # {17:03:09 host2 com33000000: Fri May  1 17:01:37 2009  TX current_Speed_KBit_Per_Second: 606}\
# # # {17:03:11 host2 com33000000: Fri May  1 17:01:38 2009  TX average_Speed_KBit_Per_Second: 607}\
# # # {17:03:20 host1 RX Bit_Errors_Low => 123}\
# # # {17:03:20 host1 RX Bit_Errors_High => 0}\
# # # {17:03:20 host1 RX Dropped_Bytes_Low => 456}\
# # # {17:03:20 host1 RX Dropped_Bytes_High => 0}\
# # # {17:02:59 host2 usb0: Fri May  1 17:01:30 2009 RX current_Speed_KBit_Per_Second: -1}\
# # # {17:02:59 host2 usb0: Fri May  1 17:01:31 2009 RX current_Speed_KBit_Per_Second: 400}\
# # # {17:03:01 host2 usb0: Fri May  1 17:01:32 2009 RX current_Speed_KBit_Per_Second: 401}\
# # # {17:03:02 host2 usb0: Fri May  1 17:01:33 2009 RX current_Speed_KBit_Per_Second: 402}\
# # # {17:03:03 host2 usb0: Fri May  1 17:01:34 2009 RX current_Speed_KBit_Per_Second: 403}\
# # # {17:03:04 host2 com33000000: Fri May  1 17:01:35 2009 RX current_Speed_KBit_Per_Second: 404}\
# # # {sfsdfsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
# # # {sfsbtsp: failed: event server 12345 ...}\
# # # {222222fsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}\
# # # { fsdf sf BTSP: failed: aaaa bbbb cccc ddd w rwrwrw er w wer }"
# # # 
# # # 
# # # # Test sequences for routine below.
# # # # ThruputBT_dev_LE::get_BLE_results host1 [list $::test_data] 0 rx
# # # # ThruputBT_dev_LE::get_BLE_results host2 [list $::test_data] 0 tx

#======================= get_BLE_results =======================================
# Extracts BLE thruput test results from collect_rpopen_data on low throughput link.
# Calling parms:
# host: name of host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value n Kb/s, per BTSP
#==============================================================================
proc ThruputBT_dev_LE::get_BLE_results {host data_list samples type} {

# # # 	UTF::Message DEBUG_LE "" "**** get_BLE_results called ****"
	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::sample_threshold]} {
		set ::ThruputBT_dev_LE::sample_threshold 3
	}

	# Get time correction delta for the target host
	set time_delta_sec [ThruputBT_dev_LE::get_remote_clock_delta $host]
	set logname [UTF::get_name $host]

	# Variables to track socket delays
	set ::ThruputBT_dev_LE::max_socket_delay 0
	set ::ThruputBT_dev_LE::max_socket_timestamp ""

	# The data_list is usually a nested list of data, which is
	# best processed by the double foreach loop below. This
	# avoids issues of processing strings with unmatched braces
	# or brackets.

	# Initially the perl scripts would send back text strings that
	# werent unique. You had to match a header line with the data 
	# result. This was very error prone. The perl scripts have now
	# been modified to send unique strings. So everything you need
	# is now contained within the line of text.
	# UTF::Message LOG "$logname" "\n\n\nThruputBT_dev_LE::get_BT_results host=$host\
	#	samples=$samples type=$type data_list=$data_list\n\n\n"
	set sample_list ""
	set host [string trim $host]
	set type [string trim $type]
	set type [string tolower $type]
	foreach item $data_list {
		# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results search for: $host $type ======================================================================"
		# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results\n\n\n\item=$item\n\n\n"
		foreach subitem $item {
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results subitem=$subitem"
			# Skip data not matching host & type. The data often has tabs,
			# which we convert to spaces.
			regsub -all {\011} $subitem " " subitem

			# There are some fatal errors that need to be flagged.
			# When a fatal error is found, we need to request the error
			# recovery procedure in order to continue testing. These errors 
			# usually dont have type RX/TX included. We save only the first
			# fatal error that we find, so as not to clutter up the web summary
			# page with repeated copies of a similar message. But we log all
			# fatal errors.
			if {[regexp -nocase {connection.*lost} $subitem] &&\
				![regexp -nocase {fsh} $subitem]} {
				set ::ThruputBT_dev_LE::need_erp yes
				set msg "connection lost (set $::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop)"
				UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results fatal error: $msg $subitem"
				if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
					$::ThruputBT_dev_LE::fatal_error == ""} {
					set ::ThruputBT_dev_LE::fatal_error "$msg"
				}
				continue
			}

			# There are other routine errors to watch for. Keep only the first
			# 3 words of failure string to minimize how much data gets shown
			# on the web page.
			if {[regexp -nocase {(BTSP:.*failed:\s+\S+\s+\S+\s+\S+)} $subitem - msg]} {
				UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results found: $subitem"
				lappend ::ThruputBT_dev_LE::current_error_list "$msg"
				lappend ::ThruputBT_dev_LE::running_error_list "$msg"
				continue
			}

			# Match the host name at start of the list pair, then match
			# on type rx or tx.
			# NB: Some strings, in particular the final error statistics, have
			# only a single space be the host and RX/TX, so you cant have regexp
			# asking for spaces around each parameter!
			if {![regexp -nocase " $host .*$type " $subitem]} {
				continue
			}
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BT_results matched host $host $type: $subitem"

			# Get local & remote timestamps & current (not average!) thruput
			# data from results line. The regexp filters out the negative values.
			# NB: 0 or 0.0 is a legitimate value!
			if {[regexp -nocase {^([\d:]{8}).*\s([\d:]{8})\s.*current.*kbit_per_second:\s*([\.\d]+)}\
				$subitem - time1 time2 tput]} {
				set corrected_timestamp [ThruputBT_dev_LE::timestamp_correction BT $time1\
					$time2 $time_delta_sec]
				# NB: BlueTool reports thruput in Kb/s!
				set tput [expr double($tput)] ;# Kb/s per BTSP, due to low throughput in BLE
				set tput [format "%6.6f" $tput]
				lappend sample_list $corrected_timestamp $tput
				
				## ? UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::get_BT_results found\
				## ?	 $type sample: time1=$time1 time2=$time2\
				## ?	 corrected=$corrected_timestamp tput=$tput subitem: $subitem"
					
				continue
			}

			# Look for other statistics at the end of the test run.
			# Show only the statistic type that failed, in order to minimize
			# the data shown on the web page.
			# added check for Delay Packets statistics check, if present
			if {[regexp -nocase {(bit_errors|dropped_bytes|delayed_packets).*\s(\d+)$} $subitem - msg stat]} {
				# UTF::Message LOG "$host" "ThruputBT_dev_LE::get_BT_results found stat:\
				#	  msg=$msg stat=$stat subitem: $subitem"
				# set stat 1 ;# test code
				if {$stat > 0} {
					lappend ::ThruputBT_dev_LE::current_error_list "$msg"
					lappend ::ThruputBT_dev_LE::running_error_list "$msg"
					UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BT_results\
						found msg=$msg stat=$stat subitem=$subitem"
				}
				continue
			}
		}
	}

	# Log UTF delays
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BLE_results $type\
		max_socket_delay=$::ThruputBT_dev_LE::max_socket_delay seconds occured at:\
		$::ThruputBT_dev_LE::max_socket_timestamp"

	# Need to toss last sample which is delayed repeat of final sample?


	# Discard duplicate time samples. We seem to get duplicate messages
	# as the BlueTool tests shut down, so we toss them.
	# Burst of zero's does not happen any more, but we could get 0 throughput
	# which is valid and we should not remove them as duplicates
	#set sample_list [ThruputBT_dev_LE::remove_duplicate_samples $host BT $type $sample_list]

	# If necessary, drop some of the earlier samples.
	set sample_cnt [llength $sample_list]
	set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
	if {$samples > 0} {
		if {$sample_cnt < $samples} {
			UTF::Message WARN "$logname" "ThruputBT_dev_LE::get_BLE_results Only\
				found $sample_cnt samples!"
		} else {
			set i [expr ($sample_cnt - $samples) * 2]
			set sample_list [lrange $sample_list $i end]
			set sample_cnt $samples
		}
	}

	UTF::Message LOG "$logname" "Full samples=$sample_list"

	# in coex testing sometimes after the test is stopped, the reciever still will
	# continue recieving messages that were backed up and this will cause 
	# "::ThruputBT_dev_LE::current_error_list=Bit_Errors Dropped_Bytes" because the extra rx
	# messages do not have a tx message, therefore we need to trim those first
	# by removing any samples above 35 
	if {$sample_cnt > $::ThruputBT_dev_LE::perf_size && $sample_cnt > 50} {
		# too many samples exist
		UTF::Message LOG "$logname" "Burst of RX messages - BT sample_cnt $sample_cnt is reduced to 35"
		set sample_list [lrange $sample_list 0 70]
		set sample_cnt 35
		UTF::Message LOG "$logname" "samples=$sample_list"
	}

	# we want 1 entry in the control chart per run
	# Since it is possible at the beginning and at the end of coex test, the wlan and bt are not running 
	# simultaneously, therefore strip the extra values from both begining and the end.
	if {$sample_cnt > $::ThruputBT_dev_LE::perf_size} {
		UTF::Message LOG "$logname" "BLE sample_cnt $sample_cnt is reduced to perf_size $::ThruputBT_dev_LE::perf_size"
		set i [expr $sample_cnt - $::ThruputBT_dev_LE::perf_size]
		if {[expr ($i % 2)] == 1} {
			# odd number
			set i [expr ($i - 1)]
		}
		set sample_list [lrange $sample_list $i end]
		set sample_list [lrange $sample_list 0 [expr ($::ThruputBT_dev_LE::perf_size * 2) - 1]]
		set sample_cnt [llength $sample_list]
		set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
		UTF::Message LOG "$logname" "samples=$sample_list"
	}

	# Log the results
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_BLE_results $type\
		cnt=$sample_cnt samples=$sample_list"

	# Too few RX samples is a good indicator of serious problems. Request 
	# the error recovery procedure in order to keep testing. We save only
	# the first fatal error. But we log all fatal errors.
	if {$sample_cnt < $::ThruputBT_dev_LE::sample_threshold && $type == "rx"} {
		set ::ThruputBT_dev_LE::need_erp yes
		set msg "$logname Only $sample_cnt $type samples, required\
			$::ThruputBT_dev_LE::sample_threshold (set $::ThruputBT_dev_LE::perf_cnt\
			of $::ThruputBT_dev_LE::perf_loop)"
		UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_BLE_results fatal error: $msg"
		if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
			$::ThruputBT_dev_LE::fatal_error == ""} {
			set ::ThruputBT_dev_LE::fatal_error "$msg"
		}
	}

	# Return the results
	
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::get_bt_results sample_list=$sample_list\n\n\n"
	
	return $sample_list
}

#==============================================================================
# Test data for routine below.
set ::test_data2 "\
{17:01:30 host1   3 ] local 192.168.1.101 port 35001 connected with 192.168.1.102 port 5001}\
{17:01:31 host2   3 ] local 192.168.1.102 port 51756 connected with 192.168.1.101 port 5001}\
{17:01:30 host1  ID Interval	   Transfer	 Bandwidth}\
{17:01:31 host2  ID] Interval	   Transfer	 Bandwidth}\
{17:01:30 host1 17:01:33 sec Bytes  13271040 bits/sec}\
{17:01:31 host1 17:01:34 sec Bytes  12713984 bits/sec}
{17:01:32 host1 17:01:35 sec Bytes  17793024 bits/sec}\
{17:01:33 host1 17:01:36 sec Bytes  26900128 bits/sec}\
{17:01:34 host1 17:01:37 sec Bytes  30081024 bits/sec}\
{17:01:35 host1 17:01:38 sec Bytes  32866304 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31850496 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31850000 bits/sec}\
{17:01:36 host1 17:01:39 sec Bytes  31860000 bits/sec}\
{17:01:37 host1 17:01:40 sec Bytes  50496 bits/sec}\
{17:01:30 host2 17:01:30 sec Bytes  23494656 bits/sec}\
{17:01:31 host2 17:01:31 sec Bytes  17039360 bits/sec}\
{17:01:32 host2 17:01:32 sec Bytes  18417616 bits/sec}\
{17:01:33 host2 17:01:33 sec Bytes  11436032 bits/sec}\
{17:01:34 host2 17:01:34 sec Bytes  7307264 bits/sec}\
{17:01:35 host2 17:01:35 sec Bytes  0.0 bits/sec}\
{17:01:36 host2 17:01:36 sec Bytes  -33 bits/sec}\
{17:01:37 host2 17:01:37 sec Bytes  6258688 bits/sec}\
{sfsdfsdfsdfsdfailed: fdfdfd connection lostjhjjhjhj}"

# Test sequences for routine below.
# ThruputBT_dev_LE::get_WLAN_results host1 [list $::test_data2] 0 rx
# ThruputBT_dev_LE::get_WLAN_results host2 [list $::test_data2] 0 tx

# Extracts thruput test results from the collect_rpopen data.
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)

#======================= get_WLAN_results =====================================
# Extracts thruput test results from collect_rpopen_data.
# Calling parms:
# host: name of host to look for in data stream
# data_list: composite results from multiple hosts from collect_rpopen_data
# samples: 0 - gets all results; N - gets just the last N samples
# type: rx selects rx report data; tx selects tx report data
# Returns sample data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value, converted to Mb/s (NOT Kb/s !)
#==============================================================================
proc ThruputBT_dev_LE::get_WLAN_results {host data_list samples type} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::sample_threshold]} {
		set ::ThruputBT_dev_LE::sample_threshold 3
	}
	if {![info exists ::ThruputBT_dev_LE::wlan_tg]} {
		set ::ThruputBT_dev_LE::wlan_tg host1
	}
	if {![info exists ::ThruputBT_dev_LE::wlan_dut]} {
		set ::ThruputBT_dev_LE::wlan_dut host2
	}

	# For iperf TCP traffic, the UTF way is to not monitor the receiving
	# end. Experience has shown that for TCP you can trust the transmitting
	# side numbers. For this script, the upper level routines process recieved
	# data. So we send back nothing for type=tx and send the transmitted data
	# back for type=rx. If we ever support iperf UDP traffic, then we will have
	# to be careful in here.
	set type [string trim $type]
	set type [string tolower $type]
	if {$type == "tx"} {
		return
	}

	# When collecting the transmitted data, we have to look at the opposite
	# wlan device than what we were called with. For example when sending
	# traffic for tg2dut, we will collect the transmitted data from the tg,
	# but report it back as the recieved data for the dut.

	if {$host == $::ThruputBT_dev_LE::wlan_tg} { 
		set host $::ThruputBT_dev_LE::wlan_dut
	} else {
		set host $::ThruputBT_dev_LE::wlan_tg
	}

	# Get time correction delta for the target host
	set time_delta_sec [ThruputBT_dev_LE::get_remote_clock_delta $host]
	set logname [UTF::get_name $host]

	# Variables to track socket delays
	set ::ThruputBT_dev_LE::max_socket_delay 0
	set ::ThruputBT_dev_LE::max_socket_timestamp ""

	# The data_list is usually a nested list of data, which is
	# best processed by the double foreach loop below. This
	# avoids issues of processing strings with unmatched braces
	# or brackets.

	# Match the host name at start of the list pair.
	# UTF::Message LOG "$logname" "\n\n\nThruputBT_dev_LE::get_WLAN_results host=$host\
	#	samples=$samples type=$type data_list=$data_list\n\n\n"
	set sample_list ""
	set host [string trim $host]
	foreach item $data_list {
		## ? UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_WLAN_results search for: $host $type ======================================================================"
		
		## ? UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::get_WLAN_results\n\n\n\item=$item\n\n\n"
		
		foreach subitem $item {
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_WLAN_results subitem=$subitem"
			# Skip data not matching host & type. The data often has tabs,
			# which we convert to spaces.
			regsub -all {\011} $subitem " " subitem

			# There are some fatal errors that need to be flagged.
			# When a fatal error is found, we request the error recovery 
			# procedures in order to continue testing. We save only the
			# first fatal error that we find, so as not to clutter up the
			# web summary page with repeated copies of a similar message.
			# But we log all fatal errors.
			if {[regexp -nocase {(connection.*lost)} $subitem] &&\
				![regexp -nocase {fsh} $subitem]} {
				set ::ThruputBT_dev_LE::need_erp yes
				set msg "connection lost (set $::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop)"
				UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_WLAN_results fatal error:\
				   $msg $subitem"
				if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
					$::ThruputBT_dev_LE::fatal_error == ""} {
					set ::ThruputBT_dev_LE::fatal_error "$msg"
				}
				continue
			}

			# Match on host.
			if {![regexp -nocase " $host " $subitem]} {
				continue
			}
			# UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_WLAN_results matched host $host: $subitem"

			# Get local & remote timestamps & current thruput data from results.
			# The regexp filters out the negative values.
			# NB: 0 or 0.0 is a legitimate value!
			if {[regexp -nocase {^([\d:]{8})\s.*\s([\d:]{8})\s.*\sBytes\s+([\.\d]+) bits/sec$}\
				$subitem - time1 time2 tput]} {
				set corrected_timestamp [ThruputBT_dev_LE::timestamp_correction WLAN $time1\
					$time2 $time_delta_sec]
				# NB: iperf reports thruput in bits/s!
				set tput [expr double($tput) / 1000000] ;# UTF likes numbers in Mb/s
				set tput [format "%6.6f" $tput]
				lappend sample_list $corrected_timestamp $tput
				
				## ? UTF::Message DEBUG "$logname" "ThruputBT_dev_LE::get_WLAN_results found\
				## ?	 $type sample: time1=$time1 time2=$time2\
				## ?	 corrected=$corrected_timestamp tput=$tput subitem: $subitem"
					
				continue
			}

			# Currently there are no stats or other events related to iperf to look for.
		}
	}

	# Log UTF delays
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_WLAN_results $type\
		max_socket_delay=$::ThruputBT_dev_LE::max_socket_delay seconds occured at:\
		$::ThruputBT_dev_LE::max_socket_timestamp"

	# Always discard the last iperf sample (time+tput), as it is the overall average.
	# We do this before the duplicate check, so we know we are discarding just the
	# last sample.
	set sample_list [lrange $sample_list 0 end-2]

	# Discard duplicate time samples. Usually doesnt occur with iperf, but
	# there is no harm checking anyway.
	# Burst of zero's does not happen any more, but we could get 0 throughput
	# which is valid and we should not remove them as duplicates
	#set sample_list [ThruputBT_dev_LE::remove_duplicate_samples $host WLAN $type $sample_list]

	# If necessary, drop some of the earlier samples.
	set sample_cnt [llength $sample_list]
	set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
	if {$samples > 0} {
		if {$sample_cnt < $samples} {
			UTF::Message WARN "$logname" "ThruputBT_dev_LE::get_WLAN_results Only\
				found $sample_cnt samples!"
		} else {
			set i [expr ($sample_cnt - $samples) * 2]
			set sample_list [lrange $sample_list $i end]
			set sample_cnt $samples
		}
	}

	# we want 1 entry in the control chart per run
	# Since it is possible at the beginning and at the end of coex test, the wlan and bt are not running 
	# simultaneously, therefore strip the extra values from both begining and the end.
	if {$sample_cnt > $::ThruputBT_dev_LE::perf_size} {
		UTF::Message LOG "$logname" "samples=$sample_list"
		UTF::Message LOG "$logname" "WLAN sample_cnt $sample_cnt is reduced to perf_size $::ThruputBT_dev_LE::perf_size"
		set i [expr $sample_cnt - $::ThruputBT_dev_LE::perf_size]
		if {[expr ($i % 2)] == 1} {
			# odd number
			set i [expr ($i - 1)]
		}
		set sample_list [lrange $sample_list $i end]
		set sample_list [lrange $sample_list 0 [expr ($::ThruputBT_dev_LE::perf_size * 2) - 1]]
		set sample_cnt [llength $sample_list]
		set sample_cnt [expr $sample_cnt / 2] ;# sample == time+tput
	}

	# Log the results
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_WLAN_results $type\
		cnt=$sample_cnt samples=$sample_list"

	# Too few samples is a good indicator of serious problems. Request
	# the error recovery procedures. We save only the first fatal error.
	# But we log all fatal errors.
	if {$sample_cnt < $::ThruputBT_dev_LE::sample_threshold} {
		set ::ThruputBT_dev_LE::need_erp yes
		set msg "$logname Only $sample_cnt $type samples, required\
			$::ThruputBT_dev_LE::sample_threshold (set $::ThruputBT_dev_LE::perf_cnt\
			of $::ThruputBT_dev_LE::perf_loop)"
		UTF::Message ERROR "$logname" "ThruputBT_dev_LE::get_WLAN_results fatal error: $msg"
		if {![info exists ::ThruputBT_dev_LE::fatal_error] ||\
			$::ThruputBT_dev_LE::fatal_error == ""} {
			set ::ThruputBT_dev_LE::fatal_error "$msg"
		}
	}

	# Return the results
	## ? UTF::Message DEBUG "" "\n\n\nThruputBT_dev_LE::get_WLAN_results sample_list=$sample_list\n\n\n"

	return $sample_list
}

#======================= get_remote_clock_delta ===============================
# Routine use to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# host: host object to get clock delta for
# tries: optional number of iterations for computing clock delta
# Returns: clock delta, in seconds
# A positive delta means the remote host clock is faster than the local clock
# A negative delta means the remote host clock is slower than the local clock
#==============================================================================
proc ThruputBT_dev_LE::get_remote_clock_delta {host {tries 10} {debug 0}} {

	## ? UTF::Message DEBUG "" "get_remote_clock_delta: host given: $host\n"

	# If we have cached value that has not been used too often,
	# then use the cached value.
	set logname [UTF::get_name $host]
	# UTF::Message ERROR "" "get_remote_clock_delta: logname given: $logname\n"
	set hType [$host hostis]

	if {[info exists ::clock_delta($logname,uses)]} {
		if {$::clock_delta($logname,uses) < 10} {
			incr ::clock_delta($logname,uses)
			set result $::clock_delta($logname,value)
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_remote_clock_delta use\
				#$::clock_delta($logname,uses) of cached result=$result"
			return $result
		}
	}

	# Get N clock time samples from the remote host. Need 3 samples
	# minimum so that later we can delete high/low values and still
	# have something left to use.
	if {$tries == "" || $tries < 3} {
		set tries 10
	}
	set clock_delta_list ""
	for {set i 0} {$i < $tries} {incr i} {

		# Get remote date/time stamp and timing info for how
		# long that took.
		set start_sec [clock seconds]
		if { $hType == "HSIC" } {
			set host $::wlan_relay
		}
		set catch_resp [catch "set remote_date \[$host rexec -quiet\
			-silent date\]" catch_msg]
		
		set stop_sec [clock seconds]
		if {$catch_resp != 0} {
			UTF::Message ERROR "$logname" "get_remote_clock_delta $catch_msg"
			return 0
		}

		# Compute clock delta
		set round_trip_sec [expr $stop_sec - $start_sec] ;# total transaction time
		regexp {\s([\d:]{8})\s} $remote_date remote_time ;# extract remote hh:mm:ss
		set remote_sec [clock scan $remote_time] ;# convert to unix seconds
		set start_time [clock format $start_sec]
		set clock_delta [expr $remote_sec - $start_sec - ($round_trip_sec/2)]
		if {$debug == 1} {
			UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::get_remote_clock_delta\
				 start_time=$start_time start_sec=$start_sec stop_sec=$stop_sec\
				 round_trip_sec=$round_trip_sec"
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_remote_clock_delta\
				 remote_date=$remote_date remote_time=$remote_time\
				 remote_sec=$remote_sec clock_delta=$clock_delta"
		}
		lappend clock_delta_list $clock_delta
	}
	# puts "clock_delta_list=$clock_delta_list"

	# Locate the lowest clock deltas and delete it.
	# NB: If you try to locate highest & lowest in same loop,
	# you may get indexing error when you delete items that
	# arent there as the list has shifted positions.
	set i 0
	set min_delta ""
	set min_i ""
	foreach delta $clock_delta_list {
		if {$min_delta == ""} {
			set min_delta $delta
			set min_i $i
		} elseif {$delta < $min_delta} {
			set min_delta $delta
			set min_i $i
		}
		# puts "i=$i delta=$delta min_delta=$min_delta min_i=$min_i"
		incr i
	}
	set clock_delta_list [lreplace $clock_delta_list $min_i $min_i]
	# puts "clock_delta_list=$clock_delta_list"

	# Locate the highest clock delta and delete it.
	set i 0
	set max_delta ""
	set max_i ""
	foreach delta $clock_delta_list {
		if {$max_delta == ""} {
			set max_delta $delta
			set max_i $i
		} elseif {$delta >= $max_delta} {
			set max_delta $delta
			set max_i $i
		}
		# puts "i=$i delta=$delta max_delta=$max_delta max_i=$max_i"
		incr i
	}
	set clock_delta_list [lreplace $clock_delta_list $max_i $max_i]
	# puts "clock_delta_list=$clock_delta_list"

	# Average the remaining clock deltas
	set cnt 0
	set total 0
	foreach delta $clock_delta_list {
		set total [expr $total + $delta]
		incr cnt
	}
	if {$cnt != 0} {
		# puts "total=$total cnt=$cnt"
		set result [expr int($total / $cnt)]
	} else {
		set result 0
	}

	# Log results, update cache & return result.
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::get_remote_clock_delta\
		high=$max_delta low=$min_delta clock_delta_list=$clock_delta_list\
		result=$result"
	set ::clock_delta($logname,value) $result
	set ::clock_delta($logname,uses) 0
	return $result
}

# Test code for routine below
# ThruputBT_dev_LE::timestamp_correction BT 01:02:13 01:02:03 2

#======================= timestamp_correction =================================
# Routine used to correct timestamps for samples from remote host to a common 
# time base for the local host.
# Calling args:
# id: bt|wlan
# time1 is localhost / UTF timestamp
# time2 is remote host timestamp
# time_delta_sec is the known time difference, in seconds, between the localhost
# and the remotehost
# Returns corrected time
# times are all in format: hh:mm:ss
#==============================================================================
proc ThruputBT_dev_LE::timestamp_correction {id time1 time2 time_delta_sec} {
	# puts "ThruputBT_dev_LE::timestamp_correction time1=$time1 time2=$time2\
	#	time_delta_sec=$time_delta_sec"

	# Convert time2 to seconds, adjust time2 and reformat
	set catch_resp [catch "set time2_sec \[clock scan $time2\]" catch_msg]
	if {$catch_resp !=0} {
		UTF::Message ERROR "$::localhost" "ThruputBT_dev_LE::timestamp_correction\
			ERROR: invalid time2=$time2 $catch_msg"
		return "$time2" 
	}
	set corrected_time_sec [expr $time2_sec - $time_delta_sec] ;# adjust to localhost timebase
	set corrected_timestamp [clock format $corrected_time_sec -format %T]

	# Keep track of worst time delay introduced by sockets
	set catch_resp [catch "set time1_sec \[clock scan $time1\]" catch_msg]
	if {$catch_resp !=0} {
		UTF::Message ERROR "$::localhost" "ThruputBT_dev_LE::timestamp_correction\
			ERROR: invalid time1=$time1 $catch_msg"
		return "$corrected_timestamp" 
	}
	set socket_delay_sec [expr abs($time1_sec - $corrected_time_sec)]
	if {![info exists ::ThruputBT_dev_LE::max_socket_delay]} {
		set ::ThruputBT_dev_LE::max_socket_delay 0
		set ::ThruputBT_dev_LE::max_socket_timestamp ""
	}
	if {$socket_delay_sec > $::ThruputBT_dev_LE::max_socket_delay} {
		set ::ThruputBT_dev_LE::max_socket_delay $socket_delay_sec
		set ::ThruputBT_dev_LE::max_socket_timestamp "$id time1=$time1\
			time2=$time2 corrected=$corrected_timestamp"
	}

	# Keep track of overall running worst time delay introduced by sockets.
	if {![info exists ::ThruputBT_dev_LE::running_max_socket_delay]} {
		set ::ThruputBT_dev_LE::running_max_socket_delay 0
		set ::ThruputBT_dev_LE::running_max_socket_timestamp ""
	}
	if {$socket_delay_sec > $::ThruputBT_dev_LE::running_max_socket_delay} {
		set ::ThruputBT_dev_LE::running_max_socket_delay $socket_delay_sec
		set ::ThruputBT_dev_LE::running_max_socket_timestamp "$id time1=$time1\
			time2=$time2 corrected=$corrected_timestamp"
	}

	# Return corrected_timestamp
	# puts "time1_sec=$time1_sec time2_sec=$time2_sec\
	#	corrected_time_sec=$corrected_time_sec"
	# puts "corrected_timestamp=$corrected_timestamp\
	#	socket_delay_sec=$socket_delay_sec"
	return "$corrected_timestamp"
}

# Test sequence for routine below.
# ThruputBT_dev_LE::remove_duplicate_samples host1 bt rx "17:01:00 3.3 17:01:00 4.3 17:01:00 5.3 17:01:00 5.4 17:00:00 2.3 17:01:01 3.3 17:01:02 3.6 17:01:02 3.7 17:01:02 3.8 17:01:03 4.0 17:01:03 4.1 17:01:03 4.2 17:01:03 4.3 17:01:04 4.4"

#======================= remove_duplicate_samples =============================
# Removes duplicate samples based on time stamps. Due slightly fuzzy timing of
# various datastreams, two samples in the same second are allowed, but no more.
# The timestamps are expected to be in ascending sequence.
# Sample_list & returned data in space separated string in format:
# time1 tput1 ... timeN tputN
# time is formated: HH:MM:SS
# tput is decimal value
# calling args host, id & type are strings shown in the log messages
#==============================================================================
proc ThruputBT_dev_LE::remove_duplicate_samples {host id type sample_list} {

	# Discard duplicate time samples. We seem to get duplicate messages
	# as the BlueTool tests shut down, so we toss them. Due slightly fuzzy
	# timing of various datastreams, two samples in the same second are
	# allowed, but no more. Check for timestamps not in ascending sequence.
	set discard_list "" ;# discarded samples
	set last_time "" ;# timestamp of previous sample
	set logname [UTF::get_name $host]
	set results "" ;# list of unique samples
	set same_time_cnt 0 ;# count of consecutive samples with same timestamp
	set warn_list "" ;# out of sequence samples
	foreach {time tput} $sample_list {
		if {$time > $last_time} {
			# Sample is in ascending order, as expected.
			lappend results $time $tput
			# puts "$time $tput ascending, keep"

		} elseif {$time == $last_time} {
			# Sample is in same second as previous sample.
			incr same_time_cnt
			if {$same_time_cnt == "1"} {
				# Allow 2 samples in same second
				lappend results $time $tput
				# puts "$time $tput duplicate, keep"

			} else {
				# After two samples in same second, samples are
				# discarded
				lappend discard_list $time $tput
				# puts "$time $tput duplicate, discard"
			}

		} else {
			# Sample is out of the expected ascending sequence.
			# Gnuplot will handle them, so we keep them as well
			# as warning the user.
			lappend results $time $tput
			lappend warn_list $time $tput
			# puts "$time $tput out of sequence, keep, warn"
		}

		# Update state variables
		if {$time != $last_time} {
			set last_time $time
			set same_time_cnt 0
		}
	}

	# Warn user if samples discarded or out of sequence, return results
	if {$discard_list != ""} {
		UTF::Message WARN "$logname" "ThruputBT_dev_LE::remove_duplicate_samples $id $type\
			dropped [expr [llength $discard_list] / 2] duplicate samples: $discard_list"
	}
	if {$warn_list != ""} {
		UTF::Message WARN "$logname" "ThruputBT_dev_LE::remove_duplicate_samples $id $type\
			[expr [llength $warn_list] / 2] out of sequence samples: $warn_list"
	}
	return $results
}

# Test sequences for routine below.
# ThruputBT_dev_LE::process_results [list bt bidirectional host1 host2 $::test_data]
# ThruputBT_dev_LE::process_results [list wlan bidirectional host1 host2 $::test_data2]
# ThruputBT_dev_LE::process_results [list bt bidirectional host1 host2 $::test_data] [list wlan bidirectional host2 host1 $::test_data2]

#======================= process_results ======================================
# Supervises the extraction of result data, creates one control chart for
# each data string in args and one overall time plot graph.
# Calling args: Each data string represents the test results of a test
# between a pair of STA, either unidirectional or bidirectional tests.
# Data strings are formated as: {id sta1 sta2 direction text_results}
# where:
# id: bt|wlan
# direction: bidirection|dut2ref|ref2dut|...
# sta1: object STA name
# sta2: object STA name
# text_results: data list returned by collect_rpopen_data
# Returns: html formated string with links to graphs.
#==============================================================================
proc ThruputBT_dev_LE::process_results {args} {

	# This code helps with unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::running_error_list]} {
		set ::ThruputBT_dev_LE::running_error_list ""
	}

	# Process each data item in args.
	set ::ThruputBT_dev_LE::current_error_list ""
	set html_results ""
	set time_plot_data ""
	foreach data $args {

		# Get id, direction, sta, etc from data. The data often has
		# unmatched brackets or braces, so we must use regexp to process.
		# lindex & lrange choke on unmatched brackets or braces.
		# NB: If we ever support id besides bt & wlan, we need to have
		# a proc called ThruputBT_dev_LE::get_$id_results to support it.
		# puts "\n\n\ndata=$data\n\n\n"
		if {![regexp {\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)} $data \
			- id direction sta1 sta2 text_results]} {
		   error "ThruputBT_dev_LE::process_results ERROR could not parse data=$data"
		}
		set id [string trim $id]
		set id [string toupper $id]
		# puts "\n\n\nid=$id direction=$direction sta1=$sta1 sta2=$sta2 \
		#	 text_results=$text_results\n\n\n"
		# ? UTF::Message DEBUG_LE "" "**** \n\n\nid=$id direction=$direction sta1=$sta1 sta2=$sta2 \
			text_results=$text_results\n\n\n ****"
		

		# Extract data, store in results array. Only the RX data is used in
		# control charts & time plots.
		# Data format: time1 value 1 ... timeN valueN
		set cc_data ""
		if {[string match "dut2*" $direction] || $direction == "bidirectional"} {
			# Log TX data, but store the RX data.
			ThruputBT_dev_LE::get_${id}_results $sta1 "$text_results" 0 tx
			set rx_data1 [ThruputBT_dev_LE::get_${id}_results $sta2 "$text_results" 0 rx]
			if {$rx_data1 !=""} {
				append ::ThruputBT_dev_LE::time_plot_array(${id}_${sta1}_-->_${sta2}) " $rx_data1"
			}
			set cc_data [ThruputBT_dev_LE::remove_timestamps $rx_data1]
		}
		if {[string match "*2dut" $direction] || $direction == "bidirectional"} {
			# Log TX data, but store the RX data.
			ThruputBT_dev_LE::get_${id}_results $sta2 "$text_results" 0 tx
			set rx_data2 [ThruputBT_dev_LE::get_${id}_results $sta1 "$text_results" 0 rx]
			if {$rx_data2 != ""} {
				append ::ThruputBT_dev_LE::time_plot_array(${id}_${sta1}_<--_${sta2}) " $rx_data2"
			}
			set cc_data [ThruputBT_dev_LE::remove_timestamps $rx_data2]
		}

		# For bidirectional test, merge the two sets of samples for the
		# control chart
		if {$direction == "bidirectional"} {
			set cc_data [ThruputBT_dev_LE::merge_samples $id [ThruputBT_dev_LE::remove_timestamps\
				$rx_data1] [ThruputBT_dev_LE::remove_timestamps $rx_data2]]
		}

		# Create new ControlChart object & graphics file
		append html_results " [ThruputBT_dev_LE::control_chart $id $direction $sta1 $sta2 $cc_data]"
	}

	# Create composite time plot graph 
	append html_results " [ThruputBT_dev_LE::timeplot]"

	# On last iteration, add fatal error, if any.
	if {$::ThruputBT_dev_LE::perf_cnt == $::ThruputBT_dev_LE::perf_loop && \
		$::ThruputBT_dev_LE::fatal_error != ""} {
		append html_results " &nbsp;<font color=\"red\"><b>FATAL ERROR</b>&nbsp;$::ThruputBT_dev_LE::fatal_error </font>"
	}

	# On the last iteration add running error list, from parsing data streams.
	# Condense the error lists to the minimum sized list with just one unique
	# copy of each error type that occured. This minimizes how messy the web
	# summary page gets when there are many errors in one test.
	set ::ThruputBT_dev_LE::current_error_list [lsort -unique $::ThruputBT_dev_LE::current_error_list]
	set ::ThruputBT_dev_LE::running_error_list [lsort -unique $::ThruputBT_dev_LE::running_error_list]
	UTF::Message LOG "$::localhost" "::ThruputBT_dev_LE::current_error_list=$::ThruputBT_dev_LE::current_error_list"
	if {$::ThruputBT_dev_LE::perf_cnt == $::ThruputBT_dev_LE::perf_loop && \
		$::ThruputBT_dev_LE::running_error_list != ""} {
		append html_results " &nbsp;<font color=\"orange\"><b>ERRORS</b>&nbsp;$::ThruputBT_dev_LE::running_error_list </font>"
	}

	# Restore the "html:" header, or UTF wont process results correctly.
	# NB: MUST NOT have leading whitespace!
	set html_results [string trim $html_results]
	if {$html_results != ""} {
		set html_results "html: $html_results"
	}
	set html_results [string trim $html_results]
	UTF::Message LOG "$::localhost" "process_results iteration\
		$::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop:\
		html_results=$html_results"

	# How we return html_results depends on error lists & iteration counter.
	# For intermediate iterations, we dont throw errors. This allows all the
	# interations to be completed.
	if {$::ThruputBT_dev_LE::perf_cnt == $::ThruputBT_dev_LE::perf_loop &&\
		($::ThruputBT_dev_LE::running_error_list != "") ||\
		$::ThruputBT_dev_LE::fatal_error != ""} {
		error "$html_results"
	} else {
		return "$html_results"
	}
}

# Test sequence for routine below.
# ThruputBT_dev_LE::remove_timestamps {a 1 b 2 c 3 d 4 e 5}

#======================= remove_timestamps ====================================
# Routine removes the timestamps from a series of samples.
# Calling arg: space separated string in format:
# time1 tput1 ... timeN tputN
# Returns data in space separated string in format:
# tput1 ... tputN
#==============================================================================
proc ThruputBT_dev_LE::remove_timestamps {series} {

	# Remove the time stamps from the series.
	set results ""
	foreach {time tput} $series {
		lappend results $tput
	}

	# Return results
	return $results
}

# Test sequence for routine below
# ThruputBT_dev_LE::merge_samples bt {1 2 3 4 5} {6 7 8 9}

#======================= merge_samples ========================================
# Merges two unidirectional series of thruput values to give a composite
# bidirectional data series for use in a control chart.
# Calling args: space separated series of decimal thruput values
# Returns:space separated series of decimal thruput values 
#==============================================================================
proc ThruputBT_dev_LE::merge_samples {id series1 series2} {

	# Check series sizes. If different, drop earlier samples 
	# from the longer series.
	set cnt1 [llength $series1]
	set cnt2 [llength $series2]
	if {$cnt1 > $cnt2} {
		set i [expr $cnt1 - $cnt2]
		set series1 [lrange $series1 $i end]
		UTF::Message WARN "$::localhost" "ThruputBT_dev_LE::merge_samples\
			 dropping $i samples during merge"
	} elseif {$cnt1 < $cnt2} {
		set i [expr $cnt2 - $cnt1]
		set series2 [lrange $series2 $i end]
		UTF::Message WARN "$::localhost" "ThruputBT_dev_LE::merge_samples\
			 dropping $i samples during merge"
	}
	# UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::merge_samples series1=$series1"
	# UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::merge_samples series2=$series2"

	# Add the 2 series together value by value to get bidirectional
	# series of values.
	set cnt [llength $series1]
	set series3 ""
	for {set i 0} {$i < $cnt} {incr i} {
		set value [expr [lindex $series1 $i] + [lindex $series2 $i]]
		lappend series3 $value
	}

	# Log & return the results
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::merge_samples $id bidirectional\
		cnt=$cnt series=$series3"
	return "$series3"
}

# Test sequence for routine below.
# ThruputBT_dev_LE::control_chart id dut2ref host1 host2 "3 4 5 6 7"

#======================= control_chart ========================================
# Feeds thruput samples to control chart in set sizes that the control
# chart can handle (2 - 25).
# Calling args: 
# The first four args are text strings used to help create unique keys
# for the perfcache data.
# sample_list is a space separated list of decimal thruput values.
# Returns: html string with control chart png file & thumbnail data
#==============================================================================
proc ThruputBT_dev_LE::control_chart {id direction sta1 sta2 sample_list} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_size]} {
		set ::ThruputBT_dev_LE::perf_size 5
	}
	if {![info exists ::ThruputBT_dev_LE::bt_test]} {
		set ::ThruputBT_dev_LE::bt_test "-1"
	}
	if {![info exists ::ThruputBT_dev_LE::bt_pkt]} {
		set ::ThruputBT_dev_LE::bt_pkt "-1"
	}
	if {![info exists ::ThruputBT_dev_LE::bt_dir]} {
		set ::ThruputBT_dev_LE::bt_dir bidirectional
	}
	if {![info exists ::ThruputBT_dev_LE::wlan_dir]} {
		set ::ThruputBT_dev_LE::wlan_dir bidirectional
	}
	if {![info exists ::ThruputBT_dev_LE::history]} {
		set ::ThruputBT_dev_LE::history 30
	}
	if {![info exists ::ThruputBT_dev_LE::key]} {
		set ::ThruputBT_dev_LE::key "-1"
	}
	if {![info exists ::ThruputBT_dev_LE::profile]} {
		set ::ThruputBT_dev_LE::profile "-1"
	}

	# Create ControlChart object regardless of samples being
	# available or not. We may need to generate control chart
	# graphics from previous iteration data.
	set sample_cnt [llength $sample_list]
	set id [string toupper $id]
	set profile $::ThruputBT_dev_LE::profile
	if {$id == "BT"} {
		set direction2 $::ThruputBT_dev_LE::wlan_dir
	} else {
		set direction2 $::ThruputBT_dev_LE::bt_dir
	}
	if {$profile >= 2} {
		# For two traffic flows, add second direction key to ensure uniqness.
		set cc_keys "$::ThruputBT_dev_LE::key P=$profile $id\
			$::ThruputBT_dev_LE::bt_test $::ThruputBT_dev_LE::bt_pkt $direction\
			$direction2 $sta1 $sta2"

	} elseif {$profile == 1} {
		# profile=1 WLAN only traffic
		set cc_keys "$::ThruputBT_dev_LE::key P=$profile $id $direction $sta1 $sta2"

	} else {
		# profile=0 BT only traffic
		set cc_keys "$::ThruputBT_dev_LE::key P=$profile $id\
			$::ThruputBT_dev_LE::bt_test $::ThruputBT_dev_LE::bt_pkt $direction\
			$sta1 $sta2"
	}
	set cc_keys [string trim $cc_keys]
	set logname [UTF::get_name $sta1]
	UTF::Message LOG "$logname" "ThruputBT_dev_LE::control_chart\
		history=$::ThruputBT_dev_LE::history cc_keys=$cc_keys\
		sample_size=$::ThruputBT_dev_LE::perf_size sample_cnt=$sample_cnt\
		sample_list=$sample_list"
	UTF::ControlChart CC -s $::ThruputBT_dev_LE::perf_size -key $cc_keys\
		-history $::ThruputBT_dev_LE::history

	# Do we have enough samples to process?
	set cc_errors "" ;# list of error from control chart
	set cc_others ""  ;# list of other results from control chart
	set cc_result "" ;# result string from control chart
	set sample_cnt [llength $sample_list]
	set min_samples [expr int(0.8 * $::ThruputBT_dev_LE::perf_size)]
	# puts "sample_cnt=$sample_cnt min_samples=$min_samples"
	if {$sample_cnt < $min_samples} {
		set msg "CC too few samples!"
		lappend ::ThruputBT_dev_LE::current_error_list "$msg"
		lappend ::ThruputBT_dev_LE::running_error_list "$msg"
		UTF::Message ERROR "$logname" "ThruputBT_dev_LE::control_chart $id\
		   $direction $sta1 $sta2 $msg"
		# NB: We dont return here. We may still need to generate the 
		# overall CC for previous iterations.

	} else {
		# Process the samples.
		if {$sample_cnt < $::ThruputBT_dev_LE::perf_size} {
			UTF::Message WARN "$logname" "ThruputBT_dev_LE::control_chart\
				$id $direction $sta1 $sta2 only $sample_cnt samples!"
		}

		# Process samples in groups of perf_size. This allows hundreds
		# of samples from a large run to be fed into the controlchart
		# within the limits of the controlchart sample size restrictions.
		set i 0
		while { 1 } {

			# Get next perf_size group of samples.
			set j [expr $i + $::ThruputBT_dev_LE::perf_size - 1]
			set cc_samples [lrange $sample_list $i $j]
			UTF::Message LOG "$logname" "ThruputBT_dev_LE::control_chart\
				i=$i j=$j cc_samples=$cc_samples"

			# Are there enough samples in this group to work with?
			set cnt [llength $cc_samples]
			if {$cnt < $min_samples} {
				UTF::Message WARN "$logname" "ThruputBT_dev_LE::control_chart\
					$id $direction $sta1 $sta2 dropping samples: $cc_samples"
				break
			}

			# Use the common UTF routine for mean, min, max
			set cc_mmm [UTF::MeanMinMax $cc_samples]
			# set cc_mmm "0.1 0.1 0.1" ;# test data

			# Add data sample, check for errors & other messages from
			# the ControlChart.
			set cc_result [CC addsample $cc_mmm]
			# puts "cc_result=$cc_result"
			if {[regexp -nocase {(LOW|WIDE|ZERO)} $cc_result - code]} {
				append cc_errors " $code"
			}
			if {[regexp -nocase {(HIGH)} $cc_result - code]} {
				append cc_others " $code"
			}

			# Exit loop when we hit end of sample list.
			incr i $::ThruputBT_dev_LE::perf_size
			if {$i >= $sample_cnt} {
				break
			}
		}

# # # ???
# # #		 Add wlan throughput <10Mbps check here? 4/4/14
# # # ???

		# Make list of codes unique. Selectively add errors to error lists.
		set cc_errors [lsort -unique $cc_errors]
		set cc_errors [string trim $cc_errors]
		set cc_others [lsort -unique $cc_others]
		set cc_others [string trim $cc_others]
		# puts "cc_errors=$cc_errors cc_others=$cc_others"
		if {$cc_errors != ""} {
			set msg "$cc_errors"
			UTF::Message ERROR "$logname" "ThruputBT_dev_LE::control_chart $id\
				$direction $sta1 $sta2 CC $msg"
			lappend ::ThruputBT_dev_LE::current_error_list "$msg"

			# The running error list is shown on the web summary page.
			# To avoid redundant error messages, if there are already 
			# other errors, there is no need to add these errors.
			# However if there are no other errors, we do need to a token
			# error msg so that the higher level routines will correctly
			# throw an error as the overall result.
			if {$::ThruputBT_dev_LE::running_error_list == ""} {
				set ::ThruputBT_dev_LE::running_error_list "$cc_errors"
			}
		}
	}

	# If not the last iteration, return
	if {$::ThruputBT_dev_LE::perf_cnt != $::ThruputBT_dev_LE::perf_loop} {
		CC destroy
		return
	}

	# Update the last result with any error/other codes that occured.
	# puts "cc_result=$cc_result"
	if {$cc_errors != ""} {
		regsub -nocase -all " OK| LOW| WIDE| ZERO" $cc_result "" cc_result
		append cc_result " $cc_errors"
	}
	if {$cc_others != ""} {
		regsub -nocase -all " OK| HIGH" $cc_result "" cc_result
		append cc_result " $cc_others"
	}
	set cc_result [string trim $cc_result]
	if {$cc_result == ""} {
		set cc_result "---"
	}
	# puts "cc_result=$cc_result"

	# Get the control chart graphics
	set chart [CC plotcontrolchart $cc_result]
	CC destroy

	# Add formating to identify the control chart. When there
	# is more than one control chart on a single line on the web
	# summary page, you need some additional identifiers to tell 
	# whats what. 
	regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
	set chart " &nbsp;<b>$id</b>&nbsp;${chart}" ;# add bold id
	return "$chart"
}

# Test data for routine below.
# set ::ThruputBT_dev_LE::time_plot_array(wlan_host1_-->_host2) "17:05  33 17:06  34 17:07  35 17:08  36 17:09   37"
# set ::ThruputBT_dev_LE::time_plot_array(bt_host1_-->_host2)   "17:05 0.2 17:06 0.4 17:07 0.5 17:08 0.6 17:09 0.27"

#======================= timeplot =============================================
# Takes data from global array time_plot_array and creates a composite time
# plot graph.
# Calling args: none
# Returns: html string with control chart png file & thumbnail
#==============================================================================
proc ThruputBT_dev_LE::timeplot {} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::perf_cnt]} {
		set ::ThruputBT_dev_LE::perf_cnt 1
	}
	if {![info exists ::ThruputBT_dev_LE::perf_loop]} {
		set ::ThruputBT_dev_LE::perf_loop 1
	}
	if {![info exists ::ThruputBT_dev_LE::fatal_error]} {
		set ::ThruputBT_dev_LE::fatal_error ""
	}

	# Create composite time plot graph just on the last iteration.
	if {$::ThruputBT_dev_LE::perf_cnt != $::ThruputBT_dev_LE::perf_loop} {
		return
	}

	# Get list of data series from the time_plot_array.
	# Array is wiped clean in the process.
	set names [array names ::ThruputBT_dev_LE::time_plot_array]
	set names [lsort $names]
	set series ""
	foreach name $names {

		# Format name into series title.
		regsub -all "_" $name " " series_title 

		# Axes to use for plot is determined by ID, the first token in title
		set id [lindex $series_title 0]
		set id [string trim $id]
		set id [string toupper $id]
		if {$id == "BT"} {
			set axes x1y2 ;# plot BT data on right Y-axis
		} else {
			set axes x1y1 ;# plot WLAN data on left Y-axis
		}
		# puts "series_title=$series_title id=$id axes=$axes"

		# Add series data to list. Dont purge the time plot array!
		lappend series "\"$series_title\" $axes $::ThruputBT_dev_LE::time_plot_array($name)"
	}

	# If there are series, plot them.
	set series [string trim $series]
	# puts "series=$series"
	if {$series == ""} {
		return
	}
	if {![info exists ::ThruputBT_dev_LE::title]} {
		set ::ThruputBT_dev_LE::title ""
	}
	set chart [UTF::gnuplot_lines "$::ThruputBT_dev_LE::title" "Time HH:MM:SS" "time"\
		"WLAN Throughput (Mbit/sec)" "BT Throughput (Mbit/sec)" "Time Plot"\
		"$series"]

	# Add formatting to chart.
	regsub -nocase {^html:} $chart "" chart ;# remove "html:" header
	append html_results " &nbsp;<b>DATA</b>&nbsp;${chart}"
}

#======================= error_recovery_procedure =============================
# When request, usually after a fatal error, reload both bluetooth devices and
# make a new BT connection. This ensures the next test or iteration will have
# a relatively clean starting point. Keep track of how often this happens.
# Calling args: none
# Returns: nothing, does NOT throw errors.
#==============================================================================
proc ThruputBT_dev_LE::error_recovery_procedure {bt_dut bt_ref} {

	# This code facilitates unit level interactive debugging.
	if {![info exists ::ThruputBT_dev_LE::bt_pkt]} {
		set ::ThruputBT_dev_LE::bt_pkt auto
	}

	# If necessary, initialize counter for error recovery procedures
	if {![info exists ::ThruputBT_dev_LE::erp_cnt]} {
		set ::ThruputBT_dev_LE::erp_cnt 0
	}
	incr ::ThruputBT_dev_LE::erp_cnt
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::error_recovery_procedure\
		START erp_cnt=$::ThruputBT_dev_LE::erp_cnt bt_dut=$bt_dut bt_ref=$bt_ref"

	# Reload both BlueTooth devices.
	# set catch_resp 1 ;# test code
	set catch_resp [catch "$bt_dut reload" catch_msg]
	if {$catch_resp != 0} {
		set logname [UTF::get_name $bt_dut]
		UTF::Message ERROR "$logname" "could not reload bt_dut=$bt_dut!"
	}
	set catch_resp [catch "$bt_ref reload" catch_msg]
	if {$catch_resp != 0} {
		set logname [UTF::get_name $bt_ref]
		UTF::Message ERROR "$logname" "could not reload bt_ref=$bt_ref!"
	}

	# if this is a recovery during the WLAN only throughput test, then skip the BT recovery 
	if {$::ThruputBT_dev_LE::bt_test == "n\/a"} {
		UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::error_recovery_procedure\
			END erp_cnt=$::ThruputBT_dev_LE::erp_cnt\
				================================================================="
		return
	}

	# Forget the old BT connections.
	$bt_dut delete_acl_handles $::ThruputBT_dev_LE::handle_acl_dut
	$bt_ref delete_acl_handles $::ThruputBT_dev_LE::handle_acl_ref

	# this recovery is not correct when we are in slave mode because
	# when ConnectBTdevices is called, the 1st paramter needs to be the 
	# master, but here bt_dut is passed which could be the slave
	# Make new BT connection.
	if {$::ThruputBT_dev_LE::bt_slave_test == 0} {
		# master connection
		set catch_resp [catch "UTF::Test::ConnectBTdevices \"$bt_dut\" \
			\"$bt_ref\" -type $::ThruputBT_dev_LE::bt_pkt" catch_msg]
	} else {
		# slave connection
		set catch_resp [catch "UTF::Test::ConnectBTdevices \"$bt_ref\" \
			\"$bt_dut\" -type $::ThruputBT_dev_LE::bt_pkt" catch_msg]
	}

	if {$catch_resp != 0} {
		set logname [UTF::get_name $bt_dut]
		UTF::Message ERROR "$logname" "could not establish new BT connection!"
	} else {
		# error_recovery_procedure was ok, set the need_erp to no in order
		# for error_recovery_procedure not to be called again due to retry
		set ::ThruputBT_dev_LE::need_erp no
	}

	# Update the handles that will be used in the next test or iteration.
	# If we didnt get a new connection, the handles are deliberately left
	# as -1, which will quickly trigger errors in the next test.
	set ::ThruputBT_dev_LE::handle_dut -1
	set ::ThruputBT_dev_LE::handle_ref -1
	set ::ThruputBT_dev_LE::handle_acl_dut -1
	set ::ThruputBT_dev_LE::handle_acl_ref -1

	set temp [$bt_dut show_acl_handles]
	if {$temp != ""} {
		set ::ThruputBT_dev_LE::handle_dut $temp
		set ::ThruputBT_dev_LE::handle_acl_dut $temp
	}
	set temp [$bt_ref show_acl_handles]
	if {$temp != ""} {
		set ::ThruputBT_dev_LE::handle_ref $temp
		set ::ThruputBT_dev_LE::handle_acl_ref $temp
	}

	# Time will tell if we need to restart the WLAN devices.
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE::error_recovery_procedure\
		END erp_cnt=$::ThruputBT_dev_LE::erp_cnt bt_dut=$bt_dut bt_ref=$bt_ref\
		================================================================="
	return
}


#======================= ThruputBT_dev_LE ============================================
# Main test program. Supervises the initialization, runs the desired test
# profile multiple times as needed.
# Calling args bt_dut & bt_ref are the STA object names to be tested.
# Returns html formatted string with links to control chart & time plot
# graphics files.
#==============================================================================
# added ble_dut ble_ref to argument
UTF::Test ThruputBT_dev_LE {ble_dut ble_ref bt_dut bt_ref args} {

	# Basic command line option processing. Options are stored in the
	# unnamed array $()
	UTF::Getopts "$::ThruputBT_dev_LE_getopts" "$::ThruputBT_dev_LE_help"

	# Run setup routine. The "" passes the unnamed array to setup.
	ThruputBT_dev_LE::setup $ble_dut $ble_ref $bt_dut $bt_ref ""
	UTF::Message DEBUG "" "\nExited ThruputBT_dev_LE::setup\n"

	# Run the desired test profile perfloop times.
	# NB: process_results and other routines are watching ::ThruputBT_dev_LE::perf_cnt
	# and expects the final value to be ::ThruputBT_dev_LE::perf_loop, which is why
	# ::ThruputBT_dev_LE::perf_cnt needs to start at 1, not 0.
	set iteration_errors 0 ;# keep track of all errors across all iterations.
	for {set ::ThruputBT_dev_LE::perf_cnt 1} {$::ThruputBT_dev_LE::perf_cnt <=\
		$::ThruputBT_dev_LE::perf_loop} {incr ::ThruputBT_dev_LE::perf_cnt} {

		UTF::Message DEBUG_LE "" "**** Inside ThruputBT_dev_LE::perf_loop ****"

		# When running multiple iterations, put a marker line in the log.
		if {$::ThruputBT_dev_LE::perf_loop > 1} {
			UTF::Message LOG "$::localhost" "ThruputBT_dev_LE getting sample\
				set $::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop\
				============================================================="
	}

		# Run the desired test profile, count all errors.
		set results ""
		set catch_msg ""
		set catch_resp [catch "set results \[ThruputBT_dev_LE::test_profile$(profile)\
			$ble_dut $ble_ref\]" catch_msg]
		if {$catch_resp != 0} {
			incr iteration_errors ;# keep track of all errors across all iterations.
		}
		UTF::Message LOG "$::localhost" "ThruputBT_dev_LE main loop iteration:\
			$::ThruputBT_dev_LE::perf_cnt of $::ThruputBT_dev_LE::perf_loop \
			iteration_errors=$iteration_errors catch_resp=$catch_resp\
			catch_msg=$catch_msg\nresults=$results"

		# Reset the timer cmds, or they accumulate from one iteration to
		# the next.
		set ::ThruputBT_dev_LE::timer_cmds ""

		# NB: Never reset the fatal_error, or  it wont show up on the web
		# page summary.

		# ----> take out recovery for code development

		 # When requested, do the error recovery procedure. This ensures
		 # that the next test or iteration will have a relatively clean
		 # starting point.
		 # Sometimes error_recovery_procedure fails and retry is needed
		 for {set retry_cnt 1} {$retry_cnt <= 3} {incr retry_cnt} {
			 if {$::ThruputBT_dev_LE::need_erp == "yes"} {
				 UTF::Message DEBUG_LE "" "**** This dummy only for development ****"
					 UTF::Message LOG "$::localhost" "======================================================================================================="
					 UTF::Message LOG "$::localhost" "error_recovery_procedure try $retry_cnt"
	### no doing REAL recovery during development
	# # #					  ThruputBT_dev_LE::error_recovery_procedure $bt_dut $bt_ref
			}
		}

		# end of recovery code

	}
	# end of perf_cnt loop

	# Return the results.
	UTF::Message LOG "$::localhost" "ThruputBT_dev_LE main loop completed\
		iteration_errors=$iteration_errors\
		erp_cnt=$::ThruputBT_dev_LE::erp_cnt"
	UTF::Message LOG "$::localhost" "max_socket_delay=$::ThruputBT_dev_LE::running_max_socket_delay\
		seconds occured at: $::ThruputBT_dev_LE::running_max_socket_timestamp"
	if {$iteration_errors == 0} {
		return "$results"
	} else {
		set error_result "$results $catch_msg"
		set error_result [string trim $error_result]
		error "$error_result"
		return "$results"
	}
return ;# needed if sourced
}
