#!/bin/env utf
# -*-tcl-*-

# Reboots the testbed before the tests are run. There is an option to reboot
# all the hosts, instead of just those that are unresponsive.
#
# To get online help, type: Test/RebootTestbed.test -h
#
# $Id$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set RebootTestbed_help "\n\nBasic usage: RebootTestbed.test <options>\
    \n\nFor each host in the testbed, checks which host unresponsive,\
    \nattempts a graceful shutdown, followed by a power cycle, including\
    \nexternal STAs & waits for the hosts to respond to ssh requests. Hosts\
    \nare rebooted in parallel to minimize the elapsed time.\
    \n\nNB: Real AP are NOT rebooted, BUT SoftAP are rebooted.\
    \n\nIf you need to reboot only a subset of your testbed, there are 3\
    \nvariables that your script can set to specify the desired subset:\
    \nset ::endpoint_device_list \"host1 host2 host5 host6\"\
    \nset ::lan_peer_sta_list \"\"\
    \nset ::wan_peer_sta_list \"\"\
    \nYou need all 3 variables, even if some of them are null, as this\
    \nscript looks for all 3 variables and will ignore you if any are not\
    \npresent. It doesnt really matter which names go in which variable,\
    \nthey all get processed.\
    \n\nThere is an option to reboot all the hosts, instead of just those that\
    \nare unresponsive.\n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set RebootTestbed_getopts {
    {email.arg "" "Email address list, format: userid1,userid2,... default is your userid"}
    {full "Reboot all hosts no matter what. Default is a conditional check & reboot."}
    {hostlist.arg "" "Specify list of hosts to operate on. This will override the 3 device lists described above"}
    {logdir.arg "" "Log directory override"}
    {noconsole "Dont check the serial console ports. Default is to check the serial consoles."}
    {noreboot "After powering down the host, leave it in the powered down state. This option turns on -full."}
    {retry.arg 3 "Number of times to try rebooting a device"}
}

# Setup online help info.
UTF::setup_help $RebootTestbed_help $RebootTestbed_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# NB: The UTF package seems to recognize -utfconf option without any 
# additional code in this script.

# Load packages
package require UTF
package require UTF::utils

# Namespace & package provide
namespace eval UTF::Test::RebootTestbed {}
package provide UTF::Test::RebootTestbed 2.0

# Common procs

# Check which hosts are responding or not. Responding means host will
# allow an incoming ssh session and answer the uname -a command.

# Takes list of host UTF object names to check, returns the list of
# unresponsive host UTF object names. If the hosts are all responding,
# the returned list is null. The calling routine can decide to throw an
# error or not as it deems fit.

# The optional parameters controls how long we sit in a loop waiting
# for the hosts to respond. For a large number of PC, we need timers
# as well as loop counters to keep things under reasonable control.

# If min_tries=max_tries=1 and loop_time=max_time=0, then hosts must respond
# on the first try or they will be declared unresponsive. The process will
# run for as long as it takes to query each host once. This could be a long
# time, 1 minute per PC that is not responding. 

# For other parameter values, the proc will poll unresponsive PCs a minimum
# of min_tries, subject to a loop_time timer that updated at the end of each
# iteration of the main loop. There is also a max_time timer that is updated
# after each PC is polled, to keep the overall time duration sane. A timer
# value of 0 means the timer is not active / used.

# The last parameter, noreboot is specified in the case where we want the
# host to remain powered off, and should not be responding to pings. In this
# case, the list of hosts returned will be those that are still responding
# to pings and presumably did not power down properly.

proc check_responding_hosts { host_object_list {min_tries 1} {max_tries 10}
    {loop_time 600} {max_time 900} {noreboot 0}} {

    # Check host_list is not null
    set host_object_list [string trim $host_object_list]
    if {$host_object_list == ""} {
        error "check_responding_hosts ERROR: host_object_list is null!"
    }

    # Check min_tries is GE 1
    set min_tries [string trim $min_tries]
    if {$min_tries == "" || ![regexp {^\d+$} $min_tries] || $min_tries < 1} {
        set min_tries 1
    }
    set min_tries [expr int($min_tries)]

    # Check max_tries is GE min_tries
    set max_tries [string trim $max_tries]
    if {$max_tries == "" || ![regexp {^\d+$} $max_tries] || $max_tries < $min_tries} {
        set max_tries $min_tries
    }
    set max_tries [expr int($max_tries)]

    # Check loop_time is GE 0
    set loop_time [string trim $loop_time]
    if {$loop_time == "" || ![regexp {^\d+$} $loop_time] || $loop_time < 0} {
        set loop_time 0
    }
    set loop_time [expr int($loop_time)]

    # Check max_time is GE loop_time
    set max_time [string trim $max_time]
    if {$max_time == "" || ![regexp {^\d+$} $max_time] || $max_time < $loop_time} {
        set max_time $loop_time 
    }
    set max_time [expr int($max_time)]

    # Log calling data
    UTF::Message INFO $::localhost "check_responding_hosts\
        host_object_list=$host_object_list min_tries=$min_tries\
        max_tries=$max_tries loop_time=$loop_time max_time=$max_time\
        noreboot=$noreboot"

    # Setup ping options based on local OS.
    set local_os abcde ;# test code
    if {[string match -nocase "*linux*" $::local_os]} {
        set ping_options "-c 2" ;# Linux
    } else {
        set ping_options "-n 2" ;# Windows
    }

    # Wait in a loop waiting for each host to respond to the uname command.
    set break_outer_loop no ;# flag used to break from double loop
    set hosts_responding_ok ""
    set hosts_not_responding ""
    set start_sec [clock seconds]
    # puts "start_sec=$start_sec"
    for {set i 1} {$i <= $max_tries} {incr i} {
        foreach host $host_object_list {

            # Get lan_ip of host. This is used for ping command.
            set lan_ip [$host cget -lan_ip]
            set lan_ip [string trim $lan_ip]
            if {$lan_ip == ""} {
                set lan_ip [$host cget -name]
                set lan_ip [string trim $lan_ip]
            }

            # When we can run the uname command, the OS is responding.
            # There have been cases where a host was in a weird state
            # and the uname command took over 2 hours to time out. So we
            # ping the host first before we try the uname command.
            # puts "i=$i host=$host host_object_list=$host_object_list"
            UTF::Message LOG "$::localhost" "check_responding_hosts\
                host=$host lan_ip=$lan_ip i=$i"
            set catch_resp [catch "exec ping $lan_ip $ping_options" catch_msg]
            if {$catch_resp == 0 && $noreboot == 0} {
                # Host responded OK to ping. It is probably safe to try uname.
                # Use the -noinit option to minimize the possible damage.
                UTF::Message LOG "$::localhost" "check_responding_hosts host\
                     responded to ping"
                set catch_resp [catch "set info \[$host rexec -noinit -timeout 30\
                    -Timeout 45 uname -a\]" catch_msg]
                if {$catch_resp == 0} {

                    # This host is responding. Log & save this data.
                    # Remove host from host_list so we dont check it anymore.
                    UTF::Message LOG $::localhost "check_responding_hosts\
                        host=$host lan_ip=$lan_ip is responding, i=$i"
                    lappend hosts_responding_ok "$host i=$i"
                    set j [lsearch -exact $host_object_list $host]
                    set host_object_list [lreplace $host_object_list $j $j]
                    # puts "host_object_list=$host_object_list"
                }
            } elseif {$catch_resp != 0 && $noreboot != 0} {
                # Host did not respond to ping and we do NOT want to reboot it.
                # Remove host from host_object_list
                UTF::Message LOG $::localhost "check_responding_hosts\
                    host=$host lan_ip=$lan_ip is NOT responding as desired, i=$i"
                lappend hosts_not_responding "$host i=$i"
                set j [lsearch -exact $host_object_list $host]
                set host_object_list [lreplace $host_object_list $j $j]
                 puts "host_object_list=$host_object_list"

            } else {
                UTF::Message LOG "$::localhost" "$host uname not done as ping\
                    failed: $catch_msg"
            }

            # Check if we have exceed the max_time allowed.
            set now_sec [clock seconds]
            set elapsed_sec [expr $now_sec - $start_sec]
            if {$max_time > 0 && $elapsed_sec >= $max_time} {
                UTF::Message LOG "$::localhost" "check_responding_hosts\
                    stopping i=$i elapsed_sec=$elapsed_sec >= max_time=$max_time"
                set break_outer_loop yes
                break
            }
        }

        # If we have exceeded the max_time allowed, stop immediately.
        if {$break_outer_loop == "yes"} {
            break
        }

        # Check if we are done. Dont stay in loop unless we have more work.
        set host_object_list [string trim $host_object_list]
        if {$host_object_list == ""} {
            break
        }

        # If we have done min_tries iterations of the loop and exceeded
        # the loop timer, we quit.
        set now_sec [clock seconds]
        set elapsed_sec [expr $now_sec - $start_sec]
        if {$i >= $min_tries && $loop_time > 0 && $elapsed_sec >= $loop_time} {
            UTF::Message LOG "$::localhost" "check_responding_hosts\
                stopping i=$i >= min_tries=$min_tries &&\
                elapsed_sec=$elapsed_sec >= loop_time=$loop_time"
            break
        }

        # Wait and try again.
        if {$i < $max_tries} {
            UTF::Sleep 30 "$::localhost" "i=$i elapsed_sec=$elapsed_sec\
                hosts_responding_ok=$hosts_responding_ok\
                unresponsive_hosts=$host_object_list"
        }
    }

    # Log results, return non-responsive hosts
    set hosts_responding_ok [string trim $hosts_responding_ok]
    set hosts_not_responding [string trim $hosts_not_responding]
    set host_object_list [string trim $host_object_list]
    if {$noreboot == 0} { 
        UTF::Message LOG $::localhost "check_responding_hosts\
            hosts_responding_ok=$hosts_responding_ok\
            unresponsive_hosts=$host_object_list"
    } else {
        UTF::Message LOG $::localhost "check_responding_hosts\
            hosts_not_responding=$hosts_not_responding\
            still_responsive_hosts=$host_object_list"
    }
    return $host_object_list
}

# Used to generate the name of a log file for this specific reboot attempt
# of this specified host. 

# The returned file name is of the form: /path/host.N.log
# Where N is the next unused integer.

# Since there can be multiple runs of the RebootTestbed script within a
# given test run, and each host can have multiple reboot retries, we need
# choose unique log file names for each attempt. Otherwise we will overwrite
# previous files and lose the trace data of what happened.

proc pick_log_file { host } {

    # Check host is not null.
    set host [string trim $host]
    if {$host == ""} {
        error "pick_log_file ERROR: host is null!"
    }

    # Choose the path location for the new log file.
    if {[info exists UTF::Logdir]} {
        set path $UTF::Logdir
    } elseif {[info exists UTF::SummaryDir]} {
        set path $UTF::SummaryDir
    } else {
        set path [pwd]
    }

    # Find first unused log file name for this host.
    for {set i 1} {$i <= 50} {incr i} {
        set log_file "${path}/${host}.${i}.log"
        if {![file exists "$log_file"]} {
            UTF::Message LOG "$::localhost" "pick_log_file using\
                log_file=$log_file"
            return $log_file
        }
    }

    # We couldnt find a file name that wasnt already in use. So we
    # overwrite the last one.
    UTF::Message ERROR "$::localhost" "pick_log_file ERROR: overwriting\
        log_file=$log_file"
    return $log_file
}

# Main test.
UTF::Test RebootTestbed {args} {

    # Parse command line options.
    UTF::Getopts "$::RebootTestbed_getopts" "$::RebootTestbed_help"

    # This script may be nested inside another higher level script. In this
    # case, setup_testbed_info may have already been run. It is also possible
    # that the lists of devices has been pared down to reduce the items being
    # tested. So we need to be careful and not modify the preparations made
    # by the higher level script.
    # set ::endpoint_device_list Utf2Test4a1 ;# test code
    # set ::lan_peer_sta_list lan  ;# test code
    # set ::wan_peer_sta_list wan  ;# test code
    if {[info exists ::endpoint_device_list] &&\
        [info exists ::lan_peer_sta_list] &&\
        [info exists ::wan_peer_sta_list]} {
        UTF::Message INFO "" "using existing setup_testbed_info"
        if {![info exists ::UTF::trailer_info]} {
            set ::UTF::trailer_info "<br>Missing testbed info!<br>"
        }
    } else {
        UTF::Message INFO "" "running setup_testbed_info"
        set ::UTF::trailer_info [UTF::setup_testbed_info $(email) $(logdir)]
    }

    # Ensure ::localhost is set
    if {[info exists ::env(HOSTNAME)]} {
        set ::localhost $::env(HOSTNAME)
    } elseif {[info exists ::env(HOST)]} {
        set ::localhost $::env(HOST)
    } else {
        set catch_resp [catch "set ::localhost \[exec hostname\]" catch_msg]
        # puts "exec hostname catch_resp=$catch_resp catch_msg=$catch_msg"
        if {$catch_resp != 0} {
            set ::localhost unknown
        }
    }
    # puts "::localhost=$::localhost"

    # Although the trailer / testbed info is added to the end of the summary
    # web page, for development, a lot of the time the script is deliberately
    # aborted before this occurs. Logging the data now ensures you can go see
    # the data on your screen or the general log file.
    UTF::Message INFO $::localhost "$::UTF::trailer_info"
    if {![info exists ::branch_list]} {
        set ::branch_list unknown
    }
    set summaryinfo ""

    # Set email subject & report title.
    set email_subject [UTF::setup_email_subject]

    # Main code body that starts html summary report and runs tests.
    # puts "UTF::SummaryDir=$UTF::SummaryDir summaryinfo=$summaryinfo\
    #    email_subject=$email_subject"
    UTF::WrapSummary $UTF::SummaryDir "$email_subject" "$summaryinfo" "$(email)" {

        UTF::Try "Get lists of hosts" {
            # Get local ip address & OS
            set local_ip [UTF::get_ip_addr $::localhost]
            set ::local_os $::tcl_platform(os)
            UTF::Message INFO $::localhost "localhost=$::localhost\
                local_ip=$local_ip local_os=$::local_os"

            # Load testbed host names into 2 lists. Routers are ignored.
            set total_devices 0
            set defer_list "" ;# host whose reboot is defered until very end
            set ip_list "";# unique list of IP addresses
            set name_list "" ;# unique list of host names (not objects)
            set primary_list "" ;# all other host in the testbed not in defer_list
            set complete_list ""
            set error_list ""

            # Command line hostlist overrides other device lists.
            if {$(hostlist) == ""} {
                # With the advent of SoftAP, we need to include the router_device_list.
                if {![info exists ::router_device_list]} {
                    set ::router_device_list ""
                }
                UTF::Message INFO $::localhost "endpoint_device_list=$::endpoint_device_list\
                    lan_peer_sta_list=$::lan_peer_sta_list wan_peer_sta_list=$::wan_peer_sta_list\
                    router_device_list=$::router_device_list"
                set (hostlist) "$::endpoint_device_list $::lan_peer_sta_list $::wan_peer_sta_list $::router_device_list"
            } else {
                UTF::Message INFO $::localhost "command line hostlist=$(hostlist)"
            }

            # Process each host.
            foreach item "$(hostlist)" {
            
                # Ignore blank items
                set item [string trim $item]
                if {$item == ""} {
                    continue
                }

                # Filter out invalid items.
                set catch_resp [catch "set host_type \[UTF::check_host_type $item\]" catch_msg]
                if {$catch_resp != 0} {
                    UTF::Message ERROR $::localhost "skipping $item $catch_msg"
                    lappend error_list "skipping $item $catch_msg"
                    continue
                }

                # Filter out routers.
                puts "item=$item host_type=$host_type"
                if {[lsearch -exact $::ap_type_list $host_type] >= 0} {
                    UTF::Message WARN $::localhost "Skipping host=$item, type=$host_type"
                    continue
                }

                # In the case of a STA, first get the host object. Always
                # get the name.
                set catch_resp [catch "set host_name \[$item cget -host\]" catch_msg]
                if {$catch_resp == 0} {
                    set host_object [$host_name cget -name]
                } else {
                    set host_object [$item cget -name]
                } 
   
                # Get host & ip addr info based on the object -lan_ip data.
                # If -lan_ip option is blank, use the object name.
                set lan_ip [$host_object cget -lan_ip]
                set lan_ip [string trim $lan_ip]
                if {$lan_ip == ""} {
                    set lan_ip [$host_object cget -name]
                    set lan_ip [string trim $lan_ip]
                }
                set lan_ip [string tolower $lan_ip]
                UTF::Message INFO $::localhost "item=$item host_object=$host_object lan_ip=$lan_ip"

                if {[regexp {^\d+\.\d+\.\d+\.\d+$} $lan_ip]} {
                    # lan_ip is a valid IP address
                    set host_ip $lan_ip
                    set host_name [UTF::get_host_name $lan_ip]
                } else {
                    # lan_ip is a host name string.
                    set host_ip [UTF::get_ip_addr $lan_ip]
                    set host_name $lan_ip
                }

                # Make sure both host_name & host_ip are not blank.
                # set host_name "" ;# test code
                # set host_ip "" ;# test code
                # puts "item=$item host_ip=$host_ip host_name=$host_name"
                if {$host_name == "" && $host_ip == ""} {
                    set msg "ERROR: item=$item has null host_name & host_ip!"
                    UTF::Message ERROR $::localhost "$msg"
                    lappend error_list "$msg"
                    continue
                }

                # Some users have multiple objects that point to the same
                # physical host name/IP address. We need to filter out these
                # duplicate objects. Otherwise, we will launch 2 parallel
                # processes to shutdown the same host, which would be messy.
                # set host_name "" ;# test code
                # set host_ip "" ;# test code
                if {($host_name != "" && [lsearch -exact $name_list $host_name] >= 0) ||\
                    ($host_ip   != "" && [lsearch -exact $ip_list $host_ip] >= 0)} {
                    UTF::Message WARN $::localhost "Skipping duplicate object $item\
                        host_name=$host_name host_ip=$host_ip\
                        name_list=$name_list ip_list=$ip_list"
                    continue
                }

                # Save the current name & IP.
                if {$host_name != ""} {
                    lappend name_list $host_name
                }
                if {$host_ip != ""} {
                    lappend ip_list $host_ip
                }

                # Some users may run this script on one of the testbed hosts
                # that needs to be rebooted. If this is done, we need to 
                # reboot everything else first, before we reboot the host
                # that this script is running on. So we look for the object
                # that represents the local host and put it on the defer_list.
                incr total_devices
                if {$local_ip == $host_ip || $::localhost == $host_name} {
                   lappend defer_list $host_object
                } else {
                   lappend primary_list $host_object
                }
            }

            # Set list of items to check for consoles & crashcheck
            set primary_list [string trim $primary_list]
            set defer_list [string trim $defer_list]
            set complete_list "$primary_list $defer_list"
            set complete_list [string trim $complete_list]
            UTF::Message INFO $::localhost "complete_list=$complete_list"

            # Log & return results
            set msg "total_devices=$total_devices primary_list=$primary_list\
                 defer_list=$defer_list"
            UTF::Message INFO $::localhost "$msg"
            set error_list [string trim $error_list]
            if {$error_list != ""} {
                error "$error_list $msg"
            } else {
                return "$msg"
            }
        }

        # The -noreboot option implies the -full option is set. This ensures
        # that all hosts will be powered off, regardless of their current state.
        if {$(noreboot) == 1} {
            set (full) 1
        }

        # For conditional reboot, the default, we check which devices are
        # currently responding. This step reduces the primary_list to only
        # the unresponsive hosts.
        if {$(full) == 1} {
            if {$(noreboot) == 1} {
               set msg "and left powered off"
            } else {
               set msg "and rebooted"
            }
            UTF::Try "All hosts will be shutdown $msg" {
                UTF::Message INFO $::localhost "full reboot option specified,\
                    full=$(full) noreboot=$(noreboot)"
            }

        } else {
            UTF::Try "Checking which hosts are unresponsive" {
                # Hosts have 1 chance to respond. Each host is polled
                # once, no matter how long it takes.
                set primary_list [check_responding_hosts $primary_list 1 1 0 0]
                set msg "unresponsive_hosts=$primary_list"
                UTF::Message INFO $::localhost "$msg"
                if {$primary_list == ""} {
                    return "$msg"
                } else {
                    # Unresponsive hosts are flagged as errors/FAIL, so 
                    # that they will stand out on the top level item of
                    # nested web summary reports.
                    error "$msg"
                }
            }
        }

        # If requested, check if there is any life left in the RTE console windows.
        # For those RTE console windows attached to dongles of any kind, it
        # is useful to know if the dongle itself is still responsive, even
        # if the host may have crashed or hung.
        if {!$(noconsole)} {
            UTF::Try "Checking which serial consoles are unresponsive" {
                set unresponsive_consoles ""
                foreach item $complete_list {
                    set console "" ;# Cygwin object dont have console
                    set catch_resp [catch "set console \[$item cget -console\]" catch_msg]
                    set console [string trim $console]
                    if {$console == "" || [string match -nocase "*var*log*" $console]} {
                        UTF::Message INFO $::localhost "$item does not have a serial\
                            console, console=$console"
                    } else {
                        # We are primarily interested in the status of RTE consoles.
                        # If the RTE device is still responding, we dont want this
                        # test to disturb the RTE device. So we use the benign "mu"
                        # command as a probe.
                        UTF::Message INFO $::localhost "Checking $item\
                            console=$console"
                        set console_output ""
                        set catch_resp [catch "set console_output \[$item rte mu\]" catch_msg]
                        if {$catch_resp == 0} {
                            UTF::Message LOG $item "console_output=$console_output"
                        } else {
                            UTF::Message WARN $item "item=$item\
                                console not responding, catch_msg=$catch_msg\
                                \nconsole_output=$console_output"
                            lappend unresponsive_consoles $item
                        }
                    }
                }

                # We dont generate a failure for any unresponsive consoles.
                # This is simply a statement of where the testbed is at, neither
                # good or bad. 
                set unresponsive_consoles [string trim $unresponsive_consoles]
                return "unresponsive_consoles=$unresponsive_consoles"
            }
        }

        # Main loop for rebooting hosts.
        if {$primary_list != ""} {

            # Check retry count is sane. 
            set temp $(retry)
            set temp [string trim $temp]
            if {$temp == "" || ![regexp {^\d+$} $temp] || $temp < 1} {
                set (retry) 3
            }

            # Find a directory containing UTF.tcl
            set file UTF.tcl
            set dir_list "$UTF::args(utfconf) [pwd] $::argv0"
            if {[info exists ::env(HOME)]} {
                set dir_list "$dir_list $::env(HOME)/tot/src/tools/unittest"
            }
            # puts "dir_list=$dir_list"
            set utf_dir ""
            foreach dir $dir_list {
                # puts "before dir=$dir"
                regsub -nocase {/unittest/.*} $dir "/unittest" dir
                # puts "after dir=$dir"
                if {[file exists "$dir/$file"]} {
                    set utf_dir $dir
                    UTF::Message INFO $::localhost "Found $file in\
                        utf_dir=$utf_dir"
                    break
                }
            }
            if {$utf_dir == ""} {
                UTF::Message ERROR $::localhost "Could not find directory\
                containing $file, looked in: $dir_list"
            }

            # Get name of config file in use, will be needed by the children
            # process that get launched in parallel.
            set config_file $UTF::args(utfconf)
            # puts "config_file=$config_file"

            # Set option to pass to shutdown_reboot
            set option ""
            if {$(noreboot) == 1} {
                set option "-noreboot"
            }

            # Customize the report message
            if {$(noreboot) == 1} {
               set msg ""
            } else {
               set msg "/ reboot"
            }

            # Each time thru this loop the primary_list should be reduced
            # as more hosts are rebooted and start responding again.
            for {set i 1} {$i <= $(retry)} {incr i} {
                UTF::Try "Try $i of $(retry): shutdown $msg hosts: $primary_list" {
                    # Launch each host reboot as a separate parallel process
                    foreach item $primary_list {

                        # Get a log file name for this specific reboot attempt
                        # for this specific host. The output of each parallel 
                        # process is saved in its own unique log file.
                        set log_file [pick_log_file $item]

                        # For full testbed reboot, we attempt a graceful
                        # software shutdown to start on the first try only.
                        # For conditional reboot or second and subsequent
                        # tries, we already know that theses hosts are 
                        # non-responsive, so we use the -force option to
                        # bypass the graceful software shutdown, which 
                        # saves some elapsed time.
                        if {$(full) == 1 && $i == 1} {
                              exec $utf_dir/UTF.tcl -nolock -utfconf $config_file\
                                  $item shutdown_reboot "" "" "" "" $option > $log_file &
                        } else {
                              exec $utf_dir/UTF.tcl -nolock -utfconf $config_file\
                                  $item shutdown_reboot "" "" "" "" $option -force\
                                  > $log_file &
                        }
                        UTF::Sleep 1
                    }

                    # Wait 120 seconds for software shutdown to occur and
                    # reboot to start
                    UTF::Sleep 120 $::localhost "Wait for software shutdown\
                        to occur and reboot to start"

                    # Check for unresponsive hosts. Allow multiple tries while
                    # the hosts are coming up, but have absolute time limits
                    # so we dont run unbounded.
                    set primary_list [check_responding_hosts $primary_list 6 20 600 900 $(noreboot)]

                    # Generate PASS/FAIL appropriately
                    set msg2 "unresponsive_hosts=$primary_list"
                    UTF::Message INFO $::localhost "$msg2"
                    if {$primary_list == ""} {
                        return "$msg2"
                    } else {
                        error "$msg2"
                    }
                }

                # Check if we are done yet.
                if {$primary_list == ""} {
                    break
                }
            }
        }

        # If there are unresponsive hosts remaining, any higher level 
        # scripts may wish to know about them and take other actions.
        set ::unresponsive_hosts $primary_list

        # For Cygwin, WinDHD, WinBT & MacOS hosts, run the crashcheck routine.
        # NB: crashcheck is getting too clever, so I use scandump, which will
        # scan the dump file regardless.
        set crash_list ""
        UTF::Try "For Cygwin/WinDHD/WinBT/MacOS hosts, running scandump" {
            set crash_list "" ;# hosts that have scandump
            foreach item $complete_list {

                # Skip hosts that dont have a scandump method.
                set type [$item info type]
                set type [lindex [split $type "::"] end]
                if {[lsearch -exact "Cygwin WinDHD WinBT MacOS" $type] < 0} {
                    UTF::Message INFO $item "host=$item type=$type\
                        does not have a crashcheck method"
                    continue
                }

                # Dont look for memory.dmp files on hosts that are known
                # to be unresponsive.
                if {[lsearch -exact $primary_list $item] >= 0} {
                    UTF::Message INFO $item "host=$item type=$type\
                        is not responding right now"
                    continue
                }

                # Check if there is a memory.dmp file
                UTF::Message INFO $item "host=$item type=$type\
                    checking for memory.dmp"
                set catch_msg ""
                set catch_resp [catch {$item stat /cygdrive/c/Windows/memory.dmp} catch_msg]
                # UTF::Message INFO $item "catch_resp=$catch_resp\
                    catch_msg=$catch_msg"
                if {$catch_resp == 0} {
                    # We found a memory.dmp file
                    UTF::Message INFO $item "==========================================================================================================="
                    append crash_list " $item crashed:"
                    set catch_msg ""
                    set catch_resp [catch "$item scandump" catch_msg]
                    append crash_list " $catch_msg<br>"
                    # UTF::Message INFO $::localhost "catch_resp=$catch_resp\
                         catch_msg=$catch_msg"
                    UTF::manage_dmp_files $item
                    UTF::Message INFO $item "==========================================================================================================="
                }
            }

            # If we found crash info, return list of crashed hosts as an error.
            regsub -all {\n} $crash_list " " crash_list
            set crash_list [string trim $crash_list]
            if {$crash_list != ""} {
                error "html: $crash_list"
            } else {
                return
            }
        }

        # Handle defer_list for -full option. For conditional reboots,
        # we can ignore the defer_list, because the defer_list is the
        # localhost, and the localhost is clearly responding because
        # this script is running on it.
        # set (full) 1 ;# test code
        # set defer_list Utf2Test4a2 ;# test code
        # set ::local_os fred ;# test code
        if {$(full) == 1 && $defer_list != ""} {
            UTF::Try "Rebooting defer_list=$defer_list" {

                # This is where things get a bit dicey. The defer_list is the
                # localhost that this script and others are running on. Even 
                # if the localhost does have remote power control, we dont 
                # use it. The Web Switches will get into trouble as the power 
                # cycle operation is 2 separate transactions. This will leave
                # the server in the off state. So we do a soft reboot and hope
                # for the best.
                # NB: defer_list is normally only one item, but we allow for
                # a list.
                foreach item $defer_list {

                    # Do a soft reboot and hope for the best.
                    # The soft reboot command depends on the local_os.
                    if {[string match -nocase "*linux*" $::local_os]} {
                        set cmd "reboot" ;# Linux
                    } else {
                        set cmd "shutdown -r 3" ;# Windows 
                    }
                    UTF::Message INFO $::localhost "doing soft reboot on\
                        host $item, cmd=$cmd"
                    UTF::Sleep 5
                    set catch_resp [catch {[$item rexec $cmd]} catch_msg]
                    if {$catch_resp != 0} {
                         UTF::Message WARN $item "cmd=$cmd catch_msg=$catch_msg"
                    }
                }

                # We really dont know if the defer_list host came back up.
                return "Please manually check if $defer_list came back up."
            }
        }

    # End code for WrapSummary
    }
}
