#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for testing performance between two 4321s
# $Id$
#
package require UTF
package provide UTF::Test::Perf-MIMO 2.0

namespace eval UTF::Test::Perf-MIMO {

    proc nicinfo {STA} {

	set type et
	set pci "0.0"
	catch {
	    set type [$STA chipname]
	    set pci [$STA pci]
	}
	return "$type\($pci\)"
    }


}

UTF::Test Perf-MIMO {In Out args} {

    UTF::Getopts {
	{title.arg "" "Test title"}
	{t.arg "6" "Time in seconds"}
	{i.arg "2" "Interval in seconds"}
	{window.arg "auto" "Tcp Window"}
	{note.arg "" "Notes"}
	{rate.arg "" "rates"}
	{ampdu_mpdu.arg "" "ampdu_mpdu"}
	{rxampdu_mpdu.arg "" "RX ampdu_mpdu"}
	{rxampdu_rts.arg "" "RX ampdu_rts"}
	{rxedcrs.arg "" "RX edcrs"}
	{b.arg "0" "UDP rate"}
	{u "UDP test (equiv -b 1m)"}
	{test.arg "iperf" "test"}
	{ack_ratio.arg "" "ack_ratio"}
	{ack_ratio_depth.arg "" "ack_ratio_depth"}
	{frameburst.arg "1" "Enable framebursting"}
	{amsdu_aggbytes.arg "" "amsdu_aggbytes" }
	{amsdu_aggsf.arg "" "amsdu_aggsf" }
	{amsdu_lowm.arg "" "amsdu_lowm (hiwm will be +2)"}
	{N.arg "0" "Disable TCP nodelay" }
	{l.arg "" "Buffer length"}
	{caldump "Caldump test" }
	{txpwrctrl.arg "" "nphy_txpwrctrl"}
	{txfifo_sz.arg "" "txfifo_sz"}
	{ampdu_dur.arg "" "ampdu_dur"}
	{txmaxpkts.arg "" "txmaxpkts"}
	{pwr_percent.arg "" "pwr_percent"}
	{ampdu_tx_lowat.arg "" "ampdu_tx_lowat"}
	{mw.arg "" "Memory Waste"}
	{sd_divisor.arg "" "sd_divisor"}
	{txpwr1.arg "" "txpwr1"}
	{bi "Use bidirectional test"}
	{ro.arg "" "Report-Only parameter list"}
	{dump_ampdu "Dump AMPDU stats"}
	{dump_amsdu "Dump AMSDU stats"}
	{mu "Dump MU stats (Dongle)"}
	{ampdu_tx_timeout.arg "" "ampdu_tx_timeout"}
	{txbound.arg "" "txbound"}
	{rxbound.arg "" "rxbound"}
	{attngrp.arg "" "Attenuator Group"}
	{attn.arg "" "Attenuation"}
	{queue.arg "BE" "Use different queues: BE BK VI VO"}
	{stf.arg "{}" "Specify stf mode"}
	{symmetric "Apply TX and RX parameters to both devices"}
	{temp "Record temperature"}
	{rssi "Record RSSI"}
	{counters "Record wl counters before and after"}
	{interrupts "Record /proc/interrupts before and after"}
	{ifconfig "Record ifconfig before and after"}
	{pretest "Run one short pretest at the start"}
	{slow_start.arg "0" "Discard initial samples"}
	{rpcdump "Dump RPC info"}
	{rcvlazy_p.arg "" "rcvlazy packets"}
	{rcvlazy_u.arg "" "rcvlazy usec"}
	{streams.arg "1" "Multiple iperf streams"}
	{P.arg "" "Parallel streams inside iperf"}
	{trim_ends.arg "0" "Discard first and last to WAR alignment issues"}
	{tlob.arg "" "tcp_limit_output_bytes"}
	{cpu.arg "" "Measure CPU on arg"}
	{pps "Report packets per sec"}
	{iperf.arg "" "Iperf command"}
	{txrate "Report UDP txrate"}
	{e "Report enhanced iperf stats"}
	{rxinterference_override.arg "" "Interference Override"}
    }

    if {($(rcvlazy_p) ne "") != ($(rcvlazy_u) ne "")} {
	error "Can't set rcvlazy_p without rcvlazy_u"
    }

    if {$UTF::Logfile eq ""} {
	UTF::Logfile "test.log"
    }

    # Mimic iperf args:
    # -b x enables UDP
    # -u is equivalent to -b 1m
    if {$(b) eq "0" && $(u)} {
	set $(b) "1m"
    }

    # Expand all variables.  This makes the cmdline interface
    # consistent, plus it ensures any variables not used are filled
    # with nulls so that UTF::forall doesn't abort early.

    set (rate) [UTF::Rateexp $(rate)]
    set (ampdu_mpdu) [UTF::Numexpand $(ampdu_mpdu)]
    set (rxampdu_mpdu) [UTF::Numexpand $(rxampdu_mpdu)]
    set (rxampdu_rts) [UTF::Numexpand $(rxampdu_rts)]
    set (rxedcrs) [UTF::Numexpand $(rxedcrs)]
    set (ack_ratio) [UTF::Numexpand $(ack_ratio)]
    set (ack_ratio_depth) [UTF::Numexpand $(ack_ratio_depth)]
    set (amsdu_aggbytes) [UTF::Numexpand $(amsdu_aggbytes)]
    set (amsdu_aggsf) [UTF::Numexpand $(amsdu_aggsf)]
    set (amsdu_lowm) [UTF::Numexpand $(amsdu_lowm)]
    set (ampdu_dur) [UTF::Numexpand $(ampdu_dur)]
    set (txmaxpkts) [UTF::Numexpand $(txmaxpkts)]
    set (pwr_percent) [UTF::Numexpand $(pwr_percent)]
    set (txpwr1) [UTF::Numexpand $(txpwr1)]
    set (ampdu_tx_lowat) [UTF::Numexpand $(ampdu_tx_lowat)]
    set (ampdu_tx_timeout) [UTF::Numexpand $(ampdu_tx_timeout)]
    set (txbound) [UTF::Numexpand $(txbound)]
    set (rxbound) [UTF::Numexpand $(rxbound)]
    set (mw) [UTF::Numexpand $(mw)]
    set (sd_divisor) [UTF::Numexpand $(sd_divisor)]
    set (attn) [UTF::Numexpand $(attn)]
    set (queue) [UTF::Numexpand $(queue)]
    set (window) [UTF::Numexpand $(window)]
    set (l) [UTF::Numexpand $(l)]
    set (rcvlazy_p) [UTF::Numexpand $(rcvlazy_p)]
    set (rcvlazy_u) [UTF::Numexpand $(rcvlazy_u)]
    set (b) [UTF::Numexpand $(b)]
    set (streams) [UTF::Numexpand $(streams)]
    set (P) [UTF::Numexpand $(P)]
    set (tlob) [UTF::Numexpand $(tlob)]
    set (rxinterference_override) [UTF::Numexpand $(rxinterference_override)]

    set parm(title) $(title)

    set parm(note) $(note)

    set parm(test) $(test)
    set parm(txfifo_sz) $(txfifo_sz)
    set parm(N) $(N)

    if {$(trim_ends) > 0} {
	# Expand range to compensate for trimming
	set (t) [expr {$(t) + 2 * $(i) * $(trim_ends)}]
    }

    # Include report-only parameters passed in on commandline
    foreach {k v} $(ro) {
	set parm($k) $v
    }

    if {[llength $In] > 1} {
	set SRC [lindex $In 0]
	set In [lindex $In 1]
    } else {
	set SRC $In
    }
    if {[llength $Out] > 1} {
	set SNK [lindex $Out 1]
	set Out [lindex $Out 0]
    } else {
	set SNK $Out
    }

    UTF::Message INFO $In "Using path $SRC -> $SNK"
    set parm(os) "[$SRC hostis]->[$SNK hostis]"

    set AP [$In cget -host]

    set SRCIP [$SRC ipaddr]
    set SNKIP [$SNK ipaddr]


    set SRCIF [$In cget -device]
    set SNKIF [$Out cget -device]

    set parm(in_if) $SRCIF
    set parm(out_if) $SNKIF

    set STAS {}
    foreach STA [list $SRC $In $Out $SNK] {
	if {[lsearch $STAS $STA] < 0} {
	    lappend path [nicinfo $STA]
	    if {![catch {$STA wl up}]} {
		lappend STAS $STA
		if {$(frameburst) ne ""} {
		    if {$(frameburst)} {
			$STA wl frameburst 1
		    } else {
			$STA wl -u frameburst 0
		    }
		}
		if {![catch {$STA wl mbss} ret] && $ret} {
		    set parm(mbss) 1
		}
	    }
	    if {![catch {$STA wl ver} ret]} {
		# Pass version list with timestamps so that plotter
		# can generate a realistic timeline.
		if {[regexp -line {:\s+?(.*?)\sversion\s(\S+)(?:\s|$)} \
			 $ret - date ret]} {
		    UTF::Message INFO $STA $date
		    set date [exec date -d $date +%s]
		    lappend parm(wlver) "$date:$ret"
		} else {
		    UTF::Message WARN $STA "Unexpected date format"
		}
	    }
	}
    }
    if {[llength $STAS] % 2} {
	UTF::Message WARN $STA \
	    "Odd number of wireless devices in data path: $STAS"
	UTF::Message WARN $STA "Discarding [lindex $STAS end]"
	set STAS [lreplace $STAS end end]
    }
    set parm(path) [join $path -]

    # For RvR is attngrp isn't set, see if any of the devices have
    # nominated an attenuator
    if {$(attngrp) eq "" && $(attn) ne {{}}} {
	foreach STA $STAS {
	    set (attngrp) [$STA cget -attngrp]
	    if {$(attngrp) ne ""} {
		break
	    }
	}
	if {$(attngrp) eq ""} {
	    error "-attn requires -attngrp"
	}
    }

    # Reset attenuator to initial value before attempting ping
    if {$(attn) ne {{}}} {
	$(attngrp) attn [lindex $(attn) 0]
    }

    # Override iperf command
    if {$(iperf) ne ""} {
	set parm(iperf) $(iperf)
	foreach STA $STAS {
	    $STA lan configure -iperf $(iperf)
	}
    }

    $SRC ping $SNKIP

    # Find largest window
    set bigwindow 0
    foreach STA $STAS {
	set window [$STA tcpautowindow]
	if {$window > $bigwindow} {
	    set bigwindow $window
	}
    }
    UTF::Message LOG $STA "Window: $bigwindow"


    # Query first STA, or the AP if there are no STAs
    set STA [lindex [concat $STAS $AP] 0]
    if {[catch {$STA wl chanspec} parm(chanspec)]} {
	regexp {target channel\s+(\d+)} [$STA wl channel] - parm(chanspec)
    } else {
	# Strip hex component, accept old and new formats
	regsub {\s+\(.*\)} $parm(chanspec) {} parm(chanspec)
	# Strip band indicator (no longer used)
	regsub {[ab]} $parm(chanspec) {} parm(chanspec)
    }
    if {[catch {$STA wl wsec} parm(wsec)]} {
	set parm(wsec) 0
    }
    if {![string map {"Infrastructure BSS" 1 IBSS 0} \
	      [$STA wl infra]]} {
	set parm(adhoc) 1
    }
    catch {
	if {[$STA wl ampdu]} {
	    set parm(ampdu) 1
	}
	if {[$STA wl amsdu]} {
	    set parm(amsdu) 1
	}
    }
    if {![catch {$STA wl frameburst} ret] && $ret eq 1} {
	set parm(fb) 1
    }

    # Find unique versions.  If none, try backup STA
    if {[info exists parm(wlver)]} {
	set parm(wlver) [lsort -unique $parm(wlver)]
    } elseif {![catch {$STA wl ver} ret]} {
	regexp -line {version (\S+)} $ret - parm(wlver)
    }

    set band [$STA band]

    if {$(attn) ne {{}}} {
	catch {
	    regexp {\((-\d+)\)} [$STA wl roam_trigger $band] - parm(roam_trigger)
	}
    }

    if {[$In hostis Router BSDAP]} {
	set parm(meminfo) [$In meminfo]
	set parm(clkfreq) [$In rexec nvram get clkfreq]
	set parm(parkid)  [$In rexec nvram get parkid]
    }
    UTF::Message WARN "STA list" $STAS
    if {[llength $STAS] == 0} {
	set TXS {}
	set RXS {}
    } elseif {$(symmetric) || $(bi)} {
	# All STAs do TX and RX
	set TXS $STAS
	set RXS $STAS
    } else {
	# STAs must come in tx/rx pairs
	foreach {TX RX} $STAS {
	    lappend TXS $TX
	    lappend RXS $RX
	}
    }

    # Set static direction-dependent options
    # STAs must come in tx/rx pairs
    foreach RX $RXS {
	$RX txrate $band auto
    }
    if {$(txpwrctrl) ne {}} {
	foreach TX $TXS {
	    # Make sure devices are really up before changing power
	    # settings, otherwise systems will crash
	    $TX wl -u nphy_txpwrctrl $(txpwrctrl)
	}
    }
    if {$(pretest)} {
	set pretest 1
    } else {
	set pretest 0
    }

    UTF::forall \
	parm(rxampdu_rts) $(rxampdu_rts) \
	parm(rxedcrs) $(rxedcrs) \
	parm(queue) $(queue) \
	parm(sd_divisor) $(sd_divisor) \
	parm(mw) $(mw) \
	parm(window) $(window) \
	parm(ampdu_tx_timeout) $(ampdu_tx_timeout) \
	parm(ampdu_tx_lowat) $(ampdu_tx_lowat) \
	parm(ack_ratio_depth) $(ack_ratio_depth) \
	parm(ack_ratio) $(ack_ratio) \
	parm(amsdu_aggbytes) $(amsdu_aggbytes) \
	parm(amsdu_aggsf) $(amsdu_aggsf) \
	parm(amsdu_lowm) $(amsdu_lowm) \
	parm(ampdu_dur) $(ampdu_dur) \
	parm(txmaxpkts) $(txmaxpkts) \
	parm(ampdu_mpdu) $(ampdu_mpdu) \
	parm(rxampdu_mpdu) $(rxampdu_mpdu) \
	parm(pwr_percent) $(pwr_percent) \
	parm(txpwr1) $(txpwr1) \
	parm(txbound) $(txbound) \
	parm(rxbound) $(rxbound) \
	parm(attn) $(attn) \
	parm(l) $(l) \
	parm(rate) $(rate) \
	parm(stf) $(stf) \
	parm(b) $(b) \
	parm(rcvlazy_p) $(rcvlazy_p) \
	parm(rcvlazy_u) $(rcvlazy_u) \
	parm(streams) $(streams) \
	parm(P) $(P) \
	parm(tlob) $(tlob) \
	parm(rxinterference_override) $(rxinterference_override) \
	{

	    set discard $(slow_start)

	    if {[catch {

		# TX options
		foreach TX $TXS {
		    foreach p {
			ampdu_mpdu ampdu_tx_lowat ampdu_tx_timeout
		    } {
			if {$parm($p) ne {}} {
			    $TX wl $p $parm($p)
			}
		    }

		    $TX txrate $band $parm(rate)
		    if {$parm(txpwr1) ne {}} {
			$TX wl txpwr1 -q -o $parm(txpwr1)
		    }
		    if {[$TX hostis DHD]} {
			if {$parm(txmaxpkts) ne {}} {
			    $TX wl txmaxpkts $parm(txmaxpkts)
			}
		    }
		    if {$parm(tlob) ne {}} {
			$TX -x sysctl -w \
			    net.ipv4.tcp_limit_output_bytes=[UTF::kexpand $parm(tlob)]
		    }
		    if {$parm(amsdu_lowm) ne {}} {
			$STA wl amsdu_lowm $parm(amsdu_lowm)
			$STA wl amsdu_hiwm [expr {$parm(amsdu_lowm) + 2}]
		    }
		}

		# RX only options
		# ...
		foreach RX $RXS {
		    foreach p {ampdu_mpdu ampdu_rts edcrs
			interference_override
		    } {
			if {$parm(rx$p) ne {}} {
			    $RX wl $p $parm(rx$p)
			}
		    }
		    if {$parm(rcvlazy_p) ne {} && $parm(rcvlazy_u)} {
			$RX wl rcvlazy \
			    [format "0x%08x" \
				 [expr {$parm(rcvlazy_p)<<24|$parm(rcvlazy_u)}]]
		    }
		}
		# Common options
		foreach STA $STAS {
		    foreach p {
			ack_ratio_depth ack_ratio amsdu_aggbytes amsdu_aggsf
			ampdu_dur pwr_percent
		    } {
			if {$parm($p) ne {}} {
			    $STA wl $p $parm($p)
			}
		    }
		    if {[$STA hostis DHD]} {
			foreach p {txbound rxbound sd_divisor} {
			    catch {$STA dhd -i [$STA cget -device] $p $parm($p)}
			}
			if {$parm(mw) ne {}} {
			    # report the memory waste actually achieved
			    if {[regexp {mw total (\d+)K} \
				     [$STA rte mw $parm(mw)] - val]} {
				set parm(mw) $val
			    }
			}
		    }
		    if {$parm(stf) eq "2"} {
			$STA wl stbc_tx 1
			$STA wl stbc_rx 1
		    } elseif {$parm(stf) ne ""} {
			# Unsupported is ok
			$STA wl -u stbc_tx 0
			$STA wl -u stbc_rx 0
		    }
		    if {$(dump_ampdu)} {
			$STA wl -u ampdu_clear_dump
		    }
		    if {$(dump_amsdu)} {
			$STA wl -u amsdu_clear_dump
		    }

		    if {$(counters)} {
			$STA wl -u counters
		    }
		    if {$(interrupts)} {
			catch {$STA cat /proc/interrupts}
		    }
		    if {$(ifconfig)} {
			catch {$STA ifconfig}
		    }
		}
		if {$parm(attn) ne {}} {
		    $(attngrp) attn $parm(attn)
		}

		switch $(test) {
		    iperf {
			if {$(bi)} {
			    set pair [list $SRC $SNK $SNK $SRC]
			} else {
			    set pair [list $SRC $SNK]
			}
			set pairs {}
			for {set s 0} {$s < $parm(streams)} {incr s} {
			    set pairs [concat $pairs $pair]
			}
			set cmd \
			    [list UTF::Multiperf $pairs -i $(i) -t $(t) \
				 -noping -e]
			if {$(N)} {
			    lappend cmd -N
			}
			if {$parm(P) ne ""} {
			    lappend cmd -P $parm(P)
			}
			if {$parm(l) ne ""} {
			    lappend cmd -l $parm(l)
			}
			if {$parm(window) eq "auto"} {
			    # Auto window
			    set r [lindex [$TX wl rate] 0]
			    if {$r < 100 || $bigwindow == 0} {
				set window 0
			    } elseif {$r < 400} {
				set window 512k
			    } else {
				set window $bigwindow
			    }
			    unset r
			    UTF::Message LOG $TX "Window: $window"
			} else {
			    set window $parm(window)
			}
			lappend cmd -w $window
			set txrate 0
			if {$parm(b) ne "0"} {
			    lappend cmd -b $parm(b)
			    if {$(txrate)} {
				lappend cmd -txrate txrate
			    }
			}
			switch $parm(queue) {
			    VO {
				lappend cmd -S 0xc0
			    }
			    VI {
				lappend cmd -S 0x80
			    }
			    BK {
				lappend cmd -S 0x20
			    }
			    BE {
			    }
			    default {
				error "Bad queue $parm(queue)"
			    }
			}
			if {$(e)} {
			    lappend cmd -e
			}
			if {$pretest} {
			    set pretest 0
			    {*}$cmd
			}
			if {$(cpu) ne ""} {
			    set mpc [expr {int(($(t)+0.0) / $(i))}]
			    set mp [$(cpu) rexec -async mpstat -P ALL $(i) $mpc]
			}
			set rets [{*}$cmd]
			if {$(cpu) ne ""} {
			    set mpstat [$mp close]
			    # remove average
			    regsub -line {^Average.*} $mpstat {} mpstat
			    foreach {idle} [regexp -inline -line -all {\d+\.\d\d$} $mpstat] {
				set cpu [expr {100 - $idle}]
				UTF::XPASS $AP $cpu \
				    [concat [UTF::ParmStrip parm] data cpu]
			    }
			}
			if {$txrate ne 0} {
			    # Report txrate as x-axis
			    # set parm(txrate) $txrate;unset parm(b)

			    # Report txrate as y-axis
			    UTF::XPASS $AP $txrate \
				[concat [UTF::ParmStrip parm] data txrate]
			}

			if {$(trim_ends) > 0} {
			    # Trim tail, which may be more than
			    # trim_ends since some threads may come in
			    # significantly later.
			    set e [expr {int(($(t)+0.0)/$(i)) - $(trim_ends)}]
			    if {$e <= [llength $rets]} {
				set rets [lreplace $rets $e end]
			    }
			    # Trim head
			    set rets [lreplace $rets -1 \
					  [expr {$(trim_ends) - 1}]]
			}
			foreach ret $rets {
			    if {[incr discard -1] < 0} {
				UTF::XPASS $AP $ret [UTF::ParmStrip parm]
				if {$(pps) && $parm(l) ne ""} {
				    set pps [expr {125.0 * $ret / $parm(l)}]
				    UTF::XPASS $AP $ret \
					[concat [UTF::ParmStrip parm] data kpps]
				}
			    }
			}
		    }
		    default {
			error "Unexpected -test: $(test)"
		    }
		}
		foreach STA $STAS {
		    if {$(interrupts)} {
			catch {$STA cat /proc/interrupts}
		    }
		    if {$(ifconfig)} {
			catch {$STA ifconfig}
		    }
		    if {$(counters)} {
			$STA wl -u counters
		    }
		    if {$(dump_ampdu)} {
			$STA wl -u dump ampdu
		    }
		    if {$(dump_amsdu)} {
			$STA wl -u dump amsdu
		    }
		    if {[$STA hostis DHD]} {
			if {$(mu)} {
			    $STA rte mu
			}
		    }
		    if {$(temp)} {
			if {[regexp {(\d+) } [$STA wl phy_tempsense] - temp]} {
			    UTF::XPASS $STA $temp \
				[concat [UTF::ParmStrip parm] data temp]
			}
		    }
		    if {$(rssi)} {
			if {[$STA wl ap] eq 0} {
			    UTF::XPASS $STA [$STA wl rssi] \
				[concat [UTF::ParmStrip parm] data rssi]
			}
		    }
		    if {$(rpcdump)} {
			catch {$STA rte rpcdump}
			$STA wl -u dump rpc
		    }
		}
	    } ret]} {
		# Allow user to specify invalid ranges.  This
		# makes it easer to set up symmetric tests between
		# devices with different capabilities.
		if {[regexp {Not In Range} $ret]} {
		    UTF::Message WARNING "" "Skipping test: $ret"
		    continue
		} else {
		    error "Perf-Mimo: $ret" $::errorInfo
		}
	    }
	}
}
