#!/bin/env utf

#
# Testrig authorization script 
#
# To get online help, type: Test/Authorize.test -help
#

# $Id: 468b60188d5bfcf6e7070a5994e18e9a4c2341a8 $
# $Copyright Broadcom Corporation$
#

# Load help package before any other UTF packages.
package require UTF::help

# Script help string
set auth_help "\n\nUsage: Test/Authorize.test -utfconf path -password password\
    \n\nThis script will authorize you to use the specified test rig.\
    \n\nGenerally you MUST specify the \"-utfconf path\" for the config file\
    \nof the testrig you want to authorize against. If you dont, your default\
    \n.utfconf.tcl file will be used, which is probably not helpful.\
    \n\nYou MUST specify \"-password password\". This is the password used\
    \nfor ssh to access all the devices in the testrig.\
    \n\nFor testrigs with public DNS names, you can run this script from any\
    \nhost. For testrigs with that are firewalled off from the corporate\
    \nnetwork, you need to run this script on the specific endpoint host\
    \nthat is providing access to the firewalled testrig. The easiest way\
    \nto do that is submit a batch job to SGE and it will figure out where\
    \nto run the script. Alternate, use the GUI at: http://sigbatch\
    \n\nValid options:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set auth_getopts {
    {email.arg ""    "Email address list, format: userid1 userid2 ... default is your userid"}
    {password.arg "hrun*10"    "Password for ssh access to the devices in the testrig"} 
}

# Setup online help info.
UTF::setup_help $auth_help $auth_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

# Load packages
package require UTF
package require UTF::utils

package provide UTF::Test::Authorize 2.0

#============== proc delete_file ====================================
# Deletes specified file, throw error on failure.
#====================================================================
proc delete_file {file} {

    # Delete the specified file.
    UTF::Message LOG $::localhost "delete_file $file"
    set catch_resp [catch "file delete \"$file\"" catch_msg]
    if {$catch_resp == 0} {
        # file delete rarely gives non-zero return code, so double-check.
        # exec touch $file ;# test code
        if {[file exists "$file"]} {
            error "delete_file $file still exists!"
        } else {
            return
        }
    } else {
        error "delete_file $file: $catch_msg"
    }
}

#============== Main test ===========================================
# Start of authorization routine.
UTF::Test Authorize {args} {
    UTF::Getopts "$::auth_getopts" "$::auth_help"

    # Get testbed info.
    set ::UTF::trailer_info [UTF::setup_testbed_info $(email) ""]

    # Start web summary page
    UTF::WrapSummary $UTF::SummaryDir "Authorize $::config_file" "" "$(email)" {

        # Ensure the required password is present.
        set password $(password)
        set password [string trim $password]
        if {$password == ""} {
            # Throwing error outside UTF::Try block ends the script.
            error "Missing required parameter: -password password"
        }

        # Check two helper scripts are present. 
        # NB: First helper calls the second helper.
        set utf_dir $UTF::unittest
        set helper1 "Test/Auth_Helper.exp"
        if {![file exists "$utf_dir/$helper1"]} {
            # Throwing error outside UTF::Try block ends the script.
            error "$utf_dir/$helper1 file not found!"
        }
        set helper2 "Test/Auth_Helper.test"
        if {![file exists "$utf_dir/$helper2"]} {
            # Throwing error outside UTF::Try block ends the script.
            error "$utf_dir/$helper2 file not found!"
        }

        # Log the testbed info.
        UTF::Message INFO "$::localhost" "$::UTF::trailer_info"

        # Fix users .ssh directory permissions. Authorize will fail without
        # execute permission in particular.
        set ssh_dir [file nativename ~/.ssh]
        UTF::Message INFO "$::localhost" "ssh_dir=$ssh_dir"
        set catch_resp [catch "exec chmod u+rwx $ssh_dir" catch_msg]
        if {$catch_resp != 0} {
            UTF::Message ERROR "$::localhost" "chmod catch_resp=$catch_resp catch_msg=$catch_msg"
        }

        # Need to get a lock so that no other instance of Authorize.test runs
        # while this instance is running. Otherwise we could have multiple instances
        # editing / updating the same file ==> disaster!
        # NB: Somebody using multiple tabs/windows on SigBatch could easily fire up
        # many Authorize jobs for many testrigs at the same time.
        set lock_fn "$ssh_dir/Auth.lock"
        set pid [pid]
        set start_sec [clock seconds]
        set timeout_sec 300
        # puts "lock_fn=$lock_fn pid=$pid"
        while { 1 } {

            # Check for timeout.
            set now_sec [clock seconds]
            set delta [expr $now_sec - $start_sec]
            if {$delta >= $timeout_sec} {
                error "timeout trying to get $lock_fn, delta=$delta sec."
            }

            # Wait for other host/pid lock_fn to go away.
            if {[file exists $lock_fn]} {
                UTF::Sleep 3 $::localhost "Wait for $lock_fn"
                continue
            }

            # Create our own lock, showing host & pid, which will be a unique pair.
            set catch_resp [catch "set out \[open \"$lock_fn\" w\]" catch_msg]
            if {$catch_resp != 0} {
                UTF::Sleep 3 $::localhost "Open $lock_fn Write failed: $catch_msg"
                continue
            }
            UTF::Message LOG $::localhost "Writing $lock_fn"
            catch "puts $out \"$::localhost $pid\""
            catch "close $out"
            catch "exec chmod a+r $lock_fn"

            # Did we really get the lock_fn to ourselves? 
            UTF::Sleep 3 $::localhost "Check $lock_fn"
            set catch_resp [catch "set in \[open \"$lock_fn\" r\]" catch_msg]
            if {$catch_resp != 0} {
                UTF::Sleep 3 $::localhost "Open $lock_fn Read failed: $catch_msg"
                continue
            }
            set catch_resp [catch "set line \[gets $in\]" catch_msg]
            # puts "gets catch_resp=$catch_resp catch_msg=$catch_msg"
            catch "close $in"
            if {$catch_resp != 0} {
                UTF::Sleep 3 $::localhost "Read $lock_fn Data failed: $catch_msg"
                continue
            }
            set t0 [lindex $line 0]
            set t1 [lindex $line 1]
            if {$t0 == $::localhost && $t1 == $pid} {
                # Host & pid in lock_fn match, we are good to go.
                UTF::Message LOG $::localhost "Got $lock_fn OK"
                break
            }

            # Another process got the lock_fn
            UTF::Sleep 3 $::localhost "Other host \($t0 $t1\) got $lock_fn instead of us \($::localhost $pid\)."
        }

        # Get unused name for backup of known_hosts file.
        set src "$ssh_dir/known_hosts"
        set dest ""
        for {set i 0} {$i <= 1000} {incr i} {
            set temp "${ssh_dir}/kh.${i}"
            if {![file exists "$temp"]} {
                # We can use this filename for backup
                set dest $temp
                break
            }
        }

        # Did we get a backup name to use?
        if {$dest == ""} {
            delete_file $lock_fn
            error "No suitable filename available to backup $src"
        }

        # Make backup file copy.
        UTF::Message LOG "$::localhost" "Backing up $src to $dest"
        set catch_resp [catch "file copy -force \"$src\" \"$dest\"" catch_msg]
        if {$catch_resp != 0} {
            delete_file $lock_fn
            error "Backup $src to $dest failed: $catch_msg"
        } 

        # Setup list of relevant hosts & ip addresses to be deleted from known_hosts.
        set host_list "$::lan_wan_device_list $::endpoint_device_list"
        set ip_list ""
        foreach host $host_list {
            set lan_ip [$host cget -lan_ip]
            if {$lan_ip != ""} {
                set host $lan_ip
            }
            set ip_addr [UTF::get_ip_addr $host]
            append ip_list " $ip_addr"
        }
        UTF::Message LOG $::localhost "host_list=$host_list"
        UTF::Message LOG $::localhost "ip_list=$ip_list"

        # Open in & out files
        set dest "$src.tmp"
        UTF::Message LOG $::localhost "Open $src, $dest"
        set catch_resp [catch "set in \[open \"$src\" r\]" catch_msg]
        if {$catch_resp != 0} {
            delete_file $lock_fn
            error "Open $src Read failed: $catch_msg"
        }
        set catch_resp [catch "set out \[open \"$dest\" w\]" catch_msg]
        if {$catch_resp != 0} {
            delete_file $lock_fn
            error "Open $dest Write failed: $catch_msg"
        }

        # Discard entries that match either hostname or ipaddr.
        set deleted 0
        set i 0
        while {![eof $in]} {

            # Get next line from input file.
            incr i
            set catch_resp [catch "set line \[gets $in\]" catch_msg]
            # puts "i=$i line: $line"
            if {$catch_resp != 0} {
                delete_file $lock_fn
                error "Read $src Data failed i=$i: $catch_msg"
            }

            # Filter blank lines.
            if {$line == ""} {
                continue
            }

            # Get hostname & IP address from start of line
            if {[regexp -nocase {(^.*)ssh-rsa} $line - str]} {
                # Filter lines that match either host_list or ip_list
                set str [string trim $str]
                set str [split $str ","]
                set host [lindex $str 0]
                set ip [lindex $str 1]
                # puts "host=$host ip=$ip"

                # First look for host in host_list
                set j [lsearch -exact $host_list $host]
                if {$host != "" && $j >= 0} {
                    UTF::Message LOG $::localhost "i=$i j=$j deleting entry for host: $host $ip"
                    incr deleted
                    continue
                }

                # Now look for ip in ip_list
                set j [lsearch -exact $ip_list $ip]
                if {$ip != "" && $j >= 0} {
                    UTF::Message LOG $::localhost "i=$i j=$j deleting entry for ip: $host $ip"
                    incr deleted
                    continue
                }

                # If hostname is missing, then variable host will have the IP.
                set j [lsearch -exact $ip_list $host]
                if {$host != "" && $j >= 0} {
                    UTF::Message LOG $::localhost "i=$i j=$j deleting entry for ip: $host $ip"
                    incr deleted
                    continue
                }

            } else {
                # hostname & IP not found ==> WARN
                # BUT save this line!
                UTF::Message WARN $::localhost "i=$i hostname/IP not found: $line"
            }
            
            # Save this line.
            set catch_resp [catch "puts $out \"$line\"" catch_msg]
            if {$catch_resp != 0} {
                delete_file $lock_fn
                error "Write $dest Data failed i=$i: $catch_msg"
            }
        }
        UTF::Message LOG $::localhost "Deleted $deleted lines"

        # Move edited file into production
        UTF::Message LOG $::localhost "Rename $dest to $src"
        catch "close $in"
        catch "close $out"
        set catch_resp [catch "file rename -force \"$dest\" \"$src\"" catch_msg]
        if {$catch_resp != 0} {
            delete_file $lock_fn
            error "Rename $dest to $src failed: $catch_msg"
        }

        # Fix permissions on new known hosts
        set catch_resp [catch "exec chmod u+rwx $src" catch_msg]
        if {$catch_resp != 0} {
            delete_file $lock_fn
            error "chmod catch_resp=$catch_resp catch_msg=$catch_msg"
        }

        # Authorize for all ssh capable devices
        UTF::Try "Authorize $::config_file" {


            # Run helper1 and catch output. Helper 1 calls to helper2.
            set catch_resp [catch "exec $utf_dir/$helper1 $::config_file $(password) $utf_dir" catch_msg]

            # Parse the helper1 output looking for fail=n and success=m messages
            set fail ""
            set fail_list ""
            set lines [split $catch_msg "\n"]
            set success ""
            set success_list ""
            foreach line $lines {
                UTF::Message LOG "$::localhost" "$line"
                if {[regexp {\s+fail=(\d+)} $line - fail]} {
                    if {[regexp {\s+fail=\d+\s+(.*)} $line - fail_list]} {
                    }
                }
                if {[regexp {\s+success=(\d+)} $line - success]} {
                    if {[regexp {\s+success=\d+\s+(.*)} $line - success_list]} {
                    }
                }
            }

            # Decide what result to push up to the main web summary page.
            UTF::Message LOG "$::localhost" "extracted: fail=$fail fail_list=$fail_list"
            UTF::Message LOG "$::localhost" "extracted: success=$success success_list=$success_list"
            if {$fail == "0" && $success != "" && $success > 0} {
                # Update the tracking cookie file for testrigs that the user 
                # has successfully authorized for usage. The primary consumer
                # of this data is SigBatch.
                set cookie "~/.utf_authorized_testrigs.txt"
                set cookie [file nativename $cookie]
                set rig [file rootname [file tail $::config_file]]
                set out [open "$cookie" a]
                puts $out "$rig"
                close $out
                exec chmod a+r $cookie
                UTF::Message LOG "$::localhost" "Updated cookie=$cookie rig=$rig"
                return "success=$success $success_list"

            } else {
                error "fail=$fail $fail_list success=$success $success_list"
            }
        }

        # Cleanup
        delete_file $lock_fn
    }
}

