#!/usr/bin/env python2.7
"""
Figure out which svn commit broke a precommit target.

This will run drill to figure out which commit broke a build or a
test. Start and end values may be numeric revisions in the wlansvn svn
repository or timestamps.  If the end date is omitted it defaults to
invocation time.

EXAMPLES:

Search between two timestamps:

    %(prog)s -s {2015-11-10} -e {2015-11-11} TRUNK_DHD_Various_FC19x32

Search from a given timestamp to the current time:

    %(prog)s -s {2015-11-11T13:37:00-0800} TRUNK_DHD_Various_FC19x32

Search using revisions (deprecated):

    %(prog)s -s 599000 -e 600000 TRUNK_DHD_Various_FC19x32
"""

# $Copyright Broadcom Corporation$
#
# <<Broadcom-WL-IPTag/Proprietary:>>

from __future__ import unicode_literals

# Imported first to fix up sys.path etc.
import preface  # pylint: disable=relative-import,unused-import

import argparse
import sys
import time

import lib.opts
import lib.scm
import lib.times
import lib.util

DRILL = 'drill'
DBGDRILL = '/home/hwndebug/software/inf-stage/precommit/client/drill.py'
DBGSERVER = 'wlan-sj1-02:8110'

DRILL_PASS = 0    # Drill ran and compiled successfully
DRILL_CFAIL = 1   # Drill ran successfully but compile failed
DRILL_TFAIL = 2   # Drill and compile worked but smoketest failed
DRILL_ERR = 3     # Drill itself failed

# Convert the status codes to string for a diagnostic
DRILL_STATUS_STRING = ['PASS', 'FAIL', 'TEST FAIL', 'ERROR']

SEARCH_FOUND = 0     # Found the commit which broke the build
SEARCH_NOTFOUND = 1  # Could not find the commit which broke the build

# Search for these strings in the drill output to decide whether
# the drill command compile-passed or compile-failed,
# and test passed or failed.
DRILL_BLD_FAIL_STR = 'C  1 of   1   0   1'
DRILL_TST_FAIL_STR = 'T  1 of   1   0   1'

# Global variable for statistics
#    1. Total number of targets we compile
#    2. Start time
#    3. End time
#    4. Build results for each revision
RESULTS = {}


def elapsed_time(start, end):
    """Calculate elapsed time and return it in a printable string."""
    elapsed = end - start
    hours = elapsed / 3600
    minutes = (elapsed % 3600) / 60
    seconds = elapsed % 60
    return '%02d:%02d:%02d' % (hours, minutes, seconds)


# Return pass, fail or error.
def try_build(build, state, opts):
    """Try running drill on a preco target at a specific version."""
    statekey = state.posixtime
    if statekey in RESULTS:
        # This version has already been built; return the stored result.
        result = RESULTS[statekey]
        if not opts.quiet:
            sys.stdout.write('Build %s has already been tested: %s\n' %
                             (state, DRILL_STATUS_STRING[result]))
    else:
        iteration = len(RESULTS) + 1

        # Hack for use in debugging.
        if iteration == opts.iteration_fail:
            sys.stdout.write('SIMULATED FAIL at %s in iteration (%d).\n' %
                             (state.wlansvn(), iteration))
            RESULTS[statekey] = DRILL_CFAIL
            return DRILL_CFAIL

        # Timestamp current time for reporting time of this build.
        curr_start = time.time()

        if opts.dbgserver:
            cmd = [DBGDRILL, '-s', DBGSERVER]
        else:
            cmd = [DRILL]

        if opts.dry_run:
            cmd.append('-n')

        cmd.append('-r{%s}' % state.iso8601())

        if opts.test:
            cmd.append(','.join([build, opts.test]))
        else:
            cmd.append(build)

        # Fork the drill command
        proc = lib.util.execute(cmd, stdout=lib.util.PIPE)

        # The use of "while True" and readline is a trick to defeat buffering
        # so we can grab drill output in real time and show the job id.
        result = DRILL_PASS
        while True:
            line = proc.stdout.readline()
            if not line:
                break

            # Report the job id in case it hangs or otherwise needs checking.
            if 'Jobid:' in line and not opts.quiet:
                jobid = line.split('Jobid:')[-1].rstrip().rstrip('.')
                sys.stdout.write('Trying %s with drill id %s (%d) ... ' %
                                 (state.wlansvn(), jobid, iteration))
                sys.stdout.flush()

            # We must parse drill output (boo!) to determine failure type.
            if result == DRILL_PASS:
                if DRILL_TST_FAIL_STR in line:
                    result = DRILL_TFAIL
                elif DRILL_BLD_FAIL_STR in line:
                    result = DRILL_CFAIL

            if lib.util.verbose_enough(3):
                sys.stdout.write(line)

        if proc.wait() == 0:
            assert result == DRILL_PASS
        elif proc.returncode == 1:
            # Drill command succeeded with Fail result.
            # Failure type _should_ have been determined above.
            if result == DRILL_PASS:
                result = DRILL_ERR
        else:
            # Drill command itself failed with error.
            result = DRILL_ERR

        # Timestamp current time for reporting time of this build
        curr_end = time.time()

        if not opts.quiet:
            tm = time.localtime()
            sys.stdout.write('compile%s %s in %s at %s\n' % (
                '/test' if opts.test else '',
                DRILL_STATUS_STRING[result],
                elapsed_time(curr_start, curr_end),
                '%d:%02d' % (tm.tm_hour, tm.tm_min)))

        RESULTS[statekey] = result

    return result


def binary_search(build, start, end, opts):
    """Binary search to see where in the range the target broke."""
    blame = start.bisect(end)
    if blame is None:
        if RESULTS.get(start.posixtime, DRILL_PASS) != DRILL_PASS:
            return SEARCH_FOUND, start
        elif RESULTS.get(end.posixtime, DRILL_PASS) != DRILL_PASS:
            return SEARCH_FOUND, end
        else:
            return SEARCH_NOTFOUND, start

    # For the binary search, test the middle state.
    # If it passes, the blame is in the top half. Otherwise the
    # blame is in the bottom half. We'll recurse on the broken half.
    compile_status = try_build(build, blame, opts)
    if compile_status in (DRILL_CFAIL, DRILL_TFAIL):
        result, blame = binary_search(build, start, blame, opts)
    elif compile_status == DRILL_PASS:
        result, blame = binary_search(build, blame, end, opts)
    else:
        sys.stdout.write('Error running drill on commit %s\n' % blame)
        result = SEARCH_NOTFOUND

    return result, blame


def main():
    """Main routine for finding a precommit breaker."""
    rc = 1
    time_start = time.time()

    # Parse command line arguments
    parser = argparse.ArgumentParser(
        epilog=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser_tgt = parser.add_mutually_exclusive_group()
    parser_tgt.add_argument(
        '-b', '--build',
        help='the precommit target to build')
    parser.add_argument(
        '--dbgserver', action='store_true',
        help='Execute this script using debug server; only invoke ' +
        'this option after disabling the failing production ' +
        'smoketest and setting up equivalent configs in staging.')
    parser.add_argument(
        '-e', '--end',
        help='ending {date} or svn rev, defaults to "now"')
    parser.add_argument(
        '-f', '--force', action='store_true',
        help="force binary search without trying start and end first")
    parser.add_argument(
        '-i', '--iteration-fail', type=int, default=0, metavar='N',
        help="fail at iteration N, for debugging this script")
    parser.add_argument(
        '-n', '--dry-run', action='count',
        help="use drill -n to exercise the bisecting logic")
    parser.add_argument(
        '-q', '--quiet', action='store_true',
        help="suppress verbosity")
    parser.add_argument(
        '-s', '--start',
        help='starting {date} or svn rev')
    parser.add_argument(
        '-t', '--test',
        help='which smoketest case to test')
    parser.add_argument(
        '-V', '--verbose', action='count', default=0,
        help="increment verbosity level")
    parser_tgt.add_argument('target', nargs='?')
    opts = parser.parse_args()

    opts.target = opts.target if opts.target else opts.build
    if not (opts.target and opts.start):
        sys.argv = [sys.argv[0], '-h']
        sys.exit(main())
    if opts.verbose:
        lib.opts.VERBOSITY = opts.verbose
    tststr = ', test ' + opts.test if opts.test else ''
    start = lib.scm.RepoState(opts.start)
    end = lib.scm.RepoState(opts.end)

    if end <= start:
        lib.util.die('start (%s) must predate end (%s)' %
                     (start, end), exc=False)

    if not opts.quiet:
        sys.stdout.write(
            'Bisecting drill between r%s and r%s on target %s%s at %s\n' % (
                start.key(), end.key(), opts.target, tststr, time.ctime()))

    if not opts.force:
        # Confirm that the start version is indeed compiling correctly.
        if not opts.quiet:
            sys.stdout.write(
                'Launching job to confirm that start state %s is ok\n' %
                start.wlansvn())
        blame = start
        result = try_build(opts.target, blame, opts)
        if result == DRILL_ERR:
            sys.stdout.write('Error running drill on target %s%s.\n' %
                             (opts.target, tststr))
            return rc
        elif result in (DRILL_CFAIL, DRILL_TFAIL):
            fail = 'compile' if result == DRILL_CFAIL else 'smoketest'
            sys.stdout.write('Drill failed %s at start state %s\n' %
                             (fail, blame.wlansvn()))
            sys.stdout.write('Try starting from an earlier state, ' +
                             'or maybe it was an infrastructure problem.\n')
            return rc

        # Confirm that the END state fails to compile.
        blame = end
        if not opts.quiet:
            sys.stdout.write(
                'Launching job to confirm that final state %s is bad\n' %
                end.wlansvn())
        result = try_build(opts.target, blame, opts)
        if result == DRILL_ERR:
            sys.stdout.write('Error running drill on target %s%s.\n' %
                             (opts.target, tststr))
            return rc
        elif result == DRILL_PASS:
            sys.stdout.write('Drill passed at end version %s\n' %
                             blame.wlansvn())
            sys.stdout.write('Try expanding the version boundaries, ' +
                             'or maybe the target is fine.\n')
            return rc

    # Binary search for where in the range a build or test broke.
    result, blame = binary_search(opts.target, start, end, opts)
    if result == SEARCH_FOUND:
        rc = 0
    else:
        sys.stdout.write('Cannot figure out which commit broke precommit.\n')

    time_end = time.time()
    if not opts.quiet:
        if rc == 0:
            last = blame.latest_repo()
            rev = blame.key(repo=last)
            sys.stdout.write('Precommit broken by r%s in %s:\n' % (rev, last))
            sys.stdout.flush()
            cmd = lib.scm.svncmd('log', '-v', '-r%s' % rev, last)
            lib.util.execute(cmd, check=True)
        sys.stdout.write('Use "drilog -j <id>" to find drill logfiles.\n')
        sys.stdout.write('Executed %d compiles%s in elapsed time %s.\n' % (
            len(RESULTS), ' and tests' if opts.test else '',
            elapsed_time(time_start, time_end)))

    return rc

sys.exit(main())

# vim: ts=4:sw=4:tw=80:et:
