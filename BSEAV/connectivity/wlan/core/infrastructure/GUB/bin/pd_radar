#!/usr/bin/env python2.7
"""
Summarizes the issues fixed between two svn revisions or tags. If
only one tag is given, then summarizes all issues before that tag.
Attempts to group changes by Jira issue, Gnats PR, or Reviewboard
review - and provide links to those intranet pages. Also highlights
any changes made to a tag.

EXAMPLES:

    %(prog)s --relnote DIN2930R18_REL_9_44_55 DIN2930R18_REL_9_44_60

    %(prog)s --relnote-ext DIN2930R18_REL_9_44_56 DIN2930R18_REL_9_44_62 \
--milestone="Daytona 6/22"

"""

# History:
#  Original 'prdiff' in perl written by csm
#  'pr-diff' revised for pr-twikilog by gcox
#  Rewritten in python for the migration to Jira by gcox

from __future__ import print_function
# Not sure unicode literals are trusted yet for this old code.
# from __future__ import unicode_literals

# Imported first to fix up sys.path etc.
import preface  # pylint: disable=relative-import,unused-import

OPTS = None

# For Jira access
import base64
import httplib
import json

# For svn history
import xml.sax

# Other dependencies
import argparse
import cgi
import os
import re
import subprocess
import sys
from datetime import datetime, date

# Fast radar field access (cached)
import hnd.oly.rallow

# Constants
WLREPO = 'http://svn.sj.broadcom.com/svn/wlansvn'
JIRA_HOST = 'jira.broadcom.com'
JIRA_URL_FMT = '/rest/api/latest/issue/{0}.json'
JIRA_LEGACY_FMT = '/rest/api/2/search?jql="Legacy+Issue+%23"~{0}'
JIRA_FIRST_LEGACY_IMPORT = 68815
USERNAME = 'hwnsjira'
PASSWORD = 'hrun-10Jirahrun-10Jira'
JIRA_RE = re.compile(r'\bJIRA[-#:\s]*([A-Z][A-Z0-9]+-[0-9]+)',
                     flags=re.IGNORECASE)
SWWLAN_RE = re.compile(r'\bJIRA[-#:\s]*([0-9]{5,6})', flags=re.IGNORECASE)
RB_RE = re.compile(r'\bRB[-#:\s]*([0-9]+)[-:;., ]*', flags=re.IGNORECASE)
PR_RE = re.compile(r'\bPR[-#:\s]*([0-9]+)', flags=re.IGNORECASE)
RADAR_RE = re.compile(r'\bRADAR[-#:\s]*([0-9]+)[-:;., ]*', flags=re.IGNORECASE)
SUPERSCRIPT1 = '&#185;'
RELNOTE_EXT_WIDTH_DUE = 24
RELNOTE_EXT_WIDTH_JIRARB = 28
RADAR_INFRA = 'rdar://problem/99999999'
SEP = ''
UCODE_RELEASE = 'http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/UcodeRelease'


class FatalError(Exception):
    """Abort the script"""
    pass


def log(message):
    """TBD."""
    if OPTS.debug:
        sys.stderr.write(message + '\n')


def writeln(message=''):
    """TBD."""
    if OPTS.twiki:
        global SEP  # pylint: disable=global-statement
        sys.stdout.write(SEP + message)  # Twiki format
        SEP = ' %BR%\\\n'
    else:
        print(message)


def writeln_warn(message):
    """TBD."""
    if OPTS.twiki:
        writeln('%X% ' + message)
    else:
        sys.stderr.write(message + '\n')


def writeln_error(message):
    """TBD."""
    if OPTS.twiki:
        writeln('%X% ' + message)
    else:
        sys.stderr.write(message + '\n')


def date2long(s):
    """Convert 12/31 to date"""
    y = date.today().year
    d = datetime.strptime(s, '%m/%d').replace(year=y)
    return d


def date2short(d):
    """Convert date to short form like 12/31 or 1/2"""
    s = None
    if d:
        s = d.strftime('%m/%d')
        s = re.sub(r'(^|/)0', r'\1', s)
    return s


class Due(object):
    """
    A representation of a milestone name and a delivery date.

    This is really just a fancy tuple.
    """
    ITOOLS = ' - Internal Tools - '

    def __init__(self, milestone=None, when=None):
        # Flip around 'Internal Tools - *' for easier sorting.
        if milestone and self.ITOOLS[3:] in milestone:
            milestone = milestone.replace(self.ITOOLS[3:], '') + \
                self.ITOOLS[:-3]
        self.milestone = milestone
        # Replace None with a huge date to make missing TCD sort last.
        if not when:
            self.when = date.max
        elif type(when) is datetime:
            # We prefer a date not a datetime.
            self.when = when.date()
        else:
            self.when = when

    def add_itools_suffix(self):
        """TBD."""
        return Due(self.milestone + self.ITOOLS[:-3], self.when)

    def __cmp__(self, other):
        return cmp((self.milestone or 'ZZ', self.when),
                   (other.milestone or 'ZZ', other.when))

    def __str__(self):
        return '{0} {1}'.format(self.milestone, self.when)

    def __hash__(self):
        return hash(str(self))

    def short(self):
        """Format the milestone name and date in a short way (no year)."""
        w = ' None' if self.when == date.max else ' ' + date2short(self.when)
        m = self.milestone
        if not m:
            m = 'No milestone'
            w = ''
        return '{0}{1}'.format(m, w)


# Remove any RB:nnn and then return the first non-blank line.
def extract_line(regex, lines, index):
    """TBD."""
    line = ''
    for line in lines[index:]:
        line = re.sub(regex, '', line)
        if not re.match(r'^[-*\s]*$', line):
            break
    return line


# Break comment string at a word boundary.
def smart_truncate(msg, length=60, suffix='...'):
    """TBD."""
    if len(msg) > length:
        msg = msg[:length].rsplit(' ', 1)[0] + suffix
    return msg


# Append to (or create as needed) a list that is a member of a map.
def add_to_list(l, key, v):
    """TBD."""
    if key in l:
        l[key].append(v)
    else:
        l[key] = [v]


def escape(text):
    """Strip out any non-ascii characters. This is commonly special quote
    marks in radar and jira titles. Or if output is markup then instead escape
    those characters and also escape >, <, & as they look like html."""
    if not OPTS.twiki:
        ascii = text.encode('ascii', 'ignore')
    else:
        # Must escape & first, as xmlcharref adds & that we want.
        ascii = cgi.escape(text).encode('ascii', 'xmlcharrefreplace')
    return ascii


# Read an issue description from the Jira database.
# (Typically these are more readable than the check-in comments. Also there can
# be multiple check-ins for the same issue.)
def read_jira(jid, url_fmt):
    """TBD."""
    url = url_fmt.format(jid)
    message = ''

    # base64 encode the username and password
    auth = base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')

    webservice = httplib.HTTP(JIRA_HOST)
    if OPTS.debug_jira:
        webservice.set_debuglevel(1)
    # write your headers
    webservice.putrequest('GET', url)
    webservice.putheader('Host', JIRA_HOST)
    webservice.putheader('User-Agent', 'Python http auth')
    webservice.putheader('Content-type', 'application/json; charset="UTF-8"')
    webservice.putheader('Content-length', '%d' % len(message))
    # Write the Authorization header like:
    # 'Basic base64encode(USERNAME + ':' + PASSWORD)
    webservice.putheader('Authorization', 'Basic %s' % auth)
    webservice.endheaders()
    webservice.send(message)

    # get the response
    statuscode, statusmessage, headers = webservice.getreply()
    if OPTS.debug_jira:
        print('Response: ', statuscode, statusmessage)
        print('Headers: ', headers)

    # Most successful responses have an HTTP 200 status
    if statuscode != 200:
        if statuscode == 403:
            writeln_error('Failed to access JIRA:{0} - {1} {2}'.format(
                jid, statuscode, statusmessage))
            # This may print
            # 'CAPTCHA_CHALLENGE; login-url=http://jira.broadcom.com/login.jsp'
            writeln_error(headers.get(
                'X-Authentication-Denied-Reason', 'No reason given'))
            raise FatalError
        elif statuscode == 404:
            # Not found - up to caller whether to show a message or not.
            log('JIRA:{0} not found - {1} {2}'.format(
                jid, statuscode, statusmessage))
        else:
            writeln_error('Failed to access JIRA:{0} - {1} {2}'.format(
                jid, statuscode, statusmessage))
            raise FatalError
        return (None, None, None, None)

    # Convert the text in the reply into a Python dictionary
    result = json.loads(webservice.getfile().read())

    # Pretty-print the JSON if debugging
    if OPTS.debug_jira:
        print(json.dumps(result, sort_keys=True, indent=4))

    if 'fields' in result:
        # Normal Jira lookup case - single issue returned.
        issue = result
    elif 'issues' in result and len(result['issues']) > 0:
        # Retrieving a legacy issue should return a list of one Jira issue.
        # If more than one, use the oldest. Perhaps somebody cloned the
        # Jira issue to create a subtask (as in PR:108271).
        when = datetime.now()
        for i in result['issues']:
            created = datetime.strptime(i['fields']['created'][0:10].encode(
                'ascii'), '%Y-%m-%d')
            if created < when:
                issue = i
                when = created
        if len(result['issues']) > 1:
            log('Multiple matches: For PR:{0}, JIRA:{1}'
                ' is oldest of {2} matches.'.format(
                    issue['fields']['customfield_10050'],
                    issue['key'],
                    len(result['issues'])))
    else:
        return (None, None, None, None)

    # The properties of the issue include:
    # self, html, key, transitions, expand, fields
    fields = issue['fields']
    if OPTS.debug_jira:
        print('JIRA:{0} (PR:{1}) {2}'.format(
            issue['key'],
            fields['customfield_10050'],
            fields['summary']
        ))
    return (escape(fields['summary']),
            issue['key'].encode('ascii'),
            fields['customfield_10050'],  # GNATS PR
            fields['customfield_10084'])  # external issue id - used for radar


def pr2jira(pr):
    """Find a Jira issue, given a legacy gnats PR number."""
    return read_jira(pr, JIRA_LEGACY_FMT)


def gnats_login():
    """Ensure access is available to the gnats database."""
    success = False
    # The user may not have GNATSDB set.
    if not os.getenv('GNATSDB'):
        # Most users have the same password.
        # Same as --host='gnats-irva-3.broadcom.com' --port='1530'
        # --user=$USER --passwd='hndwlan' --database=HND_WLAN
        os.environ['GNATSDB'] = (
            'gnats-irva-3.broadcom.com:1530:HND_WLAN:{0}:{1}'
            .format(os.environ['USER'], 'hndwlan'))
    try:
        # This should succeed if credentials are correct.
        p = subprocess.Popen(['query-pr', '--list-categories'],
                             stdout=subprocess.PIPE)
        p.communicate()
        if p.returncode == 0:
            success = True
    except OSError, e:
        sys.stderr.write(e + '\n')

    if not success:
        writeln_error(
            'Gnats access failed. Remove the --gnats option to avoid '
            'accessing gnats. Or if you need to show legacy gnats issues, '
            'check your path and consider setting the GNATSDB environment '
            'variable, or contact help or '
            'hnd-software-scm-list@broadcom.com.')
    return success


def read_gnats(pr):
    """Read an issue description from the old gnats database."""
    msg = ''
    if not OPTS.no_jira:
        # These will be categories that were not migrated to Jira yet.
        fmt = '"(%s) %s" Category Synopsis'
    else:
        # Old style
        fmt = '"%s" Synopsis'

    try:
        # python2.6 lacks check_output
        p = subprocess.Popen([
            'query-pr', '--format', fmt, str(pr)
        ], stdout=subprocess.PIPE)
        msg = p.communicate()[0]
        if p.returncode != 0:
            # Could be either invalid pr number, or wrong password etc.
            pass
    except OSError, e:
        sys.stderr.write(e + '\n')
    return msg.strip()


class LogHandler(xml.sax.ContentHandler):

    """Used for parsing SVN log (xml)."""

    def __init__(self, path):
        xml.sax.ContentHandler.__init__(self)
        self.path = path
        # State to return
        self.copyfrom_path = None
        self.copyfrom_rev = -1
        self.copyfrom_msg = ''
        self.oldest = 0
        self.changes = 0
        self.comments_by_rev = {}
        # Internal state
        self.chars = ''
        self.field = None
        self.rev = -1
        self.msg = ''
        self.is_copyfrom = False
        self.skip = False
        self.file_action = None
        self.author = None

    def get_revs(self):
        """TBD."""
        return self.comments_by_rev

    def startElement(self, name, attrs):
        """TBD."""
        if name == 'logentry' and 'revision' in attrs:
            self.rev = int(attrs.getValue('revision'))
        elif name == 'author' or name == 'msg':
            self.field = name
        elif name == 'path':
            if attrs.getValue('kind') == 'dir':
                if 'copyfrom-rev' in attrs and self.copyfrom_rev == -1:
                    self.field = name
                    # In 'svn log 1:HEAD' for a tag, the first copy
                    # we see is the tag creation.
                    # In 'svn log 1:HEAD' for a twig, the first copy
                    # we see is the twig creation.
                    self.is_copyfrom = True
                    self.copyfrom_path = attrs.getValue('copyfrom-path')
                    self.copyfrom_rev = attrs.getValue('copyfrom-rev')
            else:
                self.field = name
                self.file_action = attrs.getValue('action')

    def endElement(self, name):
        """TBD."""
        if name == self.field:
            if name == 'author':
                self.author = self.chars
            elif name == 'msg':
                self.msg = self.chars
            elif name == 'path':
                if self.is_copyfrom:
                    log('path="{0}, self.path="{1}"'.format(self.chars,
                                                            self.path))
                    if self.chars != self.path:
                        self.is_copyfrom = False
                        log('Treating copy as a typical rev'
                            ' since it is not tag/twig creation.')
                    else:
                        log('Nothing to print for the copy'
                            ' that is the tag/twig creation.')
                elif self.file_action:
                    self.skip = self.on_file(self.rev,
                                             self.file_action, self.chars)
                    self.file_action = None
            self.chars = ''
            self.field = None
        elif name == 'logentry':
            if self.skip:
                self.skip = False
            else:
                if self.is_copyfrom:
                    self.on_tag(self.rev, self.msg)
                    self.is_copyfrom = False
                    self.oldest = self.rev
                else:
                    self.on_rev(self.rev, self.msg, self.author)
                    self.changes = self.changes + 1

    def characters(self, content):
        """TBD."""
        if self.field:
            self.chars = self.chars + content

    def on_file(self, rev, action, path):  # pylint: disable=no-self-use
        """
        Exclude, this just enables other check-ins.

        Ignore any Jiras in this comment.
        """
        m = re.match(r'.*/whitelist$', path)
        if m:
            log('Ignoring whitelist change SVN:{0} "{1}" {2}'.format(
                rev, action, path))
            return True

        if path.find('/src/tools/mfgc/') != -1:
            # Exclude this. (Automerge should be stopped)
            return True

        return False

    def on_tag(self, rev, msg):
        """TBD."""
        msg = cgi.escape(msg.strip()).encode('ascii', 'xmlcharrefreplace')
        log('LogHandler.on_tag({0}, "{1}")'.format(rev, msg))
        self.copyfrom_msg = msg

    def on_rev(self, rev, msg, author):
        """Handle a log entry."""
        msg = cgi.escape(msg.strip()).encode('ascii', 'xmlcharrefreplace')
        log('LogHandler.on_rev({0}, "{1}", {2})'.format(rev, msg, author))

        if author == 'automrgr':
            # Exclude 'Updating source logs' etc. (but not real changes)
            log('\tSkipping change by author=automrgr.')
            return

        self.store_matches(rev, msg)

    # Parse text and record change information.
    def store_matches(self, rev, msg):
        """TBD."""
        self.comments_by_rev[rev] = smart_truncate(msg)

    def lookup_summaries(self, ra=None):
        """Does nothing in this simple base class."""
        pass

    # pylint: disable=unused-argument
    def write_changes(self, ra=None, due=None, show_more=False):
        """TBD."""
        for rev in self.comments_by_rev:
            writeln('SVN:{0} {1}'.format(rev, self.comments_by_rev[rev]))


class LogHandlerJira(LogHandler):

    """Log handler for Jira issues."""

    def __init__(self, path):
        LogHandler.__init__(self, path)
        # Unlike the base LogHandler class, here comments will be summarized at
        # a higher level, preferably by Jira issue. The comments_by_rev dict
        # will only contain comments for revs with no Jira/PR.
        self.milestones = set()
        self.rdarlinks = {}
        self.radar_cache_stats = None, 0, []
        self.jiras = {}
        self.prs = {}  # Legacy PRs (no Jira in comment).
        self.radars = {}  # RADARs with no PR or Jira or RB.
        # 0 is a required special entry to collect unreferenced SVN entries.
        self.rbs = {0: []}
        self.automerges = {'nvram': []}  # Make these terse

    def radar_link(self, rdarlink, linkit=True):  # pylint: disable=no-self-use
        """TBD."""
        link = rdarlink
        if not linkit:
            link = rdarlink.replace('rdar://problem/', 'Radar ') + ':'
        elif not OPTS.twiki:
            link = '<' + rdarlink + '>'
        return link

    # Concatenate JIRA: prefix and id to create a link. But also work around
    # twiki bug that corrupts JIRA:CRDOT11ACPHY-652.
    def jira_link(self, jira):  # pylint: disable=no-self-use
        """TBD."""
        prefix = 'JIRA:'
        if re.search(r'([a-z0-9][A-Z])', jira):
            # Stop an apparent WikiWord from also becoming a link
            # as this seems to get corrupted.
            prefix = '!JIRA:'
        return prefix + jira

    def jira_link_sub(self, matchobj):
        """TBD."""
        return self.jira_link(matchobj.group(1))

    def store_matches(self, rev, msg):
        """Parse text and record change information."""
        # Extract JIRA, RB, PR, RADAR
        # TODO: Handle lists
        jira_matches = JIRA_RE.findall(msg)
        swwlan_matches = SWWLAN_RE.findall(msg)
        rb_match = RB_RE.search(msg)
        pr_match = PR_RE.search(msg)
        radar_match = RADAR_RE.search(msg)
        rb = 0
        radar = 0
        key = None
        if rb_match:
            log('\tfound RB:{0}.'.format(rb_match.group(1)))
            rb = int(rb_match.group(1))
        if radar_match:
            log('\tfound RADAR:{0}.'.format(radar_match.group(1)))
            radar = int(radar_match.group(1))
        if jira_matches and not OPTS.no_jira:
            log('\tfound JIRA ' + ', '.join(jira_matches))
            for j in jira_matches:
                self.jiras[j.encode('ascii')] = rb
                key = 'JIRA:' + j.encode('ascii')
        elif swwlan_matches and not OPTS.no_jira:
            log('\tfound JIRA ' + ', '.join(swwlan_matches) +
                ', SWWLAN implied.')
            for j in swwlan_matches:
                self.jiras['SWWLAN-' + j.encode('ascii')] = rb
                key = 'JIRA:SWWLAN-' + j.encode('ascii')
        elif pr_match and OPTS.gnats:
            log('\tfound PR:{0}.'.format(pr_match.group(1)))
            self.prs[int(pr_match.group(1))] = rb
            key = 'PR:' + pr_match.group(1)
        elif rev != 0:
            # If gnats and/or jira lookup disabled, at least
            # clean up the JIRA:/PR:xxx references.
            if pr_match:
                msg = re.sub(PR_RE, r'PR:\1', msg)
            if jira_matches:
                msg = re.sub(JIRA_RE, self.jira_link_sub, msg)
            # Store first line of message for each remaining rev
            lines = msg.split('\n')
            if lines[0] == 'Automerging:':
                where = lines[1].split('/')[-2]
                msg = 'Automerging {0}: {1}'.format(
                    where, extract_line(RB_RE, lines, 4))
                if where in self.automerges:
                    # Simplified output for these - comment not shown.
                    add_to_list(self.automerges, where, rev)
                else:
                    # Track as RB=0 (no RB)
                    add_to_list(self.rbs, rb, rev)
            elif radar_match and not rb_match:
                msg = extract_line(RADAR_RE, lines, 0)
                # Always list RADARs
                add_to_list(self.radars, radar, rev)
                key = 'RADAR:' + str(radar)
            else:
                msg = extract_line(RB_RE, lines, 0)
                # Track by RB (0 if no RB)
                add_to_list(self.rbs, rb, rev)
                if rb_match:
                    key = 'RB:' + str(rb)
                else:
                    key = 'SVN:' + str(rev)

            self.comments_by_rev[rev] = ' ' + smart_truncate(msg)
        return key

    def writeln_key(self, key, detail):  # pylint: disable=no-self-use
        """TBD."""
        s = key + detail
        if OPTS.relnote == 2:
            s = '{t:>{w}}'.format(t=s, w=RELNOTE_EXT_WIDTH_DUE)
        writeln(s)

    def on_pr_to_jira(self, pr, jira):
        """Useful for subclassing."""
        pass

    # Use the concise one line title of the Jira (or Gnats) issue, rather than
    # the (often multi-line or vague) check-in comment.
    def lookup_summaries(self, ra=None):
        """TBD."""
        log('LogHandler.lookup_summaries() reading Jira and Gnats.')
        for j in sorted(self.jiras.keys()):
            msg, _, pr, rdar = read_jira(j, JIRA_URL_FMT)
            if not msg:
                log('Warning: {0} not found in Jira'.format(j))
                msg = '(Invalid Jira ID in log.)'
            rb = ''
            if self.jiras[j]:
                rb = ' RB:{0}'.format(self.jiras[j])
            prm = ''
            if pr:
                prm = ' (PR:{0})'.format(pr)
            if rdar and not OPTS.no_radar:
                # Show as a radar instead of as a jira
                del self.jiras[j]
                # Remove redundant radar number (from Jira title).
                msg = re.sub(RADAR_RE, '', msg)
                more = None
                more = ''
                due = Due()
                # If we are doing radar lookups, don't if this is the special
                # radar number for infra changes.
                if ra and rdar != RADAR_INFRA:
                    try:
                        ra.load_jira(j)
                        milestone = ra.jira['radar_milestone']
                        tcd = ra.jira['radar_targetcompletioncurrent']
                        due = Due(milestone, tcd)
                        title = escape(ra.jira['radar_title'])
                        if msg != title:
                            more = '   - Radar title != Jira: ' + msg + '\n'
                            msg = title
                        more = more + self.more_radar_info(ra.jira)
                        more = more + '\n   - ' + self.jira_link(j) + rb + '\n'
                    except (ValueError, IOError, KeyError) as e:
                        more = ('   - Error: Unable to retrieve state from'
                                ' RadarAllow for {0}: {1}'.format(j, repr(e)))

                # Make a set of milestones
                self.milestones.add(due)

                # Store as a tuple
                self.rdarlinks[rdar] = (' ' + msg,
                                        self.jira_link(j) + rb, due, more)
            else:
                self.jiras[j] = '{0}{1} {2}'.format(prm, rb, msg)

        for pr in sorted(self.prs.keys()):
            rb = ''
            if self.prs[pr]:
                rb = ' RB:{0}'.format(self.prs[pr])
            msg = None
            if pr >= JIRA_FIRST_LEGACY_IMPORT:
                msg, j = read_jira(pr, JIRA_LEGACY_FMT)[0:2]
            if not msg or OPTS.no_jira:
                msg = read_gnats(pr)
                if not msg:
                    log('Warning: PR:{0} not found in Jira or Gnats'.format(pr))
                    msg = '(Invalid PR in log.)'
                self.prs[pr] = '{0} {1}'.format(rb, msg)
            else:
                if j not in self.jiras:
                    # The PR relates to a Jira issue already output.
                    self.jiras[j] = ' (PR:{0}){1} {2}'.format(pr, rb, msg)
                self.on_pr_to_jira(pr, j)
                del self.prs[pr]

    def more_radar_info(self, jdata):  # pylint: disable=no-self-use
        """TBD."""
        more = jdata['radar_state']  # e.g. 'Closed'
        if jdata.get('radar_substate', None):
            more = '{0}-{1}'.format(more, jdata['radar_substate'])
        if jdata.get('radar_resolution', None):
            more = '{0}-{1}'.format(more, jdata['radar_resolution'])
        if jdata.get('radar_duplicateof', None):
            more = '{0}, Duplicate of {1}'.format(more,
                                                  jdata['radar_duplicateof'])
        else:
            more = '{0}, Assigned to {1}'.format(more,
                                                 jdata['radar_assignee_email'])
        return '   - ' + more

    def missing(self, jdata, due):
        """TBD."""
        if 'radar_id' not in jdata:
            # Ignore unexpected file, possibly Jira data only.
            return
        rid = str(jdata['radar_id'])
        rdarlink = 'rdar://problem/' + rid
        if rdarlink not in self.rdarlinks.keys():
            other = Due(jdata['radar_milestone'],
                        jdata['radar_targetcompletioncurrent'])
            if due == other:
                jid = jdata['jira_id']
                # Usually matches: title = read_jira(jid, JIRA_URL_FMT)[0]
                title = escape(jdata['radar_title'])
                # If not in Analyze then probably marked as duplicate etc.
                # and tcd means nothing.
                if jdata['radar_state'] == 'Analyze':
                    writeln('Missing {0} {1} {2}'.format(jid, rid, title))
                    writeln(self.more_radar_info(jdata))

    def write_changes_radar(self, ra, due, linkit):
        """TBD."""
        if OPTS.relnote and ra:
            writeln()
            writeln('{0}:'.format(due.short()))
        for rdar in sorted(self.rdarlinks.keys()):
            d = dict(zip(['msg', 'jirarb', 'due', 'more'],
                         self.rdarlinks[rdar]))
            if due != d['due']:
                continue
            d['rdar'] = self.radar_link(rdar, linkit)
            if OPTS.relnote:
                # Show radar link and summary only
                self.writeln_key(d['rdar'], d['msg'])
            else:
                # Traditional format
                self.writeln_key(
                    d['rdar'],
                    ' {jirarb}{msg}'.format(**d))  # pylint: disable=star-args
            if (OPTS.relnote == 2 or
                (OPTS.relnote and d['more'] and
                 d['more'].find('   - Error: ') >= 0)):
                writeln(d['more'])

    def write_changes(self, ra=None, due=None, show_more=False):
        """TBD."""
        if ra:
            if due:
                log('LogHandler.write_changes(ra, {0}, {1})'.format(
                    due, show_more))
                for ms in [due, due.add_itools_suffix()]:
                    if ms in self.milestones:
                        self.milestones.remove(ms)
                    # Even if no changes, at least print the milestone heading.
                    self.write_changes_radar(ra, ms, True)
                    # List any radars marked for this milestone and TCD but
                    # not found in svn. Skip it if not TCD or no milestone name,
                    # as those would be useless info.
                    if not OPTS.no_missing and ms.when and ms.milestone:
                        self.radar_cache_stats = ra.walk_jiras(
                            lambda d: self.missing(d, ms))
            else:
                log('LogHandler.write_changes(ra, due, {0})'.format(show_more))

            for m in sorted(self.milestones):
                # Now show any additional milestones found in the radars.
                self.write_changes_radar(ra, m, False)
        else:
            log('LogHandler.write_changes(None, None, {0})'.format(show_more))

        if OPTS.relnote and self.milestones and self.jiras:
            # Only need this heading if there is a need to
            # separate radars (by milestone) from jiras
            writeln()
            writeln('Commits with no radar:')

        for j in sorted(self.jiras.keys()):
            self.writeln_key(self.jira_link(j), self.jiras[j])

        for pr in sorted(self.prs.keys()):
            self.writeln_key('PR:' + str(pr), self.prs[pr])

        for rb in sorted(self.rbs.keys()[1:]):
            out = ''
            for rev in self.rbs[rb]:
                out = '{0} SVN:{1}'.format(out, rev)
            # Use the check-in message from the first check-in for this RB.
            self.writeln_key('RB:' + str(rb), '{0}{1}'.format(
                out, self.comments_by_rev[self.rbs[rb][0]]))

        for radar in sorted(self.radars.keys()):
            out = ''
            for rev in self.radars[radar]:
                out = '{0} SVN:{1}'.format(out, rev)
            # Use the check-in message from the first check-in for this radar.
            self.writeln_key('RADAR:' + str(radar), '{0}{1}'.format(
                out, self.comments_by_rev[self.radars[radar][0]]))

        if show_more:
            for rev in self.rbs[0]:
                self.writeln_key('SVN:' + str(rev), self.comments_by_rev[rev])

            for where in sorted(self.automerges.keys()):
                n = len(self.automerges[where])
                if n:
                    writeln('Includes {0} {1} automerges.'.format(n, where))
                if False:
                    # Most of these are irrelevant.
                    # Will eventually be moved to a separate component.
                    for rev in self.automerges[where]:
                        out = '{0} SVN:{1}'.format(out, rev)
                    writeln(out)


class LogHandlerJiraWithFootnotes(LogHandlerJira):

    """
    Builds on LogHandlerJira and adds support for footnotes (used for
    indicating ucode changes).

    Test cases:
     pr-diff PHO2203RC1_REL_6_25_61_19 PHO2203RC1_REL_6_25_61_20
       same as:
     pr-diff --what=/proj/branches/PHO2203RC1_TWIG_6_25_61 410065 410242

    Big test case: (multiple ucode check-ins)
     pr-diff PHOENIX2_REL_6_10_212 PHOENIX2_REL_6_10_213

    Changed ucode in tag:
     pr-diff  PHOENIX2_REL_6_10_56_169 --show-more --twiki
    """

    def __init__(self, path, start, end, footnote_revs):
        LogHandlerJira.__init__(self, path)
        # Store svn log parameters for later use
        self.start = int(start)
        self.end = end
        # Store dict of SVN revs that changed ucode (optional input)
        self.footnote_revs = footnote_revs
        # Data:
        # Footnote markers to output, dict by key
        self.footnotes_by_key = {}

    def store_matches(self, rev, msg):
        """TBD."""
        key = LogHandlerJira.store_matches(self, rev, msg)
        if key and rev in self.footnote_revs:
            self.footnotes_by_key[key] = ' ' + SUPERSCRIPT1

    def writeln_key(self, key, detail):
        """TBD."""
        LogHandlerJira.writeln_key(self,
                                   key + self.footnotes_by_key.get(key, ''),
                                   detail)

    # Called during lookup_summaries, used here to correct footnotes.
    def on_pr_to_jira(self, pr, jira):
        """TBD."""
        footnote = self.footnotes_by_key.pop('PR:' + str(pr), None)
        if footnote:
            self.footnotes_by_key['JIRA:' + jira] = footnote

    def rev2ucode(self, rev):
        """TBD."""
        bash_script = 'path={0}; rev={1};' \
            ' svn cat $path/src/wl/sys/d11ucode_p2p.c@$rev 2>/dev/null |' \
            ' egrep "^CONST uint32 d11ucode_" |' \
            " sed -r 's/.* ([0-9]+);$/\\1/' |" \
            " xargs --no-run-if-empty printf '%d.%d'".format(
                WLREPO + self.path, rev)
        if OPTS.debug > 1:
            bash_script = 'set -x; ' + bash_script
        p = subprocess.Popen(bash_script, shell=True, stdout=subprocess.PIPE)
        p.wait()
        return p.stdout.read()

    def write_ucode_changes(self):
        """TBD."""
        # If looking at changes since beginning of branch/twig, start may be 0,
        # so need to use self.oldest instead so that 'svn cat' works.
        bottom_row = self.rev2ucode(self.start or self.oldest)
        top_row = self.rev2ucode(self.end)
        if not top_row or not bottom_row:
            log('write_ucode_changes() has nothing to do, no ucode present.')
            return
        if top_row == bottom_row:
            log('write_ucode_changes() ucode rev unchanged at {0}.'.format(
                top_row))
            return
        heading = '{0}Ucode changes {1} - {2}: '.format(SUPERSCRIPT1,
                                                        bottom_row, top_row)
        # TODO: Consider caching the page
        bash_script = r'''
        curl -# -u '{0}:{1}' {2}?raw=on 2>/dev/null |
        sed -nre '/_{3}/,/_{4}/p' |
        head -n -1
        '''.format(USERNAME, PASSWORD, UCODE_RELEASE,
                   top_row.replace('.', '_'),
                   bottom_row.replace('.', '_'))
        p = subprocess.Popen(bash_script, shell=True, stdout=subprocess.PIPE)
        p.wait()
        markup = p.stdout.read()
        if not markup:
            writeln(heading + 'See UcodeRelease.')
            log('write_ucode_changes() unable to extract history from twiki,'
                ' may be a change to an older rev or a different twig,'
                ' or missing from twiki.')
            return
        handler = LogHandlerJira('')
        text = ''
        for line in markup.splitlines():
            if line and line[-1] == '\\':
                continue
            text = text + line
            if (text == '') or (text[0] != '|'):
                writeln(heading + 'See UcodeRelease.')
                log('Ucode history is not contiguous in one table;'
                    ' may be a change to an older rev or a different twig,'
                    ' or missing from twiki.')
                return
            handler.store_matches(0, text)
            text = ''
        writeln(heading)
        handler.lookup_summaries()
        handler.write_changes()


def parse_svn_log2(path, start, end, handler=None):
    """
    Get all checkin messages pertaining to a specified branch for a given range
    of repository revisions. The range is (start, end], i.e. it does not include
    start but it does include end. This is because we generally want to know
    what changes there have been after start and up to and including end. To get
    all changes from the beginning of time pass 0 for start. Note that svn takes
    an inclusive range so 1 is added to start before calling svn diff.
    (start, end] == [start+1, end].
    """
    if path[0] != '/':
        path = '/' + path
    if not handler:
        handler = LogHandlerJira(path)

    svn_cmd_words = [
        'svn', 'log', '--xml', '--stop-on-copy', '--verbose',
        '--revision', '{0}:{1}'.format(int(start) + 1, end),
        WLREPO + path + '@' + end
    ]
    log(' '.join(svn_cmd_words))
    p = subprocess.Popen(svn_cmd_words, stdout=subprocess.PIPE)

    # pylint: disable=protected-access
    try:
        xml.sax.parse(p.stdout, handler)
    except xml.sax._exceptions.SAXParseException:
        # Probably 'no element found', the svn command failed
        # and output an error message (and set p.returncode)
        pass

    p.wait()
    p.stdout.close()

    log('changes: {0}'.format(handler.changes))
    log('copyfrom_rev: {0}'.format(handler.copyfrom_rev))
    log('copyfrom_path: {0}'.format(handler.copyfrom_path))

    return handler


def parse_svn_log(path, start, end):
    """TBD."""
    if path[0] != '/':
        path = '/' + path
    footnote_revs = {}
    if not OPTS.no_ucode:
        ucode_handler = LogHandler(path)
        parse_svn_log2(path + '/src/wl/sys/d11ucode_p2p.c',
                       start, end, ucode_handler)
        footnote_revs = ucode_handler.get_revs()
    handler = LogHandlerJiraWithFootnotes(path, start, end, footnote_revs)
    return parse_svn_log2(path, start, end, handler)


def tag2path(what, tag):
    """TBD."""
    path = None
    if not what:
        what = '/proj'
    m = re.match(r'([^_]+)_(REL|TWIG|BRANCH)_', tag)
    if m and m.lastindex == 2:
        if m.group(2) == 'REL':
            path = '%s/tags/%s/%s' % (what, m.group(1), tag)
        else:
            path = '%s/branches/%s' % (what, tag)
    return path


def parse_tag_svn_log(what, tag):
    """TBD."""
    parent = None
    if tag.count('/'):
        # If any slashes, use tag verbatim, ignoring 'what'. This makes it
        # possible to diff a component based on tags from a driver branch, for
        # example.
        # Ex: /proj/tags/AARDVARK/AARDVARK_REL_6_30_96
        # Ex: /proj/tags/PHOENIX2/PHOENIX2_REL_6_10_116
        # Ex: /proj/tags/WPA_SUPPLICANT-0-8/WPA_SUPPLICANT-0-8_00_44_RELEASE
        handler = parse_svn_log(tag, '0', 'HEAD')
        if not what:
            # Throw copyfrom_path away if --what overrides it.
            parent = handler.copyfrom_path
    else:
        # This is the most common usage.
        # Example: PHOENIX2_REL_6_10_116
        # Example: /components/opensource/linux/linux-2.6.36, LINUX2636_REL_1_0
        handler = parse_svn_log(tag2path(what, tag), '0', 'HEAD')
        parent = handler.copyfrom_path

    return handler, handler.copyfrom_rev, parent


def parse_tag_or_rev(what, tag_or_rev):
    """TBD."""
    if tag_or_rev.isdigit() or tag_or_rev == 'HEAD':  # TODO: Allow 'r12345'
        handler = None
        rev = tag_or_rev
        parent = None
        if rev.isdigit() and rev < 1:
            writeln_error('Given revision "{0}" must be >= 1.'.format(rev))
    else:
        log('Parsing log for tag "{0}"'.format(tag_or_rev))
        handler, rev, parent = parse_tag_svn_log(what, tag_or_rev)
        if rev == -1:
            writeln_error('Tag "{0}" not found.'.format(tag_or_rev))
    return handler, rev, parent


# pylint: disable=too-many-return-statements
def main():
    """Conventional entry point."""
    retcode = 0

    parser = argparse.ArgumentParser(
        epilog=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '--compat',
        help="specify intended (compatible) targets for release notes")
    parser.add_argument(
        '-m', '--milestone',
        help="specify milestone for release notes")
    parser.add_argument(
        '--relnote', action='store_const', const=1, dest='relnote',
        help="output for Olympic release notes - Radar only")
    parser.add_argument(
        '--relnote-ext', action='store_const', const=2, dest='relnote',
        help="output for Olympic release notes with extended detail")
    parser.add_argument(
        '--no-missing', action='store_true',
        help="don't search for missing radars")
    parser.add_argument(
        '-t', '--twiki', action='store_true',
        help="output as twiki markup")
    parser.add_argument(
        '-p', '--path',
        help="restrict log to a path e.g. 'src/dhd'")
    # Default is effectively '/proj' with a tag, or '/proj/trunk' with revs.
    # e.g. '/proj/branches/AARDVARK_BRANCH_6_30' with revs
    # e.g. '/components/opensource/linux/linux-2.6.36' with LINUX2636_REL_1_0
    parser.add_argument(
        '-w', '--what',
        help="specify what branch or component to log")
    parser.add_argument(
        '--show-tagged', action='store_true',
        help="show information about the tag itself")
    parser.add_argument(
        '--show-more', action='store_true',
        help="show most changes even if no JIRA/PR/RB (experimental)")
    parser.add_argument(
        '--debug', action='count',
        help="show log messages to help debug this script")
    parser.add_argument(
        '--debug-jira', action='store_true',
        help="show log messages to help debug Jira reads")
    parser.add_argument(
        '--no-radar', action='store_true',
        help="do not show radar number instead of jira (old behavior)")
    parser.add_argument(
        '--no-radar-lookup', action='store_true',
        help="show radar numbers if available, but don't lookup milestone etc")
    parser.add_argument(
        '--no-jira', action='store_true',
        help="for testing only")
    parser.add_argument(
        '--gnats', action='store_true',
        help="useful with older branches if gnats tools available")
    parser.add_argument(
        '--no-ucode', action='store_true',
        help="do not attempt to list specific ucode changes")
    parser.add_argument(
        'tag_or_rev', nargs='+',
        help="tags or revisions (1 or 2)")

    global OPTS  # pylint: disable=global-statement
    OPTS = parser.parse_args()

    if len(OPTS.tag_or_rev) == 2:
        first = OPTS.tag_or_rev[0]
        last = OPTS.tag_or_rev[1]
    elif len(OPTS.tag_or_rev) == 1:
        # Just one parameter gives you history since start of twig/branch.
        first = '0'
        last = OPTS.tag_or_rev[0]
    else:
        sys.argv = [sys.argv[0], '-h']
        main()

    try:
        ra = None
        if not OPTS.no_radar_lookup:
            ra = hnd.oly.rallow.RadarAllow()

        if OPTS.gnats and not gnats_login():
            return 1

        # --path implies --no-ucode.
        if OPTS.path:
            OPTS.no_ucode = True

        # If --what is given, and not used to resolve a tag, use as path.
        path = OPTS.what

        first_handler, first_rev, first_parent = \
            parse_tag_or_rev(OPTS.what, first)
        del first_handler
        if first_parent:
            path = first_parent
        if first_rev < 1:
            return 1

        tag_handler, last_rev, last_parent = parse_tag_or_rev(OPTS.what, last)
        if last_parent:
            path = last_parent
        if last_rev < 1:
            return 1

        if last_parent and first_parent and last_parent != first_parent:
            writeln_warn('Tags are not from the same branch, unable to diff.')
            return 1

        if not path:
            path = '/proj/trunk/'
            writeln_warn('No branch was given or implied so assuming trunk.')

        if OPTS.path:
            if path.endswith('/'):
                path = path + OPTS.path
            else:
                path = path + '/' + OPTS.path

        # Output information about the tag itself.
        if tag_handler and OPTS.show_tagged:
            print('{0}\tSVN:{1}\t{2}'.format(last,
                                             last_rev,
                                             tag_handler.copyfrom_msg))
            print()

        # Finally, ready to do the real work.
        main_handler = None
        if first_rev == last_rev:
            if tag_handler:
                writeln_warn(
                    'Tags are the same so only reporting changes in the tag.')
            else:
                writeln_warn('Revisions are the same, nothing to do.')
        elif first_rev > last_rev:
            # If we passed this to svn log it would return in reverse order!
            writeln_warn('"{0}" is older than "{1}"'.format(last, first))
        elif not OPTS.path and re.match(r'^/proj/trunk/?$', path):
            # Excludes a bad tag like CARIBOU_REL_8_10_1
            # Note: Currently no support to log history of trunk driver, since
            # there are other things like DHD there.
            writeln_warn(
                'Ignoring unusual trunk log request. Maybe tag is bad.')
        else:
            main_handler = parse_svn_log(path, first_rev, last_rev)

            # TODO: Make this a function.
            due = None
            if OPTS.relnote:
                summary = clm = ucode = compat = ''
                # Note that milestone is optional.  Milestones will be extracted
                # from the radars in the history.
                if OPTS.milestone:
                    # Parse Milestone and Date (year may be implied)
                    match = re.match(r'^(.*) ([-/0-9]+)$', OPTS.milestone)
                    if not match:
                        writeln_error(
                            'Invalid milestone, expected "Milestone Name m/d"')
                        return 1
                    milestone_name = match.group(1)
                    date_str = match.group(2)

                    # TODO:  Due.parse()
                    match = re.match(r'^([0-9]+)/([0-9]+)$', date_str)
                    if match:
                        g = match.groups()
                        release = date.today().replace(month=int(g[0]),
                                                       day=int(g[1]))
                    else:
                        # dateutil.parser would be nice, but let's not count
                        # on it being available.
                        try:
                            release = datetime.strptime(date_str,
                                                        '%Y-%m-%d').date()
                        except ValueError:
                            writeln_error(
                                'Invalid date, expected m/d or yyyy-mm-dd')
                            raise

                    due = Due(milestone_name, release)

                    # Create an initial summary line, based on the milestone.
                    # Tag being delivered is typically the second parameter
                    summary = '{0} {1}'.format(due.short(), last)

                    if OPTS.compat:
                        compat = OPTS.compat
                        summary = summary + ' for ' + compat

                # CLM Data
                clmxml = '/'.join([
                    WLREPO + main_handler.path,
                    'src', 'wl', 'clm', 'private',
                    'wlc_olyclm_data.xml@{0}'.format(last_rev)])
                xmlgrep = 'xml_grep --text_only --nb_results 1 table_revision'
                cmd = 'svn cat {0} | {1}'.format(clmxml, xmlgrep)
                try:
                    # Hide errors, this is best effort only, and branches vary.
                    with open(os.devnull, 'w') as devnull:
                        clm = subprocess.check_output(
                            cmd, shell=True, stderr=devnull).strip()
                except subprocess.CalledProcessError, e:
                    writeln_error('CLM data version not found (old branch?) due'
                                  ' to error: %s' % e)

                # Ucode
                if not OPTS.no_ucode:
                    ucode = main_handler.rev2ucode(last_rev)

                # Output a header for the release note
                writeln(summary)
                writeln()
                writeln('FW: {0}'.format(last))
                writeln('uCode: {0}'.format(ucode))
                writeln('CLM: {0}'.format(clm))
                writeln('SW/HW compatibility: {0}'.format(compat))
                writeln('DHD/WL tested: {0}'.format(''))
                writeln('Milestone: {0}'.format(due.milestone if due else ''))
                writeln('Release Date: {0}'.format(due.when if due else ''))
                writeln()

            main_handler.lookup_summaries(ra)
            main_handler.write_changes(ra=ra, due=due, show_more=OPTS.show_more)
            if not OPTS.no_ucode and not OPTS.relnote:
                main_handler.write_ucode_changes()

        if tag_handler and tag_handler.changes > 0:
            writeln_warn('Changes in tag: ({0})'.format(tag_handler.changes))
            tag_handler.lookup_summaries(ra)
            tag_handler.write_changes(ra=ra, due=due, show_more=True)
            if not OPTS.no_ucode:
                tag_handler.write_ucode_changes()

        if OPTS.relnote:
            writeln('')
            writeln('WLAN Note:')
            writeln('')
            writeln('***')

        if main_handler and main_handler.radar_cache_stats[0]:
            ts, count, errs = main_handler.radar_cache_stats
            ts = ts.replace(microsecond=0)
            writeln('(Note: This report was run against {0} radars cached'
                    ' at {1})'.format(count, ts.isoformat(' ')))
            if errs:
                writeln(
                    '(There were {0} errors when reading the radar cache so'
                    ' the above report may not be correct.)'.format(len(errs)))
                for e in errs[0:20]:
                    writeln(e)

    except FatalError:
        retcode = 1

    return retcode

if __name__ == '__main__':
    sys.exit(main())

# vim: ts=8:sw=4:et:tw=80:
