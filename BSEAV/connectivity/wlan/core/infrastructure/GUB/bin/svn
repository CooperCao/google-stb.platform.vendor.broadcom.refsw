#!/usr/bin/env python

"""
Multi-version svn wrapper.

This is an svn wrapper which will examine the current or referenced
working copy (if any) to figure out which version it is and then
configure /tools/bin/svn (if available) to operate as that version. It
handles svn 1.6 through 1.9 now and should be easily extensible to
future versions once we know their schema number.  On platforms where
/tools/bin/svn is not mounted or not supported this intelligence isn't
an option so we just hand off to the next svn found on $PATH instead,
falling back to /usr/bin/svn. Bottom line, this will "work" (in the
sense of doing no harm) on any platform with svn and python 2.4+
installed but can only switch versions if /tools/bin/svn is supported.

Put differently, it modifies the semantics of the SUBVERSIONVER
variable. Essentially there are 3 levels of available svn support:

1. Regular svn client (e.g. /usr/bin/svn). Here you get what you run;
   if you use a X.Y client you'll have access to X.Y semantics only. Any
   new checkouts will be in X.Y format and any existing workspaces you
   use it with must be X.Y.

2. /tools/bin/svn. This is a wrapper script provided by IT which
   provides a default svn version but allows that default to be
   overridden via the environment variable SUBVERSIONVER. It allows easy
   switching across versions but still has the one-at-a-time problem;
   if you've got SUBVERSIONVER set to 1.7 and try using a 1.8 workspace
   it will still fail. Note that /tools/bin/svn can only do version
   switching when the required binaries have been built by IT for the
   current platform and that it falls back to invoking /usr/bin/svn if
   no custom binaries exist. Effectively this means it's helpful only
   on RHEL but does no harm elsewhere.

3. This program, which can be used as a wrapper over any svn client
   (case #1 or #2 above) but adds value only when used over
   /tools/bin/svn (#2). It modifies the semantics of SUBVERSIONVER;
   rather than being a hard setting ("use version X.Y"), it becomes just
   a preference for new checkouts. In other words if you run this wrapper
   in an existing checkout it will set SUBVERSIONVER to that version,
   so it will work in any svn checkout as long as /tools/bin/svn is
   present and supports the discovered version. A previously-existing
   value of SUBVERSIONVER is consulted only for new content. Thus
   "SUBVERSIONVER=X.Y" now means "use X.Y for new checkouts but within
   existing checkouts defer to the existing version".

A -P flag is intercepted by the wrapper to force a pass-through to
other svn variants, thus suppressing current-checkout sensitivity.
The -P levels are:

    -P:       pass through to the next 'svn' on PATH
    -PP:      pass through to /tools/bin/svn unequivocally
    -PPP:     pass through to /usr/bin/svn unequivocally
    -PPPP:    pass through to our old hard-wired 1.6.15 linux binary

A -V flag is similarly intercepted to enable wrapper verbosity.
Both flags have environment equivalents (SVN_PY_PASSTHROUGH and
SVN_PY_VERBOSITY).

Use "svn -H" to see this help message, and "svn --help" or
"svn help <command>" to get help for the real svn program.

"""

# This script attempts to remain compatible with Python 2.4, because
# there are still a few around and wrappers need to be extra robust.
# One of the tricky things is that we can't use argparse to analyze
# the command line due to the 2.4 compatibility requirement.

# Can't use these due to 2.4 requirement but keep them as comments
# to make pystyle happy.
# from __future__ import print_function
# from __future__ import unicode_literals

import getopt
import os
import sys

# The preferred major svn version.
PREFERRED = 1.8

# These versions, while not the latest, are acceptable.
ACCEPTABLE = [
    '1.8.10',
    '1.8.11',
    '1.8.13',
]

PROPCMDS = (
    'pd', 'pdel', 'propdel',
    'pe', 'pedit', 'propedit',
    'pe', 'pget', 'propget',
    'pl', 'plist', 'proplist',
    'ps', 'pset', 'propset',
)

LOOP_EV = 'SVN_WRAPPER_LOOP'
SVNVER = 'SUBVERSIONVER'
VERBOSITY = 0
SVN_1_6_15 = '/projects/hnd/tools/linux/Subversion'
WC_DB = os.path.join('.svn', 'wc.db')

PASSTHROUGH_EV = 'SVN_PY_PASSTHROUGH'
VERBOSITY_EV = 'SVN_PY_VERBOSITY'

TOOLS_BIN_SVN = '/tools/bin/svn'
USR_BIN_SVN = '/usr/bin/svn'

OSSFMT = '/tools/oss/packages/x86_64-rhel%s/subversion'
REDHAT_RELEASE = '/etc/redhat-release'
REDHAT = os.path.isfile(REDHAT_RELEASE)
FEDORA = REDHAT and os.path.isfile('/etc/fedora-release')
RHEL = REDHAT and not FEDORA

# This is the union of options for all svn commands.
SVNOPTS = (
    'F:NRc:gl:m:qr:uvx:',
    [
        'accept=', 'allow-mixed-revisions', 'auto-props',
        'change=', 'changelist', 'cl', 'config-dir=',
        'config-option=', 'depth=', 'diff', 'diff-cmd=',
        'diff3-cmd', 'dry-run', 'editor-cmd=', 'encoding=',
        'extensions=', 'file=', 'force', 'force-interactive',
        'force-log', 'git', 'ignore-ancestry', 'ignore-externals',
        'ignore-keywords', 'ignore-properties', 'ignore-whitespace',
        'include-externals', 'incremental', 'internal-diff',
        'keep-changelists', 'keep-local', 'limit=', 'message=',
        'native-eol=', 'new=', 'no-auth-cache', 'no-auto-props',
        'no-diff-added', 'no-diff-deleted', 'no-ignore', 'no-unlock',
        'non-interactive', 'non-recursive', 'notice-ancestry', 'old=',
        'parent', 'parents', 'password=', 'patch-compatible',
        'properties-only', 'quiet', 'record-only', 'recursive', 'reintegrate',
        'relocate', 'remove', 'reverse-diff', 'revprop', 'revision=',
        'search=', 'search-and=', 'set-depth=', 'show-copies-as-adds',
        'show-inherited-props', 'show-revs=', 'show-updates', 'stop-on-copy',
        'strict', 'strip=', 'summarize', 'targets=', 'trust-server-cert',
        'use-merge-history', 'username=', 'verbose', 'version',
        'with-all-revprops', 'with-no-revprops', 'with-revprop=', 'xml',
    ]

)


def verbose(msg, pfx=None, vl=0):
    """Print optional wrapper verbosity."""
    if VERBOSITY > vl:
        if pfx:
            sys.stderr.write(pfx + ' ')
        else:
            sys.stderr.write(__file__ + ': ')

        print >> sys.stderr, msg


def pipeto(cmd):
    """Send upcoming stdout through the command."""
    if os.isatty(sys.stdin.fileno()):
        rfd, wfd = os.pipe()
        if os.fork():
            # parent
            os.close(wfd)
            os.dup2(rfd, sys.stdin.fileno())
            os.execvp(cmd[0], cmd)
        else:
            # child
            os.close(rfd)
            os.dup2(wfd, sys.stdout.fileno())


def best(wanted):
    """Return the preferred point release of the provided major version."""

    latest = {'1.4': 0, '1.6': 0, '1.7': 0, '1.8': 0, '1.9': 0}
    if RHEL:
        f = open(REDHAT_RELEASE)
        line = f.read().rstrip()
        f.close()
        rhver = [w for w in line.split() if w[0] in '1234567890'][0]
        ossdir = OSSFMT % rhver[0]
        if os.path.isdir(ossdir):
            for word in os.listdir(ossdir):
                for major in latest:
                    start = str(major) + '.'
                    if word.startswith(start):
                        try:
                            minor = int(word.split('.')[-1])
                        except ValueError:
                            continue
                        if minor > latest[major]:
                            latest[major] = minor
    if wanted:
        wanted = '%s' % wanted  # convert from float, avoid e.g. 1.6999999999
        if latest.get(wanted):
            return '%s.%d' % (wanted, latest[wanted])
        else:
            return None
    else:
        return sorted(['%s.%d' % (k, latest[k]) for k in latest if latest[k]])


def svn_major_version(path):
    """Return the major version (x.y) of the current working copy, if any."""
    version = None
    path = os.path.abspath(path)
    while True:
        wc_db = os.path.join(path, WC_DB)
        if os.path.exists(wc_db):
            f = open(wc_db, 'rb')
            # The format is the 64th byte of the db file.
            fmt = ord(f.read(64)[-1])
            if fmt == 29:
                version = 1.7
            elif fmt == 31:
                version = 1.8
            else:
                print >> sys.stderr, 'Warning: unknown svn format %d' % fmt
                f.close()
            break
        elif os.path.exists(os.path.join(path, '.svn')):
            fmtfile = os.path.join(path, '.svn', 'format')
            if os.path.isfile(fmtfile):
                version = 1.4
            else:
                version = 1.6
            break
        else:
            parent = os.path.dirname(path)
            if len(parent) >= len(path):
                break
            path = parent
    return version, path


def change_version_to(major):
    """Export SUBVERSIONVER to the appropriate major version."""
    best_major = best(major)
    if best_major:
        if SVNVER in os.environ:
            if not os.path.isfile(os.path.expanduser('~/.hushsvn')):
                sys.stderr.write(
                    '%s: Warning: set %s=%s to match checkout\n' % (
                        __file__, SVNVER, best_major))
        os.environ[SVNVER] = best_major
    else:
        sys.stderr.write(
            '%s: Warning: no version found for major=%s\n' % (__file__, major))


def set_current_version():
    """Set SUBVERSIONVER to the appropriate level."""
    # Try to parse away all known svn flags for all known commands
    # in order to see whether a file/directory operand was given.
    try:
        _, words = getopt.gnu_getopt(sys.argv[1:], SVNOPTS[0], SVNOPTS[1])
    except Exception:
        words = sys.argv[1:]

    # Get the name of the svn command.
    if words:
        subcmd = words[0]
    else:
        subcmd = None

    # Try to identify the best candidate for "sampling".
    tgt1 = tgt2 = None
    if len(words) > 1:
        tgt1 = words[-1].split('@')[0]
        if len(words) > 2:
            tgt2 = words[-2].split('@')[0]

    # Checkouts are special because they create their own context and
    # shouldn't use version X just because some parent directory does.
    if subcmd not in ['co', 'checkout', 'export']:
        if len(words) == 2 and subcmd == 'patch':
            sample = '.'
        elif tgt1 and '://' in tgt1 and subcmd in PROPCMDS:
            # No working copy involved.
            sample = None
        elif tgt1 and '://' in tgt1 and not tgt2:
            # No working copy involved.
            sample = None
        elif subcmd == 'import':
            # No working copy involved.
            sample = None
        elif subcmd in ('lock', 'unlock', 'upgrade'):
            # Administrative tasks, leave them alone.
            sample = None
        elif tgt2 and \
                subcmd in ('copy', 'cp', 'move', 'mv', 'rename', 'ren'):
            if os.path.exists(tgt2):
                sample = tgt2
            elif '://' in tgt2 and '://' not in tgt1:
                if os.path.isfile(tgt1):
                    sample = os.path.dirname(tgt1)
                    if not sample:
                        sample = '.'
                elif os.path.isdir(tgt1):
                    sample = tgt1
                elif os.path.isdir(os.path.dirname(tgt1)):
                    sample = os.path.dirname(tgt1)
                else:
                    sample = '.'
            else:
                # If nothing to sample, go with the default version.
                sample = None
        elif tgt1 and os.path.exists(tgt1):
            sample = tgt1
        elif tgt1 and subcmd in ('update', 'up') and \
                os.path.isdir(os.path.dirname(tgt1)):
            sample = tgt1
        elif tgt1 and subcmd == 'mkdir' and '://' not in tgt1:
            sample = tgt1
        else:
            sample = '.'

        if sample:
            major, found = svn_major_version(sample)
            verbose('sampling %s found major version %s' % (found, major))
            if not major:
                # No local context found.
                pass
            elif major == 1.8:  # or major == 1.9
                # Special case: it seems 1.8 and 1.9 share the same format.
                # We report that format as 1.8 and let the user stay
                # with either 1.8 or 1.9 if they've chosen one.
                # TODO - prefer 1.9 once supported.
                if os.environ.get(SVNVER, '').startswith('1.9'):
                    pass
                elif not os.environ.get(SVNVER, '').startswith(str(major)):
                    change_version_to(major)
            elif not os.environ.get(SVNVER, '').startswith(str(major)):
                change_version_to(major)


def main():
    """Multi-version svn wrapper."""

    # Unadvertised convenience feature: "svn PREFERRED [major]".
    if len(sys.argv) > 1 and sys.argv[1].upper() == 'PREFERRED':
        if len(sys.argv) > 2:
            print best(float('.'.join(sys.argv[2].split('.', 2)[0:2])))
        else:
            print best(PREFERRED)
        sys.exit(0)

    # To enable wrapper verbosity we can use an EV or our own -V flag which
    # is not native to svn. Similar with -P for pass-through.
    # pylint: disable=global-statement
    global VERBOSITY
    VERBOSITY = int(os.environ.get(VERBOSITY_EV, '0'))
    passthrough = int(os.environ.get(PASSTHROUGH_EV, '0'))
    sys_argv = []
    for arg in sys.argv:
        if arg.startswith('-V') or arg.startswith('-P'):
            passthrough += arg.count('P')
            VERBOSITY += arg.count('V')
        elif arg == '-H' or (arg != '--help' and arg.upper() == '--HELP'):
            print __doc__.strip()
            sys.exit(0)
        else:
            # Unadvertised convenience features: "svn URL|REVISION|BRANCH|TAG".
            if len(sys_argv) == 1 and arg.upper() in ('REVISION', 'URL',
                                                      'BRANCH', 'TAG'):
                arg = arg.upper()
                if arg == 'BRANCH' or arg == 'TAG':
                    awkscr = ' '.join("""/^URL:/ {for (i = 3; i <= NF; i++) {
                        if ($i ~ /^[A-Z].+[0-9_]+[0-9]$/ || $i == "trunk") {
                            print $i; break}}}""".split())
                    cmd = ['awk', '-F/', awkscr]
                else:
                    cmd = ['awk', 'toupper($1) ~ /^%s:/ {print $NF}' % arg]
                pipeto(cmd)
                arg = 'info'
            sys_argv.append(arg)
    sys.argv = sys_argv

    def next_svn():
        """Search PATH for the next available 'svn'."""
        shebang = '#!/usr/bin/env python'
        svnpath = []
        pid = os.getpid()
        for entry in os.environ.get('PATH', '').split(os.pathsep):
            prog = os.path.join(entry, 'svn')
            if prog == '/projects/hnd/tools/linux/bin/svn' and not REDHAT:
                verbose('skipping redhat %s in %d ...' % (prog, pid))
                continue
            if os.path.isfile(prog) and os.access(prog, os.X_OK):
                if os.path.getsize(prog) == os.path.getsize(__file__):
                    verbose('skipping identical %s in %d ...' % (prog, pid))
                    continue
                try:
                    f = open(prog)
                    start = f.read(len(shebang))
                    f.close()
                except Exception:
                    pass
                if start == shebang:
                    verbose('skipping other python wrapper %s in %d ...' %
                            (prog, pid))
                    continue

                svnpath.append(prog)

        if svnpath:
            svnprog = svnpath[0]
            verbose('moving on to %s ...' % svnprog)
        else:
            svnprog = USR_BIN_SVN
            if os.path.exists(USR_BIN_SVN):
                verbose('falling back to %s ...' % svnprog)
            else:
                verbose('no %s, giving up' % svnprog)
                svnprog = None

        return svnprog

    if LOOP_EV in os.environ:
        print >> sys.stderr, \
            '%s: Error: exec loop with %s' % (__file__, os.environ[LOOP_EV])
        sys.exit(2)

    vpfx = None
    if passthrough == 1:
        # Allow this program to be dummied out in situ.
        svnprog = next_svn()
        if not svnprog:
            svnprog = USR_BIN_SVN
    elif passthrough == 2:
        svnprog = TOOLS_BIN_SVN
        if SVNVER in os.environ:
            vpfx = '+ %s=%s %s' % (SVNVER, os.environ[SVNVER], svnprog)
    elif passthrough == 3:
        svnprog = USR_BIN_SVN
    elif passthrough == 0 and RHEL and os.path.exists(TOOLS_BIN_SVN):
        # Due to the unfortunate behavior of /tools/bin wrappers which causes
        # them to drop silently back to the native version for unrecognized
        # values of ***VER, we add a warning here since /tools/bin/svn won't.
        # This also encourages use of the latest point release.
        bests = best(None)
        acceptable = set(bests + ACCEPTABLE)
        if SVNVER in os.environ and os.environ[SVNVER] not in acceptable:
            preferred = [v for v in bests if not v.startswith('1.4')]
            sys.stderr.write('%s: Warning: nonstandard value' % __file__)
            sys.stderr.write(' %s=%s' % (SVNVER, os.environ[SVNVER]))
            sys.stderr.write(' (preferred: %s)\n' % '|'.join(preferred))

        set_current_version()
        svnprog = TOOLS_BIN_SVN
        if SVNVER in os.environ:
            vpfx = '+ %s=%s %s' % (SVNVER, os.environ[SVNVER], svnprog)
    elif False and not passthrough and FEDORA and os.path.isdir('/tools/oss'):
        # On FC, ignore /tools/bin/svn and use its binaries directly.
        # Test on lab3-so, but remember that /usr/bin/svn is a shell override.
        # These systems prefer 1.7.x.
        if SVNVER not in os.environ:
            os.environ[SVNVER] = best(1.7)
        set_current_version()
        ldlib = '/tools/oss/brcm/i686-rhel4/lib'
        if 'LD_LIBRARY_PATH' in os.environ:
            ldlib += ':' + os.environ['LD_LIBRARY_PATH']
        os.environ['LD_LIBRARY_PATH'] = ldlib
        rhel4svn = '/tools/oss/packages/i686-rhel4/subversion'
        svnprog = '%s/%s/bin/svn' % (rhel4svn, os.environ.get(SVNVER, 'xxx'))
        vpfx = '+ LD_LIBRARY_PATH=%s %s' % (ldlib, svnprog)
    elif passthrough < 4 and ('linux' not in sys.platform or
                              not os.path.isdir(SVN_1_6_15) or
                              (SVNVER in os.environ and
                               not os.environ[SVNVER].startswith('1.6'))):
        # Search PATH for the next available 'svn'.
        svnprog = next_svn()
        if not svnprog:
            print >> sys.stderr, '%s: Error: no %s found' % (__file__,
                                                             USR_BIN_SVN)
            sys.exit(2)
    else:
        # Normally we'd fall back to the 1.6 hack described below.
        # But if there is a current checkout and it appears to be 1.7+
        # there's no sense forcing 1.6 which is sure to fail. Defer to
        # the next svn on PATH and assume the user has gotten it right.
        set_current_version()
        if os.environ.get(SVNVER, '1.6').startswith('1.6'):
            # Backward compatibility hack inherited from an older
            # bash script (now at GUB/bin/svn.sh) which forces use of
            # a hardwired svn 1.6 binary. The original reasoning
            # for this isn't documented but it does seem to be needed on
            # certain lab machines which don't have svn installed at all.
            # How this is going to scale to 1.7+ I don't know, for now just
            # trying to stay compatible with previous work while adding a
            # couple of escape hatches:
            # If on Linux and /tools/bin is supported we use it, as above.
            # If on Linux and /tools/bin is not supported, drop back
            # to this implementation. However, if the user has expressed
            # a preference for a post-1.6 version via SUBVERSIONVER, that
            # probably means they have post-1.6 working copies in which
            # case it would do no good to force them to 1.6. Even though
            # SUBVERSIONVER won't do them any good directly, it's a signal
            # that their own /usr/bin/svn is probably at a later version.
            # So if you want this hard-wired 1.6.15, don't ask for 1.7+.
            ldlib = os.path.join(SVN_1_6_15, 'lib')
            if 'LD_LIBRARY_PATH' in os.environ:
                ldlib += ':' + os.environ['LD_LIBRARY_PATH']
            os.environ['LD_LIBRARY_PATH'] = ldlib
            svnprog = os.path.join(SVN_1_6_15, 'bin', 'svn')
            vpfx = '+ LD_LIBRARY_PATH=%s %s' % (ldlib, svnprog)
        else:
            # Search PATH for the next available 'svn'.
            svnprog = next_svn()
            if not svnprog:
                print >> sys.stderr, '%s: Error: no %s found' % (__file__,
                                                                 USR_BIN_SVN)
                sys.exit(2)

    if not vpfx:
        vpfx = '+ %s' % svnprog
    verbose(' '.join(sys.argv[1:]), pfx=vpfx)

    # Double-check against infinite exec loop.
    os.environ[LOOP_EV] = __file__

    # Finally, run the command.
    try:
        os.execv(svnprog, sys.argv)
    except OSError, e:
        # pylint: disable=old-raise-syntax
        raise e.__class__, '%s: %s' % (e, svnprog)

if __name__ == '__main__':
    sys.exit(main())

# vim: ts=8:sw=4:tw=80:et:
