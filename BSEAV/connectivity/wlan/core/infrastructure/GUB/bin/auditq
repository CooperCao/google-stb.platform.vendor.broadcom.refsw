#!/usr/bin/env python2.7
"""Query a build audit for things like prereqs, targets, etc."""

from __future__ import print_function
from __future__ import unicode_literals

# Imported first to fix up sys.path etc.
import preface  # pylint: disable=relative-import,unused-import

import argparse
import os
import sys

# Look for the fast C-based yaml parser first.
import yaml
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader

import lib.audit


def main(argv):
    """Read a build audit and dump the data in various formats."""
    parser = argparse.ArgumentParser(
        epilog=main.__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    list_parser = parser.add_mutually_exclusive_group()
    list_parser.add_argument(
        '-A', '--print-all-known', action='store_true',
        help="print a list of all known files")
    list_parser.add_argument(
        '-a', '--print-all-involved', action='store_true',
        help="print a list of all involved files")
    list_parser.add_argument(
        '-d', '--print-directories', action='store_true',
        help="print a list of directories containing prereqs")
    list_parser.add_argument(
        '-I', '--print-intermediate-targets', action='store_true',
        help="print a list of intermediate target files")
    list_parser.add_argument(
        '-p', '--print-prerequisites', action='store_true',
        help="print a list of prerequisite file files")
    list_parser.add_argument(
        '-T', '--print-terminal-targets', action='store_true',
        help="print a list of terminal target files")
    list_parser.add_argument(
        '-t', '--print-targets', action='store_true',
        help="print a list of all target files")
    list_parser.add_argument(
        '-u', '--print-unused', action='store_true',
        help="print a list of files present but unused")
    parser.add_argument('dbfile', help="path to the audit file")
    opts = parser.parse_args(argv[1:])

    if not opts.dbfile:
        main([argv[0], '-h'])

    with open(opts.dbfile, 'r') as f:
        root = yaml.load(f, Loader=Loader)
        db = root[-1]

    results = set()

    if opts.print_all_involved or opts.print_all_known:
        results.update(db[lib.audit.INTERMEDIATES].keys())
        results.update(db[lib.audit.PREREQS].keys())
        results.update(db[lib.audit.TERMINALS].keys())
        if opts.print_all_known:
            results.update(db[lib.audit.UNUSED].keys())
    elif opts.print_directories:
        def add_dirs(accumulator, path):
            """I have no memory of what this does."""
            dirname = os.path.dirname(path)
            if dirname:
                accumulator.add(dirname)
                add_dirs(accumulator, dirname)

        for path in db[lib.audit.PREREQS].keys():
            add_dirs(results, path)
    elif opts.print_intermediate_targets:
        results.update(db[lib.audit.INTERMEDIATES].keys())
    elif opts.print_prerequisites:
        results.update(db[lib.audit.PREREQS].keys())
    elif opts.print_terminal_targets:
        results.update(db[lib.audit.TERMINALS].keys())
    elif opts.print_targets:
        results.update(db[lib.audit.TERMINALS].keys())
        results.update(db[lib.audit.INTERMEDIATES].keys())
    elif opts.print_unused:
        results.update(db[lib.audit.UNUSED].keys())

    for path in sorted(results):
        print(path)

if __name__ == '__main__':
    try:
        main(sys.argv)
    except IOError as e:
        # Workaround for an interpreter bug triggered by SIGPIPE.
        # See http://code.activestate.com/lists/python-tutor/88460/
        if 'Broken pipe' not in e.strerror:
            raise

# vim: ts=8:sw=4:tw=80:et:
