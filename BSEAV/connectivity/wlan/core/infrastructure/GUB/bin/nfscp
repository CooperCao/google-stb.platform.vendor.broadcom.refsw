#!/usr/bin/env python
"""
Parallel copier to defeat NFS latency issues.

The TCP Nagle algorithm delays packets with small payloads a bit in
the hope that more data will arrive soon, kind of like a bus waiting
past its scheduled departure in case a few more passengers show up. This
delay leads to latency issues which can cause problems when copying large
numbers of files over NFS. Nagle could be turned off with TCP_NODELAY but
it's actually a very good feature for using buses (packets) efficiently.

This script copies a tree of files in a massively parallel manner,
preventing Nagle delays from adding up in serial. The result can be an
order of magnitude or so faster as long as (a) large numbers of files
are being copied and (b) NFS over TCP is involved.

It also has a mode in which it can run in the background, mirroring
source to destination. This mode will automatically finish the mirroring
and exit after reading EOF from stdin, which is guaranteed to happen
when its parent process exits.

EXAMPLES:

To copy src-dir to dest-dir without SCM metadata:

    %(prog)s --exclude-scm src-dir dest-dir

To mirror continuously (every 10 seconds):

    %(prog)s -W 10 src-dir dest-dir

"""

from __future__ import print_function
from __future__ import unicode_literals

# Imported first to fix up sys.path etc.
import preface  # pylint: disable=relative-import

import argparse
import atexit
import datetime
import logging
import os
import select
import shutil
import subprocess
import sys
import time
import traceback

import lib.nfscp
import lib.opts
import lib.times
import lib.util


def main(argv):
    """Entry point for standalone use."""
    parser = argparse.ArgumentParser(
        epilog=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-B', '--backup', action='store_true',
        help="rename pre-existing dest files to .bak")
    parser.add_argument(
        '-D', '--remove-dst', action='store_true',
        help="delete dstdir prior to copy")
    parser.add_argument(
        '-E', '--elapsed', action='store_true',
        help="print elapsed time of command")
    parser.add_argument(
        '-e', '--exclude', action='append', default=[],
        metavar='RE',
        help="skip files or directories matching these regexes")
    parser.add_argument(
        '--exclude-bg', action='append', default=[],
        metavar='RE',
        help="like --exclude but only for background copies")
    parser.add_argument(
        '-f', '--fix-abs-symlinks', action='count',
        help="repoint copied absolute symlinks from src to dest")
    parser.add_argument(
        '-i', '--make-identical', action='store_true',
        help="remove any files in destdir not in srcdir")
    parser.add_argument(
        '-j', '--jobs', type=int, default=lib.nfscp.DEFAULT_JOBS,
        help="number of copy threads (default=%(default)s)")
    parser.add_argument(
        '-p', '--preserve-time', action='store_true',
        help="copy timestamps from src files to dst files")
    parser.add_argument(
        '--priority', type=float, default=1.0,
        help=argparse.SUPPRESS)
    parser.add_argument(
        '-s', '--exclude-scm', action='count',
        help="ignore SCM metadata (.svn, .git, etc)")
    parser.add_argument(
        '-S', '--remove-src', action='count',
        help="remove srcdir after successful copy")
    parser.add_argument(
        '--trim-only', action='store_true',
        help=argparse.SUPPRESS)
    parser.add_argument(
        '-t', '--trusting', action='store_true',
        help=argparse.SUPPRESS)
    parser.add_argument(
        '-V', '--verbose', action='count', default=0,
        help="increment verbosity level")
    parser.add_argument(
        '-w', '--protect', action='store_true',
        help="make copied files writable only by owner")
    parser.add_argument(
        '-W', '--watch-stdin', type=int, default=-1,
        metavar='SECS',
        help="run until stdin closes, sync every SECS seconds")
    parser.add_argument('srcdir', help="the source directory")
    parser.add_argument('dstdir', help="the target directory",
                        nargs='?', default='')
    opts = parser.parse_args(argv[1:])

    # Show elapsed wall-clock time on request.
    if opts.elapsed:
        atexit.register(lib.times.elapsed, time.time())

    # It's just not safe enough to rely only on sizes.
    if opts.trusting:
        opts.preserve_time = True

    if os.path.exists(opts.srcdir):
        if opts.dstdir and not os.path.isdir(opts.srcdir):
            shutil.copy(opts.srcdir, opts.dstdir)
    else:
        lib.util.die('%s: No such file or directory' % opts.srcdir, exc=False)

    if opts.verbose:
        lib.opts.VERBOSITY = opts.verbose
        if opts.verbose > 4:
            logging.basicConfig(level=logging.DEBUG,
                                format=preface.PROG + ': %(message)s')

    lib.util.note('Init at %s' % time.ctime(), vl=2)

    treesync = lib.nfscp.TreeSync(
        opts.srcdir,
        opts.dstdir,
        backup=opts.backup,
        excludes=opts.exclude,
        excludes_bg=opts.exclude_bg,
        exclude_scm=opts.exclude_scm,
        protect=opts.protect,
        preserve_time=opts.preserve_time,
        priority=opts.priority,
    )

    # Special, undocumented case; allow this command to do a threaded
    # (fast) removal of srcdir without copying if dstdir is unspecified.
    if not opts.dstdir:
        if opts.remove_src > 1:
            treesync.rm_src(jobs=opts.jobs)
        else:
            main([argv[0], '-h'])
        sys.exit(0)

    # Another undocumented special case: skip copy, trim only.
    if opts.trim_only:
        lib.util.note('Trim at %s' % time.ctime(), vl=2)
        treesync.trim()
        sys.exit(0)

    if opts.remove_dst:
        lib.util.note('Removing %s at %s' % (treesync.dstdir, time.ctime()))
        treesync.rm_dst(jobs=opts.jobs)

    # Loop until EOF is read from stdin. This can happen if the
    # parent closes stdin deliberately (normal case) or the parent
    # aborts. Either way, we're guaranteed to get a copy as the
    # parent is ending unless *this* process aborts or is killed.
    # This is what we call the "rough work" loop. Since copies
    # made here will be followed by a final "strict" copy they don't
    # have to be perfect. They just need to get most of the bits to
    # the right places as quickly and efficiently as possible.
    # Exceptions may be ignored, etc. These copies should not be
    # trusted until the final "finish work" copy is done.
    while opts.watch_stdin >= 0:
        if opts.watch_stdin > 0:
            # This will either time out or detect EOF on stdin.
            # If the latter, we're done.
            # Note: this may not work right on native Windows
            # but seems fine in a Cygwin python.
            sel = select.select([sys.stdin], [], [], opts.watch_stdin)
            if sel[0]:
                # If stdin is "ready", it will either have
                # at least 1 byte of data or EOF.
                if not sys.stdin.read(1):
                    break

            lib.util.note('Copy* at %s' % time.ctime(), vl=3)
            treesync.copy(fixabs=opts.fix_abs_symlinks, jobs=opts.jobs,
                          strict=False, trusting=True)
            lib.util.note('Done* at %s' % time.ctime(), vl=3)
        else:
            lib.util.note('Wait at %s' % time.ctime(), vl=3)
            sys.stdin.read()
            break

    final_start = time.time()
    lib.util.note('Copy at %s' % time.ctime(), vl=2)
    treesync.copy(fixabs=opts.fix_abs_symlinks, jobs=opts.jobs,
                  strict=True, trusting=opts.trusting)
    if treesync.success:
        lib.util.note('Done at %s' % time.ctime(), vl=2)
    else:
        lib.util.note('Fail at %s' % time.ctime(), vl=2)
        sys.exit(2)

    if opts.make_identical or opts.watch_stdin >= 0:
        lib.util.note('Trim at %s' % time.ctime(), vl=2)
        treesync.trim()

    final_elapsed = int(time.time() - final_start + 0.5)
    lib.util.note('%s took %s at %s' % (
        ('Final copy' if opts.watch_stdin > 0 else 'Copy'),
        datetime.timedelta(seconds=final_elapsed),
        time.ctime()
    ))

    if opts.remove_src:
        lib.util.note('Removing %s at %s' % (treesync.srcdir, time.ctime()))
        # There's no need for this removal to be synchronous so we
        # spin off a background process and return immediately.
        delpath = '%s.%d.DELETING' % (treesync.srcdir, os.getpid())
        try:
            os.rename(treesync.srcdir, delpath)
        except Exception:
            traceback.print_exc()
        else:
            subprocess.Popen(['rm', '-rf', delpath])

if __name__ == '__main__':
    main(sys.argv)

# vim: ts=8:sw=4:tw=80:et:
