#!/usr/bin/env python2.7

# The above way of finding python was chosen because I greatly prefer to
# avoid needing a shell wrapper. Also, PEP-394 specifies it:
# "In order to tolerate differences across platforms, all new code that
# needs to invoke the Python interpreter should not specify python,
# but rather should specify either python2 or python3 (or the more
# specific python2.x and python3.x versions)."
# As a corollary, the only way to invoke this script on platforms without
# Python2.7 is explicitly e.g. "python hnd ...". But eventually all
# platforms we care about should have 2.7 anyway.

"""
Broadcom WCC/WLAN unified internal tool framework.

The %(prog)s command has a set of subcommands; see SUBCOMMANDS above
for a list and use "%(prog)s help foo" on each for detailed usage.
You may also use "%(prog)s Help" for advanced usage. Note that options
found via capitalized "Help" are considered unsupported, may not be
well tested, and are subject to change without notice.

The "%(prog)s build" subcommand invokes the configured commands for a
given set of buildable items according to the specifications in GUB.yaml.
Here "build" is defined to mean the entire sequence of events from
populating a build tree from source control through mogrification,
compiling and linking deliverable files, copying and packaging them, etc.

The "scm" subcommand namespace operates as a front end to SCM tools like
svn and git. The "oly" subcommand namespace contains Olympic-specific
tooling.

The "summary" subcommand generates build summary messages.

The "svn2user" subcommand makes a subversion copy in your users area.

The "query" subcommand dumps data from GUB.yaml.

Most other subcommands are of use primarily to administrators. Some
are just placeholders. All subcommands can be configured via entries
in GUB.yaml.

All hnd/gub commands can be personalized via an rcfile structure under
~/.config/hnd/....  E.g. the file ~/.config/hnd/build may contain custom
flags for "hnd build" and ~/.config/hnd/scm/checkout would configure
"hnd scm checkout". Options are best placed one per line.

For extended documentation see:
http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/GUB

"""

from __future__ import print_function
from __future__ import unicode_literals

# Must be imported first to fix up sys.path etc.
# This takes care of compatibility with Python 2.6.
import preface  # pylint: disable=relative-import,unused-import

import argparse
import atexit
import bdb
import os
import sys

import hnd
#import hnd.oly.init
import hnd.scm.init
import hnd.scm.checkout

import lib.cfg
import lib.consts
import lib.lsf
import lib.init
import lib.old
import lib.opts
import lib.scm
import lib.times
import lib.util

SUBCMDS = {
    'build': {'aliases': None},
    'cleanup': {'aliases': None},
    'contents': {'aliases': None},
    'featuresizing': {'aliases': None},
    'fwcmp': {'aliases': None},
    'greplog': {'aliases': None},
    'make': {'aliases': None},
    'makejobs': {'aliases': None},
    'query': {'aliases': None},
    'rev2time': {'aliases': ('time2rev', 'rev2date', 'date2rev')},
    'sizing': {'aliases': None},
    'summary': {'aliases': None},
    'svn2user': {'aliases': None},
    'svn_ancestry': {'aliases': None},
    'validate': {'aliases': None},
}


class CustomArgParserError(Exception):

    """Exception for CustomArgParser class."""
    pass


class CustomArgParser(argparse.ArgumentParser):

    """Internal enhancements to native arg parser."""

    def error(self, message):
        raise CustomArgParserError(message)

    def convert_arg_line_to_args(self, arg_line):
        """Allow multiple flags per line in @file."""
        for arg in arg_line.split():
            if not arg.strip():
                continue
            yield arg

    def remove_subparsers(self):
        """Remove previously configured sub-parsers."""
        self._subparsers = None
        self._actions.pop()


def main():
    """Command-line interface to the hnd/gub toolset."""
    # Locally scoped convenience alias.
    argv = sys.argv

    if len(argv) < 2:
        # Sensible defaults for no arguments.
        if argv[0].endswith('hnd'):
            argv.append('list')
        else:
            argv.append('--help')
    else:
        # Accept -? for compatibility with other/pre-existing toolsets.
        for i in range(len(argv)):
            if argv[i] == '-?':
                argv[i] = '--help'
            elif argv[i] == '--':
                break

    # Since this program tends to resubmit itself on other systems via
    # LSF and ssh, and both of these may involve a change of cwd, it's
    # helpful to normalize references to "." automatically for commands
    # which may resubmit themselves.
    if set(argv) & set(('build', 'cleanup', 'summary')):
        pathflags = set(('-C', '-Y'))
        for i, arg in enumerate(argv):
            if lib.util.is_url(arg):
                pass
            elif i > 0 and argv[i - 1] in pathflags:
                argv[i] = os.path.abspath(arg)
            elif arg == '.' or arg.startswith('./'):
                argv[i] = os.path.abspath(arg)
            elif arg == '..' or arg.startswith('../'):
                argv[i] = os.path.abspath(arg)

    # Turn "hnd help foo" or "hnd man foo" into "hnd foo --help",
    # and handle advanced/unsupported features via --HELP.
    # Note that these versions use a pager whereas the flags do not.
    advanced = False
    if argv[1].lower() == 'help' or argv[1].lower() == 'man':
        lib.util.pager()
        if argv[1].lower() == 'man':
            argv[1] = ('help' if argv[1] == 'man' else 'HELP')
        advanced = argv[1] != 'help'
        helpflag = '--' + argv[1].lower()
        if len(argv) == 2:
            argv[1] = helpflag
        elif len(argv) == 3:
            argv = sys.argv = [argv[0], argv[2], helpflag]
        elif len(argv) == 4:
            argv = sys.argv = [argv[0], argv[2], argv[3], helpflag]
        # Backward compatibility hack for "hnd co".
        if 'co' in argv or 'checkout' in argv:
            argv.insert(1, 'scm')
    elif len(argv) > 2 and \
            (argv[2].lower() == 'help' or argv[2].lower() == 'man'):
        lib.util.pager()
        if argv[2].lower() == 'man':
            argv[2] = ('help' if argv[2] == 'man' else 'HELP')
        if argv[2] != 'help':
            advanced = True
        helpflag = '--' + argv[2].lower()
        if len(argv) == 4:
            argv = sys.argv = argv[0:2] + [argv[3], helpflag]
        elif len(argv) == 3:
            argv[2] = helpflag
    else:
        for i in (1, 2, 3):
            if len(argv) <= i:
                break
            if argv[i].startswith('-H') or argv[i].startswith('--H'):
                advanced = True
                argv[i] = argv[i].lower()
                break

    # Set up an arg parser for all subcommands. Arrange for
    # the docstring to be appended to the usage message.
    parser = CustomArgParser(
        epilog=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        fromfile_prefix_chars='@',
        prog=lib.consts.PROG)

    # Any options like '--xyz_' exist to force '--xyz' to be spelled out.
    # There may be cases where we'll need to do sys.argv.remove('--xyz')
    # later so must require the full flag to be used.
    parser.add_argument(
        '--as-of',
        help="use a copy of GUB from the specified date or revision")
    # Force the whole flag to be spelled out (see above).
    parser.add_argument('--as-of_', help=argparse.SUPPRESS)
    parser.add_argument(
        '-B', '--to-tree-base', action='store_true',
        help="cd to the base of the current checkout tree first")
    parser.add_argument(
        '-C', '--cdto',
        metavar='DIR',
        help="cd into DIR before doing anything"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-D', '--debug-mode', action='count',
        help="allow pdb debugging by not redirecting stdout"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '--login-env', action='store_true',
        help="reset environment to user's bash login settings"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-E', '--elapsed', action='store_true',
        help="print elapsed time of subcommand")
    parser.add_argument(
        '-F', '--lsf-foreground', action='count', default=0,
        help="use LSF synchronously with output to screen")
    parser.add_argument(
        '-G', '--lsf-hostgroup',
        help="pass the specified hostgroup or hostname to LSF"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '--lsf-priority', type=int, default=None,
        help="request a specific LSF priority (0-200)"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-L', '--localhost', action='count', default=0,
        help="suppress use of LSF and/or ssh; run on localhost")
    # Force the whole flag to be spelled out (see above).
    parser.add_argument('--makeflags_', help=argparse.SUPPRESS)
    parser.add_argument(
        '--metadir',
        help="alternate location for build metadata directory"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-N', '--dry-run', action='count',
        help="show what would be done without doing it"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-P', '--pager', action='store_true',
        help="run output through your pager ($PAGER)"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-Q', '--quiet', action='store_true',
        help="suppress unnecessary output")
    parser.add_argument(
        '--setenv', action='append', default=[],
        metavar='VAR=value',
        help="run with this setting in the environment"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-T', '--test-tree', action='store_true',
        help="set build basedir to '%s/TEST'" % lib.consts.STATE.base
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '--var', action='append', default=[],
        metavar='VAR=value',
        help="override a config-file variable assignment"
        if advanced else argparse.SUPPRESS)
    parser.add_argument(
        '-V', '--verbose', action='count', default=1,
        help="increment verbosity level (multiples allowed)")
    parser.add_argument(
        '-Y', '--config-file',
        help="override default config file"
        if advanced else argparse.SUPPRESS)

    # Create a "sub-parser".
    subparser = parser.add_subparsers(
        title='SUBCOMMANDS',
        help="use '%(prog)s help subcommand' for help"
    )

    setups, cmdnames = lib.init.setup(base='hnd', subcmds=SUBCMDS)
    try:
        exec setups
    except ImportError:
        # If something this command needs is missing we'll find
        # out soon enough. If it's an import needed by another
        # command we don't care.
        pass

    # Add all known sub-sub-commands to the sub-sub-parser.
    #cmdnames |= hnd.oly.init.add_subcmds('hnd.oly', subparser, advanced,
    #                                     hnd.oly.init.__doc__.strip())
    cmdnames |= hnd.scm.init.add_subcmds('hnd.scm', subparser, advanced,
                                         hnd.scm.init.__doc__.strip())

    # Special case for backward compatibility.
    for alias in (b'checkout', b'co'):
        hnd.scm.checkout.parse_cli(lib.consts.PROG, alias, subparser,
                                   advanced, hnd.scm.init.__doc__.strip())

    # Parse the command line. In order to converge the gub and hnd models
    # we have to treat unrecognized cmds differently. For gub it's a hard
    # error, for hnd we look for an "external" command via execvp().
    try:
        opts = parser.parse_args(argv[1:])
    except CustomArgParserError as e1:
        if lib.consts.PROG == 'gub':
            lib.util.die(str(e1), exc=False)

        # Hide a --help as we try to skim a few well-known options.
        if '--help' in argv:
            argv.insert(argv.index('--help'), '--')
        elif '-h' in argv:
            argv.insert(argv.index('-h'), '--')

        parser.remove_subparsers()
        opts, cmd = parser.parse_known_args(argv[1:])
        lib.opts.DEBUG_MODE = opts.debug_mode
        lib.opts.DRY_RUN = opts.dry_run
        if opts.metadir:
            lib.opts.METADIR = os.path.expanduser(opts.metadir)
        lib.opts.VERBOSITY = (0 if opts.quiet else opts.verbose)
        if opts.cdto:
            lib.util.chdir(opts.cdto, vl=2)
        if opts.pager:
            lib.util.pager()

        # Show elapsed wall-clock time on request.
        if opts.elapsed:
            atexit.register(lib.times.elapsed, lib.consts.INVOKE_TIME)

        if '--help' in cmd or '-h' in cmd:
            cmd.remove('--')

        hndfuncs = {
            'basedir': lib.old.basedir,
            'bd': lib.old.basedir,
            'contrib': lib.old.contributors,
            'contribs': lib.old.contributors,
            'contributors': lib.old.contributors,
            'cstyle': lib.old.cstyle,
            'ffind': lib.old.ffind,
            'gclient': lib.old.gclient,
            'help': lib.old.list_,
            'list': lib.old.list_,
            'opath': lib.old.opath,
            'privates': lib.old.privates,
            'svnjunk': lib.old.privates,
            'restore': lib.old.restore,
            'rgrep': lib.old.rgrep,
            'sparse2deps': lib.old.sparse2deps,
            'svn_shrink': lib.old.svn_shrink,
            'svn-shrink': lib.old.svn_shrink,
            'tob': lib.old.tob,
            'workspace': lib.old.workspace,
            'ws': lib.old.workspace,
        }

        if opts.to_tree_base:
            treebase = lib.scm.find_tree_base()
            if not treebase:
                lib.util.die('no SCM basedir found', exc=False)
            lib.opts.VERBOSITY += 1
        else:
            treebase = None

        hndfunc = hndfuncs.get(cmd[0] if cmd else 'list')
        if hndfunc:
            if treebase:
                lib.util.chdir(treebase)
            rc = hndfunc(cmd)
        elif cmd[0] in hnd.__dict__ or cmd[0] == 'co':
            # Don't try exec-ing something known to be a builtin.
            # We could only have reached here via an unknown flag.
            lib.util.die(str(e1), exc=False)
        else:
            # Special case - these common flag names could have
            # been stripped off.
            if '--verbose' in argv:
                cmd.insert(1, '--verbose')
            if opts.dry_run:
                cmd.insert(1, '--dry-run')
            lib.util.xtrace(cmd, cwd=treebase, vl=2)
            if treebase:
                os.chdir(treebase)
            lib.consts.STATE.reset()

            if opts.elapsed:
                rc = lib.util.execute(cmd, vl=-1)
            else:
                try:
                    os.execvp(cmd[0], cmd)
                except EnvironmentError as e2:
                    rc = 2
                    lib.util.error(str(e2), prog=cmd[0])

        sys.exit(rc)

    # Options in this namespace are 'global' and available to the
    # entire family of programs.
    lib.opts.DEBUG_MODE = opts.debug_mode
    lib.opts.DRY_RUN = opts.dry_run
    if opts.metadir:
        lib.opts.METADIR = os.path.expanduser(opts.metadir)
    lib.opts.VERBOSITY = (0 if opts.quiet else opts.verbose)

    if opts.pager:
        lib.util.pager()

    # Show elapsed wall-clock time on request.
    if opts.elapsed:
        atexit.register(lib.times.elapsed, lib.consts.INVOKE_TIME)

    if opts.cdto:
        lib.util.chdir(opts.cdto, vl=2)

    # We may need to run from an earlier version of ourself.
    # To do this we check out the older version into an NFS
    # directory, so it's available across LSF, and exec it.
    if opts.as_of:
        reftime = lib.times.timeref(opts.as_of)
        if os.path.isdir(lib.consts.NFS_TMPDIR):
            astmp = lib.util.tmpdir(prefix='as-of.', tmp=lib.consts.NFS_TMPDIR)
        else:
            astmp = lib.util.tmpdir(keep=lib.consts.SECONDS_PER_HOUR * 7,
                                    prefix='as-of.',
                                    tmp=os.path.expanduser('~'))
        os.chmod(astmp, 0o775)
        if opts.debug_mode:
            import shutil
            todir = os.path.join(astmp, os.path.basename(lib.consts.TOOLDIR))
            lib.util.xtrace('cp -a %s %s' % (lib.consts.TOOLDIR, todir))
            shutil.copytree(lib.consts.TOOLDIR, todir)
        else:
            gpath = 'groups/software/infrastructure/GUB'
            lib.scm.get([gpath], cwd=astmp, reftime=reftime, tag='', umask=0o2)
            lib.util.touch(astmp)
        parts = os.path.realpath(argv[0]).split('/GUB/', 1)
        nargv = lib.util.xargv(argv, rm2=set(['--as-of']))
        nargv[0] = '/'.join([astmp, 'GUB', parts[-1]])
        nargv.insert(0, sys.executable)
        lib.consts.STATE.reset()
        rc = lib.util.execute(nargv, execvp=True, vl=2)
        assert False

    # Initialize environment to login state + special exceptions if
    # requested or required (for instance when coming from cron).
    if lib.util.SET_LOGIN_ENV_EV in os.environ:
        del os.environ[lib.util.SET_LOGIN_ENV_EV]
        lib.util.set_login_env()

    # These are convenience variables which may be used in the crontab.
    # Cron exports them as a side effect but we don't really want them
    # exported, we just used them as regular variables. So strip them
    # from the environment if present.
    for name in ['CMD', 'LOG', 'DAILY']:
        ev = '_'.join([lib.consts.PROG.upper(), name])
        if ev in os.environ:
            del os.environ[ev]

    # Make sure the directory of the running program is on PATH.
    # Also export the same value in case someone else needs it.
    bindir = os.path.dirname(lib.util.realpath(__file__))
    lib.util.path_add([bindir], front=True)
    lib.util.export('GUB_DIR', bindir + '/', vl=4)

    # Some operations make more sense from the top of the working tree.
    if opts.to_tree_base:
        lib.scm.cd_to_tree_base()

    # Certain EV's are not useful here and can confuse things.
    for ev in ['_', 'TERMCAP', 'module']:
        if ev in os.environ:
            del os.environ[ev]

    # Export requested EVs.
    for setting in opts.setenv:
        name, val = setting.split('=', 1)
        lib.util.export(name, val, vl=2)

    # Set up variable overrides. These must be "sticky", i.e. they beat
    # any file settings. Stickiness is indicated with ".="
    overrides = set()
    for ov in opts.var + getattr(opts, 'var', []):
        overrides.add(ov.replace('=', '.=', 1))
    if opts.lsf_hostgroup:
        overrides.add('LSF_HOSTGROUP.=' + opts.lsf_hostgroup)

    # Adjust input svn URL and output path under /projects for special cases.
    if opts.test_tree:
        if 'to_users' not in opts or opts.to_users < 2:
            lib.consts.STATE.to_test_area()

    # Make sure builds don't land in the official tree if there's
    # anything nonstandard about them.
    if 'basedir' in opts and opts.basedir:
        if opts.basedir == '/dev/null':
            # Special case for CI work etc. This says to build
            # locally and not bother copying into NFS because we
            # only want to know if the build passes.
            lib.consts.STATE.base = None
            opts.basedir = None
        else:
            lib.consts.STATE.base = opts.basedir
    elif 'to_users' in opts and opts.to_users > 1:
        # Hack for dev/test - force non-std builds into std tree.
        opts.test_tree = False
        lib.consts.STATE.base = lib.consts.STATE.stdbase
    elif 'user_url' in opts and opts.user_url:
        lib.consts.STATE.to_user_area()
    elif (('as_me' in opts and opts.as_me) or
          ('copydir' in opts and opts.copydir) or
          ('diffs_from' in opts and opts.diffs_from) or
          ('makeflags' in opts and opts.makeflags) or
          ('patch' in opts and opts.patch) or
          (opts.localhost and opts.func == hnd.build.call) or
          ('to_users' in opts and opts.to_users)):
     	if not (lib.util.am_builder() and opts.test_tree):
     		pass
#  RJ: Allow FOR_USER option       	lib.consts.STATE.to_user_area()

    # Place an overridden URL in the env for consistent child access.
    if 'user_url' in opts and opts.user_url:
        if lib.util.is_url(opts.user_url):
            lib.consts.WL_REPO_ROOT = opts.user_url
        else:
            lib.consts.WL_REPO_ROOT += '/users/%s/%s' % (lib.consts.STATE.by,
                                                         opts.user_url)

        lib.util.export(lib.consts.WL_REPO_ROOT_EV,
                        lib.consts.WL_REPO_ROOT, vl=3)

    # Global handling for --mailto: ensure that opts.mailto is
    # a list of email addresses if present at all. Also, make
    # sure emails go to self automatically unless suppressed
    # with "None". I.e. you could send email to "joe" and
    # leave yourself out with "-m joe,none".
    if 'mailto' in opts:
        sendme = not lib.util.am_builder()
        addrs = []
        for addr in lib.util.tolist(opts.mailto, sep=','):
            if addr.lower() == 'none':
                sendme = False
            else:
                addrs.append(addr)
        if sendme and lib.consts.STATE.by not in addrs:
            addrs.append(lib.consts.STATE.by)
        opts.mailto = addrs

    # Prepare the config file and var overrides to be passed along.
    if opts.config_file:
        cfgfile = opts.config_file
        if lib.util.is_url(cfgfile):
            cfgtmp = lib.util.tmpdir(keep=lib.consts.SECONDS_PER_HOUR * 3,
                                     prefix='cfg.',
                                     tmp=os.path.expanduser('~'))
            os.chmod(cfgtmp, 0o775)
            cmd = lib.scm.svncmd('export', cfgfile)
            lib.util.execute(cmd, check=True, cwd=cfgtmp,
                             stdout=open(os.devnull, 'wb'), vl=2)
            cfgfile = os.path.join(cfgtmp, 'GUB.yaml')
    else:
        cfgfile = os.path.join(lib.consts.TOOLDIR, 'GUB.yaml')
    cfgproxy = lib.cfg.ConfigProxy(cfgfile=cfgfile, gvars=overrides)

    # Look for personal config settings for this command. This is done
    # by prepending the command file to the argv and reparsing it.
    path = os.path.join(os.path.expanduser('~/.config'),
                        opts.func.__module__.replace('.', os.sep))
    if os.path.isfile(path):
        tmp_argv = sys.argv[:]
        for i, arg in enumerate(tmp_argv):
            if arg in cmdnames:
                tmp_argv.insert(i + 1, '@' + path)
                opts = parser.parse_args(tmp_argv[1:])
                break

    try:
        opts.func(opts, cfgproxy)
    except lib.util.FatalError as e:
        sys.stderr.write('%s\n' % e)
        sys.exit(2)

if __name__ == '__main__':
    try:
        main()
    except IOError as e:
        # Workaround for an interpreter bug triggered by SIGPIPE.
        # See http://code.activestate.com/lists/python-tutor/88460/
        if 'Broken pipe' not in e.strerror:
            raise
    except (KeyboardInterrupt, bdb.BdbQuit):
        # There's no point in a traceback for a user-initiated interrupt.
        sys.exit(99)

# vim: ts=8:sw=4:tw=80:et:
