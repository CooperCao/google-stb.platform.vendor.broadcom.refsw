#!/usr/bin/env python
"""
Mogrify source code (remove code within specified ifdef blocks).

This script drives the mogrification process. The list of files to
consider may be provided via the command line or stdin. Directories
specified are traversed recursively for files. This raw file list is then
filtered through regular expressions to derive the final mogrify list.

%(prog)s is designed to be compatible with mogrify.pl and at least for
now it is just a wrapper over mogrify.pl. The -V flag will show what
the wrapper is doing.

By default, the mogrify list is broken into chunks of {chunks} files and
each chunk is processed in parallel by a separate instance of mogrify.pl.
Single-letter and --long-option flags are processed by %(prog)s while long
options preceded by a single "-" such as -quiet are passed to mogrify.pl.

    NOTE: The options below are needed and used ONLY by linux DHD builds.
    NOTE: DO NOT USE FOR ANY OTHER PURPOSE!
      -skip_copyright_open  : Skip replacing "open" copyright text
      -translate_open_to_dual_copyright  : What it says

Options may also be supplied space-separated in a file using
the @file syntax. This may be useful for a long list of -D
and -U flags.

EXAMPLES:

To mogrify ./src and ./components:

    %(prog)s --define AA BB --undefine XX YY -- src components

Which is equivalent to:

    %(prog)s -DAA -DBB -UXX -UYY -- src components

Request more output from the wrapper and less from mogrify.pl:

    %(prog)s -V -quiet -strip_bcmromfn -DAA -UXX -- src components

"""

from __future__ import print_function
from __future__ import unicode_literals

import Queue
import argparse
import atexit
import glob
import multiprocessing
import os
import re
import shutil
import subprocess
import sys
import tempfile
import threading

DEFAULT_CHUNKS = 20
DEFAULT_JOBS = multiprocessing.cpu_count() * 4
LOAD_LIMIT_EV = 'GUB_LOAD_LIMIT'
PROG = os.path.basename(sys.argv[0])

BCM = 'BCMINTERNAL'
BCM_RE = re.compile(BCM)
MCB = BCM[::-1]
MCB_RE = re.compile(MCB)


def warn(msg):
    """Print a warning in standard format."""
    sys.stderr.write('%s: Warning: %s\n' % (PROG, msg))


class ParallelJob(object):

    """
    Run parallel processes up to a specified number and load limit.

    Rather than reinvent the wheel we use gmake to manage parallel
    jobs while avoiding hammering the system. We start up gmake
    with -j and -l flags and feed it a trivial makefile on stdin
    which knows how to run the jobs. Make will work out how many
    to run at once.
    """

    def __init__(self, base=None, jobs=None, load=None, makejobs=None,
                 usemake=True, verbose=1):
        self.count = 0
        self.base = base
        self.usemake = usemake
        self.verbose = verbose
        self.xflag = ('set -x; ' if self.verbose == 1 else '')
        if self.usemake:
            cmd = ['make', '-s', '-f', '-']
            if makejobs:
                cmd += makejobs.split()
            else:
                cmd += (['-j', str(jobs)] if jobs else ['-j'])
                if not sys.platform.startswith('cyg'):
                    load = (load if load else multiprocessing.cpu_count())
                    cmd += ['-l', str(load)]
            if self.verbose > 1:
                sys.stderr.write('+ %s\n' % ' '.join(cmd))
            self.proc = subprocess.Popen(cmd, stdin=subprocess.PIPE)
            self.send('.PHONY: all')
            self.send('all:')
            self.recipes = []
        else:
            self.multi = []
            if jobs:
                warn('no support yet for job limits in this mode')
            if load:
                warn('no support yet for load limits in this mode')
            if makejobs:
                warn('no support yet for makejobs in this mode')

    def send(self, text):
        """Write some text to child stdin."""
        if self.verbose > 3:
            sys.stderr.write(text + '\n')
        self.proc.stdin.write(text + '\n')

    def add(self, op):
        """Add the specified operation to the list of things to do."""
        self.count += 1
        if self.usemake:
            tgt = 'job_%s' % self.count
            self.send('\n.PHONY: ' + tgt)
            self.send('all: ' + tgt)
            self.send(tgt + ':')
            recipe = (' '.join([self.base.strip(), op]) if self.base else op)
            self.send('\t@%s%s;' % (self.xflag, recipe))
            self.recipes.append(recipe)
        else:
            def func():
                """Actually execute the command."""
                if self.xflag:
                    sys.stderr.write('+ %s\n' % op)
                    sys.stderr.flush()
                subprocess.call(op, shell=True)
            job = multiprocessing.Process(target=func, args=())
            self.multi.append(job)

    def execute(self, ops=None):
        """Run the specified operations and wait for them."""
        if self.usemake:
            if ops:
                for op in ops:
                    self.add(op)
            self.proc.stdin.close()
            rc = self.proc.wait()
        else:
            for job in self.multi:
                job.start()
            rc = 0
            for job in self.multi:
                job.join()
                if job.exitcode:
                    rc = 2
        return rc


class Mogrifier(object):

    """Manage the mogrification of a directory tree."""

    def __init__(self, opts, defs=None, undefs=None):
        self.opts = opts
        self.defs = (defs if defs else set())
        self.undefs = (undefs if undefs else set())

    def mogrify(self, path):  # pylint: disable=no-self-use
        """Mogrify a given file."""
        with open(path, 'r+') as f:
            lines = f.readlines()
            for line in lines:
                line = re.sub(BCM_RE, MCB, line)
                line = re.sub(MCB_RE, BCM, line)
            f.seek(0)
            f.write(''.join(lines))

    def qmogrify(self, queue):
        """Pull a pathname off the queue and handle it."""
        while True:
            try:
                path = queue.get(False)
            except Queue.Empty:
                break
            else:
                self.mogrify(path)
                queue.task_done()


def quoted(stuff):
    """Quote the provided list or string against shell expansion."""
    q1 = "'"
    q2 = '"'

    listin = isinstance(stuff, list)
    items = (stuff if listin else [stuff])
    result = []

    for item in items:
        if isinstance(item, list):
            result.append(' '.join(quoted(item)))
            continue

        # In case we were passed an integral value.
        item = '%s' % item

        # This is a list of inert characters. Anything else gets quoted.
        # A tilde is inert except when leading.
        if item[0] != '~' and re.match(r'^[-+~\w/.%@,:{}=]+$', item):
            result.append(item)
        elif q1 in item:
            result.append(q2 + item + q2)
        else:
            # Cosmetic; quote assignments as foo='bar', not 'foo=bar'.
            match = re.match(r'^(\w+=)(.*)', item)
            if match:
                result.append(match.group(1) + q1 + match.group(2) + q1)
            else:
                result.append(q1 + item + q1)

    return result if listin else result[0]


# Currently only looks for GPL 'COPYING'; could be enhanced.
def is_oss(gdir):
    """Returns True iff this dir looks like open source code."""
    for copying in glob.glob(os.path.join(gdir, 'COPYING*')):
        with open(copying, 'r') as f:
            if 'GNU GENERAL PUBLIC LICENSE' in f.read():
                return True
    return False


def main(argv):
    """Entry point for standalone use."""
    class MogrifyArgParser(argparse.ArgumentParser):

        """Allow multiple flags per line in @file."""

        def __init__(self, *args, **kwargs):
            argparse.ArgumentParser.__init__(self, *args, **kwargs)

        def convert_arg_line_to_args(self, arg_line):
            for arg in arg_line.split():
                if not arg.strip():
                    continue
                yield arg

    parser = MogrifyArgParser(
        fromfile_prefix_chars='@',
        epilog=__doc__.strip().format(chunks=DEFAULT_CHUNKS),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-convert2ifdef',
        help="change #if defined to #ifdef for listed symbols")
    # No idea why we'd ever not want this. Forced on for compatibility.
    parser.add_argument(
        '--exclude-vcs', action='store_true', default=True,
        help=argparse.SUPPRESS)
    parser.add_argument(
        '--cdto',
        metavar='DIR',
        help="cd into DIR before doing anything")
    parser.add_argument(
        '-c', '--chunk-size', type=int, default=DEFAULT_CHUNKS,
        help="number of files per chunk (default=%(default)s)")
    parser.add_argument(
        '-N', '--dry-run', action='count',
        help="show what would be done without doing it")
    parser.add_argument(
        '-f', '--file-re',
        help="override the RE selecting file types to mogrify")
    parser.add_argument(
        '-F', '--file-re-extra',
        help="an RE selecting additional file types to mogrify")
    parser.add_argument(
        '-hide_trivial', const='-hide_trivial',
        action='append_const', dest='flags',
        help="hide trivial expressions, e.g. '#if 0 && MACRO'")
    parser.add_argument(
        '-j', '--jobs', type=int, default=0,
        help="number of parallel jobs to run (default=%s)" % DEFAULT_JOBS)
    parser.add_argument(
        '-L', '--list-files',
        help="save the list of mogrified files here")
    parser.add_argument(
        '-l', '--load-limit', type=float, default=0.0,
        help="spin off chunks in parallel until load avg reaches limit")
    parser.add_argument(
        '-M', '--mogrifier', default='mogrify.pl',
        help="path to the mogrify script (use PATH by default)")
    parser.add_argument(
        '-preserve_atime', const='-preserve_atime',
        action='append_const', dest='flags',
        help="put back the original access time of the file")
    parser.add_argument(
        '--prune-oss', action='store_true',
        help="skip dirs containing a GPL 'COPYING' file")
    parser.add_argument(
        '-p', '--prune-dir-re',
        help="RE matching directories to skip")
    parser.add_argument(
        '-P', '--prune-dir-re-extra',
        help="RE matching additional directories (beyond default) to skip")
    parser.add_argument(
        '--prune-file-re',
        help="RE matching individual files to skip")
    parser.add_argument(
        '-q', '--quiet', action='store_true',
        help="suppress unnecessary mogrifier verbosity")
    parser.add_argument(
        '--stdin', action='store_true',
        help="read list of files from stdin")
    parser.add_argument(
        '-t', '--tobase',
        help=argparse.SUPPRESS)
    parser.add_argument(
        '-break_links', const='-break_links',
        action='append_const', dest='flags',
        help="break hard links when writing output file")
    parser.add_argument(
        '-endings', default='n',
        help="write files with o|n (original|native) line endings")
    parser.add_argument(
        '-strip_comments', const='-strip_comments',
        action='append_const', dest='flags',
        help="strips comment blocks except for copyright block")
    parser.add_argument(
        '-strip_bcmromfn', const='-strip_bcmromfn',
        action='append_const', dest='flags',
        help="strips BCMROMFN(), BCMINITFN(), etc.")
    parser.add_argument(
        '-strip_wlmsgs',
        help="strips WL_<MSG>() blocks")
    parser.add_argument(
        '-skip_copyright_open', const='-skip_copyright_open',
        action='append_const', dest='flags',
        help="skip replacing 'open' copyright text")
    parser.add_argument(
        '-translate_open_to_dual_copyright',
        const='-translate_open_to_dual_copyright',
        action='append_const', dest='flags',
        help="what it says")
    parser.add_argument(
        '-D', '--define', nargs='+', action='append',
        help="a list of words (-D optional) to be treated as 'defined'")
    parser.add_argument(
        '-U', '--undefine', nargs='+', action='append',
        help="a list of words (-U optional) to be treated as 'undefined'")
    parser.add_argument(
        '-V', '--verbosity', action='count', default=0,
        help="increment verbosity level")
    parser.add_argument(
        '--version', action='store_true',
        help="print the mogrifier version number")
    parser.add_argument('files', nargs=argparse.REMAINDER)

    # Because the perl mogrify.pl has a hand-rolled arg parser they can
    # do things like "-convert2ifdef -CMACRO" easily, while argparse
    # would naturally see that as two options. This hacks around that.
    # An alternative might be to handle -C just like -D and -U.
    pargv = []
    for i, arg in enumerate(argv):
        if i > 0 and argv[i - 1] == '-convert2ifdef':
            pargv.append('=' + arg)
        else:
            pargv.append(arg)
    opts = parser.parse_args(pargv[1:])
    if opts.convert2ifdef:
        opts.convert2ifdef = opts.convert2ifdef[1:]

    if opts.cdto:
        os.chdir(opts.cdto)

    if opts.mogrifier.upper() == 'LATEST':
        tmpdir = tempfile.mkdtemp(prefix=PROG + '.', suffix='.tmp')
        atexit.register(shutil.rmtree, tmpdir)
        mg = 'http://svn.sj.broadcom.com/svn/wlansvn'
        mg += '/proj/trunk/src/tools/build/mogrify.pl'
        opts.mogrifier = os.path.join(tmpdir, 'mogrify.pl')
        cmd = ['svn', '--non-interactive', 'export', '-q', mg, opts.mogrifier]
        subprocess.check_call(cmd)

    if opts.version:
        os.execvp('/bin/sh', ['sh', '-c', opts.mogrifier + ' --version'])

    if opts.prune_dir_re:
        prune_dir_re = opts.prune_dir_re
    else:
        prune_dir_re = \
            r'''(?:
                /BCGSoft|
                /libusb|
                /router/(?:
                    alsa-utils|
                    bridge-1.x|
                    dnsmasq|
                    ffmpeg|
                    hotplug2|
                    iproute2-3.1.0|
                    iptables-1.4.12|
                    libid3tag|
                    libmad|
                    madplay|
                    salsa|
                    samba|
                    udev|
                    udhcpd
                )|
                /tools/boost|
                /tools/mfgc/vendor|
                /tools/misc/(?:
                    ce_ttcp|
                    ethtool-5|
                    gdb_remote|
                    iperf|
                    lzma_src|
                    netbsd|
                    udptools|
                    usbtrace|
                    xz
                )|
                components/opensource/(?:
                    dnsmasq|
                    netfilter|
                    yaffs2|
                    xz
                )|
                /[.][^/]+  # skip hidden dirs
                )$'''
        if opts.prune_dir_re_extra:
            prune_dir_re = '(?:%s|%s)' % (prune_dir_re,
                                          opts.prune_dir_re_extra)

    if opts.file_re:
        file_re = opts.file_re
    else:
        file_re = '(?:%s)$' % '|'.join([
            r'[^/]+\.(?:[chs]|cpp|inc|mk|sh|tcl|usf|h\.in)',
            r'[^/]*filelist.txt',
            r'[^/]*readme.*txt',
            r'sources[^/]*',
            r'[^/]*wl\.wlex',
            r'[^/]*ake(?:fi|ru)le.*',
            r'Makeconf',
            r'/config/wl(?:config|_).*',
        ])

    if opts.file_re_extra:
        file_re = '(?:%s|%s)' % (file_re, opts.file_re_extra)

    # Derive raw list of files
    if opts.files:
        raw_flist = opts.files
        if '--' in raw_flist:
            raw_flist.remove('--')
    elif opts.stdin:
        raw_flist = []
        for line in sys.stdin:
            raw_flist.append(line.strip())
    else:
        main([sys.argv[0], '-h'])

    # Expand directories, skipping pruned dirs.
    fileset = set()
    for fn in raw_flist:
        if os.path.isdir(fn):
            for parent, dnames, fnames in os.walk(fn):
                pruned = set()
                for d in dnames:
                    dpath = os.path.join(parent, d)
                    if opts.exclude_vcs and (d == '.svn' or d == '.git'):
                        if opts.verbosity:
                            sys.stderr.write('PRUNE VCS DIR: %s\n' % dpath)
                        pruned.add(d)
                    elif re.search(prune_dir_re, dpath, re.VERBOSE):
                        if opts.verbosity:
                            sys.stderr.write('PRUNE MATCHED DIR: %s\n' % dpath)
                        pruned.add(d)
                    elif opts.prune_oss and is_oss(dpath):
                        if 'src/router/linux/' not in dpath:
                            if opts.verbosity:
                                sys.stderr.write('PRUNE OSS DIR: %s\n' % dpath)
                            pruned.add(d)
                dnames[:] = sorted(list(set(dnames) - pruned))
                for fn in fnames:
                    path = os.path.join(parent, fn)
                    if not os.path.islink(path):
                        fileset.add(path)
        else:
            with open(fn, 'r') as f:  # raise exception on error
                fileset.add(fn)
                f.close()

    paths = []
    dirset = set()
    reflags = re.IGNORECASE | re.VERBOSE
    for fn in sorted(fileset):
        if fn in raw_flist or re.search(file_re, fn, reflags):
            if fn.endswith('mogrify.pl'):
                continue
            if opts.prune_file_re and re.search(opts.prune_file_re,
                                                fn, reflags):
                continue
            paths.append(fn)
            parent = os.path.dirname(fn)
            if parent:
                dirset.add(parent)

    # Optionally keep a record of mogrified files.
    if opts.list_files:
        ldir = os.path.dirname(opts.list_files)
        if ldir and not os.path.exists(ldir):
            os.mkdir(ldir)
        with open(opts.list_files, 'a') as f:
            for fn in paths:
                f.write(fn + '\n')

    if opts.dry_run:
        sys.exit(0)

    if not paths:
        print('no input files found')
        sys.exit(0)

    # Create the directory structure here to avoid mkdir races
    # in parallel mogrifications.
    if opts.tobase:
        if not os.path.exists(opts.tobase):
            os.mkdir(opts.tobase)
        for d in sorted(dirset):
            dpath = os.path.join(opts.tobase, d)
            if not os.path.exists(dpath):
                os.makedirs(dpath)

    defs = set()
    if opts.define:
        for dlist in opts.define:
            defs.update(dlist)
    undefs = set()
    if opts.undefine:
        for ulist in opts.undefine:
            undefs.update(ulist)

    if opts.mogrifier.upper() == 'INTERNAL':
        sys.stderr.write('MOGRIFYING %d FILES ...\n' % len(paths))
        mog = Mogrifier(opts, defs=defs, undefs=undefs)
        q = Queue.Queue()
        for path in paths:
            q.put(path)

        jobs = min(opts.jobs if opts.jobs else DEFAULT_JOBS, len(paths))
        for _ in range(jobs):
            t = threading.Thread(target=mog.qmogrify, args=(q,))
            t.start()
        q.join()
        sys.exit(0)

    mogcmd = opts.mogrifier
    if opts.quiet:
        mogcmd += ' -quiet'
    if opts.flags:
        mogcmd = '%s %s' % (mogcmd, ' '.join(opts.flags))
    if opts.convert2ifdef:
        mogcmd = '%s -convert2ifdef "%s"' % (mogcmd, opts.convert2ifdef)
    if opts.strip_wlmsgs:
        mogcmd = '%s -strip_wlmsgs "%s"' % (mogcmd, opts.strip_wlmsgs)
    if opts.endings:
        mogcmd = '%s -endings=%s' % (mogcmd, opts.endings)
    if opts.tobase:
        mogcmd = '%s -tobase %s' % (mogcmd, opts.tobase)
    for df in sorted(defs):
        mogcmd += ' -D' + df
    for undf in sorted(undefs):
        mogcmd += ' -U' + undf

    # Break the file set into chunks and fork a mogrifier for each.

    def chunker(l, n):
        """Break a list into chunks of specified size."""
        return [l[i:i + n] for i in range(0, len(l), n)]

    makejobs = os.environ.get('MAKEJOBS')
    if makejobs:
        load = None
    elif opts.load_limit:
        load = opts.load_limit
    else:
        load = float(os.environ.get(LOAD_LIMIT_EV, 0.0))

    jobs = ParallelJob(jobs=opts.jobs, load=load, makejobs=makejobs,
                       verbose=opts.verbosity)
    size = (opts.chunk_size if opts.chunk_size else len(paths))
    mogcmd += ' '
    for chunk in chunker(paths, size):
        jobs.add(mogcmd + ' '.join(quoted(chunk)))
    if jobs.execute():
        sys.exit(2)

if __name__ == '__main__':
    main(sys.argv)

# vim: ts=8:sw=4:tw=80:et:
