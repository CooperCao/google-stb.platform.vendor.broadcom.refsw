#!/usr/bin/env python2.7
"""
Start a shell process on a given LSF host.

If passed something that looks like a hostname %(prog)s will use lsrun to
start a shell there. If passed something that looks like an LSF job ID it
will query that ID to determine the hostname and then use lsrun as above.

EXAMPLES:

    %(prog)s sjc-wlan-evl26b
    %(prog)s 276277311

"""

from __future__ import print_function
from __future__ import unicode_literals

# Imported first to fix up sys.path etc.
import preface

import argparse
import os
import sys

import lib.opts
import lib.util


def main():
    """Entry point for standalone use."""

    parser = argparse.ArgumentParser(
        epilog=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-V', '--verbose', action='count', default=0,
        help="increment verbosity level")
    parser.add_argument(
        'where', help="hostname or LSF job ID")
    parser.add_argument(
        'cmd', nargs=argparse.REMAINDER)
    opts = parser.parse_args()

    lib.opts.VERBOSITY = opts.verbose

    try:
        cmd = ['bjobs', '-w', str(int(opts.where))]
    except ValueError:
        hostname = opts.where
    else:
        proc = lib.util.execute(cmd, stdout=lib.util.PIPE)
        out = proc.communicate()[0]
        if proc.returncode:
            sys.exit(2)
        hostname = out.splitlines()[-1].split()[5].split(':')[0]

    os.chdir(os.path.expanduser('~'))
    if not opts.cmd:
        opts.cmd = ['bash', '-il']
    cmd = ['lsrun', '-P', '-S', '-m', hostname, '--'] + opts.cmd
    lib.util.execute(cmd, check=True, execvp=True)
    sys.exit(2)

if '__main__' == __name__:
    if len(sys.argv) < 2:
        sys.argv.append('--help')
    main()

# vim: ts=8:sw=4:tw=80:et:
