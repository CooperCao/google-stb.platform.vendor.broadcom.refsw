/*
 * EFI-specific portion of
 * Broadcom 802.11abgn Networking Device Driver
 *
 * Copyright (C) 2017, Broadcom. All Rights Reserved.
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * <<Broadcom-WL-IPTag/Open:>>
 *
 * $Id: dhd_efi.c 552299 2015-12-03 00:56:24Z $
 */

#include <osl.h>
#include <epivers.h>
#include <typedefs.h>
#include <dngl_stats.h>
#include <dhd_dbg.h>
#include <dhd.h>
#include <pcie_core.h>
#include <dhd_bus.h>
#include <dhd_flowring.h>
#include <dhd_proto.h>
#include <dhd_efi.h>

#include <bcmutils.h>
#include <bcmendian.h>
#include <bcmdevs.h>
#include <pcicfg.h>
#include <bcmendian.h>
#include <bcmutils.h>
#include <bcmstdlib.h>
#include <bcmwpa.h>
#include <siutils.h>
#include <sbhndpio.h>
#include <sbhnddma.h>
#include <hnddma.h>
#include <hnd_pktq.h>
#include <dhd_pcie.h>
#include <brcmefi.h>
#ifdef SHOW_LOGTRACE
#include <dhd_debug.h>
#include <event_log.h>
#endif /* SHOW_LOGTRACE */

#ifdef IL_BIGENDIAN
#define htod32(i) (bcmswap32(i))
#define htod16(i) (bcmswap16(i))
#define dtoh32(i) (bcmswap32(i))
#define dtoh16(i) (bcmswap16(i))
#define htodchanspec(i) htod16(i)
#define dtohchanspec(i) dtoh16(i)
#else
#define htod32(i) (i)
#define htod16(i) (i)
#define dtoh32(i) (i)
#define dtoh16(i) (i)
#define htodchanspec(i) (i)
#define dtohchanspec(i) (i)
#endif /* IL_BIGENDINA */

/* TODO: In case of edk2.0 build some of the guids are
* already present in an autogenerated header 'Autogen.h'
* as part of the EDK2.0 toolchain. We may need to later
* determine how to auto generate this file for efi-dhd
* in order to avoid the below hack
*/
#ifdef APPLE_BUILD
extern EFI_GUID gBcmwlIoctlGuid;
extern EFI_GUID gBcmdhdIoctlGuid;
extern EFI_GUID gapple80211_protocolGuid;
#elif defined(EFI_WINBLD)
EFI_GUID gBcmwlIoctlGuid = BCMWL_IOCTL_GUID;
EFI_GUID gBcmdhdIoctlGuid = BCMDHD_IOCTL_GUID;
EFI_GUID gapple80211_protocolGuid = APPLE_80211_PROTOCOL_GUID;
#else /* i.e, EFI-EDK2 toolchain unix build */
extern EFI_GUID gBcmwlIoctlGuid;
EFI_GUID gBcmdhdIoctlGuid = BCMDHD_IOCTL_GUID;
EFI_GUID gapple80211_protocolGuid = APPLE_80211_PROTOCOL_GUID;
#endif /* APPLE_BUILD */

#if defined(APPLE_BUILD) || !defined(EFI_WINBLD)
extern EFI_GUID gApple80211IoctlScanGuid;
extern EFI_GUID gApple80211IoctlScanResultGuid;
extern EFI_GUID gApple80211IoctlJoinGuid;
extern EFI_GUID gApple80211IoctlStateGuid;
extern EFI_GUID gApple80211IoctlInfoGuid;
extern EFI_GUID gApple80211IoctlIBSSGuid;
#else
EFI_GUID gApple80211IoctlScanGuid = APPLE_80211_IOCTL_SCAN_GUID;
EFI_GUID gApple80211IoctlScanResultGuid = APPLE_80211_IOCTL_SCANRESULT_GUID;
EFI_GUID gApple80211IoctlJoinGuid = APPLE_80211_IOCTL_JOIN_GUID;
EFI_GUID gApple80211IoctlStateGuid = APPLE_80211_IOCTL_STATE_GUID;
EFI_GUID gApple80211IoctlInfoGuid = APPLE_80211_IOCTL_INFO_GUID;
EFI_GUID gApple80211IoctlIBSSGuid = APPLE_80211_IOCTL_IBSS_GUID;
EFI_GUID gAppleLinkStateProtocolGuid = APPLE_LINK_STATE_PROTOCOL_GUID;
#endif /* APPLE_BUILD || !EFI_WINBLD */

#ifndef EFI_WINBLD
EFI_GUID gEfiFileInfoGuid = EFI_FILE_INFO_ID;
EFI_GUID  gEfiSimpleFileSystemProtocolGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
#endif

#ifdef DHD_LOG_DUMP
struct dhd_log_dump_buf g_fwlog_ring_buf;
static void dhd_log_dump_init(dhd_pub_t *dhd);
static void dhd_log_dump_deinit(dhd_pub_t *dhd);
#endif /* DHD_LOG_DUMP */

#define BUF_MAX	256
#define PCI_VENDOR(vid) ((vid) & 0xFFFF)
#define PCI_DEVID(vid) ((vid) >> 16)

uint dhd_watchdog_ms = CUSTOM_DHD_WATCHDOG_MS;
#define	MAXMULTILIST	32	/* max # multicast addresses */

typedef struct {
	dll_t link;
	APPLE_80211_SCANRESULT	sr;
	uint8		*ie_data;	/* IE from probe in scan results */
	uint		ie_len;
} wl_80211_scanresults_t;

/* Mapping for reason code to Apple status APPLE80211_S_BAD_KEY */
static uint apple80211_bad_key_rc[] = {
	DOT11_RC_UNSPECIFIED,
	DOT11_RC_AUTH_INVAL,
	DOT11_RC_4WH_TIMEOUT,
	DOT11_RC_8021X_AUTH_FAIL,
	0
};

/* Mapping for reason code to Apple status APPLE80211_S_BAD_KEY */
static uint apple80211_bad_key_sc[] = {
	DOT11_SC_FAILURE,
	DOT11_SC_ASSOC_FAIL,
	DOT11_SC_AUTH_CHALLENGE_FAIL,
	0
};

typedef struct dhd_info {
	dhd_pub_t pub;

#ifdef BCMWLUNDI
	EFI_HANDLE ChildHandle;
	EFI_HANDLE UNDIHandle;
	EFI_PCI_IO_PROTOCOL *PciIoIntf;
	EFI_PCI_IO_PROTOCOL *ChildPciIoIntf;
	/* Only UNDI 3.1 interfaces implemented */
	EFI_DEVICE_PATH_PROTOCOL *UndiBaseDevPath;
	EFI_DEVICE_PATH_PROTOCOL *UndiDevPath;
	uint DevPathLen;
	EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL nii_31;
	void		*pxe_ptr; /* Pointer to allocated/unaligned memory */
	PXE_SW_UNDI	*pxe_31;  /* Pointer to aligned structure as required */
	UINT16		UndiState; /*  stopped, started or initialized */
	uint	nmcastcnt;
	uint nmulticast;
	IN EFI_DRIVER_BINDING_PROTOCOL *efi_bind_proto;
	IN EFI_HANDLE Controller;
	/* Store the callback for now but the driver uses EFI API directly
	 * as wl attach and wl up need to happen before UDNIStart will happen
	 * wl up needs Map/Unmap for DMA
	 */
	struct {
		DELAY_API Delay;
		VIRT2PHY_API Virt2Phys;
		BLOCK_API Block;
		MEMIO_API Mem_IO;
		MAP_API Map;
		UNMAP_API UnMap;
		SYNC_API Sync;
		UINT64 SAP;
	} undi_callback;
#endif /* BCMWLUNDI */

	uint32		ntxbuf;		/* number of tx buffers */
	uint32		nrxbuf;		/* number of rx buffers */
	/* General per-port stuff */
	volatile BOOLEAN	TxFlowControl;	/* Flowthrottle indication */
	volatile UINT16		callbacks;	/* # outstanding callback functions */

	CHAR16 fw_path[PATH_MAX];		/* path to firmware image */
	CHAR16 nv_path[PATH_MAX];		/* path to nvram file */

	/* SNP related */
	struct spktq q_tx_done; /* holds packets that have been transmitted */
	struct spktq q_rx_sendup; /* packets to be sent up to the stack */
	uint txpendcnt;

	/* apple 80211 stuff */
	APPLE_80211_PROTOCOL apple80211_proto;
	APPLE_LINK_STATE_PROTOCOL apple_link_state_proto;
#ifdef APPLE_BUILD
	APPLE_ADAPTER_INFORMATION_PROTOCOL apple_adapter_info_proto;
#endif
	enum apple80211_state apple_dot11_state;
	bool connected; /* indicates we are authenticated, associated and data port is open */

	EFI_LOCK proto_lock;
	EFI_EVENT exit_boot_service_event;

	/* scan results cache */
	dll_t scan_result_list;
	uint16 scan_result_count;
	uint8 scan_done;

#ifdef SHOW_LOGTRACE
	dhd_event_log_t event_data;
#endif /* SHOW_LOGTRACE */
	EFI_EVENT watchdog_timer;


}  dhd_info_t;

/* the dhd info context structure, initialized during dhd_attach in the driver start path */
static dhd_info_t g_dhd_info;

/*  Local function prototypes. */
/* -- Driver Binding Protocol Prototypes -- */
STATIC EFI_STATUS
EFIAPI
BCMDHD_DriverSupported(IN EFI_DRIVER_BINDING_PROTOCOL *This,
                      IN EFI_HANDLE Controller,
                      IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath);

STATIC EFI_STATUS
EFIAPI
BCMDHD_DriverStart(IN EFI_DRIVER_BINDING_PROTOCOL *This,
                  IN EFI_HANDLE Controller,
                  IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath);

STATIC EFI_STATUS
EFIAPI
BCMDHD_DriverStop(IN  EFI_DRIVER_BINDING_PROTOCOL *This,
                 IN  EFI_HANDLE Controller,
                 IN  UINTN NumberOfChildren,
                 IN  EFI_HANDLE *ChildHandleBuffer);

/* -- Component Name Protocol -- */
STATIC EFI_STATUS
EFIAPI
BCMDHD_ComponentNameGetDriverName(IN  EFI_COMPONENT_NAME_PROTOCOL  *This,
                                 IN  CHAR8 *Language,
                                 OUT CHAR16 **DriverName);

STATIC EFI_STATUS
EFIAPI
BCMDHD_ComponentNameGetControllerName(IN  EFI_COMPONENT_NAME_PROTOCOL  *This,
                                     IN  EFI_HANDLE ControllerHandle,
                                     IN  EFI_HANDLE ChildHandle OPTIONAL,
                                     IN  CHAR8 *Language,
                                     OUT CHAR16 **ControllerName);

/* APPLE_80211_PROTOCOL */
STATIC EFI_STATUS
EFIAPI
BCMDHD_80211Ioctl(IN VOID *This,
                 IN EFI_GUID *SelectorGuid,
                 IN VOID *InParams,
                 IN UINTN InSize,
                 OUT VOID *OutParams,
                 IN OUT UINT32 *OutSize);

/* APPLE_LINK_STATE_PROTOCOL */
STATIC
EFI_STATUS
BCMDHD_InfoIoctl(dhd_info_t *dhd, APPLE_80211_INFO *info, UINT32 *OutSize);

STATIC EFI_STATUS
EFIAPI
BCMDHD_GetLinkState(IN VOID *This);

#ifdef APPLE_BUILD
STATIC EFI_STATUS
EFIAPI
BCMDHD_GetAdaptorInformation(
			    IN APPLE_ADAPTER_INFORMATION_PROTOCOL *This,
			    IN EFI_GUID *InformationType,
			    OUT VOID **InformationBlock,
			    OUT UINTN *InformationBlockSize);
#endif /* APPLE_BUILD */

STATIC VOID
EFIAPI
BCMDHD_ExitBootService(EFI_EVENT event, VOID *context);

void wl_event_to_host_order(wl_event_msg_t * evt);

/* -- Loaded Image Protocol -- */
STATIC EFI_STATUS
EFIAPI
BCMDHD_ImageUnloadHandler(EFI_HANDLE ImageHandle);

EFI_COMPONENT_NAME_PROTOCOL BCMDHD_ComponentName =
{
	BCMDHD_ComponentNameGetDriverName,
	BCMDHD_ComponentNameGetControllerName,
	"eng"
};

STATIC EFI_UNICODE_STRING_TABLE BCMDHD_DriverNameTable[] =
{
	{ "eng", L"Broadcom 802.11 Dongle Host Driver"},
	{ NULL, NULL }
};

STATIC EFI_UNICODE_STRING_TABLE BCMDHD_ControllerNameTable[] =
{
	{ "eng", L"BCM XXXX Wireless Controller"},
	{ NULL, NULL }
};

STATIC EFI_DRIVER_BINDING_PROTOCOL BCMDHD_DriverBinding =
{
	BCMDHD_DriverSupported,
	BCMDHD_DriverStart,
	BCMDHD_DriverStop,
	EPI_VERSION_NUM,
	NULL,
	NULL
};

/* UNDI related functions and values */
#ifdef BCMWLUNDI
#define BCMDHD_UNDI_NOT_REQUIRED        0xffff
#define BCMDHD_UNDI_SIZE_VARY           0xfffe
#define BCMDHD_UNDI_AT_LEAST_STARTED     1
#define BCMDHD_UNDI_AT_LEAST_INITIALIZED 2
#define NII_GUID gEfiNetworkInterfaceIdentifierProtocolGuid_31
typedef struct UNDI_API_ENTRY
{
	UINT16 cpbsize;
	UINT16 dbsize;
	UINT16 opflags;
	UINT16 state;
	void (*handler_fn)();
	const char *name;
} UNDI_API_ENTRY, *pUNDI_API_ENTRY;

STATIC EFI_STATUS EFIAPI BCMDHD_UNDIAPIEntry_31(UINT64 cdb);
STATIC VOID BCMDHD_UNDIAPIEntry(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIGetState(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIStart(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIStop(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIGetInitInfo(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIGetConfigInfo(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIInitialize(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIReset(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIShutdown(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIInterruptCtrl(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIRxFilter(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIStationAddr(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIStatistics(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIIpToMac(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDINVData(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIGetStatus(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIFillHeader(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDITxPacket(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
STATIC VOID BCMDHD_UNDIRxPacket(PXE_CDB *cdb_ptr, struct dhd_info *dhd);
static int dhd_cur_etheraddr_set(dhd_info_t *dhd, uint8 *addr);

/* Dispatch table */
UNDI_API_ENTRY undi_api_table[PXE_OPCODE_LAST_VALID+1] =
{
	/* PXE_OPCODE_GET_STATE */
	{PXE_CPBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED, PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDIGetState, "BCMDHD_UNDIGetState"},

	/* PXE_OPCODE_START */
	{BCMDHD_UNDI_SIZE_VARY, PXE_DBSIZE_NOT_USED, PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDIStart, "BCMDHD_UNDIStart"},

	/* PXE_OPCODE_STOP */
	{PXE_CPBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED, PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_AT_LEAST_STARTED, BCMDHD_UNDIStop, "BCMDHD_UNDIStop"},

	/* PXE_OPCODE_GET_INIT_INFO */
	{PXE_CPBSIZE_NOT_USED, sizeof(PXE_DB_GET_INIT_INFO), PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_AT_LEAST_STARTED, BCMDHD_UNDIGetInitInfo, "BCMDHD_UNDIGetInitInfo"},

	/* PXE_OPCODE_GET_CONFIG_INFO */
	{PXE_CPBSIZE_NOT_USED, sizeof(PXE_DB_GET_CONFIG_INFO), PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_AT_LEAST_STARTED, BCMDHD_UNDIGetConfigInfo, "BCMDHD_UNDIGetConfigInfo"},

	/* PXE_OPCODE_INITIALIZE */
	{sizeof(PXE_CPB_INITIALIZE), sizeof(PXE_DB_INITIALIZE), BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_STARTED, BCMDHD_UNDIInitialize, "BCMDHD_UNDIInitialize"},

	/* PXE_OPCODE_RESET */
	{PXE_CPBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIReset, "BCMDHD_UNDIReset"},

	/* PXE_OPCODE_SHUTDOWN */
	{PXE_CPBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIShutdown, "BCMDHD_UNDIShutdown"},

	/* PXE_OPCODE_INTERRUPT_ENABLES */
	{PXE_CPBSIZE_NOT_USED, PXE_DBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIInterruptCtrl, "BCMDHD_UNDIInterruptCtrl"},

	/* PXE_OPCODE_RECEIVE_FILTERS */
	{BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIRxFilter, "BCMDHD_UNDIRxFilter"},

	/* PXE_OPCODE_STATION_ADDRESS */
	{BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIStationAddr, "BCMDHD_UNDIStationAddr"},

	/* PXE_OPCODE_STATISTICS  */
	{PXE_CPBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIStatistics, "BCMDHD_UNDIStatistics"},

	/* PXE_OPCODE_MCAST_IP_TO_MAC */
	{sizeof(PXE_CPB_MCAST_IP_TO_MAC), sizeof(PXE_DB_MCAST_IP_TO_MAC), BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIIpToMac, "BCMDHD_UNDIIpToMac"},

	/* PXE_OPCODE_NVDATA */
	{BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDINVData, "BCMDHD_UNDINVData"},

	/* PXE_OPCODE_GET_STATUS */
	{PXE_CPBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIGetStatus, "BCMDHD_UNDIGetStatus"},

	/* PXE_OPCODE_FILL_HEADER */
	{BCMDHD_UNDI_NOT_REQUIRED, PXE_DBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIFillHeader, "BCMDHD_UNDIFillHeader"},

	/* PXE_OPCODE_TRANSMIT */
	{BCMDHD_UNDI_NOT_REQUIRED, PXE_DBSIZE_NOT_USED, BCMDHD_UNDI_NOT_REQUIRED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDITxPacket, "BCMDHD_UNDITxPacket"},

	/* PXE_OPCODE_RECEIVE */
	{sizeof(PXE_CPB_RECEIVE), sizeof(PXE_DB_RECEIVE), PXE_OPFLAGS_NOT_USED,
	 BCMDHD_UNDI_AT_LEAST_INITIALIZED, BCMDHD_UNDIRxPacket, "BCMDHD_UNDIRxPacket"}
};

STATIC EFI_STATUS dhd_install_undi(struct dhd_info *dhd,
                                  EFI_DEVICE_PATH_PROTOCOL *UndiDevicePath,
                                  uint8 *addr);

STATIC EFI_STATUS BCMDHD_CreateMacDevPath(struct dhd_info *dhd,
                                         EFI_DEVICE_PATH_PROTOCOL **dev_p,
                                         EFI_DEVICE_PATH_PROTOCOL *basedev_p,
                                         uint8 *addr);
#endif /* BCMWLUNDI */

/* dhd and wl ioctl related functions */
static char ioctl_buf[WLC_IOCTL_MEDLEN];
static char bssinfo_buf[WLC_IOCTL_MAXLEN];
int wl_iovar(dhd_info_t *dhd, const char *name, void *params, size_t p_len, void *buf, size_t len,
                bool set);
int wl_ioctl(dhd_info_t *dhd, uint cmd, void *arg, size_t len, bool set);
extern int dhdpcie_init(void *controller, void *pcie_dev, struct spktq *q_q_tx_done,
		char *clmblob_path);
extern int dhdpcie_deinit(dhd_pub_t *bus);
int dhd_os_write_image(char *filename, uint8 *buf, uint32 size);

#ifdef SHOW_LOGTRACE
static void dhd_init_logstrs_array(osl_t *osh, dhd_event_log_t *temp);
static void dhd_init_static_strs_array(osl_t *osh, dhd_event_log_t *temp,
		char *str_file, char *map_file);
#endif /* SHOW_LOGTRACE */

#ifdef EFI_WINBLD
EFI_DRIVER_ENTRY_POINT(BCMDHD_InitializeDriver)

/* Release version of the driver cannot have any console prints */
#if defined(BCMDBG)
#define PRINT_BANNER(_s) Aprint _s
#else
#define PRINT_BANNER(_s)
#endif
#else /* EFI_WINBLD */
/* Release version of the driver cannot have any console prints */
#if defined(BCMDBG)
#define PRINT_BANNER(_s) AsciiPrint _s
#else
#define PRINT_BANNER(_s)
#endif
#endif /* EFI_WINBLD */

EFI_STATUS
EFIAPI
BCMDHD_InitializeDriver(IN EFI_HANDLE           ImageHandle,
                       IN EFI_SYSTEM_TABLE     *SystemTable)
{
	EFI_STATUS Status;
	EFI_LOADED_IMAGE_PROTOCOL *LoadedImageInterface;

#ifdef EFI_WINBLD
	EfiInitializeDriverLib(ImageHandle, SystemTable);
#endif
	PRINT_BANNER(("\n\rCopyright (c) 2015 Broadcom Corporation\n\r"));
	PRINT_BANNER(("Broadcom 802.11 Wireless EFI driver v%a\n\r",
	              EPI_VERSION_STR));

#ifdef BCMWLUNDI
	PRINT_BANNER(("Supports UNDI 3.1 Protocol\n\r\n\r"));
#endif

	DHD_ERROR(("%s: BRCM EFI dongle host driver entry..\n",  __FUNCTION__));

	/*
	 * Install Driver Binding Protocol on the the driver's binding
	 * handle.  And also initialize driver's library stuffs.
	 */
	if ((Status = EfiLibInstallAllDriverProtocols(ImageHandle,
	                                              SystemTable,
	                                              &BCMDHD_DriverBinding,
	                                              ImageHandle,
	                                              &BCMDHD_ComponentName,
	                                              NULL,
	                                              NULL)) != EFI_SUCCESS) {
		DHD_ERROR(("%s: Install Driver Binding failed!\n",
		          __FUNCTION__));
		EFI_ERRMSG(Status, "Install Driver Binding Failed");
		return Status;
	}

	/* Finally, install unload handler... */
	gBS->OpenProtocol(ImageHandle,
	                  &gEfiLoadedImageProtocolGuid,
	                  (VOID **)&LoadedImageInterface,
	                  NULL,
	                  NULL,
	                  EFI_OPEN_PROTOCOL_GET_PROTOCOL);

	LoadedImageInterface->Unload = BCMDHD_ImageUnloadHandler;

	DHD_ERROR(("%s: init success.\n", __FUNCTION__));

	return EFI_SUCCESS;
}

/* TODO: In case of edk2.0 build the entry point
* has already been declared as BCMWL_InitializeDriver
* in an autogenerated C file 'Autogen.c' as part of the EDK2.0
* toolchain. We may need to later on determine how to auto generate
* this file for efi-dhd in order to avoid the below hack
*/
#ifndef EFI_WINBLD
EFI_STATUS
EFIAPI
BCMWL_InitializeDriver(IN EFI_HANDLE ImageHandle,
		IN EFI_SYSTEM_TABLE *SystemTable)
{
	return BCMDHD_InitializeDriver(ImageHandle, SystemTable);
}
#endif /* EFI_WINBLD */

STATIC EFI_STATUS EFIAPI
BCMDHD_DriverSupported(IN EFI_DRIVER_BINDING_PROTOCOL *This,
                      IN EFI_HANDLE Controller,
                      IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath)
{
	EFI_STATUS Status;
	EFI_PCI_IO_PROTOCOL *PciIo;

	UINT32 VidDid = 0;

	/*
	 * Determine if Controller handle has Device Path Protocol
	 * installed on our driver binding handle.
	 */
	Status = gBS->OpenProtocol(Controller,
	                           &gEfiDevicePathProtocolGuid,
	                           NULL,
	                           This->DriverBindingHandle,
	                           Controller,
	                           EFI_OPEN_PROTOCOL_TEST_PROTOCOL);
	if (EFI_ERROR (Status))
		return Status;

	/*
	 * Determine if Controller handle has PCI IO Protocol
	 * installed on our driver binding handle. If present,
	 * it will return PCI IO Interface handler.
	 */
	Status = gBS->OpenProtocol(Controller,
	                           &gEfiPciIoProtocolGuid,
	                           (VOID **)&PciIo,
	                           This->DriverBindingHandle,
	                           Controller,
	                           EFI_OPEN_PROTOCOL_BY_DRIVER);
	if (EFI_ERROR (Status))
		return Status;

	/*  Read vendor id/device id */
	Status = PciIo->Pci.Read(PciIo,
	                         EfiPciIoWidthUint32,
	                         0,
	                         1,
	                         &VidDid);

	if (EFI_ERROR (Status))
		goto Done;

	if (dhdpcie_chipmatch ((UINT16)PCI_VENDOR(VidDid), (UINT16)PCI_DEVID(VidDid)) == 0) {
		DHD_ERROR(("%s: Found brcm pcie wlan chip; vendor id = %x; device id = %x \n",
				__FUNCTION__, PCI_VENDOR(VidDid), PCI_DEVID(VidDid)));
		Status = EFI_SUCCESS;
	} else {
		Status = EFI_UNSUPPORTED;
	}

Done:
	gBS->CloseProtocol(Controller,
	                   &gEfiPciIoProtocolGuid,
	                   This->DriverBindingHandle,
	                   Controller);

	gBS->CloseProtocol(Controller,
	                   &gEfiDevicePathProtocolGuid,
	                   This->DriverBindingHandle,
	                   Controller);

	return Status;
}

EFI_STATUS
EFIAPI
BCMDHD_DriverStart(IN EFI_DRIVER_BINDING_PROTOCOL *This,
                  IN EFI_HANDLE Controller,
                  IN EFI_DEVICE_PATH_PROTOCOL *RemainingDevicePath)
{
	EFI_STATUS Status = EFI_SUCCESS;
	EFI_DEVICE_PATH_PROTOCOL *DevicePath;
	EFI_PCI_IO_PROTOCOL *PciIoIntf;
	int err;
	uint8 addr[ETHER_ADDR_LEN];
	uint32 num_flowrings; /* includes H2D common rings */
	char eventmask[WL_EVENTING_MASK_LEN];
	char clmblob_path[PATH_MAX];
	EFI_FILE_HANDLE clm_file = NULL;
	uint8 *clm_blob = NULL;
	EFI_FILE_INFO *clm_file_info = NULL;
	uint32 clm_len = 0;
	UINTN clm_file_info_size = 0;

	/*
	 * Determine if Controller handle has PCI IO Protocol
	 * installed on our driver binding handle. If present,
	 * it will return PCI IO Interface handler.
	 */
	Status = gBS->OpenProtocol(Controller,
	                           &gEfiPciIoProtocolGuid,
	                           (VOID **)&PciIoIntf,
	                           This->DriverBindingHandle,
	                           Controller,
	                           EFI_OPEN_PROTOCOL_BY_DRIVER);

	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: No PciIo Protocol on handle!\n",
		          __FUNCTION__));
		EFI_ERRMSG(Status, "No PciIOProtocol on handle");
		return Status;
	}

	Status = gBS->OpenProtocol(Controller,
	                           &gEfiDevicePathProtocolGuid,
	                           (VOID **)&DevicePath,
	                           This->DriverBindingHandle,
	                           Controller,
	                           EFI_OPEN_PROTOCOL_BY_DRIVER);

	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: DevicePath open failed !\n", __FUNCTION__));
		EFI_ERRMSG(Status, "DevicePath open failed\r\n");
		goto Error;
	}

	memset(&g_dhd_info, 0, sizeof(g_dhd_info));
	g_dhd_info.PciIoIntf = PciIoIntf;

	/* Initialize the packet queues
	 *    q_tx_done: Holds the Tx complete buffers which have been transmitted by dongle
	 *    q_rx_sendup: Holds the Rx buffers to be given up to the stack
	 * Make these queues virtually unbounded!
	 */
	Status = spktqinit(&g_dhd_info.q_tx_done, PKTQ_LEN_MAX);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: txdone pkt queue init failed !\n", __FUNCTION__));
		goto Error;
	}
	Status = spktqinit(&g_dhd_info.q_rx_sendup, PKTQ_LEN_MAX);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: rx pkt queue init failed !\n", __FUNCTION__));
		goto Error;
	}

	g_dhd_info.txpendcnt = 0;
	g_dhd_info.ChildHandle = NULL;
#ifdef BCMWLUNDI
	g_dhd_info.UndiBaseDevPath = DevicePath;
	g_dhd_info.efi_bind_proto = This;
	g_dhd_info.Controller = Controller;
#endif

	memset(clmblob_path, 0, PATH_MAX);
	err = dhdpcie_init(Controller, PciIoIntf, &g_dhd_info.q_tx_done, clmblob_path);

	if (err == BCME_ERROR) {
		DHD_ERROR(("%s: dhdpcie_init failed !\n",
			__FUNCTION__));
		goto Error;
	} else if (err == BCME_OK) {

		if (dhd_bus_start(&g_dhd_info.pub) != BCME_OK) {
			DHD_ERROR(("%s: dhd_bus_start failed !\n", __FUNCTION__));
			goto Error_Pcie;
		}

		/* special requirement from olympic, download clm blob also */
		clm_file = (EFI_FILE_HANDLE)dhd_os_open_image(clmblob_path);
		if (!clm_file) {
			DHD_ERROR(("%s: CLM blob file not found !"
					" Falling back to default clm path \n",
					__FUNCTION__));
			clm_file = (EFI_FILE_HANDLE)dhd_os_open_image(CLM_PATH);
			if (!clm_file)
				DHD_ERROR(("%s: default CLM blob file not found ! \n",
					__FUNCTION__));
		}

		if (clm_file) {
			clm_file_info = MALLOCZ(g_dhd_info.pub.osh, sizeof(*clm_file_info)
							+ PATH_MAX);
			clm_file_info_size = sizeof(*clm_file_info) + PATH_MAX;
			Status = clm_file->GetInfo(clm_file, &gEfiFileInfoGuid,
					&clm_file_info_size, clm_file_info);
			if (!EFI_ERROR(Status)) {
				clm_len = (uint32)clm_file_info->FileSize;
				clm_blob = MALLOCZ(g_dhd_info.pub.osh, clm_len);
				if (clm_blob) {
					if (dhd_os_get_image_block(clm_blob, clm_len, clm_file)
							== clm_len) {
						if (dhd_download_clm_blob(&g_dhd_info.pub, clm_blob,
								clm_len) < 0)
							DHD_ERROR(("%s: error downloading clm ! \n",
									__FUNCTION__));
						else
							DHD_ERROR(("%s: clm download success. \n",
								__FUNCTION__));
					} else {
						DHD_ERROR(("%s: error reading clm blob file ! \n",
								__FUNCTION__));
					}
					MFREE(g_dhd_info.pub.osh, clm_blob, clm_len);
				} else {
					DHD_ERROR(("%s: could not alloc. clm blob memory ! \n",
							__FUNCTION__));
				}
			} else {
				DHD_ERROR(("%s: could not get clm blob file size !"
						" err = %d; reqd size = %u, act size = %u \n",
						__FUNCTION__, Status, clm_file_info_size,
						sizeof(EFI_FILE_INFO) + PATH_MAX));
			}
			dhd_os_close_image((void *)clm_file);
			if (clm_file_info) {
				MFREE(g_dhd_info.pub.osh, clm_file_info,
						sizeof(*clm_file_info) + PATH_MAX);
			}
		}

	}

	/* Install Apple80211 and AppleLinkState protocol */
	g_dhd_info.apple80211_proto.Ioctl = BCMDHD_80211Ioctl;
	g_dhd_info.apple80211_proto.mode = MALLOC(g_dhd_info.pub.osh, sizeof(APPLE_80211_MODE));
	if (g_dhd_info.apple80211_proto.mode == NULL) {
		DHD_ERROR(("%s: apple80211 proto allocation failed !\n", __FUNCTION__));
		goto Error_Pcie;
	}

	bcopy(addr, &g_dhd_info.apple80211_proto.mode->HwAddress, ETHER_ADDR_LEN);

	/* Add AppleLinkState and AdaptorInformationProto functions. */
	g_dhd_info.apple_link_state_proto.GetLinkState = BCMDHD_GetLinkState;
#ifdef APPLE_BUILD
	g_dhd_info.apple_adapter_info_proto.GetAdapterInformation = BCMDHD_GetAdaptorInformation;
#endif

	/* add 80211, AdaptorInformationProto and AppleLinkState to the handle */
	Status = gBS->InstallMultipleProtocolInterfaces(&g_dhd_info.ChildHandle,
	                                                &gapple80211_protocolGuid,
	                                                &(g_dhd_info.apple80211_proto),
	                                                &gAppleLinkStateProtocolGuid,
	                                                &(g_dhd_info.apple_link_state_proto),
#ifdef APPLE_BUILD
	                                                &gAppleAipProtocolGuid,
	                                                &(g_dhd_info.apple_adapter_info_proto),
#endif
	                                                NULL);

	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: Apple80211 and AppleLinkState Installation failed\n",
			__FUNCTION__));
		gBS->CloseProtocol(Controller,
			&gEfiPciIoProtocolGuid,
			This->DriverBindingHandle,
			g_dhd_info.ChildHandle);
		goto Error_Pcie;
	}
#ifdef EFI_WINBLD
	Status = gBS->CreateEvent(EFI_EVENT_SIGNAL_EXIT_BOOT_SERVICES,
	                          EFI_TPL_NOTIFY,
	                          BCMDHD_ExitBootService,
	                          (VOID *)&g_dhd_info,
	                          &g_dhd_info.exit_boot_service_event);
#else
	Status = gBS->CreateEventEx(EVT_NOTIFY_SIGNAL,
			TPL_NOTIFY,
			BCMDHD_ExitBootService,
			(VOID *)&g_dhd_info,
			&gEfiEventExitBootServicesGuid,
			&g_dhd_info.exit_boot_service_event);
#endif /* EFI_WINBLD */
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: Error creating exit boot service event !\n", __FUNCTION__));
		goto Error_Pcie;
	}

	/* initialize scan result list */
	dll_init(&g_dhd_info.scan_result_list);

	DHD_ERROR(("%s: start success. \n", __FUNCTION__));

	return EFI_SUCCESS;

Error_Pcie:
	dhdpcie_deinit(&g_dhd_info.pub);

Error:
	DHD_ERROR(("%s: start failed !\n", __FUNCTION__));

	gBS->CloseProtocol(Controller,
	                   &gEfiDevicePathProtocolGuid,
	                   This->DriverBindingHandle,
	                   Controller);

	gBS->CloseProtocol(Controller,
	                   &gEfiPciIoProtocolGuid,
	                   This->DriverBindingHandle,
	                   Controller);

	return Status;
}

STATIC EFI_STATUS
EFIAPI
BCMDHD_DriverStop(IN EFI_DRIVER_BINDING_PROTOCOL *This,
                 IN EFI_HANDLE Controller,
                 IN UINTN NumberOfChildren,
                 IN EFI_HANDLE *ChildHandleBuffer)
{
	EFI_STATUS Status;
	int err = 0;
	static int duplicate_entry = 0;

	if (duplicate_entry)
		return EFI_SUCCESS;

	DHD_ERROR(("%s: Unloading Broadcom Full Dongle Driver...\n", __FUNCTION__));
	duplicate_entry = 1;

	if (g_dhd_info.exit_boot_service_event != NULL)
		gBS->CloseEvent(g_dhd_info.exit_boot_service_event);

	if (g_dhd_info.apple80211_proto.mode) {
		MFREE(g_dhd_info.pub.osh, g_dhd_info.apple80211_proto.mode,
			sizeof(APPLE_80211_MODE));
	}

#ifdef BCMWLUNDI
	/* Check if we have been called already */
	if (g_dhd_info.UndiDevPath != NULL && g_dhd_info.pxe_ptr != NULL)
	{
		DEBUG((EFI_D_ERROR, "%s: NumberOfChildren = %d\n",
			__FUNCTION__, NumberOfChildren));

		/* Uninstall the protocol if already installed on the handle */
		Status = gBS->UninstallMultipleProtocolInterfaces(g_dhd_info.UNDIHandle,
				&NII_GUID,
				&g_dhd_info.nii_31,
				&gEfiDevicePathProtocolGuid,
				g_dhd_info.UndiDevPath,
				NULL);

		Status = gBS->CloseProtocol(Controller,
				&gEfiPciIoProtocolGuid,
				This->DriverBindingHandle,
				g_dhd_info.UNDIHandle);

		if (g_dhd_info.UndiDevPath)
			MFREE(g_dhd_info.pub.osh, g_dhd_info.UndiDevPath, g_dhd_info.DevPathLen);
		g_dhd_info.UndiDevPath = NULL;

		if (EFI_ERROR(Status))
			EFI_ERRMSG(Status, "Uninstall NII failed\r\n");

		ASSERT(g_dhd_info.UndiState == PXE_STATFLAGS_GET_STATE_STOPPED);

		if (g_dhd_info.pxe_ptr)
			MFREE(g_dhd_info.pub.osh, g_dhd_info.pxe_ptr, sizeof(PXE_SW_UNDI) + 0x10);

		g_dhd_info.pxe_ptr = NULL;
		g_dhd_info.pxe_31 = NULL;
	}
#endif /* BCMWLUNDI */

	Status = gBS->UninstallMultipleProtocolInterfaces(g_dhd_info.ChildHandle,
			&gapple80211_protocolGuid,
			&(g_dhd_info.apple80211_proto),
			&gAppleLinkStateProtocolGuid,
			&(g_dhd_info.apple_link_state_proto),
#ifdef APPLE_BUILD
			&gAppleAipProtocolGuid,
			&(g_dhd_info.apple_adapter_info_proto),
#endif
			NULL);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: uninstall of apple80211 proto and link state failed !\n",
			__FUNCTION__));
	}

	/* deinit pcie bus */
	err = dhdpcie_deinit(&g_dhd_info.pub);

	if (err != BCME_OK) {
		DHD_ERROR(("%s: dhdpcie_deinit error !\n", __FUNCTION__));
	}

	/* Close the bus driver */
	Status = gBS->CloseProtocol(Controller,
	                            &gEfiDevicePathProtocolGuid,
	                            This->DriverBindingHandle,
	                            Controller);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: CloseProtocol of DevicePath fails !\n", __FUNCTION__));
	}

	Status = gBS->CloseProtocol(Controller,
	                            &gEfiPciIoProtocolGuid,
	                            This->DriverBindingHandle,
	                            Controller);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: CloseProtocol of PciIo fails !\n", __FUNCTION__));
	}
	DHD_ERROR(("%s: DONE. \n", __FUNCTION__));

	return Status;
}

STATIC EFI_STATUS
EFIAPI
BCMDHD_ComponentNameGetDriverName(IN  EFI_COMPONENT_NAME_PROTOCOL *This,
                                            IN  CHAR8 *Language,
                                            OUT CHAR16 **DriverName)
{
	return EfiLibLookupUnicodeString(Language,
			BCMDHD_ComponentName.SupportedLanguages,
			BCMDHD_DriverNameTable,
			DriverName);
}

STATIC EFI_STATUS
EFIAPI
BCMDHD_ComponentNameGetControllerName(IN EFI_COMPONENT_NAME_PROTOCOL *This,
                                                IN EFI_HANDLE ControllerHandle,
                                                IN EFI_HANDLE ChildHandle OPTIONAL,
                                                IN  CHAR8 *Language,
                                                OUT CHAR16 **ControllerName)
{
	SPrint(BCMDHD_ControllerNameTable[0].UnicodeString,
			(EfiStrLen(BCMDHD_ControllerNameTable[0].UnicodeString)+1) * 2,
			L"BCM Wireless Controller");

	return EfiLibLookupUnicodeString(Language,
			BCMDHD_ComponentName.SupportedLanguages,
			BCMDHD_ControllerNameTable,
			ControllerName);
}

/*
 *
 * Routine Description:
 * Unload function that is registered in the LoadImage protocol.  It un-installs
 * protocols produced and deallocates pool used by the driver.  Called by the core
 * when unloading the driver.
 *   Arguments:
 *      EFI_HANDLE ImageHandle
 * Returns:
 *      Nothing
 */

STATIC EFI_STATUS
EFIAPI
BCMDHD_ImageUnloadHandler(EFI_HANDLE ImageHandle)
{
	EFI_STATUS  Status;
	EFI_HANDLE *DeviceHandleBuffer;
	UINTN DeviceHandleCount;
	UINTN Index;

	/* Get a list of all handles in the handle database */
	Status = gBS->LocateHandleBuffer(AllHandles,
	                                 NULL,
	                                 NULL,
	                                 &DeviceHandleCount,
	                                 &DeviceHandleBuffer);

	if (EFI_ERROR(Status))
		return Status;

	for (Index = 0; Index < DeviceHandleCount; Index++) {
		Status = gBS->DisconnectController(DeviceHandleBuffer[Index],
		                                   ImageHandle,
		                                   NULL);
	}

	if (DeviceHandleBuffer != NULL)
		gBS->FreePool(DeviceHandleBuffer);

	Status = gBS->UninstallMultipleProtocolInterfaces(ImageHandle,
	                                                  &gEfiDriverBindingProtocolGuid,
	                                                  &BCMDHD_DriverBinding,
	                                                  &gEfiComponentNameProtocolGuid,
	                                                  &BCMDHD_ComponentName,
	                                                  NULL);

	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: "
		          "Failed to uninstall protocol interfaces.\n", __FUNCTION__));
		EFI_ERRMSG(Status, "Uninstall protocol failed\n");
		return (Status);
	}

	return EFI_SUCCESS;
}

STATIC EFI_STATUS
EFIAPI
BCMDHD_GetLinkState(IN VOID *This)
{
	EFI_STATUS Status = EFI_NO_MEDIA;
	struct ether_addr bssid;
	int ret = 0;

	ret = wl_ioctl(&g_dhd_info, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, IOV_GET);
	if (ret == BCME_OK)
		Status = EFI_SUCCESS;

	return Status;
}


#ifdef APPLE_BUILD
STATIC EFI_STATUS
EFIAPI
BCMDHD_GetAdaptorInformation(
			    IN APPLE_ADAPTER_INFORMATION_PROTOCOL *This,
			    IN EFI_GUID *InformationType,
			    OUT VOID **InformationBlock,
			    OUT UINTN *InformationBlockSize)
{
	EFI_STATUS Status = EFI_SUCCESS;


	return Status;
}
#endif /* APPLE_BUILD */

STATIC VOID
EFIAPI
BCMDHD_ExitBootService(EFI_EVENT event, VOID *context)
{
	dhd_info_t *dhd = (dhd_info_t *)context;
	int is_up = 0;
	int ret = 0;

	if (dhd == NULL) {
		return;
	}

	ret = wl_ioctl(dhd, WLC_GET_UP, &is_up, sizeof(is_up), IOV_GET);
	if (ret != BCME_OK) {
		DHD_ERROR(("%s: wl get up fails ! err = %d ! \n", __FUNCTION__, ret));
		return;
	}

	if (is_up) {
		ret = wl_ioctl(&g_dhd_info, WLC_DOWN, NULL, 0, IOV_SET);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: wl up fails ! err = %d ! \n", __FUNCTION__, ret));
			return;
		}
	}

	/*
	* Complete all outstanding transactions to Controller.
	* Don't allow any new transaction to Controller to be started.
	*/
	dhd->PciIoIntf->Attributes(dhd->PciIoIntf,
			EfiPciIoAttributeOperationDisable,
			EFI_PCI_IO_ATTRIBUTE_MEMORY |
			EFI_PCI_IO_ATTRIBUTE_BUS_MASTER,
			NULL);

}

static bool wl_code2applebadkey_map(uint reason, uint* map)
{
	int i = 0;
	int max = sizeof(apple80211_bad_key_sc)/sizeof(apple80211_bad_key_sc[0]);

	while (map[i] && i < max) {
		if (reason == map[i])
			return TRUE;
		i++;
	}
	return FALSE;
}


static uint32
wl_cipher2appleadvcap(uint32 cipher)
{
	switch (cipher) {
	case WPA_CIPHER_NONE:
		return 0;
	case WPA_CIPHER_WEP_40:
	case WPA_CIPHER_WEP_104:
		return APPLE80211_AC_WEP;
	case WPA_CIPHER_TKIP:
		return APPLE80211_AC_TKIP;
	case WPA_CIPHER_AES_OCB:
	case WPA_CIPHER_AES_CCM:
		return APPLE80211_AC_AES;
	}
	return 0;
}

static uint32
wl_akm2appleadvcap(uint32 akm)
{
	if (akm == RSN_AKM_UNSPECIFIED)
		return APPLE80211_AC_Enterprise;
	else if (akm == RSN_AKM_PSK)
		return APPLE80211_AC_PSK;
	return 0;
}

static void
BCMDHD_ScanResultAdvcapUpd(uint8 *wpa_ie, uint8 is_rsn, UINT32 *advcap)
{
	uint8 *ptr = wpa_ie;
	int i = 0;
	uint16 ucast_ciphcnt;
	uint16 akm_cnt;

	if (!wpa_ie)
		return;

	if (is_rsn) {

		/* group cipher suite - final byte in the 4-byte oui is sufficient
		* to identify the type of cipher used
		*/
		*advcap |= wl_cipher2appleadvcap(ptr[7]);

		/* pairwise cipher suite count */
		ptr += 8;
	}
	else {
		/* wpa legacy ie - group cipher suite begins at an offset of 8
		* we need the final byte
		*/
		*advcap |= wl_cipher2appleadvcap(ptr[11]);

		/* pairwise cipher suite count */
		ptr += 12;
	}

	ucast_ciphcnt = *((uint16*)ptr);
	ptr += 2;
	/* pairwise cipher suite */
	for (i = 0; i < (int)ucast_ciphcnt; i++) {
		*advcap |= wl_cipher2appleadvcap(ptr[3]);
		ptr += 4;
	}

	/* akm suite */
	akm_cnt = *((uint16*)ptr);
	ptr += 2;
	for (i = 0; i < (int)akm_cnt; i++) {
		*advcap |= wl_akm2appleadvcap(ptr[3]);
		ptr += 4;
	}
}


STATIC EFI_STATUS
EFIAPI BCMDHD_ScanResultIoctl(dhd_info_t *dhd, APPLE_80211_SR_REQ *sr_req,
                      APPLE_80211_SCANRESULT *scanres_80211,
                      UINT32 *out_size)
{
	uint8 *ie = 0;
	wl_80211_scanresults_t *result = 0;
	int i = 0;
	dll_t *node = 0;
	uint8 id = 0;
	uint32 count = 0;

	if (!scanres_80211 || !out_size || !sr_req)
		return EFI_INVALID_PARAMETER;

	if (!dhd->scan_done)
		return EFI_NOT_READY;

	bzero(scanres_80211, sizeof(APPLE_80211_SCANRESULT));

	count = dhd->scan_result_count;
	if (sr_req->index >= count)
		scanres_80211->channel = 0;
	else {
		ie = sr_req->ie;
		node = dll_next_p(&dhd->scan_result_list);
		for (i = 0; i < (int)sr_req->index; i++) {
			node = dll_next_p(node);
		}
		result = (wl_80211_scanresults_t *)node;

		/* If length is non-zero, then locate the IE in the scan result */
		if (ie[1] != 0) {
			id = ie[0];
			if (bcm_parse_tlvs(result->ie_data, result->ie_len, id) == NULL) {
				*out_size = 0;
				return EFI_SUCCESS;
			}
		}
		bcopy(&result->sr, scanres_80211, sizeof(APPLE_80211_SCANRESULT));
	}

	*out_size = sizeof(APPLE_80211_SCANRESULT);

	return EFI_SUCCESS;
}

static void
BCMDHD_ScanFreeResults(dhd_info_t *dhd)
{
	dll_t *node, *next_node;
	wl_80211_scanresults_t *scanres = 0;

	node = dll_next_p(&dhd->scan_result_list);

	while (!dll_empty(&dhd->scan_result_list)) {
		scanres = (wl_80211_scanresults_t *)node;
		if (scanres->ie_data)
			MFREE(dhd->pub.osh, scanres->ie_data, scanres->ie_len);
		next_node = dll_next_p(node);
		dll_delete(node);
		MFREE(dhd->pub.osh, scanres, sizeof(wl_80211_scanresults_t));
		node = next_node;
	}

	dhd->scan_done = 0;
	dhd->scan_result_count = 0;
}

static void
BCMDHD_ScanAddResult(dhd_info_t *dhd, wl_bss_info_t *scan_results)
{
	wl_80211_scanresults_t *scanres_80211 = NULL;
	dll_t *node;
	wl_80211_scanresults_t *scanres = 0;
	int i = 0;
	uint8 *wpa_ie = 0;

	if (scan_results->RSSI == WLC_RSSI_INVALID)
		return;

	node = dll_next_p(&dhd->scan_result_list);
	while (node != &dhd->scan_result_list) {
		scanres = (wl_80211_scanresults_t *)node;
		if (memcmp(&scanres->sr.bssid, &scan_results->BSSID, ETHER_ADDR_LEN) == 0)
			return;
		node = dll_next_p(node);
	}

	scanres_80211 = MALLOCZ(dhd->pub.osh, sizeof(wl_80211_scanresults_t));
	if (!scanres_80211)
		return;

	scanres_80211->sr.channel = wf_chspec_ctlchan(scan_results->chanspec);
	scanres_80211->sr.noise = scan_results->phy_noise;
	scanres_80211->sr.rssi = scan_results->RSSI;
	scanres_80211->sr.cap = scan_results->capability;
	bcopy(&scan_results->BSSID, (char *)&scanres_80211->sr.bssid, ETHER_ADDR_LEN);
	scanres_80211->sr.ssid_len = (uint8)MIN((int)scan_results->SSID_len,
			APPLE80211_MAX_SSID_LEN);
	bcopy(scan_results->SSID, scanres_80211->sr.ssid, scanres_80211->sr.ssid_len);

	/* Is WPA/2 supported ? */
	if (scan_results->ie_length > 0) {
		wpa_ie = (uint8 *)bcm_find_wpaie((uint8 *)scan_results + scan_results->ie_offset,
				scan_results->ie_length);
		if (wpa_ie != NULL) {
			scanres_80211->sr.advCap |= APPLE80211_AC_WPA;
			BCMDHD_ScanResultAdvcapUpd(wpa_ie, FALSE, &scanres_80211->sr.advCap);
		}

		wpa_ie = (uint8 *)bcm_parse_tlvs((uint8 *)scan_results + scan_results->ie_offset,
				scan_results->ie_length, DOT11_MNG_RSN_ID);
		if (wpa_ie != NULL) {
			scanres_80211->sr.advCap |= APPLE80211_AC_WPA2;
			BCMDHD_ScanResultAdvcapUpd(wpa_ie, TRUE, &scanres_80211->sr.advCap);
		}
	}
	if (scan_results->capability & DOT11_CAP_PRIVACY) {
		/* If none of the WPA/2 encr are set and Privacy is set
		 * then it must be WEP
		 */
		if (scanres_80211->sr.advCap == 0)
			scanres_80211->sr.advCap |= APPLE80211_AC_WEP;
	}

	/* Save the IE as driver may need to filter this based on an IE passed when collecting
	 * the scan results
	 */
	if (scan_results->ie_length > 0) {
		scanres_80211->ie_len = scan_results->ie_length;
		scanres_80211->ie_data = MALLOC(dhd->pub.osh, scanres_80211->ie_len);
		if (scanres_80211->ie_data == NULL)
			scanres_80211->ie_len = 0;
		else
			bcopy((uint8 *)scan_results + scan_results->ie_offset,
					scanres_80211->ie_data, scanres_80211->ie_len);
	} else {
		scanres_80211->ie_len = 0;
		scanres_80211->ie_data = NULL;
	}

	dll_append(&dhd->scan_result_list, (dll_t *)scanres_80211);
	dhd->scan_result_count++;

}


STATIC EFI_STATUS
EFIAPI BCMDHD_ScanIoctl(dhd_info_t *dhd,
                APPLE_80211_SCANPARAMS *scanParams)
{
	int bcmerr = 0;
	wlc_ssid_t req_ssid;
	chanspec_t chanspec_list[MAXCHANNEL];
	int chanspec_count;
	int passive_time, active_time;
	int i;
	wl_escan_params_t escan_params;
	wl_scan_params_t *scan_params = &escan_params.params;
	static struct ether_addr any_bssid = {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}};

	/* if its a scan abort request */
	if (scanParams->NumChannels == -1) {
		dhd->apple_dot11_state = APPLE80211_S_IDLE;
		return EFI_SUCCESS;
	}

	/* Convert the channel list */
	for (i = 0; i < (int)scanParams->NumChannels && i < MAXCHANNEL; i++)
		chanspec_list[i] = CH20MHZ_CHSPEC(scanParams->Channels[i]);

	chanspec_count = i;

	/* convert the passive and active dwell times.
	 * 0 means default to EFI, so pass -1 which means default to escan
	 */
	passive_time = (scanParams->PassiveDwellTime == 0) ? -1 : scanParams->PassiveDwellTime;
	active_time = (scanParams->ActiveDwellTime == 0) ? -1 : scanParams->ActiveDwellTime;

	/* Prepare the ssid_t */
	bzero(&req_ssid, sizeof(req_ssid));
	req_ssid.SSID_len = MIN(DOT11_MAX_SSID_LEN, scanParams->SsidLen);
	bcopy(scanParams->Ssid, req_ssid.SSID, req_ssid.SSID_len);

	escan_params.version = ESCAN_REQ_VERSION;
	escan_params.action = WL_SCAN_ACTION_START;
	escan_params.sync_id = 4321;

	scan_params->ssid.SSID_len = req_ssid.SSID_len;
	memcpy(scan_params->ssid.SSID, req_ssid.SSID, req_ssid.SSID_len);
	memcpy(&scan_params->bssid, &any_bssid, sizeof(scan_params->bssid));
	scan_params->bss_type = DOT11_BSSTYPE_ANY;
	scan_params->scan_type = DOT11_SCANTYPE_ACTIVE;
	scan_params->nprobes = -1;
	scan_params->active_time = active_time;
	scan_params->passive_time = passive_time;
	scan_params->home_time = -1;
	scan_params->channel_num = chanspec_count;

	for (i = 0; i < chanspec_count; i++) {
		scan_params->channel_list[i] = chanspec_list[i];
	}

	BCMDHD_ScanFreeResults(dhd);

	bcmerr = wl_iovar(dhd, "escan", NULL, 0, &escan_params, sizeof(escan_params), IOV_SET);
	if (bcmerr != BCME_OK) {
		DHD_ERROR(("%s: error setting escan ! err = %d \n", __FUNCTION__, bcmerr));
	} else {
		dhd->apple_dot11_state = APPLE80211_S_SCAN;
	}

	return osl_error(bcmerr);
}

STATIC EFI_STATUS
wl_set_infra_mode(dhd_info_t *dhd, int mode)
{
	EFI_STATUS Status = EFI_SUCCESS;
	bool is_up;
	int infra;
	int err = 0;

	err = wl_iovar(dhd, "infra_configuration", NULL, 0, &infra, sizeof(infra), IOV_GET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar get 'infra_configuration' fails ! \n", __FUNCTION__));
		return EFI_DEVICE_ERROR;
	}

	/* No change, just return */
	if ((mode == DOT11_BSSTYPE_INFRASTRUCTURE && infra == WL_BSSTYPE_INFRA) ||
	    (mode == DOT11_BSSTYPE_INDEPENDENT && infra == WL_BSSTYPE_INDEP) ||
	    (mode == DOT11_BSSTYPE_ANY && infra == WL_BSSTYPE_ANY))
	    return Status;

	err = wl_ioctl(dhd, WLC_GET_UP, &is_up, sizeof(is_up), IOV_GET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: ioctl get 'up' fails ! \n", __FUNCTION__));
		return EFI_DEVICE_ERROR;
	}

	if (is_up) {
		err = wl_ioctl(dhd, WLC_DOWN, NULL, 0, IOV_SET);
		if (err != BCME_OK) {
			DHD_ERROR(("%s: ioctl 'down' fails ! \n", __FUNCTION__));
			return EFI_DEVICE_ERROR;
		}
	}

	/* infra_configuration DOES NOT match bss_type
	 * BSS_TYPE == 0 => infra == 1
	 * BSS_TYPE == 1 => infra == 0
	 * BSS_TYPE == 2 => infra == non-zero/one
	 */
	switch (mode) {
	case DOT11_BSSTYPE_INFRASTRUCTURE:
		infra = WL_BSSTYPE_INFRA;
		break;
	case DOT11_BSSTYPE_INDEPENDENT:
		infra = WL_BSSTYPE_INDEP;
		break;
	case DOT11_BSSTYPE_ANY:
		infra = WL_BSSTYPE_ANY;
		break;
	default:
		ASSERT(0);
	};

	err = wl_iovar(dhd, "infra_configuration", NULL, 0, &infra, sizeof(infra), IOV_SET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar set 'infra_configuration' fails ! \n", __FUNCTION__));
		return EFI_DEVICE_ERROR;
	}

	if (is_up) {
		err = wl_ioctl(dhd, WLC_UP, NULL, 0, IOV_SET);
		if (err != BCME_OK) {
		   DHD_ERROR(("%s: ioctl 'up' fails ! \n", __FUNCTION__));
		   return EFI_DEVICE_ERROR;
		}
	}

	return Status;
}


STATIC
EFI_STATUS BCMDHD_SetCipherKey(uint8 *keyData,	int keylen,
		int keyIdx, bool txKey, wl_wsec_key_t *key)
{
	if (keylen != 0)
		DHD_ERROR(("setCipherKey %s: len %d, idx %d\n",
				txKey ? "Tx" : "Rx", keylen, keyIdx));

	bzero(key, sizeof(wl_wsec_key_t));

	key->len = keylen;
	key->index = keyIdx;

	if (keylen == 5)
		key->algo = CRYPTO_ALGO_WEP1;
	else if (keylen == 13)
		key->algo = CRYPTO_ALGO_WEP128;
	else if (keylen != 0) {
		DHD_ERROR(("setCipherKey: bad keylen = %d\n", keylen));
		return EFI_INVALID_PARAMETER;
	}

	if (keylen && txKey)
		key->flags = WL_PRIMARY_KEY; /* this is also the tx key */

	if (keylen && keyData)
		bcopy(keyData, key->data, keylen);

	return EFI_SUCCESS;
}

STATIC EFI_STATUS
BCMDHD_JoinIoctl(dhd_info_t *dhd, APPLE_80211_JOINPARAMS *joinParams)
{
	APPLE_80211_KEY	*Key = &joinParams->Key;
	wl_wsec_key_t wlkey;
	wsec_pmk_t pmk;
	uint mode;
	wlc_ssid_t ssid;
	EFI_STATUS Status;
	EFI_TPL tpl;
	int macAuth = DOT11_OPEN_SYSTEM;
	int wpaAuth = WPA_AUTH_DISABLED;
	int wsec = 0;
	int err = 0;
	int i = 1;

	/* first, handle special case:  disassociate */
	if (joinParams->bssType == APPLE80211_BSSTYPE_NONE) {
		err = wl_ioctl(dhd, WLC_DISASSOC, NULL, 0, IOV_SET);
		if (err != BCME_OK)
			DHD_ERROR(("%s: error issuing disassoc ! \n", __FUNCTION__));
		return osl_error(err);
	}

	/* Set Auth type */
	switch (joinParams->LowerAuth) {
	case APPLE80211_AUTHTYPE_OPEN:
		macAuth = DOT11_OPEN_SYSTEM;
		break;

	case APPLE80211_AUTHTYPE_SHARED:
		macAuth = DOT11_SHARED_KEY;
		break;

	case APPLE80211_AUTHTYPE_CISCO:
		macAuth = 0x80;
		break;

	default:
		return EFI_INVALID_PARAMETER;
	}

	switch (joinParams->UpperAuth) {
	case APPLE80211_AUTHTYPE_NONE:
		break;
	case APPLE80211_AUTHTYPE_WPA_PSK:
		wpaAuth = WPA_AUTH_PSK;
		break;
	case APPLE80211_AUTHTYPE_WPA: /* Only WPA-PSK/WPA2-PSK */
		ASSERT(0);
		wpaAuth = WPA_AUTH_UNSPECIFIED;
		break;
	case APPLE80211_AUTHTYPE_WPA2_PSK:
		wpaAuth = WPA2_AUTH_PSK;
		break;
	case APPLE80211_AUTHTYPE_WPA2:
		ASSERT(0);
		wpaAuth = WPA2_AUTH_UNSPECIFIED;
		break;
	case APPLE80211_AUTHTYPE_LEAP:
		ASSERT(0);
		macAuth = 0x80;
		break;
	case APPLE80211_AUTHTYPE_8021X:
	case APPLE80211_AUTHTYPE_WPS:
		break;
	default:
		return EFI_INVALID_PARAMETER;
	}

	/* Set Cipher key */
	Status = EFI_SUCCESS;
	switch (Key->CipherType) {
	case APPLE80211_CIPHER_NONE:
		break;

	case APPLE80211_CIPHER_WEP_40:
	case APPLE80211_CIPHER_WEP_104:
		if (Key->KeyLen != 5 && Key->KeyLen != 13) {
			DHD_ERROR(("%s: setCIPHER_KEY: cipher type WEP (%u) "
				  "but len (%u) was not 5 or 13 \n", __FUNCTION__,
				  Key->CipherType, Key->KeyLen));
			return EFI_INVALID_PARAMETER;
		}

		wsec = WEP_ENABLED;

		Status = BCMDHD_SetCipherKey(Key->Key,
				(int)Key->KeyLen,
				(int)Key->KeyIndex,
				TRUE,
				&wlkey);
		break;

	case APPLE80211_CIPHER_TKIP: /* WPA EAP is not supported */
	case APPLE80211_CIPHER_AES_CCM:
		if (strlen(Key->Password) == 0 && Key->Key != NULL && Key->KeyLen == PMK_LEN) {
			/* using raw key material */
			pmk.key_len = Key->KeyLen;
			memcpy(pmk.key, Key->Key, Key->KeyLen);
			pmk.flags &= ~WSEC_PASSPHRASE;
		} else {
			/* using preshared key which must be hashed */
			if ((strlen(Key->Password) < WSEC_MIN_PSK_LEN) ||
			    (strlen(Key->Password) > WSEC_MAX_PSK_LEN))
			{
				return EFI_INVALID_PARAMETER;
			}
			pmk.key_len = strlen(Key->Password);
			pmk.flags |= WSEC_PASSPHRASE;
			strncpy(pmk.key, Key->Password, pmk.key_len);
		}
		wsec = (Key->CipherType == APPLE80211_CIPHER_TKIP) ? TKIP_ENABLED : AES_ENABLED;
		break;
	case APPLE80211_CIPHER_PMK:
		break;

	default:
		DHD_ERROR(("%s: unknown cipher type %d", __FUNCTION__,
				Key->CipherType));
		return EFI_INVALID_PARAMETER;
	}

	if (EFI_ERROR(Status))
		return Status;

	switch (joinParams->bssType) {
	case APPLE80211_BSSTYPE_IBSS:
		mode = DOT11_BSSTYPE_INDEPENDENT;
		break;
	case APPLE80211_BSSTYPE_INFRA:
		mode = DOT11_BSSTYPE_INFRASTRUCTURE;
		break;
	case APPLE80211_BSSTYPE_ANY:
		mode = DOT11_BSSTYPE_ANY;
		break;
	default:
		DHD_ERROR(("%s: unknown bss type %d", __FUNCTION__,
				joinParams->bssType));
		return EFI_INVALID_PARAMETER;
	}

	/* Set SSID */
	ssid.SSID_len = joinParams->SsidLen;
	bcopy(joinParams->Ssid, ssid.SSID, MIN(ssid.SSID_len, sizeof(ssid.SSID)));

	/* Reset the state to idle */
	dhd->connected = FALSE;
	dhd->apple_dot11_state = APPLE80211_S_IDLE;

	/* Reset the infrastructure mode to Any, as we can join any infra */
	Status = wl_set_infra_mode(dhd, DOT11_BSSTYPE_ANY);
	if (EFI_ERROR(Status))
		return Status;

	/* Don't create IBSS if it does not exist */
	i = 1;
	err = wl_iovar(dhd, "IBSS_join_only", NULL, 0, &i, sizeof(i), TRUE);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar set 'IBSS_join_only' fails ! \n", __FUNCTION__));
		return EFI_DEVICE_ERROR;
	}

	/* set mac-layer auth */
	wl_ioctl(dhd, WLC_SET_AUTH, &macAuth, sizeof(macAuth), IOV_SET);

	/* set upper-layer auth */
	wl_ioctl(dhd, WLC_SET_WPA_AUTH, &wpaAuth, sizeof(wpaAuth), IOV_SET);

	/* set in-driver supplicant */
	if (wpaAuth != WPA_AUTH_DISABLED) {
		i = wpaAuth & (WPA_AUTH_PSK | WPA2_AUTH_PSK);
		wl_iovar(dhd, "sup_wpa", NULL, 0, &i, sizeof(i), IOV_SET);
	}

	/* Clear the current keys */
	//wlc_keymgmt_reset(wl->wlc->keymgmt, wl->wlc->cfg, NULL); --- ??? TODO ???
	i = 0;
	wl_iovar(dhd, "wsec", NULL, 0, &i, sizeof(i), IOV_SET);

	/* set wsec */
	wl_iovar(dhd, "wsec", NULL, 0, &wsec, sizeof(wsec), IOV_SET);

	/* set the key if wsec */
	if (wsec == WEP_ENABLED)
		wl_ioctl(dhd, WLC_SET_KEY, &wlkey, sizeof(wlkey), IOV_SET);
	else if (wsec != 0)
		wl_ioctl(dhd, WLC_SET_WSEC_PMK, &pmk, sizeof(pmk), IOV_SET);

	err = wl_ioctl(dhd, WLC_SET_SSID, &ssid, sizeof(ssid), IOV_SET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: ioctl set 'SSID' fails ! \n", __FUNCTION__));
	}

	return osl_error(err);
}

STATIC EFI_STATUS
BCMDHD_InfoIoctl(dhd_info_t *dhd, APPLE_80211_INFO *info, UINT32 *OutSize)
{
	wl_bss_info_t *bss_info;
	EFI_TPL tpl;
	struct ether_addr bssid;
	int err = 0;


	memset(bssinfo_buf, 0, WLC_IOCTL_MAXLEN);
	*OutSize = sizeof(APPLE_80211_INFO);
	bzero(info, sizeof(APPLE_80211_INFO));
	info->Channel = 0;

	err = wl_ioctl(dhd, WLC_GET_BSSID, &bssid, ETHER_ADDR_LEN, IOV_GET);
	if (err != BCME_OK)
		return EFI_SUCCESS;

	*(uint32*)bssinfo_buf = htod32(WLC_IOCTL_MAXLEN);
	err = wl_ioctl(dhd, WLC_GET_BSS_INFO, bssinfo_buf, WLC_IOCTL_MAXLEN, IOV_GET);
	if (err != BCME_OK)
		return EFI_SUCCESS;
	bss_info = (wl_bss_info_t *)(bssinfo_buf + 4);

	err = wl_ioctl(dhd, WLC_GET_PHY_NOISE, &bss_info->phy_noise,
			sizeof(bss_info->phy_noise), IOV_GET);
	if (err != BCME_OK) {
		return EFI_SUCCESS;
	}

	info->Channel = wf_chspec_ctlchan(bss_info->chanspec);
	info->SsidLen = bss_info->SSID_len;
	bcopy(bss_info->SSID, info->Ssid, bss_info->SSID_len);
	bcopy(&bss_info->BSSID, &info->bssid, ETHER_ADDR_LEN);
	info->Noise = bss_info->phy_noise;
	info->RSSI = bss_info->RSSI;

	return EFI_SUCCESS;
}

STATIC EFI_STATUS
BCMDHD_IBSSIoctl(dhd_info_t *dhd, APPLE_80211_IBSSPARAMS *ibssParams)
{
	wlc_ssid_t ssid;
	EFI_STATUS Status;
	int macAuth = DOT11_OPEN_SYSTEM;
	int wpaAuth = WPA_AUTH_DISABLED;
	int wsec = 0;
	wl_wsec_key_t wlkey;
	int i, err;

	/* A WEP Key is provided */
	if (ibssParams->keyLen != 0) {
		if (ibssParams->keyLen != 5 && ibssParams->keyLen != 13) {
			DHD_ERROR(("%s: WEP Key, "
				  "but len(%u) was not 5 or 13\n", __FUNCTION__,
				  ibssParams->keyLen));
			return EFI_INVALID_PARAMETER;
		}

		wsec = WEP_ENABLED;

		Status = BCMDHD_SetCipherKey(ibssParams->key,
		                            (int)ibssParams->keyLen,
		                            (int)0,
		                            TRUE,
		                            &wlkey);
		if (EFI_ERROR(Status))
			return Status;
	}

	/* Set SSID */
	ssid.SSID_len = ibssParams->ssidLen;
	bcopy(ibssParams->ssid, ssid.SSID, MIN(ssid.SSID_len, sizeof(ssid.SSID)));


	/* Reset the state */
	dhd->apple_dot11_state = APPLE80211_S_IDLE;
	dhd->connected = FALSE;

	/* Clear the mode and joining restrictions */
	wl_set_infra_mode(dhd, DOT11_BSSTYPE_INDEPENDENT);

	i = 0;
	wl_iovar(dhd, "IBSS_join_only", NULL, 0, &i, sizeof(i), IOV_SET);

	/* set mac-layer auth */
	wl_ioctl(dhd, WLC_SET_AUTH, &macAuth, sizeof(macAuth), IOV_SET);

	/* set upper-layer auth */
	wl_ioctl(dhd, WLC_SET_WPA_AUTH, &wpaAuth, sizeof(wpaAuth), IOV_SET);

	/* Clear the current keys */
	//wlc_keymgmt_reset(wl->wlc->keymgmt, wl->wlc->cfg, NULL);
	i = 0;
	wl_iovar(dhd, "wsec", NULL, 0, &i, sizeof(i), IOV_SET);

	/* set wsec */
	wl_iovar(dhd, "wsec", NULL, 0, &wsec, sizeof(wsec), IOV_SET);

	/* set the key if wsec */
	if (wsec == WEP_ENABLED)
		wl_ioctl(dhd, WLC_SET_KEY, &wlkey, sizeof(wlkey), IOV_SET);

	wl_ioctl(dhd, WLC_SET_CHANNEL, &ibssParams->channel,
			sizeof(ibssParams->channel), IOV_SET);

	err = wl_ioctl(dhd, WLC_SET_SSID, &ssid, sizeof(ssid), IOV_SET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: ioctl set 'SSID' fails ! \n", __FUNCTION__));
	}

	return osl_error(err);
}

STATIC EFI_STATUS
EFIAPI BCMDHD_80211Ioctl(IN void *this,
                 IN EFI_GUID *SelectorGuid,
                 IN VOID *InParams,
                 IN UINTN InSize,
                 OUT VOID *OutParams,
                 IN OUT UINT32 *OutSize)
{
	EFI_STATUS Status;
	int cmd = 0;
	int val = 0;
	bool set = FALSE;
	int err = 0;
	int buflen = 0;
	APPLE_80211_SR_REQ *SrReq = NULL;
	UINT32 *state = NULL;
	struct ether_addr bssid;
	dhd_ioctl_t *ioc = NULL;

	DHD_INFO(("%s: ENTER; InParams = %p; InSize = %u; OutParams = %p;"
			" OutSize = %u; SelectorGuid->Data4[4..7] = %x %x %x %x ;\n",
			__FUNCTION__, InParams, InSize, OutParams, OutSize,
			SelectorGuid->Data4[4], SelectorGuid->Data4[5], SelectorGuid->Data4[6],
			SelectorGuid->Data4[7]));

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlScanGuid, sizeof(EFI_GUID)) == 0) {
		if (InSize != sizeof(APPLE_80211_SCANPARAMS) ||
			InParams == NULL) {
			DHD_ERROR(("%s: invalid params !\n", __FUNCTION__));
			return EFI_INVALID_PARAMETER;
		}
		Status = BCMDHD_ScanIoctl(&g_dhd_info, (APPLE_80211_SCANPARAMS *)InParams);
		if (EFI_ERROR(Status)) {
			DHD_ERROR(("BCMWL_80211Ioctl SCAN failed\n"));
		}
		return Status;
	}

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlScanResultGuid,
			sizeof(EFI_GUID)) == 0) {
		SrReq = ((APPLE_80211_SR_REQ *)InParams);
		if (InParams == NULL ||
			InSize < sizeof(APPLE_80211_SR_REQ) ||
			OutParams == NULL) {
			return EFI_INVALID_PARAMETER;
		}
		Status = BCMDHD_ScanResultIoctl(&g_dhd_info, SrReq,
				(APPLE_80211_SCANRESULT *)OutParams,
				OutSize);
		if (EFI_ERROR(Status)) {
			*OutSize = 0;
			DHD_ERROR(("BCMWL_80211Ioctl SCAN RESULTS failed\n"));
		}
		return Status;
	}

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlJoinGuid, sizeof(EFI_GUID)) == 0) {
		if (InSize < sizeof(APPLE_80211_JOINPARAMS) ||
			InParams == NULL ||
			OutParams != NULL) {
			return EFI_INVALID_PARAMETER;
		}
		Status = BCMDHD_JoinIoctl(&g_dhd_info, (APPLE_80211_JOINPARAMS *)InParams);
		if (EFI_ERROR(Status)) {
			DHD_ERROR(("BCMWL_80211Ioctl JOIN failed\n"));
		}
		return Status;
	}

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlStateGuid, sizeof(EFI_GUID)) == 0) {
		state = ((UINT32 *)OutParams);
		if (OutParams == NULL ||
			InSize != 0 ||
			InParams != NULL) {
			return EFI_INVALID_PARAMETER;
		}

		if (g_dhd_info.connected) {
			g_dhd_info.apple_dot11_state = APPLE80211_S_RUN;
		}
		*state = g_dhd_info.apple_dot11_state;
		return EFI_SUCCESS;

	}

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlInfoGuid, sizeof(EFI_GUID)) == 0) {
		if (OutParams == NULL ||
			InSize != 0 ||
			InParams != NULL) {
			return EFI_INVALID_PARAMETER;
		}

		Status = BCMDHD_InfoIoctl(&g_dhd_info, (APPLE_80211_INFO *)OutParams, OutSize);
		if (EFI_ERROR(Status)) {
			*OutSize = 0;
			DHD_ERROR(("BCMWL_80211Ioctl INFO failed\n"));
		}
		return Status;

	}

	if (bcmp((char *)SelectorGuid, (char *)&gApple80211IoctlIBSSGuid, sizeof(EFI_GUID)) == 0) {
		if (InSize < sizeof(APPLE_80211_IBSSPARAMS) ||
			InParams == NULL ||
			OutParams != NULL) {
			return EFI_INVALID_PARAMETER;
		}
		Status = BCMDHD_IBSSIoctl(&g_dhd_info, (APPLE_80211_IBSSPARAMS *)InParams);
		if (EFI_ERROR(Status)) {
			DHD_ERROR(("BCMWL_80211Ioctl IBSS failed\n"));
		}
		return Status;
	}

	if (bcmp((char *)SelectorGuid, (char *)&gBcmdhdIoctlGuid,
	         sizeof(EFI_GUID) - sizeof(UINT32)) == 0) {
		cmd = *((uint16 *)(&SelectorGuid->Data4[4]));
		ioc->cmd = cmd;
		if (InParams)
			buflen = MIN((int)InSize, DHD_IOCTL_MAXLEN);
		err = dhd_ioctl(&g_dhd_info.pub, ioc, InParams, buflen);
		if (err < 0) {
			DHD_ERROR(("%s: dhd_ioctl failed. cmd %d, err %d\n",
			__FUNCTION__, ioc->cmd, err));
		}

	}
	if (bcmp((char *)SelectorGuid, (char *)&gBcmwlIoctlGuid,
	         sizeof(EFI_GUID) - sizeof(UINT32)) == 0) {
		cmd = *((uint16 *)(&SelectorGuid->Data4[4]));
		set = *((uint8 *)(&SelectorGuid->Data4[6]));

		if (set)
			DHD_INFO(("%s: set ioctl, cmd = %d \n", __FUNCTION__, cmd));
		else
			DHD_INFO(("%s: get ioctl, cmd = %d \n", __FUNCTION__, cmd));

		/* This is a WL IOVAR, truncate buflen to WLC_IOCTL_MAXLEN */
		if (InParams)
			buflen = MIN((int)InSize, WLC_IOCTL_MAXLEN);

		/* For the time being only a single interface (index = 0)
		* will be supported in EFI-DHD
		*/
		if (g_dhd_info.pub.busstate == DHD_BUS_LOAD)
			dhd_bus_start(&g_dhd_info.pub);

		err = dhd_wl_ioctl_cmd(&g_dhd_info.pub, cmd,
				InParams, buflen, set, 0);
		if (err < 0) {
			DHD_ERROR(("%s: ioctl %d failed with err = %d !\n",
					__FUNCTION__, cmd, err));
		}
	}

	return osl_error(err);
}

int dhd_bus_start(dhd_pub_t *dhdp)
{

	EFI_STATUS Status = EFI_SUCCESS;
	EFI_PCI_IO_PROTOCOL *PciIoIntf;
	uint8 addr[ETHER_ADDR_LEN];
	int err, pm_val, mpc_val;
	uint32 num_flowrings; /* includes H2D common rings */
	char eventmask[WL_EVENTING_MASK_LEN], *str, *fw_type;

	ASSERT(dhdp);

	DHD_TRACE(("Enter %s:\n", __FUNCTION__));

	if (dhd_bus_init(dhdp, FALSE) < 0) {
		DHD_ERROR(("%s: dhd_bus_init failed !\n", __FUNCTION__));
		goto Error;
	} else {
		DHD_ERROR(("%s: dhd_bus_init success. \n", __FUNCTION__));
	}

#ifdef DHD_FW_COREDUMP
	/* enable socram dump */
	dhdp->bus->dhd->memdump_enabled = DUMP_MEMFILE;
#endif

	ASSERT(dhdp->osh);
	/* Now initialize the packet buffer memory */
	Status = osl_pktinit(dhdp->osh);
	if (EFI_ERROR(Status)) {
		EFI_ERRMSG(Status, "osl_pktinit failed");
		DHD_ERROR(("%s: pkt init failed !\n", __FUNCTION__));
		goto Error;
	}

	/* Initialize the flow rings */
	num_flowrings = dhd_bus_max_h2d_queues(dhdp->bus);
	DHD_ERROR(("%s: Initializing %u flowrings...\n", __FUNCTION__,
		num_flowrings));
	if ((dhd_flow_rings_init(dhdp, num_flowrings)) != BCME_OK) {
		DHD_ERROR(("%s: dhd_flow_rings_init failed\n", __FUNCTION__,
		num_flowrings));
		goto Error;
	}

	/* Do protocol initialization necessary for IOCTL/IOVAR */
	if (dhd_prot_init(dhdp) != BCME_OK) {
		DHD_ERROR(("%s: dhd_prot_init failed !\n",
			__FUNCTION__));
		goto Error;
	}

	/* Read event_msgs mask */
	err = wl_iovar(&g_dhd_info, "event_msgs", NULL, 0, eventmask, WL_EVENTING_MASK_LEN, FALSE);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar get 'event_msgs' fails with err = %d ! \n",
				__FUNCTION__, err));
	}

	/* Setup event_msgs */
	setbit(eventmask, WLC_E_SET_SSID);
	setbit(eventmask, WLC_E_PRUNE);
	setbit(eventmask, WLC_E_AUTH);
	setbit(eventmask, WLC_E_ASSOC);
	setbit(eventmask, WLC_E_REASSOC);
	setbit(eventmask, WLC_E_REASSOC_IND);
	setbit(eventmask, WLC_E_DEAUTH);
	setbit(eventmask, WLC_E_DEAUTH_IND);
	setbit(eventmask, WLC_E_DISASSOC_IND);
	setbit(eventmask, WLC_E_DISASSOC);
	setbit(eventmask, WLC_E_JOIN);
	setbit(eventmask, WLC_E_START);
	setbit(eventmask, WLC_E_ASSOC_IND);
	setbit(eventmask, WLC_E_PSK_SUP);
	setbit(eventmask, WLC_E_LINK);
	setbit(eventmask, WLC_E_NDIS_LINK);
	setbit(eventmask, WLC_E_MIC_ERROR);
	setbit(eventmask, WLC_E_ASSOC_REQ_IE);
	setbit(eventmask, WLC_E_ASSOC_RESP_IE);
	setbit(eventmask, WLC_E_PMKID_CACHE);
	setbit(eventmask, WLC_E_TXFAIL);
	setbit(eventmask, WLC_E_JOIN_START);
	setbit(eventmask, WLC_E_SCAN_COMPLETE);
	setbit(eventmask, WLC_E_HTSFSYNC);
	setbit(eventmask, WLC_E_PFN_NET_FOUND);
	setbit(eventmask, WLC_E_ROAM);
	setbit(eventmask, WLC_E_BSSID);
	setbit(eventmask, WLC_E_ADDTS_IND);
	setbit(eventmask, WLC_E_DELTS_IND);
	setbit(eventmask, WLC_E_TDLS_PEER_EVENT);
	setbit(eventmask, WLC_E_ESCAN_RESULT);
	setbit(eventmask, WLC_E_ACTION_FRAME_RX);
	setbit(eventmask, WLC_E_P2P_DISC_LISTEN_COMPLETE);
	setbit(eventmask, WLC_E_ACTION_FRAME_RX);
	setbit(eventmask, WLC_E_TRACE);

	clrbit(eventmask, WLC_E_PROBREQ_MSG);

	/* Write updated Event mask */
	err = wl_iovar(&g_dhd_info, "event_msgs", NULL, 0, eventmask, WL_EVENTING_MASK_LEN, TRUE);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar set 'event_msgs' fails with err = %d ! \n",
				__FUNCTION__, err));
	}

	/* Get the ether addr */
	err = wl_iovar(&g_dhd_info, "perm_etheraddr", NULL, 0,
	            addr, ETHER_ADDR_LEN, IOV_GET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar get 'perm_etheraddr' fails with err = %d ! \n",
				__FUNCTION__, err));
	}
	DHD_INFO(("%s: sta addr = %x.%x.%x.%x.%x.%x \n", __FUNCTION__,
		addr[0], addr[1], addr[2], addr[3],
		addr[4], addr[5]));

	str = MALLOCZ(dhdp->osh, BUF_MAX);
	err = wl_iovar(&g_dhd_info, "ver", NULL, 0, str, BUF_MAX, IOV_GET);
	if (strstr(str, "WLTEST") != NULL) {
		pm_val = 0;
		mpc_val = 0;
		fw_type = "Mfgtest FW";
	} else {
		pm_val = 2;
		mpc_val = 1;
		fw_type = "Release FW";
	}
	err = wl_iovar(&g_dhd_info, "mpc", NULL, 0, &mpc_val, sizeof(mpc_val), IOV_SET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar set 'mpc' fails!\n", __FUNCTION__));
	}
	err = wl_iovar(&g_dhd_info, "mpc", NULL, 0, &mpc_val, sizeof(mpc_val), IOV_GET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: iovar get 'mpc' fails!\n", __FUNCTION__));
	}
	err = wl_ioctl(&g_dhd_info, WLC_SET_PM, &pm_val, sizeof(pm_val), IOV_SET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: ioctl set 'PM' fails!\n", __FUNCTION__));
	}
	err = wl_ioctl(&g_dhd_info, WLC_GET_PM, &pm_val, sizeof(pm_val), IOV_GET);
	if (err != BCME_OK) {
		DHD_ERROR(("%s: ioctl get 'PM' fails!\n", __FUNCTION__));
	}
	DHD_ERROR(("%s, Set PM=%d mpc=%d\n", fw_type, pm_val, mpc_val));
	MFREE(dhdp->osh, str, BUF_MAX);

#ifdef BCMWLUNDI
	Status = dhd_install_undi(&g_dhd_info, g_dhd_info.UndiBaseDevPath, addr);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("NII Installation failed \n"));
		goto Error;
	}

	/* Open For Child Device */
	Status = gBS->OpenProtocol(g_dhd_info.Controller,
	                           &gEfiPciIoProtocolGuid,
	                           (VOID **)&g_dhd_info.ChildPciIoIntf,
	                           g_dhd_info.efi_bind_proto->DriverBindingHandle,
	                           g_dhd_info.UNDIHandle,
	                           EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER);
	if (EFI_ERROR (Status)) {
		DHD_ERROR(("%s: PCI proto open by child controller fails !\n", __FUNCTION__));
		goto Error;
	}
#endif /* BCMWLUNDI */

	dhdp->up = 1;

	return BCME_OK;

Error:
	return BCME_ERROR;

}

void EFIAPI
dhd_watchdog_timer_expired(IN EFI_EVENT Event,	IN VOID *Context)
{
	dhd_info_t *dhd = (dhd_info_t *)Context;
	int tpl = 0;

	ASSERT(dhd);
	if (!dhd) {
		DHD_ERROR(("%s: dhd context is null !\n", __FUNCTION__));
		return;
	}

	dhd_bus_watchdog(&dhd->pub);

	gBS->SetTimer(dhd->watchdog_timer, TimerRelative,
		dhd_watchdog_ms * EFI_DHD_MS_NS_CONVERSION_UNIT);
}

dhd_pub_t*
dhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)
{
	dhd_info_t *dhd = &g_dhd_info;
	EFI_STATUS status = EFI_SUCCESS;
#ifdef SHOW_LOGTRACE
	char *str_file;
	char *map_file;
#endif
	memset(&dhd->pub, 0, sizeof(dhd->pub));

	dhd->pub.osh = osh;
	dhd->pub.info = dhd;

	/* Link to bus module */
	dhd->pub.bus = bus;
	dhd->pub.hdrlen = bus_hdrlen;

	/* Initialize the lock used to serialize ioctls from app */
	EfiInitializeLock(&dhd->proto_lock, DHD_LOCK_LEVEL_LOW);

	/* Attach and link in the protocol */
	if (dhd_prot_attach(&dhd->pub) != 0) {
		DHD_ERROR(("%s: dhd_prot_attach failed !\n", __FUNCTION__));
		dhd_detach(&dhd->pub);
		return NULL;
	}

#ifdef SHOW_LOGTRACE
	str_file = ST_STR_FILE_PATH;
	map_file = MAPFILE_PATH;
	dhd_init_logstrs_array(osh, &dhd->event_data);
	dhd_init_static_strs_array(osh, &dhd->event_data, str_file, map_file);
	str_file = ROM_ST_STR_FILE_PATH;
	map_file = ROM_MAP_FILE_PATH;
	dhd_init_static_strs_array(osh, &dhd->event_data, str_file, map_file);
#endif /* SHOW_LOGTRACE */

#ifdef DHD_LOG_DUMP
	dhd_log_dump_init(&dhd->pub);
#endif /* DHD_LOG_DUMP */


	/* create and start the watchdog timer to periodically
	* read FW prints from the FW console buffer
	*/
	status = gBS->CreateEvent(
		EFI_EVENT_NOTIFY_SIGNAL | EFI_EVENT_TIMER,
		DHD_LOCK_LEVEL_LOW,
		dhd_watchdog_timer_expired,
		(VOID *)dhd,
		&dhd->watchdog_timer);
	if (EFI_ERROR (status)) {
		DHD_ERROR(("%s: watchdog timer event creation failed !\n", __FUNCTION__));
	}
	gBS->SetTimer(dhd->watchdog_timer, TimerRelative,
		dhd_watchdog_ms * EFI_DHD_MS_NS_CONVERSION_UNIT);

	return &dhd->pub;
}

void
dhd_detach(dhd_pub_t *dhdp)
{
	dhd_info_t *dhd = NULL;

	ASSERT(dhdp);

	dhd = dhdp->info;
	ASSERT(dhd);

	dhdp->up = 0;

	if (dhd->watchdog_timer) {
		gBS->SetTimer(dhd->watchdog_timer, TimerCancel, 0);
		gBS->CloseEvent(dhd->watchdog_timer);
	}

#ifdef SHOW_LOGTRACE
	if (dhd->event_data.fmts)
		MFREE(dhd->pub.osh, dhd->event_data.fmts,
				dhd->event_data.fmts_size);
	if (dhd->event_data.raw_fmts)
		MFREE(dhd->pub.osh, dhd->event_data.raw_fmts,
				dhd->event_data.raw_fmts_size);
	if (dhd->event_data.raw_sstr)
		MFREE(dhd->pub.osh, dhd->event_data.raw_sstr,
				dhd->event_data.raw_sstr_size);
	if (dhd->event_data.rom_raw_sstr)
		MFREE(dhd->pub.osh, dhd->event_data.rom_raw_sstr,
				dhd->event_data.rom_raw_sstr_size);
#endif /* SHOW_LOGTRACE */

#ifdef DHD_LOG_DUMP
		dhd_log_dump_deinit(&dhd->pub);
#endif /* DHD_LOG_DUMP */

	dhd_prot_detach(&dhd->pub);
}


/*
 * OS specific functions required to implement DHD driver in OS independent way
 */

int
dhd_timeout_expired(dhd_timeout_t *tmo)
{
	return 0;
}

void
dhd_timeout_start(dhd_timeout_t *tmo, uint usec)
{

}

int
dhd_os_proto_block(dhd_pub_t *pub)
{

	dhd_info_t *dhd = NULL;

	ASSERT(pub);
	dhd = (dhd_info_t *)pub->info;
	ASSERT(dhd);

	EfiAcquireLock(&dhd->proto_lock);

	return 1;
}

int
dhd_os_proto_unblock(dhd_pub_t *pub)
{
	dhd_info_t *dhd = NULL;

	ASSERT(pub);
	dhd = (dhd_info_t *)pub->info;
	ASSERT(dhd);

	EfiReleaseLock(&dhd->proto_lock);

	return 1;
}

void
dhd_rx_event(dhd_pub_t *pub, int ifidx, void *pkt)
{
	void *pktdata;
	uint pktlen;
	wl_event_msg_t event;
	void *event_data = NULL;
	wl_escan_result_t *escan_result = NULL;
	uint16 i = 0;
	dhd_info_t *dhd = 0;
	int wsec = 0;

	dhd = pub->info;
	ASSERT(dhd);

	pktdata = PKTDATA(pub->osh, pkt);
	pktlen = PKTLEN(pub->osh, pkt);

#ifdef SHOW_LOGTRACE
	wl_host_event(pub, &ifidx, pktdata, pktlen, &event, &event_data, &dhd->event_data);
#else
	wl_host_event(pub, &ifidx, pktdata, pktlen, &event, &event_data, NULL);
#endif
	wl_event_to_host_order(&event);

	/* process events required by EFI */
	switch (event.event_type) {
		case WLC_E_AUTH:
			if (event.status != WLC_E_STATUS_SUCCESS) {
				dhd->apple_dot11_state = APPLE80211_S_AUTHFAIL;
			}
			break;

		case WLC_E_ASSOC:
			if (event.status != WLC_E_STATUS_SUCCESS)
				dhd->apple_dot11_state = APPLE80211_S_ASSOCFAIL;
			break;

		case WLC_E_ASSOC_IND:
		case WLC_E_REASSOC_IND:
			break;

		case WLC_E_DEAUTH_IND:
			DHD_ERROR(("%s: 802.11 deauth \n", __FUNCTION__));
			if (event.reason != 0)
				dhd->apple_dot11_state = APPLE80211_S_OTHER;
			else
				dhd->apple_dot11_state = APPLE80211_S_IDLE;
			break;

		case WLC_E_DISASSOC_IND:
			DHD_ERROR(("%s: 802.11 disassoc \n", __FUNCTION__));
			dhd->apple_dot11_state = APPLE80211_S_IDLE;
			break;

		case WLC_E_LINK:
			if (!(event.flags & WLC_EVENT_MSG_LINK)) {
				dhd->apple_dot11_state = APPLE80211_S_IDLE;
				dhd->connected = FALSE;
			} else {
				dhd->apple_dot11_state = APPLE80211_S_RUN;
				dhd->connected = TRUE;
			}
			DHD_ERROR(("%s: 802.11 link %s \n", __FUNCTION__,
					(event.flags & WLC_EVENT_MSG_LINK) ? "up" : "down"));
			break;

		case WLC_E_SET_SSID:
			if (event.status != WLC_E_STATUS_SUCCESS)
				dhd->apple_dot11_state = APPLE80211_S_NONETWORK;
			break;

		case WLC_E_SCAN_COMPLETE:
			DHD_ERROR(("%s: 802.11 scan complete \n", __FUNCTION__));
			break;

		case WLC_E_ESCAN_RESULT:
			escan_result = (wl_escan_result_t*) event_data;
			if (escan_result) {
				for (i = 0; i < escan_result->bss_count; i++) {
					BCMDHD_ScanAddResult(pub->info, &escan_result->bss_info[i]);
				}
			}
			if (event.status == WLC_E_STATUS_SUCCESS) {
				DHD_ERROR(("%s: scan complete \n", __FUNCTION__));
				dhd->scan_done = 1;
				if (dhd->apple_dot11_state == APPLE80211_S_SCAN)
					dhd->apple_dot11_state = APPLE80211_S_IDLE;
			}
			break;

		default:
			break;
	}

	PKTFREE(pub->osh, pkt, FALSE);

}

void
dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
{
	int i;
	void *pnext = NULL;
	void *pinit = pktbuf;
	void *pprev = pktbuf;
	void *pktdata;
	wl_event_msg_t event;
	void *event_data = NULL;
	struct EFI_PKT *pxe_pkt = NULL;
	dhd_info_t *dhd = NULL;

	ASSERT(dhdp);
	dhd = (dhd_info_t *)dhdp->info;
	ASSERT(dhd);

	while (pktbuf && numpkt) {
		struct ether_header *eh;

		pnext = PKTNEXT(dhdp->osh, pktbuf);
#ifdef PCIE_FULL_DONGLE
		/* info ring "debug" data, which is not a 802.3 frame, is sent/hacked with a
		 * special ifidx of -1. This is just internal to dhd to get the data from
		 * dhd_msgbuf.c:dhd_prot_infobuf_cmplt_process() to here (dhd_rx_frame).
		 */
		if (ifidx == -1) {
			--numpkt;
#ifdef SHOW_LOGTRACE
			dhd_event_logtrace_infobuf_pkt_process(dhdp, pktbuf, &dhd->event_data);
#endif /* SHOW_LOGTRACE */
			PKTCFREE(dhd->pub.osh, pktbuf, FALSE);
			pktbuf = pnext;
			continue;
		}
#endif /* PCIE_FULL_DONGLE */

		eh = (struct ether_header *)PKTDATA(dhdp->osh, pktbuf);
		if (ntoh16(eh->ether_type) == ETHER_TYPE_BRCM) {
			if (pinit == pktbuf) {
				pinit = pnext;
			}
			PKTSETNEXT(dhdp->osh, pktbuf, NULL);
			if (pprev != pktbuf) {
				PKTSETNEXT(dhdp->osh, pprev, pnext);
			}

			dhd_rx_event(dhdp, ifidx, pktbuf);

		} else {
			if (spktq_full(&dhd->q_rx_sendup)) {
				DHD_ERROR(("%s: rx q overflow !\n", __FUNCTION__));
				ASSERT(0);
				PKTFREE(dhd->pub.osh, pktbuf, FALSE);
				return;
			}
			pxe_pkt = PKTTONATIVE(dhdp->osh, pktbuf);
			if (!pxe_pkt) {
				DHD_ERROR(("%s: PKTTONATIVE fails ! \n", __FUNCTION__));
				PKTFREE(dhd->pub.osh, pktbuf, FALSE);
				return;
			}
			/* packet will be dequeued later and handed over when
			* EFI calls UNDIRxPacket.
			*/
			spktenq(&dhd->q_rx_sendup, pxe_pkt);
			PKTFREE(dhd->pub.osh, pktbuf, FALSE);
			pprev = pktbuf;
		}

		pktbuf = pnext;
		--numpkt;
	}

}

unsigned long
dhd_os_general_spin_lock(dhd_pub_t *pub)
{
	return 0;
}

void
dhd_os_general_spin_unlock(dhd_pub_t *pub, unsigned long flags)
{

}

#ifdef SHOW_LOGTRACE
int
dhd_os_read_file(void *file, char *buf, uint32 size)
{
	return dhd_os_get_image_block(buf, size, file);
}

int
dhd_os_seek_file(void *file, int64 offset)
{
	EFI_FILE_HANDLE FileHandle = (EFI_FILE_HANDLE)file;
	EFI_STATUS status = EFI_SUCCESS;
	uint64 cur_posn = 0;

	if (!file)
		return BCME_ERROR;

	status = FileHandle->GetPosition(FileHandle, &cur_posn);
	if (!EFI_ERROR(status)) {
		/* offset can be -ve */
		cur_posn += offset;
		status = FileHandle->SetPosition(FileHandle, cur_posn);
		if (!EFI_ERROR(status))
			return BCME_OK;
	}

	return BCME_ERROR;
}

static void
dhd_init_logstrs_array(osl_t *osh, dhd_event_log_t *temp)
{
	EFI_FILE_HANDLE file = NULL;
	EFI_FILE_INFO *file_info = NULL;
	EFI_STATUS status = EFI_SUCCESS;
	UINTN file_info_size = 0;
	char *raw_fmts =  NULL;
	int logstrs_size = 0;
	int error = 0;
	char *filename = LOGSTRS_FILE_PATH;

	file = (EFI_FILE_HANDLE)dhd_os_open_image(filename);
	if (!file) {
		DHD_ERROR(("%s: Failed to open logstrs file \n", __FUNCTION__));
		goto fail;
	}
	file_info = MALLOCZ(g_dhd_info.pub.osh, sizeof(*file_info) + PATH_MAX);
	if (!file_info) {
		DHD_ERROR(("%s: unable to alloc mem for file info !\n", __FUNCTION__));
		goto fail;
	}
	file_info_size = sizeof(*file_info) + PATH_MAX;
	status = file->GetInfo(file, &gEfiFileInfoGuid,
			&file_info_size, file_info);
	if (EFI_ERROR(status)) {
		DHD_ERROR(("%s: Failed to stat logstrs file \n", __FUNCTION__));
		MFREE(osh, file_info, sizeof(*file_info) + PATH_MAX);
		goto fail;
	}
	logstrs_size = file_info->FileSize;
	MFREE(osh, file_info, sizeof(*file_info) + PATH_MAX);

	raw_fmts = MALLOC(osh, logstrs_size);
	if (raw_fmts == NULL) {
		DHD_ERROR(("%s: Failed to allocate memory \n", __FUNCTION__));
		goto fail;
	}

	if (dhd_os_read_file(file, raw_fmts, logstrs_size) != logstrs_size) {
		DHD_ERROR(("%s: Failed to read logstrs file \n", __FUNCTION__));
		goto fail;
	}

	if (dhd_parse_logstrs_file(osh, raw_fmts, logstrs_size, temp)
				== BCME_OK) {
		dhd_os_close_image(file);
		return;
	}

fail:
	if (raw_fmts) {
		MFREE(osh, raw_fmts, logstrs_size);
		raw_fmts = NULL;
	}

	if (file)
		dhd_os_close_image(file);

	temp->fmts = NULL;
	return;
}

static int
dhd_read_map(osl_t *osh, char *fname, uint32 *ramstart, uint32 *rodata_start,
		uint32 *rodata_end)
{
	EFI_FILE_HANDLE file = NULL;
	int err = BCME_ERROR;

	if (fname == NULL) {
		DHD_ERROR(("%s: ERROR fname is NULL \n", __FUNCTION__));
		goto fail;
	}

	file = (EFI_FILE_HANDLE)dhd_os_open_image(fname);
	if (!file) {
		DHD_ERROR(("%s: Failed to open file !\n", __FUNCTION__));
		goto fail;
	}

	if ((err = dhd_parse_map_file(osh, file, ramstart,
			rodata_start, rodata_end)) < 0)
		goto fail;

fail:
	if (file)
		dhd_os_close_image(file);

	return err;
}

static void
dhd_init_static_strs_array(osl_t *osh, dhd_event_log_t *temp, char *str_file, char *map_file)
{
	EFI_FILE_HANDLE file = NULL;
	char *raw_fmts =  NULL;
	uint32 logstrs_size = 0;
	char *ram_file_str = RAM_FILE_STR;
	char *rom_file_str = ROM_FILE_STR;
	int error = 0;
	uint32 ramstart = 0;
	uint32 rodata_start = 0;
	uint32 rodata_end = 0;
	uint32 logfilebase = 0;

	error = dhd_read_map(osh, map_file, &ramstart, &rodata_start, &rodata_end);
	if (error != BCME_OK) {
		DHD_ERROR(("readmap Error!! \n"));
		/* don't do event log parsing in actual case */
		if (strstr(str_file, ram_file_str) != NULL) {
			temp->raw_sstr = NULL;
		} else if (strstr(str_file, rom_file_str) != NULL) {
			temp->rom_raw_sstr = NULL;
		}
		return;
	}
	DHD_ERROR(("ramstart: 0x%x, rodata_start: 0x%x, rodata_end:0x%x\n",
		ramstart, rodata_start, rodata_end));

	file = (EFI_FILE_HANDLE)dhd_os_open_image(str_file);
	if (!file) {
		DHD_ERROR(("%s: Failed to open  str_file \n",  __FUNCTION__));
		goto fail;
	}

	/* Full file size is huge. Just read required part */
	logstrs_size = rodata_end - rodata_start;

	raw_fmts = MALLOC(osh, logstrs_size);
	if (raw_fmts == NULL) {
		DHD_ERROR(("%s: Failed to allocate raw_fmts memory \n", __FUNCTION__));
		goto fail;
	}

	logfilebase = rodata_start - ramstart;

	error = dhd_os_seek_file(file, logfilebase);
	if (error < 0) {
		DHD_ERROR(("%s: file seek failed; err = %d \n", __FUNCTION__, error));
		goto fail;
	}

	error = dhd_os_read_file(file, raw_fmts, logstrs_size);
	if (error != logstrs_size) {
		DHD_ERROR(("%s: %s read failed %d \n", __FUNCTION__, str_file, error));
		goto fail;
	}

	if (strstr(str_file, ram_file_str) != NULL) {
		temp->raw_sstr = raw_fmts;
		temp->raw_sstr_size = logstrs_size;
		temp->ramstart = ramstart;
		temp->rodata_start = rodata_start;
		temp->rodata_end = rodata_end;
	} else if (strstr(str_file, rom_file_str) != NULL) {
		temp->rom_raw_sstr = raw_fmts;
		temp->rom_raw_sstr_size = logstrs_size;
		temp->rom_ramstart = ramstart;
		temp->rom_rodata_start = rodata_start;
		temp->rom_rodata_end = rodata_end;
	}

	dhd_os_close_image(file);
	return;

fail:
	if (raw_fmts) {
		MFREE(osh, raw_fmts, logstrs_size);
		raw_fmts = NULL;
	}
	if (file)
		dhd_os_close_image(file);

	if (strstr(str_file, ram_file_str) != NULL) {
		temp->raw_sstr = NULL;
	} else if (strstr(str_file, rom_file_str) != NULL) {
		temp->rom_raw_sstr = NULL;
	}
	return;
}

#endif /* SHOW_LOGTRACE */

void *
dhd_os_locate_image(char *filename, UINT64 mode, UINT64 attrib)
{
	EFI_HANDLE *HandleBuffer = NULL;
	UINTN HandleCount = 0;
	EFI_STATUS Status = EFI_NOT_FOUND;
	EFI_FILE_HANDLE FileHandle = NULL;
	EFI_FILE_HANDLE ActualFileHandle = NULL;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *Volume = NULL;
	CHAR16 filename_unicode[PATH_MAX];
	int i = 0;

	if (!filename)
		return NULL;

	/* EFI APIs require path strings to be in unicode format */
	memset(filename_unicode, 0, PATH_MAX * sizeof(CHAR16));
	osl_strn_ascii2unicode(filename, strlen(filename), filename_unicode);

	Status = gBS->LocateHandleBuffer(
			ByProtocol,
			&gEfiSimpleFileSystemProtocolGuid,
			NULL,
			&HandleCount,
			&HandleBuffer);
	if (EFI_ERROR(Status)) {
		DHD_ERROR(("%s: error locating simple fs protocol handle !\n", __FUNCTION__));
		return NULL;
	}

	for (i = 0; i < HandleCount; ++i) {
		Status = gBS->HandleProtocol(HandleBuffer[i],
				&gEfiSimpleFileSystemProtocolGuid,
				(VOID**)&Volume);
		if (!EFI_ERROR(Status)) {
			Status = Volume->OpenVolume(Volume, &FileHandle);
			if (!EFI_ERROR(Status)) {
				Status = FileHandle->Open(FileHandle,
						&ActualFileHandle, filename_unicode,
						mode, attrib);
				if (!EFI_ERROR(Status)) {
					return ActualFileHandle;
				}
			}
		}
	}

	return NULL;

}

int
dhd_os_write_image(char *filename, uint8 *buf, uint32 size)
{
	EFI_FILE_HANDLE FileHandle = NULL;
	EFI_STATUS Status = EFI_NOT_FOUND;

	if (!filename || !buf || size <= 0)
		return BCME_BADARG;

	FileHandle = dhd_os_locate_image(filename,
			EFI_FILE_MODE_CREATE |
			EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
			0);

	if (FileHandle) {
		Status = FileHandle->Write(FileHandle,
				(UINTN *)&size, buf);
		FileHandle->Flush(FileHandle);
		FileHandle->Close(FileHandle);
	}

	return (EFI_ERROR(Status)) ? BCME_ERROR : BCME_OK;
}

void *
dhd_os_open_image(char *filename)
{
	if (!filename)
		return NULL;

	return dhd_os_locate_image(filename,
			EFI_FILE_MODE_READ,
			0);
}

int
dhd_os_get_image_block(char *buf, int len, void *image)
{
	EFI_FILE_HANDLE FileHandle = (EFI_FILE_HANDLE)image;
	EFI_STATUS Status = EFI_SUCCESS;
	UINTN ulen = len;

	if (!buf || len <= 0 || !image)
		return -1;

	Status = FileHandle->Read(FileHandle, &ulen, buf);
	if (!EFI_ERROR (Status)) {
		return (int)ulen;
	}

	return -1;
}

void
dhd_os_close_image(void *image)
{
	EFI_FILE_HANDLE FileHandle = (EFI_FILE_HANDLE)image;

	if (!image)
		return;

	FileHandle->Close(FileHandle);
}

int
dhd_os_create_dir(char *dirname)
{
	EFI_FILE_HANDLE handle = NULL;

	handle = dhd_os_locate_image(dirname,
		EFI_FILE_MODE_CREATE |
		EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
		EFI_FILE_DIRECTORY);
	if (!handle)
		return BCME_ERROR;

	dhd_os_close_image(handle);

	return BCME_OK;
}

int
dhd_open_corecapture_folder(dhd_pub_t *dhdp, char *folder)
{
	EFI_TIME cur_ts;
	EFI_STATUS status;
	char dir_prefix[PATH_MAX];

	memset(dir_prefix, 0, PATH_MAX);
	memset(&cur_ts, 0, sizeof(cur_ts));

/* TODO: as of now GetTime API is working only in EDK1.02
* on EDK 2.0 x86-64 BRIX platform its causing a crash
* need to fix this later
*/
#if !defined(EDK_RELEASE_VERSION) || (EDK_RELEASE_VERSION < 0x00020000)
	status = gRT->GetTime(&cur_ts, NULL);
	if (EFI_ERROR (status)) {
		DHD_ERROR(("%s: Get Time failed!\n", __FUNCTION__));
		return BCME_ERROR;
	}
#endif /* EDK_RELEASE_VERSION */
	sprintf(dir_prefix, WIRELESS_PATH TIMESTAMP_PREFIX,
		cur_ts.Year, cur_ts.Month, cur_ts.Day,
		cur_ts.Hour, cur_ts.Minute, cur_ts.Second,
		cur_ts.Nanosecond);

	if (dhd_os_create_dir(dir_prefix) != BCME_OK) {
		DHD_ERROR(("\n%s: Create folder failed (%s)!\n", __FUNCTION__, dir_prefix));
		return BCME_ERROR;
	}
	strcpy(folder, dir_prefix);
	return BCME_OK;
}

int
dhd_corecapture_driverlog(dhd_pub_t *dhdp, char *folder)
{
	char filename[PATH_MAX];
	char dir_prefix[PATH_MAX];
	uint8 *buf;
	struct bcmstrbuf b;
	struct bcmstrbuf *strbuf = &b;
	int driverlog_dump_success = BCME_ERROR;

	buf = MALLOCZ(dhdp->osh, DHD_LOG_DUMP_BUFFER_SIZE);

	if (!buf) {
		DHD_ERROR(("%s: Failed to allocate memory for driver log dump !\n", __FUNCTION__));
		return driverlog_dump_success;
	}
	bcm_binit(strbuf, buf, DHD_LOG_DUMP_BUFFER_SIZE);

	memset(dir_prefix, 0, PATH_MAX);
	strcpy(dir_prefix, folder);
	strcat(dir_prefix, DRIVER_LOG_DIR);
	if (dhd_os_create_dir(dir_prefix) == BCME_OK) {
		int status;
		strcpy(filename, dir_prefix);
		strcat(filename, MMIO_FILE_NAME);
		dhd_prot_print_info(dhdp, strbuf);
		DHD_ERROR(("\n%s: Driver log dump to file Start(%s)\n", __FUNCTION__, filename));
		/* write to file */
		status = dhd_os_write_image(filename, b.origbuf, (b.origsize - b.size));
		if (status == BCME_OK) {
			DHD_ERROR(("%s: Driver log written to '%s' \n",
				__FUNCTION__, filename));
			driverlog_dump_success = BCME_OK;
		}
	}

	if (driverlog_dump_success) {
		DHD_ERROR(("\n%s: Driver log write to file failed! \n", __FUNCTION__));
	}
	MFREE(dhdp->osh, buf, DHD_LOG_DUMP_BUFFER_SIZE);
	return driverlog_dump_success;
}

int
dhd_corecapture_fwlog(dhd_pub_t *dhdp, char *folder)
{
	char filename[PATH_MAX];
	int fwlog_dump_success = BCME_ERROR;
	uint32 fwlog_size = DHD_LOG_DUMP_BUFFER_SIZE;

	memset(filename, 0, PATH_MAX);
	strcpy(filename, folder);
	strcat(filename, FW_LOG_DIR);
	if (dhd_os_create_dir(filename) == BCME_OK) {
		strcat(filename, FW_LOG_FILENAME);
		if (!g_fwlog_ring_buf.wraparound) {
			fwlog_size = g_fwlog_ring_buf.present - g_fwlog_ring_buf.buffer;
		}
		DHD_ERROR(("\n%s: FW log dump to file Start(%s)\n", __FUNCTION__, filename));
		if (dhd_os_write_image(filename, g_fwlog_ring_buf.buffer, fwlog_size) == BCME_OK) {
			DHD_ERROR(("%s: FW log written to '%s' \n", __FUNCTION__, filename));
			fwlog_dump_success = BCME_OK;
		}
	}

	if (fwlog_dump_success) {
		DHD_ERROR(("%s: FW log dump to file failed! (%s) \n", __FUNCTION__, filename));
	}
	return fwlog_dump_success;

}

int
dhd_corecapture_socram(dhd_pub_t *dhdp, char *folder, uint8 *buf, uint32 size)
{
	char filename[PATH_MAX];
	int socram_dump_success = BCME_ERROR;

	memset(filename, 0, PATH_MAX);
	strcpy(filename, folder);
	strcat(filename, SOCRAM_LOG_DIR);
	if (dhd_os_create_dir(filename) == BCME_OK) {
		strcat(filename, SOCRAM_FILE_NAME);
		if (dhd_os_write_image(filename, buf, size) == BCME_OK) {
			DHD_ERROR(("\n%s: socram dump written to '%s' \n",
				__FUNCTION__, filename));
			socram_dump_success = BCME_OK;
		}
	}

	if (socram_dump_success) {
		DHD_ERROR(("%s: socram dump to file failed! (%s) \n", __FUNCTION__, filename));
	}
	return socram_dump_success;

}

void
dhd_schedule_memdump(dhd_pub_t *dhdp, uint8 *buf, uint32 size)
{
	char folder[PATH_MAX];
	int status;

	memset(folder, 0, PATH_MAX);
	status = dhd_open_corecapture_folder(dhdp, folder);
	if (status != BCME_OK)
		return;

	status = dhd_corecapture_socram(dhdp, folder, buf, size);
	if (status != BCME_OK)
		return;

	status = dhd_corecapture_fwlog(dhdp, folder);
	if (status != BCME_OK)
		return;

	status = dhd_corecapture_driverlog(dhdp, folder);
	if (status != BCME_OK)
		return;
}

#ifdef BCMWLUNDI
STATIC
EFI_STATUS
BCMDHD_CreateMacDevPath(dhd_info_t *dhd,
                       EFI_DEVICE_PATH_PROTOCOL **dev_p,
                       EFI_DEVICE_PATH_PROTOCOL *basedev_p,
                       uint8 *addr)
{
	EFI_MAC_ADDRESS MACAddress;
	UINT16 j;
	UINT8 addr_len;
	MAC_ADDR_DEVICE_PATH mac_addr_node;
	EFI_DEVICE_PATH_PROTOCOL     *end_node;
	UINT8 *d_ptr;
	UINT16 tot_path_len, base_path_len;

	addr_len = 6;
	for (j = 0; j < addr_len; j++) {
		MACAddress.Addr[j] = addr[j];
	}

	for (j = addr_len; j < sizeof(EFI_MAC_ADDRESS); j++) {
		MACAddress.Addr[j] = 0;
	}

	/*  fill the mac address node first */
	bzero((char *)&mac_addr_node, sizeof(mac_addr_node));
	memcpy((char *)&mac_addr_node.MacAddress, (char *)&MACAddress,
	       sizeof(EFI_MAC_ADDRESS));

	mac_addr_node.Header.Type = MESSAGING_DEVICE_PATH;
	mac_addr_node.Header.SubType = MSG_MAC_ADDR_DP;
	mac_addr_node.Header.Length[0] = sizeof(mac_addr_node);
	mac_addr_node.Header.Length[1] = 0;

	/*  Find the size of the base dev path. */
	end_node = basedev_p;
	while (!IsDevicePathEnd(end_node)) {
		end_node = NextDevicePathNode(end_node);
	}

/* Pointers need to be typecast to unsigned long in case of linux builds.
* Type cast of pointers is required *before* performing the subtraction
* as otherwise according to pointer arithmetic rules
* the result of the subtraction will be divided by the size
* of the pointer type which in this case is 'EFI_DEVICE_PATH_PROTOCOL'.
* Since we don't want that to happen we typecast.
*/
#ifdef EFI_WINBLD
	base_path_len = ((UINT16)end_node - (UINT16)basedev_p);
#else
	base_path_len = ((UINT16)(unsigned long)end_node
			- (UINT16)(unsigned long)basedev_p);
#endif /* EFI_WINBLD */

	/*  create space for full dev path */
	tot_path_len = base_path_len + sizeof(mac_addr_node) +
	        sizeof(EFI_DEVICE_PATH_PROTOCOL);

	d_ptr = MALLOCZ(g_dhd_info.pub.osh, tot_path_len);
	dhd->DevPathLen = tot_path_len;

	if (d_ptr == NULL)
		return EFI_OUT_OF_RESOURCES;

	/*  copy the base path, mac addr and end_dev_path nodes */
	*dev_p = (EFI_DEVICE_PATH_PROTOCOL *)d_ptr;
	memcpy(d_ptr, (char *)basedev_p, base_path_len);
	d_ptr += base_path_len;
	memcpy(d_ptr, (char *)&mac_addr_node, sizeof(mac_addr_node));
	d_ptr += sizeof(mac_addr_node);
	memcpy(d_ptr, (char *)end_node, sizeof(EFI_DEVICE_PATH_PROTOCOL));

	return EFI_SUCCESS;
}

STATIC UINT8
dhd_cksum(void *buf, unsigned len)
{
	unsigned char cksum = 0;
	char *bp;

	if ((bp = buf) != NULL)
		while (len--)
			cksum = cksum + *bp++;

	return cksum;
}

STATIC void
dhd_init_pxestruct(PXE_SW_UNDI *pxe)
{
	/*  initialize the !PXE structure */
	pxe->Signature = PXE_ROMID_SIGNATURE;
	pxe->Len = sizeof(PXE_SW_UNDI);
	pxe->Fudge = 0;  /* cksum */
	pxe->IFcnt = 0;  /*  number of NICs this undi supports */
	pxe->Rev = PXE_ROMID_REV;
	pxe->MajorVer = PXE_ROMID_MAJORVER;

	pxe->MinorVer = PXE_ROMID_MINORVER_31;
	pxe->EntryPoint = (UINT64)BCMDHD_UNDIAPIEntry_31;
	pxe->reserved1 = 0;

	pxe->Implementation = PXE_ROMID_IMP_SW_VIRT_ADDR |
	        PXE_ROMID_IMP_STATION_ADDR_SETTABLE |
		PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED |
		PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED |
		PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED |
		PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED |
		PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED |
		PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED |
		PXE_ROMID_IMP_64BIT_DEVICE;

	pxe->reserved2[0] = pxe->reserved2[1] = pxe->reserved2[2]  = 0;
	pxe->BusCnt = 1;
	pxe->BusType[0] = PXE_BUSTYPE_PCI;

	pxe->Fudge -= (dhd_cksum((void *)pxe, pxe->Len));
}

STATIC EFI_STATUS
dhd_install_undi(dhd_info_t *dhd, EFI_DEVICE_PATH_PROTOCOL *UndiBaseDevPath, uint8 *addr)
{
	EFI_STATUS Status;

	dhd->pxe_ptr = MALLOC(dhd->pub.osh, sizeof(PXE_SW_UNDI) + 0x10);

	if (dhd->pxe_ptr == NULL)
		return EFI_OUT_OF_RESOURCES;
	/* Must be aligned to 16-byte boundary */
	dhd->pxe_31 = (PXE_SW_UNDI *)(((UINTN)dhd->pxe_ptr + 0x10) & (~(UINTN)0xf));
	bzero(dhd->pxe_31, sizeof(PXE_SW_UNDI));

	/* Initiailze !PXE structure */
	dhd_init_pxestruct(dhd->pxe_31);
	dhd->UndiState = PXE_STATFLAGS_GET_STATE_STOPPED;

	/* Initialize NII and install NII */
#if defined(APPLE_BUILD) || !defined(EFI_WINBLD)
	dhd->nii_31.Id = (UINT64) dhd->pxe_31;
#else
	dhd->nii_31.ID = (UINT64) dhd->pxe_31;
#endif
	dhd->nii_31.IfNum = 0;

	dhd->nii_31.Revision = EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_REVISION_31;
	dhd->nii_31.Type = EfiNetworkInterfaceUndi;
	dhd->nii_31.MajorVer = PXE_ROMID_MAJORVER;
	dhd->nii_31.MinorVer = PXE_ROMID_MINORVER_31;
	dhd->nii_31.ImageSize = 0;
	dhd->nii_31.ImageAddr = 0;
	dhd->nii_31.Ipv6Supported = FALSE;
	dhd->nii_31.StringId[0] = 'U';
	dhd->nii_31.StringId[1] = 'N';
	dhd->nii_31.StringId[2] = 'D';
	dhd->nii_31.StringId[3] = 'I';

	Status = BCMDHD_CreateMacDevPath(dhd,
			&dhd->UndiDevPath,
			dhd->UndiBaseDevPath,
			addr);

	if (EFI_ERROR (Status)) {
		EFI_ERRMSG(Status, "Dev path creation failed\r\n");
		return Status;
	}

	dhd->UNDIHandle = NULL;
	return  gBS->InstallMultipleProtocolInterfaces(&dhd->UNDIHandle,
			&NII_GUID,
			&(dhd->nii_31),
			&gEfiDevicePathProtocolGuid,
			dhd->UndiDevPath,
			NULL);
}

STATIC EFI_STATUS
EFIAPI
BCMDHD_UNDIAPIEntry_31(UINT64 cdb)
{
	PXE_CDB *cdb_ptr;

	if (cdb == (UINT64) 0)
		return EFI_INVALID_PARAMETER;

	cdb_ptr = (PXE_CDB *)(UINTN)cdb;

	BCMDHD_UNDIAPIEntry(cdb_ptr, &g_dhd_info);

	return EFI_SUCCESS;

}

STATIC VOID
BCMDHD_UNDIAPIEntry(PXE_CDB * cdb_ptr, dhd_info_t *dhd)
{
	PXE_CDB tmp_cdb;
	EFI_TPL tpl;
	pUNDI_API_ENTRY api_entry;

	WL_LOCK(dhd, tpl);

	if (!cdb_ptr)
		return;

	tmp_cdb = *cdb_ptr;

	WL_UNLOCK(dhd, tpl);

	/*  Check the OPCODE range */
	if ((tmp_cdb.OpCode > PXE_OPCODE_LAST_VALID) ||
	    (tmp_cdb.StatCode != PXE_STATCODE_INITIALIZE) ||
	    (tmp_cdb.StatFlags != PXE_STATFLAGS_INITIALIZE)) {
		DHD_ERROR(("BCMDHD_UNDIAPIEntry(): Bad parms!\n"));
		goto badcdb;
	}

	if (tmp_cdb.CPBsize == PXE_CPBSIZE_NOT_USED) {
		if (tmp_cdb.CPBaddr != PXE_CPBADDR_NOT_USED) {
			DHD_ERROR(("BCMDHD_UNDIAPIEntry(): Bad CPBaddr! Expected=%d\n",
			          PXE_CPBADDR_NOT_USED));
			goto badcdb;
		}
	} else if (tmp_cdb.CPBaddr == PXE_CPBADDR_NOT_USED) {
		DHD_ERROR(("BCMDHD_UNDIAPIEntry(): Bad CPBaddr! Expected !=%d\n",
		          PXE_CPBADDR_NOT_USED));
		goto badcdb;
	}

	if (tmp_cdb.DBsize == PXE_DBSIZE_NOT_USED) {
		if (tmp_cdb.DBaddr != PXE_DBADDR_NOT_USED) {
			DHD_ERROR(("BCMDHD_UNDIAPIEntry(): Bad DBaddr! Expected %d\n",
			          PXE_CPBADDR_NOT_USED));
			goto badcdb;
		}
	} else if (tmp_cdb.DBaddr == PXE_DBADDR_NOT_USED) {
		DHD_ERROR(("BCMDHD_UNDIAPIEntry(): Bad DBaddr! Expected !=%d\n",
		          PXE_CPBADDR_NOT_USED));
		goto badcdb;
	}

	api_entry = &undi_api_table[tmp_cdb.OpCode];

	if (api_entry->cpbsize != BCMDHD_UNDI_SIZE_VARY) {
		if ((api_entry->cpbsize != BCMDHD_UNDI_NOT_REQUIRED) &&
		    (api_entry->cpbsize != tmp_cdb.CPBsize)) {
			DHD_ERROR(("BCMDHD_UNDIAPIEntry(): %s Bad cpbsize! Expected %d got %d\n",
			          api_entry->name, api_entry->cpbsize, tmp_cdb.CPBsize));
			goto badcdb;
		}
	}

	if (api_entry->dbsize != BCMDHD_UNDI_SIZE_VARY)  {
		if ((api_entry->dbsize != BCMDHD_UNDI_NOT_REQUIRED) &&
		    (api_entry->dbsize != tmp_cdb.DBsize)) {
			DHD_ERROR(("BCMDHD_UNDIAPIEntry(): %s Bad cpbsize! Expected %d got %d\n",
			          api_entry->name, api_entry->dbsize, tmp_cdb.DBsize));
			goto badcdb;
		}
	}

	if ((api_entry->opflags != BCMDHD_UNDI_NOT_REQUIRED) &&
	    (api_entry->opflags != tmp_cdb.OpFlags)) {
		DHD_ERROR(("BCMDHD_UNDIAPIEntry(): %s Bad opflags! Expected 0x%x got 0x%x\n",
		          api_entry->name, api_entry->opflags, tmp_cdb.OpFlags));
		goto badcdb;
	}

	if (api_entry->state != BCMDHD_UNDI_NOT_REQUIRED) {
		if (dhd->UndiState == PXE_STATFLAGS_GET_STATE_STOPPED &&
			tmp_cdb.OpCode != PXE_OPCODE_STOP &&
			tmp_cdb.OpCode != PXE_OPCODE_SHUTDOWN) {
			DHD_ERROR(("BCMDHD_UNDIAPIEntry(): %s(OpCode %d) Bad state!"
			          " current state is STOPPED\n",
			          api_entry->name, tmp_cdb.OpCode));
			tmp_cdb.StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
			tmp_cdb.StatCode = PXE_STATCODE_NOT_STARTED;
			goto badcdb;
		}

		/*  check if it should be initialized */
		if (api_entry->state == BCMDHD_UNDI_AT_LEAST_INITIALIZED) {
			if (dhd->UndiState != PXE_STATFLAGS_GET_STATE_INITIALIZED &&
				dhd->UndiState != PXE_STATFLAGS_GET_STATE_STOPPED) {
				DHD_ERROR(("BCMDHD_UNDIAPIEntry(): %s Bad state!"
				          " Expected INTIALIZED got %d\n",
				          api_entry->name, dhd->UndiState));
				tmp_cdb.StatCode = PXE_STATCODE_NOT_INITIALIZED;
				tmp_cdb.StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
				goto badcdb;
			}
		}
	}

	tmp_cdb.StatFlags = PXE_STATFLAGS_COMMAND_COMPLETE;
	tmp_cdb.StatCode = PXE_STATCODE_SUCCESS;

	api_entry->handler_fn(&tmp_cdb, dhd);

	WL_LOCK(dhd, tpl);
	*cdb_ptr = tmp_cdb;
	WL_UNLOCK(dhd, tpl);

	return;

badcdb:
	if (!(tmp_cdb.StatFlags & PXE_STATFLAGS_STATUS_MASK)) {
		tmp_cdb.StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		tmp_cdb.StatCode = PXE_STATCODE_INVALID_CDB;
	}

	/* Copy the information back */
	WL_LOCK(dhd, tpl);
	*cdb_ptr = tmp_cdb;
	WL_UNLOCK(dhd, tpl);
}

STATIC VOID
BCMDHD_UNDIGetState(PXE_CDB *cdb_ptr,
                   dhd_info_t *dhd)
{
	EFI_TPL tpl;

	WL_LOCK(dhd, tpl);
	cdb_ptr->StatFlags |= dhd->UndiState;
	WL_UNLOCK(dhd, tpl);
}

STATIC VOID
BCMDHD_UNDIStart(PXE_CDB *cdb_ptr,
                struct dhd_info *dhd)
{
	PXE_CPB_START_31 *cpb_ptr_31;
	EFI_TPL tpl;

	WL_LOCK(dhd, tpl);
	if (dhd->UndiState != PXE_STATFLAGS_GET_STATE_STOPPED) {
		WL_UNLOCK(dhd, tpl);
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_ALREADY_STARTED;
		return;
	}

	/* Store callbacks but don't use them */
	cpb_ptr_31 = (PXE_CPB_START_31 *)(cdb_ptr->CPBaddr);
	dhd->undi_callback.Delay = (DELAY_API)cpb_ptr_31->Delay;
	dhd->undi_callback.Virt2Phys = (VIRT2PHY_API)cpb_ptr_31->Virt2Phys;
	dhd->undi_callback.Block = (BLOCK_API)cpb_ptr_31->Block;
	dhd->undi_callback.Mem_IO = (MEMIO_API)cpb_ptr_31->Mem_IO;
	dhd->undi_callback.Map = (MAP_API)cpb_ptr_31->Map_Mem;
	dhd->undi_callback.UnMap = (UNMAP_API)cpb_ptr_31->UnMap_Mem;
	dhd->undi_callback.Sync = (SYNC_API)cpb_ptr_31->Sync_Mem;
	dhd->undi_callback.SAP =  cpb_ptr_31->Unique_ID;

	dhd->UndiState = PXE_STATFLAGS_GET_STATE_STARTED;
	WL_UNLOCK(dhd, tpl);
}

STATIC VOID
BCMDHD_UNDIStop(PXE_CDB *cdb_ptr,
               struct dhd_info *dhd)
{
	EFI_TPL tpl;

	WL_LOCK(dhd, tpl);
	if (dhd->UndiState == PXE_STATFLAGS_GET_STATE_INITIALIZED) {
		WL_UNLOCK(dhd, tpl);
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_NOT_SHUTDOWN;
		return;
	}

	/*  Delete the call back function pointers  */
	dhd->UndiState = PXE_STATFLAGS_GET_STATE_STOPPED;
	WL_UNLOCK(dhd, tpl);
}

STATIC VOID
BCMDHD_UNDIGetInitInfo(PXE_CDB *cdb_ptr,	struct dhd_info *dhd)
{
	PXE_DB_GET_INIT_INFO  *db_ptr;
	int i;

	db_ptr = (PXE_DB_GET_INIT_INFO *)(cdb_ptr->DBaddr);

	/* The driver allocates it's own memory */
	db_ptr->MemoryRequired = 0;
	db_ptr->FrameDataLen = 1600;

	for (i = 0; i < 4; i++)
		db_ptr->LinkSpeeds[i] = 0;

	db_ptr->NvCount = 0;
	db_ptr->NvWidth = 0;    /*  dword */
	db_ptr->MediaHeaderLen = PXE_MAC_HEADER_LEN_ETHER;
	db_ptr->HWaddrLen = PXE_HWADDR_LEN_ETHER;

	dhd->nmcastcnt = MIN(MAX_MCAST_ADDRESS_CNT, MAXMULTILIST);
	db_ptr->MCastFilterCnt = dhd->nmcastcnt;

	db_ptr->TxBufCnt = (UINT16)NTXBUF;
	db_ptr->TxBufSize = (UINT16)PKTBUFSZ;
	db_ptr->RxBufCnt = (UINT16)NRXBUF;
	db_ptr->RxBufSize = (UINT16)PKTBUFSZ;
	db_ptr->IFtype = PXE_IFTYPE_ETHERNET;
#if !defined(EDK_RELEASE_VERSION) || (EDK_RELEASE_VERSION < 0x00020000)
	db_ptr->Duplex = 0;
	db_ptr->LoopBack = 0;
#else
	db_ptr->SupportedDuplexModes = 0;
	db_ptr->SupportedLoopBackModes = 0;
#endif
	cdb_ptr->StatFlags = PXE_STATFLAGS_CABLE_DETECT_SUPPORTED;

	return;
}

STATIC VOID
BCMDHD_UNDIGetConfigInfo(PXE_CDB *cdb_ptr,
                        struct dhd_info *dhd)
{
	UINT16 i;
	PXE_DB_GET_CONFIG_INFO  *db_ptr;
	UINT32 value;
	UINTN Seg;

	db_ptr = (PXE_DB_GET_CONFIG_INFO *)(cdb_ptr->DBaddr);

	db_ptr->pci.BusType = PXE_BUSTYPE_PCI;
	dhd->PciIoIntf->GetLocation(dhd->PciIoIntf,
	                           &Seg,
	                           (UINTN *)&db_ptr->pci.Bus,
	                           (UINTN *)&db_ptr->pci.Device,
	                           (UINTN *)&db_ptr->pci.Function);

	for (i = 0; i < MAX_PCI_CONFIG_LEN; i++)  {
		dhd->PciIoIntf->Pci.Read(dhd->PciIoIntf,
		                        EfiPciIoWidthUint32,
		                        i*4,
		                        1,
		                        &value);
		db_ptr->pci.Config.Dword[i] = value;
	}

}

STATIC VOID
BCMDHD_UNDIInitialize(PXE_CDB *cdb_ptr, struct dhd_info *dhd)
{
	int ret = 0;
	int is_up = 0;

	ret = wl_ioctl(&g_dhd_info, WLC_GET_UP, &is_up, sizeof(is_up), IOV_GET);
	if (ret != BCME_OK) {
		DHD_ERROR(("%s: wl get up fails ! err = %d ! \n", __FUNCTION__, ret));
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_DEVICE_FAILURE;
		return;
	}

	if (!is_up) {
		ret = wl_ioctl(&g_dhd_info, WLC_UP, NULL, 0, IOV_SET);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: wl up fails ! err = %d ! \n", __FUNCTION__, ret));
			cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
			cdb_ptr->StatCode = PXE_STATCODE_DEVICE_FAILURE;
			return;
		}
	}
/*
* Do not report 'PXE_STATFLAGS_INITIALIZED_NO_MEDIA' because if we do this,
* ifconfig reports that media is disconnected
* and pings do not go through. It is ok to report PXE_STATFLAGS_INITIALIZED_NO_MEDIA
* when there is another means of reporting media status like the
* 'GetLinkStatus' apple 80211 protocol. But this is not present
* on BRIX x86-64. Later when we get a edk2 olympic setup,
* we may want to revisit this change.
*/
#ifdef EFI_WINBLD
	if ((cdb_ptr->OpFlags != PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE)) {
		cdb_ptr->StatCode = PXE_STATCODE_NOT_STARTED;
		cdb_ptr->StatFlags |= PXE_STATFLAGS_INITIALIZED_NO_MEDIA;
	}
#endif /* EFI_WINBLD */
	dhd->UndiState = PXE_STATFLAGS_GET_STATE_INITIALIZED;

	return;
}

STATIC VOID
BCMDHD_UNDIReset(PXE_CDB *cdb_ptr,
                struct dhd_info *dhd)
{
/* TODO: need to figure out what to do for DHD */
}

STATIC VOID
BCMDHD_UNDIShutdown(PXE_CDB *cdb_ptr,
                   struct dhd_info *dhd)
{
	EFI_TPL tpl;

	WL_LOCK(dhd, tpl);
	dhd->UndiState = PXE_STATFLAGS_GET_STATE_STARTED;
	WL_UNLOCK(dhd, tpl);
}

STATIC VOID
BCMDHD_UNDIInterruptCtrl(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{
	DHD_ERROR(("%s %d OpFlags 0x%x\n", __FUNCTION__, __LINE__, cdb_ptr->OpFlags));
}

STATIC VOID
BCMDHD_UNDIRxFilter(PXE_CDB *cdb_ptr,
                   struct dhd_info *dhd)
{


	UINT16 new_filter, opflags;
	PXE_CPB_RECEIVE_FILTERS *pRxFilter;
	PXE_DB_RECEIVE_FILTERS *pRxReturnFilter;
	UINT32 i, mc_count;
	EFI_TPL tpl;
	struct ether_addr multicast;
	/* TODO: Need to figure out how to get actual multicast address list from dongle FW
	* through the appropriate iovar instead of hardcoding.
	*/
	multicast.octet[0] =  0x01;
	multicast.octet[1]	= 0x00;
	multicast.octet[2]	= 0x5e;
	multicast.octet[3]	= 0x00;
	multicast.octet[4]	= 0x00;
	multicast.octet[5]	= 0x01;

	opflags = cdb_ptr->OpFlags;
	new_filter = opflags &
	        (PXE_OPFLAGS_RECEIVE_FILTER_UNICAST |
	         PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST |
	         PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST |
	         PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS |
	         PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST);

	switch (opflags & PXE_OPFLAGS_RECEIVE_FILTER_OPMASK)   {
	case PXE_OPFLAGS_RECEIVE_FILTER_READ:

		WL_LOCK(wl, tpl);
		if (cdb_ptr->DBsize) {
			pRxReturnFilter = (PXE_DB_RECEIVE_FILTERS *)cdb_ptr->DBaddr;

			bzero((char *)cdb_ptr->DBaddr, (UINT16)cdb_ptr->DBsize);

			bcopy((char *) &multicast.octet[0],
			      (char *)&pRxReturnFilter->MCastList[0],
			      ETHER_ADDR_LEN);
		}

		cdb_ptr->StatFlags |= PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST;
		cdb_ptr->StatFlags |= PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST;
		cdb_ptr->StatFlags |= PXE_STATFLAGS_RECEIVE_FILTER_UNICAST;
		WL_UNLOCK(wl, tpl);
		break;

	case PXE_OPFLAGS_RECEIVE_FILTER_ENABLE:
/* TODO: need to figure out what to do for DHD */
		break;

	case PXE_OPFLAGS_RECEIVE_FILTER_DISABLE:
/* TODO: need to figure out what to do for DHD */
		break;

	default:
		goto Error;
	}

	return;

Error:
	cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
	cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;

}

STATIC VOID
BCMDHD_UNDIStationAddr(PXE_CDB *cdb_ptr,
                      struct dhd_info *dhd)
{

	PXE_CPB_STATION_ADDRESS *cpb_ptr;
	PXE_DB_STATION_ADDRESS *db_ptr;
	uint8 addr[ETHER_ADDR_LEN];
	uint8 perm_addr[ETHER_ADDR_LEN];
	EFI_TPL tpl;
	EFI_STATUS Status;
	int i = 0;
	int ret = 0;

	/* We want to configure MAC address */
	cpb_ptr = (PXE_CPB_STATION_ADDRESS *)(cdb_ptr->CPBaddr);

	if ((cpb_ptr != NULL) &&
	    (cdb_ptr->CPBsize != sizeof(PXE_CPB_STATION_ADDRESS)))
		goto Error;

	switch (cdb_ptr->OpFlags) {
	case PXE_OPFLAGS_STATION_ADDRESS_WRITE:
		if (cpb_ptr != (UINT64) 0) {
			bcopy(cpb_ptr->StationAddr, addr, ETHER_ADDR_LEN);
			WL_LOCK(dhd, tpl);
			ret = dhd_cur_etheraddr_set(dhd, addr);
			WL_UNLOCK(dhd, tpl);
			if (ret != BCME_OK) {
				DHD_ERROR(("%s: Error setting cur_etheraddr !\n", __FUNCTION__));
				goto Error;
			}
		}
		break;

	case PXE_OPFLAGS_STATION_ADDRESS_RESET: {
		/* Get the perm_etheraddr and set cur_etheraddr to it */
		WL_LOCK(dhd, tpl);
		ret = wl_iovar(dhd, "perm_etheraddr", NULL, 0,
				addr, ETHER_ADDR_LEN, IOV_GET);
		WL_UNLOCK(dhd, tpl);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: Error getting perm_etheraddr !\n", __FUNCTION__));
			goto Error;
		}

		WL_LOCK(dhd, tpl);
		ret = dhd_cur_etheraddr_set(dhd, addr);
		WL_UNLOCK(dhd, tpl);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: Error re-setting cur_etheraddr !\n", __FUNCTION__));
			goto Error;
		}

	}
		break;

	default:
		break;
	}

	if (cdb_ptr->DBaddr != (UINT64)0) {
		/* Upper layer wants to query MAC address */
		db_ptr = (PXE_DB_STATION_ADDRESS *)(cdb_ptr->DBaddr);
		/*  fill it with the new values */
		WL_LOCK(dhd, tpl);
		ret = wl_iovar(dhd, "cur_etheraddr", NULL, 0,
		                     addr, ETHER_ADDR_LEN, IOV_GET);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: Error getting cur_etheraddr !\n", __FUNCTION__));
			goto Error;
		}
		ret = wl_iovar(dhd, "perm_etheraddr", NULL, 0,
		                        perm_addr, ETHER_ADDR_LEN, IOV_GET);
		if (ret != BCME_OK) {
			DHD_ERROR(("%s: Error getting perm_etheraddr !\n", __FUNCTION__));
			goto Error;
		}

		WL_UNLOCK(dhd, tpl);

		bzero(&db_ptr->StationAddr, PXE_MAC_LENGTH);
		bzero(&db_ptr->BroadcastAddr, PXE_MAC_LENGTH);
		bzero(&db_ptr->PermanentAddr, PXE_MAC_LENGTH);

		bcopy(addr, &db_ptr->StationAddr, ETHER_ADDR_LEN);
		bcopy(&ether_bcast, &db_ptr->BroadcastAddr, ETHER_ADDR_LEN);
		bcopy(perm_addr, &db_ptr->PermanentAddr, ETHER_ADDR_LEN);

		DHD_INFO(("%s: sta addr = %x.%x.%x.%x.%x.%x \n", __FUNCTION__,
				addr[0], addr[1], addr[2], addr[3],
				addr[4], addr[5]));
		DHD_INFO(("%s: perm addr = %x.%x.%x.%x.%x.%x \n", __FUNCTION__,
				perm_addr[0], perm_addr[1], perm_addr[2], perm_addr[3],
				perm_addr[4], perm_addr[5]));
	}

	return;
Error:
	cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
	cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;

}

STATIC VOID
BCMDHD_UNDIStatistics(PXE_CDB *cdb_ptr,
                     struct dhd_info *dhd)
{
/* TODO: need to figure out what to do for DHD */
}

STATIC VOID
BCMDHD_UNDIIpToMac(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{

	PXE_CPB_MCAST_IP_TO_MAC *cpb;
	PXE_DB_MCAST_IP_TO_MAC *db_ptr;
	cpb = (PXE_CPB_MCAST_IP_TO_MAC *)(UINTN)cdb_ptr->CPBaddr;
	db_ptr = (PXE_DB_MCAST_IP_TO_MAC *)(UINTN)cdb_ptr->DBaddr;

	if (cdb_ptr->OpFlags & PXE_OPFLAGS_MCAST_IPV6_TO_MAC) {
		/* We don't support IPv6 yet. */
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_UNSUPPORTED;
		return;
	}

	DHD_INFO(("IP = %02d.%02d.%02d.%02d\n",
	          ((UINT8 *)&cpb->IP.IPv4)[0],
	          ((UINT8 *)&cpb->IP.IPv4)[1],
	          ((UINT8 *)&cpb->IP.IPv4)[2],
	          ((UINT8 *)&cpb->IP.IPv4)[3]));

	/* Convert Multicast IP address to Multicast MAC adress per RFC 1112 */
	db_ptr->MAC[0] = 0x01;
	db_ptr->MAC[1] = 0x00;
	db_ptr->MAC[2] = 0x5e;
	db_ptr->MAC[3] = ((UINT8 *)&cpb->IP.IPv4)[1] & 0x7f;
	db_ptr->MAC[4] = ((UINT8 *)&cpb->IP.IPv4)[2];
	db_ptr->MAC[5] = ((UINT8 *)&cpb->IP.IPv4)[3];

	return;

}

STATIC VOID
BCMDHD_UNDINVData(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{
	cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
	cdb_ptr->StatCode = PXE_STATCODE_UNSUPPORTED;
}

STATIC VOID
BCMDHD_UNDIGetStatus(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{
	PXE_DB_GET_STATUS *db_ptr;
	UINT16 tx_buffer_size;
	UINT32 i;
	EFI_TPL tpl;

	if (cdb_ptr->DBsize == 0) {
		DHD_ERROR(("UM_UNDIGetStatus(): DBsize is zero\n"));
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;
		return;
	}

	db_ptr = (PXE_DB_GET_STATUS *)cdb_ptr->DBaddr;
	if (spktq_n_pkts(&dhd->q_rx_sendup) > 0) {
		struct EFI_PKT *pkt = spktq_peek(&dhd->q_rx_sendup);
		db_ptr->RxFrameLen = (UINT32)pkt->BufferSize;
	} else {
		db_ptr->RxFrameLen = 0;
		}

	db_ptr->reserved = 0;

	if (spktq_n_pkts(&dhd->q_tx_done) == 0)
		cdb_ptr->StatFlags |= (PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN |
		                       PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY);

	/* Update the interrupt status first before dequeueing */
	if (cdb_ptr->OpFlags & PXE_OPFLAGS_GET_INTERRUPT_STATUS) {
		/* Set the interrupt status based on whether packets are there */
		if (spktq_n_pkts(&dhd->q_rx_sendup) > 0) {
			cdb_ptr->StatFlags |= PXE_STATFLAGS_GET_STATUS_RECEIVE;
		}

		if (spktq_n_pkts(&dhd->q_tx_done) > 0) {
			cdb_ptr->StatFlags |= PXE_STATFLAGS_GET_STATUS_TRANSMIT;
		}
	}

	/* Enqueue as many tx buffers as possible based on remaining DBsize */
	if (cdb_ptr->OpFlags & PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS) {
		/* Decrement to account for first 2 UINT32 fields */
		tx_buffer_size = cdb_ptr->DBsize - sizeof(UINT64);
		cdb_ptr->DBsize = sizeof(UINT64);
		i = 0;
		while (!spktq_empty(&dhd->q_tx_done) &&
		      tx_buffer_size >= sizeof(UINT64)) {
			struct EFI_PKT *pkt = spktdeq(&dhd->q_tx_done);
			dhd->txpendcnt--;
			db_ptr->TxBuffer[i] = (UINT64)pkt->Buffer;
			MFREE(dhd->pub.osh, pkt, sizeof(struct EFI_PKT));
			i++;
			tx_buffer_size -= sizeof(UINT64);
		}
	}
}


STATIC VOID
BCMDHD_UNDIFillHeader(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{

	PXE_CPB_FILL_HEADER *cpb;
	PXE_CPB_FILL_HEADER_FRAGMENTED *cpbf;
	struct ether_header  *mac_hdr;
	UINTN i;

	if (cdb_ptr->CPBsize == PXE_CPBSIZE_NOT_USED) {
		cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
		cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;
		DHD_ERROR(("%s:PXE_CPBSIZE_NOT_USED is set, return failure! \n", __FUNCTION__));
		return;
	}

	if (cdb_ptr->OpFlags & PXE_OPFLAGS_FILL_HEADER_FRAGMENTED) {
		cpbf = (PXE_CPB_FILL_HEADER_FRAGMENTED *)cdb_ptr->CPBaddr;

		/*  Assume 1st fragment is big enough for the mac header */
		if (!cpbf->FragCnt || cpbf->FragDesc[0].FragLen < PXE_MAC_HEADER_LEN_ETHER) {
			/*  no buffers given */
			DHD_ERROR(("%s: no buffers ! \n", __FUNCTION__));
			cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;
			cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;
			return;
		}

		mac_hdr = (struct ether_header *)cpbf->FragDesc[0].FragAddr;
		mac_hdr->ether_type = cpbf->Protocol;

		for (i = 0; i < PXE_HWADDR_LEN_ETHER; i++) {
			mac_hdr->ether_dhost[i] =  cpbf->DestAddr[i];
			mac_hdr->ether_shost[i]  = cpbf->SrcAddr[i];
		}
	} else {
		cpb = (PXE_CPB_FILL_HEADER *)cdb_ptr->CPBaddr;

		mac_hdr = (struct ether_header *)cpb->MediaHeader;
		mac_hdr->ether_type = cpb->Protocol;

		for (i = 0; i < PXE_HWADDR_LEN_ETHER; i++) {
			mac_hdr->ether_dhost[i] =  cpb->DestAddr[i];
			mac_hdr->ether_shost[i]  = cpb->SrcAddr[i];
		}
	}
}

STATIC VOID
BCMDHD_UNDITxPacket(PXE_CDB *cdb_ptr,
	struct dhd_info *dhd)
{
	PXE_CPB_TRANSMIT *tx_ptr_1;
	struct EFI_PKT *pxe_pkt;
	void *pkt;
	EFI_TPL tpl;

	WL_LOCK(dhd, tpl);
	if (cdb_ptr->CPBsize == PXE_CPBSIZE_NOT_USED) {
		cdb_ptr->StatCode = PXE_STATCODE_INVALID_CDB;
		goto Error;
	}

	if (dhd->TxFlowControl == TRUE) {
		cdb_ptr->StatCode = PXE_STATCODE_QUEUE_FULL;
		goto Error;
	}

	if (cdb_ptr->OpFlags & PXE_OPFLAGS_TRANSMIT_FRAGMENTED) {
		cdb_ptr->StatCode = PXE_STATCODE_UNSUPPORTED;
		goto Error;
	}

	tx_ptr_1 = (PXE_CPB_TRANSMIT *)cdb_ptr->CPBaddr;

	if (!tx_ptr_1->FrameAddr || !tx_ptr_1->DataLen) {
		DHD_ERROR(("%s: invalid tx pkt ! \n", __FUNCTION__));
		goto Error;
	}

	pxe_pkt = MALLOC(dhd->pub.osh, sizeof(struct EFI_PKT));

	if (pxe_pkt == NULL) {
		cdb_ptr->StatCode = PXE_STATCODE_NOT_ENOUGH_MEMORY;
		goto Error;
	}

	/* Fill in pxe_pkt information */
	pxe_pkt->Link = NULL;
	pxe_pkt->Buffer = (void *)(uintptr)tx_ptr_1->FrameAddr;
	pxe_pkt->BufferSize = tx_ptr_1->DataLen;

	/* Following are being ignored for now */
	pxe_pkt->HeaderSize = tx_ptr_1->MediaheaderLen;
	pxe_pkt->SrcAddr = NULL;
	pxe_pkt->DestAddr = NULL;
	pxe_pkt->Protocol = NULL;

	if ((pkt = PKTFRMNATIVE(dhd->pub.osh, pxe_pkt)) == NULL) {
		MFREE(dhd->pub.osh, pxe_pkt, sizeof(struct EFI_PKT));
		pxe_pkt = NULL;
		cdb_ptr->StatCode = PXE_STATCODE_NOT_ENOUGH_MEMORY;
		goto Error;
	}

	dhd_sendpkt(&dhd->pub, 0, pkt);
	dhd->txpendcnt++;
	WL_UNLOCK(dhd, tpl);

	return;

Error:
	WL_UNLOCK(dhd, tpl);
	cdb_ptr->StatFlags = PXE_STATFLAGS_COMMAND_FAILED;

}

STATIC VOID
BCMDHD_UNDIRxPacket(PXE_CDB *cdb_ptr,
                   struct dhd_info *dhd)
{
	PXE_CPB_RECEIVE *pRxCpd;
	PXE_DB_RECEIVE *pRxDb;
	struct EFI_PKT *pxe_pkt;
	UINT32 CopyLen;
	EFI_TPL tpl;

	pRxCpd = (PXE_CPB_RECEIVE *)cdb_ptr->CPBaddr;
	pRxDb = (PXE_DB_RECEIVE *)cdb_ptr->DBaddr;


	WL_LOCK(dhd, tpl);
	if (spktq_empty(&dhd->q_rx_sendup)) {
		cdb_ptr->StatCode = PXE_STATCODE_NO_DATA;
		WL_UNLOCK(dhd, tpl);
		return;
	}

	pxe_pkt = spktdeq(&dhd->q_rx_sendup);
	WL_UNLOCK(dhd, tpl);

	CopyLen  = MIN((UINT32)pxe_pkt->BufferSize, pRxCpd->BufferLen);

	bcopy(pxe_pkt->Buffer, pRxCpd->BufferAddr, CopyLen);

	pRxDb->FrameLen = (UINT32)pxe_pkt->BufferSize;
	pRxDb->MediaHeaderLen = PXE_MAC_HEADER_LEN_ETHER;
	if (ETHER_ISBCAST(pxe_pkt->DestAddr))
		pRxDb->Type = PXE_FRAME_TYPE_BROADCAST;
	else if (ETHER_ISMULTI(pxe_pkt->DestAddr))
		pRxDb->Type = PXE_FRAME_TYPE_MULTICAST;
	else
		pRxDb->Type = PXE_FRAME_TYPE_UNICAST;

	bcopy(pxe_pkt->SrcAddr, pRxDb->SrcAddr, ETHER_ADDR_LEN);
	bcopy(pxe_pkt->DestAddr, pRxDb->DestAddr, ETHER_ADDR_LEN);
	pRxDb->Protocol = *pxe_pkt->Protocol;

	MFREE(dhd->pub.osh, pxe_pkt->Buffer, (uint)pxe_pkt->BufferSize);
	MFREE(dhd->pub.osh, pxe_pkt, sizeof(struct EFI_PKT));

}

#endif /* BCMWLUNDI */

static int
dhd_cur_etheraddr_set(dhd_info_t *dhd, uint8 *addr)
{
	int err;

	err = wl_iovar(dhd, "cur_etheraddr", NULL, 0,
	                     addr, ETHER_ADDR_LEN, IOV_SET);

	/* Update 80211proto address */
	if (err == BCME_OK)
		bcopy(addr, &dhd->apple80211_proto.mode->HwAddress, ETHER_ADDR_LEN);

	return err;
}


int
wl_iovar(dhd_info_t *dhd, const char *name, void *params, size_t p_len,
            void *buf, size_t len, bool set)
{
	int ret;
	int iovar_len;
	uint buflen = sizeof(ioctl_buf);

	memset(ioctl_buf, 0, sizeof(ioctl_buf));
	iovar_len = bcm_mkiovar((char *)name, (char*)params, (uint)p_len, ioctl_buf, buflen);
	if (iovar_len == 0) {
		DHD_ERROR(("%s: insufficient buffer space passed to bcm_mkiovar for name %s\n",
		           __FUNCTION__, name));
		return BCME_BUFTOOSHORT;
	}
	if (set) {
		if (len+iovar_len > buflen) {
			printf("%s: buffer too short\n", __FUNCTION__);
			return BCME_BUFTOOSHORT;
		}
		memcpy(ioctl_buf + iovar_len, buf, len);
		iovar_len += (int)len;
	}

	ret =  wl_ioctl(dhd, (set) ? WLC_SET_VAR : WLC_GET_VAR,
			ioctl_buf, (set) ? iovar_len : buflen, set);
	if (ret < 0) {
		DHD_ERROR(("%s wlIoctl failed. name %s, ret %d\n",
			__FUNCTION__, name, ret));
	}
	else if (!set) {
		memcpy(buf, ioctl_buf, len);
	}
	return ret;
}

int
wl_ioctl(dhd_info_t *dhd, uint cmd, void *arg, size_t len, bool set)
{
	int ret = -1;
	dhd_ioctl_t *ioc = NULL;
	void *internal_buf = NULL;
	uint buflen = 0;
	int ifidx = 0;

	ret = dhd_wl_ioctl_cmd(&dhd->pub, cmd, arg, (int)len, set, ifidx);
	if (ret < 0 && cmd != WLC_GET_BSSID) {
		DHD_ERROR(("%s: dhd_wl_ioctl_cmd failed. cmd %d, ret %d, ifidx = %d\n",
			__FUNCTION__, cmd, ret, ifidx));
	}

	return ret;
}

int
dhd_os_get_cur_priority_level()
{
	EFI_TPL cur_tpl;

	cur_tpl = gBS->RaiseTPL(EFI_TPL_CALLBACK);
	gBS->RestoreTPL(cur_tpl);

	return (int)cur_tpl;
}

void
dhd_os_sdlock(dhd_pub_t *pub)
{

}

void
dhd_os_sdunlock(dhd_pub_t *pub)
{

}

void *
dhd_os_spin_lock_init(osl_t *osh)
{
	EFI_LOCK *lock = NULL;
	lock = MALLOC(osh, sizeof(EFI_LOCK));
	if (!lock)
		return NULL;

	EfiInitializeLock(lock, DHD_LOCK_LEVEL_HIGH);

	return (void *)lock;
}

void
dhd_os_spin_lock_deinit(osl_t *osh, void *lock)
{
	MFREE(osh, lock, sizeof(EFI_LOCK));
}

unsigned long
dhd_os_spin_lock(void *lock)
{
	EfiAcquireLock((EFI_LOCK *)lock);
	return 0;
}

void
dhd_os_spin_unlock(void *lock, unsigned long flags)
{
	EfiReleaseLock((EFI_LOCK *)lock);
}

void
dhd_os_wd_timer(void *bus, uint wdtick)
{
	dhd_pub_t *pub = bus;
	dhd_info_t *dhd = (dhd_info_t *)pub->info;

	DHD_TRACE(("%s: Enter\n", __FUNCTION__));

	if (!dhd) {
		DHD_ERROR(("%s: dhd NULL\n", __FUNCTION__));
		return;
	}

	/* don't start the wd until fw is loaded */
	if (pub->busstate == DHD_BUS_DOWN)
		return;

	/* Totally stop the timer */
	if (!wdtick) {
		gBS->SetTimer(dhd->watchdog_timer, TimerCancel, 0);
		return;
	}

	if (wdtick) {
		dhd_watchdog_ms = (uint)wdtick;
		gBS->SetTimer(dhd->watchdog_timer, TimerRelative,
			dhd_watchdog_ms * EFI_DHD_MS_NS_CONVERSION_UNIT);
	}
}

void
dhd_os_dhdiovar_lock(dhd_pub_t *pub)
{
	dhd_info_t *dhd = NULL;

	ASSERT(pub);
	dhd = (dhd_info_t *)pub->info;
	ASSERT(dhd);

	EfiAcquireLock(&dhd->proto_lock);
}

void
dhd_os_dhdiovar_unlock(dhd_pub_t *pub)
{
	dhd_info_t *dhd = NULL;

	ASSERT(pub);
	dhd = (dhd_info_t *)pub->info;
	ASSERT(dhd);

	EfiReleaseLock(&dhd->proto_lock);
}

int dhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pkt)
{
	int ret;

	ASSERT(pkt);

	ret = dhd_flowid_update(dhdp, ifidx, dhdp->flow_prio_map[(PKTPRIO(pkt))], pkt);
	if (ret != BCME_OK) {
		return ret;
	}

	ret = dhd_bus_txdata(dhdp->bus, pkt, ifidx);
	if (ret != BCME_OK) {
		DHD_ERROR(("%s: dhd_bus_txdata failed! err = %d \n", __FUNCTION__, ret));
	}

	return ret;
}

#ifdef DHD_LOG_DUMP
void
dhd_log_dump_init(dhd_pub_t *pub)
{
	memset(&g_fwlog_ring_buf, 0, sizeof(g_fwlog_ring_buf));

	g_fwlog_ring_buf.buffer = MALLOCZ(pub->osh, DHD_LOG_DUMP_BUFFER_SIZE);

	if (!g_fwlog_ring_buf.buffer) {
		DHD_ERROR(("%s: Failed to allocate memory for fw log ring buffer !\n",
				__FUNCTION__));
	}

	g_fwlog_ring_buf.wraparound = 0;
	g_fwlog_ring_buf.max = (unsigned long)g_fwlog_ring_buf.buffer + DHD_LOG_DUMP_BUFFER_SIZE;
	g_fwlog_ring_buf.present = g_fwlog_ring_buf.buffer;
	g_fwlog_ring_buf.front = g_fwlog_ring_buf.buffer;
	g_fwlog_ring_buf.remain = DHD_LOG_DUMP_BUFFER_SIZE;
	g_fwlog_ring_buf.enable = 1;
}

void
dhd_log_dump_deinit(dhd_pub_t *pub)
{
	g_fwlog_ring_buf.enable = 0;
	if (g_fwlog_ring_buf.buffer) {
		MFREE(pub->osh, g_fwlog_ring_buf.buffer, DHD_LOG_DUMP_BUFFER_SIZE);
		g_fwlog_ring_buf.buffer = NULL;
	}
}


void
dhd_log_dump_print(const char *fmt, ...)
{
	int len = 0;
	char tmp_buf[DHD_LOG_DUMP_MAX_TEMP_BUFFER_SIZE] = {0, };
	va_list args;
	unsigned long flags = 0;

	if (g_fwlog_ring_buf.enable != 1 || !g_fwlog_ring_buf.buffer) {
		return;
	}

	va_start(args, fmt);

	len = vsnprintf(tmp_buf, DHD_LOG_DUMP_MAX_TEMP_BUFFER_SIZE, fmt, args);
	if (len < 0) {
		return;
	}

	if (g_fwlog_ring_buf.remain < len) {
		g_fwlog_ring_buf.wraparound = 1;
		g_fwlog_ring_buf.present = g_fwlog_ring_buf.front;
		g_fwlog_ring_buf.remain = DHD_LOG_DUMP_BUFFER_SIZE;
	}

	strncpy(g_fwlog_ring_buf.present, tmp_buf, len);
	g_fwlog_ring_buf.remain -= len;
	g_fwlog_ring_buf.present += len;

	/* double check invalid memory operation */
	ASSERT((unsigned long)g_fwlog_ring_buf.present <= g_fwlog_ring_buf.max);
	va_end(args);
}

char*
dhd_log_dump_get_timestamp(void)
{
	static char buf[32];
	EFI_TIME cur_ts;

	memset(&cur_ts, 0, sizeof(cur_ts));
/* TODO: as of now GetTime API is working only in EDK1.02
* on EDK 2.0 x86-64 BRIX platform its causing a crash
* need to fix this later
*/
#if !defined(EDK_RELEASE_VERSION) || (EDK_RELEASE_VERSION < 0x00020000)
	gRT->GetTime(&cur_ts, NULL);
#endif
	snprintf(buf, sizeof(buf), "%2u-%2u-%2u_%2u.%2u.%2u.%u]",
			cur_ts.Year, cur_ts.Month, cur_ts.Day,
			cur_ts.Hour, cur_ts.Minute, cur_ts.Second,
			cur_ts.Nanosecond);

	return buf;
}


#endif /* DHD_LOG_DUMP */
