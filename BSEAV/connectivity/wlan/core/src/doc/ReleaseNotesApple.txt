
BROADCOM PROPRIETARY AND CONFIDENTIAL INFORMATION/SUBJECT TO NDA

***
*** Release notes from 3.120.28 to 3.130.20.1
***

Major features added include:
o Multiple SSID support
o Simultaneous AP and STA support
o Afterburner over WDS
o Secure Easy Setup over WDS
o Save/Restore of NVRAM
o AP Support for 802.11h+d

Specifics on feature restrictions and use for some of these are provided 
in greater detail in sections below.

As a result of these and other changes, there are a number of changes to
the driver per-port API(s).

- Virtual Interface Creation

  When more than one SSID configuration is enabled (for MSSID or APSTA) it
  will need to have a virtual interface for the upper edge of the driver
  similar to how we implement WDS links.  The interface creation and
  deletion functions formerly required for WDS have been extended to handle
  BSS (i.e. non-WDS) interfaces as well.

  The new wl_add/del_if() functions replace the wl_add/del_wds() functions:

    void wl_del_if(struct wl_info *wl, struct wl_if *wlif);
  
    struct wl_if *wl_add_if(struct wl_info *wl, struct wlc_if* wlcif,
                            uint unit, struct ether_addr *remote);

  The "remote" parameter points as before to the MAC address of a WDS peer;
  a NULL indicates that this is a BSS (non-WDS) interface.  

  The wl_if* returned by the creation function is used as the wl_sendup()
  parameter.  The wlc_if* parameter passed in the creation function is what
  the per-port code now uses for wlc_sendpkt() and wlc_ioctl() calls.

    void wl_sendup(struct wl_info *wl, struct wl_if *wlif, void *p);

    bool wlc_sendpkt(wlc_info_t *wlc, void *sdu, struct wlc_if *wlc_if);

    int wlc_ioctl(struct wlc_info *wlc, int cmd, void *arg, int len,
                  struct wlc_if *wlcif);

  These three functions interpret a NULL pointer to indicate the primary
  interface; this helps simplify any per-port code which does not require
  the use of virtual interfaces.

  Use of the "remote" parameter in wl_add_if() above allows the per-port
  code to distinguish WDS and BSS interfaces where necessary (for example:
  interface naming; interface plumbing; type-specific ioctl handling.)

  The sample VX driver provided names the primary interface "wlN"; virtual
  WDS and BSS interfaces are "wdsX" and "wlmbssX" respectively, where
  where X = N<<8 + M, N being the wl interface unit number and N the wds or
  bss unit number.  (For example: wl0 and wlmbss1, wl1 and wds257.)  For WDS
  interfaces, it also adds them to the bridge automatically; it also handles
  WLC_WDS_GET_REMOTE_HWADDR commands and rejects EIOCSADDR for WDS.

  The updated prototypes and forward declarations can be found in
  src/wl/sys/wl_export.h and src/wl/sys/wlc_pub.h; the per-port code for the
  sample VX driver is in src/wl/sys/wl_vx.c.

- Event Indications
  
  The wlc_event_t structure used as a parameter to wl_event() has been
  modified.  The definition in src/include/wlioctl.h, but now includes a
  wl_event_msg_t substructure defined in src/common/include/proto/bcmevent.h. The
  event type definitions have been moved from wlioctl.h to bcmevent.h as
  well.  Some differences of note:

    o Elimination of the "link", "group", and "flush_txq" fields; these are
      replaced by bits in the new "flags" field of the wl_event_msg_t.

    o The event code is in the "event_type" field of the wl_event_msg_t
      structure.

    o In addition to the definition of new events, the actual event numbers
      have all be shifted down one (zero-based rather than one-based).

    o The new wlc_event_t structure includes a "next" pointer, used
      internally by the common code; is it NOT intended to be interpreted by
      the per-port wl_event() function.

  Refer to the relevant portions of wlioctl.h, bcmevent.h, and wl_vx.c.

  One reason for these change is to unify and enhance delivery of events
  through encapsulated ethernet frames.  The EAPOL and WPA Messages are
  still passed to NAS using an ethernet encapsulation, which is now shared
  with delivery of other events.  Notable changes include:

    o The wl_secpvt_data_t structure has been removed from wlioctl.h;
      encapsulated messages now use the bcm_event_t structure defined in
      bcmevent.h, which includes a wl_event_msg_t structure (see above).

    o The BCMILCP_BCM_SUBTYPE_WPA and BCMILCP_BCM_SUBTYPE_EAPOL definitions
      have been removed, the corresponding event sets are now delivered
      using the BCMILCP_BCM_SUBTYPE_EVENT subtype.

    o The source MAC address used in the ethernet header is now the MAC
      address of the WLAN interface; modified to have the locally-assigned
      bit set.  The remote address, if applicable for the event, appears
      only within the event data.

    NOTE: The locally-assigned address bit is turned on to prevent the
    inadvertant caching of the actual WLAN address by the client bridge
    code.  Since all event messages are destined to the WLAN address, a
    bridge which learns this address on a port might prevent subsequent
    event messages from that same port from being delivered to local clients
    (such as NAS).  We have seen this issue on the version of the VX bridge
    used in our sample port.

    o Event callbacks have been similarly modified; the wlc_event_cb_t
      definition has been moved from wlioctl.h to bcmevent.h, and the
      callback function takes a bcm_event_t* as a parameter, rather than a
      wlc_event_t*.

    o Callback registration is no longer per-event-type; a single callback
      function is registered, which receives all events requested.

    o Event messages and callbacks are requested using two new iovars: 

      Name: event_msgs
      Type: 128-bit vector
      Default: 0
      Notes: 128-bit vector of bit enables to selectively enable or disable
      the reporting of MAC events via the packet data path. For example,
      setting bit locations 0 and 3 would enable the reporting of
      WLC_E_SET_SSID and WLC_E_AUTH event messages.

      Name: eventing
      Type: 128-bit vector
      Default: 0xffffffff

      Notes: 128-bit vector of bit enables to selectively enable or disable
      the reporting of MAC events via the control path. For example, setting
      bit locations 0 and 3 would enable the reporting of WLC_E_SET_SSID and
      WLC_E_AUTH event messages.

      See the definition of WL_EVENTING_MASK_LEN in wlioct.h

- Other OSL and Per-Port Changes

  - Change to the osl/drv cookie usage.

    The code has been changed to remove references to the drv cookie and
    encapsulate this information in the osl cookie.

    XXX_osl.c:
      This module now has to include a struct os_handle {} declaration which 
      contains any information required by the osl.  This info should be
      passed as args to osl_alloc(), which will return a pointer to an osl_t
      type.  All osl functionality should take osl_t *osh as an argument,
      rather than void *drv and/or void *osh (as previously implemented).
 
    XXX_osl.h :
      Any osl api call should use the osl_t *osh arg instead of void *drv or
      void *osh. Note that this alters the PKTXXXX macros and their usage. 

    MALLOC()/MFREE():
      This functionality should allow for a NULL pointer to be passed in as
      the osl arg. If MALLOC() is passed a NULL pointer, the corresponding
      MFREE() call must also be passed a NULL. MALLOC()/MFREE() should be
      passed a valid osl_t * unless it is unreasonable to do so.
 
    Note: The XXX_osl.c and wl_XXX.c files may include "osl.h", rather than
    "XXX_osl.h" directly; "osl.h" contains a forward declaration for typedef
    struct os_handle osl_t.  Otherwise the forward declaration must be
    included in the XXX_osl.h file.

  - The wlc_attach() function no longer takes a void *drv, and the void *dev
    parameter has been changed to an osl_t *osh.

  - The XXX_osl.h file should have definitions for OSL_PCI_BUS() and
    OSL_PCI_SLOT() macros to satisfy references in src/shared/siutils.c

   Refer to the files wl_vx.c, vx_osl.c, and vx_osl.h for examples.

- Access to LED (GPIO) pins has been changed since the 3.90.34 release.
  As in the 3.120.28 release, WL-internal use of the LEDs uses sb
  functions (sb_gpioled(), sb_gpioout(), sb_gpioouten()) rather than
  direct register writes (see wlc_led.c).
  
  This allows coordination with applications using the GPIO/LED pins
  through the libbcm library.  The libbcm library is available to apps
  both in Linux and VxWorks; see SES for an example of a gpio user, and
  src/router/libbcm/bcmgpio.h for the interface.

- AP support for 5 GHz Radar regulations for Dynamic Frequency Selection
  (DFS) and Channel Availability Check (CAC) are provided with 802.11h
  mechanisms.

    Name: dfs_channel_forced
    Type: uint32
    Default: 0 (not forced)
    Notes: The immmediate next dfs channel is forced to this channel;
    facilitates testing.

    Name: dfs_ism_monitor
    Type: bool
    Default: false
    Notes: A true value forces In Service Mode (ISM) to monitor-only mode.
    This disables channel switching; on detecting radar a message will be
    displayed, but the channel will not be changed and no Channel Switch
    Announcement will be sent.  THIS IS INTENDED FOR TEST PURPOSES ONLY,
    AS IT VIOLATES THE 802.11H RADAR REGULATIONS.

    Name: dfs_postism
    Type: uint32
    Default: 60
    Notes: In Service Mode Channel Availability Check, aka Post-ISM CAC time:
    number of seconds to spend listening for radar when an AP switches to a
    new channel when using 802.11H. 

    Name: dfs_preism
    Type: uint32
    Default: 60
    Notes: Pre network initiation Channel Availability Check, aka Pre-ISM CAC
    time: number of seconds to spend listening for radar before initiating a
    network. Used when in 802.11H mode. 

    Name: dfs_status
    Type: wl_dfs_status_t
    Default: N/A
    Notes: Reports the status of dfs processing.

  In addition, the following iovar has been modified:

    Name: chan_info
    Type: channel_info_t
    Default: N/A
    Notes: Provides detailed information on each channel; the remaining DFS 
    Non-Occupancy Period (in minutes) is included in the high 8 bits.

- Afterburner over WDS support.  If afterburner is enabled, and all APs
  connected support it, then afterburner will be used throughout the WDS
  network.  If an AP has to disable afterburner (e.g. due to association of
  an afterburner-incapable STA) then afterburner will be disabled throughout
  the WDS network as long as that situation persists.  All changes are
  internal to the common code, with no configuration required.

- Secure Easy Setup (SES) over WDS.  The router code drop includes
  additional SES client mode, which can be used to automatically configure
  the WDS link between two devices, or a device in WET mode.  This is
  implemented using the files in src/router/ses and src/ses/client.

- Other ioctl and iovar changes:

  o The following deprecated ioctls have been removed, in some cases
    equivalent or similar functionality is available via iovars as
    indicated:
    - WLC_SET_RATE                      -> bg_rate, a_rate
    - WLC_GET/SET_FRAG                  -> fragthresh
    - WLC_GET/SET_RTS                   -> rtsthresh
    - WLC_GET/SET_WEP                   -> wsec
    - WLC_GET/SET_TXPWR                 -> qtxpower
    - WLC_GET/SET_MRATE                 -> bg_mrate, a_mrate
    - WLC_GET/SET_FAST_TIMER            -> fast_timer
    - WLC_GET/SET_SLOW_TIMER            -> slow_timer
    - WLC_GET/SET_GLACIAL_TIMER         -> glacial_timer
    - WLC_GET/RESET_D11CNTS             -> counters, reset_d11cnts

  o The WLC_SET_LOCALE ioctl is deprecated in favor of WLC_SET_COUNTRY, but
    has not actually been removed (though its constant ID has changed).

  o The following iovars have been removed:
    - "rate_override"
    - "wep"

  o The following iovar has been changed:
    - "bcmerrstr" becomes "bcmerrorstr"

  o The following is a summary of additional iovars that have been added;
    some are specific to MSSID or APSTA support, and may be described in
    more detail in subsequent sections.

    Name: apsta
    Type: bool
    Default: false
    Notes: Puts the driver into (or out of) apsta mode, where bsscfg 0 is
    STA and bsscfg 1 is AP.  Should only be used after WLC_SET_AP has set
    overall driver mode to AP.

    Name: apsta_dbg
    Type: int
    Default: 0
    Notes: For additional internal debugging control.

    Name: assoc_info
    Type: buffer
    Default: N/A
    Notes: Returns a wl_assoc_info_t struct (wlioctl.h) with association
    pkts lengths & 802.11 headers.

    Name: assoc_req_ies
    Type: buffer
    Default: N/A
    Notes: Returns the IE portion of the most recent association request.

    Name: assoc_resp_ies
    Type: buffer
    Default: N/A
    Notes: Returns the IE portion of the most recent association response.

    Name: bcmerror
    Type: int
    Default: N/A
    Notes: Get the error code corresonding to the last configuration error.

    Name: bss
    Type: buffer
    Default: N/A
    Notes: Sets or returns the status of a BSS configuration.  The first int
    in the buffer is the bsscfg index.  On a set, this is followed by a
    second int interpreted as a bool to bring up (true) or down (false) the
    BSS.  On a get, the return value indicates the current state.

    Name: closednet
    Type: bool (bsscfg indexed)
    Default: false
    Notes: This is the BSS Configuration Closed Network attribute. When an
    AP's BSS is a Closed Network, the SSID is replaced by NULL characters in
    the Beacon, and the AP only responds to Probe Requests with the AP's
    configured SSID.  The value can only be changed when the indexed BSS
    Configuration is disabled.

    Name: counters
    Type: buffer
    Default:
    Notes: Read-Only.  Get a buffer of type wl_cnt_t containing uint32
    counter values maintained by the driver and ucode. Most of these
    counters are the same ones that show up in "wl dump" output for a debug
    build of a driver.

    Name: country_list_extended
    Type: bool
    Default: false
    Notes: Controls what is reported in GET_COUNTRY_LIST.  Does not affect
    any other operation.  True value causes all countries to be reported;
    false causes Japan-variants such as J1 and J2 to be omitted in
    GET_COUNTRY_LIST; JP, which is the country code for JAPAN, is reported
    independently of country_list_extended setting.

    Name: mssid
    Type: bool
    Default: FALSE
    Notes: This flag can only be set when driver is down. If true, the user
    can bring up multiple configurations; if false, multiple configurations
    can still be defined but not brought up.

    Name: pmkid_info
    Type: buffer
    Default: N/A
    Notes: Sets/gets the pmkid cache table via the pmkid_list_t struct
    defined in wlioctl.h

    Name: radarargs
    Type: buffer
    Interface: wl_radar_args_t
    Default: N/A
    Notes: It controls radar detection parameters.  In the wl_radar_args_t
    structure: 
      npulses - required number of pulses at n * t_int
      ncontig - required number of pulses at t_int
      min_pw - minimum pulse width (20 MHz clocks)
      max_pw - maximum pulse width (20 MHz clocks)

    Name: reset_d11cnts
    Type: N/A
    Notes: Updates txrts, rxcrc, and txnocts counters; clears the other
    D11-specific counters.

    Name: ssid
    Type: wlc_ssid (bsscfg indexed)
    Default: ""
    Notes: This is the BSS Configuration's SSID. For an AP, it will be the
    SSID of the BSS, or for a STA, it specifies the BSS to join, or the IBSS
    to join or create. The value can only be changed when the indexed BSS
    Configuration is disabled.

    Name: wpa_auth
    Type: uint32 (bsscfg indexed)
    Default: 0
    Notes: Per-BSS version of the WLC_SET_WPA_AUTH ioctl.

    Name: wsec
    Type: uint32 (bsscfg indexed)
    Default: 0
    Notes: Specifies the encryption types configured for the BSS.

    Name: wsec_restrict
    Type: bool (bsscfg indexed)
    Default: FALSE
    Notes: Flag for policy of accepting unencrypted packets. If TRUE, drop
    unencrypted packets if wsec is enabled for the bsscfg.
    
    Name: wsec_key
    Type: wl_wsec_key_t (bsscfg indexed)
    Default: n/a
    Notes: Write-Only. Add or delete a wsec key. The wl_wsec_key_t struct
    specifes a specific MAC address if this is a paired key, or just the
    KeyID if it is a group key. Group keys will be programned for the bsscfg
    specified.

- Multiple SSID Support (MSSID) and APSTA configuration.

  Support for a second simultaneous SSID is included in this release.  This
  second BSS is supported only to the extent that it may have a different
  SSID and security configuration -- most other configuration settings (such
  as channel, rateset, and so forth) it shares with the first (primary) BSS;
  there is also a single beacon advertising the primary SSID, though probes
  for either SSID are answered independently.

  For the second BSS, the driver allows a separate set of configuration
  parameters (referred to here as a bsscfg) and a separate interface to the
  OS (see Virtual Interface Creation, above).  To configure and control WL
  behavior on a per-BSS basis, some iovars and ioctls have been "indexed" to
  allow per-BSS configuration -- but most controls still apply to the
  physical interface, and so affect driver behavior on both the "primary"
  (or "parent") and "secondary" (or "virtual") BSS.

  Both in-band (on the interface) and out-of-band (through the "parent") may
  be required -- in-band so apps like NAS can operate independently on an
  interface, and out-of-band so startup/configuration apps (like wlconf) can
  create and configure both bsscfgs.

  In general, the BSS for an ioctl/iovar is the one corresponding to the
  interface block (wlif pointer) passed in the wl_ioctl() call.  For an
  iovar, a different BSS may be specified by using the "bsscfg:" prefix for
  the iovar name and adding an index for the value, which is how the "wl
  <var> -C N" commands work.  [As noted above, most ioctls and iovars ignore
  the BSS, since they operate "globally" on the physical interface.]

  The following ioctls/iovars are now bsscfg-aware:

    IOCTL                         IOVAR
    --------                      --------
    WLC_GET/SET_WSEC              wsec
    WLC_SET_KEY                   wsec_key
    WLC_GET/SET_WEP_RESTRICT      wsec_restrict
    WLC_GET/SET_AUTH              auth
    WLC_GET/SET_WPA_AUTH          wpa_auth
    <N/A>                         wpa_cap
    <N/A>                         ap_isolate
    WLC_GET/SET_EAP_RESTRICT      eap_restrict
    WLC_GET/SET_KEY_PRIMARY       <n/a>
    WLC_TKIP_COUNTERMEASURES      <n/a>
    WLC_GET_KEY_SEQ               <n/a>
    WLC_SET_WSEC_PMK              <n/a>

  The following deserve more comment; even some which are not bss-aware
  may operate differently in APSTA mode.

    IOVAR: bss [new]
      - Enable or disable a BSS configuration.
      * NOTE: This is the only iovar that ALWAYS takes a BSS number as the
        first int32 in its argument buffer; it IGNORES the "current bsscfg"
        context from the interface or "bsscfg:" prefix.

    IOVAR: ssid (per-BSS) [new]
      - Sets or gets the SSID in the bsscfg.  The BSS should be disabled
        with the "bss" iovar first.

    IOCTL: WLC_GET/SET_SSID (now per-BSS, otherwise unchanged)
      - On an AP BSS gets or sets from the BSS config, SET restarts the BSS 
        (disables old, enables new).  If set to null (""), leaves disabled. 
      - On the STA BSS, SET breaks the current assoc and starts a new one;
        GET returns SSID from the "current" BSS, i.e. will return empty ("")
        if association to the requested upstream AP has failed.

    IOVAR: closednet (per-BSS) [new]
    IOCTL: WLC_GET/SET_CLOSED (per-BSS)
      - The iovar SET is rejected if the BSS is not "down", but the ioctl
        allows SET while up (but does not take effect immediately).
      - Note: in APSTA mode, the primary BSS is in STA mode, so setting
        "closednet" on bsscfg 0 has no effect; bsscfg 1 must be used.

    IOCTL: WLC_SCB_DEAUTHENTICATE/_FOR_REASON (per-BSS)
      - On the STA, disassociates and disables the BSS, sends a deauth
        to the specified MAC address (or if MAC is bc/mc, to BSSID).
      - For an AP, deauth the specified station, or all within this BSS.

    IOCTL: WLC_SCB_(DE)AUTHORIZE (per-BSS)
      - Broadcast MAC argument means all stations in the specified BSS.
      * NOTE: If a specific MAC is used, acts even if it's associated to a
        different BSS than indicated by the interface in the call.

    IOCTL: WLC_GET_BSS_INFO
      - Returns content of "current_bss" as before.  For an AP this is the
        SSID of BSS 0 (but may have parameters from the first AP BSS up);
        for a STA it's the STA BSS, whose SSID might be empty if not
        associated (see WLC_GET_SSID); for an APSTA it's generally the STA
        BSS but with the configured SSID (even if not now associated). 

    IOCTL: WLC_GET_ASSOCLIST
      - Returns all associated STAs in all BSSs; includes the upstream AP. 

    IOCTL: WLC_GET/SET_AP
      - Global, APSTA is considered an AP.

    IOCTL: WLC_GET_BSSID
      - For APSTA, operates as before on the STA interface, i.e.: error if
        not associated to upstream AP, else return upstream BSSID (0 if
        roaming with link down.)  This is useful for determining link-down
        versus link-up versus never-associated for an APSTA.

    IOVAR: mssid [new]
      - Global.  Must be on for any BSS other than 0 to be enabled.  Turning 
        off forces all BSSs other than 0 to be disabled. 

    IOVAR: apsta [new]
      - Global.  Enables APSTA mode, forcing BSS 0 to STA and BSS 1 to AP;
        also forces INFRA ON, and WET OFF.

  - Summary of MSSID.

    - MSSID Behavior
        - The same BSSID is used for all SSIDs. 
	- Only one Beacon per beacon interval. This may cause compatibility 
          issues since passive scanning would only see the common Beacon and 
	  not the independent Probe Responses, and since some STA 
	  implementations may pay more attention to the Beacon that we do 
	  even when doing active scans. 
	- Only one SSID is present in the Beacon. 
	- WPA IEs for the primary configuration are included in the beacon
	- BRCM IE announces total number of STAs associated to all SSIDs 
	  supported by the AP. 
	- The capability field may not be correct for all SSIDs. 
	- Broadcast/Multicast traffic sent by the AP cannot be differentiated 
	  by SSID since all SSIDs share the same BSSID. This means Bc/Mc 
	  packets for one SSID will not be rejected by address filtering in 
	  STAs belonging to another SSID. 
	  Depending on the combination of security settings, STAs will 
	  encounter many counts for dot11WEPExcludedCount (receiving a 
	  unencrypted frame when encryption is required), 
	  dot11WEPUndecryptableCount (receiving an encrypted frame when 
	  encryption is off), or ICV errors (receiving a frame encrypted with 
	  the wrong key). 
	- Probe responses for the SSIDs have the correct information for the
	  specific SSID. 
	- One SSID will have probe responses sent by ucode, all others will 
	  have probe responses generated in the host driver. Host driver 
	  generated probe responses may not meet the 5 ms Wi-Fi turnaround 
	  time. This may cause compatibility issues. 
        - The association limit is a global limit of the total number of 
	  stations associated to all the SSIDs.
        - There is a single MAC access list that is applied globally to all 
	  SSIDs
    
    - To turn on MSSID:
      - Set the driver to AP mode.
      - Enable the "mssid" iovar.
      - Do the desired per-BSS configurations (e.g. ssid and security) using
        per-BSS iovars.
      - Do any other desired global configuration (e.g. WLC_SET_CHANNEL).
      - Bring the driver up using WLC_UP.
      - Enable each BSS using the "bss" iovar.

      * In general, refer to startup files wlconf.c, apbase.c, apconf.c for
        example usage.

    - The WL driver does not forward frames between its BSSs directly, but
      will send them up the stack for forwarding; it is up to the client
      software to determine any additional bridging, routing, NAT, or
      firewall restrictions.

    - Note that in the MSSID context, WDS links to the AP are considered
      part of the primary BSS.

  - Summary of APSTA.

    When operating in APSTA mode, the driver treats bsscfg 0 as its STA
    configuration, meaning it will attempt to associate to the AP specified
    by that ssid.  The configuration in bsscfg 1 is for the BSS it will
    support as an AP.  This pre-assignment of the BSS types cannot be
    changed.

    o To turn on APSTA (similar to MSSID).
      - Set driver to AP mode.
      - Enable the "mssid" iovar.
      - Enable the "apsta" iovar.
      - Do the desired per-BSS configurations (e.g. ssid and security) using
        per-BSS iovars.
      - Do any other desired global configuration (e.g. WLC_SET_CHANNEL).
      - Bring the driver up using WLC_UP.
      - Enable each BSS using the "bss" iovar.

      * In general, refer to startup files wlconf.c, apbase.c, apconf.c for
        example usage.

    o If the STA BSS fails its initial association to its AP, it will not
      retry; the application may detect this condition (see WLC_GET_BSSID)
      and retry as desired.  If the STA associates but later loses link with
      its AP (e.g. loses beacons) it will roam regularly; the frequency can
      be set using WLC_SET_ROAM_SCAN_PERIOD, and defaults to 10 seconds.

    o Whenever the STA BSS succeeds in associating to its AP, the AP BSS
      will be restarted, and all associated STAs will be disconnected and
      need to reassociate.

    o Limitations and known problems for APSTA:

      - The driver must be explicitly set to AP mode with WLC_SET_AP in
        order to APSTA mode to work correctly.

      - Afterburner, 802.11d, WET, and WDS are not supported in APSTA mode.

      - The AP BSS continues to generate beacons and probe responses even
        while the driver may be scanning on other channels to locate an AP.

  - Known limitations and issues with MSSID and APSTA.

    o To prevent a problem with possible bridge caching of the WLAN MAC
      address (see "Event Indications" above) we may wish to avoid sending
      up packets with the WLAN MAC as the source address.  One of the IAPP
      packets sent when a STA reassociates to the AP includes the AP address
      as the source; a new iovar "suppress_reassoc_iapp" may be used to
      prevent that packet from being sent.  See wlconf.c and apconf.c for
      example usage.

    o In our experience, event indications sent up to NAS may be bridged
      throughout the DS.

    o In order to support separate security configurations, the driver may
      use pairwise keys even for a legacy WEP BSS when mssid is enabled;
      thus multiple WEP keys cannot be used simultaneously on a single BSS. 

  - NAS has been modified to allow multiple instances to operate
    independently in a VX environment.

- New files:

src/bcmcrypto/aes_vectors.h
  Used by aes.c

src/cfe/cfe/arch/mips/board/bcm947xx/include/bsp_priv.h
  Split from bsp_config.h

src/common/include/proto/bcmevent.h
  Definitions for event indication messages.

src/include/sbhnddma.h
  Split from hnddma.h

src/router/config/defconfig-mfgtest-router
  New configuration for internal test router.

src/router/ses/ses_cfmain.c
src/router/ses/ses_cfwl.c
src/router/ses/ses_cfwl.h
src/router/ses/ses_cl/Makefile
src/router/ses/ses_clmain.c
src/router/ses/ses_clvendor.c
src/router/ses/ses_wl.c
src/ses/client/shared/fsm_assoc.c
src/ses/client/shared/fsm_ds.c
src/ses/client/shared/fsm_main.c
src/ses/client/shared/fsm_sur.c
src/ses/client/shared/pkt_win.c
src/ses/client/shared/ReadMe.txt
src/ses/client/shared/ses_cl.h
src/ses/client/shared/ses_cl_fsm.c
src/ses/client/shared/ses_cl_priv.h
src/ses/client/shared/ses_net.h
src/ses/client/shared/ses_win.c
src/ses/client/shared/timer_win.c
  Additional SES support.

src/router/shared/opencrypto.h
  Used by router/shared/broadcom.c for nvram save/restore.

src/router/shared/shutils.c
  Includes the nvram functions.

src/shared/nvram/bcm94320lph.txt
src/shared/nvram/bcm94320pagh.txt
src/shared/nvram/bcm95351agr.txt
src/shared/nvram/bcm95352gr.txt
  New platform NVRAM.

src/vxWorks/target/config/bcm47xx/wl/wl_ap/Makefile
src/vxWorks/target/config/bcm47xx/wl/wl_sta/Makefile
  Allows option of building AP-only or STA-only WL.

src/wl/config/wlconfig_apdef
src/wl/sys/wlc_bsscfg.c
src/wl/sys/wlc_bsscfg.h
src/wl/sys/wlc_msfblob.c
src/wl/sys/wlc_msfblob.h
src/wl/sys/wlc_channel.c
src/wl/sys/wlc_channel.h
src/wl/sys/wlc_key.c
src/wl/sys/wlc_key.h
src/wl/sys/wlc_rate_sel.c
src/wl/sys/wlc_rate_sel.h
src/wl/sys/wlc_scb.c
src/wl/sys/wlc_scb.h
  Code reorganization.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***
*** Release notes from 3.90.34 to 3.120.28:
***


4311/4312 Driver Overview

- Added Routines to Parse the PCI Configuration Capabilities space. PCIE device
information is abstracted from the Wireless Device Driver after initialization.

- Added Infrastructure routines to access the PCIE Core registers, Device 
Physical Layer/Data Link Layer/ Transaction Layer Protocol Registers. 

- Added Internal Debug routines to dump the core registers and Clock Registers.

- Added support for Hardware Radio Disable. Previous generations of
chipsets would turn off the radio immediately. An RF Disable Timer Feature has
been added to 4311. The timer ticks down once the signal is received by the
chipset to turn off. This allows the STA to transmit a disassociate packet to
an access point prior to radio being disabled. At driver initialization time,
the RF Disable Interrupt source is enabled and the RF Disable timeout register
is programmed with a timeout value of 500ms. Saturated test environments show
that 100ms is needed to send the dis-assoc packet.  On a hardware radio disable
sequence, driver receives a interrupt and the timer starts to tick down. If
the Station is associated to an Access Point, Station sends out a D11
Disassociation request.  The wireless driver goes into down state. If driver
is unable to get the dis-assoc packet out (because of a Contention Free Period
Backoff), and timer expires, radio is disabled anyway.

- Added pulsing to LED's to reduce Power consumption. The 4311 provides new 
registers to control pulsing LEDs to provide for power saving instead of 
always being on. There is a 32bit register to configure the duty cycle for 
all the LEDS.  16 bits for on time and 16 bits for off time. Register are 
provided to disable/enable the feature per LED.  Recommended value is 10% duty
cycle (10 clock ticks on / 90 ticks off).  This is a platform dependant setting
and should be tested with end target hardware.

- Auto WPA

Background 
As wireless network users people have been facing lots of administrative chaos
today in order to enable their wireless-enabled computers' secured access to
the network. For example, one must configure his/her wireless stations to be
WPA-PSK with TKIP if the Access Point is configured this way, and they are
forced to re-configure their stations when network's configuration is changed
or Access Points' software is upgraded, for example, to WPA2-PSK with AES. 

Also in an enterprise network, where multiple Access Points provide extended
coverage of service, deciding which Access Point to associate with in order
to have more secured access and faster speed when joining the network and
when roaming from one Access Point to another is becoming more complex. Some
companies may choose more secured access over speed and some others may
choose the opposite way. Even with the security settings some companies may
choose stronger encryption over newer authentication and some may favor newer
authentication over stronger encryption. 

Ideally all Access Points in an extended network should be configured all the
same. However during a lengthy software upgrade process before all Access
Points are taken care of, for example, some Access Points may have been
configured to WPA2-PSK with AES while some others still WPA-PSK with TKIP,
clients that are configured with the old configuration will not work when
they associate with or roam to the upgraded Access Points or vise versa. 

Design 
The idea here is to provide a mechanism to allow applications/users to 
configure the driver by a list of assorted preferences and configurations 
to control how the driver selects an Access Point to associate with and 
what configuration to use to associate to the Access Point. The driver 
then uses these preferences and configurations in its Access Point selecting 
process to select a most desired Access Point and to configure itself 
automatically before associating to the Access Point. 

This mechanism is enabled by users/applications' issuing a list of join
preferences. Each join preference has a type and a type specific value which
is typically a list of Automatic Configuration Preference (aka ACP)
specifications. The significance of each join preference and each ACP spec
are specified by the order they are presented to the driver. The driver uses
these preferences and ACP specs to calculate a weight for each join target
(aka. Access Point) reference (join target along with ACP specs).

For example, the driver selects the Access Point with the strongest RSSI first
and tries to associate to it using WPA2-PSK/AES and then WPA-PSK/AES and so on
so forth, if the application has configured the driver to favor speed over
encryption over authentication and the Access Point offers WPA2-PSK/AES and
WPA-PSK/AES. The driver stops trying other Access Points and configurations
whenever the driver is able to associate with an Access Point using a
configuration.

Interface 
"join_prefs" iovar is defined for applications to communicate join preferences
and ACP specs to the driver to customize driver's target joining behavior. The
driver uses this information to decide the order in which it tries to associate
to the join target and the ACP spec it uses to associate to the join target. 

The value is variable in length, consisting of a Type-Length-Value (TLV) 
triplets list. The order in which each triplet is presented in the list is 
from most significant to least significant. Absence of a preference means 
that the preference is not to participate in the decision making process.

Currently there are two join preferences implemented. Their types are defined 
in wlioctl.h: 

WL_JOIN_PREF_WPA - WPA preference 
WL_JOIN_PREF_RSSI - RSSI preference 
WL_JOIN_PREF_BAND - Band preference

Once set the join preferences stay the life cycle of the driver. Setting new 
join preferences frees the current one. Setting join preferences with zero 
length value disables the feature. The feature is disabled by default. 
Applications must explicitly send in valid join preferences to enable the 
feature. 

1. WPA preference 

WPA preference is used to automatically configure STA security settings before 
associating to a target Access Point based on target Access Point's advertised 
capabilities. It is presented by a list of 'akm-ucipher-mcipher' 
configurations/tuples. The order of tuples in the list is from the most 
favorable configuration to the least favorable configuration. Maximum 
WL_MAXWPACFGS (currently is 16) configurations are allowed. Minimum 1 
configuration is required. 

In each configuration, AKM is authenticated key management suite; ucipher is 
unicast cipher suite; mcipher is multicast cipher suite. Each suite is 
represented by an OUI and a type, same as it appears in the IE. OUI for each 
suite in the same tuple must be consistent as appearing within the same IE, 
for example, WPA and WPA2 suites cannot be used in the same tuple. 

Use of the MSFT OUI for AES and TKIP are defined in the WPA pointer doc. Use 
of the RSN OUI for AES and TKIP is defined in 802.11i. Multicast cipher suite 
value in each ACP can be all 0s to match any multicast cipher that Access 
Point offers. 

There is no default WPA preference in the driver. Application must explicitly 
passing WPA configurations into the driver thru join preferences to enable the 
auto WPA configuration. 

Setting WPA auth through WLC_SET_WPA_AUTH ioctl (wl command: 'wl wpa_auth') 
removes current WPA preference if any, which effectively disables the auto 
WPA configuration. 

WPA configurations not presented in the preference are disabled. For example, 
WPA-PSK/AES and WPA2-PSK/AES with WEP as multicast cipher are disabled if one 
sets the preference to the one given in section "Troubleshooting". 

Type (1 octet): 2
Length (1 octet): 2 + 12 * N

Value:

 7                     0
+-----------------------+
|      reserved         | 0
+-----------------------+
|       count           | 1
+-----------------------+
|                       | 2
|        tuple          |
|                       |
+-----------------------+
|                       | 14
|                       |
|                       |
+-----------------------+
|                       | 
|        tuple          |
|                       |
+-----------------------+

struct
{
   uint8 reserved;
   uint8 count;
   struct
   {
      uint8 akm[4];
      uint8 ucipher[4];
      uint8 mcipher[4];
   } wpa[1];
}

2. RSSI preference 

RSSI preference is used to select Access Point with stronger signal first. 
RSSI preference is mandatory and provided for ease of implementation purpose 
only. Applications must define this preference type in the iovar value 
regardless of other preference types. It is driver's default behavior to sort 
join target references by RSSI therefore there is no need to enable RSSI 
preference if it is the only join preference. 

Type (1 octet): 1
Length (1 octet): 2

Value:

 7                     0
+-----------------------+
|       reserved        | 0
+-----------------------+
|       reserved        | 1
+-----------------------+

The two value bytes are reserved, should be all 0s.

3. Band Preference

Band preference is taken from the value setup by WLC_SET_ASSOC_PREFER ioctl 
(compatibility). Defining this preference enables the band preference to take 
part in the decision making process.

Type (1 octet): WL_JOIN_PREF_BAND
Length (1 octet): 2

Value:

 7                     0
+-----------------------+
|       reserved        | 0
+-----------------------+
|       preference      | 1
+-----------------------+

The band preference values are shared with WLC_SET|GET_ASSOC_PREFER ioctl, 
they are:
    * WLC_BAND_AUTO
    * WLC_BAND_A
    * WLC_BAND_B

In addition, the following value may be used to maintain compatibility with 
existing band preference set by WLC_SET_ASSOC_PREFER:
    * WLJP_BAND_ASSOC_PREF


- WMM Production STA support.  Added support to complete the set of WIFI WMM
test sequences, which the driver passes.


- Minimum Power Consumption (MPC)
MPC is a STA-only Power Saving feature -- portions of the hardware are disabled
whenever possible (when the STA is not associated and not scanning).
MPC has nothing to do with 802.11 power save.  MPC is orthogonal with existing
RADIO_SW_DISABLE, RADIO_HW_DISABLE mechanism. If any one of them is TRUE,
radio will be disabled. If all of them are FALSE, radio will be enabled. MPC
behavior is dynamic and driver internal, the MPC states are not exposed to
UI(TrayApp etc.)  The driver turns all chip clocks off for maximum current
savings. This is the current implementation. 

MPC is OS independent and supports the following chipsets:: 4306B0/C0, 
4309B0/C0, 4318, 4311.
One of the implementation's goals was to not disturb any hardware calibrations.
Stringent DVT tests were executed to ensure this.  The design doesn't intended
to leave and re-enter MPC frequently, only up for SCAN or JOIN. wlc->mpc
controls whether this MPC feature is enabled or not. Currently, we have ioctl
WLC_SET_RADIO which manages 2 bool fields in wlc_info_t, radio_disabled_sw and
radio_disabled_hw. 

The centralized funciton wlc_radio_mpc_upd() managers radio_mpc_disable bit
If mpc is cleared, radio_enabled is called immediately(synchronous). However,
when mpc is set, radio_disabled is not called in place, rather postponed to
watchdog. This is not because we want to save extra disable/enable pair, but
to avoid calling wl_down in the middle of driver thread like dpc, which will
make any following register access in risk(get 0xfffffff or crash). 

cards  idle(up)  radio disabled(hw/sw/mpc)  
4318B0  290mA     3-4mA  
4306C0  280mA     38mA  
4309C0  200mA     38mA  

- WPA2 in driver supplicant support.  In addition to the WPA-PSK, WPA-802.1x,
LEAP, CCKM, and general packet sink/src routines, support was added for 
WPA2-PSK and WPA2-802.1x.  

- Added an adaptive roaming algorithm to back off the restrictions in roam 
targets as network conditions get worse. This helps to maintain connectivity

- Passive scanning dwell time has been increased in all locales by at least 20%

- Passive scanned channels will now connect to closed networks if the driver 
sees there are beacons already being sent on that channel       

- Upgraded regulatory settings as of May 2005. 

- CCX has been upgraded to V3, including the new 3.61 testplan from Cisco 

- Added a mode of operation where System Administrators can disable IBSS 
networks

- The struct rw_reg_t is modified to include and optional band parameter.

- One of the following reasons are now specified when a ROAM event is
generated:
   WLC_E_REASON_LOW_RSSI
   WLC_E_REASON_DEAUTH
   WLC_E_REASON_DISASSOC
   WLC_E_REASON_BCNS_LOST
   WLC_E_REASON_FAST_ROAM_FAILED

- Power Save Mode during scans
The scan algorithm was designed to minimize off channel time, and thus lost
packets.  In order to ensure the driver never misses a packet destined for
the home channel, the driver now indicates 802.11 power save mode back to
the AP while off channel, gets back to the home channel and gets data from
the AP, then back to another off channel. 

- Some Linksys WPC11 Cards do not stay on the center of the channel. 
Fundamentally, the particular Intersil radio used in this design has a lot of
carrier frequency drift over the duration of a frame, well in excess of what
is reasonably expected from the 802.11 specification.
The carrier frequency drifts about 25 kHz over 190 symbols (190 usec.). That
is a significant amount of drift.  For reference, Broadcom transceivers may 
drift only as much as 1 kHz after settling.
This does not happen with all WPC 11 cards.  Unknown in terms of percentage.
802.11 Spec makes no statement about drift tolerance (it should). This
characteristic is representative of a deficiency of the .11 PHY specifications
in that carrier frequency stability is not specified (only the allowable
offset).  

Adaptive Solution: We have been able to detect Aps that have this card and
adaptively understand if the STA is connected to the AP, and increase the
PLL width such that you only make the receive sensitivity tradeoff for bad
WPC 11 Access Points.

- Resolved a WPA interoperability issue with Extreme Altitude300 AP wireless
switch. Broadcom has had a policy of checking for a cleared secure bit during
re-authentication in our driver from day one. Broadcom has now slightly relaxed
it's validation during re-authentication while still maintaining security. With
this change, Broadcom will no longer be more strict than WZC during
re-authentication. This change has no effect on any other AP that sets the bit
in the manner we are accustomed to. It seems highly likely from our
interpretation that the Extreme switch has never passed WPA WIFI or it would
have been tripped up in the test lab.

The IEEE 802.11i specification is very clear on what should happen with
authentication sequences, and very vague on what should happen with
*re*-authentication sequences. The policy we have always taken is that if
the bit in question did not get cleared by the AP we would reject the packet
and thus the connection would break. Our new policy is if the bit is not
cleared the way we want it to, but the packet comes in encrypted, we will no
longer reject the packet. This new policy is only for re-authentication.

- Contention Free Periods
The scanning algorithm has been enhanced to not respect an off channel CFP.
In the prior code, if your home channel was on channel #1, and the scan on
channel # 11 were to find a CFP, it would be honored, effecting transmit
traffic back on the home channel (in this case, #1).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***
*** Release notes from 3.90.9 to 3.90.34:
***


- A new iovar "btc" is added to turn on/off bluetooth coexistence.

- Support for rate based power control on 4318.

- A new ioctl WLC_LONGTRAIN is added to put the aphy in test mode.

- Support for 5352.

- Support for SES2.

- Move ETROBO and ETADM defines from etc47xx.c to Makefiles.

- Fix compile time warnings in bcmtuils.c and bcmtuils.h.

New files:

src/vxWorks/target/config/bcm47xx/ses/Makefile
src/router/ses
src/router/ses/ses_vx.c
src/router/ses/ses_gpio_stubs.c

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***
*** Release notes from 3.90.5.6 to 3.90.9:
***


- The encapsulation used by the driver to pass up the EAPOL messages to NAS
ia modified in this release. Instead of adding a SNAP header, these frames
are now encapsulated with an ethernet header. The ethertype is set to 0x886c,
which is a protocol type assigned to broadcom.

See wl_secpvt_data_t structure defined and in wlioctl.h and wlc_eapol_msg()
in wlc.c.

- VxWorks related change:
A "vxvlan" driver is added in this release to support one or more vxvlan
instances above an END device driver. When a 802.1Q frame is received
from the underlying driver, the vlan tag is parsed and passed up the 
corresponding vxvlan instance, after removing the vlan tag.
For transmit, a vlan tag for the specific vid is constructed and inserted
into the outbound frame before calling the underlying driver send function.
See components/et/sys/vxvlan.c.

- Support for SES is added in this release.


***
*** Release notes from 3.80.9.2 to 3.90.5.6:
***


- Support for WPA2 has been added to this release and is enabled by the
compiler flag BCMWPA2.

- Power control changes for 4318 supports ucode level transmit power control.
Previous generations of hardware required software to recalibrate tx power 
periodically to account for temprature induced flunctuations.  The driver 
now downloads tx power parameters to microcode so the microcode can adjust 
tx power levels on a packet by packet basis.
 
- In tx_power_t structure defined in wlioctl.h, "txpwr_antgain" is changed from
unsigned to signed integer. The return value is in quarter dbm granularity.
Older sroms specified gain in whole dbm only.  In order
be able to specify quarter dbm granularity and remain backward compatible                    
the whole dbms are now encoded in only low 6 bits and remaining qdbms
are encoded in the hi 2 bits. 6 bit signed number ranges from -32 - 31.

- The newly defined "txpwr_est_Pout_gofdm" field in tx_power_t structure
returns the tx power estimate for 2.4 OFDM.

- A new api wl_pmkid_cache_req() has to be defined in the per port files for
WPA2.  To support external management of the driver's WPA2 PMKID cache,
upon completion of a scan, the driver generates and orders a list of join/roam 
candidates and passes this list to the supplicant, requesting a PMKID cache fill, 
using wl_pmkid_cache_req().  The supplicant is expected to generate PMKIDs for 
the candidates (e.g., stored PMKIDs for authenticated and pre-authenticated APs
and, possibly, opportunistic PMKIDs for not-yet-authenticated APs) and, through 
some other mechanism, satisfy the PMKID cache fill request.


- A boolean iovar "wpa_msgs" is added which controls the generation of
wpa event indications.

- sta_info_t struct is updated with "listen_interval_inms" field which returns
the listen interval for the sta on a query.


- A new iovar "vndr_ie" is introduced for AP builds, which allows manipulation i
of the "ie"s advertised in beacons, probe responses etc. The structure
"vndr_ie_setbuf" defined in wlioctl.h is populated and passed along with the
iovar name to the WLC_SET_VAR ioctl call.

Structures and constants used for this interface are listed below:

        #define VNDR_IE_BEACON_FLAG 0x1
        #define VNDR_IE_PRBRSP_FLAG 0x2
        #define VNDR_IE_ASSOCRSP_FLAG   0x4
        #define VNDR_IE_AUTHRSP_FLAG    0x8

        typedef struct vndr_ie_info {
            uint32 pktflag;         /* bitmask indicating which packet(s) contain this IE */
            vndr_ie_t vndr_ie_data;     /* vendor IE data */
        } vndr_ie_info_t;

        typedef struct vndr_ie_buf {
            int iecount;            /* number of entries in the vndr_ie_list[] array */
            vndr_ie_info_t vndr_ie_list[1]; /* variable size list of vndr_ie_info_t structs */
        } vndr_ie_buf_t;

        typedef struct vndr_ie_setbuf {
            char cmd[VNDR_IE_CMD_LEN];  /* vndr_ie IOVar set command : "add", "del" + NULL */
            vndr_ie_buf_t vndr_ie_buffer;   /* buffer containing Vendor IE list information */
        } vndr_ie_setbuf_t;


***
*** Release notes from 3.70.10.4 to 3.80.9.2:
***
  
- Build changes
  
  Driver functionality has been #ifdefed for smaller executables where
  features are not required. CPP flags need to be defined to include
  the features. Some flags below are not new, but are mentioned here
  for completeness.

  AP         Access Point mode
  STA        Client mode
  WLLED      Device LED management
  WET        Wireless Ethernet
  WME        Wi-Fi WME
  PIO        PIO mode
  CRAM       Afterburner support
  WL11H      802.11h protocol
  WL11D      802.11d protocol
  DBAND      Dual band
  WLRM       Radio Measurement (required for CCX and WL11H)
  WLCQ       Channel Quality measurements
  BCMSUP_PSK In-driver WPA PSK supplicant
  BCMCCX     In-driver CCX supplicant and other CCX client requirements

  The base common code .c files are 
  
  wlc.c d11ucode.c wlc_phy.c wlc_rate.c wlc_security.c rc4.c tkhash.c
  bcmwpa.c hnddma.c bcmutils.c bcmsrom.c siutils.c

  Some of the feature flags require additional files:
  
  WET   wlc_wet.c
  WLLED wlc_led.c
  BCMSUP_PSK
        wlc_sup.c aes.c md5.c rijndael-alg-fst.c aeskeywrap.c hmac.c 
        passhash.c prf.c sha1.c
  BCMCCX
        wlc_sup.c aes.c md5.c rijndael-alg-fst.c ccx.c des.c md4.c

  Phy type/revision and 802.11 core revision support are also
  configurable. Without any flags, defaults will be defined by
  wlc_cfg.h to support all phys/cores. To support only certain
  revisions, the compile can override the default values of D11CONF,
  ACONF, BCONF, and GCONF.

  Note: BCMDRIVER needs to be defined for any driver build.
  
  For a 11g/11b only, AP and STA build without many extras, the flags
  would be:
  BCMDRIVER AP STA WLLED ACONF=0

- CPP symbol CCX renamed to BCMCCX. Enables client side CCX support.
  Please check per-port files for possible uses.

- CPP symbol WPAPSK renamed BCMSUP_PSK. Enables in-driver PSK
  supplicant feature. Please check per-port files for possible uses.

- src/crypto and src/include/crypto dirs renamed to src/bcmcrypto and
  src/include/bcmcrypto. Please delete old directories and adjust 
  builds as needed.

- wlc_rm_req_state.class renamed to wlc_rm_req_state.report_class to
  avoid C++ keyword clash.

- New osl required per-port macro PKTBUFSZ. Should be a size equal to or
  close to 2048. Some implementations have trimmed the size by a few 
  bytes to avoid underlying packet allocation implementations to 
  allocate over page boundaries.

- New osl required per-port macro DMA_CONSISTENT_ALIGN. Should be
  an integer that specifies the alignment of memory returned by
  DMA_ALLOC_CONSISTENT(). So if DMA_ALLOC_CONSISTENT() always returns
  memory on 4k page boundaries, the define would be:

  #define DMA_CONSISTENT_ALIGN 4096

  Currently used by hnddma.c to determine how large an allocation
  needs to be made to satisfy other alignment constraints.

- Moved a handful of CPP symbols for driver tunables to a new file
  wlc_cfg.h, eliminating the need for the per-port header files in all
  our ports. (wl_linux.h, wl_vx.h, etc.)  wlc_cfg.h is included by the
  common code files that need the definitions, and the per-port
  implementation files. (wl_linux.c, wl_vx.c, etc.) A header file
  wlconfig.h is included by wlc_cfg.h in case changes to the default
  values are required.

- Some mode/feature flags are now checked through macros instead of
  direct references to wlc_info or wlc_pub fields. This allows the
  macros to be defined as constants in compiles that do not allow the
  feature, and allows compilers to optimize out code as a result. The
  macros are defined in wlc_cfg.h. Replace direct references to check
  the state of the fields below as follows:

  wlc.pub.ap            AP_ENAB() or AP_PUBENAB()
  wlc.pub.nbands        NBANDS() or NBANDS_PUB()
  wlc.pub.wme           WME_ENAB() or WME_PUBENAB()
  wlc.piomode           POI_ENAB()
  wlc.regulatory_domain WL11D_ENAB()
  wlc.spect_management  WL11H_ENAB()

  The above fields have all been renamed with a "_" prefix to make sure
  all references are updated.

  Also, checks for the phy type and 802.11 core or phy core revisions
  are replaced with macros in wlc_cfg.h, such as; ISGPHY(), GREV_IS(),
  GREV_GE(), etc.

- sta_info_t ioctl structure changed, sta_info version is now 2. This
  structure is used in the "sta_info" iovar ioctl query. Added
  associated time field and struct length field. Added two new flag
  bits, WL_STA_WDS, and WL_WDS_LINKUP. WL_STA_WDS indicates that the
  STA entry is for a WDS device. WL_WDS_LINKUP indicates that the WDS
  link appears to be active.  The WL_WDS_LINKUP feature is enabled by
  the ioctl iovar "wdstimeout".

- New iovar "wdstimeout" implemented for AP builds. This enables a WDS
  link detection similar to the idle STA link detection. Setting
  wdstimeout to a time in seconds turns on WDS link detection with
  polling at the specified interval. Setting to zero disables polling.
  
- WLC_GET_RSSI ioctl now requires activation when in AP mode. Per-STA
  RSSI values are not tracked until activated. To activate, eithier
  set the wlc->scbrssi value to TRUE, or query the WLC_GET_RSSI ioctl
  with any MAC address.

- wl_export.h changes

  To better enforce wl-to-wlc interface consistency, wl_export.h now
  has forward declarations for structs wl_info, wl_timer, and wl_wds;
  most void* arguments and return values in wl_export.h prototypes
  have been changed to use real struct pointers expected by the
  wl_xx.c files.

  Per-port wl_xx.c files should explicitly include wl_export.h,
  dropping their own duplicate or conflicting prototypes, and forward
  decls of structs wl_info, wl_timer, and wl_wds.  (They may still
  define and use the typedefs, and of course must define the actual
  structure content.)

  Where function definitions differ from the new prototypes they must
  be made consistent.  Of particular note:

    * Timer handles (wl_init_timer() return, wl_add/del/free_timer()
      second arg) are now (struct wl_timer*) rather than uint.  Type
      is still opaque to callers.

    * Functions wl_monitor() and wl_sendup() take (void*) as packet
      pointer type (third arg); they must cast to their preferred type
      internally.

    * Functions wl_ifname(), wl_del_wds(), and wl_sendup() take an
      explicit (struct wl_wds*) as second arg, and wl_add_wds()
      returns one.

    * Function wl_init_timer() second arg is now a function taking an
      opaque (void*) type; wl_xx.c port should not need to know
      whether it is a (wlc_info_t*) or anything else.
  
    * struct wl_rxsts is used in one interface definition but not defined
      in wl_export.h. wlc.h or wlc_pub.h needs to be included before
      wl_export.h to pick up this definition.

- SET_WPA_AUTH changes

  As part of adding support for WPA2 (along with adding more
  flexibility in configuration), the values for the SET_WPA_AUTH have
  changed.  The new values are implemented as a bitvector of all
  enabled authentication modes:

    /* WPA authentication mode bitvec */
    #define WPA_AUTH_DISABLED       0x0000  /* Legacy (i.e., non-WPA) */
    #define WPA_AUTH_NONE           0x0001  /* none (IBSS) */
    #define WPA_AUTH_UNSPECIFIED    0x0002  /* over 802.1x */
    #define WPA_AUTH_PSK            0x0004  /* Pre-shared key */
    #define WPA_AUTH_CCKM           0x0008  /* CCKM */
    #define WPA2_AUTH_CCKM          0x0010  /* CCKM2 */
    #define WPA2_AUTH_UNSPECIFIED   0x0040  /* over 802.1x */
    #define WPA2_AUTH_PSK           0x0080  /* Pre-shared key */

  This change affects anybody writing their own authenticator or
  supplicant and using the ioctl interface.

- BSS Arrays

  The BSS arrays in wlc_info_t used for scanning (scan_results,
  custom_scan_results, rm_state.scan_results, join_targets) and their
  associated count fields (*_num) have been replaced with
  wlc_bss_list_t structures, which contain an array of pointers
  (rather than blocks) and a count.  The structures are dynamically
  allocated as required during scans.

  Any references to these fields from per-port files must be modified
  accordingly.  Any such references should really be read-only; these
  structures should not be modified by per-port files.  If clearing a
  list is desired, use the wlc_bss_list_free() function, which is
  prototyped in wlc.h; it will free the allocated blocks in the list
  and reset the count to 

- Scan BSSID

  The bssid argument of wlc_scan_request, if it points to a unicast
  MAC address, is now used to filter incoming beacons and probe
  responses when collecting scan results.  (Previously the bssid was
  only used after the scan to prune targets for a directed
  reassociation through the custom reassoc ioctl.)


***
*** Release notes from 3.50.37 to 3.70.10.4:
***

- Support for CCXv2 is included in this release.

- Partial WME implementation included. Not operational in this release, but some
  code an interface will be visible.

- Afterburner enabling method changed. Instead of setting WLC_SET_GMODE to 6, the
  iovar "afterburner_override" should be set to -1 (Auto). If the capability bit
  is not set in device SROMS, set the iovar "abcap" to 1.

- A new header file wlc_pub.h is added. The wlc_pub_t structure and few other
  prototypes are moved into the new header file.

- LEAP and WPAPSK supplicant code is implemented in a new file wlc_sup.c and
  associated header file wlc_sup.h. To compile the in-driver supplicant, define
  WPAPSK in the compile.
  To enable the in-driver supplicant for WPA-PSK, set the iovar "wpa_sup" to 1,
  and set the PMK with the WLC_SET_WSEC_PMK ioctl. The WLC_SET_WSEC_PMK takes a
  wsec_pmk_t struct as a parameter, defined in src/include/wlioctl.h.
  If the WSEC_PASSPHRASE is set in wsec_pmk_t.flags, the key is considered a
  passphrase and must be 8 to 63 bytes. The passphrase will be combined with the
  SSID at BSS association attempt time to create the PMK.
  If the WSEC_PASSPHRASE flag is not set, the key is considered as the literal
  PMK and must be 1 to 32 bytes.
  To enable the in-driver supplicant for CCX, instructions can be made available
  on request.

Per-Port source updates required:

- SCBs (Station Control Blocks) are allocated dynamically instead of being drawn
  from a static pool. NSCB per-port define changed to MAXSCB.

- Add PKTPRIO(pkt), PKTSETPRIO(pkt, prio) macros. 
  PKTPRIO(pkt) is expected to return an integer priority.
  PKTSETPRIO(pkt, prio) returns nothing and expects a priority integer.
  Can be noops if priority is not implemented. I.e.:
#define PKTPRIO(m)                      (0)
#define PKTSETPRIO(m, n)                do {} while (0)

  The interpretation of the the priority value is dependent on the particular
  driver.

  For the wireless driver, the priority field is used for WME connections.
  Current source does not have full WME support, so the null mapping to priority
  zero is appropriate.

- Added osl_attach(), osl_detach() to Broadcom's OSL implementations.
  void* osl_attach(void* pdev)
  void osl_detach(void* osh)

  These are hooks to allow init and tear-down of an OS specific layer
  implementation. The routines are expected to be called by the per-port layer
  code. The 'pdev' parameter is an arbitrary parameter to be decided by the
  per-port/osl implementation design. The 'osh' pointer (OS Layer Handle) is
  returned by osl_attach() and taken as a param for osl_detach(). The osh is
  used in several other OSL functions/macros to aid in an OSL implementation.

  Since the routines are used only by the per-port and osl code, they are not
  required if the particular per-port and osl do not need them. The only
  requirement is that some 'osh' cookie is passed into wlc_attach() to be used
  in the osl functions/macros used by common code.

- Add MALLOCED(osh), MALLOC_FAILED(osh), MALLOC_DUMP(osh, buf, sz), macros.
  These macros have been added to aid in memory allocation accounting/debug.

  MALLOCED(osh) takes the OS Layer Handle pointer and returns the
  bytes allocated with MALLOC().

  MALLOC_FAILED(osh) takes the OS Layer Handle pointer and returns the
  number of MALLOC() calls that failed.

  MALLOC_DUMP(osh, buf, sz) takes 'osh', the OS Layer Handle pointer,
  'buf', a buffer pointer, and 'sz', the size of the buffer, and is
  expected to format a report of allocated blocks. This macro is only
  used if MALLOC_DEBUG is defined in the build.

  An example implementation of these can be found in the Linux port, in
  linux_osl.h, linux_osl.c, are used in common code and also in the per-port
  file wl_linux.c

- wl_link_up(), wl_link_down(), wl_mac_event(), wl_mic_error(), replaced with
  wl_event().

void wl_event(wl_info_t *wl, wlc_event_t *e)

/* Event data type */
typedef struct {
        uint msg;                       /* Message (see below) */
        struct ether_addr *addr;        /* Station address (if applicable) */
        uint status;                    /* Status code (see below) */
        uint reason;                    /* Reason code (if applicable) */
        uint auth_type;                 /* WLC_E_AUTH */
        bool link;                      /* WLC_E_LINK */
        bool group;                     /* WLC_E_MIC_ERROR */
        bool flush_txq;                 /* WLC_E_MIC_ERROR */
} wlc_event_t;

  The wl_event() function was added as the per-port interface for driver events,
  expanding on the previous wl_mac_event() interface. The set of events
  generated are found in wlioctl.h in the list of "Event messages" defining the
  WLC_E_* symbols.

  The wl_link_up/down() functions are no longer required by common code. They
  can be left as is and called from wl_event() on reception of WLC_E_LINK
  messages.

  The wl_mic_error() function is no longer required by common code. It can be
  left as is and called from wl_event() on reception of WLC_E_MIC_ERROR
  messages.

  The wl_mac_event() function is no longer required by common code. It can be
  left as is and called from wl_event() on reception of any event that was not
  dispatched to the other routines.

- Added wl_interson(), wl_intersoff(), wl_intersrestore().

  For SMP safety, following per port functions are created:

        void wl_intrson(void *wlh);
        uint32 wl_intrsoff(void *wlh);
        void wl_intrsrestore(void *wlh, uint32 macintmask);

  The per-port layer should implement these functions in an SMP safe way to run
  mutually exclusively of each other.
        
  wl_linux.c and wl_vx.c have simple implementations for examples.

  Interrupts will be manipulated by the common code using these functions with
  the exception of wlc_intrsoff_isr(), which is reserved for ISR use for
  efficiency.  Code running in the ISR is assumed to be running in a SMP safe
  context and will not preempt or be preempted by the other wl_inters*
  functions.

- The wl_monitor() prototype changed from this:

        extern void wl_monitor(void *wlh, d11rxhdr_t *rxh, void *p);

  to this:

        extern void wl_monitor(void *wlh, wl_rxsts_t *rxsts, void *p)

  where wl_rxsts_t is a new hardware-independent data structure declared in
  wlc_pub.h.

Other changes:

- typedefs.h default type for bool changed from int to unsigned char. The
  default bool type is used if SITE_TYPEDEFS is not defined and the compile does
  not define MACOSX, KERNEL, _WIN32, or __cplusplus.

- The WLC_SCAN ioctl was extended to allow more parameters to be specified to
  implement fine grained scan control. Previously, the WLC_SCAN ioctl would
  ether take a zero length buffer, to specify a broadcast scan, or a 4 to 4+32
  byte buffer to start a scan for a specific SSID. The buffer contains a 4 byte
  SSID length, followed by up to 32 bytes of the SSID.

  The extension of the ioctl allows a buffer of at least 64 byes to be specified
  holding a wlc_scan_params_t structure. The structure allows setting the SSID
  as before, but also allows specification of:
        the specific BSSID instead of the default broadcast address
        the type of network to scan, Infrastructure or IBSS
        the type of scan, active or passive.
        number of probes to send per channel (spaced evenly over the scan time)
        time in ms to scan each channel in two cases, time for active scans,
        and time for passive scans.
        time to spend on the home channel between each channel scanned.
        the list of channels to scan

  Most of the parameters can be specified with -1 or 0 as noted above to use the
  driver's current default scan behavior. The ssid, bssid, and bss_type need to
  be specified since there is no driver default value for these params.

Known issues:

- The recent fixes provided for the 3.50.37 release to fix the multicast
  performance and passive scan issues are not included in this release.

- There is an unaligned 32bit access in TKIP MIC check code.
