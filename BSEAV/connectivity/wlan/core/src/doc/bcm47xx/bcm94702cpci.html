<!-- $Id: bcm94702cpci.html,v 1.1 2002-11-23 00:43:39 jfd Exp $ -->
<HTML>
<IMG BORDER=0 SRC="bcwlft1.gif">
<HEAD>
<TITLE>Linux Development Kit (LDK) </TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#800080">
<H1>Linux Development Kit (LDK) </H1>
<H2>Linux/MIPS on Broadcom BCM94702 CPCI </H2>
<H2>CPCI and StrataSwitch/XGS Platforms</H2>
<H6> $Id: bcm94702cpci.html,v 1.1 2002-11-23 00:43:39 jfd Exp $ </H6>
<UL>

<H4> Table of Contents </H4>
<UL>
<LI> <A HREF="#Intro"> Introduction </A>
<LI> <A HREF="#Overview"> Overview </A>
<UL><LI> <A HREF="#HWCONFIG"> Hardware Configuration </LI></UL>
<LI> <A HREF="#DEVTOOLS">Development Environment </A>
<LI> <A HREF="#BootLoader">Boot-Firmware </A>
<UL><LI> <A HREF="#CFEBU">CFE Bringup NVRAM Configuration</A>
<LI><A HREF="#CFENVRAM">CFE NVRAM Configuration</A>
</UL>
<LI> <A HREF="#Linux-2.4.x">Linux 2.4.x Kernel Configuration </A>
<UL><LI><A HREF="#NFSBootSetup">Linux/MIPS TFTP and NFS Setup</A>
</UL>
<LI> <A Href="#User">User Applications </A>
<UL><LI>
<A HREF="#ROOTFS">Building the User Applications</A></UL>
<LI> <A Href="#NVRAM">NVRAM Router Configuration Variables </A>
<LI> <A Href="#DOCConfig">Configuring DiskOnChip (TM) TFFS Flash Devices </A>
<LI> <A Href="#DOCBoot">Configuring DiskOnChip (TM) as CFE Boot Device </A>
<LI> <A Href="#ROUTER"> Configuring the Router </A>
<LI> <A Href="#TESTING"> Testing the Router Application </A>
<LI> <A Href="#SDK"> Strata/XGS SDK 4.x Configuration and Build</A>
<LI> <A Href="#ROBO"> RoboSwitch (BCM53xx) Setup, Configuration and Build</A>
<LI> <A Href="#FLASHConfig">Configuring Flash Devices </A>
<LI> <A Href="#FLASHBOOT">Configuring FLASH Filesystems with mkcramfs </A>
<LI> <A Href="#ISSUES">Known Issues </A>
</UL>
</UL>
<HR>

<A NAME="Intro"><H1>Introduction</H1></A>
<P>This document describes the port of Linux to MIPS processors, and in particular, the Broadcom BCM94702 platforms which use either BCM4710 or BCM4702 Processors. Hardware and software support for these platforms are described along with configuration options for building boot firmware, Linux OS kernel images, user applications, along with how-to on target setup, boot, and configuration. By using this document, you should be able to bringup systems from scratch, and build and maintain all of the software from the reset exception vector, all the way up to the command shell or application program. </P>

<P>&quot;Linux is a Unix clone written from scratch by Linus Torvalds with assistance from a loosely-knit team of hackers across the Net. It aims towards POSIX compliance. It has all the features you would expect in a modern fully-fledged Unix, including true multitasking, virtual memory, shared libraries, demand loading, shared copy-on-write executables, proper memory management and TCP/IP networking.&quot; For more information on <B>Linux</B>, see <A HREF="http://www.kernel.org/">http://www.kernel.org/</A>
</UL>

<A NAME="Overview"><H1>Overview</H1></A>
The Broadcom BCM94702CPCI platform is a 3U CompactPCI system controller
with full support for embedded Linux in a CompactPCI platform architecture.
The BCM94702CPCI platform is a complete standalone router/system controller
with the following features:

<UL>
<LI> BCM4702 MIPS CPU onboard, 100Mhz Core, 100Mhz SDRAM Interface
<LI> Dual 10/100 Integrated 802.3 Ethernet MAC
<LI> 32MB M-Systems DiskOnChip (TM) for FLASH filesystem using M-Systems True Flash Filesystem (TFFS) block driver.
<LI>PLCC (512K) bootrom
<LI> STM48T59Y 8K NVRAM/RTC or Dallas DS1743 Compatible device.
<LI> OSRAM DLR2416 4-Character 5x7 Dot-Matrix Alphanumeric intelligent display
<LI> Dual 16552 Serial Ports (Console, and Debug port)
<LI> Compact PCI J1 System Controller Card design.
</UL>

This document describes support for the following software applications
on the BCM94702CPCI platform:
<UL>
<LI> Broadcom Common Firmware Environment (CFE) - BIOS Firmware
<LI> Linux Kernel 2.4.5
<LI> Linux Kernel 2.4.18
</UL>

Using this document and the associated S/W, one can develop a standalone
system using BCM94702CPCI for use as a system controller, standalone 2-port router, or managed multiport switch/router host controller.

<A NAME="HWCONFIG"><H2> Hardware Configuration </H2></A>

Before using the BCM94702 CPCI platform, you must first initially
boot the CPU from the PLCC flash device in the ROM socket and select
Little-Endian (LE) MIPS boot mode. In order to configure these settings
several important jumper settings need configuration.<P>


<H3>JP800 (PLCC/Onboard FLASH boot)</H3>

One must look at JP800 with the CPCI connector facing towards you, in this view you will see three pins behind the PLCC adapter. Note that the three position jumber selects the boot flash device. The jumper settings have the following meanings:

<PRE>

1 2 3
o o-o PLCC Boot (2-3 jumpered) (AM29LV160DB)

1 2 3
o-o o FLASH boot (1-2 jumpered) via AM29LV160DB FLASH or Intel 28F320J FLASH.
</PRE>

<P>

<H3> JP1 (Big/Little Endian Select) </H3>

The CPU must be configured for Little endian mode. The JP1 jumpers affect the endian-mode of the CPU, the meanings are below:
<PRE>


BE	LE
o	o	1
|	
o 	o	2
	|
o 	o	3

</PRE>

<UL>
<LI>Pins 1-2 (Big Endian Mode - VxWorks)
<LI>Pins 2-3 (Little Endian Mode - Linux)
</UL>

Your system is now configured to boot CFE and MIPS/Linux from the network, and then standalone (from the DiskOnChip FLASH device).


<A NAME="DEVTOOLS"><H1>Development Environment</H1></A>

In order to build a CFE bootloader and Linux kernel for BCM94702CPCI, you will need the following Broadcom-supplied toolchains.

<UL>
<TT>
<LI>sbtools-mips64-sb1sim-2.3.1.x86-linux-rh6.0 - or newer
<LI>hndtools-mipsel-linux-3.0 - or newer
</TT>
</UL>

Within the Broadcom environment, you can use these tools by adding
the following lines to your <tt>.cshrc</tt>:<P>
<PRE>
# For building CFE loader (set this first)
set path=(/projects/bbp/sbtools/x86-linux-rh6.0/mips64-sb1sim-2.3.1/bin $path)

# BCM4710 Linux-X86-Hosted Tools (set this second) (head of path)
set path=(/projects/hnd/tools/linux/hndtools-mipsel-linux/bin $path)
rehash

</PRE>


<A NAME="LAYOUT"><H1> Source Tree Organization </H1></A>

The organization of the files in the Linux Development kit are as follows:
<UL>
<PRE>
src/include  - common C header files
src/shared   - common C source files and API files
components/et       - source code for the 47xx/43xx/42xx series of Ethernet MAC's
src/il       - source code for Broadcom iLine series of HPNA MAC's
src/wl       - source code for Broadcom Airforce series of Wireless LAN MAC's.
src/usbdev   - source code for USB networking device support on BCM947xx platforms.
src/doc      - documentation
src/router   - source code for the Router application and BSP (Linux), root filesystem source code for all user applicaions
src/linux/linux - Linux kernel version 2.4.5
src/linux/linux-2.4.18 - Linux kernel version 2.4.18
src/cfe - Common Firmware Environment boot-loader firmware.
</PRE>
</UL>

See the file <tt>src/doc/bcm47xx/BCM47XX_Resource_Guide.pdf</tt> for more information.


<A NAME="BootLoader"><H1>Boot-Firmware </H1></A>

The BCM94702CPCI platform uses the Broadcom Common Firmware Environment (CFE) for system initialization and boot loading of Linux kernel images. CFE is a full-featured firmware environment featuring:
<UL>

   <LI> Initialization of CPUs, caches, memory controllers, and peripherals
   <LI> Built-in device drivers for BCM947XX and SB1250 internal SOC peripherals
   <LI> Several console choices, including serial ports, ROM
     emulators, JTAG, etc.
   <LI> Environment storage in NV EEPROM, flash, etc.
   <LI> Supports big or little endian operation
   <LI> Supports 32-bit and 64-bit operation
   <LI> Support for network bootstrap.  Network protocols supported 
     include IP,ARP,ICMP,UDP,DHCP,TFTP.
   <LI> Support for disk bootstrap.
   <LI> Provides an external API for boot loaders and startup programs
   <LI> Simple user interface.  UI is easy to remove for embedded apps.
</UL>

For more information on the CFE environment, see the files:
<PRE>
src/cfe/README
src/cfe/docs/cfe.pdf
</PRE>
<P>

To build the CFE bootloader image for BCM94702:<P>
<PRE>
cd src/cfe/build/broadcom/bcm94702cpci
make 
</PRE>

The output of the build will be a file called <tt>cfe.srec</tt>; this file
should be burnt into the PLCC FLASH ROM and the system should be powered up.

<PRE>
CFE version 1.0.34 for BCM94702_CPCI (32bit,SP,LE)
Build Date: Thu Nov  7 15:52:37 PST 2002 (jfd@que)
Copyright (C) 2000,2001,2002 Broadcom Corporation.
Initializing Arena.
Initializing Devices.
et0: Broadcom BCM47xx 10/100 Mbps Ethernet Controller
et1: Broadcom BCM47xx 10/100 Mbps Ethernet Controller
CPU type 0x24000: 100MHz                             
Total memory: 0x1000000 bytes (16MB)

Total memory used by CFE:  0x80F73780 - 0x81000000 (575616)
Initialized Data:          0x80F73780 - 0x80F74F00 (6016)
BSS Area:                  0x80F74F00 - 0x80F76980 (6784)
Local Heap:                0x80F76980 - 0x80FB6980 (262144)
Stack Area:                0x80FB6980 - 0x80FB8980 (8192)
Text (code) segment:       0x80FB8980 - 0x80FFFFB8 (292408)
Boot area (physical):      0x00F32000 - 0x00F72000
Relocation Factor:         I:E13B8980 - D:00F72780
CFE>
</PRE>


Alternatively, if you are using a GEI ROMICE, set the following configuration file for your ROMICE and save as <tt>loadice.ini</tt>.

<PRE>
fastport=<IP ADDRESS OF YOUR ROMICE>
cursor 1
socket 29040
rom 512K
word 8
ppbus=lpt1
begin
fill 0 1ffff ff
file cfe.srec
log target.txt
load
go
</PRE>
<P>
<A NAME="CFEBU"><H2> CFE Bringup NVRAM Configuration </H2> </A>

First, verify your hardware inventory; you should see the following
devices with the CFE <tt>show devices</tt> command:

<PRE>
CFE> show devices 

Device Name          Description                                         
-------------------  --------------------------------------------------------- 
uart0                NS16550 UART at 0x1F800008                                
nvram0               ST M48Txx NVRAM at 1f00e000 size 7KB                    
doc0                 M-Systems Binary Partition at BF006000 size 32MB         
flash0.boot          New CFI flash at 1FC00000 offset 00000000 size 512KB     
flash0.os            New CFI flash at 1FC00000 offset 00080000 size 1528KB     
flash0.nvram         New CFI flash at 1FC00000 offset 001FE000 size 8KB       
eth0                 BCM4710 Ethernet unit 0 (40-00-00-47-10-10)               
eth1                 BCM4710 Ethernet unit 1 (40-00-00-47-10-11)               
*** command status = 0                                                         
CFE> 

</PRE>

Before you can use CFE to boot your system, you must program some configuration
data into the NVRAM environment region and reset your system. The following commands should be issues once (at bringup) to complete BCM94702 boot-firmware configuration.<P>
<PRE>

setenv -p et0phyaddr 2
setenv -p et0mdcport 0
setenv -p et1phyaddr 1
setenv -p et1mdcport 1
setenv -p et0macaddr 40-00-00-47-10-10
setenv -p et1macaddr 40-00-00-47-10-11
setenv -p watchdog 15000
setenv -p pcitestfreq 0

reset
</PRE>
<P>


<A NAME="CFENVRAM"><H2> CFE NVRAM Configuration </H2> </A>
Once you have configured the basics, you should perform some sanity tests
and verify that your network is working. In order todo so, CFE will need to
have IP parameters configured (unless you are using DHCP). CFE uses the special environment variable <TT>STARTUP</TT> for a semicolon-delimited list of commands which should be executed at startup. For example:

<PRE>
setenv -p STARTUP "ifconfig eth0 -addr=172.16.40.113 -mask=255.255.240.0 -gw=10.16.64.1 -dns=10.16.64.11"
</PRE>

This configures the first device with the specified IP parameters. In general, any command can be added to the STARTUP variable provided the commands are semilcolon delimited. 

<H4> STARTUP NVRAM Variable</H4>
For initial bootup of Linux, we would use the following STARTUP commands:

<PRE>
setenv -p STARTUP "ifconfig eth0 -addr=172.16.40.113 -mask=255.255.240.0 -gw=10.16.64.1 -dns=10.16.64.11;boot -elf -tftp 172.16.40.111:vmlinux"
</PRE>

In this configuration, we bringup eth0 (top ethernet port) with IP address 172.16.40.113 and we use TFTP to download the Linux kernel image <tt>vmlinux</tt> from the TFTP server at IP address 172.16.40.111
<P>

<H4> kernel_args NVRAM Variable</H4>
There is another environment variable <tt>kernel_args</tt> which the Linux kernel will parse using IP-PNP auto-configuration to bringup the network interfaces, select the correct console and baudrate, as well as obtain the root-filesystem for system initialization. Initially, we use NFS as the root device and must configure the <tt>kernel_args</tt> variable with a command such as:
<PRE>

setenv -p kernel_args "console=ttyS1,115200 ip=172.16.40.113:172.16.40.111:10.16.64.1:255.255.240.0:switch-2:eth0 root=/dev/nfs rw nfsroot=172.16.40.111:/boot/install-mipsel,timeo=200,retrans=500 nfsaddrs=172.16.40.113:172.16.40.111 noinitrd"

</PRE>
The format of this argument string is :
<PRE>

console=ttyS1,115200 - use specified console port and speed
ip=[client]:[NFS server]:[default router]:[netmask]:[hostname]:[device]
root=[device] - use [device]=nfs for NFS boot, [device]=/dev/fl/0 for FLASH boot.
rw - option for R/W access via NFS
nfsroot=[NFS server]:[mount point],timeo=[timeout],retrans=[retrans]
nfsaddrs=[client IP]:[NFS server IP]
noinitrd - do not use initial RAMDISK
</PRE>


The format of the <tt>kernel_args</tt> string is documented in the <tt>linux/Documentation/kernel-parameters.txt</tt> file which should be reviewed for more information. In general, you will set this once for NFS boot, and then once you have built a FLASH filesystem from your NFS environment, you will only need to set your root device to mount the flash filesystem.

<P>
NOTE: In the examples above:
<UL>
<LI> 172.16.40.113 - client IP address of BCM94702CPCI top port (eth0)
<LI> 172.16.40.111 - NFS and TFTP Server IP address serving kernel and filesystem via NFS.
<LI> 10.16.64.1 - default router for both client and server.
<LI> 255.255.240.0 - IP netmask
</UL>


You are now ready to configure your BCM94702CPCI platform to boot from the network. The process of booting from the network consists of :

<OL>
<LI> Building a Linux kernel with the correct configuration and storing this file in a location accessible by your TFTP server.
<LI> Building a root-filesystem which Linux can mount via NFS over the network. The root filesystem will serve as an installation baseline for initial setup and boot.
</OL>


<A NAME="Linux-2.4.x"><H1>Linux 2.4.x Kernel Configuration </H1></A>

For both the bridge and router packages you will be delivered:</p>
<ul>
 <li> A general readme file that describes the tools used in building the package, how to install the tools, etc.</li>
 <li>Source to the Linux kernel in the /src/linux/linux directory</li>
 <li>Source for all of the Broadcom-supplied components in the root directory:</li>
 <ul>
  <li>The /components/et/ directory contains source for the Ethernet driver</li>
  <li>The /src/il/ directory contains source for the HPNA 2.0 driver</li>
  <li>The /src/shared/ directory contains source code shared among many of the
      Broadcom-supplied components</li>
  <li>The /src/include/ directory contains header files for many of the
      Broadcom-supplied components</li>
  <li>The /src/router directory contains the remaing bridge/router source modules</li>
 </ul>
 <li> The /doc directory contains this document as well as other supporting
     documentation</li>
 <li> The /tools direcotory contains things necessary to build the router
     image.
      <ul>
  <li> GCC 3.0 compiler</li>
  <li> The GLIBC library</li>
 </ul>

<p> In addition, a full router release package will also include source code for the services necessary to implement a full residential gateway application.</p>

<p>Please note that depending on the package that was agreed upon (full-source, or binary), some or all of the aforementioned source directories may be omitted and replaced with corresponding binary files.</p>

<p>The Linux image is based on freely available Linux kernel source code.

<p>Because of memory and Flash constraints, certain kernel
services are not compiled when the BCM94702 Linux image is created.
These services were not necessary in order to provide the desired router functionality. If, however, you are going to be adding extra router functionality
you may need to modify the kernel build in order to include some services that
may be necessary to you.
</UL>

This section covers configuring, building, running, and installation of the Linux kernel (versions 2.4.x). Note that the source tree supports both Linux kernel version 2.4.5 and 2.4.18. Both kernel's can be configured with the following commands:

<H4> For Kernel 2.4.5 </H4>
<PRE>
cd src/linux
cp arch/mips/defconfig-bcm94702-cpci .config
make menuconfig (simply save kernel)
make dep
make 
</PRE>


<H4> For Kernel 2.4.18 </H4>
<PRE>
cd src/linux-2.4.18
cp arch/mips/defconfig-bcm94702-cpci .config
make menuconfig (save kernel)
make dep
make
</PRE>


The output of your builds will be the ELF binary "vmlinux". Using CFE, you should be able to boot that file from the network and immediately get a failure from Linux trying to mount a non-existent root filesystem. The next step to build the system is to build the <tt>router</tt> application software.
<PRE>
Device eth0:  hwaddr 40-00-00-47-10-10, ipaddr 172.16.40.113, mask 255.255.240.0 gateway 10.0.16.64, nameserver 10.16.64.11                              
Loader:elf Filesys:tftp Dev:eth0 File:172.16.40.111:vmlinux Options:(null) 
Loading: 0x80001000/1692504 0x801a0000/188592 0x801ce0b0/259180 Entry at 0x80008
Closing network.
                                                                
et0: link down                                                                  
Starting program at 0x800027a8                                          
CPU revision is: 00024000                                                    
Primary instruction cache 8kb, linesize 16 bytes (2 ways)                    
Primary data cache 4kb, linesize 16 bytes (2 ways)                           
Linux version 2.4.18-xfs-brcm (jfd@que) (gcc version 3.0 20010422 (prerelease) 
RTC: 11/0/2003, 6:24:05                                                        
Determined physical RAM map:                                                  
 memory: 01000000 @ 00000000 (usable)                                          
On node 0 totalpages: 4096                          
zone(0): 4096 pages.
zone(1): 0 pages.                                                             
zone(2): 0 pages.                                                             
Calibrating delay loop... 66.56 BogoMIPS                                      
Memory: 14032k/16384k available (1652k kernel code, 2352k reserved, 93k data, 8)
Dentry-cache hash table entries: 2048 (order: 2, 16384 bytes)                
Inode-cache hash table entries: 1024 (order: 1, 8192 bytes)                  
Mount-cache hash table entries: 512 (order: 0, 4096 bytes)                   
Buffer-cache hash table entries: 1024 (order: 0, 4096 bytes)                   
Page-cache hash table entries: 4096 (order: 2, 16384 bytes)                    
Checking for 'wait' instruction...  unavailable.                               
POSIX conformance testing by UNIFIX                                            
PCI: Probing PCI hardware                                                      
PCI: Fixing up bus 0                                                           
PCI: Fixing up bridge                                                          
PCI: Enabling device 01:00.0 (0000 -> 0002)                                    
PCI: Fixing up bus 1                                                           
Linux NET4.0 for Linux 2.4                                                     
Based upon Swansea University Computer Society NET3.039                        
Initializing RT netlink socket                                                 
Starting kswapd                                                                
devfs: v1.10 (20020120) Richard Gooch (rgooch@atnf.csiro.au)                   
devfs: boot_options: 0x1                                                       
Serial driver version 5.05c (2001-07-08) with MANY_PORTS SHARE_IRQ SERIAL_PCI ed
ttyS00 at 0xbf800000x (irq = 0) is a ST16650                                   
ttyS01 at 0xbf800008x (irq = 2) is a ST16650                                   
block: 64 slots per queue, batch=16                                            
loop: loaded (max 8 devices)                                                   
TFFS 5.1.1 Flash disk driver for DiskOnChip                                    
Copyright (C) 1998,2001 M-Systems Flash Disk Pioneers Ltd.                     
DOC device(s) found: 1 at 0xbf006000                                           
fl_init: registered device at major: 101                                       
fl_geninit: registered device at major: 101                                    
Partition check:                                                               
 fla: unknown partition table                                                  
partition: /dev/fl/0: start_sect: 0,nr_sects: 55808 Fl_blk_size[]: 27904KB     
partition: /dev/fl/1: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
partition: /dev/fl/2: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
partition: /dev/fl/3: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
PPP generic driver version 2.4.1                                               
CFI: Found no Physically mapped flash device at location zero                  
sflash: chipcommon not found                                                   
NET4: Linux TCP/IP 1.0 for NET4.0                                              
IP Protocols: ICMP, UDP, TCP                                                   
IP: routing cache hash table of 512 buckets, 4Kbytes                           
TCP: Hash tables configured (established 1024 bind 2048)                       
ip_conntrack (128 buckets, 1024 max)  
ip_tables: (C) 2000-2002 Netfilter core team
NET4: Unix domain sockets 1.0/SMP for Linux NET4.0.
NET4: Ethernet Bridge 008 for NET4.0                                          
Looking up port of RPC 100003/2 on 172.16.40.111                              
RPC: sendmsg returned error 128                                                
portmap: RPC call returned error 128                                           
Root-NFS: Unable to get nfsd port number from server, using default            
Looking up port of RPC 100005/1 on 172.16.40.111                               
RPC: sendmsg returned error 128                                                
portmap: RPC call returned error 128                                           
Root-NFS: Unable to get mountd port number from server, using default          
RPC: sendmsg returned error 128                                                
mount: RPC call returned error 128                                             
Root-NFS: Server returned error -128 while mounting /boot/install-mipsel       
VFS: Unable to mount root fs via NFS, trying floppy.                           
VFS: Cannot open root device "nfs" or 02:00                                    
Please append a correct "root=" boot option                                    
Kernel panic: VFS: Unable to mount root fs on 02:00                            
<0>Rebooting in 5 seconds..Please stand by while rebooting the system...       

</PRE>
<P>
<A NAME="NFSBootSetup"><H2> Linux/MIPS TFTP and NFS Setup </H2></A>
On your Redhat 7.x host machine, edit <tt>/etc/xinetd.d/tftp </tt> and enable
the TFTP daemon to accept connections, here is an example file :

<PRE>
# default: off
# description: The tftp server serves files using the trivial file transfer \
#       protocol.  The tftp protocol is often used to boot diskless \
#       workstations, download configuration files to network-aware printers, \
#       and to start the installation process for some operating systems.
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /tftpboot
        disable                 = no
}
</PRE>
<P>
On Solaris machines, simply edit <tt>/etc/inetd.conf</tt> and uncomment the line for TFTP and replace it with something like:
<PRE>
# Tftp service is provided primarily for booting.  Most sites run this
tftp    dgram   udp     wait    root    /usr/sbin/in.tftpd      in.tftpd /boot

</PRE>
<P>



<A NAME="User"><H1>User Applications </H1></A>

Once you have built the CFE loader and Linux kernel and you can boot and
load your Kernel over the network, you are ready for building the Linux user application code which supports a full-featured UNIX environment in as little as 4MB of FLASH (user configurable).<P>

<H2> Core Applications Overview </H2>
In addition to the kernel, source code for a number of Linux user-level applications may also beprovided. The following sections give some details about these
applications.</p>
<UL>
<h3>brctl</h3>
<p>Maintainer: Linux Community</p>
From the brctl man page:</p>
brctl is used to set up, maintain, and inspect the ethernet bridge configuration in the linux kernel.</p>

An ethernet bridge is a device commonly used to connect different
networks of ethernets together, so that these ethernets will appear as one
ethernet to the participants.</p>

Each of the ethernets being connected corresponds to one physical interface in the bridge. These individual ethernets are bundled into one bigger ('logical') ethernet, this bigger ethernet corresponds to the bridge network interface.</p>

<p>Usage:</p>

<p>To bridge together eth0 and eth1 into a new logical
interface br0, do:</p>

<PRE>
brctl addbr br0
brctl addif br0 eth0
brctl addif br0 eth1
</PRE>

<p>See the brctl man page for a more detailed list of options.</p>

<h3>busybox</H3>
Maintainer: Lineo<BR>
License: GPL<BR>
Homepage: <A HREF="http://busybox.lineo.com/">http://busybox.lineo.com</A><BR>
Description:<BR>
From the busybox web site:<BR>

<p>BusyBox combines tiny versions of many common UNIX utilities
into a single small executable. It provides minimalist replacements for most of
the utilities you usually find in fileutils, shellutils, findutils, textutils,
grep, gzip, tar, etc. BusyBox provides a fairly complete POSIX environment for
any small or embedded system. The utilities in BusyBox generally have fewer
options than their full featured GNU cousins; however, the options that are
included provide the expected functionality and behave very much like their GNU
counterparts.</p>

<p>BusyBox has been written with size-optimization and limited
resources in mind. It is also extremely modular so you can easily include or
exclude commands (or features) at compile time. This makes it easy to customize
your embedded systems. To create a working system, just add /dev, /etc, and a
kernel.</p>

<BR>Usage:</BR>

<p>Edit busybox/Config.h to suit your requirements. The BusyBox
binary and the symlinks it generates, as well as a minimal /dev directory,
should be all that is required to get Linux to a shell prompt.</p>

<H3>httpd</h3>
<BR>Maintainer: Broadcom Corporation
<BR>License:
<BR>Homepage:
<BR>Description:

<p>A modified combination of Jef Poskanzer's micro_httpd and mini_httpd, httpd is a minimal web server daemon that calls ooks to handle various types of HTTP/1.0 GET requests. The basic build defines a NULL-terminated list of MIME handlers of the form</p>

<p>{ &lt;pattern&gt;, &lt;mime_type&gt;, &lt;mime_handler&gt;,
&lt;auth_handler&gt; }</p>

<p>See basic.c for a default list that handles most common
requests. More complicated parsing of dynamic HTML files can also be
implemented.<span style="mso-spacerun: yes">&nbsp; </span>The basic build
provides do_file() as an example of handling static HTML files.</p>

<p>To run httpd, start it in the root directory of your HTML
files.</p>

<h3>iptables</h3>
<BR>Maintainer: Netfilter Project
<BR>License: GPL
<BR>Homepage: <A HREF="http://www.netfilter.org">http://www.netfilter.org</A>
<BR>Description:

<p>iptables is the user interface to the Linux 2.4 packet mangling infrastructure (&quot;netfilter&quot;). Netfilter encompasses NAT (including IP masquerading), packet filtering (firewalling), and generalized packet mangling.</p>

<p>Usage:</p>

<p>For embedded needs, it is strongly recommended that netconf be used instead. netconf provides a C API to the kernel networking stack with a much simpler and reduced syntax.</p>

<p>Otherwise, see the iptables man page for detailed
information on usage.</p>

<h3>netconf</h3>

<BR>Maintainer: Broadcom Corporation
<BR>License:
<BR>Homepage:
<BR>Description:

<p>netconf is a C API to the Linux 2.4 kernel networking stack.
netconf provides hooks for accessing Ethernet interfaces, IP routes, NAT, and
packet filter tables.</p>


<p>Usage:</p>

<p>See the netconf header file netconf.h for API definitions
and the rc package for usage examples. The netconf binary provides sample
ifconfig, route, and fw commands implemented using the netconf API. Type
&quot;ifconfig -h&quot; and &quot;route -h&quot; and &quot;fw&quot; for usage
information.</p>

<p>Examples:</p>


<p>From the command line:</p>


ifconfig br0 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255</BR>
route add net 192.168.1.0 netmask 255.255.255.0 br0 fw</BR>

<p>From C:</p>

<PRE>
netconf_if_t interface;

memset(&amp;interface, 0, sizeof(interface));
interface.flags = IFF_UP | IFF_RUNNING | IFF_BROADCAST;
strncpy(interface.name, &quot;br0&quot;,sizeof(interface.name));

inet_aton(&quot;192.168.1.1&quot;, &amp;interface.ipaddr);
inet_aton(&quot;255.255.255.0&quot;,&amp;interface.netmask);
inet_aton(&quot;192.168.1.255&quot;,&amp;interface.broadcast);
netconf_set_interface(&amp;interface);
</PRE>

<h3>nvram</h3>

<BR>Maintainer: Broadcom Corporation
<BR>License:
<BR>Homepage:
<BR>Description:

<p>nvram is a C API to the NVRAM portion of flash memory or battery backed SRAM devices. It provides persistent storage for ASCII text in the form of &quot;name=value&quot; pairs. See the nvram header file bcmnvram.h for API definitions and the rc package for usage examples. The nvram binary provides access to the NVRAM API from the command line and supports &quot;get&quot;, &quot;set&quot;, &quot;unset&quot;, and &quot;show&quot; commands.</p>

<p>Examples:</p>

<p>From the command line:</p>
<PRE>
nvram set foo=bar
nvram get foo
nvram show
nvram unset foo
</PRE>
<p>From C:
<PRE>
nvram_set(&quot;foo&quot;, &quot;bar&quot;);
nvram_get(&quot;foo&quot;);
nvram_getall(buf, sizeof(buf));
nvram_unset(&quot;foo&quot;);
</PRE>

<h3>udhcp</h3>

<BR>Maintainer: Lineo
<BR>License: GPL
<BR>Homepage: <A HREF="http://opensource.lineo.com">http://opensource.lineo.com</A>
<BR>Description:

<p>The udhcp package provides minimal DHCP server and client functionality in a (optionally) single binary. Both are highly configurable through the use of command-line options and configuration files. See the README for more information.</p>

<p>Usage:</p>

<p>A sample udhcpc script is located in samples/sample.script.
Install the script and point the client at it before starting the client. A
sample udhcpd configuration file is located in samples/udhcpd.conf. Install the
configuration file in the location defined in dhcpd.h before starting the
server.</p>

<p>Examples:</p>

<p>From the command line:</p>
<PRE>
udhcpc -i eth1 -s /etc/sample.script
udhcpd
</PRE>

<h3>rc</h3>

<BR>Maintainer: Broadcom Corporation
<BR>License:
<BR>Homepage:
<BR>Description

<p>rc is the master control daemon for the router reference design. It runs as process 1 (&quot;init&quot;) and is responsible for starting and stopping all processes. To add a new process to the system initialization and shutdown sequences, edit main_loop() in rc.c. The state of rc may be controlled from the command line using the rc utility or by sending signals to process 1 from C.</p>

<p>Examples:</p>

<p>From the command line:</p>

<PRE>
rc start
rc stop
rc restart
</PRE>

From C:<P>
<PRE>
kill(1, SIGUSR1);
kill(1, SIGUSR2);
kill(1, SIGHUP);
</PRE>

<h3>tcpdump & libpcap</h3>

<BR>Maintainer: LBNL Networking Group
<BR>License: GPL
<BR>Homepage: http://www.tcpdump.org
<BR>Description<P>

libpcap is a system-independent interface for user-level packet capture.  libpcap provides a portable framework for low-level network monitoring.  Applications include network statistics collection, security monitoring, network debugging, etc.  <P>
The libpcap interface supports a filtering mechanism based on the
architecture in the BSD packet filter.  BPF is described in the 1993
Winter Usenix paper ``The BSD Packet Filter: A New Architecture for
User-level Packet Capture''.  A compressed postscript version is in:<P>

        ftp://ftp.ee.lbl.gov/papers/bpf-usenix93.ps.Z.
<P>
tcpdump is a tool for network monitoring, intrusion detection, traffic analysis and data acquisition.  This software was originally developed by the Network Research Group at the Lawrence Berkeley National Laboratory.  The original distribution is available via anonymous ftp to ftp.ee.lbl.gov, in tcpdump.tar.Z.  More recent development is performed at tcpdump.org, http://www.tcpdump.org/<P>

Tcpdump uses libpcap, a system-independent interface for user-level
packet capture; hence, libpcap is built first in the root-filesystem build.<P>



<h3>fdisk</h3>

<BR>Maintainer: 
<BR>License: GPL
<BR>Homepage:
<BR>Description<P>
`fdisk' is the Linux partition table editor.  It is used to configure DiskOnChip(TM) devices. See the directory <tt>router/src/router/fdisk/README</tt> for more information.
<P>

<h3>ncurses5.2</h3>

<BR>Maintainer: 
<BR>License: GPL
<BR>Homepage:
<BR>Description<P>

The ncurses libraries implement the curses API.  The panel, menu and forms
libraries implement clones of the SVr4 panel, menu and forms APIs.  The source
code for these lives in the `ncurses', `panel', `menu', and `form' directories
respectively. ncurses is used by terminal applications which would like to implement a basic user interface.<P>
To do its job, the ncurses code needs your terminal type to be set in the
environment variable TERM (normally set by your OS; under UNIX, getty(1)
typically does this, but you can override it in your .profile); and, it needs a
database of terminal descriptions in which to look up your terminal type's
capabilities.
<P>

<h3>terminfo</h3>

<BR>Maintainer: 
<BR>License: GPL
<BR>Homepage:
<BR>Description<P>

terminfo supports a small, embedded terminfo database for use in embedded Linux applications. Currently support for linux, linux-c (color), vt100, and dtterm terminal types are supported.

<P>

<h3>iproute2+tc</h3>

<BR>Maintainer: 
<BR>License: GPL
<BR>Homepage: http://lartc.org/
<BR>Description<P>
<P>
iproute2+tc is the first release of the Traffic control Engine for Linux. It will be superseded by tcng (http://tcng.sourceforge.net/). Using iproute2+tc, one can control the Bandwidth and WFQ engine internal to Linux 2.4. Note that this software may not be available in future releases.
</UL>
<P>
<P>



<A NAME="ROOTFS"><H2> Building the User Applications </H2></A>
When you build the Linux applications, you have the option for building either a router application (for Access Point) or a standalone BSP (which just runs the shell). These configuration options are dependent on the building of the <tt>rc</tt> initialization library. <P>

To build the router application:<P>

<PRE>
cd src/router
make
make install
</PRE>

The output of the above commands will be a tarfile and directory called
<tt>src/router/install-mipsel</tt> which you will use as your NFS mountpoint.
To configure the Linux kernel to boot and mount via NFS, you would use the <tt>kernel_args</tt> parameter to configure the system. From previous setup and configuration, type the following at the <tt>CFE</tt> prompt:


<PRE>
setenv -p kernel_args "console=ttyS1,115200 ip=172.16.40.113:172.16.40.111:10.16.64.1:255.255.240.0:switch-2:eth0 root=/dev/nfs rw nfsroot=172.16.40.111:/boot/install-mipsel,timeo=200,retrans=500 nfsaddrs=172.16.40.113:172.16.40.111 noinitrd"

</PRE>

Note that you will have to change your parameters as appropriate, once you have done this step, you should be able to mount the NFS root filesystem from the BCM94702 CPCI client. In order todo this, you may need to configure NFS on your boot/build server first.<P>


The first time your system boots, you will not have an NVRAM configuration other than that which you configured from CFE. When the router application starts, it will search the NVRAM variables for a configuration variable <tt>restore_defaults</tt> to determine whether or not the system has any configuration data. If this variable is not present, then the router application will restore defaults. Unfortunately, the default behaviour for configuration of device eth0 is to acquire an IP address via DHCP<P>


So, the first time you boot, after you see the message:<P>

"Restoring defaults"<P>


You should hit enter to get to the shell and type the following commands:<P>

<PRE>
nvram set wan_proto=static
nvram set wan_ifname=eth0
nvram set wan_ipaddr=172.16.40.11
nvram set wan_netmask=255.255.240.0
nvram set wan_gateway=172.160.40.111
</PRE>

If your system does not give you a prompt, you must reboot your
platform (or power-cycle if your system hangs after it starts) and at
the CFE prompt, set the following NVRAM variables:<P>

<PRE>
setenv -p wan_proto static
setenv -p wan_ifname eth0
setenv -p wan_ipaddr 172.16.40.11
setenv -p wan_netmask 255.255.240.0
setenv -p wan_gateway 172.160.40.111
</PRE>

The reason this happens is because the router is setup to DHCP for the
WAN address (eth0) bye default which you are using to mount the root
filesystem. When you first boot the router application, it looked for
the nvram environment variable "restore_defaults" which, if not
present, reset the router configuration.<P>

Consequently, since you are booting the kernel over the network
(initially) and the router will take over the devices for DHCP, you're
device will not be configured correctly as a result. To fix this issue,
simply reconfigure your IP interface using the variable names below. Once
this has been accomplished, you should be able to reboot your system and
see a full initialization as below.<P>




<PRE>

CFE version 1.0.34 for BCM94702_CPCI (32bit,SP,LE)  
Build Date: Thu Nov  7 15:52:37 PST 2002 (jfd@que)   
Copyright (C) 2000,2001,2002 Broadcom Corporation.                           

Initializing Arena.                                                            
Initializing Devices.                                                         
et0: Broadcom BCM47xx 10/100 Mbps Ethernet Controller                          
et1: Broadcom BCM47xx 10/100 Mbps Ethernet Controller                          
CPU type 0x24000: 100MHz                                                       
Total memory: 0x1000000 bytes (16MB)                                           
                                                                                
Total memory used by CFE:  0x80F73780 - 0x81000000 (575616)                    
Initialized Data:          0x80F73780 - 0x80F74F00 (6016)                      
BSS Area:                  0x80F74F00 - 0x80F76980 (6784)                      
Local Heap:                0x80F76980 - 0x80FB6980 (262144)                    
Stack Area:                0x80FB6980 - 0x80FB8980 (8192)                      
Text (code) segment:       0x80FB8980 - 0x80FFFFB8 (292408)                    
Boot area (physical):      0x00F32000 - 0x00F72000                             
Relocation Factor:         I:E13B8980 - D:00F72780                             
                                                                               
et0: link up                                                                   
Device eth0:  hwaddr 40-00-00-47-10-10, ipaddr 172.16.40.113, mask 255.255.240.0 gateway 10.16.64.1, nameserver 10.16.64.11                              
Loader:elf Filesys:tftp Dev:eth0 File:172.16.40.111:vmlinux.stab Options:(null)
Loading: 0x80001000/1990832 0x801e70b0/318252 Entry at 0x800027a8              
Closing network.                                                               
et0: link down                                                                 
Starting program at 0x800027a8                                                 
Loading MIPS32 MMU routines.                                                   
CPU revision is: 00024000                                                      
Primary instruction cache 8kb, linesize 16 bytes (2 ways)                      
Primary data cache 4kb, linesize 16 bytes (2 ways)                             
Number of TLB entries 32.                                                      
Linux version 2.4.5 (jfd@que) (gcc version 3.0 20010422 (prerelease) with bcm472
RTC: 11/0/2003, 10:52:03                                                       
Determined physical RAM map:                                                   
 memory: 01000000 @ 00000000 (usable)                                          
On node 0 totalpages: 4096                                                     
zone(0): 4096 pages.                                                           
zone(1): 0 pages.                                                              
zone(2): 0 pages.                                                              
Kernel command line: console=ttyS1,115200 ip=172.16.40.113:172.16.40.111:10.16.d
New MIPS time_init() invoked.                                                  
CPU: BCM4702at 100 MHz                                                         
get_rtc_time: 2003-11-00 10:52:03.                                             
Calibrating delay loop... 66.56 BogoMIPS                                       
Memory: 13860k/16384k available (1762k kernel code, 2524k reserved, 93k data, 8
Dentry-cache hash table entries: 2048 (order: 2, 16384 bytes)                  
Inode-cache hash table entries: 1024 (order: 1, 8192 bytes)                    
Buffer-cache hash table entries: 1024 (order: 0, 4096 bytes)                   
Page-cache hash table entries: 4096 (order: 2, 16384 bytes)                    
Checking for 'wait' instruction...  unavailable.                               
POSIX conformance testing by UNIFIX                                            
PCI: Probing PCI hardware                                                      
PCI: Fixing up bus 0                                                           
PCI: Fixing up bridge                                                          
PCI: Setting latency timer of device 01:00.0 to 64                             
PCI: Enabling device 01:00.0 (0000 -> 0002)                                    
PCI: Fixing up bus 1                                                           
Linux NET4.0 for Linux 2.4                                                     
Based upon Swansea University Computer Society NET3.039                        
Initializing RT netlink socket                                                 
Starting kswapd v1.8                                                           
devfs: v0.102 (20000622) Richard Gooch (rgooch@atnf.csiro.au)                  
devfs: boot_options: 0x0                                                       
Serial driver version 5.05a (2001-03-20) with MANY_PORTS SHARE_IRQ SERIAL_PCI ed
ttyS00 at 0x0000 (irq = 0) is a ST16650                                        
ttyS01 at 0x0000 (irq = 2) is a ST16650                                        
block: queued sectors max/low 9093kB/3031kB, 64 slots per queue                
RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize          
loop: loaded (max 8 devices)                                                   
TFFS 5.1.1 Flash disk driver for DiskOnChip                                    
Copyright (C) 1998,2001 M-Systems Flash Disk Pioneers Ltd.                     
DOC device(s) found: 1 at 0xbf006000                                           
fl_init: registered device at major: 101                                       
fl_geninit: registered device at major: 101                                    
Partition check:                                                               
 fla: unknown partition table                                                  
partition: /dev/fl/0: start_sect: 0,nr_sects: 55808 Fl_blk_size[]: 27904KB     
partition: /dev/fl/1: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
partition: /dev/fl/2: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
partition: /dev/fl/3: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB             
PPP generic driver version 2.4.1                                               
Registered PPPoX v0.5                                                          
Registered PPPoE v0.6.5                                                        
eth0: Broadcom BCM47xx 10/100 Mbps Ethernet Controller 2002.9.27.0 (BROADCOM IN)
eth1: Broadcom BCM47xx 10/100 Mbps Ethernet Controller 2002.9.27.0 (BROADCOM IN)
il0: chipattach: nvram_get(il0macaddr) not found                                
il0: chipattach error                                                           
il0: ilc_attach() failed                                                        
CFI: Found no Physically mapped flash device at location zero                   
sflash: chipcommon not found                                                    
NET4: Linux TCP/IP 1.0 for NET4.0                                               
IP Protocols: ICMP, UDP, TCP, IGMP                                              
IP: routing cache hash table of 512 buckets, 4Kbytes                            
TCP: Hash tables configured (established 1024 bind 2048)                        
IP-Config: Gateway not on directly connected network.                           
ip_conntrack (128 buckets, 1024 max)                                            
ip_tables: (c)2000 Netfilter core team                                          
NET4: Unix domain sockets 1.0/SMP for Linux NET4.0.                             
NET4: Ethernet Bridge 008 for NET4.0                                            
Looking up port of RPC 100003/2 on 172.16.40.111                                
Looking up port of RPC 100005/2 on 172.16.40.111                                
VFS: Mounted root (nfs filesystem).                                             
Mounted devfs on /dev                                                           
Freeing unused kernel memory: 84k freed                                         
Algorithmics/MIPS FPU Emulator v1.4                                             
Hit enter to continue...et0: link up                                            
info, udhcp server (v0.9.7) started                                             
eth0: No such process                                                           
info, udhcp server (v0.9.7) started                                             
killall: upnp: no process killed                                                
killall: nas: no process killed                                                 
Hit enter to continue...                                                        
                                                                                
                                                                                
BusyBox v0.60.0 (2002.10.29-05:52+0000) Built-in shell (msh)                    
Enter 'help' for a list of built-in commands.                                   
                                                                                
#                                                                               
# nvram show                                                                    
james=here                                                                      
et0phyaddr=2                                                                    
et0mdcport=0                                                                    
et1phyaddr=1                                                                    
et1mdcport=1                                                                    
et0macaddr=40-00-00-47-10-10                                                    
et1macaddr=40-00-00-47-10-11                                                    
pcitestfreq=0                                                                   
wan_hwname=                                                                     
timer_interval=3600                                                             
ntp_server=                                                                     
log_level=0                                                                     
time_zone=PST8PDT                                                               
upnp_enable=0                                                                   
os_server=http://router:kilroy@64.162.141.122                                   
stats_server=http://router:kilroy@64.162.141.122/cgi-bin/stats.pl               
console_loglevel=7                                                              
log_ipaddr=                                                                     
lan_proto=dhcp                                                                  
lan_ipaddr=192.168.1.1                                                          
lan_netmask=255.255.255.0                                                       
wan_dns=                                                                        
wan_wins=                                                                       
wan_lease=864000                                                                
static_route=                                                                   
filter_ip=                                                                      
filter_tcp=                                                                     
filter_udp=                                                                     
filter_mac=                                                                     
forward_tcp=                                                                    
forward_udp=                                                                    
dmz_ipaddr=                                                                     
dhcp_start=192.168.1.100                                                        
dhcp_end=192.168.1.150                                                          
http_username=router                                                            
http_passwd=kilroy                                                              
http_wanport=8080                                                               
http_lanport=80                                                                 
pppoe_ifname=                                                                   
pppoe_username=                                                                 
pppoe_passwd=                                                                   
pppoe_idletime=60                                                               
pppoe_keepalive=0                                                               
pppoe_demand=0                                                                  
pppoe_mru=1500                                                                  
pppoe_mtu=1500                                                                  
wl_ssid=Broadcom                                                                
wl_closed=0                                                                     
wl_mode=ap                                                                      
wl_lazywds=0                                                                    
wl_wds=                                                                         
wl_wep=off                                                                      
wl_auth=0                                                                       
wl_key=1                                                                        
wl_key1=                                                                        
wl_key2=                                                                        
wl_key3=                                                                        
wl_key4=                                                                        
wl_mac=                                                                         
wl_macmode=allow                                                                
radius_ipaddr=                                                                  
radius_key=                                                                     
radius_port=1812                                                                
d11b_hwaddr=                                                                    
d11b_channel=11                                                                 
d11b_rate=0                                                                     
d11b_rateset=default                                                            
d11b_frag=2346                                                                  
d11b_rts=2347                                                                   
d11b_dtim=3                                                                     
d11b_bcn=100                                                                    
d11b_plcphdr=long                                                               
d11a_hwaddr=                                                                    
d11a_channel=64                                                                 
d11a_rate=0                                                                     
d11a_rateset=default                                                            
d11a_frag=2346                                                                  
d11a_rts=2347                                                                   
d11a_dtim=3                                                                     
d11a_bcn=100                                                                    
d11g_hwaddr=                                                                    
d11g_channel=11                                                                 
d11g_rate=0                                                                     
d11g_rateset=default                                                            
d11g_frag=2346                                                                  
d11g_rts=2347                                                                   
d11g_dtim=3                                                                     
d11g_bcn=100                                                                    
d11g_mode=1                                                                     
restore_defaults=0                                                              
wan_proto=static                                                                
wan_ifname=eth0                                                                 
wan_ipaddr=172.16.40.113                                                        
wan_netmask=255.255.240.0                                                       
wan_gateway=172.16.40.111                                                       
wan_domain=sj.broadcom.com                                                      
wan_hostname=switch-2                                                           
lan_ifname=eth1                                                                 
lan_stp=0                                                                       
lan_ifnames=eth1                                                                
lan_hwnames=et1                                                                 
watchdog=5000                                                                   
kernel_args=console=ttyS1,115200 ip=172.16.40.113:172.16.40.111:10.16.64.1:255.d
STARTUP=ifconfig eth0 -addr=172.16.40.113 -mask=255.255.240.0 -gw=10.16.64.1 -db
os_name=linux                                                                   
os_version=2002.9.27.0 (BROADCOM INTERNAL)                                      
lan_hwaddr=40:00:00:47:10:11                                                    
wan_hwaddr=40:00:00:47:10:10                                                    
                                                                                
size: 2141 bytes (30627 left)                                                   
#                                                                               
</PRE>



<A NAME="NVRAM"><H2> NVRAM Router Configuration Variables </H2></A>

The following configuration parameters are used by the router
application for configuring the behaviour of the system. Each nvram
environment variable and its usage is describe below. For more
information, see the source code for <tt>rc</tt>.


<H3> Network Parameters</H3>
<UL>

<LI>lan_ifname - Linux LAN interface device name.  Typically bcm0 (switch)

<LI>lan_ifnames - Linux LAN interface enslaved device names.  Typically eth0 ethX..

<LI>wan_ifname - Linux WAN interface device name.  Typically eth0

<LI>wan_ifnames - Linux WAN interface enslaved device names.  Typically blank.

<LI>lan_proto - Type of IP addresses to be used on the LAN interface.  Can
            be either static or dhcp

<LI>lan_ipaddr - Default IP address on the LAN interface.  Typically 192.168.1.1

<LI>lan_netmask - IP netmask on the LAN interface.  Typically 255.255.255.0

<LI>wan_proto - Type of IP addresses to be used on the WAN interface.  Can
            be either static or dhcp

<LI>wan_ipaddr - Default IP address on the WAN interface.  If wan_proto
             was set to DHCP, this should be set to 0.0.0.0

<LI>wan_netmask - IP netmask on the WAN interface. If wan_proto was set to
              DHCP, this should be set to 0.0.0.0

<LI>wan_gateway - IP gateway to be used on the WAN interface. If wan_proto
              was set to DHCP, this should be set to 0.0.0.0

<LI>wan_dns - IP address of the DNS server to be used on the WAN
          interface.  If wan_proto was set to DHCP, this field should be left
          blank.

<LI>wan_wins - IP address of the WINS server to be used on the WAN interface. If
	   wan_proto was set to DHCP, this field should be left blank.

<LI>wan_hostname - IP host name to be used on the WAN interface. If
               wan_proto was set to DHCP, this field should be left blank.

<LI>wan_domain - IP domain name to be used on the WAN interface. If
             wan_proto was set to DHCP, this field should be left blank.

</UL>
 
<H3> Firmware Upgrade Parameters</H3>
<UL>
<LI>sw_version - The current router software revision.

<LI>sw_server - URL of the upgrade server.
</UL>


<H3> Firewall Parameters </H3>
<UL>
<LI>fw_disable - Flag to enable/disable the firewall protection.  Set to 0 to keep
	     firewall disabled and set to 1 to disable the firewall.
</UL>

<H3> LAN Filters </H3>
<UL>
<LI>filter_ip - A list of ranges, separated by spaces, of IP addresses to
            be filtered on the LAN interfaces.  For example
            192.168.1.100-192.168.1.101 192.168.1.150-192.168.1.150

<LI>filter_tcp - Lists IP address and TCP port ranges that the router
             should block.  For instance, to block ports 80-81 on
             192.168.1.100: filter_tcp=192.168.1.100:80-01 To block
             ports 80-81 on ALL LAN clients: filter_tcp=*:80-81

<LI>filter_udp - This variable has the same syntax as the filter_tcp
	     variable.  The difference is that it pertains to UDP
	     ports instead of TCP ports.

<LI>filter_mac - A list of MAC addresses, separated by commas, to be
	     filtered on the LAN interfaces.
</UL>
 

<H3> Port Forwards </H3>
<UL>
<LI>forward_tcp - Indicates ranges of TCP port numbers and to where they
	    should be forwared to on the LAN.  For instance, to
	    forward ports 80-81 to IP address 192.168.1.100 on the
	    LAN, ports 80-81: 80-81>192.168.1.1:80-81 Additional TCP
	    port forwards can be appended, separated by a space
	    character.

<LI>forward_udp - Indicates ranges of UDP port numbers and to where they
	    should be forwared to on the LAN.  For instance, to
	    forward ports 80-81 to IP address 192.168.1.100 on the
	    LAN, ports 80-81: 80-81>192.168.1.1:80-81 Additional UDP
	    port forwards can be appended, separated by a space
	    character.
</UL>
 

<H3> DHCP server parameters </H3>
<UL>
<LI>dhcp_start - Beginning of range of LAN IP addresses to be handed out
	     by the DHCP server.

<LI>dhcp_end - End of range of LAN IP addresses to be handed out by the
	   DHCP server.
</UL>
 

<H3> Web server parameters </H3>
<UL>
<LI>http_username - Username required to access configuration web pages.
	        This field can be left blank if desired, typically set
		to blank or "router"

<LI>http_passwd - Default password required to access the configurations
	      web pages.  Typicallay set to "admin" or "kilroy"

<LI>http_lanport - Default port number used to access configuration web
	       pages on the LAN interface.  Typically set to 80

<LI>http_wanport - Default port number used to access configuration web
	      pages from the WAN interface.  Typically set to 8080
</UL>
 

<H3> PPPOE parameters </H3>
<UL>
<LI>pppoe_username - Login name to be used when making a PPPOE connection.

<LI>pppoe_passwd - Password to be used when making a PPPOE connection.

<LI>pppoe_idletime - Timeout value, in seconds, after which the PPPOE
	         connection will be terminated if there has been no activity.

<LI>pppoe_keepalive - Set to 1 to automatically reconnect when a PPPoE
                  link goes down.

<LI>pppoe_demand - Set to 1 to only bring up the PPPoE link when it is
	       necessary.  (NOTE: This functionality is not currently
	       enabled.)
</UL>
 

<H3>Restore defaults</H3>
<UL>
<LI>restore_defaults - Set to restore to factory defaults on the next
		   reset.  0 if no restore required, 1 to perform
		   restore.
</UL>
 

<H2> <A NAME="DOCConfig">Configuring DiskOnChip (TM) TFFS Flash Devices </H2>
Once you can boot the Linux kernel over the network via TFTP, and mount the <tt>install-mipsel</tt> root-filesystem via NFS from your boot-server, you are ready to configure the DiskOnChip (TM) FLASH devices for use as a boot device, as well as a True FLASH Filesystem (TFFS).<P> 
The first step in configuring the DiskOnChip(TM) device is to use the <tt>DFORMAT</tt> utility to low-level format the device, this process performs several important steps:
<OL>
<LI>Identification of the DiskOnChip (TM) device and the factory programmed Bad block table on the device.
<LI>Creation of a Binary partition to use as storage for the Linux kernel image; this region is a special region, invisible to FDISK and the native Filesystem.
<LI>Formatting of the Inverse-Nand or Nand Flash Translation Layer format (INFTL/NFTL) depending upon the device. This flash-translation layer is used by the upper-level block driver for managing sectors.
<LI>Storage of the Linux kernel in the reserved Binary partition.
</OL>
Once you have completed these steps, you will be ready to create a disk partition table using <tt>FDISK</tt> and can then format the filesystem using the filesystem of your choice (<TT>EXT2</TT>, <TT>EXT3</TT>, etc).
<P>
<H3> Create Kernel Image </H3>
To begin with, you must prepare the Linux kernel image by running the <tt>docprep</tt> utility which will allow the EDC/ECC H/W error correction and detection feature of the DiskOnChip (TM) to work correctly. To perform this step, use the <tt>docprep</tt> tool found in <tt>src/cfe/build/broadcom/bcm94702cpci/docprep</tt> to create a new file.
<PRE>
#docprep /boot/vmlinux.stab vmlinux.doc
Total Size: 3178496 bytes (3178496 bytes aligned [308000]),32155 bytes pad)
Wrote 3178496 bytes to vmlinux.doc
#
</PRE>
<H3> Estimate Binary Partition Size </H3>
In the example above, we found that an uncompressed kernel image, after properly padded, was 3.2MB in size. Consequently, we should plan on using at least a 4MB binary partition to store the image. Once you have decided that you will need this much space, you will be left with the remaining space on the drive for use as a FLASH filesystem. For example, if you have a 32MB device, and you need 4MB for the kernel image, you will be left with 28MB for FLASH filesystem space. <P>
<em>Note that we could strip the image to make it smaller in size, and future releases will support GZIP compressed images. </em>

<H3> Run DFORMAT utility </H3>
You are now ready to run the DFORMAT utility which will create the binary partition named <tt>BIPO</tt> of the specified size, format the chip, and write the kernel image to the device (all in one command). Use the following command to run DFORMAT; not that the device base address and partition name (<tt>BIPO</tt>) will remain constant, however, partition size and file to write are variable and should be changed to suit your particular application. 
<P>
<PRE>
dformat -win:1f006000 -bdkL0:4M -bdkN0:BIPO -bdkF0:vmlinux.doc -y
</PRE>
<P>Here is an example:
<PRE>
# dformat -win:1f006000 -bdkL0:4M -bdkN0:BIPO -bdkF0:vmlinux.doc -y
DFORMAT Version 5.1.0.26 for Linux (MIPS_LE)
Copyright (C) M-Systems, 1992-2002

mmap: 0x1f006000/0x1f006000 (DOC low/high), Map Size: 8192 bytes, Memory Range:0
Debug: entering NFDC MDOCP identification routine.
Debug: identified NFDC MDOCP.
Debug: starting INFTL preMount operation.

Debug: flash=0x10004de0, flash->flags=0x4
Debug: entering NFDC MDOCP identification routine.
Debug: identified NFDC MDOCP.
Millennium DiskOnChip Plus found in 0x1f006000.
32M media, 32K unit
Debug: flFormatPhysicalDrive.
Debug: entering NFDC MDOCP identification routine.
Debug: identified NFDC MDOCP.
Debug: starting INFTL format by verifying arguments.
Debug: initINFTL: flash=0x10004de0

Debug: flash=0x10004de0, flash->flags=0x4
Debug: INFTL format arguments have been verified, starting format.

Debug: finished INFTL format.

Debug: starting INFTL dismount.
Debug: finished INFTL dismount.
Debug: entering NFDC MDOCP identification routine.
Debug: identified NFDC MDOCP.
Debug: starting INFTL mount: flash=0x10004de0
Debug: initINFTL: flash=0x10004de0

Debug: flash=0x10004de0, flash->flags=0x4
Debug: finished INFTL mount.

Debug: starting INFTL dismount.
Debug: finished INFTL dismount.
Debug: entering NFDC MDOCP identification routine.
Debug: identified NFDC MDOCP.

Debug: searching for TL media header.
INFTL media header encounterd.
Debug: getBootAreaInfo() - BDK mount succeed.
Debug: searching for signtured blocks.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Debug: getBootAreaInfo() - Reading unit signature...
Debug: getBootAreaInfo() - Signature read done.
Writing file to BDK 0    2031616
Writing file to BDK 0    3178496
OK
Please reboot to let DiskOnChip install itself.
#
#
#

</PRE>
You should now reboot your system and see that the new partition table has been adjusted for the size of the binary partition you created above. This is the amount of space on the device available to the native filesystem. For example:
<PRE>
TFFS 5.1.1 Flash disk driver for DiskOnChip
Copyright (C) 1998,2001 M-Systems Flash Disk Pioneers Ltd.
DOC device(s) found: 1 at 0xbf006000
Partition check:
 fla: unknown partition table
partition: /dev/fl/0: start_sect: 0,nr_sects: 55808 Fl_blk_size[]: 27904KB
partition: /dev/fl/1: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB
partition: /dev/fl/2: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB
partition: /dev/fl/3: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB
</PRE>

Your device is now ready to store a partition table entry and, finally, to be formatted with the native filesystem of your choice.<P>
<P>
<em> Note that for most applications, 4MB is more then sufficient, although this can (and will) be optimized. </em>
<P>
<H3> Run FDISK to Create Partition Table </H3>
You are now ready to create a partition with all the remaining sectors for use by the native filesystem. Here is how you do this using <tt>fdisk</tt>:<P>
<PRE>
# fdisk /dev/fl/0
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklal
Building a new DOS disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content won't be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-996, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-996, default 996):
Using default value 996

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
 fl/disc0/disc: p1
 fl/disc0/disc: p1
devfs: devfs_register(): device already registered: "part1"
Syncing disks.
#
# fdisk /dev/fl/0

Command (m for help): p

Disk /dev/fl/0: 14 heads, 4 sectors, 996 cylinders
Units = cylinders of 56 * 512 bytes

     Device Boot    Start       End    Blocks   Id  System
/dev/fl/0p1             1       996     27886   83  Linux

Command (m for help): q

#
</PRE>
Note that the second time we ran the command, we verified the size of
the partition and how many blocks are available for the native filesystem format.<P>
<H3> Create Native Filesystem </H3>
Currently, the target root filesystem is setup to use <tt>EXT2</tt> native Linux filesystem format. Here is how to format the device and install a filesystem which Linux can use just like a Disk device:<P>
<PRE>
# mke2fs -m 0 /dev/fl/0
mke2fs 1.27 (8-Mar-2002)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
6976 inodes, 27904 blocks
0 blocks (0.00%) reserved for the super user
First data block=1
4 block groups
8192 blocks per group, 8192 fragments per group
1744 inodes per group
Superblock backups stored on blocks:
        8193, 24577

Writing inode tables: done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 25 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
#
</PRE>
<em>Note that we used the <tt> -m 0 </tt> option not to reserve space for the
root user (which doesn't make sense for an embedded Linux application).</em>
<P>
<H3> Install Root Filesystem </H3>
Your DiskOnChip (TM) now stores a kernel, a partition table with the blocks not used by the kernel binary partition, and a native filesystem. You are now ready to install the Linux root-filesystem which you are currently running via NFS.
Todo this, copy the install-mipsel.tar file into the NFS boot directory, mount the device, and arrange the filesystem. Here is an example:<P>
<PRE>
# ls -l install-mipsel.tar
-rw-rw-r--    1 1014     20       14448640 Nov 12  2002 install-mipsel.tar
# mount -t ext2 /dev/fl/0 /mnt
# df
Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/root              3095966   2668475    365572  88% /
/dev/fl/0                27017        13     27004   0% /mnt
# cd /mnt
# ln -s /install-mipsel.tar .
# tar -xvf install-mipsel.tar
./install-mipsel/
./install-mipsel/usr/
./install-mipsel/usr/sbin/
./install-mipsel/usr/sbin/brctl
./install-mipsel/usr/sbin/httpd
./install-mipsel/usr/sbin/netconf
./install-mipsel/usr/sbin/fw
./install-mipsel/usr/sbin/ntpclient
./install-mipsel/usr/sbin/nvram
./install-mipsel/usr/sbin/pppoecd
./install-mipsel/usr/sbin/udhcpd
./install-mipsel/usr/sbin/dumpleases
./install-mipsel/usr/sbin/udhcpc
./install-mipsel/usr/sbin/upnp
./install-mipsel/usr/sbin/iptables
./install-mipsel/usr/bin/
./install-mipsel/usr/bin/basename
./install-mipsel/usr/bin/dirname
./install-mipsel/usr/bin/free
./install-mipsel/usr/bin/killall
./install-mipsel/usr/bin/logger
./install-mipsel/usr/bin/route
./install-mipsel/usr/bin/telnet
./install-mipsel/usr/bin/traceroute
./install-mipsel/usr/bin/uptime
./install-mipsel/usr/bin/wget
./install-mipsel/usr/lib/
./install-mipsel/usr/lib/libnetconf.so
./install-mipsel/usr/lib/libnvram.so
./install-mipsel/usr/lib/iptables/
./install-mipsel/usr/lib/iptables/libipt_DNAT.so
./install-mipsel/usr/lib/iptables/libipt_mac.so
./install-mipsel/usr/lib/iptables/libipt_MASQUERADE.so
./install-mipsel/usr/lib/iptables/libipt_SNAT.so
./install-mipsel/usr/lib/iptables/libipt_standard.so
./install-mipsel/usr/lib/iptables/libipt_state.so
./install-mipsel/usr/lib/iptables/libipt_TCPMSS.so
./install-mipsel/usr/lib/iptables/libipt_tcp.so
./install-mipsel/usr/lib/iptables/libipt_udp.so
./install-mipsel/usr/share/
./install-mipsel/usr/share/terminfo/
./install-mipsel/usr/share/terminfo/d/
./install-mipsel/usr/share/terminfo/d/dtterm
./install-mipsel/usr/share/terminfo/l/
./install-mipsel/usr/share/terminfo/l/linux
./install-mipsel/usr/share/terminfo/l/linux-c
./install-mipsel/usr/share/terminfo/v/
./install-mipsel/usr/share/terminfo/v/vt100
./install-mipsel/usr/tmp
./install-mipsel/bin/
./install-mipsel/bin/busybox
./install-mipsel/bin/cat
./install-mipsel/bin/chmod
./install-mipsel/bin/cp
./install-mipsel/bin/date
./install-mipsel/bin/dd
./install-mipsel/bin/df
./install-mipsel/bin/dmesg
./install-mipsel/bin/echo
./install-mipsel/bin/false
./install-mipsel/bin/grep
./install-mipsel/bin/kill
./install-mipsel/bin/ln
./install-mipsel/bin/ls
./install-mipsel/bin/mkdir
./install-mipsel/bin/mknod
./install-mipsel/bin/more
./install-mipsel/bin/mount
./install-mipsel/bin/msh
./install-mipsel/bin/mv
./install-mipsel/bin/ping
./install-mipsel/bin/ps
./install-mipsel/bin/pwd
./install-mipsel/bin/rm
./install-mipsel/bin/rmdir
./install-mipsel/bin/sed
./install-mipsel/bin/sh
./install-mipsel/bin/sleep
./install-mipsel/bin/sync
./install-mipsel/bin/tar
./install-mipsel/bin/touch
./install-mipsel/bin/true
./install-mipsel/bin/umount
./install-mipsel/bin/uname
./install-mipsel/bin/vconfig
./install-mipsel/bin/dformat
./install-mipsel/bin/fdisk
./install-mipsel/bin/clear
./install-mipsel/bin/iptraf
./install-mipsel/bin/rvnamed
./install-mipsel/bin/rawtime
./install-mipsel/bin/cfconv
./install-mipsel/sbin/
./install-mipsel/sbin/halt
./install-mipsel/sbin/ifconfig
./install-mipsel/sbin/init
./install-mipsel/sbin/insmod
./install-mipsel/sbin/lsmod
./install-mipsel/sbin/makedevs
./install-mipsel/sbin/modprobe
./install-mipsel/sbin/pivot_root
./install-mipsel/sbin/reboot
./install-mipsel/sbin/rmmod
./install-mipsel/sbin/syslogd
./install-mipsel/sbin/rc
./install-mipsel/sbin/erase
./install-mipsel/sbin/write
./install-mipsel/sbin/stats
./install-mipsel/sbin/hotplug
./install-mipsel/sbin/mke2fs
./install-mipsel/sbin/e2fsck
./install-mipsel/sbin/tune2fs
./install-mipsel/sbin/tcpdump
./install-mipsel/www/
./install-mipsel/www/filter.asp
./install-mipsel/www/firmware.asp
./install-mipsel/www/forward.asp
./install-mipsel/www/index.asp
./install-mipsel/www/internal.asp
./install-mipsel/www/status.asp
./install-mipsel/www/wireless.asp
./install-mipsel/www/blur_new.jpg
./install-mipsel/www/btn.gif
./install-mipsel/www/logo_new.gif
./install-mipsel/www/repeat_edge_new.gif
./install-mipsel/www/style.css
./install-mipsel/www/overlib.js
./install-mipsel/etc/
./install-mipsel/etc/init.d/
./install-mipsel/etc/init.d/rcS
./install-mipsel/etc/inittab
./install-mipsel/etc/pcmcia/
./install-mipsel/etc/pcmcia/config
./install-mipsel/etc/termcap
./install-mipsel/etc/ld.so.conf
./install-mipsel/etc/ld.so.cache
./install-mipsel/lib/
./install-mipsel/lib/libform.so.5
./install-mipsel/lib/libmenu.so.5
./install-mipsel/lib/libncurses.so.5
./install-mipsel/lib/libpanel.so.5
./install-mipsel/lib/libc.so.6
./install-mipsel/lib/ld.so.1
./install-mipsel/lib/libanl.so.1
./install-mipsel/lib/libBrokenLocale.so.1
./install-mipsel/lib/libcrypt.so.1
./install-mipsel/lib/libdl.so.2
./install-mipsel/lib/libgcc_s.so.0
./install-mipsel/lib/libgcjgc.so.1
./install-mipsel/lib/libgcjgc.so.1.0.1
./install-mipsel/lib/libm.so.6
./install-mipsel/lib/libnsl.so.1
./install-mipsel/lib/libnss_compat.so.2
./install-mipsel/lib/libnss_dns.so.2
./install-mipsel/lib/libnss_files.so.2
./install-mipsel/lib/libnss_hesiod.so.2
./install-mipsel/lib/libnss_nisplus.so.2
./install-mipsel/lib/libnss_nis.so.2
./install-mipsel/lib/libpthread.so.0
./install-mipsel/lib/libresolv.so.2
./install-mipsel/lib/librt.so.1
./install-mipsel/lib/libthread_db.so.1
./install-mipsel/lib/libutil.so.1
./install-mipsel/lib/libzgcj.so.0
./install-mipsel/lib/libzgcj.so.0.0.0
./install-mipsel/tmp/
./install-mipsel/tmp/var/
./install-mipsel/var/
./install-mipsel/var/iptraf/
./install-mipsel/var/log/
./install-mipsel/var/run/
./install-mipsel/var/var
./install-mipsel/dev/
./install-mipsel/mnt/
./install-mipsel/proc/
# mv install-mipsel/* .
# rmdir install-mipsel
# rm install-mipsel.tar
# ls
www         usr         sbin        mnt         etc         bin
var         tmp         proc        lib         dev         lost+found
# cd /
# umount /mnt
</PRE>
Your device is now ready for use in a production environment. To configure the system to use the device, see <A HREF="#DOCBOOT"> Configuring DiskOnChip (TM) as CFE Boot Device </A>.

<H2> <A NAME="DOCBoot">Configuring DiskOnChip (TM) as CFE Boot Device </H2>
Now that you have the device formatted, and a filesystem installed, you must
perform the following final steps:
<P>
<UL>
<LI> Inform Linux of the root device, this is accomplished by changing the <tt>kernel_args</tt> NVRAM variable.
<LI> Inform CFE of the new <tt>STARTUP</tt> command which will boot the Linux kernel from the Binary partition on the DiskOnChip(TM) device.
</UL>
To perform these steps, you can configure the NVRAM from either CFE or from the Router application:<P>
<H3> From CFE </H3>
<PRE>
setenv -p STARTUP boot -elf -loader=doc doc0:0
setenv -p kernel_args "console=ttyS1,115200 root=/dev/fl/0"
</PRE>
<H3> From Linux </H3>
<PRE>
nvram set STARTUP="boot -elf -loader=doc doc0:0"
nvram set kernel_args="console=ttyS1,115200 root=/dev/fl/0 rw"
</PRE>

Now reboot the system, you should see the system boot as a standalone
machine:<P>
<PRE>

CFE version 1.0.34 for BCM94702_CPCI (32bit,SP,LE)
Build Date: Mon Nov 11 23:37:02 PST 2002 (jfd@xfiles)
Copyright (C) 2000,2001,2002 Broadcom Corporation.

Initializing Arena.
Initializing Devices.
et0: Broadcom BCM47xx 10/100 Mbps Ethernet Controller
et1: Broadcom BCM47xx 10/100 Mbps Ethernet Controller
CPU type 0x24000: 100MHz
Total memory: 0x1000000 bytes (16MB)

Total memory used by CFE:  0x80F73780 - 0x81000000 (575616)
Initialized Data:          0x80F73780 - 0x80F74F00 (6016)
BSS Area:                  0x80F74F00 - 0x80F76980 (6784)
Local Heap:                0x80F76980 - 0x80FB6980 (262144)
Stack Area:                0x80FB6980 - 0x80FB8980 (8192)
Text (code) segment:       0x80FB8980 - 0x80FFFFB0 (292400)
Boot area (physical):      0x00F32000 - 0x00F72000
Relocation Factor:         I:E13B8980 - D:00F72780

Loader:doc Filesys:(null) Dev:doc0 File:0 Options:(null)
Loading: Load address: 0x20000000 (262144 bytes)
Partition: [BIPO], Size=4194304,UnitSize=32768
	128 Units,ImageSize=3178496 (308000)
DOC read 3178496 bytes OK with checksum 0x93
Entry at 0x20000000
Starting program at 0x20000000
Loading MIPS32 MMU routines.
CPU revision is: 00024000
Primary instruction cache 8kb, linesize 16 bytes (2 ways)
Primary data cache 4kb, linesize 16 bytes (2 ways)
Number of TLB entries 32.
Linux version 2.4.5 (jfd@que) (gcc version 3.0 20010422 (prerelease) with bcm4710a0 modifications) #22 Thu Nov 7 14:35:23 PST 2002
RTC: 11/4/2003, 17:09:39
Determined physical RAM map:
 memory: 01000000 @ 00000000 (usable)
On node 0 totalpages: 4096
zone(0): 4096 pages.
zone(1): 0 pages.
zone(2): 0 pages.
Kernel command line: console=ttyS1,115200 root=/dev/fl/0 rw
New MIPS time_init() invoked.
CPU: BCM4702at 100 MHz
get_rtc_time: 2003-11-04 17:09:40.
Calibrating delay loop... 66.56 BogoMIPS
Memory: 13860k/16384k available (1762k kernel code, 2524k reserved, 93k data, 84k init)
Dentry-cache hash table entries: 2048 (order: 2, 16384 bytes)
Inode-cache hash table entries: 1024 (order: 1, 8192 bytes)
Buffer-cache hash table entries: 1024 (order: 0, 4096 bytes)
Page-cache hash table entries: 4096 (order: 2, 16384 bytes)
Checking for 'wait' instruction...  unavailable.
POSIX conformance testing by UNIFIX
PCI: Probing PCI hardware
PCI: Fixing up bus 0
PCI: Fixing up bridge
PCI: Setting latency timer of device 01:00.0 to 64
PCI: Enabling device 01:00.0 (0000 -> 0002)
PCI: Fixing up bus 1
Linux NET4.0 for Linux 2.4
Based upon Swansea University Computer Society NET3.039
Initializing RT netlink socket
Starting kswapd v1.8
devfs: v0.102 (20000622) Richard Gooch (rgooch@atnf.csiro.au)
devfs: boot_options: 0x0
Serial driver version 5.05a (2001-03-20) with MANY_PORTS SHARE_IRQ SERIAL_PCI enabled
ttyS00 at 0x0000 (irq = 0) is a ST16650
ttyS01 at 0x0000 (irq = 2) is a ST16650
block: queued sectors max/low 9093kB/3031kB, 64 slots per queue
RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize
loop: loaded (max 8 devices)
TFFS 5.1.1 Flash disk driver for DiskOnChip
Copyright (C) 1998,2001 M-Systems Flash Disk Pioneers Ltd.
DOC device(s) found: 1 at 0xbf006000
fl_init: registered device at major: 101
fl_geninit: registered device at major: 101
Partition check:
 fla: p1
partition: /dev/fl/0: start_sect: 0,nr_sects: 55808 Fl_blk_size[]: 27904KB
partition: /dev/fl/1: start_sect: 4,nr_sects: 55772 Fl_blk_size[]: 27886KB
partition: /dev/fl/2: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB
partition: /dev/fl/3: start_sect: 0,nr_sects: 0 Fl_blk_size[]: 0KB
PPP generic driver version 2.4.1
Registered PPPoX v0.5
Registered PPPoE v0.6.5
eth0: Broadcom BCM47xx 10/100 Mbps Ethernet Controller 2002.9.27.0 (BROADCOM INTERNAL)
eth1: Broadcom BCM47xx 10/100 Mbps Ethernet Controller 2002.9.27.0 (BROADCOM INTERNAL)
il0: chipattach: nvram_get(il0macaddr) not found
il0: chipattach error
il0: ilc_attach() failed
CFI: Found no Physically mapped flash device at location zero
sflash: chipcommon not found
NET4: Linux TCP/IP 1.0 for NET4.0
IP Protocols: ICMP, UDP, TCP, IGMP
IP: routing cache hash table of 512 buckets, 4Kbytes
TCP: Hash tables configured (established 1024 bind 2048)
ip_conntrack (128 buckets, 1024 max)
ip_tables: (c)2000 Netfilter core team
NET4: Unix domain sockets 1.0/SMP for Linux NET4.0.
NET4: Ethernet Bridge 008 for NET4.0
EXT2-fs warning: mounting unchecked fs, running e2fsck is recommended
VFS: Mounted root (ext2 filesystem).
Mounted devfs on /dev
Freeing unused kernel memory: 84k freed
Algorithmics/MIPS FPU Emulator v1.4
Hit enter to continue...info, udhcp server (v0.9.7) started
eth0: No such process
info, udhcp server (v0.9.7) started
killall: upnp: no process killed
killall: nas: no process killed
et0: link up
Hit enter to continue...


BusyBox v0.60.0 (2002.11.12-08:35+0000) Built-in shell (msh)
Enter 'help' for a list of built-in commands.

# 
# 
</PRE>


<H2> <A NAME="ROUTER"> Configuring the Router </H2>
Typically, the router configuration is automatic and zero-configuration is required. This is accomplished by making the WAN interface DHCP for a Network address, and the LAN IP address for the local-router interface is configured as <tt>192.18.1.100</tt>. When the system boots, the <tt>rc</tt> command executes and starts or stops the services and searchs for several special NVRAM configuration variables:<P>
<UL>
<LI> wan_ifname - ethernet device name for WAN (Internet) interface.
<LI> lan_ifname - ethernet device name for LAN router interface (or switch/bridge).
<LI> wan_proto - one of <tt>dhcp</tt> or <tt>static</tt> for dynamic or static configuration.
<LI> wan_ipaddr - IP address of the WAN interface (<tt> wan_ifname</tt>).
<LI> lan_ipaddr - IP address of the LAN Router interface (<tt> lan_ifname </tt>)
<LI> lan_netmask - IP Netmask for LAN interface
<LI> wan_netmask - IP Netmask for WAN interface
<LI> wan_gateway - Next hop IP router for WAN IP interface (e.g. Cable-Modem, DSL or other Ethernet Router interface IP address).
<LI> lan_proto - one of <tt> dhcp</tt> or <tt>static </tt>; when lan_proto is <tt> static</tt>, DHCP service is not enabled on the LAN or Bridge (typically a switch device).

<LI> wan_ifname - ethernet device name for WAN (Internet) interface.
<LI> wan_dns - IP address for DNS server for IP name resolution.
<LI> wan_wins - IP address for WINS server for Windows SMB/NETBIOS name resolution.
</UL>
Note that when configuring DHCP for the WAN interface, the IP address, netmask and gateway should all have the IP address <tt>0.0.0.0</tt>. Also, the NVRAM variables for <tt>wan_dns </tt> and <tt> wan_wins </tt> should be configured as blank (the DHCP server will fill these in for us).<P>
<H3> Configuring the WAN Interface for DHCP </H3>
Issue the following commands from the shell prompt on your target system:<BR>
<PRE>
nvram set wan_ipaddr=0.0.0.0
nvram set wan_netmask=0.0.0.0
nvram set wan_gateway=0.0.0.0
nvram set wan_proto=dhcp
nvram set wan_dns=""
nvram set wan_wins=""
</PRE>

<H3> Configuring the WAN Interface for Static IP Assignment </H3>
Issue the following commands from the shell prompt on your target system:<BR>
<PRE>
nvram set wan_ipaddr=172.16.40.114
nvram set wan_netmask=255.255.240.0
nvram set wan_gateway=172.16.40.111
nvram set wan_proto=static


</PRE>
NOTE: you will need to change the IP configuration parameters above for your network; typically these numbers are provided to you by your ISP or network administrator.
<P>


<H3> Configuring Switch or Other Ethernet Interfaces </H3>

Typically, one creates a bridge group using the <tt>brctl</tt> command and then bins the WAN or LAN interface to the bridge group. Other possibilities are to use the device directly as in the case of a simple bridge or switch device which only supports a single management interface. Many combinations are possible, for example:<P>
<UL>
<LI> Dual Ethernet Interfaces 
     <UL><LI><tt>wan_ifname=eth0</tt>
         <LI><tt>lan_ifname=eth1</tt></UL>
<LI> Dual Ethernet Interfaces, Wireless LAN NIC, LAN Bridging
     <UL> <LI><tt>wan_ifname=eth0</tt> 
          <LI><tt>lan_ifname=br0 </tt>
          <LI><tt> brctl addbr br0 </tt>
	  <LI><tt> brctl addif br0 eth1</tt>
	  <LI><tt> brctl addif br0 wl0 </tt>
     </UL>
</UL>

<A NAME="TESTING"><H3> Testing the Router Application </H3></A>
To setup a test network, configure the router with a static IP address for the WAN interface (or use DHCP if that is available on your network). Next, connect the second ethernet port (eth1 is the bottom port on BCM94702CPCI) to a switch or other bridge device. Here is a simple ASCII diagram:<P>

<PRE>
                                               +-------------+
                                               |             ||
--------------- Ethernet to WAN (eth0)------[]=|  BCM94702   ||--> to CPCI chassis
                                     +------[]=|  CPCI       ||
                                     |         |             ||
                                     |         +-------------+
                                     |
                                     | Ethernet to LAN (eth1)
                                    /
                                   /  __________________   
                                  /  /                 /|
                                 /  /-----------------+ /
                                /   | x o o o x x o o |/
                               /    +-|-------|-|-----+
                              |       |       | |
                              +-------+       | |
                                              | |
                                             [] [] (To Network Clients)

</PRE>

Once the network is setup, you should be able to enable DHCP service on the LAN, connect one or PC clients to the switch, and under the Network Control Panel for your NIC card, select "Automatically acquire IP parameters" under the IP protocol configuration for the client. PC's will then connect to the switch and be transparently routed via the WAN Interface. <P>
Note that you can use the firewall and NAT/DNAT options of NETFILTER (<tt>iptables</tt>) to allow for IP masquerading of TCP/UDP port forwarding to a service available on a client connected to the Bridge. This allows for secure distribution of services on your LAN.<P>


<A NAME="SDK"><H2> Strata/XGS SDK 4.x Configuration and Build</H2></A>

The Strata/XGS SDK (version 4.x and later) is installed in the source
directory for the user-applications. When you install the Strata/XGS
SDK into the user application area, the loadable modules for the PCI
enumerator, Strata/XGS API and Driver, as well as the Strata/XGS
network driver is installed by default. This allows the router
applications to operate using the network driver and Strata/XGS API
to take advantage of all H/W features of Strata/XGS devices under Linux.

<P>
To configure the Strata/XGS SDK for use with the LDK:<P>
<OL>
<LI> Install the SDK <tt>firmware</tt> directory in <tt> router/src/router/firmware</tt> <UL><LI>e.g. <tt> cd router/src/router; cvs co firmware </tt></UL>
<LI> Type <tt>make ntsw</tt> followed by <tt> make ntsw-install</tt>
<LI> The modules <tt> linux-kernel-bde.o, linux-bcm-core.o, linux-bcm-net.o</tt> are installed in <tt>/bin</tt> by default.
<LI> When you build the BSP, the initialization (rc) script in <tt>src/router/etc/init.d/rcS</tt> can be used to insmod the drivers at bootup. You must add <tt>ntsw</tt> to the <tt>COMPONENTS</tt> line todo this. Otherwise the BSP builds all applications except the network driver for Strata/XGS, and router init.
<LI> When you build the <tt>router</tt> configuration, the <tt>rc</tt> program will be loaded and built, and the network driver in <tt>ntsw</tt> will be automatically started todo this, you will need to edit the file <tt>rc.c</tt>.
<LI> The switch will be configure with all ports in VLAN1, with device name <tt>bcm0</tt>
<LI> Configure the LAN interface (<tt>lan_ifname</tt>) device as <tt>bcm0</tt>
</OL>
To automatically load the Strata/XGS drivers at boot (when the router starts), add the following lines are the module initialization in the file <tt>rc.c</tt>:
<PRE>
        printf("Loading Strata/XGS network drivers...\n");
        eval("insmod","/bin/linux-kernel-bde.o");
        eval("insmod","/bin/linux-bcm-core.o");
        eval("insmod","/bin/linux-bcm-net.o");
</PRE>

<P>
<A NAME="ROBO"><H2> RoboSwitch (BCM53xx) Setup, Configuration and Build</H2></A>
Support for RoboSwitch (BCM53xx) devices is provided on Revision-2 of the BCM94702CPCI board using the BCM4702 GPIO pins to perform SPI protocol and communicate with the Serial Management Port (SMP interface) on the BCM53xx device.<P> To use this feature, connect the SPI interface using the GPIO pins as described in BCM94702CPCI schematics to the RoboSwitch device and/or board. Next, connect the LAN interface (eth1, bottom port) to the Reverse MII interface on the BCM53xx platform.<P>

By default, the driver will attempt to configure Reverse MII mode on the CPU Port interface (Reverse MII connector). This is all the support that is required for basic routing with BCM53xx as LAN-side bridge.<P>


<H2> <A NAME="FLASHConfig">Configuring Flash Devices </H2>
Intel 28F320J (StrataFlash) in 2MBx16 (4MB) will be made available on Revision-2 of BCM94702; currently this is unsupported.<P>

<H2> <A NAME="FLASHBOOT">Configuring FLASH Filesystems with mkcramfs </H2>
-TBD<P>

<A NAME="ADDRSPACE"><H2>System Address Map </H2></A>

<H3>Address map of external interface</H3>

  <UL>
  <LI> Devices on "PCMCIA" chip select
  <UL>
  <LI>0xbf000000   -- Reset.         Read or write to reset board
  <LI>0xbf002000   -- not used
  <LI>0xbf004000   -- Board ID       Read-only, returns board revid
  <LI>0xbf006000   -- Disk On Chip
  <LI>0xbf00c000   -- Alphanumeric LEDs  Write only
  <LI>0xbf00e000   -- NVRAM
  </UL>
  <LI>Devices on asynchronous interface

 <UL><LI> 0xbf800000   -- DUART

      <UL><LI>0xbf800008   -- External UART, channel 1 (DB9 connector)
      <LI>0xbf800000   -- External UART, channel 2 (header on board)
</UL>

  <LI>Flash interface

  <UL><LI>0xbfc00000   -- bootrom
</UL>
</UL>
    There are 2 different bootroms on MBZ, a removable EPROM and a soldered
    flash.  Jumper JP800 selects between the two bootroms.
<UL>

       <LI>1-2  --  removable EPROM 29LV040B (jumper away from BCM4702)
       <LI>2-3  --  soldered flash 29LV160DB
</UL>

<LI>  10/100 RJ45 Ethernet Connectors
<UL><LI>  eth0 (Ethernet 0) -- Top port on connector.  Used for boot loading.
  <LI> eth1 (Ethernet 1) -- Bottom connector.
</UL></UL>
</PRE>
<A NAME="ISSUES"><H2> Known Issues </H2></A>
<UL>
<LI> The system should use GZIP compressed ELF images to save space used by the binary partition for a raw (uncompressed) ELF image.
<LI> The EXT2FS filesystem should be checked at boot. 
<LI> Support for multiple binary partitions currently unavailable (the CFE loader uses the name "BIPO" for the boot partition).
<LI> TFFS does not work under Linux 2.4.18 (there is an issue with fdisk).
</UL>
<HR>
