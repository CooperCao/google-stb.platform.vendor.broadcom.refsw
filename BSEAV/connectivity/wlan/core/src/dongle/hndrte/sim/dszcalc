#!/usr/bin/perl
#
# Calculate runtime code size and cache size of a given function.
#
# Usage: perl dszcalc <log-file> <nm-file> <start-symbol> [options]
#
#   <log-file> is a PC trace file.
#     Each line in the file is in format: <line-number> <pc> <instr> <cycle-count>
#     It can be captured from armulator's output (generated by an external cheeseball)
#   <nm-file> is a symbol file with symbol size (generated by 'nm -S' command)
#   <start-symbol> is the function name
#
# $Id: dszcalc,v 1.4 2006-07-24 19:13:35 csm Exp $
#

use FileHandle;

# command line options
my $parms = 3;			# require 3 parameters
if (@ARGV < $parms)
{
    printf("Usage: dszcalc <log-file> <nm-file> <start-symbol> [<options>]\n");
    printf("\n<options>\n\n");
    printf("must=<must-seen-symbol>     - specify address must be seen\n");
    printf("stop=<stop-symbol>          - specify address to stop at\n");
    printf("msglevel=<message-level>    - specify message level\n");
    printf("                              1: +function names\n");
    printf("                              2: +cache line tags\n");
    printf("                              11: +progress indications\n");
    printf("                              12: +verbose mode\n");
    printf("call=<call-type>            - specify start symbol call type [direct]|indirect\n");
    printf("iclnsz=<cache-line-size>    - specify cache line size [16]|32|...\n");
    printf("instrsz=<instr-size>        - specify instruction size [2]|4|...\n");
    exit;
}
my $log = $ARGV[0];		# log file path
my $nm = $ARGV[1];		# nm file path
# open the nm file and read in all lines
open(INPUT, "<$nm") or die "failed to open file $nm";
my @sym = sort(grep(/\b[0-9a-f]{8} [0-9a-f]{8} . .*\b/, <INPUT>));
close(INPUT);
# resolve start symbol to PC
sub addr_find
{
    my $name = shift;
    my @found = grep(/\b$name\b/, @sym);
    if (@found == 0) {
	return "deadbeef";
    }
    my @token = split(" ", $found[0]);
    if (@token != 4) {
	return "deadbeef";
    }
    return $token[0];
}
my $startpc = addr_find($ARGV[2]);	# PC to start with
if ($startpc eq "deadbeef")
{
    printf("%s not found in %s\n", $ARGV[2], $nm);
    exit;
}
# find optional parameters
my $mustpc = 0xdeadbeef;	# must seen PC in the path
my $lastpc = 0xdeadbeef;	# last PC to look at in the path
my $msglevel = 0;		# 1: +func, 2: +cache, 11: +progress, 12: +verbose
my $indirect = 0;		# call to <start-symbol> is indirect
my $iclnsz = 16;		# instruction cache line size
my $instrsz = 2;		# instruction size
if (@ARGV > $parms)
{
    # save the must seen PC in $mustpc
    my @result = grep(s/\bmust=//, @ARGV);
    if (@result > 0) {
	# resolve must seen symbol to the PC
	my $addr = addr_find($result[0]);
	# take the param as a PC when lookup fails
	if ($addr eq "deadbeef") {
	    $mustpc = hex($result[0]);
	}
	else {
	    $mustpc = hex($addr);
	}
    }
    # save the last PC to look at in $lastpc
    @result = grep(s/\bstop=//, @ARGV);
    if (@result > 0) {
	# resolve stop symbol to the PC
	my $addr = addr_find($result[0]);
	# take the param as a PC when lookup fails
	if ($addr eq "deadbeef") {
	    $lastpc = hex($result[0]);
	}
	else {
	    $lastpc = hex($addr);
	}
    }
    # save the message level in $msglevel
    @result = grep(s/\bmsglevel=//, @ARGV);
    if (@result > 0) {
	$msglevel = int($result[0]);
    }
    # save the call type in $indirect
    @result = grep(s/\bcall=//, @ARGV);
    if (@result > 0) {
	$indirect = $result[0] eq "indirect" ? 1 : 0;
    }
    # save the cache line size in $iclnsz
    @result = grep(s/\biclnsz=//, @ARGV);
    if (@result > 0) {
	$iclnsz = int($result[0]);
    }
    # save the call type in $indirect
    @result = grep(s/\binstrsz=//, @ARGV);
    if (@result > 0) {
	$instrsz = int($result[0]);
    }
}
# validate optional parameters
if ($lastpc != 0xdeadbeef && $mustpc != 0xdeadbeef && $mustpc == $lastpc) {
    printf("Command line: 'must seen address' can not be same as 'last address to stop'\n");
    exit;
}

# local variables
my @extfn =			# external functions to ignore
    sort(
	 "cball_core_clock",
	 "cball_core_cycle",
	 "RateStat",
	 "RateStatShow",
	 "RateStatTrigger"
	 );			# Note: These symbols should not be linked into
				# the binary the first place. They should be
				# moved to the external cheeseball. However
				# let's just ignore them before that happens.
my @prevpc = (0xdeadbeef, 0xdeadbeef);		# PC before $startpc
my $stoppc = "deadbeef";	# PC to stop (from command line)
my $state = "init";		# state machine state ("init" "start" "count")
my $instrs = 0;			# number of instructions
my $ignore = 0;			# number of instructions ignored
my %cache = ();			# cache line address tags
my %func = ();			# functions in the path
my @path = ();			# functions in the path, order kept
my $valid = 0;			# $mustpc has been seen and path is valid
my $lnbegin = "";		# line # at which counting begins
my $lnend = "";			# line # at which counting ends
my $cycbegin = "";		# cycle # at which counting begins
my $cycend = "";		# cycle # at which counting ends
my $maxicsize = 0;		# maximum cache size
my $maxcodesz = 0;		# maximum code size
my $maxinstrs = 0;		# maximum # instrs
my $ttlrefs = 0;		# total references

#
# indicate progress
#
sub prog_ind
{
    if ($msglevel > 10) {
	my $ind = shift;
	printf("%s", $ind);
	autoflush STDOUT, 1;
    }
}

#
# initialize variables
#
sub var_init
{
    # state machine state
    $state = "init";
    # number of instructions
    $instrs = 0;
    # number of instructions ignored
    $ignore = 0;
    # cache line tag list
    %cache = ();
    # function name list
    %func = ();
    @path = ();
    $valid = ($mustpc == 0xdeadbeef) ? 1 : 0;
    # line # in log file (first token of each line)
    $lnbegin = "";
    $lnend = "";
    # cycle # in log file (fourth token of each line)
    $cycbegin = "";
    $cycend = "";
    # previous PC(s) before $startpc (funcptr/indirect call needs two)
    @prevpc = (0xdeadbeef, 0xdeadbeef);
}

#
# binary search on a symbol list.
# return the symbol upon success otherwise "".
#
sub sym_find
{
    my $addr = shift;
    my $b = 0;
    my $e = scalar(@sym) - 1;

    while ($e >= $b) {
	use integer;
	my $m = ($b + $e) / 2;
	my @token = split(" ", $sym[$m]);
	if ($addr >= hex($token[0]) &&
	    $addr < hex($token[0]) + hex($token[1])) {
	    return $token[3];
	}
	elsif ($addr < hex($token[0])) {
	    $e = $m - 1;
	}
	else {
	    $b = $m + 1;
	}
    }

    return "";
}

#
# binary search on a string list.
# return element index upon success otherwise list size.
#
sub str_find
{
    my $str = shift;
    my @list = @_;
    my $b = 0;
    my $e = scalar(@list) - 1;
    
    while ($e >= $b) {
	use integer;
	my $m = ($b + $e) / 2;
	if ($str eq $list[$m]) {
	    return $m;
	}
	elsif ($str lt $list[$m]) {
	    $e = $m - 1;
	}
	else {
	    $b = $m + 1;
	}
    }
    return scalar(@list);
}

#
# update related info for a PC/address
#
sub stat_upd
{
    my $addr = shift;
    my $name;
    my $line;
    my $tag = 0;
    my $i;

    # mark the path is valid
    if ($mustpc != 0xdeadbeef) {
	if ($addr == $mustpc) {
	    $valid = 1;
	}
    }

    # find it in symbol list
    $name = sym_find($addr);
    if ($name eq "") {
	if ($msglevel > 11) {
	    printf("address %08x unknown\n", $addr);
	}
	$ignore ++;
	return;
    }

    # ignore it if it is in the external function list
    if (str_find($name, @extfn) < @extfn) {
	$ignore ++;
	return;
    }

    # count instructions
    $instrs ++;

    # tag the function in function list
    if (exists($func{$name}) == 0) {
	if ($msglevel > 0) {
	    push(@path, $name);
	}
	$func{$name} = 0;
	$tag = 1;
    }
    $func{$name} ++;

    # tag the new cache line
    $line = $addr & ~($iclnsz - 1);
    if (exists($cache{$line}) == 0) {
	$cache{$line} = 0;
	$tag = 1;
    }
    $cache{$line} ++;

    # report progress
    if ($tag == 1) {
	prog_ind("T");
    }
}

#
# report stats for all PCs/addresses
#
sub stat_rep
{
    my $fnsize = 0;
    my $icsize = 0;
    my @keys;
    my $i;

    # don't report if $valid is not set
    if ($valid == 0) {
	return;
    }

    # calc code size
    for ($i = 0, @keys = keys(%func); $i < @keys; $i ++) {
	my @result = grep(/\b$keys[$i]\b/, @sym);
	my @token = split(" ", $result[0]);
	$fnsize += hex($token[1]);
    }
    # calc cache size
    $icsize = scalar(keys(%cache)) * $iclnsz;

    # record max and update counts
    if ($fnsize > $maxcodesz) {
	$maxcodesz = $fnsize;
    }
    if ($icsize > $maxicsize) {
	$maxicsize = $icsize;
    }
    if ($instrs > $maxinstrs) {
	$maxinstrs = $instrs;
    }
    $ttlrefs ++;

    # report function name and references
    if ($msglevel > 0) {
	for ($i = 0; $i < @path; $i ++) {
	    printf("%s(%u)\n", $path[$i], $func{$path[$i]});
	}
    }
    # report cache line tags and references
    if ($msglevel > 1) {
	for ($i = 0, @keys = sort(keys(%cache)); $i < @keys; $i ++) {
	    printf("%08x(%u)\n", $keys[$i], $cache{$keys[$i]});
	}
    }
    # report code size, cache size, and number of instructions
    printf("[%s - %s] %u bytes code %u bytes cache %u instrs %u cycles\n",
	   $lnbegin, $lnend, $fnsize, $icsize, $instrs,
	   int($cycend) - int($cycbegin));
}

#
# Work hard to figure out code and cache sizes and other related stats.
#
#   $log file line format: INDEX PC INSTR CYCLE
#   $nm file line format: ADDR SIZE SECT SYMBOL
#
# open the $log file and go through each line
open(INPUT, "<$log") or die "failed to open $log";
while (<INPUT>)
{
    # find the line with $startpc
    if (/\b[0-9]+ $startpc [0-9a-f]+ [0-9]+\b/) {
	# there is no known $prevpc
	if ($prevpc[$indirect] == 0xdeadbeef) {
	    printf("PC previous to $startpc unknown\n");
	    next;
	}
	# the $prevpc is too close
	elsif (hex($startpc) > $prevpc[$indirect] &&
	       hex($startpc) - $prevpc[$indirect] == $instrsz) {
	    printf("$nm and $log mismatch?\n");
	    return;
	}
	# predict $stopppc(s)
	$stoppc = sprintf("%08x|%08x", $prevpc[$indirect] + $instrsz,
			  $prevpc[$indirect] + $instrsz + $instrsz);
	if ($lastpc != 0xdeadbeef) {
	    $stoppc = sprintf("%s|%08x", $stoppc, $lastpc);
	}
	# reset everything and do it last
	var_init();
	#  move state to "start"
	$state = "start";
	prog_ind("\n<");
    }
    # find the line with $stoppc
    elsif (/\b[0-9]+ $stoppc [0-9a-f]+ [0-9]+\b/) {
	# make sure the state is "count"
	if ($state eq "count") {
	    prog_ind(">\n");
	    stat_rep();
	    var_init();
	}
    }
    # process lines with other pcs
    elsif (/\b[0-9]+ [0-9a-f]+ [0-9a-f]+ [0-9]+\b/) {
	# remember previous PCs
	my @token = split(" ");
	if ($state eq "init") {
	    $prevpc[1] = $prevpc[0];
	    $prevpc[0] = hex($token[1]);
	}
	# start counting
	elsif ($state eq "start") {
	    $lnbegin = $token[0];
	    $cycbegin = $token[3];
	    $state = "count";
	}
	# keep counting
	elsif ($state eq "count") {
	    $lnend = $token[0];
	    $cycend = $token[3];
	    stat_upd(hex($token[1]));
	}
    }
}
close(INPUT);

# report final stats
printf("***total %u ref, max %u bytes code, max %u bytes cache, max %u instrs***\n",
       $ttlrefs, $maxcodesz, $maxicsize, $maxinstrs);
