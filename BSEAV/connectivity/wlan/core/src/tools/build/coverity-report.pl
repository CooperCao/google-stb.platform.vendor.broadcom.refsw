#!/usr/local/bin/perl

## #########################################################################
##
## This program queries the coverity database and generates email
## reports to respective owners of various coverity targets.
## NOTE: Coverity target names specified here should match target
## NOTE: name format used in all-run-coverity.mk makefile
##
## Categories
## 1. The administrators (hnd-software-scm-list)
##     Will want nightly notification of what ran and its status.
## 2. The developers:
##    2.1 STA Group (XP/Vista NIC, Vista USB DHD and dongle)
##    2.2 Embedded Group (Linux/WinXP/CE/WP7 DHD and dongle)
##    2.3 Router (nothing yet)
##
## Author: Prakash Dhavali
##
## $Id$
##
## SVN: $HeadURL$
##
## #########################################################################
##

use     Env;
use     Getopt::Long;
use     MIME::Lite;
my $fromAddress = "hnd-coverity-list\@broadcom.com";

# TODO. Make all symbols adhere to "use strict"
#use strict 'refs';

use lib  "/home/hwnbuild/src/tools/build";
require  "wl_swengg_lib.pl";

my $reportdate;
my $help;
my $bldadmin="hnd-software-scm-list";
my $mailto;

# -date : Set a different date to produce report for (default: today)
# -dbg  : Enable debug mode (emails don't go to blame list, goes to bldadmin)
my %scan_args = (
		'date=s'        => \$reportdate,
		'dbg'           => \$dbg,
		'help'          => \$help,
		'mailto=s'      => \$mailto,
	);

# Scan the command line arguments
GetOptions(%scan_args) or &Help;

#$dbg=1;

&Help if ($help);

&Info("=========================================================");
my $REPORT_USER   = "hwnbuild"; # user used to access/query db and report results
if ( $USER !~ /$REPORT_USER/ ) {
	&Error3("'$USER' user does not have coverity report generation access");
	&Info("Coverity reports need to be generated by '$REPORT_USER' user only");
	$ERRORS .= "'$USER' user does not have coverity report generation access\n";
	&Exit($ERROR);
}

my $REPORT_SERVER   = "COV-SJ1-08"; # system used to access/query db and report results
if ( $thishost !~ /$REPORT_SERVER/ ) {
	&Error3("'$thishost' system can not generate coverity reports");
	&Info("Coverity reports are generated on '$REPORT_SERVER' server");
	$ERRORS .= "'$thishost' system does not have coverity report generation access\n";
	&Exit($ERROR);
}

&Dbg("Debug/Verbose mode enabled");

my $goner          = "_goner_"; # Pseudo name for invalid users
my $newdefect_runs = 0; # Number of runs with new defects
my $numtotal_sched;     # Number of targets scheduled
my $rNightlyRuns   = {};
my $build_config   = "/home/hwnbuild/src/tools/build/build_config.sh";
my $svnwho         = "/projects/hnd_software/gallery/src/tools/misc/svnwho";
my $svncmd         = "/tools/bin/svn --non-interactive";
my $srctree        = "/projects/hnd_software/gallery/src_tree.txt";
my @srctree        = qx(egrep -v "src/customer/nintendo|src/router" $srctree); chomp(@srctree);
		     # TODO: coverity path to svn path mapping ignore dup
		     # TODO: files in nentendo tree and router tree
my $coverity_config= "gmake -s -f /home/hwnbuild/src/tools/release/coverity-target-info.mk";
my @ActiveBranches = split(/\s+/,qx($build_config --show_coverity_active)); chomp(@ActiveBranches);

if ( $hostenv =~ /win32/ ) {
	$PATHPFX = "Z:";
	$TEMP    = "C:/temp";
} else {
	$PATHPFX = "";
	$TEMP    = "/tmp";
}

my $PREVENT_DIR   = "${PATHPFX}/projects/hnd_tools/linux/Coverity/cov-sa-linux64-5.3.0";
my $HNDWLANDB_DIR = "/var/lib/coverity/5.3.0/coverity-integrity-manager";
my $COVPROCESS_URL= "http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/CoverityStaticCodeAnalysis";
my $BLDSERVER_BASE= "/projects/hnd_swbuild";
my $BLDSERVER_URL = "http://home.sj.broadcom.com";
my $COVBUILD_URL  = "${BLDSERVER_URL}${BLDSERVER_BASE}";
my $COVSUM_LOGDIR = "${BLDSERVER_BASE}/build_admin/logs/coverity530/summary";
my $SVNBLAME_LOGDIR = "${BLDSERVER_BASE}/build_admin/logs/coverity530/svnblames";

my $WEBAPI_LOG = "${BLDSERVER_BASE}/build_admin/logs/coverity530/webapi.log";
open(WEBAPI_LOG,">>$WEBAPI_LOG") || die "ERROR: Can't open $WEBAPI_LOG";
print WEBAPI_LOG "======= START: $dirtimestamp ======\n";
print WEBAPI_LOG "Today's Runs Cmd: $GET_SNAPSHOTS_FOR_DAY --year $nowyear --month $nowmonth --day $nowday\n";

# Sample URLS
# CID Link : http://cov-sj1-08.sj.broadcom.com:8080/sourcebrowser.htm?projectId=10058#mergedDefectId=100206
# Proj Link: http://cov-sj1-08.sj.broadcom.com:8080/defects/index.htm?projectId=10008";
my $PREVENT_WEBURL= "http://cov-sj1-08.sj.broadcom.com:8080";
my $PREVENT_RUNURL= "${PREVENT_WEBURL}/defects/index.htm?projectId=PROJ_ID";
my $PREVENT_NEWURL= "${PREVENT_WEBURL}/defects/index.htm?projectId=PROJ_ID";

# This interface isn't available in 5.3.x still
my $PREVENT_CMPURL= "${PREVENT_WEBURL}/cov.cgi?new=NEW_RUN_ID&old=OLD_RUN_ID&sort=b62&t=11&v=1";
# WebService APIs to replace coverity query commands
my $WEBAPI_USER = "hwnbuild";
my $WEBAPI_PW   = qx(cat /home/${WEBAPI_USER}/.restricted/passwd 2> $NULL);
                  chomp($WEBAPI_PW);
my $WEBAPI_OPTS           = "--host cov-sj1-08.sj.broadcom.com --port 8080 --user hwnbuild --password ${WEBAPI_PW}";
my $WEBAPI_DIR            = "/projects/hnd_software/gallery/src/tools/coverity/webapi/python";
my $GET_SNAPSHOTS_FOR_DAY = "python ${WEBAPI_DIR}/getSnapshotsForDate.py $WEBAPI_OPTS";
my $GET_CIDS_FOR_SNAPSHOT = "python ${WEBAPI_DIR}/getCidsForSnapshotComponent.py $WEBAPI_OPTS";
my $DIFF_RUNS             = "python ${WEBAPI_DIR}/diffRuns.py $WEBAPI_OPTS";
my $GET_PROJECT_URL       = "python ${WEBAPI_DIR}/getProjectURL.py $WEBAPI_OPTS";

# Build logs
my $ERRORS        = "";
my $WARNINGS      = "";
my $RLSLOG        = ",release.log";
my $ERRORLOG      = ",build_errors.log";

my %BrandsByPlatform = (
	windows => qw(win-coverity),
	window  => qw(win-coverity),
	linux   => qw(linux-coverity),
	macos   => qw(macos-coverity),
	netbsd  => qw(netbsd-coverity),
);

my %tgtDescMap;    # Mapping between make target and descriptive names
my %cidsProcessed; # Record list of CIDs processed
my $querydate     = `date '+%Y%m%d'`; chomp($querydate);
my $rundate       = $nowdate;

if (( $reportdate) && ($reportdate !~ /(\d{4}).(\d{2}).(\d{2})/)) {
	&Error3("Date=$reportdate wrong specs, expecting 'YYYY.mm.dd'");
	$ERRORS .= "Date=$reportdate wrong specs, expecting 'YYYY.mm.dd'\n";
	&Exit($ERROR);
}

## Set rundate (which is used in report email) to custom date if specified
if ($reportdate =~ /(\d{4}).(\d{2}).(\d{2})/) {
	$querydate   = "$1$2$3";
	$rundate     = $reportdate;

	# If reportdate is specified on cmd line, override now{year,month,day}
	# These are used in WebAPI calls
	$nowyear  = $1;
	$nowmonth = $2;
	$nowday   = $3;
}

&Info("Run Date=$rundate TimeStamp=$nowtimestamp");
&Info("nowyear=$nowyear; nowmonth=$nowmonth; nowday=$nowday") if ($reportdate);

my $today      = `date '+%a'`;     chomp($today);
my $blddate    = `date '+%Y.%-m.%-d.{?,??}'`; chomp($blddate);

# Define functional modules in coverity and their owners
# These are referred as "categories" in this programs
$rCatInfo = {
	admin   => {
		owners  => [($bldadmin)],
	},
	sta     => {
		owners  => [qw(hnd-coverity-list@broadcom.com)],
	},
	esta    => {
		owners  => [qw(hnd-coverity-list@broadcom.com)],
	},
	router  => {
		owners  => [qw(hnd-coverity-list@broadcom.com)],
	},
}; # rCatInfo

# Email subroutine to send email
sub email {

    my $fromAddress = $_[0];
    my $toAddress = $_[1];
    my $ccAddress = $_[2];
    my $subject = $_[3];
    my $data = $_[4];

    my $message = MIME::Lite->new(
    From => $fromAddress,
    To => $toAddress,
    Cc => $ccAddress,
    Subject => $subject,
    Data => $data
	);
    $message->send('smtp','mail.broadcom.com');

}

#
# Given Target Description, identify its build OS and categorize
# to broadcom functional group. This will be help keep the reports
# going specific groups for faster closure
#
sub CategorizeTargets {
	my ($tgtType, $tgt, $tgtDesc) = @_;

	# print "CategorizeTargets(): Processing type=$tgtType, tgt=$tgt, desc=$tgtDesc\n";

	if ( $tgtDesc =~ /Win(XP|7|Vista).*WL.*(NIC|BMac).*Driver/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "window";
	} elsif ( $tgtDesc =~ /Win(XP|7|Vista).*DHD.*Driver/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(esta)];
		$tgtType->{$tgtDesc}{buildos}    = "window";
	} elsif ( $tgtDesc =~ /Win(XP|7|Vista).*WL.*Utility/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "window";
	} elsif ( $tgtDesc =~ /WinCE|WinMobile/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(esta)];
		$tgtType->{$tgtDesc}{buildos}    = "window";
	} elsif ( $tgtDesc =~ /prefast/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "window";
	} elsif ( $tgtDesc =~ /Linux.*WL.*(NIC|BMac).*Driver/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /Linux.*DHD.*Driver/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /Linux.*(WL|DHD).*Utility/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /(43...*bmac\/|Dongle)/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /(43...*\/|Dongle)/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /Router/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(router)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /Linux/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /Win/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /VxWorks/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(router)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	} elsif ( $tgtDesc =~ /MacOS/i ) {
		$tgtType->{$tgtDesc}{categories} = [qw(sta)];
		$tgtType->{$tgtDesc}{buildos}    = "macos";
	} else {
		&Warn("'$tgtDesc' couldn't be categorized as either sta or esta");
		&Warn("'$tgtDesc' is assigned to both sta and esta categories");
		$tgtType->{$tgtDesc}{categories} = [qw(sta esta)];
		$tgtType->{$tgtDesc}{buildos}    = "linux";
	}

	&Info("Categorize '$tgtDesc' as '@{$tgtType->{$tgtDesc}{categories}}' target");

	# Mark all builds in admin category too
	push(@{$tgtType->{$tgtDesc}{categories}},"admin");

} # CategorizeTargets

#
# Go through active branches and find out scheduled coverity runs on a
# nightly basis as well as weekly basis
#
sub findTargets {

	foreach my $branch (@ActiveBranches) {
		my @branchNightlyTargets;

		# Starting with Coverity 5.3.x, we use TRUNK for NIGHTLY
		$branch =~ s/NIGHTLY/TRUNK/g;

		@branchNightlyTargets = split(/\s+/, qx($coverity_config TAG=$branch show_coverity_targets | fmt -1));

		next unless ($#branchNightlyTargets > 0);

		&Info("-------------------------------------");
		&Info("branchNightlyTargets[$#branchNightlyTargets] = @branchNightlyTargets");

		# Categorize nightly targets
		foreach my $tgt (@branchNightlyTargets) {
			my ($tmptgt);
			my ($tmptgtDesc);

			next if $tgt =~ /^\s*$/g;

			my $tgtDesc = qx($coverity_config $tgt);
			chomp($tgtDesc);

			$tmptgt     = $tgt;     $tmptgt     =~ s/\//_/g;
			$tmptgtDesc = $tgtDesc; $tmptgtDesc =~ s/\//_/g;

			# Reverse map, used for stream/project names
			$tgtDescMap{$tmptgtDesc} = $tmptgt;

			# Prefix Preco to identify preco targets from
			# similar nightly targets. Needed in URL query below
			if ($tgtDesc =~ /preco/i) {
				$tgtDesc =~ s/preco |preco_//gi;
				$tgtDesc = "Preco $branch $tgtDesc";
			} else {
				$tgtDesc = "$branch $tgtDesc";
			}
			&CategorizeTargets($rNightlyRuns,$tgt,$tgtDesc);
		}

		# Target name to description name mapping
		&Info("Target description mapping (cumulative across branches)");
		foreach my $tgtdesc (sort keys %tgtDescMap) {
			&Info("Map '$tgtdesc' => '$tgtDescMap{$tgtdesc}'");
		}

	} # @ActiveBranches

	# Populate a new rAllRuns hash from rNightlyRuns and rWeeklyRuns
	# Note: Weekly targets are suppressed for now

	foreach my $run ( keys %$rNightlyRuns ) {

		next if ($run =~ /prefast/);

		$nrun = $run;
		@{$rAllRuns->{$nrun}{categories}} = @{$rNightlyRuns->{$run}{categories}};
		$rAllRuns->{$nrun}{schedule}      = $rNightlyRuns->{$run}{schedule};
		$rAllRuns->{$nrun}{buildos}       = $rNightlyRuns->{$run}{buildos};
	}

	# Total number of scheduled coverity targets
	$numtotal_sched = keys %$rAllRuns;

	foreach my $schedrun ( sort keys %$rAllRuns ) {
		&Dbg("Scheduled target = $schedrun");
	}

} # findTargets()

#
# For all targets found in findTargets, search for Coverity snapshots
#
sub getSnapshots {

	# Extract a list of targets that actually ran for ${querydate}
	# Examples from following query
	# Run ID,Product,Description,Date,Hist. New Defects,Outstanding Defects,PARSE_ERROR,# Files,# Components,LOC
	# 100030,hndwlan,FALCON_BRANCH_5_90 4330b2-roml/sdio-g 20110416_1444 ,2011-04-16 14:05:50.000163,5,87,0,0,0,0

	my $curtime=qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);
	&Info("[$curtime] Getting list of snapshots for $nowmonth/$nowday/$nowyear");
	&Info("$GET_SNAPSHOTS_FOR_DAY --year $nowyear --month $nowmonth --day $nowday");

	@todays_runs = qx($GET_SNAPSHOTS_FOR_DAY --year $nowyear --month $nowmonth --day $nowday); $webapi_ec=$?;
	chomp(@todays_runs);

	$curtime=qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);
	&Info("[$curtime] Finished getting list of snapshots for $nowmonth/$nowday/$nowyear");

	# Take out header row and double spaces
	@todays_runs = grep { !/Run ID,/ } @todays_runs;
	@todays_runs = map { $_ =~ s/\s+/ /g; "$_" } @todays_runs;

	# If @todays_runs is empty, then it is an error
	if (($webapi_ec != 0 ) || ( ! @todays_runs )) {
		&Error3("Coverity snapshot query error ($webapi_ec)");
		$ERRORS .= "\nCoverity snapshot query error ($webapi_ec)\n";
		$ERRORS .= "\nLook up stdout log on system where this ran\n";
		# When this happens, notify admin users and set dbg
		$dbg = 1;
	}

	my $i=1;
	foreach my $run (@todays_runs) {
		&Info("[$i] Snapshot Found: $run");
		$i++;
	}

}; # getSnapshots ()

## If new coverity defects are detected, then this function
## searches the coverity database for checkers that produced
## the new defect
sub showNewDefects
{
	my($myrun_id,$schedrun) = @_;
	my($ndefmsg,$ndef,@new_defects);
	my($cid,$checker,$class,$func,$file);
	my($myrun_newurl);
	my($branch, $branchdir, $def_author, $ver_author);
	my($filerev, $filerevtmp);

	my $buildos;
	my $COVBUILD_BRAND;
	my $blddir;
	my $bldsvnrev;
	my $svnurl;
	my $fileurl;
	my $schedruntmp= $schedrun;

	&Dbg("showNewDefects('$myrun_id','$schedrun')");

	$schedruntmp =~ s/Preco\s+//gi;
	($branch) = $schedruntmp =~ /^(\w+\b)/;

	$buildos= $rAllRuns->{$schedrun}{buildos};
	$COVBUILD_BRAND= $BrandsByPlatform{$buildos};

	$ndefmsg    = "";

	# Get New Defects.
	# 3rd party components are filtered out in IM UI
	print WEBAPI_LOG "Get New Defects Cmd: $GET_CIDS_FOR_SNAPSHOT --only-new --snapshot $myrun_id\n";
	&Info("Get New Defects Cmd: $GET_CIDS_FOR_SNAPSHOT --only-new --snapshot $myrun_id");
	@new_defects = qx($GET_CIDS_FOR_SNAPSHOT --only-new --snapshot $myrun_id);
	$webapi_ec=$?;

	chomp(@new_defects);

	# Filter out only defects marked as New
	@new_defects = sort grep { /,New,/ } @new_defects;

	# If no new defects are found, no work to do here
	# Recurred defects, are reported as recurred by API, even though
	# UI may show them as New
	return("") if ( $#new_defects < 0 );

	my $ndindex=0;
	foreach my $defect (@new_defects) {
		$ndindex++;
		&Dbg("[$ndindex] FOUND NDEFECT: $defect");
	}

	if (@new_defects) {
		$branchdir= ($branch =~ /TRUNK/) ? "NIGHTLY" : $branch;
		$blddir   = qx(find ${BLDSERVER_BASE}/build_${buildos}/$branchdir/${COVBUILD_BRAND}/$blddate -maxdepth 0 -mindepth 0 2> ${NULL} | xargs ls -1td); chomp($blddir);
		$bldsvnrev   = qx(cat $blddir/_SUBVERSION_REVISION);
		$bldsvnrev   =~ s/\s+//g;
		if ($branch =~ /NIGHTLY|TRUNK/) {
			$svnurl      = "${SVNROOT}/trunk";
		} else {
			$svnurl      = "${SVNROOT}/branches/$branch";
		}
	}

	# Massage the output to filter out fields that are really needed
	# CID,Checker,Classification,Historical State,Owner,Severity,Action,Function,File,Line
	$ndefmsg  .= sprintf("    -----------------------------------------------------------------------------\n");
	$ndefmsg  .= sprintf("    %-7s %-15.15s  %-8s  %-20s  %-s\n","CID","Checker","Author","File[Line]", "Function");
	$ndefmsg  .= sprintf("    -----------------------------------------------------------------------------\n");
	
	my $ndindex=0;
	foreach my $ndef ( @new_defects ) {
		my $curtime;
		my $filelinkpath;
		my $cid_key;

		($cid,$checker,$func,$filefullpath,$line) = (split(/,/,$ndef))[0,1,7,8,9];

		# Increase new defect index
		$ndindex++;

		# If the coverity path, is a symlink, dereference it
		$filelinkpath=qx(readlink -q $filefullpath);
		chomp($filelinkpath);
		&Info("Readlink path=$filelinkpath");

		$curtime=qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);
		&Info("[$curtime] Blame[$ndindex]: $ndef");

		$filepath = ($filelinkpath ? $filelinkpath : $filefullpath);
		$filepath =~ s%\\%/%g;
		# Remove leading absolute path until 'src'
		my (@filepaths) = split(/\//, $filepath);
		my $skip_path;
		foreach my $fpath (@filepaths) {
		        last if ($fpath =~ /^src$/);
        		$skip_path.="$fpath/";
		}

		$filepath =~ s/$skip_path//g;
		&Info("Effective filepath to search = $filepath");

		$file    = qx(basename $filefullpath); chomp($file);

		# Create a unique CID key, so that blame list generation
		# can re-use an identified user id across different targets
		$cid_key="cid${cid}__${checker}__${func}__${file}__${line}";
		$cid_key=~ s/\(\)//g;

		# Check if a cache svn user exists for unique cid key
		if ( -s "${SVNBLAME_LOGDIR}/${cid_key}.txt" ) {
			my $svn_user=qx(cat "${SVNBLAME_LOGDIR}/${cid_key}.txt");
			chomp($svn_user);
			if ($svn_user =~ /^\s*$/) {
				&Error("Empty cached svn blame user found: $svn_user");
				&Error("Removing bad cached blame file");
				unlink("${SVNBLAME_LOGDIR}/${cid_key}.txt");
			} else {
				&Info("Cached svn blame user found: $svn_user");
				$cidsProcessed{$cid_key} = $svn_user;
			}
		}

		if (!exists($cidsProcessed{$cid_key})) {

			# Extract svn rev number from $file. If it can't be
			# extracted, set filerev to branch or HEAD for TOT
			$fileurl   = "${svnurl}/$filepath";
			my $svnls=`$svncmd ls $fileurl 2>&1`;
			if ($? != "0") {
				($filepath) = grep { /\/${file}$/ } @srctree;
				$fileurl    = "${svnurl}/$filepath";
				&Info("Recomputed filepath=$filepath");
			} else {
				&Dbg("svn ls $fileurl output");
				&Dbg("$svnls");
			}

			($filerev) = (split(/\s+/,qx($svncmd info $fileurl | grep "^Revision: ")))[1];
			$filerev   =~ s/\s+//g;
			# If filerev can't be derived, set to bld SVN rev
			if ($filerev !~ /^\d+$/) {
				$filerev = $bldsvnrev;
			}

			# First check annotate runs on path found by build
			# if not go to svn path
			$curtime=qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);
			&Info("[$curtime] start svnwho $cid_key");
			if ( $filepath ) {
				&Info("$svnwho -r $filerev $fileurl $line");
				$def_author = qx($svnwho -r $filerev $fileurl $line 2> $NULL);
				chomp($def_author);
				$ver_author_line = qx($svncmd log -q -r $filerev $fileurl | grep "$filerev");
				($ver_author) = (split(/\|/, $ver_author_line))[1];
				$ver_author =~ s/\s+//g;
				chomp($ver_author);

				# Validate if the identified user valid or not
				`id $def_author > $NULL 2>&1`;
				if ( "$?" != "0" ) { $def_author = $goner; }
				`id $ver_author > $NULL 2>&1`;
				if ( "$?" != "0" ) { $ver_author = $goner; }
			} else {
				$def_author = "unknown";
			}

			&Info("blddir=$blddir");
			&Info("bldsvnrev=$bldsvnrev");
			&Info("filelinkpath=$filelinkpath");
			&Info("filefullpath=$filefullpath");
			&Info("filepath=$filepath");
			&Info("filerev=$filerev");
			&Info("bldsvnrev=$bldsvnrev");
			&Info("defect_author=$def_author");
			&Info("version_author=$ver_author");

			# Populate processed blames, to share with other targets
			$cidsProcessed{$cid_key} = $def_author if ($def_author);
		} else { #else (!exists($cidsProcessed{$cid_key}))
			&Info("Already found: $cid_key = $cidsProcessed{$cid_key}");
			# When default blame author comes from cached cid_key
			# set its value from cidsProcessed hash
			$def_author = $cidsProcessed{$cid_key};
		} # cidsProcessed

		# Store identified svn user for unique cid_key
		# This will act like cache for subsequent report runs,
		# as svn blame is slower many times.
		# takes a while to run
		if ( ! -f "${SVNBLAME_LOGDIR}/${cid_key}.txt" ) {
			system("echo $cidsProcessed{$cid_key} > ${SVNBLAME_LOGDIR}/${cid_key}.txt" );
		}

		$ndefmsg.= sprintf("    %-7.7s %-15.15s  %-8s  %-20s  %-s\n",$cid,$checker,$cidsProcessed{$cid_key},"$file\[$line\]",$func);

		push(@{$svnCheckins{$branch}},$file);

		$curtime=qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);
		&Info("[$curtime] end svnwho $cid_key");

		foreach my $category ( @{$rAllRuns->{$schedrun}{categories}} ) {
			if ($def_author !~ /unknown|$goner/) {
				&Info("Will skip $def_author from email notification list");
			}
			push(@{$rCatInfo->{$category}{notifylist}},$def_author) unless (grep {/^$def_author$/} @{$rCatInfo->{$category}{notifylist}});
			push(@{$rCatInfo->{$category}{cclist}},$ver_author) unless (grep {/^$ver_author$/} @{$rCatInfo->{$category}{cclist}});
		}
	} # @new_defects

	# $ndefmsg  .= sprintf("    File last checked in by: $ver_author\n");
	$ndefmsg  .= sprintf("    -----------------------------------------------------------------------------\n");

	if ( @new_defects ) {
		return("$ndefmsg");
	} else {
		# &Warn("No new defects were found for $myrun_id");
		return("");
	}

}; # showNewDefects ()

## Scan runs in rAllRuns hash
sub scanRuns
{
	## Initialize counters
	$numpassed = $numfailed = 0;

	## Now check the status of each coverity target and generate messages
	foreach my $schedrun ( sort keys %$rAllRuns ) {
		my @fruns      = ();
		my @runstrings = ();
		my $msg        = "";
		my $ndefmsg    = "";
		my $branch     = "";
		my $branddir   = "";
		my $branchdir  = "";
		my $bldtarget  = "";
		my $projname   = "";
		my $schedruntmp= $schedrun;

		# Append querydate to ensure that project string isn't matched as a
		# substring
		my $runstring = "$schedrun $querydate";
		my $curtime   = qx(date '+%Y/%m/%d %H:%M:%S'); chomp($curtime);

		&Info("[$curtime] Scanning Run: $runstring");

		push(@runstrings,"$runstring");

		$schedruntmp =~ s/Preco\s+//g;
		($branch,$bldtarget) = ($schedruntmp =~ /^(\w+\b)\s*(.*)$/);

		&Info("Derived from snapshot branch=$branch; bldtarget=$bldtarget");

		$bldtarget =~ s/\//_/g;

		# Construct project/stream name from build target name
		# e.g: "FALCON_BRANCH_5_90 WinXP x86 DHD USB Driver" becomes
		#       "FALCON_BRANCH_5_90__WinXP_x86_DHD_USB_Driver"
		if (($bldtarget =~ /preco_/) || ($runstring =~ /preco/i)) {
			# Get short target name from descriptive name for stream
			# Prefix Preco to fetch correct bld target name
			$bldtarget = $tgtDescMap{"Preco $bldtarget"};
			# Match preco coverity baseline convention preco_<branch>_<target>
			$bldtarget =~s/preco_//g;
			$projname  = "preco_${branch}__${bldtarget}";
		} else {
			# Get short target name from descriptive name for stream
			$bldtarget = $tgtDescMap{$bldtarget};
			$projname  = "${branch}__${bldtarget}";
		}

		&Info("Coverity project derived for query: $projname");

		foreach my $runstring ( @runstrings ) {
			my $msg_header = "";
			my $msg        = "";

			$runstrings =~ s/\s+/ /g;

			# Search for matching snapshot in today's
			# snapshots doesn't mix preco and nightly streams
			# So prefix with product hndwlan in query
			@frunstring = grep { m/hndwlan\s*,\s*$runstring/i } @todays_runs;
			if (@frunstring) {
				&Info("Found matching snapshot: @frunstring");
			} else {
				&Warn("No matching snapshot found for $runstring");
			}

			# See if the new stream that is created in different product component
			@frunstring_bad = grep { m/Default\s*,\s*$runstring/i } @todays_runs;
			if (@frunstring_bad) {
				&Error("WRONG product component map 'Default' for $runstring");
				&Error("Login to Coverity UI Config and update this stream to have hndwlan as component");
			}

			# Run ID,Product,Description,Date,Hist. New Defects,Outstanding Defects,PARSE_ERROR,# Files,# Components,LOC
			if ( @frunstring ) {

				push(@fruns, @frunstring);

				foreach my $frun ( @frunstring ) {
					@frun_details     = split(/,/,$frun);
					$frun_id          = $frun_details[0];
					$frun_desc        = $frun_details[2];
					$frun_newdefects  = $frun_details[4];
					$frun_outstanding = $frun_details[5];
					$frun_files       = $frun_details[6];

					print WEBAPI_LOG "$GET_PROJECT_URL --project $projname\n";

					&Info("$GET_PROJECT_URL --project $projname");
					$frun_url         = qx($GET_PROJECT_URL --project $projname);
					$webapi_ec=$?;
					chomp($frun_url);

					&Info("Project URL derived = $frun_url");

					if ($webapi_ec != 0) {
						&Warn("Project URL missing for $projname");
					}

					&Dbg("== $frun_desc ==");
					if ( $frun_newdefects > 0 ) {
						# If new defects are found, tag it with '*' char
						$msg_header  = "* $frun_desc";
					} else {
						$msg_header  = "  $frun_desc";
					}

					$msg_header .= "\n";
					$msg_header .= "    $frun_newdefects new defects, ";
					$msg_header .= "$frun_outstanding outstanding defects, ";
					$msg_header .= "Run ID=$frun_id\n";
					$msg_header .= "    Run Details: $frun_url\n";
					if ( $frun_newdefects > 0 ) {
						# Show new defects in run-id.
						$ndefmsg  = &showNewDefects($frun_id,"$schedrun");
						$newdefect_runs++;
					}
					foreach my $category ( @{$rAllRuns->{$schedrun}{categories}}) {
						$rCatInfo->{$category}{pass}      .= "$msg_header $msg\n";
						if ( $frun_newdefects > 0 ) {
							$rCatInfo->{$category}{newdefects} .= "$msg_header $msg\n";
							$rCatInfo->{$category}{newdefects} .= "$ndefmsg\n" if ( $ndefmsg );
							my $branch_pfx;
							($branch_pfx) = (split(/_/,$branch))[0];
							# If $branch has a new defect, include branch_pfx
							# to include in email notification subject line
							push(@{$rCatInfo->{$category}{newdefect_branches}},$branch_pfx) unless (grep { /^$branch_pfx$/ } @{$rCatInfo->{$category}{newdefect_branches}});
						}
					}

					$numpassed++;
				} # for $frun in @frunstring

			} else {

				# !@frunstring
				my $buildos= $rAllRuns->{$schedrun}{buildos};
				my $COVBUILD_BRAND= $BrandsByPlatform{$buildos};

				&Dbg("buildos = $buildos COVBUILD_BRAND = $COVBUILD_BRAND");

				$branchdir= ($branch =~ /TRUNK/) ? "NIGHTLY" : $branch;
				$branddir = "${BLDSERVER_BASE}/build_${buildos}/$branchdir/${COVBUILD_BRAND}";
				$blddir   = qx(find ${branddir}/$blddate -maxdepth 0 -mindepth 0 2> ${NULL} | xargs ls -1td | egrep -v '^\.\$'); chomp($blddir);

				&Info("Found Build Dir = $blddir");
				&Info("Found Build ERROR LOG=$blddir/$ERRORLOG") if ( -f "$blddir/$ERRORLOG" );

				if (( -d "${blddir}" ) && ( -s "${blddir}/${ERRORLOG}" )) {
					# Match build errors/warnings to build_summary format
					$ignorewarnings='has modification time in the future|clock skew detected';
					$blderrors   = qx(grep "Error [0-9]\\+[[:space:]]*\$" ${blddir}/${RLSLOG} |  wc -l | xargs printf "%d"); chomp($blderrors);
					$bldwarnings = qx(grep "warning" ${blddir}/${RLSLOG} | egrep -v -i "${ignorewarnings}"  | wc -l | xargs printf "%d"); chomp($bldwarnings);
					&Dbg("blderrors=$blderrors; bldwarnigns=$bldwarnings");
					$msg  = "  $runstring FAILED";
					$msg .= "  ($blderrors errors, $bldwarnings warnings)\n";
					$msg .= "    Errors: ${BLDSERVER_URL}${blddir}/${ERRORLOG}\n";
					$msg .= "    Log   : ${BLDSERVER_URL}${blddir}/${RLSLOG}\n";
				} else {

					$msg  = "  $runstring FAILED (missing build)\n";
					$msg .= "    Build : ${COVBUILD_URL}/build_$rAllRuns->{$schedrun}{buildos}/$branch/${COVBUILD_BRAND}/\n";
				}

				foreach my $category ( @{$rAllRuns->{$schedrun}{categories}}) {
					$rCatInfo->{$category}{fail} .= "$msg\n";
				}
				$numfailed++;
			} # frunstring
		} # foreach $runstring in @runstrings
	} # foreach $schedrun in %$rAllRuns
}; # scanRuns ()

## Notify admins overall coverity summary (and also module level messages)
sub notifyCategoryAdmins
{
	my ($category) = shift;
	my ($catname,$catfh,$catmsg);

	$catname = uc($category);
	$CATFH   = uc($category);

	$catmsg = qx(mktemp ${TEMP}/cov${category}.XXXXXX);
	chomp($catmsg);
	chmod 0644, $catmsg;
	open($CATFH, ">$catmsg")  || die "Can't open $catmsg";
	print $CATFH "Coverity Nightly Run Summary of ALL targets for ${rundate}\n\n";
	print $CATFH "Report Time         : ${nowtimestamp}\n";
	if ( $newdefect_runs > 0 ) {
		print $CATFH "Coverity Run Status : ${numtotal_sched} scheduled, ${numpassed} ran, ${numfailed} failed, $newdefect_runs with new defects\n\n";
	} else {
		print $CATFH "Coverity Run Status : ${numtotal_sched} scheduled, ${numpassed} ran, ${numfailed} failed\n\n";
	}
	if ( $ERRORS ne '' ) {
		print $CATFH "=== COVERITY REPORTING ERRORS ============================\n";
		print $CATFH "$ERRORS\n";
	}

	if ( $WARNINGS ne '' ) {
		print $CATFH "=== COVERITY REPORTING WARNIGNS ==========================\n";
		print $CATFH "$WARNINGS\n";
	}
	if ( defined($rCatInfo->{$category}{fail}) ) {
		&Dbg("$rCatInfo->{$category}{fail}");
		print $CATFH "=== COVERITY TARGETS FAILED TO RUN =====================\n";
		print $CATFH "$rCatInfo->{$category}{fail}\n";
	}
	if ( defined($rCatInfo->{$category}{newdefects}) ) {
		&Dbg("$rCatInfo->{$category}{newdefects}");
		print $CATFH "=== COVERITY TARGETS WITH NEW DEFECTS ==================\n";
		print $CATFH "$rCatInfo->{$category}{newdefects}\n";
	}
	if ( defined($rCatInfo->{$category}{svncheckins}) ) {
		&Dbg("$rCatInfo->{$category}{svncheckins}");
		print $CATFH "=== RELEVANT SVN CHECKINS ==================\n";
		print $CATFH "$rCatInfo->{$category}{svncheckins}\n";
	}
	if ( defined($rCatInfo->{$category}{pass}) ) {
		&Dbg("$rCatInfo->{$category}{pass}");
		print $CATFH "=== COVERITY TARGETS SUCCESSFULLY RAN ==================\n";
		print $CATFH "$rCatInfo->{$category}{pass}\n";
	}
	close($CATFH);
	&Info("Notifying $catname summary to '@{$rCatInfo->{$category}{owners}}' now");
	$subject  = "";
	$subject .= "COVERITY ERROR:"    if ( $ERRORS   ne '' );
	$subject .= "COVERITY WARNINGS:" if ( $WARNINGS ne '' );
	if ( $numfailed > 0 ) {
		$subject .= "Coverity Run Summary ";
		if ( $newdefect_runs > 0 ) {
			$subject .= "($numfailed of ${numtotal_sched} FAILED, found $newdefect_runs with new defects) for ${rundate}";
		} else {
			$subject .= "($numfailed of ${numtotal_sched} FAILED) for ${rundate}";
		}
	} else {
		$subject .= "Coverity Run Summary ";
		if ( $newdefect_runs > 0 ) {
			$subject .= "(all ${numtotal_sched} ran, found $newdefect_runs with new defects) for ${rundate}";
		} else {
			$subject .= "(all ${numtotal_sched} ran) for ${rundate}";
		}
	}
	if ( $USER =~ /$REPORT_USER/ ) {
		my(@tolist,@cclist);

		push(@tolist, @{$rCatInfo->{$category}{owners}});

		if ($dbg) {
			&Dbg("Reset tolist=cclist=$bldadmin");
			@tolist = @cclist = ($bldadmin);
		}

		if ($mailto) {
			&Dbg("Reset tolist=cclist=$mailto");
			@tolist = @cclist = ($mailto);
		}

		&Info("Notifying $catname summary To: @tolist now");
		system("cat $catmsg   | mail -s '$subject' @tolist");
		sleep 5;
		system("cp -v $catmsg ${COVSUM_LOGDIR}/${category}_${dirtimestamp}.txt");
		system("unix2dos ${COVSUM_LOGDIR}/${category}_${dirtimestamp}.txt");
		system("rm -fv $catmsg");
	} else {
		&Info("Email notification disabled. Check '$category' report '$catmsg'");
	}
}; # notifyCategoryAdmins ()

## Notify individual module owners only if there are new defects
sub notifyCategoryOwners
{
	my ($category) = shift;
	my ($catname,$catfh,$catmsg);
	my ($notifyusers);
	my (%seen_users);

	$catname = uc($category);
	$CATFH   = uc($category);

	if ( ! defined($rCatInfo->{$category}{newdefects}) ) {
		&Info("No new defects found in $catname category");
		return;
	}

	$notifyusers = join(',',grep { !$seen_users{$_}++ } sort @{$rCatInfo->{$category}{notifylist}});

	$catmsg  = qx(mktemp ${TEMP}/cov${category}.XXXXXX);
	chomp($catmsg);
	chmod 0644, $catmsg;
	open($CATFH,  ">$catmsg")   || die "Can't open $catmsg";

	if ( "$ERRORS" ne '' ) {
		print $CATFH "\n";
		print $CATFH "#################### WARN ##################\n";
		print $CATFH "* ERRORS : Coverity DB Query API Errors Found\n";
		print $CATFH "* ERRORS : Lookup console log for details\n";
		print $CATFH "* ERRORS : BLAME EMAIL SUPPRESSED\n";
		print $CATFH "#################### WARN ##################\n";
		print $CATFH "\n";
	}

	print $CATFH "* New Defects Found in $catname targets for $rundate\n";
	print $CATFH "* Defects From    : $notifyusers\n";
	print $CATFH "* Coverity 5.3 UI : $PREVENT_WEBURL\n";
	print $CATFH "* Read This Now. You MUST follow this process to address this issue:\n";
	print $CATFH "*                 : $COVPROCESS_URL\n";
	print $CATFH "\n";

	if ( defined($rCatInfo->{$category}{newdefects}) ) {
		print $CATFH "=== COVERITY TARGETS WITH NEW DEFECTS ==================\n";
		print $CATFH "$rCatInfo->{$category}{newdefects}\n";
	}
	if ( defined($rCatInfo->{$category}{svncheckins}) ) {
		&Dbg("$rCatInfo->{$category}{svncheckins}");
		print $CATFH "=== RELEVANT SVN CHECKINS ==================\n";
		print $CATFH "$rCatInfo->{$category}{svncheckins}\n";
	}
	if ( defined($rCatInfo->{$category}{pass}) ) {
		print $CATFH "=== COVERITY TARGETS SUCCESSFULLY RAN ==================\n";
		print $CATFH "$rCatInfo->{$category}{pass}\n";
	}
	close($CATFH);
	if ( $USER =~ /$REPORT_USER/ ) {
		my(@tolist,@cclist);

		push(@tolist, @{$rCatInfo->{$category}{owners}});
		push(@tolist, @{$rCatInfo->{$category}{notifylist}});
		push(@cclist, @{$rCatInfo->{$category}{cclist}});

		# Take out goner from tolist and cclist for email purposes
		# But still show in subject line
		@cclist = grep { ! /^$goner$/ } @cclist;
		@tolist = grep { ! /^$goner$/ } @tolist;

		if ($dbg) {
			&Dbg("Reset $notifyusers=tolist=cclist=$bldadmin");
			@tolist = @cclist = ($bldadmin);
		}

		if ($mailto) {
			&Dbg("Reset tolist=cclist=$mailto");
			@tolist = @cclist = ($mailto);
		}


		my @newdefect_branches = sort @{$rCatInfo->{$category}{newdefect_branches}};

		my $subject;
		if ( "$ERRORS" ne '' ) {
			$subject = "COVERITY QUERY ERRORS FOUND: Coverity New Defects on @newdefect_branches by $notifyusers on $rundate";
		} else {
			$subject = "Coverity New Defects on @newdefect_branches by $notifyusers on $rundate";
		}

		&Info("Notifying $catname defects to To:'@tolist' Cc:'@cclist' now");
		my $toAddress = join(',', @tolist);
		my $ccAddress = join(',', @cclist);
		open(my $CATFH, "<", $catmsg) or die "Can't open $catmsg: $!";
		my $data = do {local $/; <$CATFH> };
		close($CATFH);
		email($fromAddress, $toAddress, $ccAddress, $subject, $data);
		sleep 5;
		system("cp -v $catmsg ${COVSUM_LOGDIR}/${category}_${dirtimestamp}.txt");
		system("unix2dos ${COVSUM_LOGDIR}/${category}_${dirtimestamp}.txt");
		system("rm -fv $catmsg");
	} else {
		&Info("Email notification disabled. Check '$category' report '$catmsg'");
	}

}; #notifyCategoryOwners ()

#
# Main ()
#
sub Main {

	&Info3("STEP1: Finding list of all scheduled Nightly and Preco Targets");
	&findTargets;

	&Info3("STEP2: Finding coverity snapshots for Nightly and Preco Targets");
	&getSnapshots;

	&Info3("STEP3: Scan snapshots for new defects introduced");
	&scanRuns;

	# If coverity query db returns any errors, notify admin users
	if (( "$ERRORS" ne '' ) || (defined($dbg))) {
		$rdbgowner=[($bldadmin)];
		foreach my $category ( keys %$rCatInfo ) {
			$rCatInfo->{$category}{owners} = $rdbgowner;
		};
	}

	&Info3("STEP4: Notify functional groups on new defects found");
	&notifyCategoryAdmins("admin");
	&notifyCategoryOwners("esta");
	&notifyCategoryOwners("sta");
	#&notifyCategoryOwners(router);
}

# Show help
sub Help
{
	print "
        This script produces Coverity build status report and detects any
	new defects across all branches and targets.
        This script needs to be run as $REPORT_USER by build-team.
        Coverity database is access as read-only through webapi.

	Usage: $0 \\
	  -date yyyy.mm.dd (optional) Coverity reports as of yyyy.mm.dd      \\
	  -dbg 	          (optional) Debug/Verbose mode. Emails go to admins \\
	  -help 	  (optional) Show this help screen.                  \\
	  -mail <rcpt> 	  (optional) Force emails to <rcpt>.
	";

	exit 0;
}

&Main;

print WEBAPI_LOG "======= END  : $dirtimestamp ======\n";
close(WEBAPI_LOG);
