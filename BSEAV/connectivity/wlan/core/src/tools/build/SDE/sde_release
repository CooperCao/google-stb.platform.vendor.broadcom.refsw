#!/usr/local/bin/perl
#
# $Copyright Broadcom Corporation$
#
# $id$

package SDE::sde_release;
use strict;
use warnings;
use Env;
use File::Copy;
use File::Path qw(make_path);
use File::Basename;

use version;
our $VERSION = "1.00";

if ($#ARGV < 1)
{
        print_release_usage(); 
}

my $action = shift @ARGV;
my $target = shift @ARGV;

# Make sure we start from the correct directory
if ( ! -e "./src" )
{
    print "$0: Not in build root directory (./src not found)!\n";
    exit 1;
}

if ( ! -e "./build" )
{
    print "$0: Not in build root directory (./build not found)!\n";
    exit 1;
}

if ( $action eq "release-bins" )
{
    my ($release, $oem, $junk) = split ( /_/, $target);
    my $rls_root     = "release/$oem";

    # Make sure release src exists or create it ourselves
    if ( ! -e "$rls_root" )
    {
        mk_dir ( "$rls_root" ) ;
    }

    ###########################################
    # Copy dhd driver(s) to release directory
    ###########################################

    # *dhd.*.stripped are the binaries we need to release, use it to confine
    # the our match, so we can get our directory paths from the matched paths
    my @dhd_driver_list = `ls ./build/${oem}/src/dhd/linux/*/*/*/*/*dhd.*.stripped`;

    # loop through all the matches files
    my $dhd_driver = "";
    foreach $dhd_driver (@dhd_driver_list)
    {
	chomp($dhd_driver);

        # We only need the path under dhd/linux/ for release path structure
	my ($junk, $rls_driver) = split ( /\/linux\//, ${dhd_driver} );

	my ($filename, $directory) = fileparse ("${rls_driver}");

        # get rid of the .stripped suffix in the object name in release
	$filename =~ s/\.stripped$//g ;

	# create release path and copy the driver from build area to release
        mk_dir ( "${rls_root}/${directory}" );
	if ( -e "${dhd_driver}" )
	{
	    copy ( "${dhd_driver}", "${rls_root}/${directory}/${filename}" ) or die "$0: Cannot copy ${dhd_driver} to ${rls_root}/${directory}/${filename} \n";
        }
    }


    ###########################################
    # Copy apps dhd.exe to release directory
    ###########################################

    my $dhd_apps_dir = "./build/${oem}/src/dhd/exe" ;

    # file dhd are the binaries we need to release, use it to confine
    # the our match, so we can get our directory paths from the matched paths
    # todo: we will need to change dhd to dhd${suffix} for different platforms
    my @dhd_apps_list = `ls ./build/${oem}/src/dhd/exe/*/dhd`;
    my $dhd_apps = "";

    # loop through all the match paths
    foreach $dhd_apps (@dhd_apps_list)
    {
	chomp($dhd_apps);

	my ($filename, $directory) = fileparse ("$dhd_apps");

        # We only need the path under dhd/exe/ for release path structure
	my ($junk, $target_arch) = split ( /\/exe\//, $directory );

	# map x86_mmx to x86, since we prefer x86 in release
        $target_arch =~ s/x86_mmx/x86/g;

	# Create valid directory before we can copy the file over
	# to the release area
	mk_dir ( "${rls_root}/apps/${target_arch}" );
	copy ("$dhd_apps", "${rls_root}/apps/${target_arch}/${filename}") or die "$0: Cannot copy $dhd_apps to ${rls_root}/apps/$(target_arch}/${filename} ! \n";
    }

 
    ################################################
    # Copy apps bcmdl and trx to release directory
    ################################################

    mk_dir ( "${rls_root}/apps/x86" );
    if ( ! -e "${rls_root}/apps/x86/bcmdl" )
    {
        copy ("src/usbdev/usbdl/bcmdl", "${rls_root}/apps/x86") or die "$0: Cannot copy src/usbdev/usbdl/bcmdl to ${rls_root}/apps/x86 ! \n";
    }

    if ( ! -e "${rls_root}/apps/x86/trx" )
    {
        copy ("src/tools/misc/trx", "${rls_root}/apps/x86") or die "$0: Cannot copy src/tools/misc/trx to ${rls_root}/apps/x86 ! \n";
    }
 

}
elsif ( $action eq "release-src" )
{
    my $filelist = shift @ARGV;

    my ($release, $oem, $junk) = split ( /_/, $target);
    my $rls_root     = "release/$oem";
    my $rls_src_dir  = "release/$oem/src";
    my $oem_filelist = "${filelist}_${oem}";

    # Make sure release src exists or create it ourselves
    if ( ! -e "$rls_src_dir" )
    {
        mk_dir ( "$rls_src_dir" ) ;
    }

    #######################################################
    # Copy all the files in OEM filelist to release area
    #######################################################

    open (FILELIST, "<$oem_filelist") or die "$0: Cannot open filelist file $oem_filelist\n";

    # go through the filelist copy every file from build to release directories
    while (<FILELIST>)
    {
	# get rid of blank line and comments, line begin with ~src is for 
        # windows dll only? anyway we don't want them in linux build
	if ( $_ !~ /^\s*$/ && $_ !~ /^\s*#/ && $_ !~ /^\~src/ )
	{
	    # get rid of newline character at the end of the line
	    chomp($_);

	    # strip non-printable characters
	    $_ =~ s/[^[:print:]]//g;
	    # strip dollar sign, Per Parkash $ is used for windows builds 
	    $_ =~ s/\x3f//g;

	    my ($filename, $directory) = fileparse ("$_");

	    # Create valid directory before we can copy the file over
	    # to the release area
	    mk_dir ( "${rls_root}/${directory}" );
	    copy ("$_", "${rls_root}/$_") or print "$0: **** Cannot copy $_ to ${rls_root}/$_ \n";
	}
    } #end while FILELIST

    if ( $oem eq "android" )
    {
	# There is also ./src/dhd/android/Android.mk????
	copy ( "./src/Android.mk", "${rls_src_dir}" ) or die "$0: Cannot copy Android.mk to $rls_src_dir!\n";
    }

 
    #######################################################
    # tar zip the release goes here.....
    #######################################################
}
elsif ( $action eq "integrate-fw" )
{
    my ($release, $oem, $junk) = split ( /_/, $target);
    my $rls_root         = "release/$oem";
    my $custom_cfg       = "~/integrate_firmware.cfg";
    my $default_cfg      = "src/tools/release/integrate_firmware.cfg";
    my $integrate_fw_cfg = "";
    my $fw_bld_root      = "/projects/hnd_swbuild/build_linux";
    my $cfg_def_1        = "firmware_tag";
    my $cfg_def_2        = "brand";
     
    #if ( -e "$custom_cfg" )
    #{
    #	$integrate_fw_cfg = $custom_cfg;
    #}
    #elsif ( -e "$default_cfg" )
    if ( -e "$default_cfg" )
    {
	$integrate_fw_cfg = $default_cfg;
    }
    else
    {
	print "$0: Cannot find integrate_firmware.cfg file!\n";
	exit 1;
    }

    open (FW_CFG, "<$integrate_fw_cfg") or die "$0: Cannot open filelist file $integrate_fw_cfg\n";
    
    # go through the filelist copy every file from build to release directories
    my $def_1_flag = 0;
    my $def_2_flag = 0;
    my @fw_tags = ();
    my $brand = "";

    print "\nOEM: $oem\n";
    while (<FW_CFG>)
    {
	# get rid of blank line and comments
	if ( $_ !~ /^\s*$/ && $_ !~ /^\s*#/ )
	{
	    # get rid of newline character at the end of the line
	    chomp($_);

            # We only need the path under dhd/linux/ for release path structure
	    my ($name, $tmp1) = split ( /=/, $_ );
 	    my ($tmp2, $junk)  = split ( /;/, $tmp1 );

	    $name =~ tr/A-Z/a-z/;
	    $name =~ s/\W+//g;  # get rid of all non word characters
	   
	    if ( $name eq "$cfg_def_1" )
	    {
		if ( $def_1_flag == 1 )
		{
	            print "$0: More then one line of \"$cfg_def_1\" definition !\n";
		    exit 1;
		}
	        print "Firmware tag(s): $tmp2\n";
	        @fw_tags = split ( /\s+/, $tmp2 );
		$def_1_flag = 1;
	    }
	    elsif ( $name eq "$cfg_def_2" )
	    {
		if ( $def_2_flag == 1 )
		{
	            print "$0: More then one line of \"$cfg_def_2\" definition !\n";
		    exit 1;
		}
	        print "Firmware brand(s): $tmp2\n\n";
	        $brand = $tmp2;
		$def_2_flag = 1;
	    }
	    else
	    {
	        print "$0: Warning! line \"$_\" undefined !\n";
		exit 1;
	    }
	}
    } #end while FW_CFG

    if ( $def_1_flag == 0 || $def_2_flag == 0 )
    {
        print "$0: Cannot found all required configuration definitions in $integrate_fw_cfg !\n";
	exit 1;
    }

    foreach my $fw_tag (@fw_tags)
    {
	$fw_tag =~ s/\W+//g;
        
        my $ret_str = `find ${fw_bld_root}/${fw_tag}/${brand}/ -maxdepth 1 -print | sort -t. -n | tail -1`;
   
	chomp($ret_str); 
	my ($fw_bld_date, $path) = fileparse ("$ret_str");

        print "Integrating firmware release from ${fw_bld_root}/${fw_tag}/${brand}/${fw_bld_date}/release/${oem}/firmware \n";

        my @ret_list = `ls -d ${fw_bld_root}/${fw_tag}/${brand}`;

	for my $brand_dir (@ret_list)
	{	
	    chomp($brand_dir); 
	    my ($one_brand, $path) = fileparse ("$brand_dir");
            print "Integrating brand $one_brand....\n";

	    if ( -e "${fw_bld_root}/${fw_tag}/${one_brand}/${fw_bld_date}/release/${oem}/firmware" )
	    {

	        mk_dir ( "${rls_root}/firmware/${fw_tag}/${one_brand}/${fw_bld_date}" );
	        my $cp_return = `cp -rf ${fw_bld_root}/${fw_tag}/${one_brand}/${fw_bld_date}/release/${oem}/firmware/*  ${rls_root}/firmware/${fw_tag}/${one_brand}/${fw_bld_date}/ `;
	        if ($? != 0)
	        {
	            #print "$0: cp -rf ${fw_bld_root}/${fw_tag}/${one_brand}/${fw_bld_date}/release/${oem}/firmware/*  ${rls_root}/firmware/${fw_tag}/${one_brand}/${fw_bld_date}/* failed !\n";
		}
	    }
	    else
	    {
		#print "$0: *** ${fw_bld_root}/${fw_tag}/${one_brand}/${fw_bld_date}/release/${oem}/firmware doesn't exist! Skipping this brand.\n";
		print "Firmware release structure doesn't exist for this brand! Skip it.\n";
	    }
	}
    }
}
else
{
    print_release_usage();
}


#########################################################################
# subroutine to create directory and report the error when error occur
# , not to exit for now, let the following step handle error
#########################################################################

sub mk_dir
{
    my $new_dir = shift @_;

    make_path ( "${new_dir}", { verbose => 1, mode => 0755,
			error => \my $err,} );
    if (@$err)
    {
	for my $diag (@$err)
	{
	    my ($file, $message) = %$diag;
	    print "$0: $message\n";
	}
    }
}

sub print_release_usage
{
    print "\n";
    print "Usage: $0 <subcommand> [options] [args] \n\n";
    print "Available subcommands: \n";
    print "   release-bins \n";
    print "   release-src \n";
    print "   integrate-fw \n";
    print "   help \n";
    print "\n";
    exit 1;
}


exit 0;
