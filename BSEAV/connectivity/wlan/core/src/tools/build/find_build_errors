#!/usr/bin/perl
#
# Given a list of known error strings, search them build log.
#
# It does following subtasks
# - Remove all clutter from filtered build error chunks
# - Support platform specific error filtering
# - Support error patterns that have relevant useful info either
#   before the error string or after
# - Convert relative paths to absolute paths of files in build logs
#   to easily pass them find_svn_checkins phase to create blames
# - Consolidate duplicate looking errors (show one error chunk,
#   instead of multiple duplicate chunks from 'make -k' session logs)
# - Search TAG, BRAND user from build logs
# - Files that are filtered are automatically queried in version control
#   tools for given tag to find out who checked in last.
#
# Author: Prakash Dhavali (2009/05/25)
# Contact: hnd-software-scm-list
#
# $Id$
#
# SVN: $HeadURL$
#
# Usage: find_build_errors.pl -platform <unix|windows|macos|netbsd> [-r <tag|branch>] <build-log-file>
#

use strict;
use Cwd 'abs_path';
use File::Basename;

my $NULL = "/dev/null";

my @ERROR_PATTERNS;       # List of platform specific ERROR_PATTERNS to search for
my $ERROR_PATTERNS;       # @ERROR_PATTERNS regex
my @POSTMATCH_PATTERNS;   # These show reasons after an error occurance
my $POSTMATCH_PATTERNS;   # @POSTMATCH_PATTERNS regex
my @EXIT_PATTERNS;        # List of platform specific EXIT_PATTERNS to search for
my $EXIT_PATTERNS;        # @EXIT_PATTERNS regex
my @build_failures;       # Errors found in $buildlog
my @simplified_errors;    # Errors found in $buildlog
my %processed_error = (); # Try to eliminate duplicate error blocks
my $verbose=0;            # Don't remove duplicates and include exit code search
my $cvsuser;              # Try to match file references to checkins
my $tag;                  # Tag to pull cvs checkin report from
my $reportnum=5;          # Search in last 'n' cvs reports on $tag
my $help;                 # Show help/usage info
my $buildlog;             # Build logfile to process
my @buildlog;             # Array of $buildlog contents
my $buildos="unknown";    # Default build host os (this is derived later)
my $uname_found='';       # platform name found in buildlog
my $brand_found;          # build brand name found in buildlog
my $tag_found;            # branch or tag name found in buildlog
my $platform;             # Build OS platform == uc($buildos)
my $linesbefore=6;        # Filter these number of lines preceding the error
my $linesafter=0;         # Filter these number of lines after the error
my $postmatch_lines=6;    # Certain error patterns and platforms set
			  # linesafter to this value
my @cifindfiles=();      # List of source that can be searched in cvs reports
my $dbg=0;                # CVS query output
my $force=0;              # Command line forcing of certain steps that are
                          # blocked otherwise

my $uname   = `uname -s 2> $NULL`; chomp($uname);
my $pathpfx = ($uname =~ /cygwin/gi) ? 'Z:' : '';

my $find_cvs_checkins = "${pathpfx}/home/hwnbuild/src/tools/build/find_cvs_checkins";
my $find_svn_checkins = "${pathpfx}/home/hwnbuild/src/tools/build/find_svn_checkins";
my $find_checkins; # If -cvs is passed, search CVS reports, otherwise svn log
my $cvs_search;    # If -cvs is passed, set this to indicate cvs is context
my $skip_blame=0;  # Skip blame emails, if set
my $log_times;     # Expect timing data prefixes on each line and strip them off

my @now      = localtime(time());
my $nowtime  = sprintf("%.2d:%.2d:%.2d",$now[2],$now[1],$now[0]);
my $nowdate  = sprintf("%d-%.2d-%.2d",$now[5]+1900,$now[4]+1,$now[3]);

# Default cutoff time used is current time
my $cutoff_time = "$nowdate $nowtime";

# Exit codes/strings (secondary errors, that are unique to each failure)
my @aCommonExitPatterns=(
	'make[\d+]: \*\*\* ',
	'make: \*\*\* ',
);

my @aLinuxOnlyExitPatterns=();
my @aWindowsOnlyExitPatterns=();
my @aMacosOnlyExitPatterns=();
my @aNetbsdOnlyExitPatterns=();

# Commonly occuring error strings in $buildlog
# Escape special chars, as these members are processed as reg-ex patterns
my @aCommonErrorPatterns = (
	# From all compilers
	'cc1: warnings being treated as errors',
	': error: ',
	': .*error .*:',
	' undeclared \(first use in this function\)',
	' \(Each undeclared identifier is reported only once',
	' multiple definition of ',
	' first defined here',
	' undefined reference to \`',
	': parse error before ',
	'cc: Input/output error',
	'cc: No such file or directory',
	'too few arguments to function',
	': version .*GLIBC.*\d+\.\d+.*not found',
	# From Macos compiler
	'cc1plus: warnings being treated as errors',
	# From linkers
	': could not read symbols: Archive has no index; run ranlib to add one',
	'collect2: ld returned 1 exit status',
	'cc1: warnings being treated as errors',
	'referenced in section .*: defined in discarded section',
	'\*\*\* ERROR: Struct elements mismatch',
	'ERROR: struct offset mismatch',
	# From cvs or hndcvs commands
	'Could not find product file ',
	'\bfatal error',
	# From rsh commands
	'protocol failure in circuit setup',
	'failed: Connection timed out',
	'socket: recv: Connection reset by peer',
	# From gmake
	': \*\*\* missing .* Stop',
	' No rule to make target ',
	':\d+:\d+: .*: No such file or directory',
	': \*\*\* commands commence before first target.  Stop.',
	': \*\*\* .*: No such file or directory.  Stop.',
	#disabled# 'install: cannot stat .*: No such file or directory',
	# From binutils
	'/tar: Argument list too long',
	'sed:.*expression.*char.*:',
	# dongle image errors
	'CHIP variable is not defined',
	'awk: cmd. line:\d: fatal: cannot open.*reading',
	'ERROR: Verify .*,dongle_image_release.log',
	'ROM size exceeded',
	#disabled# 'ERROR: Dongle image .*NOT BUILT',
	# Missing files
	'No rule to make target `.*\.o\', needed by',
	# From coverity
	'Another commit is in progress',
	'\[ERROR\] streams must be specified',
	# [ERROR] From server: StaticStream with name 'KIRIN_BRANCH_5_100__debug-apdef-stadef-high' not found.
	'\[ERROR\] From server: StaticStream with name.*not found',
	# Finally Build infrastructure related errors
	'cvs.*failed.*connection.*refused',
	'checkout aborted',
	'No space left on device',
	'ERROR EC1015: Invalid emake root directory',
	'ERROR EC\d+: ',
	'bad root.*/efsroot',
	'Interrupted build: ',
	# SVN errors
	'ERROR.*Module.*does not exist in repository',
	'svn.*Internal Server Error',
	'ERROR.*Cannot access remote subversion repository',
	'Could not read response body:',
	'ERROR.*File is nonexistent at revision',
	'CRITICAL.*Traceback.*most recent call',
	'Authentication realm:',
	'ERROR.*sparse.*not found',
	'svn: Can\'t open file \'.*svn-base\'',
	'ERROR Command Failure',
	# Missing or in-accessible files
	'bash: line .: .*: No such file or directory',
	'perl: realpath couldn\'t resolve ',
	'rm: cannot remove directory.*\.svn.*:',
	'Died at .*.pl line 32',
	'Integer overflow in hexadecimal number',
	# Misc
	'Died at .* line \d+',
	'ClmCompiler: Error: ',
	'realpath.*failed.*No such file or directory',
	'^\S+:\d+: \*\*\* Error:\s+',
	'gcc: [Cc]ommand not found',
	'could not read symbols: Bad value',
	'/bin/sh: .*: No such file or directory',
	'Error: selected processor does not support ',
	'^ERROR: ',
	'\bar:\s+\S+:\s+No such file or directory',
	'Could not open .*: No such file or directory',
	"^svn: URL '.*' doesn't exist",
	"^ln: .*: No such file or directory",
	"Can't locate \\S+ in \@INC",			# missing perl module
	'mixed implicit and normal rules',		# new error in make 3.82+
	'^gub: Error: ',				# all gub errors fit this
	'File name too long',				# fw build filename limit
);

# Linux specific error strings in $buildlog
my @aLinuxOnlyErrorPatterns = (
	# From gmake
	'make: \*\*\* .*Interrupt',
	'make.*\*\*\*.*oldconfig.*Error \d+',
	'make: \*\*\* .*Deleting file',
	# Filter out disabled firmware targets
	'Skipping disabled target ',
	# From all compilers and linkers
	'-ld: NULL .*!',
	' Floating point exception',
	'\*\*\* Failed target:',
	'\*\*\* Error code \d+',
	'FATAL: modpost: GPL-incompatible module .*.ko uses GPL-only symbol',
	# From linker in linking dongle image with roml image
	'arm-none-eabi-ld: UNDEF ',
	'scripts/basic/fixdep: cannot execute binary file',
	# From cross-compiled netbsd5 router image
	'nbmakefs:.*failed',
	# Following is too verbose and in some modules is intentional
	#'\*\*\* Warning: \".*\" .*undefined\!',
	#'ERROR: This kernel module may not load on targets',
	# Custom error messages
	'Error: image exceeds size limit',
	# Finally Build infrastructure related errors
	'Failed in an LSF library call',
	'ld: cannot open ',
	'ERROR This .* build can not run on 64bit os node',
	'sh: Argument list too long',
);

# Windows specific error strings in $buildlog
my @aWindowsOnlyErrorPatterns = (
	# From all compilers
	': unresolved external symbol ',
	'assertion failed at .*:',
	'Error: L.*: ',
	' : Command line error ',
	# From EFI build
	'error C\d+: warning treated as error',
	'error C\d+: cannot open program database ',
	# From Nucleus ARM compiler
	': Error:  #',
	# From inf check
	'Line \d+: ERROR: ',
	# Nucleus ARM compiler produces following error
	'Error: L\d+.*: Undefined symbol',
	# Finally Build infrastructure related errors
	'Job caused multiple agents to fail',
	'Application encountered an unexpected error.*Stopping',
	'ERROR EC3009: CM handshake failed:',
	'ERROR EC3101: BuildStopped:',
	'handle_threadlist_exception called',
	'Error:.*cannot open source input file',
	'There is not enough space on the disk',
	'Resource temporarily unavailable',
);

# MacOS specific error strings in $buildlog
my @aMacosOnlyErrorPatterns = (
	# From macos compiler
	': no input files',
	# SDK/Tool conflict warnings flagged as error, if build fails
	# 'Warning: SDK name collision for name .*: SDK at path',
);

# NetBSD specific error strings in $buildlog
my @aNetbsdOnlyErrorPatterns = (
	# From netbsd compiler
	'\*\*\* Error code \d+',
	# From native netbsd router image (if any)
	'nbmakefs:.*failed',
);

# Exit Patterns per platform
# These are repetitive and ignored unless actual ErrorPatterns are found
my @aLinuxExitPatterns   = (@aCommonExitPatterns, @aLinuxOnlyExitPatterns);
my @aWindowsExitPatterns = (@aCommonExitPatterns, @aWindowsOnlyExitPatterns);
my @aMacosExitPatterns   = (@aCommonExitPatterns, @aMacosOnlyExitPatterns);
my @aNetbsdExitPatterns  = (@aCommonExitPatterns, @aNetbsdOnlyExitPatterns);

# In POSTMATCH_PATTERNS, the errors appear *after* the error message unlike
# other patterns
@POSTMATCH_PATTERNS = (
	'cc1: warnings being treated as errors',
	# Macos compiler shows following occasionally
	'cc1plus: warnings being treated as errors',
	# Efi MSDEV compiler shows following occasionally
	' warning treated as error ',
	# Linux dongle image
	'Error: image exceeds size limit',
	'install: cannot stat .*: No such file or directory',
	# From inf check
	'Line \d+: ERROR: ',
	# Dongle image errors
	'ERROR: Dongle image .*NOT BUILT',
);

# Resource or Infra related error separated out
# For these don't lookup checkins
my @INFRA_PATTERNS = (
	'No space left on device',
	'cvs.*failed.*connection.*refused',
);

# Final Error Patterns per platform
my %ERROR_PATTERNS = (
	LINUX   => [(@aCommonErrorPatterns,
			@aLinuxOnlyErrorPatterns)],
	WINDOWS => [(@aCommonErrorPatterns,
			@aWindowsOnlyErrorPatterns)],
	MACOS   => [(@aCommonErrorPatterns,
			@aMacosOnlyErrorPatterns)],
	NETBSD  => [(@aCommonErrorPatterns,
			@aNetbsdOnlyErrorPatterns)],
);

# Final Exit Patterns per platform
my %EXIT_PATTERNS = (
	LINUX   => [(@aLinuxExitPatterns)],
	WINDOWS => [(@aWindowsExitPatterns)],
	MACOS   => [(@aMacosExitPatterns)],
	NETBSD  => [(@aNetbsdExitPatterns)],
);

# Shell and Bin utils patterns are used in collapsing similar looking errors
# i.e: If two or identical looking errors differ only in binutils or shellutils
# then discard that line (only if line doesn't have $ERROR_PATTERNS)
my @BINUTILS = qw(gcc cc ld as ar nm objcopy objdump ranlib size strings strip addr2line nlmcon);

my $BINUTILS_PATTERNS  = join('|', @BINUTILS);

my @SHELLUTILS = qw(sed awk sh ln);
my $SHELLUTILS_PATTERNS  = join('|', @SHELLUTILS);
my $INFRA_PATTERNS = join('|', @INFRA_PATTERNS);

# These build brands are special, they have been marked to ignore intermediate
# build errors and these produce huge build_error.log file, if duplications
# are not intelligently consolidated
my @SPECIAL_BRANDS = (
	'hndrte',		# this has been made to continue despite errors
	'hndrte-dongle-wl',	# this has been made to continue despite errors
);

# Process cmd line args
sub processArgs {
	my $arg;

	while ($ARGV[0]) {
		$arg = shift @ARGV;
		if ($arg =~ /^-(p|platform)/) {
			# Set build platform
			$platform = shift @ARGV;
			$platform =~ s/window$/windows/g;
       	         	next;
		} elsif ($arg =~ /^-(a|all|v|verbose)/) {
			# Show verbose output
			$verbose = 1;
			next;
		} elsif ($arg =~ /^-(r|rev)/) {
			# Limit the search to this revision or tag or branch
			$tag = shift @ARGV;
			next;
		} elsif ($arg =~ /^-(c|cutoff)/) {
			# Cutoff time for passing to find_svn_checkins
			$cutoff_time = shift @ARGV;
			next;
		} elsif ($arg =~ /^-(d|debug|dbg)/) {
			# Enable debug output
			$dbg = 1;
			next;
		} elsif ($arg =~ /^-n/) {
			# Limit the search only to last 'n' cvs reports/days
			$reportnum = shift @ARGV;
			next;
		} elsif ($arg =~ /^-(h|help)/) {
			$help = 1;
			next;
		} elsif ($arg =~ /^-force/) {
			# Limit the search to this revision or tag or branch
			$force = 1;
			next;
		} elsif ($arg =~ /^-cvs/) {
			# Search in cvs reports
			$cvs_search = 1;
			next;
		} elsif ($arg =~ /^-+logtimes/) {
			# Strip off time stamp prefixes
			$log_times = 1;
			next;
		} elsif ($arg =~ /^-(skip_blame)/) {
			# Skip blame list generation
			$skip_blame = 1;
			next;
		}
		$buildlog = $arg; # User specified logfile to filter errors
		$buildlog =~ s%^http://[^/]+%%;  # Convenience - allow logfile URLS to be pasted.
	} # while
} # processArgs ()

# Debug ()
sub Dbg {
	my ($msg) = @_;

	return if (!$dbg);

	print "DBG: $msg\n";
} # Debug()

# Help ()
sub Usage {
	print "This script filters and simplifies build errors for easier readability\n";
	print "This script is used by all build scripts\n";
	print " - It derives the build host os/platfrom from buildlog\n";
	print " - It removes duplicate errors and lines as much as possible\n";
	print " - It removes all the long path clutter\n";
	print " - It converts relative paths to simple src paths\n";
	print " - It searches failed source filename references in buildlog\n";
	print " - It searches those filtered sources in cvsreports\n\n";
	print " - OR It searches those filtered sources in svn\n\n";
	print "Usage:\n";
   	print "$0 [<options>] <build-log-file>\n\n";
	print "<build-log-file> (*Required*)\n\n";
	print "Options (optional):\n";
	print "  [-p <platform>]\n";
	print "     (optional)(default: derived from <build-log-file> given)\n";
	print "     Build host platform (one of linux,windows,macos,netbsd)\n";
	print "  [-r <tag>]\n";
	print "     (optional)(default: derived from <build-log-file> given)\n";
	print "     CVS branch/tag built set via 'TAG=<tag>' in cmd line\n";
	print "  [-n <search in n cvsreports>]\n";
	print "     (optional)(default: default last 5 reports\n";
	print "     CVS branch/tag built set via 'TAG=<tag>' in cmd line\n";
	print "  [-verbose]\n";
	print "     (optional)(default: non verbose)\n";
	print "     Include exit codes references, duplicate errors\n";
	print "     or directories where errors occured\n";
	print "  [-debug]\n";
	print "     (optional)(default: debug mode output)\n";
	print "     Use it to debug why a particular error pattern was missed\n\n";
	print "EXAMPLES:\n";
	print " 1. Show errors in ,release.log\n";
	print "    \"find_build_errors ,release.log\"\n";
	print " 2. Force build platform to windows in searching ,release.log\n";
	print "    \"find_build_errors -p windows ,release.log\"\n";
	print " 3. Show error patterns that are searched for\n";
	print "    \"find_build_errors -d ,release.log\"\n";
	print " 4. Search failed sources in last 10 days of cvsreports\n";
	print "    \"find_build_errors -n 10 ,release.log\"\n";
	print " 5. Exit patterns that are due to error patterns\n";
	print "    are suppressed as they repeat. Use -verbose to show then\n";
	print "    \"find_build_errors -verbose ,release.log\"\n";
	exit(0);
} # Help()

# Cleanup path prefixes, and convert relative paths to abs paths
sub simplify_error {
	my ($failure) = @_;
	my @abs_lines;
	my %processed_line;
	
	return("$failure") if (!$failure);

	$failure =~ s%\\%/%g;
	# Strip out cygwin local build path for windows logs
	$failure =~ s%/cygdrive/\w%%gi;
	if ($buildos =~ /window/gi) {
		# Strip out local build path for windows logs
		$failure =~ s%[a-z]:.*_\d{6}/% %gi;
		$failure =~ s%\w:/projects/hnd.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
		$failure =~ s%/projects/hnd.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
	}
	# Add any prefix patterns that can iteratively be stripped off
	# Strip out build root with build iteration number
	$failure =~ s%/projects/hnd.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
	# For local drive build paths
	$failure =~ s%/tmp/wlanswbuild/.*/ws_.*?/%%gi;
	$failure =~ s%/tmp/wlanswbuild/.*/${brand_found}_\d{6}_\d{1,2}/%%gi;
	# For precommit logs (linux targets)
	$failure =~ s%/projects/wl_preco.*?/src/%src/%gi;
	# For precommit logs (windows targets)
	$failure =~ s%\w:/wl_preco.*?/src/%src/%gi;
	# For precommit logs (windows targets)
	$failure =~ s%\w:/temp/preco_.*?/ws_.*?/%%gi;
	# For continuous integration logs
	# Windows logs, separate line if drive or dfs  mounting changes
	$failure =~ s%\w:/projects/hnd_swci.*?/ws*\d+/%%gi;
	# Unix logs
	$failure =~ s%/projects/hnd_swci.*?/ws*\d+/%%gi;
	# Step target log references if any
	$failure =~ s%/ec_workspace/.*\d+/%%gi;
	if ($buildos =~ /macos/gi) {
		# Strip out macos local build path
		$failure =~ s%/private/tmp/.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
		$failure =~ s%/tmp/.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
	}
	if ($buildos =~ /netbsd/gi) {
		# Strip out netbsd local build path
		$failure =~ s%/a/fs-.*?/vol/.*?/\d{4}\.\d{1,2}\.\d{1,2}\.\d{1,2}/%%gi;
	}
	# Look inside each failure for additional cleanup line-by-line
	# Remove duplicate lines (from run-away error patterns)
	my @lines = grep {!$processed_line{$_}++} split(/\r\n|\n/ms, $failure);
	return("$failure") if ($#lines < 1);

	foreach my $line (@lines) {
		my($file);
		my(@ndirs);

		Dbg("Processing line = $line");
		next if ($line =~ /Ignored Error:/i);
		# Temporary workaround until we get fix from Microsoft for
		# chkinf.bat script
		next if ($line =~ /ERROR: .*netvwifi/i);
		# TODO: Combine all these reg-exp into one, once all scenarios
		# TODO: are identified
		next if ($line =~ /^\s*$/);
		# Ignore compiler lines
		next if ($line =~ /gcc\s+/);
		next if (($line =~ /gcc-.*?\s+/) && ($line !~ /: no input files/));
		next if ($line =~ /com.apple.compilers.gcc/);
		next if (($line =~ /\bcl\.exe\s+/) && ($line !~ / : Command line error /));
		next if (($line =~ /\bcl\s+/) && ($line !~ / : Command line error /));
		next if ($line =~ /^cc\s+/);
		next if ($line =~ /-ld\s+/);
		next if ($line =~ /: Leaving directory |: Entering directory /);
		next if ($line =~ /--- Building: /);
		next if ($line =~ /: Nothing to be done for/);
		next if ($line =~ /Target \`.*\' not remade because of errors./);
		next if ($line =~ /^CFLAGS: /);
		next if ($line =~ /Compiling\s+-\s+/); # From DDK and WDK
		next if ($line =~ /c:.tools.msdev.*\.lib\s*$/i); # From DDK and WDK
		next if ($line =~ /CC\s+\[M\]\s+.*\.o/); # linux make modules
		# For brands that ignore errors, skip info lines that show
		# non error info
		if (grep {/^$brand_found$/} @SPECIAL_BRANDS) {
			next if ($line =~ /^\s*Compiling \w+\.c/i);
		}

		# For certain errors, remove non-relevant info to collapse
		# similar looking errors
		$line =~ s%/tmp/(\w+)\.s:%/tmp/xxxxxxxx.s:%g if ($line =~ /: fatal error:.*No space left/i);

		# next if ($line !~ /:/); # Too greedy!
		$line =~ s/make\[(\d+)\]:/make\[x\]:/g; # Ignore make-levels in combining errors

		Dbg("Filtering filenames = $line");
		# /projects/xxxxxx/../../../../wl/sys/wlc.h:1007: error:
		# above line changes to
		# src/wl/sys/wlc.h:1007: error:
		if ($line =~ /(src[^ :()"'\]]*)/) {
			$file = "$1";
			$file =~ s/src[\/]$//g;
			Dbg("Rule01: file = $file");
		} elsif ($line =~ /\/(\S+\.o)\(.*\):/i) {
			$file = "$1";
			$file =~ s/\.o/\.c/i;
			Dbg("Rule02: file = $file");
		} elsif (($line =~ /\.o.*\.c/i) && ($line =~ /:(\w+\.c):/i)) {
			# wlc_phy_shim.o(.text+0x429):wlc_phy_shim.c: undefined ...
			$file = "$1";
			Dbg("Rule03: file = $file");
		} elsif ($line =~ /(^\S+\.c):/i) {
			$file = "$1";
			Dbg("Rule04: file = $file");
		} elsif (($line =~ /: error /) && ($line =~ /\((\w+\.o.*?)\)/i)) {
			# BcmWlLocal.lib(wlc_phy_shim.obj) : error  (efi builds)
			$file = "$1";
			$file =~ s/\.o.*$/\.c/g; # partial file substring
			Dbg("Rule05: file = $file");
		} elsif (($line =~ / : error /) && ($line =~ /\b(\w+\.o.*?) : /i)) {
			# WinMobile errors
			# BUILD: [01:0000018047:ERRORE] wl_ndis.obj : error LNK2019: unresolved external
			# WinXP errors
			# wlc_phy_shim.obj : error LNK2019: unresolved
			$file = "$1";
			$file =~ s/\.o.*$/\.c/g; # partial file substring
			Dbg("Rule06: file = $file");
		} elsif (($line =~ / : error /) && ($line =~ /[\/]{0,1}(\w+\.c)\(\d+\)\s+: /i)) {
			#  ../../../wl/sys/wlc_ap.c(1653) : error C2220:
			#  OR wlu.c(19436) : error C2143: syntax error :
			$file = "$1";
			Dbg("Rule07: file = $file");
		} elsif (($line =~ /: error:/) && ($line =~ /([^:]*):\d+:/)) {
			# linux gcc compiler produces following erro
			# ../../cnClient/clie_tools.h:21: error:
			$file = "$1";
			$file = basename($file);
			Dbg("Rule08: file = $file");
		} elsif ($line =~ /^\s*"([^"]*)",\s+line\s+\d+:\s+(Warning:|Error:)\s+/) {
			# Nucleus ARM compiler produces following error
			# "../../dhd/sys/dhd.h", line 207: Warning:  #231-D:...
			# "../../dhd/sys/dhd_osl_ext.c", line 534: Error:
			$file = "$1";
			Dbg("Rule09: file = $file");
		} elsif ($line =~ /\*\*\*\s+No\s+rule\s+to\s+make\s+target\s+`([^']*)',\s+needed\s+by/) {
			# Missing files or new additions
			# 1. Error patterns by local builds or unix compilers
			#    'No rule to make target `qos.o', needed by',
			# 2. Error patterns by vpath builds or windows compilers
			#    'No rule to make target
			#    `obj/bcmsddhdbtamp/500/ARM/checked/wlc_apcs.obj',
			#    needed by `obj/bcmsddhdbtamp/500/ARM/checked'
			$file = "$1";
			$file = basename($file);
			$file =~ s/\.obj$/\.c/gi; # .obj to .c translation
			$file =~ s/\.o$/\.c/g;    # .o to .c translation
			Dbg("Rule10: file = $file");
		} elsif ($line =~ /Error:\s+L\d+.*:\s+Undefined symbol.*referred\s+from\s+(.*?)\b\s*\)/) {
			# Nucleus ARM compiler produces following error
			# Error: L6218E: Undefined symbol xxx (referred from y.o
			$file = "$1";
			$file =~ s/\.o$/\.c/g; # partial file substring
			Dbg("Rule11: file = $file");
		} elsif ($line =~ /make\[\d+\]: \*\*\* \[([^]]*)\] Error \d+\s*$/) {
			# gmake[1]: *** [obj/.../wlu_server_shared.o] Error 1
			$file = "$1";
			$file =~ s%\\%/%g;
			$file = basename($file);
			$file =~ s/\.obj$/\.c/gi; # .obj to .c translation
			$file =~ s/\.o$/\.c/g;    # .o to .c translation
			Dbg("Rule12: file = $file");
	 	};
		Dbg("Processed line after all rule-sets: $line");

		# For certain infra related failures (INFRA_PATTERNS)
		# Do not extract file or module name
		if ($file && ($failure !~ /$INFRA_PATTERNS/i)) {
			Dbg("Found file $file");
			my $foundfile = $file;
			# Derive file's abs path w.r.t src folder
			my @filedirs  = split(/\//, $file);
			# Walk directory/file components to search for ".."
			foreach my $dir (@filedirs) {
				if ($dir =~ /\.\./) {
					pop(@ndirs);
				} else {
					push(@ndirs,$dir);
				}
			}
			Dbg("ndirs = @ndirs");
			$file = join('/', @ndirs) if (@ndirs);
			$file = simplify_error("$file");
			# Replace found filename with relative paths to abs
			# path file
			$line =~ s/$foundfile/$file/g;
			push(@cifindfiles, $file) if ($file !~ /^\s*src\s*$/);
			# If compiler puts some form of source file path,
			# extract just the filename from it
			if ((! -f "$file") || ($file =~ /\/obj.*/)) {
				if ($file =~ m/\.c|\.h|\.cpp|\.s/gi) {
					push(@cifindfiles, basename($file));
				}
			}
		}
		push(@abs_lines, $line);
	}
	$failure = join("\n",@abs_lines);
	
	Dbg("Final processed failure: $failure");
	return("$failure");

} # simplify_error()

# Find last folder where the current error occured
sub findErrorDir {
	my $line=shift;
	my $found_dir;

	while ($buildlog[$line] !~ /Entering directory `([^']*)/) {
		$line--;
		last if ($line <= 0);
	}
	($found_dir) = ($buildlog[$line] =~ /Entering directory `([^']*)/);

	return($found_dir);

} # findErrorDir

# From @buildlog create blocks of log text, that has error patterns
sub filterErrors {
	my $special_brand;

	$special_brand = (grep {/^$brand_found$/} @SPECIAL_BRANDS) ? 1 : 0;
	Dbg("filterErrors(ERROR_PATTERNS) = $ERROR_PATTERNS");

	for (my $i=1; $i<@buildlog; $i++) {
		my $error_block;
		my $failed_dir="";

		while ($buildlog[$i] =~ /$ERROR_PATTERNS/o) {
			my $j;
			my $linesaftertmp = ($buildlog[$i] =~ /$POSTMATCH_PATTERNS/) ?
			"$postmatch_lines" : "$linesafter";

			$failed_dir = findErrorDir($i);
			Dbg("Failed_Dir = $failed_dir");
			for ($j=$i-$linesbefore; $j<=$i+$linesaftertmp; $j++) {
				# line number can't be negative
				next unless ($j >= 0);
				# $error_block .= "[$j] " if ($verbose);
				if ($special_brand) {
					Dbg("$brand_found: processing $buildlog[$j]");
					# Very greedy binutils and shellutils
					# filtering for run-away errors from
					# builds that are marked to continue
					# despite errors
					# EXIT_PATTERNS are not filtered out
					if ($verbose || ($buildlog[$j] !~ /(\b([-]*)($BINUTILS_PATTERNS|$SHELLUTILS_PATTERNS)\b\s+)|$EXIT_PATTERNS/) || ($buildlog[$j] =~ /$ERROR_PATTERNS/o)) {
						$error_block .= "$buildlog[$j]\n";
					}
				} else {
					$error_block .= "$buildlog[$j]\n";
				}
			}
			# Start processing logfile after $linesaftertmp now
			$i = $j;
			# Try to club error sequences if they continue
			# (within next 2 lines)
			# Greedy binutils/shellutils filterinig not needed
			# for continued errors, as they are rarely seen
			for (my $k=1; $k<=2; $k++) {
				next unless (($i+$k) >= 0);
				if ($buildlog[$i+$k] =~ /$ERROR_PATTERNS/o) {
					# $error_block .= "[$i+$k] " if ($verbose);
					$error_block .= "$buildlog[$i+$k]\n";
					$i += $k;
				}
			}
		}
		next unless $error_block;
		next if ($error_block =~ /^\s*$/g);
		next if ($error_block =~ /Error \d+ \(ignored\)/);
		if ($verbose) {
			push(@build_failures, "Directory = $failed_dir\n\n$error_block");
		} else {
			push(@build_failures, $error_block);
		}
	}
} # filterErrors()

# Show who checked in last, the files that were detected above
sub findCheckins {
	my $tag = shift;
	my @build_error_files;    # src file references found in buildlog
	my %processed_cifiles;   # Unique list of files to search in cvs reports
	my $ciquery;             # Command to query cvsreport files
	my $ciresults;           # CVS query output
	my $file;                 # Found cvs filename

	foreach my $file ( grep {!$processed_cifiles{$_}++} @cifindfiles) {
		# These should have been filtered in simplify_error()
		# Take out any missed extra chars, parens etc.,
		$file =~ s/('|")$//g;
		$file =~ s/\(.*\)//g;
		# Transform nic build folders to src folders
		if ($file =~ /wdm\/build.*\//) {
			Dbg("Stripping windows nic build dir prefix for $file");
			$file = basename($file);
			# next if ($file !~ m%(\.c|\.cpp|\.s|\.h)$%i);
			# Dbg("Stripped windows nic build file $file");
		}
		next if (-d "$file"); # For now skip directories
		
		Dbg("Found build_error_file : $file");
		push(@build_error_files, $file);
	}
	
	# If any source files are detected in buildlog out, query cvsreports
	# to see who checked them in
	if (@build_error_files) {
		$ciquery  = "perl $find_checkins -n $reportnum ";
		$ciquery .= ($cutoff_time) ? " -c '$cutoff_time' " : "";
		$ciquery .= ($tag) ? " -r $tag " : "";
		if ($cvs_search) {
		   $ciquery .= join " ",map { ($_ =~ /\//) ? "-f '$_'" : "-f '/$_'" } @build_error_files;
		} else {
		   $ciquery .= join " ",map { "-f '$_'" } @build_error_files;
		}
		Dbg("build_error_files = @build_error_files");
		Dbg("ciquery = $ciquery");
		$ciresults=qx($ciquery -noheader 2> $NULL);
		$ciresults =~ s/\s+//g;
		Dbg("ciresults = ${ciresults}");
		
		if ($ciresults) {
			$ciresults=qx($ciquery 2> $NULL | col -b);
			chomp($ciresults);
			print "\n  Relevant $tag checkin activity (if any):\n";
			print "$ciresults\n";
		}
	}
} # findCheckins

# Main routine (Entry point)
sub Main {
	my $errorno = 1;
	my $buildlog_size;

	processArgs;

	if ($cvs_search) {
	   $find_checkins = $find_cvs_checkins;
	} else {
	   $find_checkins = $find_svn_checkins;
	}

	Usage if ($help);

	if (!$buildlog || ! -f "$buildlog") {
		print "ERROR: Logfile: $buildlog missing to query\n";
		sleep 2;
		Usage;
	}

	# Compute build log size. Huge run-away logfiles may hog CPU
	# Warn for logfiles bigger than 75MB
	$buildlog_size = -s $buildlog;
	$buildlog_size = int($buildlog_size/1048576);

	$brand_found = qx(grep "^[[:space:]]*BRAND[[:space:]]*=" "$buildlog");
	chomp($brand_found);
	$brand_found =~ s/^\s*BRAND\s*=\s*//g; $brand_found =~ s/\s+//g;

	# If -tag isn't specified and buildlog contains TAG=<tag-name>
	# string use <tag-name> as default tagname when doing cvs searches
	if (!$tag) {
		$tag_found = qx(grep "^[[:space:]]*TAG[[:space:]]*=" "$buildlog");
		chomp($tag_found);
		$tag_found =~ s/^\s*TAG\s*=\s*//g; $tag_found =~ s/\s+//g;
		$tag = $tag_found;
		print "NOTE: Found $tag_found build $buildlog\n" if ($tag_found);
	}
	Dbg("Uname = $uname_found; Brand = $brand_found; Build Tag = $tag_found");

	# If tag is still unset and if it is a preco log, then parse it
	# differently. Example strings:
	# proj_branches_RUBY_TWIG_6_20_58_wl-build_002_1bb87b0
	# proj_branches_AARDVARK_BRANCH_6_30_wl-build_008_1bb87b0
	my $ws_info;
	if ( (!$tag) && ($buildlog =~ m/hwnprebd.*logs/) ) {
		# Search for SVN or GCLIENT branch info the log first
		open(PRECOLOG,"$buildlog") || die "Can't open $buildlog";
		while (<PRECOLOG>) {
			# When preco log starts with windows specific strings
			# set the search platform to windows
			if ((/^\s*CYGWIN_/i) && ($buildos =~ /unknown/)) {
				$buildos = "windows";
				# Intentionally buildos is set to windows
				# uc is used for consistency across
				$buildos = uc($buildos);
			}
			if (/checkouts.proj_branches_/) {
				$ws_info = $_;
				last;
			}
		}
		close(PRECOLOG);

		# Only if ws_info contains branches, try to derive branch name
		if ($ws_info) {
			# Split and extract svn or gclient branch info
			my ($br_info) = grep {/proj_branches/} split(/\s+|\//, $ws_info);
			$br_info =~ s/proj_branches_//g;

			# Split found branch info (and extra info) into tokens
			my ($tag_pfx, $br_type, @br_nums) = split(/_/,$br_info);

			# Construct found tag. First join tag-prefix and branch-type
			$tag_found="${tag_pfx}_${br_type}";

			# Append until first non-digit sparse keyword is found
			# example: proj_branches_RUBY_TWIG_6_20_58_wl-build_002_1bb87b0
			foreach (@br_nums) { last unless /\d+/; $tag_found .= "_$_"; }

			# This tag or branch name filtered is used to pass to SVN search
			$tag = $tag_found;
			print "NOTE: Found $tag_found preco $buildlog\n" if ($tag_found);
		}
	}

	# If force isn't enabled, quit processing huge logfiles
	if (($buildlog_size > 75) && (!$force)) {
		print "\n";
		print "WARN: Build log too big to process\n";
		print "WARN: Logfile: $buildlog\n";
		if ($brand_found =~ /hndrte-dongle-wl/) {
		   print "WARN:          OR ,dongle_image_release.log\n";
		}
		print "WARN: Size   : $buildlog_size MB\n";
		print "WARN: Scan for errors in $buildlog manually\n";
		print "\n";
		exit(1);
	}

	$buildos = uc($platform) if ($platform);

	# If $platform (where the buildlog was produced) is not given
	if ($buildos =~ /unknown/) {
		# Derive $buildlog from $buildlog.
		$uname_found = qx(grep "^[[:space:]]*BUILD_HOSTOS[[:space:]]*=" "$buildlog");
		chomp($uname_found);
		$uname_found =~ s/\s+//g;

		if ($uname_found =~ /cygwin/gi) {
			$buildos="windows"
		} elsif ($uname_found =~ /linux/gi) {
			$buildos="linux"
		} elsif ($uname_found =~ /darwin/gi) {
			$buildos="macos"
		} elsif ($uname_found =~ /netbsd/gi)  {
			$buildos="netbsd"
		}

		# If none found, derived it from native 'uname -s'
		if ($buildos =~ /unknown/) {
			if ($uname =~ /cygwin/gi) {
				$buildos="windows"
			} elsif ($uname =~ /linux/gi) {
				$buildos="linux"
			} elsif ($uname =~ /darwin/gi) {
				$buildos="macos"
			} elsif ($uname =~ /netbsd/gi)  {
				$buildos="netbsd"
			}
			print "NOTE: Assuming $buildlog to be a $buildos build log\n";
		} else {
			print "NOTE: Found $buildlog to be a $buildos build log\n";
		}

		$buildos = uc($buildos);
	}
	# Macos compiler spits reasons for failure after showing error string
	# or exit string
	$linesafter = $postmatch_lines if ($buildos =~ /macos/i);

	@ERROR_PATTERNS = @{$ERROR_PATTERNS{$buildos}} if (exists($ERROR_PATTERNS{$buildos}));
	@EXIT_PATTERNS = @{$EXIT_PATTERNS{$buildos}} if (exists($EXIT_PATTERNS{$buildos}));

	push(@ERROR_PATTERNS,@EXIT_PATTERNS) if ($verbose);
	$ERROR_PATTERNS = join('|', @ERROR_PATTERNS);
	$EXIT_PATTERNS  = join('|', @EXIT_PATTERNS);
	$POSTMATCH_PATTERNS  = join('|', @POSTMATCH_PATTERNS);
	
	if (!$ERROR_PATTERNS) {
		print "ERROR:\n";
		print "ERROR: No ERROR patterns found to search in $buildlog\n";
		print "ERROR: Build host/platform ($buildos) couldn't be derived\n";
		print "ERROR:\n";
		exit(1);
	}

	open(BUILDLOG, "${buildlog}") || die "Can't open buildlog '$buildlog'\n";
	@buildlog = grep !/^A\s/, <BUILDLOG>;  # Skip svn checkout verbosity.
	close(BUILDLOG);

	if ($log_times) {
	    @buildlog = map {s/^[0-9:]+\s//; $_} @buildlog;
	}

	filterErrors; # Convert @buildlog into smaller @build_failures errors
	
	# If error patterns aren't found in initial search, look for exit codes
	if (!@build_failures) {
		push(@ERROR_PATTERNS,@EXIT_PATTERNS);
		$ERROR_PATTERNS = join('|', @ERROR_PATTERNS);
		Dbg("NOTE: No error strings found. Searching erroneous exit codes");
		Dbg("ERROR_PATTERNS_NEW = $ERROR_PATTERNS");
		filterErrors;
		print "NOTE: Searching erroneous exit codes\n" if (@build_failures);
	}
	# @buildlog is very big and already processed by filterErrors. So blank it out
	@buildlog = ();

	# Cleanup log clutter for each error block found
	my $i=1;
	foreach my $failure (@build_failures) {
		# Dbg("--- START ERROR_BLOCK [$i] ---");
		# Dbg("$failure");
		# Dbg("--- END   ERROR_BLOCK [$i] ---");
		push(@simplified_errors, simplify_error("$failure"));
		$i++;
	}

	# Print final results
	foreach my $failure (grep {!$processed_error{$_}++} @simplified_errors) {
		next if ($failure =~ /^\s*$/g);
		print "\n  * ---- ERROR $errorno ----\n";
		#print "$failure\n";
		foreach (split(/\r\n|\n/,$failure)) {
			print "    $_\n";
		}
		$errorno++;
	}

	# Finally relevant checkins
	findCheckins($tag) unless ($skip_blame);
} # Main()

Main;
