#!/bin/bash

HNDCVS_REV=HNDCVS_REL_1_6_0
HNDCVS_LEGACY=HNDCVS_REL_1_4_0
hndcvs_tag=""

CVS_REV="$Revision: 1.148 $"
CVS_REV=${CVS_REV/$Revision:}
CVS_REV=${CVS_REV/%$}
CVS_DATE="$Date: 2010-11-24 00:38:03 $"
CVS_DATE=${CVS_DATE/$Date:}
CVS_DATE=${CVS_DATE/%$}


echo
echo hndcvs version: $CVS_REV $CVS_DATE GMT
echo

CVS="cvs -Q"

if [ "$HNDCVS_DBG" = "TRUE" ]; then
    verbose=TRUE
    CVS=cvs
fi

help=0;

# called for every options in the command line. 
# If help was asked, print the help string for every options
# and commands
# Used to indicate that an option was found

myhelp() 
{
    read_options=1
    if [ "$1" = "-n" ]; then
	return
    fi
    if [ "$help" != "1" ]; then
	return
    fi
    echo -e $@
}

myecho() 
{
    
#    if [ "$verbose" != "TRUE" ]; then
#	return
#    fi
    echo $@
}


#default to "make"
if [ "$MAKE" = "" ]; then
    MAKE="make"
fi

OS=`echo OSTYPE $OSTYPE | grep -o inux`

if [ "$OS" != "inux" ]; then
    make_version=`$MAKE -v | grep -m 1 -o -e [[:digit:]]\.[[:digit:]]*`
    echo make version "$make_version"
    IFS="." vers=(${make_version})
    unset IFS
    
    let major=${vers[0]} 
    let minor=${vers[1]}
    
    if [ $major -lt 3 -o $minor -lt 81 ]; then
	echo "hndcvs needs GNU make version >= 3.81"
	exit
    fi
fi


if [ "$HNDCVS_REV" != "" ]; then
    hndcvs_tag="-r $HNDCVS_REV"
fi


# Global module list. Will be checked out when extracting the BOM 
mod_list="src/tools/release/module_list.mk"

#Generic bom rules
old_bomrules="src/tools/release/bomrules.mk"
bomrules="src/hndcvs/bomrules.mk"

#Generic makerules for components
old_makerules="src/tools/release/components/makerules.mk"
makerules="src/hndcvs/makerules.mk"

# backend
hndcvs_backend="src/hndcvs/hndcvs_backend"

# indicates that we are interested in finding the head 
# of the specified tag.

head_requested=0
rel_requested=0

#use local .mk files
local=0

#don't use the global modules-list-bom.mk by default
global=0

#no date spec by default
date=""
date_req=0

br_rev=0

#brand_filetype : product (bom) or component
brand_filetype=none

#tag variables
tag_size=""
tagtype=""


# NOTE : we need to be consistent with variable naming since they are used globally 
# in this file. 
# It is useful to define tag variables including the -r in front when not empty. 
# But sometimes it is also useful to use the original name instead.
# as a convention from here on , we define :
# tag : name of tag without the -r
# rtag : -r $tag
# branch : branch name without -r
# rbranch : -r $branch

co_file()
{
    #if local, bail if file exists
    if [ "$local" = "1"  ]; then
	if test -f $2; then 
	    myecho Local file $2 exists. No checkout
	    return
	fi
    fi
    if [ $date_req -eq 1 ]; then	
	myecho cvs co -AP -D "$date" -kkv $1 $2 
	$CVS co -AP -D "$date" -kkv $1 $2 
    else
	myecho cvs co -AP -kkv $1 $2 
	$CVS co -AP -kkv $1 $2 
    fi

}


# computes brand_filetype from brand name 
# if brand end by -bom, set to product, otherwise component

check_brandtype()
{
    if [ "$brand" = "" ]; then 
	echo No brand specified ! 
	exit -1
    fi
    IFS="-"  tmpbrand=(${brand})
    unset IFS
    brand_size=${#tmpbrand[@]}
    brand_suffix=${tmpbrand[$brand_size-1]}
    if [ "$brand_suffix" = "bom" ]; then
	brand_filetype="product"
    else
	brand_filetype="component"
    fi    
}



get_hndcvs()
{
    file_tag=""

    if [ "$1" != "" -a "$1" != "HEAD" ]; then
	file_tag="-r $1"
    else
	on_tot=TRUE
    fi

    mkdir -p src/tools/release/components

    # if it is a BOM, try to extract the correct version of hndcvs
    if [ "$brand_filetype" = "product" ]; then
	if [ "$local" != "1" ]; then
	    echo "cvs co -AP $file_tag $mod_list"
	    $CVS co -AP $file_tag $mod_list
	fi
	myecho $MAKE -f $mod_list hndcvs_vers
	bomval=`grep -m 1 BOM_REL_TAG src/tools/release/module_list.mk`
	bomval=${bomval/*=}

	#is bomval a variable ?
	var=${bomval/\$\(}

	if [ "$var" != "" ]; then
	    var=${var/%\)}
	    bomval=`grep -m 1 $var src/tools/release/module_list.mk`
	    bomval=${bomval/*=}
	    echo BOM VAR = "$var"
	    echo BOM_VAL = "$bomval"  
	fi


	val=`grep HNDCVS_VERS_START  $mod_list | grep -v "#"`

	#`$MAKE -f $mod_list hndcvs_vers`

	val2=${val/*--HNDCVS_VERS_START--}
	tst=${val/*--HNDCVS_VERS_START--*/HNDCVS_VERS_START}
	val3=${val2/%--HNDCVS_VERS_STOP--*}
	res=""
	myecho val3 : $val3
	myecho test $tst

	if [ "$val3" != "" -a "$tst" = "HNDCVS_VERS_START" ]; then
	    IFS=" "
	    res=(${val3})
	    myecho val3 $val3
	    unset IFS
	fi

	if [ "$local" = "1" -o "$tst" != "HNDCVS_VERS_START" ]; then
	    # if local, do not check the BOM TAG
	    BOM_TAG=""
	else
	    BOM_TAG=$bomval
	    echo Tag in BOM file : $BOM_TAG
	fi

	if [ "$BOM_TAG" != "" ]; then
	    if [ "$branch" = "" -a "$1" != "" ]; then
		find_branch_from_tag $1
	    fi
	    cmd_branch=$branch
	    
	    find_branch_from_tag $BOM_TAG
	    
	    if [ "$cmd_branch" != "$branch" ]; then
		echo branch $cmd_branch differs from $branch
		echo Tag $1 on command line is not on the same branch as BOM $BOM_TAG file tag !
		exit -1
	    fi
	fi

	if [ "${res[0]}" = "bom" ]; then
	    if [ ${res[2]} -gt 3 ]; then
		myecho extracting hndcvs tag : $HNDCVS_REV
		$CVS co -AP $hndcvs_tag src/hndcvs
	    else 
		myecho old version : use legacy
		$CVS co -AP -r $HNDCVS_LEGACY $old_bomrules
		$CVS co -AP -r $HNDCVS_LEGACY src/hndcvs
	    fi
	elif [ "${res[0]}" = "hndcvs" ]; then
	    myecho extracting BOM specified hndcvs tag : ${res[2]}

	    if [ "${res[2]}" = "HEAD" ]; then
		hndcvs_tag=""
	    elif [ "${res[2]}" != "" ]; then
		hndcvs_tag="-r ${res[2]}" 
	    else
		hndcvs_tag=""
	    fi

	    $CVS co -AP $hndcvs_tag src/hndcvs

	else
	    myecho BOM does not contain hndcvs_vers target. Using legacy version.
	    $CVS co -AP -r $HNDCVS_LEGACY $old_bomrules
	    $CVS co -AP -r $HNDCVS_LEGACY src/hndcvs
	fi
	# always use the same makerules 
	cp $makerules $old_makerules
    # if this is a component, check if there is a locally extracted version. If so, use it.
    # otherwise, use the newest.
    elif [ "$brand_filetype" = "component" ]; then
	if test ! -f $makerules; then
	    echo $CVS co -AP  src/hndcvs
	    $CVS co -AP  src/hndcvs
	fi
	cp $makerules $old_makerules
    else
	echo brand type $brand_filetype is invalid. Please run check_brandtype first !
	exit -1
    fi

}

parse_tag()
{

    ltag=$1

    if [ "$ltag" = "" ]; then
	tagtype=TOT
	branch=""
	return
    fi

    if [ "$1" = "HEAD" ]; then
	return
    fi

    IFS="_	     " tag_array=(${ltag})
    unset IFS

    tag_size=${#tag_array[@]}

    tagtype=${tag_array[1]}
 
    myecho tag size : $tag_size

    #if already a twig or a branch, assign and return
    if [ "$tagtype" = "BRANCH" -o "$tagtype" = "TWIG" ]; then
	branch=$ltag
	return
    else
	rel_requested=1
    fi
}

find_branch_from_tag()
{
    myecho find branch $1

    ltag=$1
	
    if [ "$brand_filetype" = "component" ]; then
	file="src/tools/release/components/$brand.mk"
    elif [ "$brand_filetype" = "product" ]; then
	file="src/tools/release/$brand.mk"
    else
	echo brand type $brand_filetype is invalid. Please run check_brandtype first !
	exit -1
    fi

    if [ "$ltag" = "" ]; then
	branch=""
	return
    fi
    
    parse_tag $ltag
    #if branch was specified, verify
    if [ "$tagtype" = "BRANCH" -o "$tagtype" = "TWIG" ]; then
	if [ "$ltag" != "$branch" ]; then
	    echo Wrong branch name $branch !
	    exit -127
	fi
	return
    fi

    # is it on TOT ?
    if [ $tag_size -eq 5 ]; then
	if [ ${tag_array[4]} = 0 ]; then
	    myecho Using  $file on ToC
	    branch=""
	    return
	fi
    fi
    
    #If the tag is supposed to be on a branch or twig, infer the branch name, verify and 
    # set it if not present
    if [ $tag_size -lt 6 ]; then
	toto=${ltag/_REL_/_BRANCH_}
	test_br=${toto/%_${tag_array[$tag_size-1]}}
    else
	myecho $ltag
	toto=${ltag/_REL_/_TWIG_}
	test_br=${toto/%_${tag_array[$tag_size-1]}}
    fi

    if [ "$test_br" != "" ]; then
	    $CVS -n co -r $test_br $file  >& /dev/null
	    if [ $? = 0 ]; then
		branch="$test_br"
		rbranch="-r $test_br"
		myecho Setting branch name to $branch
		myecho Branch exist
		return	
	    else
		test_br="$test_br"_0
		$CVS -n co -r $test_br $file  >& /dev/null
		if [ $? = 0 ]; then
		    branch="$test_br"
		    rbranch="-r $test_br"
		    myecho Setting branch name to $branch
		    myecho Branch exist
		    return	
		fi
	    fi
	    echo Branch $branch does not exist !
	    exit -1
    fi
}


parse_opts() {

while test "$read_options" = "1"; do
    # read_options is set to 1 at each call to myhelp indicating an option was found
    read_options=0
if  test "$1" = "-help"; then
    help=1
    myhelp 'synopsys : hndcvs [options] <cmd> <bom or module> [TAG or BRANCH]'
    myhelp
    myhelp 'options :'

fi

if [ "$1" = "-opt" -o "$help" = "1" ]; then
    myhelp ' \t -opt "cvs options"  : options passed directly to cvs, right after the command'
    myhelp ' \t \t Could be used to pass date and revision ranges to log etc.'
     shift 2
fi

if [ "$1" = "-m" -o "$help" = "1" ]; then
    myhelp ' \t -m "list of modules"  : restrict operations to a list of specific modules inside a BOM'
    sub_target=$2
    shift 2
fi

if [ "$1" = "-m" -o "$help" = "1" ]; then
    myhelp '\t -h : get the head of the branch on which the module or bom tag resides' 
    head_requested=1
    HEAD_REQ=Y
    shift
fi

if [ "$1" = "-nocheck" -o "$help" = "1" ]; then
    myhelp -n
    nocheck=1
    shift
fi
if [ "$1" =  "-noop" -o "$help" = "1" ]; then
    myhelp -n
    noop=1
    shift
fi

if [ "$1" =  "-l" -o "$help" = "1" ]; then
    myhelp '\t -l : use locally extracted BOM or component files. Does not  need a TAG'
    myhelp '\t \t In its current form, does not update BOM and component files.' 
    local=1
    shift
fi

if [ "$1" =  "-g" -o "$help" = "1" ]; then
    myhelp '\t -g : use the global BOM modules-list-bom. Does not  need a bom file' 
    global=1
    shift
fi
if [ "$1" =  "-q" -o "$help" = "1" ]; then
    myhelp -n
    redir=0
    shift
fi

if [ "$1" =  "-n" -o "$help" = "1" ]; then
    myhelp '\t -n : for checkout only. Checkout only BOM and component files, no code' 
    myhelp '\t \t Could be used before a -l option is used, to update BOM files' 
    shift
fi

if [ "$1" =  "-k" -o "$help" = "1" ]; then
    myhelp '\t -k : for checkout only. Checkout module only if not present' 
    myhelp '\t \t Can be used to compound several BOMS in the same tree' 
    shift
fi

if [ "$1" =  "-date" -o "$help" = "1" ]; then
    myhelp '\t -date "date spec" : checks out BOM or module at the ealiest after the specified date' 
    myhelp '\t \t Ignored if a static tag is specified, or for static modules in a BOM' 
    date="$2"
    date_req=1
    shift 2
fi
if [ "$1" =  "-defs" -o "$help" = "1" ]; then
    myhelp '\t -defs "list of defines" : passes a list of definitions to bom and module files' 
    myhelp '\t \t allows to add or remove modules from a bom or specify options to modules' 
    shift 2
fi
if [ "$1" = "-of" -o "$help" = "1" ]; then
    myhelp '\t -of : output file for operations like diff and cvs reports'
    output_file=$2
    shift 2
fi

if test "$1" = "-new_make"; then
    myhelp
    MAKE=$2
    newmake=1
    shift 2
fi
if [ "$help" = "1" ]; then
    myhelp
    myhelp 'commands :'
fi
if [ "$1" =  "-fd" -o "$help" = "1" ]; then
    myhelp '\t -fd "list of directories" : prints which module includes a given directory'
   shift 2
fi
if [ "$1" =  "-ff" -o "$help" = "1" ]; then
    myhelp '\t -fd "list of files" : prints which module includes a given file'
   shift 2
fi
if [ "$1" =  "-md" -o "$help" = "1" ]; then
    myhelp '\t -md "list of directories...TAG" : prints which module includes a given directory with a given TAG'
   shift 2
fi
if [ "$1" =  "-mf" -o "$help" = "1" ]; then
    myhelp '\t -mf "list of files...TAG" : prints which module includes a given file with a given TAG'
   shift 2
fi
if [ "$1" =  "-rlog" ]; then
    shift 1
fi
if [ "$1" =  "-logf" -o "$help" = "1" ]; then
    myhelp '\t -logf "list of files" : find which module includes a given file and print its logs'
    myhelp '\t \t Can use -opt to define revision and date ranges'
   shift 2
fi 
if [ "$1" =  "-logd" -o "$help" = "1" ]; then
    myhelp '\t -logd "list of files" : find which module includes a given directory and print its logs'
    myhelp '\t \t Can use -opt to define revision and date ranges'
   shift 2
fi 
if test "$1" = "-rpt"; then
    myhelp
    shift 2
fi
if [ "$help" = "1" ]; then
    myhelp '\t (none) <bom or module> TAG : if no command is specified, checkout of bom or module'
    myhelp '\t \t if no TAG is specified, checkout TOT'
    myhelp '\t \t Note that checking out a TOT bom might not result in TOT code'

    myhelp '\t -r <bom or module> <TAG1> [TAG2] : release with a static tag'
    myhelp '\t \t If only one tag is specified, finds the branch on which the tag resides and apply the tag on its top.'
    myhelp '\t \t If two tags are specified, use TAG2 to tag TAG1.'
    myhelp '\t \t If the tag already exists, do nothing'.
    myhelp '\t \t If tagging a BOM, the tag must match the BOM_REL_TAG on top of the inventory module_list.mk.'
    myhelp '\t \t This command must be run from an empty directory (no src/)'

    myhelp '\t -b <module> <TAG1> <BRANCH TAG> : branch module at tag TAG1 with BRANCH TAG'
    myhelp '\t \t This command must be run from an empty directory (no src/)'
    myhelp '\t \t Works only on individual modules'

    myhelp '\t -log : prints the logs for a module or bom'
    myhelp '\t \t not yet implemented. Should come with a spec to define revision and date ranges'

    myhelp '\t -find-boms : matches a module and its tag with the list of boms in bomed_list.txt'
    myhelp '\t \t prints the inventories and boms using that module with the specified tag'
    myhelp '\t -dh: Find all diff from a tagged BOM (diff from release to head)'
    myhelp '\t -dr: Diff two releases of a bom. Crawls component changes'
    myhelp '\t -dd: Diff two tags with a development BOM. Mix of DEV and REL components'
    myhelp '\t -rlog -dr: Diff two release tags and produce raw cvs log output'
    myhelp
    myhelp '\t For hndcvs examples refer to: '
    myhelp '\t http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/HndCVSHowto'

    exit
fi
done


myecho operation = $1 no check = $nocheck,  no op = $noop, sub target = $sub_target, new make = $MAKE

MAKE_CMD=$MAKE

#test if we have an explicit command or use the implicit default "checkout"
#TODO : it should more simple to detect the "-" sign here instead of checking every 
#single options !

op=$1

if [ "${op:0:1}" = "-" ]; then
    shift
else
    op=co
fi

nargs=$#

#from here, the first arg must be the brand (if not global) then the tags
  
if [  $global = 0 ]; then
    brand=$1
    tag1=$2
    tag2=$3
else
    brand="modules-list-bom"
    tag1=$1
    tag2=$2
    nargs=$(($# + 1))
fi 

# always figure the brand type first
check_brandtype

# if -r, check if we want a branch tag or a release tag

if test "$op" = "-r"; then
    parse_tag $tag1
fi

if [ "$HNDCVS_TMP_DIR" != "" ]; then
    if [ "$op" = "-r" -a "$rel_requested" = "1" ]; then
	cd $HNDCVS_TMP_DIR
	rm -rf *
    elif [ "$op" = "-r" -a  "$local" != "1" ]; then
	cd $HNDCVS_TMP_DIR	
    elif [ "$op" = "-v" -a "$local" != "1" ]; then
	cd $HNDCVS_TMP_DIR
    elif [ "$op" = "-find-boms" ]; then
	cd $HNDCVS_TMP_DIR
    fi
fi

# basic checks 
if [ "$op" = "-r" -a "$rel_requested" = "1" ]; then
    if [ $local = 1 ]; then
	echo cannot use a pre-checkout for tagging! please remove -l option.
	exit -1
    fi
    if test -d src  ; then
	if [ "$brand_filetype" = "product" ]; then
	    echo src sub-directory exist! Please use an empty directory for tagging a Product.
	    exit -1
	fi
    fi
elif test "$op" = "-b"; then
    if [ $local = 1 ]; then
	echo cannot use a pre-checkout for branching!  please remove -l option.
	exit -1
    fi 
fi

# if tagging, use head since the TAG might not exist

if [ $head_requested = 1 -o "$op" = "-r" ]; then
    find_branch_from_tag $tag1
    get_hndcvs $branch
else
   get_hndcvs $tag1
fi
}

diff_type=""
read_options=1

params_pos=0

parse_opts "$@"

#check that there is no CVS directory around 

if test -d CVS -a "$1" != "-help" ; then 
    echo hndcvs cannot be run from inside a CVS controlled directory !!
    exit -1
fi

# For logging usage command line as part of the BOM under Subversion options investigation.
`/usr/bin/dirname $0`/hndcvs_logcmdline.sh "$*" &

# exec backend so the error code propagates
myecho $hndcvs_backend $@
exec $hndcvs_backend "$@"
