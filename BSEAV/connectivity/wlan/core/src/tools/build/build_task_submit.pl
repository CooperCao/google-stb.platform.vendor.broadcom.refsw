#!/usr/local/bin/perl
#
# Script to submit all build related jobs to lsf farm directly instead
# of using 'rsh' to xlinux systems. This will be used by all build and
# notification tasks in hwnbuild cronjobs
#
# Author: Prakash Dhavali
# Contact: hnd-software-scm-list
#
# $Id$
#

use strict;

$ENV{PATH}   = "/bin:/usr/bin:/usr/local/bin:/tools/bin:/sbin:/usr/sbin:$ENV{PATH}";

my $null     = "/dev/null";
my $bldadmin = "hnd-software-scm-list";
my $queue    = "sj-wlanswbuild"; # Default queue
my $lsfres   = "rhel";           # Default resource
my @now      = localtime(time());
my $nowtime  = sprintf("%d%.2d%.2d_%.2d%.2d%.2d",$now[5]+1900,$now[4]+1,$now[3],$now[2],$now[1],$now[0]);
my @jobids   = ();
my @thistask = ();
my @lsf_task = ();
my @ARGV_CMD = ();

my ($lsfout, $lsfjobstatus, %jobstatus, $lsf_queue, $lsf_resource);
my ($id, $arg, $random, $logdir, $tmpfile, $bsub, $bjobs, $bhosts);
my ($lsf_task_cmd, $mailer, $lsfec);
my (@valid_lsf_queues);
my (@valid_lsf_resources);

# mimicking missing mktemp() on non-linux platforms
$random   = join('', map { chr($_+97) } split //,sprintf("%04d",rand(10000)));
# logs generated by this script's run are logged here
$logdir   = "/home/$ENV{LOGNAME}/tmp/lsf";
# logfile name
$tmpfile  = "${logdir}/lsf_${nowtime}_${random}.out";
# this task launcher is used across different operating systems
$mailer   = ( -f "/usr/ucb/mail" ) ? "/usr/ucb/mail" : "mail";

# List of valid lsf queues
@valid_lsf_queues    = ('sj-hnd','sj-Ihnd','sj-cron','sj-rerun','sj-wlanswbuild');
# List of valid resources within them
@valid_lsf_resources = ('r32bit','r64bit','rhel','rhel40','rhel50');

@ARGV_CMD = @ARGV;

if ( $#ARGV_CMD < 0 ) {
	print "ERROR: TaskSubmit (Empty lsf task). No args presented\n\n";
	print "Usage: $0 \\\n";
	print "	-lsf_queue <queue> \\\n";
	print "	[-lsf_resource (r32bit|r64bit)] \\\n";
	print "	<your-lsf-task>\n\n";
	print "Exiting\n";
	exit(1);
}

# override lsf queue and resource if supplied on cmd line
while ( $ARGV[0] ) {
   $arg = shift @ARGV;
   if ($arg =~ /^-lsf_queue/ ) {
      $lsf_queue = shift @ARGV;
      next;
   } elsif ($arg =~ /^-lsf_resource/ ) {
      $lsf_resource = shift @ARGV;
      next;
   }
   push(@lsf_task,"$arg");
   $lsf_task_cmd = join(' ',@lsf_task);
} # while

# Show info or error messages with timestamps
sub printlog {
    my ($msg) = shift;
    my (@now,$nowtime);

    @now     = localtime(time());
    $nowtime = sprintf("%.2d:%.2d:%.2d",$now[2],$now[1],$now[0]);

    print "[$nowtime] : $msg\n";
}

# Alert build-admin user on warn or error conditions
sub send_alert {
    my $msg  = shift;
    my $body = shift;
    my $node = qx(uname -n); chomp($node);

    $msg .= " ["; $msg .= `date '+%a %Y/%m/%d %H:%M:%S'`; chomp($msg); $msg .= "]";
    $msg .= " [$ENV{LOGNAME} on $node]";
    printlog("Alerting $bldadmin with message: $mailer '$msg'");
    system("echo -e '$0: \"$lsf_task_cmd\"\n\n$body' | $mailer -s \"$msg\" $bldadmin");
}

# Validate lsf queue
if ( $lsf_queue ) {
   if ( grep { /^$lsf_queue$/ } @valid_lsf_queues ) {
      $queue  = $lsf_queue;
   } else {
      printlog("ERROR: Invalid LSF QUEUE '$lsf_queue' specified");
      printlog("ERROR: Task Command: @ARGV_CMD");
      printlog("ERROR: Pick one of '@valid_lsf_queues' as lsf queue\n");
      send_alert("ERROR: TaskSubmit (Invalid lsf queue: $lsf_queue)");
      exit(1);
   }
} # lsf_queue

# Validate lsf resource
if ( $lsf_resource ) {
   if ( grep { /^$lsf_resource$/ } @valid_lsf_resources ) {
      $lsfres  = $lsf_resource;
   } else {
      printlog("ERROR: Invalid LSF RESOURCE '$lsf_resource' specified");
      printlog("ERROR: Task Command: @ARGV_CMD");
      printlog("ERROR: Pick one of '@valid_lsf_resources' as lsf resource\n");
      send_alert("ERROR: TaskSubmit (Invalid lsf resource: $lsf_resource)");
      exit(1);
   }
} # lsf_resource

$bsub     = "/tools/bin/bsub -q $queue -R $lsfres -o $tmpfile";
$bjobs    = "/tools/bin/bjobs";
$bhosts   = "/tools/bin/bhosts";

send_alert("ERROR: TaskSubmit (Empty lsf task on $queue/$lsfres)") if (( $#lsf_task < 0 ) && ($ENV{LOGNAME} eq "hwnbuild"));
exit(1) if ( $#lsf_task < 0 );

# Quote lsf command line parameters
@thistask  = map { /^[^"'].*\s+/ ? "'$_'" : "$_" } @lsf_task;
# exit(1) if ( grep { $_ !~ m%src/tools/build/%gi } join(//,@thistask) );
mkdir("$logdir") if ( ! -d "$logdir" );

print "================================================\n";
printlog("START '$bsub @thistask'");
printlog("Submitted Task Details Log: $tmpfile");

# Finally submit to requested queue
$lsfout = `$bsub @thistask 2>&1`;
$lsfec  = $?;
chomp($lsfout);

foreach my $out ( split(/\n/,$lsfout) ) {
   next if ( $out !~ /Job\s+<(\d+)>\s+is\s+submitted\s+to\s+queue/ );
   push(@jobids,$1);
}

printlog("Wrapper lsfout '$lsfout' (ec=$lsfec; ids=@jobids)");

foreach my $id ( @jobids ) {
  for ( my $i=0; $i < 20; $i++ ) {
     $lsfjobstatus=`$bjobs $id 2>&1`;
     if ( $lsfjobstatus =~ m/${id}.*(RUN|EXIT|DONE)\s+/msg ) {
        $jobstatus{$id}=$1;
        printlog("[$i] Wrapper Job $id started (current status=$1)");
        ## Allow few seconds for bsub to completely create/flush tmpfile
        sleep 15; last;
     } elsif ( $lsfjobstatus =~ m/${id}.*(PEND|..USP)\s+/msg ) {
        $jobstatus{$id}=$1;
        printlog("[$i] Waiting for wrapper job $id (current status=$1)");
        sleep 30;
     } else {
        printlog("[$i] Waiting for wrapper job $id (current status=UNKNOWN)");
        sleep 30;
     }
  }
}

foreach my $id ( @jobids ) {
  if ( $jobstatus{$id} !~ /RUN|EXIT|DONE/ ) {
     my $warn_alert;
     my $warn_msg;
     my $queuestatus;

     my @current  = localtime(time());
     my $curtime  = sprintf("%d%.2d%.2d_%.2d%.2d%.2d",$current[5]+1900,$current[4]+1,$current[3],$current[2],$current[1],$current[0]);
     my $queuename   = $queue;

     # Assumes <site>-<queue-name> convention to extract queuename from
     # given queue
     $queuename   =~ s/([^-]*-)//g;
     $queuestatus = qx($bhosts $queuename);

     $warn_alert = "WARNING: job $id took 10+mins to start\n";

     $warn_msg .= "Submit Time : $nowtime\n";
     $warn_msg .= "Current Time: $curtime\n";
     $warn_msg .= "Queue Status ($queue): \n$queuestatus\n";

     send_alert("$warn_alert","$warn_msg");
     printlog("WARNING job $id took 10+mins to start");
   }
}

sleep(15) if (( ! -f "$tmpfile" ) || ( -z "$tmpfile" ));
print "SUBMITTED TASK DETAILS:\n", "#" x 25, "\n", `cat $tmpfile 2>&1`, "#" x 25, "\n" ;

# unlink($tmpfile) # preserve for lsf cluster debugging

printlog("Submitted Task Details Log: $tmpfile");
printlog("END   '$bsub @thistask'");
print "================================================\n";
