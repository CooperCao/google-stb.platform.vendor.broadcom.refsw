
/****************************************************************************
 *  (c) Copyright 2006 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 * License is granted only to Wi-Fi Alliance members and designated Wi-Fi
 * contractors ("Authorized Licensees").  Authorized Licensees are hereby
 * granted the limited right to use this software solely for noncommercial
 * applications and solely for testing Wi-Fi equipment. Authorized Licensees
 * may embed this software into their proprietary equipment and distribute this
 * software with such equipment under a license with at least the same
 * restrictions as contained in this License, including, without limitation,
 * the disclaimer of warranty and limitation of liability, below.  Other than
 * expressly granted herein, this License is not transferable or sublicensable,
 * and it does not extend to and may not be used with non-Wi-Fi applications.
 *
 * Commercial derivative works of this software or applications that use the
 * Wi-Fi scripts generated by this software are NOT AUTHORIZED without specific
 * prior written permission from Wi-Fi Alliance.
 *
 * Non-Commercial derivative works of this software for internal use are
 * authorized and are limited by the same restrictions; provided, however,
 * that the Authorized Licensee shall provide Wi-Fi with a copy of such
 * derivative works under a perpetual, payment-free license to use, modify,
 * and distribute such derivative works for purposes of testing Wi-Fi equipment.
 *
 * Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 * or promote products that are derived from or that use this software without
 * specific prior written permission from Wi-Fi Alliance.
 *
 * THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE,
 * ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************
 */


/*
 * File: wfa_pctg.c - The main program for PC Traffic Generator.
 *       This is the top level of traffic Generator. It initializes a local TCP
 *       socket for command and control link and waits for a connect request
 *       from a Test Console. Once the the connection is established, it
 *       will process the commands from the Test Console.
 *
 * Revision History:
 *       2006/03/10  -- Initially created by qhu.
 *       2006/06/01  -- BETA Release by qhu
 *       2006/06/13  -- 00.02 Release by qhu
 *       2006/06/30  -- 00.10 Release by qhu
 *       2006/07/10  -- 01.00 Release by qhu
 *       2006/09/01  -- 01.05 Release by qhu
 *       2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *       2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 */
#include <signal.h>
#include <pthread.h>
#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_pctg.h"
#include "wfa_sock.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_miscs.h"
#include "wfa_agt.h"
#include "wfa_rsp.h"

/* Global flags for synchronizing the TG functions */
BOOL       gtgSend = 0;         /* flag to sync Send traffic */
BOOL       gtgRecv = 0;         /* flag to sync Recv traffic */
BOOL       gtgTransac = 0;      /* flag to sync Transaction traffic */
int        gtimeOut = 0;        /* timeout value for select call in usec */

/* Added for proper working */
int        gRegSec = 1;         /* regularly periodical timeout     */

/* Added for build errors */

int adj_latency; /* adjust sleep time due to latency */
/* Added on 29/12/07 */
#ifdef WFA_WMM_EXT


BOOL       gtgStartSync = 0;       /* flag to sync End2End Time handshaking */
BOOL       gtgFinishSync = 0;      /* flag to sync End2End Time handshaking */

tgWMM_t wmm_thr[WFA_THREADS_NUM];
extern void *wfa_wmm_thread(void* thr_param);
extern void *wfa_wmmps_thread();

tgSyncTime_t gtgStartSyncTime;  /* End2End Start Sync record  */
tgSyncTime_t gtgFinishSyncTime; /* End2End Finish Sync Record */
double min_rttime = 0xFFFFFFFF;
int e2eCnt = 0;
tgE2EStats_t *e2eStats;
#endif
/* Added on 29/12/07 */
/* Socket Handler table */
//int           tgSockfds[WFA_MAX_STREAMS]; /* for baseline, this is one */
char       gnetIf[16];        /* specify the interface to use */

int tgSockfds[WFA_MAX_TRAFFIC_STREAMS];

/* stream table */
tgStream_t *gStreams;         /* streams' buffers             */

/* the agent local Socket, Agent Control socket and baseline test socket*/
int        gagtSockfd = -1, gxcSockfd = -1, btSockfd = -1;

extern     xcCommandFuncPtr gWfaCmdFuncTbl[]; /* command process functions */
extern int wfa_estimate_timer_latency();
extern void tmout_stop_send(int);
unsigned short wfa_defined_debug = WFA_DEBUG_ERR;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR;
extern dutCmdResponse_t gGenericResp;
extern tgStream_t *findStreamProfile(int);
tgWMM_t wmm_thr[WFA_TRAFFIC_CLASS_NUM];

int
main(int argc, char **argv)
{
    int	      nfds, maxfdn1 = -1, nbytes = 0, cmdLen = 0, isExit = 1;
    int       respLen;
    WORD      locPortNo = 0;   /* local control port number                  */
    //WORD tgPortNo[MAX_TRAFFIC_STREAMS]; /* UDP traffic ports' numbers      */
    fd_set    sockSet;         /* Set of socket descriptors for select()     */
    BYTE      *xcCmdBuf=NULL, *parmsVal=NULL;
    BYTE      *trafficBuf=NULL, *respBuf=NULL;
    struct timeval *toutvalp=NULL, *tovalp; /* Timeout for select()           */
    BYTE      xcCmdTag;
    struct sockfds fds;

    #ifdef WFA_WMM_EXT
    struct timeval lrtime,lstime;
    double rttime = 0;
    int ncnt,cntThr = 0;
    int asn = 1;
    tgThrData_t tdata[WFA_THREADS_NUM];
    pthread_attr_t ptAttr;
    int ptPolicy; 
    struct sched_param ptSchedParam;
    #endif /* WFA_WMM_EXT */  
    if (argc < 3)              /* Test for correct number of arguments */
    {
        DPRINT_ERR(WFA_ERR, "Usage:  %s <command interface> <Local Control Port> \n", argv[0]);
        exit(1);
    }

    if(isString(argv[1]) == FALSE)
    {
        DPRINT_ERR(WFA_ERR, "incorrect network interface\n");
        exit(1);
    }
    strncpy(gnetIf, argv[1], 31);

    if(isNumber(argv[2]) == FALSE)
    {
        DPRINT_ERR(WFA_ERR, "incorrect port number\n");
        exit(1);
    }

    locPortNo = atoi(argv[2]);

    /* allocate the traffic stream table */
    gStreams = (tgStream_t *) malloc(WFA_MAX_WMM_STREAMS*sizeof(tgStream_t));
    if(gStreams == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc theStreams\n");
       exit(1);
    }
    trafficBuf = (BYTE *) malloc(MAX_UDP_LEN+1);  /* alloc a traffic buffer */
    if(trafficBuf == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc traffic buffer\n");
       exit(1);
    }
    
    respBuf = (BYTE *)malloc(512);
    if(respBuf == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc response buffer\n");
       exit(1);
    }

    
	
    toutvalp = malloc(sizeof(struct timeval));
    if(toutvalp == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc timeval\n");
       exit(1);
    }

    xcCmdBuf = malloc(WFA_BUFF_1K);
    if(xcCmdBuf == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc xcCmdBuf\n");
       exit(1);
    }

    
    parmsVal = malloc(MAX_PARMS_BUFF);
    if(parmsVal == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc parmsVal\n");
       exit(1);
    }

#ifdef WFA_WMM_EXT
    e2eStats = malloc(6144*sizeof(tgE2EStats_t));
    if(e2eStats == NULL)
    {
       DPRINT_ERR(WFA_ERR, " Failed to malloc e2eStats\r\n");
       exit(1);
    }
#endif
    /* 4create listening TCP socket */
    gagtSockfd = wfaCreateTCPServSock(locPortNo);
    if(gagtSockfd == -1)
    {
       DPRINT_ERR(WFA_ERR, "Failed to open socket\n");
       exit(1);
    }

   #ifdef WFA_WMM_EXT
   pthread_attr_init(&ptAttr);

   ptSchedParam.sched_priority = 10;
   pthread_attr_setschedparam(&ptAttr, &ptSchedParam);
   pthread_attr_getschedpolicy(&ptAttr, &ptPolicy);
   pthread_attr_setschedpolicy(&ptAttr, SCHED_RR);
   pthread_attr_getschedpolicy(&ptAttr, &ptPolicy);
   

   for(cntThr = 0; cntThr < WFA_THREADS_NUM; cntThr++)
   {
      tdata[cntThr].tid = cntThr;
      pthread_mutex_init(&wmm_thr[cntThr].thr_flag_mutex,NULL);
      pthread_cond_init(&wmm_thr[cntThr].thr_flag_cond,NULL);
      wmm_thr[cntThr].thr_id = pthread_create(&wmm_thr[cntThr].thr,
                   &ptAttr,wfa_wmm_thread, &tdata[cntThr]);
   }

   #endif



    maxfdn1 = gagtSockfd + 1;
    while (isExit) {
        /* set socket file descriptors. For baseline, there are only
         * three sockets required. They are an agent main socket,
         * Control Agent link socket and Traffic Generator Socket.
         */
        fds.agtfd = &gagtSockfd;
        fds.cafd = &gxcSockfd;
        fds.tgfd = &btSockfd;
        #ifdef WFA_WMM_EXT
          fds.wmmfds = tgSockfds;
        #ifdef WFA_WMM_PS_EXT
          fds.psfd = &psSockfd;
        #endif
        #endif
        wfaSetSockFiDesc(&sockSet, &maxfdn1, &fds);

        tovalp = NULL;
        if(gtimeOut != 0 )
        {
          /* timeout is set to usec */
          tovalp = wfaSetTimer(0, gtimeOut*1000, toutvalp);
        }

        nfds = 0;
	if ( (nfds = select(maxfdn1, &sockSet, NULL, NULL, tovalp)) < 0)
        {
	     if (errno == EINTR)
	  	  continue;		/* back to for() */
	     else
 		  DPRINT_WARNING(WFA_WNG, "select error: %i", errno);
	}

        if(nfds == 0)
        {
           /*
             * For transaction test, if it times out without receive a packet,
             * here it should initiate/send the next transac packet and count
             * a packet loss for the previous one
             */
            if(gtgTransac != 0 && btSockfd != -1)
            {
              memset(respBuf,0,WFA_BUFF_512);
              respLen = 0;
              #ifdef WFA_WMM_EXT
                gettimeofday(&lstime,NULL);
                int2BuffBigEndian(asn++, &((tgHeader_t *)trafficBuf)->hdr[8]);
                int2BuffBigEndian(lstime.tv_sec, &((tgHeader_t *)trafficBuf)->hdr[12]);
                int2BuffBigEndian(lstime.tv_usec, &((tgHeader_t *)trafficBuf)->hdr[16]);
              #endif /* WFA_WMM_EXT */
#ifdef DEBUG
              printf("nfds == 0, gtgTransac != 0, SendShortFile called\n");
#endif
               wfaSendShortFile(btSockfd, gtgTransac, trafficBuf, 0, respBuf, &respLen);

               if(wfaCtrlSend(gxcSockfd, respBuf, respLen) != respLen)
               {
                   DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
               }
            }/* gtgTransac && btSockfd */
           #ifdef WFA_WMM_EXT
           #ifdef WFA_WMM_PS_EXT
                if(gtgWmmPS != 0 && psSockfd != -1 )
                {
                   BUILD_APTS_MSG(APTS_HELLO, psTxtMsg);
                   wfaTrafficSendTo(psSockfd,(char *)psTxtMsg,sizeof(psTxtMsg),(struct sockaddr*)&wmmps_info.psToAddr);
                   wmmps_info.sta_state = 0;
                   wmmps_info.wait_state = WFA_WAIT_STAUT_00;
                   continue;
                }
        
         
           #endif /* WFA_WMM_PS_EXT */
           #endif /* WFA_WMM_EXT */
          }/* if nfds == 0 */

	if (FD_ISSET(gagtSockfd, &sockSet))
        {
            /* Incoming connection request */
            gxcSockfd = wfaAcceptTCPConn(gagtSockfd);
            if(gxcSockfd == -1)
            {
               DPRINT_ERR(WFA_ERR, "Failed to open control link socket\n");
               exit(1);
            }
	}

        /* Control Link port event*/
        if(gxcSockfd > 0 && FD_ISSET(gxcSockfd, &sockSet)) {
            memset(xcCmdBuf, 0, WFA_BUFF_1K);  /* reset the buffer */
            nbytes = wfaCtrlRecv(gxcSockfd, xcCmdBuf);
#if DEBUG
          {
              int i;
              printf("received %i\n", nbytes);
              for(i = 0; i< nbytes; i++)
                 printf("%x ", xcCmdBuf[i]);

              printf("\n");
          }
#endif

            if(nbytes <=0)
            {
                /* errors at the port, close it */
                shutdown(gxcSockfd, SHUT_WR);
                close(gxcSockfd);
                gxcSockfd = -1;
            }
            else
            {
               /* command received */
               wfaDecodeTLV(xcCmdBuf, nbytes, &xcCmdTag, &cmdLen, parmsVal);
               DPRINT_INFO(WFA_OUT, "command %i\n", xcCmdTag);

               memset(&gGenericResp, 0 ,sizeof(dutCmdResponse_t));

               gWfaCmdFuncTbl[xcCmdTag](cmdLen, parmsVal, &respLen, (BYTE *)respBuf);
               if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen) != respLen)
               {
                  DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
               }
            }

        }

	#ifdef WFA_WMM_EXT
		for(ncnt = 0; ncnt < WFA_MAX_WMM_STREAMS; ncnt++)
		{
		  if(tgSockfds[ncnt]>0 && FD_ISSET(tgSockfds[ncnt],&sockSet))
		  {
		     int sn;
		     struct timeval ttval, currTimeVal;
		     #ifdef WFA_DUT_SYNC
			int traffic_start_drift;
		     #endif
		     wfaRecvFile(tgSockfds[ncnt],gStreams[ncnt].id,(char *)trafficBuf);
		     sn = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[8]);
		     ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
		     ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
		     gettimeofday(&currTimeVal,NULL);                    
          #ifdef WFA_DUT_SYNC
                     if(sn >= 10 && sn < 15)
                {
                double bdftime = wfa_timeval2double(&currTimeVal) - gtgStartSyncTime.dut_time; 
                if(bdftime > 10.00)
                {
                   currTimeVal.tv_sec = ttval.tv_sec;
                   currTimeVal.tv_usec = ttval.tv_usec + gtgStartSyncTime.dtime/2 * 1000000;
                   traffic_start_drift = clock_drift_ps * bdftime;
                   currTimeVal.tv_usec += traffic_start_drift;
                   if(currTimeVal.tv_usec < 0)
                   {
                      currTimeVal.tv_sec -= 1;
                      currTimeVal.tv_usec += 1000000;
                   }
                   else if(currTimeVal.tv_usec >= 1000000)
                   {
                      currTimeVal.tv_sec += 1;
                      currTimeVal.tv_usec -= 1000000;
                   }
                   settimeofday(&currTimeVal, NULL);
                 }
                 }

            #endif /* WFA_DUT_SYNC */
          if(e2eCnt < 6000 )
	   {
              tgE2EStats_t *ep = &e2eStats[e2eCnt++];
	      ep->seqnum = sn;
              ep->rsec   = ttval.tv_sec;
              ep->rusec   = ttval.tv_usec;


              ep->lsec   = currTimeVal.tv_sec;
              ep->lusec   = currTimeVal.tv_usec;

              if(ep->lusec < 0 )
              {
                 ep->lsec -= 1;
                 ep->lusec += 1000000;
              }
              else if(ep->lusec >= 1000000)
              {
                 ep->lsec += 1;
                 ep->lusec -= 1000000;
              }
            }
       
	  }/* if loop */
        }/* for loop */
	#endif /* WFA_WMM_EXT */

        /* Test Traffic received */
#ifdef DEBUG
        printf("btSockfd = %d, gtgRecv = %d, gtgSend = %d,gtgTransac = %d\r\n",btSockfd,gtgSend,gtgRecv,gtgTransac);
#endif     
        //if(btSockfd > 0 && FD_ISSET(btSockfd, &sockSet)) 
            if(gtgRecv != 0 || gtgTransac != 0)
            {
            int n =0;
            #ifdef WFA_WMM_EXT
               struct timeval ttval;
            #endif
        //    if(gtgRecv != 0 || gtgTransac != 0)
        if(btSockfd > 0 && FD_ISSET(btSockfd, &sockSet)) 
            {
                int i = gtgRecv?gtgRecv:gtgTransac;

                n = wfaRecvFile(btSockfd, i, (char *)trafficBuf);
#ifdef DEBUG
                printf("Test traffic received: PCTG:wfaRecvFile: %d\n",n);
#endif
            }


            #ifdef WFA_WMM_EXT
                ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
                ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
            #endif

            /* If it is testing transaction, once it receives a packet
             * send a new one right away.
             */
            if(gtgTransac != 0 && n != 0)
            {
             #ifdef WFA_WMM_EXT
                gettimeofday(&lrtime,NULL);
                rttime = wfa_ftime_diff(&lstime,&lrtime);
                if(min_rttime > rttime)
                {
                   min_rttime = rttime;
                   ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
                   ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
                   if(gtgStartSync != 0)
                   {
                      gtgStartSyncTime.dtime = min_rttime;
                      gtgStartSyncTime.tm_time = wfa_timeval2double(&ttval);
                      ttval.tv_usec += min_rttime/2*1000000;
                      if(ttval.tv_usec > 1000000)
                      {
                         ttval.tv_sec += 1;
                         ttval.tv_usec -= 1000000;
                      }
                      settimeofday(&ttval,NULL);
                      gtgStartSyncTime.dut_time = wfa_timeval2double(&ttval);
                   }
                   else if(gtgFinishSync != 0 )
                   {
                      gtgFinishSyncTime.dtime = min_rttime;
                      gtgFinishSyncTime.dut_time = wfa_timeval2double(&lrtime);
                      gtgFinishSyncTime.tm_time  = wfa_timeval2double(&ttval);
                   }
                 }
                 gettimeofday(&lstime,NULL);
                 int2BuffBigEndian(lstime.tv_sec,&((tgHeader_t *)trafficBuf)->hdr[12]);
                 int2BuffBigEndian(lstime.tv_usec,&((tgHeader_t *)trafficBuf)->hdr[16]);
               #endif /* WFA_WMM_EXT */
                wfaSendShortFile(btSockfd, gtgTransac, (BYTE *)trafficBuf, n, respBuf, &respLen);
                if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen)!=respLen)
                {
                    DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                }
               #ifdef WFA_WMM_EXT
                  if(gtgStartSync != 0 || gtgFinishSync != 0)
                  {
                     usleep(5000);
                  }
               #endif /* WFA_WMM_EXT */
            }
	}

        #ifdef WFA_WMM_EXT
        #ifdef WFA_WMM_PS_EXT
           if(psSockfd > 0 && FD_ISSET(psSockfd, &sockSet))
           {
              wfaWmmPowerSaveProcess(psSockfd);
              continue;
           }
        #endif
        #endif 
        /*
         * If the profile is set for file transfer, this will run to
         * complete (blocking).
         */
        if(gtgSend != 0 && gtgTransac == 0)
        {
            tgStream_t *myStream = NULL;
            respLen = 0;
            memset(respBuf,0,WFA_BUFF_512);
            myStream = findStreamProfile(gtgSend);
/* signal Handler added */
            signal(SIGALRM,tmout_stop_send);
            alarm(myStream->profile.duration);
            wfaSendLongFile(btSockfd, gtgSend, respBuf, &respLen);
            if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen)!=respLen)
            {
                DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
            }

            DPRINT_INFO(WFA_OUT, "done with send long\n");
        }
    }

    /*
     * necessarily free all mallocs for flat memory real-time systems
     */
     free(gStreams);
     free(trafficBuf);
     free(toutvalp);
     free(respBuf);
     free(xcCmdBuf);
     free(parmsVal);
     #ifdef WFA_WMM_EXT
     free(e2eStats);
     #endif
     /* Close sockets */
    close(gagtSockfd);
    close(gxcSockfd);
    close(btSockfd);
    
     #ifdef WFA_WMM_EXT
     for(cntThr = 0; cntThr < WFA_MAX_TRAFFIC_STREAMS; cntThr++)
     {
        if(tgSockfds[cntThr] != -1)
        {
           close(tgSockfds[cntThr]);
           tgSockfds[cntThr] = -1;
        }
     }
     #ifdef WFA_WMM_PS_EXT
       close(psSockfd);
     #endif 
     #endif /* WFA_WMM_EXT */
    return 0;
}
