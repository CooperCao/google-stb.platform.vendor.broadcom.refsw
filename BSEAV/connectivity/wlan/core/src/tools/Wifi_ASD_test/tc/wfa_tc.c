
/****************************************************************************
 *  (c) Copyright 2006 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 * License is granted only to Wi-Fi Alliance members and designated Wi-Fi
 * contractors ("Authorized Licensees").  Authorized Licensees are hereby
 * granted the limited right to use this software solely for noncommercial
 * applications and solely for testing Wi-Fi equipment. Authorized Licensees
 * may embed this software into their proprietary equipment and distribute this
 * software with such equipment under a license with at least the same
 * restrictions as contained in this License, including, without limitation,
 * the disclaimer of warranty and limitation of liability, below.  Other than
 * expressly granted herein, this License is not transferable or sublicensable,
 * and it does not extend to and may not be used with non-Wi-Fi applications.
 *
 * Commercial derivative works of this software or applications that use the
 * Wi-Fi scripts generated by this software are NOT AUTHORIZED without specific
 * prior written permission from Wi-Fi Alliance.
 *
 * Non-Commercial derivative works of this software for internal use are
 * authorized and are limited by the same restrictions; provided, however,
 * that the Authorized Licensee shall provide Wi-Fi with a copy of such
 * derivative works under a perpetual, payment-free license to use, modify,
 * and distribute such derivative works for purposes of testing Wi-Fi equipment.
 *
 * Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 * or promote products that are derived from or that use this software without
 * specific prior written permission from Wi-Fi Alliance.
 *
 * THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE,
 * ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************
 */

/*
 * File: wfa_tc.c
 *       This is the main program for Test Console.
 *
 * Revision History:
 *   2006/06/01 -- BETA Release by qhu
 *   2006/06/13 -- 00.02 Release by qhu
 *   2006/06/30 -- 00.10 Release by qhu
 *   2006/07/10 -- 01.00 Release by qhu
 *   2006/09/01 -- 01.05 Release by qhu
 *   2007/03/30 -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *   2007/04/40 -- 02.00 WPA2 and Official WMM Release by qhu
 */
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_sock.h"
#include "wfa_ca.h"
#include "wfa_agtctrl.h"

extern int xcCmdProcGetVersion(unsigned char *parms);
extern dutCommandRespFuncPtr wfaCmdRespProcFuncTbl[];
extern void buildDutCommandRespProcessTable(void);
extern typeNameStr_t nameStr[];
int tgSockfds[WFA_MAX_TRAFFIC_STREAMS];

int gSock = -1, tmsockfd, gCaSockfd = -1, xcSockfd, btSockfd;
int gtgSend;
int gtgRecv;
int gtgTransac;
char gnetIf[32] = "any";
tgStream_t    *theStreams;
long          itimeout = 0;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR;

/*
 * the output format can be redefined for file output.
 */

int main(int argc, char *argv[])
{
    int nfds, done;
    struct sockaddr_in servAddr;
    unsigned short servPort, myport;
    char *servIP=NULL, *tstr=NULL;
    int bytesRcvd;
    fd_set sockSet;
    char cmdName[32];
    int i, isFound = 0, nbytes, tag, ret_status, slen;
    int tmsockfd, cmdLen;
    int maxfdn1;
    BYTE xcCmdBuf[1024];
    BYTE caCmdBuf[1024];
    BYTE  pcmdBuf[1024];
    char *pcmdStr;
    char respStr[128];
    if(argc < 3)
    {
        DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port>\n", argv[0]);
        exit(1);
    }

    myport = atoi(argv[2]);

    //strcpy(gnetIf, argv[1]);

    if((tstr = getenv("WFA_ENV_PCTG_IPADDR")) == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_PCTG_IPADDR not set\n");
       exit(1);
    }

    if(isIpV4Addr(tstr)== FALSE)
       return FALSE;

    servIP= tstr;

    if((tstr = getenv("WFA_ENV_PCTG_PORT")) == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_PCTG_PORT not set\n");
       exit(1);
    }

    if(isNumber(tstr)== FALSE)
       return FALSE;

    servPort = atoi(tstr);

    tmsockfd = wfaCreateTCPServSock(myport);

    maxfdn1 = tmsockfd + 1;

    FD_ZERO(&sockSet);

         if(gSock == -1)
           {
               if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
               {
                   DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
                   exit(1);
               }

               memset(&servAddr, 0, sizeof(servAddr));
               servAddr.sin_family      = AF_INET;
               servAddr.sin_addr.s_addr = inet_addr(servIP);
               servAddr.sin_port        = htons(servPort);

               if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
               {
                   DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
                   exit(1);
               }

           }

    for(;;)
    {
       FD_ZERO(&sockSet);
       FD_SET(tmsockfd, &sockSet);
       maxfdn1 = tmsockfd +1;
       if(gCaSockfd != -1)
       {
         FD_SET(gCaSockfd, &sockSet);
         if(maxfdn1 < gCaSockfd)
             maxfdn1 = gCaSockfd +1;
       }

       if(gSock != -1)
       {
         FD_SET(gSock, &sockSet);
         if(maxfdn1 < gSock)
             maxfdn1 = gSock +1;
       }
       if((nfds = select(maxfdn1, &sockSet, NULL, NULL, NULL)) < 0)
       {
           if(errno == EINTR)
               continue;
           else
               DPRINT_WARNING(WFA_WNG, "select error %i", errno);
       }

       if(FD_ISSET(tmsockfd, &sockSet))
       {
           gCaSockfd = wfaAcceptTCPConn(tmsockfd);
           DPRINT_INFO(WFA_OUT, "accept new connection\n");
           continue;
       }

       if(gCaSockfd > 0 && FD_ISSET(gCaSockfd, &sockSet))
       {
           memset(xcCmdBuf, 0, 1024);

           nbytes = wfaCtrlRecv(gCaSockfd, xcCmdBuf);
           DPRINT_INFO(WFA_OUT, "message %s %i\n", xcCmdBuf, nbytes);
           slen = (int )strlen((char *)xcCmdBuf);
       
           DPRINT_INFO(WFA_OUT, "last %x last-1  %x last-2 %x last-3 %x\n", cmdName[slen], cmdName[slen-1], cmdName[slen-2], cmdName[slen-3]);

           xcCmdBuf[slen-3] = '\0';

           if(nbytes <=0)
           {
              shutdown(gCaSockfd, SHUT_WR);
              close(gCaSockfd);
              gCaSockfd = -1;
              continue;
           }

         if(gSock == -1)
           {
               if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
               {
                   DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
                   exit(1);
               }

               memset(&servAddr, 0, sizeof(servAddr));
               servAddr.sin_family      = AF_INET;
               servAddr.sin_addr.s_addr = inet_addr(servIP);
               servAddr.sin_port        = htons(servPort);

               if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
               {
                   DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
                   exit(1);
               }
           }
      
           isFound = 0;

           memcpy(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);
           i = 0;
           
           while(nameStr[i].type != -1)
           {
              if(strcmp(nameStr[i].name, cmdName) == 0)
              {
                 switch(nameStr[i].type)
                 {
                    /*
                     * For PC WTG, only the following commands are
                     * supported.
                     */
                    case WFA_TRAFFIC_SEND_PING_TLV:
                    case WFA_TRAFFIC_STOP_PING_TLV:
                    case WFA_TRAFFIC_AGENT_CONFIG_TLV:
                    case WFA_TRAFFIC_AGENT_SEND_TLV:
                    case WFA_TRAFFIC_AGENT_RESET_TLV:
                    case WFA_TRAFFIC_AGENT_RECV_START_TLV:
                    case WFA_TRAFFIC_AGENT_RECV_STOP_TLV:
                    isFound = 1;
                    break;
                    default:
                    DPRINT_ERR(WFA_ERR, "The message type is not supported for PC WTG\n");
                 }

                 break;
              }
              i++;
           }

           DPRINT_INFO(WFA_OUT, "%s\n", cmdName);

           if(isFound == 0)
           {
               DPRINT_WARNING(WFA_WNG, "Command not valid, check the name\n");
               continue;
           }

           if(nameStr[i].cmdProcFunc(pcmdStr, pcmdBuf, &cmdLen)==FALSE)
           {
              DPRINT_WARNING(WFA_WNG, "Incorrect command syntax\n");
              continue;
           }

           /*
            * send to DUT.
            */
           if(send(gSock, pcmdBuf, cmdLen, 0) != cmdLen)
           {
               DPRINT_WARNING(WFA_WNG, "Incorrect sending ...\n");
               continue;
           }
           /*
            * send back to command line or TM.
            */
           sprintf(respStr, "status,RUNNING\r\n");
           wfaCtrlSend(gCaSockfd, (BYTE *)respStr, 16);
       } /* gCaSockfd */
          done = 1;
          
          //done for testing
           while(done)
           {
	       sleep(1); /* Modified as per BRCM 1.3 ASD */

               memset(respStr, 0, 128);
               memset(caCmdBuf, 0, 1024);
	       strcpy(caCmdBuf,"");
               if ((bytesRcvd = recv(gSock, caCmdBuf, 1024, 0)) <= 0)
               {
                   DPRINT_WARNING(WFA_WNG, "recv() failed or connection closed prematurely");
                   done = 0;
               }
#if DEBUG
               for(i = 0; i< bytesRcvd; i++)
                 printf("%x ", caCmdBuf[i]);

               printf("\n");
#endif
               tag = ((wfaTLV *)caCmdBuf)->tag;
               memcpy(&ret_status, caCmdBuf+4, 4);
               DPRINT_INFO(WFA_OUT, "bytes=%i, %i,%i,%x %x %x %x \n", bytesRcvd, ((wfaTLV *)caCmdBuf)->tag,((wfaTLV *)caCmdBuf)->len, *(caCmdBuf+4), *(caCmdBuf+5), *(caCmdBuf+6), *(caCmdBuf+7));

               DPRINT_INFO(WFA_OUT, "tag %i \n", tag-WFA_STA_COMMANDS_END);
               if(wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END] != NULL)
               {
                  done = wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END](caCmdBuf);

               }
               else
                  DPRINT_WARNING(WFA_WNG, "function not defined\n");
           
	 /*while*/
     } /* if(gCaSock */
    } /* for */

    close(gSock);
    exit(0);
}
