#!/usr/bin/perl

$dbg = 0;

require 'getopts.pl';

# Try to use own dhd if present (src/dhd/exe/dhd); otherwise, from path
my $dhd = $0;
$dhd =~ s,[^/]*/[^/]*/[^/]*$,dhd/exe/dhd,;
$dhd = 'dhd' if ! -x $dhd;
$dbg and print "dhd = $dhd\n";

$0 =~ s/.*\///;

$nm = "/projects/hnd/tools/linux/hndtools-armeabi-2007q3/bin/arm-none-eabi-nm";

$h = '[0-9a-f]';

sub usage {
    print STDERR "Usage: dmpcons [-i ethdev] rtecdc.exe\n";
    exit 1;
}

&Getopts("i:") || &usage;

(@ARGV == 1) || &usage;

$exe = shift;

$opt_i = "eth1" if !$opt_i;

# Get address of cons0_addr
open(IN, "$nm $exe | sed -e '/cons0\$/s/ .*//p' -e d |") ||
    die "Could not run $nm: $!";
chomp($cons0_addr = '0x' . <IN>);
close IN;

$dbg and print "cons0_addr=$cons0_addr\n";

$cons0_addr =~ /^0x($h)+$/ or
    die "Unable to get cons0_addr from $exe\n";

# Read contents of cons0
# dhd membytes output looks like:
# 000175c8: ac 9d 03 00

$dbg and print "$dhd -i $opt_i membytes $cons0_addr 4\n";
open(IN, "$dhd -i $opt_i membytes $cons0_addr 4 |") ||
    die "Could not run $dhd: $!";
chomp($cons0 = <IN>);
# Reorder it to look like the string "0x00039dac"
$cons0 =~ s/$h{8}: ($h$h) ($h$h) ($h$h) ($h$h) /0x\4\3\2\1/;
close IN;

$dbg and print "cons0=<$cons0>\n";

$cons0 =~ /^0x($h)+/ or
    die "Unable to get cons0\n";

(hex $cons0 >= 0x0 && hex $cons0 < 0xa0000) or
    die "cons0 address out of range ($cons0)";

# Read contents of console struct
# dhd membytes output looks like:
# 00039dac: 00 00 00 00 00 00 00 00 a4 95 03 00 00 08 00 00   ................
# 00039dbc: e7 01 00 00 a4 95 03 00 00 00 00 00 00 00 00 00   ................
#   get the console ptr from offset 8
#   get the console buffer size from offset 12
#   get the console index from offset 16

$dbg and print "dhd -i $opt_i membytes $cons0 32\n";
open(IN, "$dhd -i $opt_i membytes $cons0 32 |") ||
    die "Could not run $dhd: $!";
# Get hndrte_log_t 'buf' field from offset 8 and 'buf_size' from offset 12
chomp($t = <IN>);
$buf = $t;
$buf =~ s/^$h{8}: .. .. .. .. .. .. .. .. ($h$h) ($h$h) ($h$h) ($h$h).*/0x\4\3\2\1/;
$size = $t;
$size =~ s/^$h{8}: .. .. .. .. .. .. .. .. .. .. .. .. ($h$h) ($h$h) ($h$h) ($h$h).*/0x\4\3\2\1/;
$size = oct $size;
chomp($t = <IN>);
$idx = $t;
$idx =~ s/^$h{8}: ($h$h) ($h$h) ($h$h) ($h$h).*/0x\4\3\2\1/;
$idx = oct $idx;
close IN;

$dbg and print "buf=$buf size=$size idx=$idx\n";

# Read contents of console buffer and convert to an array of hex digit pair strings
# dhd membytes output looks like:
# 000395a4: 0d 0a 52 54 45 20 28 55 53 42 2d 53 44 49 4f 2d   ..RTE (USB-SDIO-
open(IN, "$dhd -i $opt_i membytes $buf $size |") ||
    die "Could not run $dhd: $!";
@chr = ();
$n = 0;
while (<IN>) {
    s/^$h{8}: //;
    s/.{16}$//;
    s/ //g;
    for ($i = 0; $i < 16; $i++) {
	$chr[$n++] = substr($_, $i * 2, 2);
    }
}
close IN;

# Display the contents starting from the index position and wrapping around back to it,
# so that the latest output shows last.  Ignore leading zero bytes.

$lz = 1;
$nl = 1;

for ($i = 0; $i < $n; $i++) {
    $p = ($i + $idx) % $size;
    $ch = oct ('0x' . $chr[$p]);
    if ($ch == 13) {
	next;
    }
    if ($ch == 0) {
	if (!$lz) {
	    print '\0';
	}
	next;
    }
    $lz = 0;
    if ($ch == 10) {
	print "\n";
	$nl = 1;
	next;
    }
    $nl = 0;
    if ($ch == 9) {
	print "\t";
	next;
    }
    if ($ch < 32 || $ch > 126) {
	printf "\\%03o", $ch;
	next;
    }
    print chr($ch);
}

if (!$nl) {
    print "\n";
}
