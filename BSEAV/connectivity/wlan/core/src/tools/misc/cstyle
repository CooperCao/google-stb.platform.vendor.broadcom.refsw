#!/usr/bin/perl
#
# cstyle - check for some common stylistic errors.
#
#	cstyle is a sort of "lint" for C coding style.
#	It attempts to check for the style used in the
#	kernel, sometimes known as "Bill Joy Normal Form".
#
#	There's a lot this can't check for, like proper
#	indentation of continuation lines.  There's also
#	a lot more this could check for.
#
#	Original author: Bill Shannon
#
# $Id: cstyle,v 12.62 2011-02-07 19:26:00 csm Exp $
#

use strict;
use Cwd;
use File::Basename;
use File::Spec;
use Getopt::Long;

use vars qw($opt_a $opt_c $opt_d $opt_f $opt_h $opt_l $opt_v $opt_w);

my $prog = (split('/', $0))[-1];

sub usage {
    my $retcode = shift;
    print STDERR "Usage: $prog [-acdhlv] [-w <width>] [-f <filelist>] [filename ...]\n";
    print STDERR "   -a: Operate on all files named (do not filter through filelist)\n";
    print STDERR "   -c: Include C++ files\n";
    print STDERR "   -d: Print the set of directories traversed via filelist\n";
    print STDERR "   -f: Run cstyle once per line in filelist, using line as arguments\n";
    print STDERR "   -h: Give this help\n";
    print STDERR "   -l: Print files to be processed with non-blank-line max\n";
    print STDERR "   -w: Set alternate maximum line width\n";
    print STDERR "   -v: Verbose\n";
    #print STDERR "\nReturns 0 for success, 1 for style issues, 2 for script errors.\n";
    print STDERR "Must be run from within current checkout. Examples:\n";
    print STDERR "% src/tools/misc/cstyle\n";
    print STDERR "% ../../tools/misc/cstyle -v *p2p*.c\n";
    exit($retcode);
}

my $rc = 0;
my $err_filename;
my @err_list;

sub err {
    push @err_list, "${err_filename}: $.: " . (shift) . "\n";
}

sub check_file {
    my($infile, $limit) = @_;

    # With -l flag, print each file but don't process it.
    if ($opt_l) {
	printf "%-50s %d\n", $_, $limit;
	return;
    }

    print STDERR "$infile\n" if $opt_v;

    @err_list = ();
    $err_filename = $infile;

    # check for executable mode
    if (-x $infile) {
	err("$infile: bad mode: execute bit set");
    }

    if (!open(INPUT, "<$infile")) {
	warn "$prog: Error: $infile: $!\n";
	$rc = 2;
	next;
    }

    $. = 0;

    my $in_initialization = 0;
    my $check_continuation = 1;
    my $maxline = ($infile =~ m:wlc_phy_ssn.[ch]$: ? 120 : $opt_w);
    my $blank_line = 0;
    my $blank_line_limit = 2;
    # endif may omit comment if matching #if is <= pp_endif_distance_limit lines back
    my $pp_endif_distance_limit = 15;
    my $pp_if_line = 0;
    my $expect_continuation = 0;
    my $continuation_indent = '';
    my $in_continuation = 0;
    my $in_function = 0;
    my $in_function_header = 0;
    my $switch_indent = '';
    my $end_comment = 0;
    my $beg_comment = 0;
    my $in_comment = 0;
    my $cpp_continuation = 0;
    my $in_cpp = 0;
    my $prev = '';
    my $line;
    my $nextok = 0;
    my $okmsg;
    my $copyright_seen = 0;
    my $ident_seen = 0;
    my $keywords = ("for|if|while|switch|return|case|void|const|" .
		    "(u|u_)?(char|short|int)(8|16|32|64|ptr)?(_t)?|" .
		    "bool|VOID|typedef|__attribute__|__section__|__format__");
    my $cppwords = ("include|define|undef|if|ifdef|ifndef|else|elif|endif|error");
    my $rootfn = "";
    my $indir = "";
    my $root = "";
    my $skip_crlf = 0;
    my $num_lines = 0;
    my $non_blank_line_limit = 25000;
    my $non_blank_wlc_phy_n_line_limit = 45562;
    my $num_blank_lines = 0;
    my $wlc_phy_n_c_file_path = 'components/phy/old/wlc_phy_n.c';

    # While on windows platform, detect if checkout happened on unix systems
    if (exists($ENV{OS}) && $ENV{OS} =~ /Windows/) {
	if ($infile =~ /\/|\\/) {
	    ($indir) = ($infile =~ /(.*)[\/\\].*$/);
	    $rootfn = "$indir"."/CVS/Root";
	} else {
	    $rootfn = "CVS/Root";
	}
	if (-s "$rootfn") {
	    open(ROOTFN, $rootfn) or return;
	    my $root = <ROOTFN>;
	    close ROOTFN;
	    $skip_crlf = 1 if $root =~ /pserver/;
	}
    }

line:
    while (<INPUT>) {
	chomp;	# strip newline

	# Enforce number of lines in file
        $num_lines++;
        $num_blank_lines++ if /^$/;
	my $wlc_phy_n_line_limit = $non_blank_wlc_phy_n_line_limit + \
	    $num_blank_lines;
	my $line_limit = $non_blank_line_limit + $num_blank_lines;

        if ($num_lines == $wlc_phy_n_line_limit
	       && $infile =~ /$wlc_phy_n_c_file_path/) {
	    err("non blank line count exceeds $non_blank_wlc_phy_n_line_limit");
	}
	# For rest, number of lines not to exceed 25K, hard limit 64K
        elsif (($num_lines == $line_limit) && ($infile !~ /$wlc_phy_n_c_file_path/)) {
	    err("non blank line count exceeds $non_blank_line_limit");
	}

	# accept entire file if it contains the string FILE-CSTYLED
	return if /FILE-CSTYLED/;

	if (/\015$/) {
	    if (!$skip_crlf) {
		err("file contains CR+LF terminator(s)");
		$skip_crlf = 1;
	    }
	    s/\015$//;
	}

	if (/[\001-\010\016-\037\177-\377]/) {
	    err("invalid control character or unicode");
	}

	if (/^<<<<<<< / || /^>>>>>>> /) {
	    err("file contains unresolved merges");
	}

	$copyright_seen = 1 if /\$[ \t]*Copyright.* Broadcom.*\$/;
	$ident_seen = 1 if /\x{24}Id[^\x{24}]*\x{24}/;

	# save the original line, then remove all text from within
	# double or single quotes; we do not want to check such text.

	$line = $_;
	s/\\[\'\"]/Q/g;
	s/"[^\"]*"/""/g if !/#\s*include/;
	s/'[^\']*'/''/g;

	if (/\/\*/) {
	    $beg_comment = $.;
	}

	if (/\*\//) {
	    $end_comment = $.;
	}

	# Check multi-line comments
	if ($. > $end_comment && $end_comment >= $beg_comment) {
	     $beg_comment = $end_comment = 0;
	     $in_comment = 0;
	} else {
	     $in_comment = 1;
	}

	#print $beg_comment , " ", $end_comment, " ", $.,"\n";

	# Check length of line
	if ($line =~ tr/\t/\t/ * 7 + length($line) > $maxline) {
	    my $pos = 0, my $oldp = 0, my $p = 0;
	    while (($p = index($line, "\t", $p)) >= 0) {
		$pos = ($pos + $p - $oldp + 8) & ~7;
		$oldp = ++$p;
	    }
	    $pos += length($line) - $oldp;
	    if ($pos > $maxline) {
		err("line > $maxline characters");
	    }
	}

	# Check for more than n consecutive blank lines
	if ($line =~ /^\s*$/) {
	    if ($blank_line >= $blank_line_limit) {
		err("more than $blank_line_limit consecutive blank lines");
	    }
	    $blank_line++;
	} else {
	    $blank_line = 0;
        }

	# remember whether we expect to be inside a continuation line.
	$in_continuation = $expect_continuation;

	# check for proper continuation line.  blank lines
	# and C preprocessor lines in the middle of the
	# continuation do not count.
	if ($check_continuation && $expect_continuation &&
	    !/^#/ && !/^\s*$/) {
	    if ($in_initialization) {
		if (!/};/ && !/^$continuation_indent\S/) {
		    err("initialization continuation line improperly indented");
		}
	    } else {
		# continuation line must start with whitespace of
		# previous line, plus either spaces or a tab, but
		# do not check lines that start with a string constant
		# since they are often shifted to the left to make them
		# fit on the line.
		if (!/^$continuation_indent[ ]*\S/ &&
		    !/^$continuation_indent\t\t?\S/ && !/^\s*"/ && !$in_comment) { # "
		    err("continuation line improperly indented");
		}
	    }
	    $expect_continuation = 0;
	}

	# a /*CSTYLED*/ comment indicates that the next line is ok.
	if ($nextok) {
	    if ($okmsg) {
		err($okmsg);
	    }
	    $nextok = 0;
	    $okmsg = 0;
	    if (/\/\* *CSTYLED.*\*\//) {
		/^.*\/\* *CSTYLED *(.*) *\*\/.*$/;
		$okmsg = $1;
		$nextok = 1;
	    }
	    $prev = $line;
	    next line;
	}
	if (/\/\* *CSTYLED.*\*\//) {
	    /^.*\/\* *CSTYLED *(.*) *\*\/.*$/;
	    $okmsg = $1;
	    $nextok = 1;
	}

	# skip lines marked via the exception mechanism.
	if (/^NOCSTYLE/) {
	    $prev = $line;
	    next line;
	}

	# Check function open brace is on separate line
	if (/^\w.*\)\s*\{$/ && !/inline/) {
	    err("function open brace should appear on its own line");
	}

	# Note: extra backslash on mismatched braces/parens/quotes in character classes
	# and pound-signs in strings are there to help Perl context editors.

	# Is this the beginning or ending of a function
	if (/^\{$/) {
	    $prev = $line;
	    $in_function = 1;
	    $in_initialization = 0;
	    $in_function_header = 0;
	    next line;
	}

	if (/^\}$/) {
	    $prev = $line;
	    $in_function = 0;
	    next line;
	}

	if (/^\w*\($/) {
	    $in_function_header = 1;
	}

	# Is this the beginning of an initialization?
	if (/=\s*\{$/) {
	    $in_initialization = 1;
	}

	# Is this the end of an initialization? (don't check EOL because there may be a comment)
	if (/^\s*\};/) {
	    $prev = $line;
	    $in_initialization = 0;
	    next line;
	}

	# Check for errors that might occur in comments and in code.

	# Allow formatting ruler
	if (/^[ \t]*$/ && /( \t.*){3}/) {
	    $prev = $line;
	    next line;
	}

	if (/^ / && !/^ \*[ \t\/]/ && !/^ \*$/ &&
	    (!/^    \w/ || $in_function != 0) && !$in_continuation) {
	    err("indent by spaces instead of tabs");
	}
	if (/\s$/) {
	    err("space or tab at end of line");
	}
	if (/\*\// && !/\/\*.*\*\// && !/^\s*\*\/\s*$/) {
	    err("improper last line of block comment");
	}
	if (/[^ \t\(]\/\*/ && !/\w\(\/\*.*\*\/\);/) {
	    err("comment preceded by non-blank");
	}
	if (/\t[ ]+\t/) {
	    err("spaces between tabs");
	}
	if (/ [\t]+ /) {
	    err("tabs between spaces");
	}
	if (/\((NULL|-?\d+|-?0x[0-9a-fA-F]+)\s*==\s*\S/) {
	    err("backward '==' comparison");
	}
	if (/^.*if\s*\(\s*[^\s(=]+\s*=[^=]/) {
	    err("equals assignment needs parenthesis");
	}

	# To support Doxygen, we allow multiple asterisks/exclamation marks after "/*"
	if (!/^\s*\/[*!]+\s*$/ &&
	    (/[^(]\/\*[^ \t*!]/ || /^\/\*[^ \t*!]/) &&
	    !(/\/\*(ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*)\*\// ||
	    /\/\*(CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY)\*\// ||
	    /\/\*(FALLTHRU|FALLTHROUGH|LINTED.*|PRINTFLIKE[0-9]*)\*\// ||
	    /\/\*(PROTOLIB[0-9]*|SCANFLIKE[0-9]*|CSTYLED.*)\*\//)) {
		err("missing blank after open comment");
	}
	if (/\S\*\/[^)]|\S\*\/$/ &&
	    !(/\/\*(ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*)\*\// ||
	    /\/\*(CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY)\*\// ||
	    /\/\*(FALLTHRU|FALLTHROUGH|LINTED.*|PRINTFLIKE[0-9]*)\*\// ||
	    /\/\*(PROTOLIB[0-9]*|SCANFLIKE[0-9]*|CSTYLED.*)\*\//)) {
		err("missing blank before close comment");
	}

	# XXX not wedded to these, the !ts=8 folks seem to like them
	if (/^#\s*include\t/) {
		err("include followed by tab instead of space");
	}
	if (/^#\s*include\s*[<"][^<"]+\\[^>"]+[>"]/) {
		err("#include with backslash in filename");
	}
#	if (/^#undef /) {
#	    err("#undef followed by space instead of tab");
#	}
#	if (/^#if /) {
#	    err("#if followed by space instead of tab");
#	}
#	if (/^#ifdef /) {
#	    err("#ifdef followed by space instead of tab");
#	}
#	if (/^#ifndef /) {
#	    err("#ifndef followed by space instead of tab");
#	}
#	if (/^#else /) {
#	    err("#else followed by space instead of tab");
#	}
#	if (/^#endif /) {
#	    err("#endif followed by space instead of tab");
#	}
#	if (/^#define /) {
#	    err("#define followed by space instead of tab");
#	}
#	if (/^enum /) {
#	    err("enum followed by space instead of tab");
#	}
#	if (/^typedef /) {
#	    err("typedef followed by space instead of tab");
#	}
#	if (/^struct /) {
#	    err("struct followed by space instead of tab");
#	}

	# remember most recent preprocessor #if start line
	if (/^\s*#\s*if/) {
	    $pp_if_line = $.;
	}

#	# check that case after switch is indented at the same level
#	if (/^(\s*)switch\b/) {
#	    $switch_indent = $1;
#	} elsif ($switch_indent && /^(\s*)case\b/) {
#	    if ($1 ne $switch_indent) {
#		err("case not indented same as switch");
#	    }
#	    $switch_indent = '';	# Only check 1st one (nested switch problem)
#	}

	if (/^\s*#\s*endif/) {
	    # endif lines should have a comment if they are far away from the #if
	    # or there was a nested #if in the intervening lines
	    if (!(/\/\*/ && /\*\//) && !$in_comment &&
		(($pp_if_line == 0) || ($. - $pp_if_line) > $pp_endif_distance_limit)) {
		err("missing \#endif /* comment */");
	    }
	    $pp_if_line = 0;
	}

	# now skip over these
	if (/^\s*#\s*(else|endif|include)/) {
	    $prev = $line;
	    next line;
	}

#	# definitions of magic numbers should always have a comment
#	# zero is not such a magic number
#	if (/^#define\s+[0-9a-zA-Z_]+\s+((0x[0-9a-fA-F]+)|(\-?\d+\.?\d*|\.\d+))/) {
#	    $num = $1;
#	    if (!($num =~ /^((0x[0]+)|(\-?0+\.?0*|\.0+))$/) && !(/\/\*/)) {
#		err("missing #define magic number /* comment */");
#	    }
#	}

	# Anything after this is not checked inside block comments.
	if ($in_comment) {
	    $prev = $line;
	    next line;
	}

	# delete any comments and check everything else.
	s/\/\*.*\*\//^A/g;

	# delete any trailing whitespace; we have already checked for that.
	s/\s*$//;

#	if (/^\s+#($cppwords)/) {
#		err("CPP directive not at beginning of line");
#	}

	# detect when we are in a CPP directive
	if ($cpp_continuation || $line =~ /^\s*#\s*($cppwords)/) {
	    $in_cpp = 1;
	    if ($line =~ /\\$/) {
		$cpp_continuation = 1;
	    } else {
		$cpp_continuation = 0;
	    }
	} else {
	    $in_cpp = 0;
	}

	if (!$in_cpp && /\\\s*$/) {
	    err("spurious backslash at end of line");
	}

	# following checks do not apply to text in comments.

	# if it looks like an operator at the end of the line, and it is
	# not really the end of a comment (...*/), and it is not really
	# a label (done:), and it is not a case label (case FOO:),
	# or we are not in a function definition (ANSI C style) and the
	# operator is a "," (to avoid hitting "int\nfoo(\n\tint i,\n\tint j)"),
	# or we are in a function and the operator is a
	# "*" (to avoid hitting on "char*\nfunc()").
	if ((/[-+|&\/?:=]$/ && !/\*\/$/ && !/^\s*\w*:$/ &&
	     !/^\s\s*case\s.*:$/) ||
	    (!$in_function_header && /,$/) ||
	    ($in_function && /\*$/)) {
	    $expect_continuation = 1;
	    if (!$in_continuation) {
		/^(\s*)\S/;
		$continuation_indent = $1;
	    }
	}
	if (/[^<>\s][!<>=]=/ || /[^<>][!<>=]=\S/ ||
	    (/[^->]>[^=>\s]/ && !/[^->]>$/) || (/[^<]<[^=<\s]/ && !/[^<]<$/) ||
	    /[^<\s]<[^<]/ || /[^->\s]>[^>]/) {
	    err("missing space around relational operator");
	}
	if (/\S>>=/ || /\S<<=/ || />>=\S/ || /<<=\S/ || /\S[-+*\/&|^%]=/ ||
	    (/[^-+*\/&|^%!<>=\s]=[^=]/ && !/[^-+*\/&|^%!<>=\s]=$/) ||
	    (/[^!<>=]=[^=\s]/ && !/[^!<>=]=$/)) {
	    err("missing space around assignment operator");
	}
	if (/[,;]\S/ && !/\bfor \(;;\)/ && !/\bfor .+;\)/ && !/;\}/) {
	    err("comma or semicolon followed by non-blank");
	}
	if (/\s[,;]/ && !/^[\t]+;$/ && !/\bfor \(.*; ; .*/ && !/\s+,\s+##/) {
	    err("comma or semicolon preceded by blank");
	}
	if (/(?<! ), ## /) {
	    err("'##' construct without space preceding comma (compatibility issue)");
	}
	if (/^\s*(&&|\|\|)/) {
	    err("improper boolean continuation");
	}
	if (/\S   *(&&|\|\|)/ || /(&&|\|\|)   *\S/) {
	    err("more than one space around boolean operator");
	}
	if (/\b(${keywords})\(/) {
	    err("missing space between keyword and paren");
	}
	if (!/^#/ && /\b\w+\s+\(/ && !/\btypedef[ \t]/ && !/\b(${keywords})\s+\(/) {
	    err("whitespace before left paren");
	}

#	if (/^\s*return\W[^;]*;/ && !/^\s*return\s*\(.*\);/) {
#		err("unparenthesized return expression");
#	}
	if (/\bsizeof\b/ && !/\bsizeof\s*\(.*\)/) {
	    err("unparenthesized sizeof expression");
	}
	if (/\(\s/) {
	    err("whitespace after left paren");
	}
	if (/(?<!;)\s\)/) {
	    err("whitespace before right paren");
	}
	if (/\)\{/) {
	    err("missing space between right paren and left curly brace");
	}
	if (/\w\{/) {
	    err("missing space before left curly brace");
	}
	if (/\}\w/) {
	    err("missing space after right curly brace");
	}

#	if (/^\s*else\W/) {
#	    if ($prev =~ /^\s*}$/) {
#		err("else and right brace should be on same line");
#	    }
#	}

	$prev = $line;
    }

    if ($prev eq "") {
	err("Last line in file is blank");
    }

    if (!$copyright_seen) {
	err("missing Broadcom Copyright notice, include \
        \"\$ Copyright Broadcom \$\"  or \"\$ Copyright Open Broadcom \$\"");
    }

    if (!$ident_seen) {
	# (using \x{24} instead of \$ to prevent substitution on cstyle checkout)
	err("no RCS ident keyword '\x{24}Id\x{24}' in file");
    }

    close(INPUT);

    # Show the errors
    foreach my $err (@err_list) {
	print $err;
    }

    # TODO - the line below would produce a more meaningful exit code.
    #   However, it's commented out for now due to being untested with
    #   the svn cstyle hook. See RB:26209 and RB:26216 for details.
    # Exit status is 2 for script errors, 1 for cstyle problems.
    #$rc = 1 if @err_list && $rc == 0;
}

$opt_w = 100;

&usage(2) if !GetOptions(
    'a' => \$opt_a,
    'c' => \$opt_c,
    'd' => \$opt_d,
    'f=s' => \$opt_f,
    'h' => \$opt_h,
    'l' => \$opt_l,
    'v' => \$opt_v,
    'w=i' => \$opt_w,
    );

&usage(0) if $opt_h;

# The canonical way of running cstyle is from within the checkout:
# "src/tools/misc/cstyle -f src/tools/misc/cstyle-filelist.txt"
# This block does that automatically by cd-ing to the root of the tree
# and correctly locating the config file and explicit filenames
# relative to there.
my $absprog = Cwd::abs_path($0);
my $copath = 'src/tools/misc/cstyle';
my $rootwd;
if (index($absprog, $copath) < 0) {
    # TODO temporary workaround until the svn hook catches up.
    #usage(2);
    $rootwd = Cwd::abs_path('.')
} else {
    $rootwd = (split $copath, $absprog)[0];
}
if ($opt_f) {
    die "$prog: Error: -a and -f are incompatible flags\n" if $opt_a && $opt_f;
    if (-e $opt_f) {
	$opt_f = Cwd::abs_path($opt_f);
    } elsif (-e "$rootwd/$opt_f") {
	$opt_f = Cwd::abs_path("$rootwd/$opt_f");
    }
} elsif (!$opt_a) {
    my $filelist = $absprog . '-filelist.txt';
    if (-f $filelist) {
	$opt_f = $filelist;
    }
}

my %explicit_set;

sub read_dir {
    my($dir, $href, $recurse) = @_;
    no strict 'refs';
    opendir($dir, $dir) || die "$prog: Error: $dir: $!\n";
    while ($_ = readdir $dir) {
	my $path = "$dir$_";
	if (-d $path) {
	    if ($recurse && $_ ne '..' && $_ ne '.') {
		read_dir("$path/", $href, $recurse);
	    }
	} elsif (/\.(h|c)$/ || ($opt_c && /\.(cc|cpp)$/)) {
	    my $rpath = File::Spec->abs2rel($path, $rootwd);
	    $href->{$rpath} = 0 unless exists($href->{$rpath});
	}
    }
    closedir($dir) || die "$prog: Error: $dir: $!\n";
}

for (@ARGV) {
    if (-d) {
	# Dirs given on the cmdline are always read recursively.
	my $dpath = File::Spec->canonpath($_) . '/';
	read_dir($dpath, \%explicit_set, 1);
    } else {
	$explicit_set{File::Spec->abs2rel($_, $rootwd)}++;
    }
}

chdir($rootwd) || die "$prog: Error: $rootwd: $!\n";

# Read the config file to derive a hash of all files mentioned therein.
# File lines are allowed to contain glob patterns.
# Lines beginning with ~ are exclusion patterns (regular expressions).
my %config_set;
my @exclusions = ('^THIS_WILL_NEVER_MATCH_ANYTHING');
if ($opt_f) {
    my @file_list;
    open (FILELIST, $opt_f) || die "$prog: Error: $opt_f: $!\n";
    while (<FILELIST>) {
	chomp;
	s/^\s+//;		# Remove leading blanks
	s/\s+$//;		# Remove trailing blanks
	next if s/^#.*//;	# Remove comments
	next if /^$/;		# Remove blank lines
	if (/^~/) {
	    push(@exclusions, substr($_, 1));
	} else {
	    push(@file_list, glob($_));
	}
    }
    close FILELIST;
    for (@file_list) {
	if (m,/$,) {
	    # Silently skip nonexistent dirs for compatibility.
	    if (-d) {
		my $dpath = File::Spec->canonpath($_) . '/';
		if (m,//$,) {
		    read_dir($dpath, \%config_set, 1);
		} else {
		    read_dir($dpath, \%config_set, 0);
		}
	    }
	} else {
	    my($path, $limit) = /(.*)#(\d+)$/;
	    if (/(.*)#(\d+)$/) {
		$config_set{$1} = $2;
		$_ = $1;
	    } else {
		$config_set{$_} = 0;
	    }

	    if (! -T) {
		delete $config_set{$_};
		if (-e) {
		    warn("$prog: Error: $_: not a text file\n");
		    $rc = 2;
		} else {
		    # Due to our sparse-tree architecture, do not warn for files
		    # mentioned in the config file but not actually present.
		    #warn("$prog: Error: $_: no such file or directory\n");
		    #$rc = 2;
		}
	    }
	}
    }
}

# Print the set of directories derived via the filelist and exit.
if ($opt_d) {
    my %dirset = map {dirname($_) => 1} keys %config_set;
    print "$_\n" for sort keys %dirset;
    exit($rc);
}

my $exclude_re = join('|', @exclusions);

# If arguments are specified, check only those files mentioned which
# are also in the filelist. Unless -a is given in which case work on
# whichever files are given regardless. Also, assume -a mode if the
# intersection of the two sets is null.
if (%explicit_set) {
    my @checklist = sort
		    grep !/$exclude_re/o,
		    map File::Spec->abs2rel(Cwd::realpath($_)),
		    grep exists $config_set{$_},
		    keys %explicit_set;
    $opt_a = 1 if ! @checklist;
    for (sort keys %explicit_set) {
	next if /$exclude_re/o;
	if (! -f $_) {
	    warn "$prog: Error: $_: $!\n";
	    next;
	}
	my $path = File::Spec->abs2rel(Cwd::realpath($_));
	check_file($path, 0) if $opt_a || exists $config_set{$path};
    }
} else {
    for (sort grep !/$exclude_re/o, keys %config_set) {
	check_file($_, $config_set{$_});
    }
}

exit($rc);
