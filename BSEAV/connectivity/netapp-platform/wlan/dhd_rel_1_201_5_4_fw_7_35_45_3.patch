diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/dhd/sys/dhd_linux.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/dhd/sys/dhd_linux.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/dhd/sys/dhd_linux.c	2014-09-26 10:29:18.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/dhd/sys/dhd_linux.c	2014-12-18 19:53:51.029579249 -0500
@@ -199,6 +199,7 @@
 static bool dhd_inetaddr_notifier_registered = FALSE;
 #endif /* ARP_OFFLOAD_SUPPORT */

+#ifdef CONFIG_IPV6
 static int dhd_inet6addr_notifier_call(struct notifier_block *this,
	unsigned long event, void *ptr);
 static struct notifier_block dhd_inet6addr_notifier = {
@@ -208,6 +209,7 @@
  * created in kernel notifier link list (with 'next' pointing to itself)
  */
 static bool dhd_inet6addr_notifier_registered = FALSE;
+#endif

 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)
 #include <linux/suspend.h>
@@ -509,7 +511,9 @@
 static void dhd_ifdel_event_handler(void *handle, void *event_info, u8 event);
 static void dhd_set_mac_addr_handler(void *handle, void *event_info, u8 event);
 static void dhd_set_mcast_list_handler(void *handle, void *event_info, u8 event);
+#ifdef CONFIG_IPV6
 static void dhd_inet6_work_handler(void *dhd_info, void *event_data, u8 event);
+#endif

 #ifdef WL_CFG80211
 extern void dhd_netdev_free(struct net_device *ndev);
@@ -5108,10 +5112,12 @@
		register_inetaddr_notifier(&dhd_inetaddr_notifier);
	}
 #endif /* ARP_OFFLOAD_SUPPORT */
+#ifdef CONFIG_IPV6
	if (!dhd_inet6addr_notifier_registered) {
		dhd_inet6addr_notifier_registered = TRUE;
		register_inet6addr_notifier(&dhd_inet6addr_notifier);
	}
+#endif
	dhd->dhd_deferred_wq = dhd_deferred_work_init((void *)dhd);
 #ifdef DEBUG_CPU_FREQ
	dhd->new_freq = alloc_percpu(int);
@@ -6788,6 +6794,7 @@
 }
 #endif /* ARP_OFFLOAD_SUPPORT */

+#ifdef CONFIG_IPV6
 /* Neighbor Discovery Offload: defered handler */
 static void
 dhd_inet6_work_handler(void *dhd_info, void *event_data, u8 event)
@@ -6904,6 +6911,7 @@
		dhd_inet6_work_handler, DHD_WORK_PRIORITY_LOW);
	return NOTIFY_DONE;
 }
+#endif

 int
 dhd_register_if(dhd_pub_t *dhdp, int ifidx, bool need_rtnl_lock)
@@ -7109,11 +7117,12 @@
		unregister_inetaddr_notifier(&dhd_inetaddr_notifier);
	}
 #endif /* ARP_OFFLOAD_SUPPORT */
+#ifdef CONFIG_IPV6
	if (dhd_inet6addr_notifier_registered) {
		dhd_inet6addr_notifier_registered = FALSE;
		unregister_inet6addr_notifier(&dhd_inet6addr_notifier);
	}
-
+#endif
 #if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)
	if (dhd->dhd_state & DHD_ATTACH_STATE_EARLYSUSPEND_DONE) {
		if (dhd->early_suspend.suspend)
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/include/bcmdefs.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/include/bcmdefs.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/include/bcmdefs.h	2014-09-26 10:29:18.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/include/bcmdefs.h	2014-12-18 19:53:51.029579249 -0500
@@ -68,7 +68,7 @@
 #define CONST	const

 #if defined(__ARM_ARCH_7A__) && !defined(OEM_ANDROID)
-#define BCM47XX_CA9
+//#define BCM47XX_CA9
 #else
 #undef BCM47XX_CA9
 #endif /* BCM47XX && __ARM_ARCH_7A__ && !OEM_ANDROID */
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/Makerules dhd_rel_1_201_5_4_fw_7_35_45_3/src/Makerules
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/Makerules	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/Makerules	2014-12-18 19:53:51.033575650 -0500
@@ -202,6 +202,7 @@
	ifeq ($(TARGETENV), freebsd)
		GLDFLAGS = -static
	endif
+# TGK: static -> -shared x2 -- weird missing "main" failures?!?!
	ifeq ($(TARGETENV), linuxarm)
		GLDFLAGS = -static
	endif
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/BcmP2PAPI.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/BcmP2PAPI.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/BcmP2PAPI.c	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/BcmP2PAPI.c	2014-12-18 19:56:23.806504163 -0500
@@ -410,7 +410,7 @@
 /* Create a P2P Group and act as a Group Owner */
 BCMP2P_API BCMP2P_STATUS
 BCMP2PCreateGroup(BCMP2PHandle p2pHandle, unsigned char *name,
-	BCMP2P_BOOL bAutoRestartWPS)
+	BCMP2P_BOOL bAutoRestartWPS, BCMP2P_BOOL bSoftAp)
 {
	p2papi_instance_t* hdl = (p2papi_instance_t*) p2pHandle;

@@ -419,6 +419,8 @@

	p2papi_enable_p2p(hdl, TRUE);

+	hdl->bSoftAp= bSoftAp;
+
	if (createGroupOverrideFn) {
		return createGroupOverrideFn(p2pHandle, name,
			bAutoRestartWPS ? true : false);
@@ -1976,7 +1978,7 @@
			goto exit;
		}
		status = BCMP2PCreateGroup(p2pHandle,
-			persist->ssid, BCMP2P_TRUE);
+			persist->ssid, BCMP2P_TRUE, BCMP2P_FALSE);
		if (status != BCMP2P_SUCCESS) {
			BCMP2PLOG((BCMP2P_LOG_MED, TRUE,
				"BCMP2PCreateGroup failed %d\n", status));
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2plib_api.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2plib_api.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2plib_api.h	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2plib_api.h	2014-12-18 19:56:23.810498163 -0500
@@ -831,6 +831,7 @@
	uint8  acBK;
	uint8  acVI;
	uint8  acVO;
+	bool bSoftAp;
 } p2papi_instance_t;


diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2plib_generic_osl.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2plib_generic_osl.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2plib_generic_osl.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2plib_generic_osl.c	2014-12-18 19:53:51.033575650 -0500
@@ -1086,12 +1086,121 @@
	return TRUE;
 }

+/* Steven: Adding API to set an IP Address without calling ifconfig.
+ * The following implementation is copied from NetAppPrivate_P_SetIPSettings()
+ * and NetAppPrivate_P_SetGateWay() in netapp_priv.c from STB */
+#if defined(linux)
+#include <linux/route.h>
+static int p2papi_osl_set_gateway(
+    int                 lPacketSocket,
+    const char          *pIFaceName,
+    int                 tGateway)
+{
+    struct  rtentry     rtent;
+    struct sockaddr_in  *pDest  = (struct sockaddr_in *)&rtent.rt_dst;
+    struct sockaddr_in  *pGW    = (struct sockaddr_in *)&rtent.rt_gateway;
+    struct sockaddr_in  *pMask  = (struct sockaddr_in *)&rtent.rt_genmask;
+
+    memset(&rtent,0,sizeof(struct rtentry));
+    rtent.rt_metric         = 1;
+    rtent.rt_window         = 0;
+    pDest->sin_family       = pGW->sin_family = pMask->sin_family = AF_INET;
+    pDest->sin_addr.s_addr  = tGateway;
+    pGW->sin_addr.s_addr    = 0;
+    pMask->sin_addr.s_addr  = 0xffffffff;
+    rtent.rt_flags          = RTF_UP | RTF_HOST;
+    rtent.rt_dev            = (char *)pIFaceName;
+
+    /* Add route for subnet */
+    if (ioctl(lPacketSocket, SIOCADDRT, &rtent) < 0)
+    {
+        P2PERR3("%s()[%d]: Failed error:%s", __FUNCTION__, __LINE__, strerror(errno));
+        return -1;
+    }
+
+    pDest->sin_addr.s_addr  = 0;
+    pGW->sin_addr.s_addr    = tGateway;
+    pMask->sin_addr.s_addr  = 0;
+    rtent.rt_flags          = RTF_UP | RTF_GATEWAY;
+
+    /* Add route for default gateway */
+    if (ioctl(lPacketSocket, SIOCADDRT, &rtent) < 0)
+    {
+        P2PERR3("%s()[%d]: Failed error:%s", __FUNCTION__, __LINE__, strerror(errno));
+        return -1;
+    }
+    return 0;
+}
+
+
+bool p2papi_osl_set_ap_ipaddr_linux(char *pIFaceName, uint32 ip, uint32 netmask)
+{
+    int                 lPacketSocket = 0;
+    int                 tRetCode = 0;
+    struct ifreq        ifr;
+    struct sockaddr_in  *p;
+
+    if ((lPacketSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        P2PERR2("%s socket(AF_PACKET) Error: %s", __FUNCTION__, strerror(errno));
+        return -1;
+    }
+
+    memset(&ifr, 0, sizeof(ifr));
+    strncpy(ifr.ifr_name, pIFaceName, sizeof(ifr.ifr_name)-1);
+
+    p = (struct sockaddr_in *)&(ifr.ifr_addr);
+
+    /* Set IP Address to 0 to kill all routes, this might fail
+     * if there are no routes so we ignore the error */
+    p->sin_family = AF_INET;
+    p->sin_addr.s_addr = 0;
+    if (ioctl(lPacketSocket, SIOCSIFADDR, &ifr) < 0)
+    {
+        BCMP2PLOG((BCMP2P_LOG_MED, TRUE,"%s(): Not routes in the table", __FUNCTION__));
+    }
+
+    /* IP ADDRESS */
+    p->sin_family = AF_INET;
+    p->sin_addr.s_addr = ip;
+    if ( (ioctl(lPacketSocket, SIOCSIFADDR, &ifr) < 0) && ip )
+    {
+        P2PERR3("%s()[%d]: Failed error:%s", __FUNCTION__, __LINE__, strerror(errno));
+        tRetCode = -1;
+        goto err_out;
+    }
+
+    if (ip)
+    {
+        /* NETMASK ADDRESS */
+        p = (struct sockaddr_in *)&(ifr.ifr_netmask);
+        p->sin_family = AF_INET;
+        p->sin_addr.s_addr = netmask;
+        if (ioctl(lPacketSocket, SIOCSIFNETMASK, &ifr) < 0)
+        {
+            BCMP2PLOG((BCMP2P_LOG_MED, TRUE,"%s(): Could not set netmask", __FUNCTION__));
+        }
+
+        /* GATEWAY ADDRESS */
+        tRetCode = p2papi_osl_set_gateway(lPacketSocket, pIFaceName, (ip & 0x000000ff) + 1);
+    }
+err_out:
+    if (lPacketSocket > 0)
+    {
+        close(lPacketSocket);
+    }
+    return tRetCode;
+}
+#endif
 /* Set a static IP addr/netmask for this AP peer device's P2P network
  * interface.
  */
 bool
 p2papi_osl_set_ap_ipaddr(p2papi_instance_t* hdl, uint32 ip, uint32 netmask)
 {
+#if 1
+	return (p2papi_osl_set_ap_ipaddr_linux(p2papi_osl_get_ap_mode_ifname(hdl), ip, netmask) >= 0);
+#else
 #ifdef TARGETOS_symbian
	extern uint32 osl_ext_set_ap_ipaddr(bool aDhcp, uint32 aIpAddr, uint32 aNetmask);
	extern void socketSetIapId(uint32 aIapId);
@@ -1148,6 +1257,7 @@
	BCMP2PLOG((BCMP2P_LOG_MED, TRUE, "p2papi_osl_set_ap_ipaddr: %s\n", cmd));
	system(cmd);
 #endif /* TARGETENV_android */
+#endif
	return TRUE;
 }

@@ -1155,9 +1265,11 @@
 bool
 p2papi_osl_clear_ap_ipaddr(struct p2papi_instance_s* hdl)
 {
+#if 1 //defined(TARGETENV_BCMSTB)
+    return (p2papi_osl_set_ap_ipaddr_linux(p2papi_osl_get_ap_mode_ifname(hdl), 0, 0) >= 0);
+#else
	char cmd[128];
	(void) hdl;
-
 #ifdef TARGETENV_android
	snprintf(cmd, sizeof(cmd), "/system/bin/ifconfig %s 0.0.0.0 down\n",
 #elif defined(TARGETENV_BCMSTB)
@@ -1170,6 +1282,7 @@
	system(cmd);

	return TRUE;
+#endif
 }

 #if P2PAPI_ENABLE_DHCPD
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2psig/p2plib_connect.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2psig/p2plib_connect.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/common/p2psig/p2plib_connect.c	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/common/p2psig/p2plib_connect.c	2014-12-18 19:56:23.810498163 -0500
@@ -3113,7 +3113,7 @@
	 * the random "DIRECT-xy" ssid generated earlier.  This is for the case
	 * if reinvoking a persistent group.
	 */
-	if (hdl->enable_p2p) {
+    if (hdl->enable_p2p && !hdl->bSoftAp) {
		if (memcmp((char*)ssid, "DIRECT-", strlen("DIRECT-")) == 0) {
			strncpy(hdl->credentials.ssid, (char*)ssid,
				sizeof(hdl->credentials.ssid));
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/include/BcmP2PAPI.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/include/BcmP2PAPI.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/include/BcmP2PAPI.h	2014-09-26 10:29:18.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/include/BcmP2PAPI.h	2014-12-18 19:56:23.810498163 -0500
@@ -2459,7 +2459,8 @@
  */
 BCMP2P_API BCMP2P_STATUS  BCMP2PCreateGroup(BCMP2PHandle p2pHandle,
                                             BCMP2P_UINT8 *name,
-                                            BCMP2P_BOOL bWaitForever);
+                                            BCMP2P_BOOL bWaitForever,
+                                            BCMP2P_BOOL bSoftAp);


 /**
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/include/p2plib_osl.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/include/p2plib_osl.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/include/p2plib_osl.h	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/include/p2plib_osl.h	2014-12-18 19:53:51.033575650 -0500
@@ -387,6 +387,14 @@
 bool p2papi_osl_dhcp_end_server(struct p2papi_instance_s* hdl, void *dhcpd_hdl);


+/* Steven: Adding API to set an IP Address without calling ifconfig.
+ * The following implementation is copied from NetAppPrivate_P_SetIPSettings()
+ * and NetAppPrivate_P_SetGateWay() in netapp_priv.c from STB */
+#if defined(linux)
+bool p2papi_osl_set_ap_ipaddr_linux(char *pIFaceName, uint32 ip, uint32 netmask);
+#endif
+
+
 /*
  * Logging definitions
  */
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/linux/p2posl_linux.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/linux/p2posl_linux.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/linux/p2posl_linux.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/linux/p2posl_linux.c	2014-12-18 19:53:51.033575650 -0500
@@ -1151,11 +1151,64 @@
	(void) ifname;
 }

+/* Steven: Adding IOCTL API to bring up/down the interface
+ * The following code was taken from netapp_priv.c the function:
+ * NetAppPrivateSetInterfaceUp()
+ */
+#if defined(linux)
+
+static int p2posl_set_iface(const char* pIFaceName, bool bUp)
+{
+    int             tRetCode = -1;
+    int             lPacketSocket = 0;
+    struct ifreq    ifr;
+    int             retry = 10;
+
+    memset(&ifr, 0, sizeof(ifr));
+
+    if ((lPacketSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        P2PERR3("%s()[%d]: iface=%s socket() Failed\n", __FUNCTION__, __LINE__, pIFaceName);
+        return -1;
+    }
+    strncpy(ifr.ifr_name, pIFaceName, sizeof(ifr.ifr_name)-1);
+
+    /*INTERFACE CONTROL (Up/Down) */
+    while ( (ioctl(lPacketSocket, SIOCGIFFLAGS, &ifr) < 0) && retry--)
+    {
+        p2posl_sleep_ms(10);
+    }
+
+    if (!retry)
+    {
+        P2PERR3("%s()[%d]: iface=%s Failed to set up and running!\n", __FUNCTION__, __LINE__, pIFaceName);
+        goto err_out;
+    }
+
+
+    ifr.ifr_flags = (bUp) ? (ifr.ifr_flags | IFF_UP | IFF_RUNNING) : (ifr.ifr_flags & ~(IFF_UP | IFF_RUNNING));
+    if (ioctl(lPacketSocket, SIOCSIFFLAGS, &ifr) < 0)
+    {
+        P2PERR3("%s()[%d]: iface=%s Failed", __FUNCTION__, __LINE__, pIFaceName);
+        goto err_out;
+    }
+    tRetCode = 0;
+err_out:
+    if (lPacketSocket > 0)
+    {
+        close(lPacketSocket);
+    }
+    return tRetCode;
+}
+#endif

 /* Bring up an OS wireless network interface */
 int
 p2posl_ifup(const char* ifname, void *hdl)
 {
+#if 1
+    return p2posl_set_iface(ifname, true);
+#else
	int ret;
	char cmd[80];
	char *path = "";
@@ -1226,17 +1279,20 @@
		return -1;
	}

-
	return 0;
+#endif
 }

 /* Bring down an OS wireless network interface */
 int
 p2posl_ifdown(const char* ifname)
 {
+#if 1
+    p2papi_osl_set_ap_ipaddr_linux(ifname, 0, 0);
+    return p2posl_set_iface(ifname, false);
+#else
	int ret;
	char cmd[80];
-
 #ifdef TARGETENV_android
	snprintf(cmd, sizeof(cmd), "/system/bin/route del -host 255.255.255.255 %s\n",
		ifname);
@@ -1268,6 +1324,7 @@
	}

	return 0;
+#endif
 }


diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/linux/sampleapp/p2p_app.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/linux/sampleapp/p2p_app.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/p2p/p2plib/linux/sampleapp/p2p_app.c	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/p2p/p2plib/linux/sampleapp/p2p_app.c	2014-12-18 19:56:23.814492163 -0500
@@ -1688,7 +1688,7 @@
					(char *)persist.pmk,
					(char *)persist.passphrase);
				BCMP2PCreateGroup(p2papp_dev_hdl,
-					invite_req.groupSsid, TRUE);
+					invite_req.groupSsid, TRUE, FALSE);
			}
			else {
				p2papi_log(BCMP2P_LOG_MED, TRUE,
@@ -3438,7 +3438,7 @@
	}

	p2papi_log(BCMP2P_LOG_MED, TRUE, "p2papp_create_group:Create Group: %s\n", persist_go_ssid);
-	status = BCMP2PCreateGroup(p2papp_dev_hdl, (unsigned char*)persist_go_ssid, TRUE);
+	status = BCMP2PCreateGroup(p2papp_dev_hdl, (unsigned char*)persist_go_ssid, TRUE, FALSE);

	if (status == BCMP2P_SUCCESS)
	{
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/bcmsromio.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/bcmsromio.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/bcmsromio.c	1969-12-31 19:00:00.000000000 -0500
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/bcmsromio.c	2014-12-18 19:53:51.033575650 -0500
@@ -0,0 +1,53 @@
+#ifdef WLC_LOW
+#ifndef LINUX_VERSION_CODE
+#include <linuxver.h>
+#endif
+
+#define MAX_SROM_FILE_SIZE SROM_MAX
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <osl.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/unistd.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <typedefs.h>
+#include <bcmdevs.h>
+#include "bcmsrom_fmt.h"
+#include "siutils.h"
+#include "bcmutils.h"
+
+int BCMATTACHFN(init_sromvars_map)(si_t *sih, uint chipId, void *buf, uint nbytes);
+
+int BCMATTACHFN(init_sromvars_map)(si_t *sih, uint chipId, void *buf, uint nbytes)
+{
+	void *fp = NULL;
+	char fname[32];
+	int ret = 0;
+
+	sprintf(fname, "/etc/wlan/bcm%x_vars.bin", chipId);
+
+	fp = (void*)osl_os_open_image(fname);
+	if (fp != NULL) {
+		while (osl_os_get_image_block(buf, nbytes, fp));
+		osl_os_close_image(fp);
+	}
+	else {
+		printk("Could not open %s file\n", fname);
+		ret = -1;
+	}
+
+	return ret;
+}
+#else
+/* no longer maintained for linux 2.4, compare above */
+#error "kernel version not supported"
+
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) */
+#endif /* WLC_LOW */
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/dbus.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/dbus.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/dbus.c	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/dbus.c	2014-12-18 19:53:51.033575650 -0500
@@ -40,6 +40,9 @@
 #endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */


+#include <linux/vmalloc.h>
+#define VMALLOC(osh, size)  vmalloc(size)
+#define VFREE(osh, addr, size)  vfree(addr)

 #if defined(BCM_REQUEST_FW)
 #ifndef VARS_MAX
@@ -47,6 +50,9 @@
 #endif
 #endif

+#include <linux/vmalloc.h>
+#define VMALLOC(osh, size)  vmalloc(size)
+#define VFREE(osh, addr, size)  vfree(addr)

 /** General info for all BUS types */
 typedef struct dbus_irbq {
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/dbus_usb_linux.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/dbus_usb_linux.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/shared/dbus_usb_linux.c	2014-09-26 10:29:18.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/shared/dbus_usb_linux.c	2014-12-18 19:53:51.033575650 -0500
@@ -4129,6 +4129,9 @@
		case BCM43242_CHIP_ID:
			strcat(fw_name, "43242");
			break;
+		case BCM43238_CHIP_ID:
+			strcat(fw_name, "43238");
+			break;
		case BCM43526_CHIP_ID:
			strcat(fw_name, "43526");
			break;
@@ -4180,6 +4183,9 @@
		case BCM43236_CHIP_ID:
			strcat(fw_name, "43236");
			break;
+		case BCM43238_CHIP_ID:
+			strcat(fw_name, "43238");
+			break;
		case BCM43242_CHIP_ID:
			strcat(fw_name, "43242");
			break;
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/usbdev/usbdl/Makefile dhd_rel_1_201_5_4_fw_7_35_45_3/src/usbdev/usbdl/Makefile
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/usbdev/usbdl/Makefile	2014-09-26 10:29:19.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/usbdev/usbdl/Makefile	2014-12-18 19:53:51.033575650 -0500
@@ -41,21 +41,19 @@
 ifeq ($(TARGETENV), linuxmips_be)
	OBJECTS += $(ObjPfx)usb_linux.o
	COMPILE = mips-linux-gcc
-	LIBS := -L$(LIBUSB_PATH)/.libs $(LIBUSB_PATH)/.libs/libusb.a
-	CFLAGS += -I$(LIBUSB_PATH) -DIL_BIGENDIAN
+	LIBS := -L$(LIBUSB_PATH)/lib $(LIBUSB_PATH)/lib/libusb.a
+	CFLAGS += -I$(LIBUSB_PATH)/include -DIL_BIGENDIAN
 endif


 ifeq ($(TARGETENV), linuxmips)
	TARGET_PREFIX := mipsel-linux-
	OBJECTS += $(ObjPfx)usb_linux.o
-	CFLAGS += -I ../libusb
	COMPILE = mipsel-linux-gcc
	CLEAN = clean_linux
-	LDFLAGS += -L$(LIBUSB_PATH)/.libs
-	LIBS= ../libusb/.libs/libusb.a
-	LIBS := -L$(LIBUSB_PATH)/.libs $(LIBUSB_PATH)/.libs/libusb.a
-	CFLAGS += -I$(LIBUSB_PATH)
+	LDFLAGS += -L$(LIBUSB_PATH)/lib
+	LIBS := -L$(LIBUSB_PATH)/lib $(LIBUSB_PATH)/lib/libusb.a
+	CFLAGS += -I$(LIBUSB_PATH)/include
 #It is wrong to put install target here, affect the rest of ifeq tests
 #install:
 #	cp bcmdl $(SRCBASE)/router/mipsel-uclibc/target/bin
@@ -74,6 +72,16 @@
 #	cp bcmdl $(SRCBASE)/router/mipsel-uclibc/target/bin
 endif

+ifeq ($(TARGETENV), linuxarm_le)
+	TARGET_PREFIX := arm-linux-
+	OBJECTS += $(OBJDIR)usb_linux.o
+	COMPILE = arm-linux-gcc
+	CLEAN = clean_linux
+	LDFLAGS += -L$(LIBUSB_PATH)/lib
+	LIBS := -L$(LIBUSB_PATH)/lib $(LIBUSB_PATH)/lib/libusb.a
+	CFLAGS += -I$(LIBUSB_PATH)/include
+endif
+
 ifeq ($(TARGETENV), macos)
	TARGET = bcmdl_macos
	CLEAN = clean_macos
@@ -89,14 +97,11 @@
	OBJECTS := $(SRCS:%.c=$(ObjPfx)%.o)
	OBJECTS += $(ObjPfx)usb_linux.o
	TARGET_PREFIX := mipsel-linux-
-	TARGET := $(ObjPfx)bcmdl
	COMPILE := $(CC)
	LDFLAGS += $(CROSS_LD_PATH)
-	LDFLAGS += -L$(LIBUSB_PATH)/.libs
-	LIBS= ../libusb/.libs/libusb.a
-	LIBS := -L$(LIBUSB_PATH)/.libs $(LIBUSB_PATH)/.libs/libusb.a
-	CFLAGS += -I ../libusb
-	CFLAGS += -I$(LIBUSB_PATH)
+	LDFLAGS += -L$(LIBUSB_PATH)/libs
+	LIBS := -L$(LIBUSB_PATH)/lib $(LIBUSB_PATH)/lib/libusb.a
+	CFLAGS += -I$(LIBUSB_PATH)/include
 endif

 ifeq ($(BCMQT),1)
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/include/wps_api_osl.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/include/wps_api_osl.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/include/wps_api_osl.h	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/include/wps_api_osl.h	2014-12-18 19:53:51.037572050 -0500
@@ -61,7 +61,7 @@
 extern char *wps_osl_get_short_adapter_name();
 extern int wps_osl_get_mac(uint8 *mac);
 extern char *wps_osl_get_ssid();
-extern uint32 wps_osl_init(void *cb_ctx, void *cb, const char *adapter_id);
+extern uint32 wps_osl_init(void *cb_ctx, void *cb, const char *adapter_id, const char* bridge_id);
 extern void wps_osl_deinit();
 extern void wps_osl_abort();
 extern uint32 wps_osl_setup_802_1x(uint8 *bssid);
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/include/wps_sdk.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/include/wps_sdk.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/include/wps_sdk.h	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/include/wps_sdk.h	2014-12-18 19:53:51.037572050 -0500
@@ -277,6 +277,8 @@
  * Function : wps_api_open
  * Parameters :
  *		adapter_id - Adapter identifier
+ *		bridge_id Bridge adaptor name that the interface is connected too (the interface to
+ *		listen for events on)
  *		cb_ctx  - Optional. If provided, the WPS status callback
  *			will be called with this context.
  *		callback - WPS status callback.
@@ -303,10 +305,10 @@
  *			serial Number = "5678"
  */
 #ifdef WFA_WPS_20_TESTBED
-BCM_WPSAPI bool wps_api_open(const char *adapter_id, void *cb_ctx, fnWpsProcessCB callback,
+BCM_WPSAPI bool wps_api_open(const char *adapter_id, const char* bridge_id, void *cb_ctx, fnWpsProcessCB callback,
	wps_devinf *devinf, wps20_testbed_inf *wps20_tbinf, bool ap_pin, bool version2);
 #else
-BCM_WPSAPI bool wps_api_open(const char *adapter_id, void *cb_ctx, fnWpsProcessCB callback,
+BCM_WPSAPI bool wps_api_open(const char *adapter_id, const char* bridge_id, void *cb_ctx, fnWpsProcessCB callback,
	wps_devinf *devinf, bool ap_pin, bool version2);
 #endif

diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_api.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_api.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_api.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_api.c	2014-12-18 19:53:51.037572050 -0500
@@ -734,10 +734,10 @@
 /* wps_api_open function must be called first, before any other wps api call */
 BCM_WPSAPI bool
 #ifdef WFA_WPS_20_TESTBED
-wps_api_open(const char *adapter_id, void *cb_ctx, fnWpsProcessCB callback, wps_devinf *devinf,
+wps_api_open(const char *adapter_id, const char* bridge_id, void *cb_ctx, fnWpsProcessCB callback, wps_devinf *devinf,
	wps20_testbed_inf *wps20_tbinf, bool ap_pin, bool b_v2)
 #else
-wps_api_open(const char *adapter_id, void *cb_ctx, fnWpsProcessCB callback, wps_devinf *devinf,
+wps_api_open(const char *adapter_id, const char* bridge_id, void *cb_ctx, fnWpsProcessCB callback, wps_devinf *devinf,
	bool ap_pin, bool b_v2)
 #endif /* WFA_WPS_20_TESTBED */
 {
@@ -796,7 +796,7 @@
	wps_api_status_cb(&wps_api_wksp->cb, wps_api_wksp->cb_ctx, WPS_STATUS_INIT, NULL);

	/* WPS hook init for adapter and led (HW) */
-	if (wps_hook_init(cb_ctx, callback, adapter_id) == false) {
+	if (wps_hook_init(cb_ctx, callback, adapter_id, bridge_id) == false) {
		TUTRACE((TUTRACE_ERR, "wps_api_open : Failed to initial wireless adapter.\n"));
		return false;
	}
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_api_priv.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_api_priv.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_api_priv.h	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_api_priv.h	2014-12-18 19:53:51.037572050 -0500
@@ -35,7 +35,7 @@

 extern bool wps_hook_create_profile(const struct _wps_credentials *credentials);
 extern int wps_hook_get_mac(uint8 *mac);
-extern bool wps_hook_init(void *cb_ctx, void *cb, const char *adapter_id);
+extern bool wps_hook_init(void *cb_ctx, void *cb, const char *adapter_id, const char* bridge_id);
 extern void wps_hook_deinit();
 extern void wps_hook_abort();
 extern uint32 wps_hook_setup_802_1x(char *bssid);
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_hooks.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_hooks.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/common/wps_hooks.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/common/wps_hooks.c	2014-12-18 19:53:51.037572050 -0500
@@ -61,9 +61,9 @@

 /* Initial HW related */
 bool
-wps_hook_init(void *cb_ctx, void *cb, const char *adapter_id)
+wps_hook_init(void *cb_ctx, void *cb, const char *adapter_id, const char * bridge_id)
 {
-	uint32 retVal = wps_osl_init(cb_ctx, cb, adapter_id);
+	uint32 retVal = wps_osl_init(cb_ctx, cb, adapter_id, bridge_id);
	return ((retVal == WPS_OSL_SUCCESS) ? true : false);
 }

diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/Makefile dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/Makefile
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/Makefile	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/Makefile	2014-12-18 19:53:51.037572050 -0500
@@ -45,7 +45,7 @@
 WFA_TB ?= 0

 # Set CFLAGS
-CFLAGS = -Wall -Werror -Wnested-externs -fPIC -fno-strict-aliasing
+CFLAGS = -Wall -Wnested-externs -fPIC -fno-strict-aliasing

 ifeq ($(TARGETARCH), x86_64)
 CFLAGS += -DBN64_BIT
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_tester.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_tester.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_tester.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_tester.c	2014-12-18 19:53:51.037572050 -0500
@@ -343,11 +343,11 @@

	/* 2. Open WPS */
 #ifdef WFA_WPS_20_TESTBED
-	bRet = wps_api_open(STRP(wps->ifname), NULL, _wps_join_callback,
+	bRet = wps_api_open(STRP(wps->ifname), STRP(wps->brname), NULL, _wps_join_callback,
		_wps_my_devinf(&my_devinf, wps->transport_uuid), &wps->wps20_tbinf, wps->b_appin,
		wps->b_v2);
 #else
-	bRet = wps_api_open(STRP(wps->ifname), NULL, _wps_join_callback,
+	bRet = wps_api_open(STRP(wps->ifname), STRP(wps->brname), NULL, _wps_join_callback,
		_wps_my_devinf(&my_devinf, wps->transport_uuid), wps->b_appin, wps->b_v2);
 #endif
	if (bRet == FALSE) {
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_tester.h dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_tester.h
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_tester.h	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_tester.h	2014-12-18 19:53:51.037572050 -0500
@@ -29,7 +29,8 @@

	char bssid[6];
	char ssid[33];
-	char ifname[16];
+    char ifname[16];
+    char brname[16];
	char def_dhclient_pf[256];
	char ip_addr[16];
	char dhcp_cmd[256];
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_ui.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_ui.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_api_ui.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_api_ui.c	2014-12-18 19:53:51.037572050 -0500
@@ -970,11 +970,16 @@
			wps->b_ssid = TRUE;
			WPS_PRINT(("SSID : %s", wps->ssid));
		}
-		else if (!strcmp(cmd, "-if")) {
-			WPS_ARGC_CHECK();
-			val = argv[index++]; argc--;
-			wps_strncpy(wps->ifname, val, sizeof(wps->ifname));
-		}
+        else if (!strcmp(cmd, "-if")) {
+            WPS_ARGC_CHECK();
+            val = argv[index++]; argc--;
+            wps_strncpy(wps->ifname, val, sizeof(wps->ifname));
+        }
+        else if (!strcmp(cmd, "-br")) {
+            WPS_ARGC_CHECK();
+            val = argv[index++]; argc--;
+            wps_strncpy(wps->brname, val, sizeof(wps->brname));
+        }
		else if (!strcmp(cmd, "-bssid")) {
			WPS_ARGC_CHECK();
			/*
diff -BNru dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_linux_osl.c dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_linux_osl.c
--- dhd_rel_1_201_5_4_fw_7_35_45_3_org/src/wps/wpsapi/linux/wps_linux_osl.c	2014-09-26 10:29:17.000000000 -0400
+++ dhd_rel_1_201_5_4_fw_7_35_45_3/src/wps/wpsapi/linux/wps_linux_osl.c	2014-12-18 19:53:51.041568449 -0500
@@ -93,6 +93,8 @@
 WPS_OSL_T *wps_osl_wksp = NULL;

 static char ifname_lx[IFNAMSIZ] = "";
+static char ifname_br[IFNAMSIZ] = "";
+
 static uint8 peer_mac[6] = {0};
 static int eap_fd = -1; /* descriptor to raw socket  */
 static int ifindex = -1; /* interface index */
@@ -158,6 +160,12 @@

	ifr.ifr_name[0] = '\0';

+	if (ifname_br[0] != '\0')
+    {
+	    strncpy(ifname, ifname_br, ifname_len);
+	    return 0;
+    }
+
	if (!(fp = fopen(proc_net_dev, "r")))
		return ret;

@@ -630,7 +638,7 @@
		memcpy(peer_mac, bssid, 6);

	memset(&ifr, 0, sizeof(ifr));
-	wps_strncpy(ifr.ifr_name, ifname_lx, sizeof(ifr.ifr_name));
+	wps_strncpy(ifr.ifr_name, ifname_br[0] ? ifname_br : ifname_lx, sizeof(ifr.ifr_name));

	err = ioctl(eap_fd, SIOCGIFINDEX, &ifr);
	if (err < 0) {
@@ -644,15 +652,24 @@

	ll.sll_family = PF_PACKET;
	ll.sll_ifindex = ifr.ifr_ifindex;
-	ifindex  = ifr.ifr_ifindex;
	ll.sll_protocol = htons(ETH_8021X_PROT);
	if (bind(eap_fd, (struct sockaddr *) &ll, sizeof(ll)) < 0) {
-		WPS_DEBUG(("Bind interface failed\n"));
+		WPS_DEBUG(( "Bind interface failed\n"));
		close(eap_fd);
		eap_fd = -1;
		return WPS_OSL_ERROR;
	}

+	wps_strncpy(ifr.ifr_name, ifname_lx, sizeof(ifr.ifr_name));
+	err = ioctl(eap_fd, SIOCGIFINDEX, &ifr);
+	if (err < 0) {
+		WPS_DEBUG(( "Get interface index failed\n"));
+		close(eap_fd);
+		eap_fd = -1;
+		return WPS_OSL_ERROR;
+	}
+	ifindex  = ifr.ifr_ifindex;
+
	return WPS_OSL_SUCCESS;
 }

@@ -840,7 +857,7 @@
 }

 uint32
-wps_osl_init(void *cb_ctx, void *cb, const char *adapter_id)
+wps_osl_init(void *cb_ctx, void *cb, const char *adapter_id, const char* bridge_id)
 {
	char *ifname = (char*) adapter_id;
	char dyn_name[IFNAMSIZ];
@@ -869,6 +886,11 @@
		ifname = dyn_name;
	}

+	if (bridge_id != NULL)
+	{
+	    wps_strncpy(ifname_br, bridge_id, sizeof(ifname_br));
+	}
+
	/* Save this specific interface for further use */
	wps_strncpy(ifname_lx, ifname, sizeof(ifname_lx));

@@ -925,6 +947,8 @@
		free(wps_osl_wksp);
		wps_osl_wksp = NULL;
	}
+    memset(ifname_br, 0, sizeof(ifname_br));
+    memset(ifname_lx, 0, sizeof(ifname_lx));
 }

 void
