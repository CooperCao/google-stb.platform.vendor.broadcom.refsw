/******************************************************************************
 *  Copyright (C) 2017 Broadcom.  The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the terms and
 *  conditions of a separate, written license agreement executed between you and Broadcom
 *  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 *  no license (express or implied), right to use, or waiver of any kind with respect to the
 *  Software, and Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 *  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 *  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 *  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 *  and to use this information only in connection with your use of Broadcom integrated circuit products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 *  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 *  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 *  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
 *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
 *  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
 *  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
 *  USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 *  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
 *  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
 *  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
 *  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
 *  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
 *  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
 *  ANY LIMITED REMEDY.
 ******************************************************************************/


#include <stdio.h>
#include "bchp_m2mc.h"

/********************************************************************
 Usage:  printpkt < src_file > out_file

 asseume: the input data format is the one generated by RDBLive/Mem View/CSV Gen,
 Every line is a set of two integers (addr,value):
 ....
 0x13f39d34,0x00640190
 0x13f39d38,0x00320032
 0x13f39d3c,0x00000000
 0x13f39d40,0x13f39de0 # next
 0x13f39d44,0x00001a00 # GROUP_MASK
 0x13f39d48,0x00000001 # OUTPUT_FEEDER_ENABLE(10)
 0x13f39d4c,0x00000000 # OUTPUT_SURFACE_ADDR_0_MSB
 0x13f39d50,0x81000000 # OUTPUT_SURFACE_ADDR_0
 0x13f39d54,0x00000b40 # OUTPUT_SURFACE_STRIDE_0
 .....

 If the first valid pkt is also the last one, you need to manually edit the input
 file so that the pkt start at the 1st line.  This is to avoid wrong locking.
*/

#define  bool      int
#define  uint32_t  unsigned

#define PKT_MAX_SIZE      0x300
#define PKT_FULL_GRP_MSK  0x7ff2


#define BGRC_M2MC(val)   BCHP_M2MC_##val

/* this is copied from bgrc_packet_priv.[hc] */
#if (!defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_0_MSB) && ((BCHP_M2MC_OUTPUT_SURFACE_STRIDE_0 - BCHP_M2MC_OUTPUT_SURFACE_ADDR_0) == 0x8))
#define BGRC_P_64BITS_ADDR    1
#else
#define BGRC_P_64BITS_ADDR    0
#endif
#if (BGRC_P_64BITS_ADDR)
#define BCHP_M2MC_SRC_SURFACE_ADDR_0_LSB           (BCHP_M2MC_SRC_SURFACE_ADDR_0 + 4)
#define BCHP_M2MC_SRC_SURFACE_ADDR_0_BOT_FLD_LSB   (BCHP_M2MC_SRC_SURFACE_ADDR_0_BOT_FLD + 4)
#define BCHP_M2MC_SRC_SURFACE_ADDR_1_LSB           (BCHP_M2MC_SRC_SURFACE_ADDR_1 + 4)
#define BCHP_M2MC_SRC_SURFACE_ADDR_1_BOT_FLD_LSB   (BCHP_M2MC_SRC_SURFACE_ADDR_1_BOT_FLD + 4)
#define BCHP_M2MC_SRC_SURFACE_ADDR_2_LSB           (BCHP_M2MC_SRC_SURFACE_ADDR_2 + 4)
#define BCHP_M2MC_DEST_SURFACE_ADDR_0_LSB          (BCHP_M2MC_DEST_SURFACE_ADDR_0 + 4)
#define BCHP_M2MC_DEST_SURFACE_ADDR_1_LSB          (BCHP_M2MC_DEST_SURFACE_ADDR_1 + 4)
#define BCHP_M2MC_OUTPUT_SURFACE_ADDR_0_LSB        (BCHP_M2MC_OUTPUT_SURFACE_ADDR_0 + 4)
#define BCHP_M2MC_OUTPUT_SURFACE_ADDR_1_LSB        (BCHP_M2MC_OUTPUT_SURFACE_ADDR_1 + 4)
#endif

static char *s_SRC_FEEDER_REG[] =
{
#if defined(BCHP_M2MC_SRC_FEEDER_ENABLE)
	"SRC_FEEDER_ENABLE",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_MSB)
	"SRC_SURFACE_ADDR_0_MSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0)
	"SRC_SURFACE_ADDR_0",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_LSB)
	"SRC_SURFACE_ADDR_0_LSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_BOT_FLD_MSB)
	"SRC_SURFACE_ADDR_0_BOT_FLD_MSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_BOT_FLD)
	"SRC_SURFACE_ADDR_0_BOT_FLD",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_BOT_FLD_LSB)
	"SRC_SURFACE_ADDR_0_BOT_FLD_LSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_STRIDE_0)
	"SRC_SURFACE_STRIDE_0",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1_MSB)
	"SRC_SURFACE_ADDR_1_MSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1)
	"SRC_SURFACE_ADDR_1",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1_LSB)
	"SRC_SURFACE_ADDR_1_LSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1_BOT_FLD_MSB)
	"SRC_SURFACE_ADDR_1_BOT_FLD_MSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1_BOT_FLD)
	"SRC_SURFACE_ADDR_1_BOT_FLD",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_1_BOT_FLD_LSB)
	"SRC_SURFACE_ADDR_1_BOT_FLD_LSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_STRIDE_1)
	"SRC_SURFACE_STRIDE_1",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_0_FORMAT_DEF_1)
	"SRC_SURFACE_0_FORMAT_DEF_1",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_0_FORMAT_DEF_2)
	"SRC_SURFACE_0_FORMAT_DEF_2",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_0_FORMAT_DEF_3)
	"SRC_SURFACE_0_FORMAT_DEF_3",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_1_FORMAT_DEF_1)
	"SRC_SURFACE_1_FORMAT_DEF_1",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_1_FORMAT_DEF_2)
	"SRC_SURFACE_1_FORMAT_DEF_2",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_1_FORMAT_DEF_3)
	"SRC_SURFACE_1_FORMAT_DEF_3",
#endif
#if defined(BCHP_M2MC_SRC_W_ALPHA)
	"SRC_W_ALPHA",
#endif
#if defined(BCHP_M2MC_SRC_CONSTANT_COLOR)
	"SRC_CONSTANT_COLOR",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_MSB)
	"SRC_SURFACE_ADDR_2_MSB",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0)
	"SRC_SURFACE_ADDR_2",
#endif
#if defined(BCHP_M2MC_SRC_SURFACE_ADDR_0_LSB)
	"SRC_SURFACE_ADDR_2_LSB"
#endif
};

static char *s_DEST_FEEDER_REG[] =
{
#if defined(BCHP_M2MC_DEST_FEEDER_ENABLE)
	"DEST_FEEDER_ENABLE",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_0_MSB)
	"DEST_SURFACE_ADDR_0_MSB",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_0)
	"DEST_SURFACE_ADDR_0",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_0_LSB)
	"DEST_SURFACE_ADDR_0_LSB",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_STRIDE_0)
	"DEST_SURFACE_STRIDE_0",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_1_MSB)
	"DEST_SURFACE_ADDR_1_MSB",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_1)
	"DEST_SURFACE_ADDR_1",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_ADDR_1_LSB)
	"DEST_SURFACE_ADDR_1_LSB",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_STRIDE_1)
	"DEST_SURFACE_STRIDE_1",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_FORMAT_DEF_1)
	"DEST_SURFACE_FORMAT_DEF_1",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_FORMAT_DEF_2)
	"DEST_SURFACE_FORMAT_DEF_2",
#endif
#if defined(BCHP_M2MC_DEST_SURFACE_FORMAT_DEF_3)
	"DEST_SURFACE_FORMAT_DEF_3",
#endif
#if defined(BCHP_M2MC_DEST_W_ALPHA)
	"DEST_W_ALPHA",
#endif
#if defined(BCHP_M2MC_DEST_CONSTANT_COLOR)
	"DEST_CONSTANT_COLOR"
#endif
};

static char *s_OUTPUT_FEEDER_REG[] =
{
#if defined(BCHP_M2MC_OUTPUT_FEEDER_ENABLE)
	"OUTPUT_FEEDER_ENABLE",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_0_MSB)
	"OUTPUT_SURFACE_ADDR_0_MSB",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_0)
	"OUTPUT_SURFACE_ADDR_0",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_0_LSB)
	"OUTPUT_SURFACE_ADDR_0_LSB",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_STRIDE_0)
	"OUTPUT_SURFACE_STRIDE_0",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_1_MSB)
	"OUTPUT_SURFACE_ADDR_1_MSB",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_1)
	"OUTPUT_SURFACE_ADDR_1",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_ADDR_1_LSB)
	"OUTPUT_SURFACE_ADDR_1_LSB",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_STRIDE_1)
	"OUTPUT_SURFACE_STRIDE_1",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_FORMAT_DEF_1)
	"OUTPUT_SURFACE_FORMAT_DEF_1",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_FORMAT_DEF_2)
	"OUTPUT_SURFACE_FORMAT_DEF_2",
#endif
#if defined(BCHP_M2MC_OUTPUT_SURFACE_FORMAT_DEF_3)
	"OUTPUT_SURFACE_FORMAT_DEF_3"
#endif
};

static char *s_BLIT_REG[] =
{
#if defined(BCHP_M2MC_BLIT_HEADER)
	"BLIT_HEADER",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_TOP_LEFT_0)
	"BLIT_SRC_TOP_LEFT_0",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_SIZE_0)
	"BLIT_SRC_SIZE_0",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_UIF_FULL_HEIGHT)
	"BLIT_SRC_UIF_FULL_HEIGHT",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_TOP_LEFT_1)
	"BLIT_SRC_TOP_LEFT_1",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_SIZE_1)
	"BLIT_SRC_SIZE_1",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_STRIPE_HEIGHT_WIDTH_0)
	"BLIT_SRC_STRIPE_HEIGHT_WIDTH_0",
#endif
#if defined(BCHP_M2MC_BLIT_SRC_STRIPE_HEIGHT_WIDTH_1)
	"BLIT_SRC_STRIPE_HEIGHT_WIDTH_1",
#endif
#if defined(BCHP_M2MC_BLIT_DEST_TOP_LEFT)
	"BLIT_DEST_TOP_LEFT",
#endif
#if defined(BCHP_M2MC_BLIT_DEST_SIZE)
	"BLIT_DEST_SIZE",
#endif
#if defined(BCHP_M2MC_BLIT_DEST_UIF_FULL_HEIGHT)
	"BLIT_DEST_UIF_FULL_HEIGHT",
#endif
#if defined(BCHP_M2MC_BLIT_OUTPUT_TOP_LEFT)
	"BLIT_OUTPUT_TOP_LEFT",
#endif
#if defined(BCHP_M2MC_BLIT_OUTPUT_SIZE)
	"BLIT_OUTPUT_SIZE",
#endif
#if defined(BCHP_M2MC_BLIT_OUTPUT_UIF_FULL_HEIGHT)
	"BLIT_OUTPUT_UIF_FULL_HEIGHT",
#endif
#if defined(BCHP_M2MC_BLIT_INPUT_STRIPE_WIDTH_0)
	"BLIT_INPUT_STRIPE_WIDTH_0",
#endif
#if defined(BCHP_M2MC_BLIT_INPUT_STRIPE_WIDTH_1)
	"BLIT_INPUT_STRIPE_WIDTH_1",
#endif
#if defined(BCHP_M2MC_BLIT_OUTPUT_STRIPE_WIDTH)
	"BLIT_OUTPUT_STRIPE_WIDTH",
#endif
#if defined(BCHP_M2MC_BLIT_STRIPE_OVERLAP_0)
	"BLIT_STRIPE_OVERLAP_0",
#endif
#if defined(BCHP_M2MC_BLIT_STRIPE_OVERLAP_1)
	"BLIT_STRIPE_OVERLAP_1",
#endif
#if defined(BCHP_M2MC_BLIT_CTRL)
	"BLIT_CTRL",
#endif
#if defined(BCHP_M2MC_DCEG_CFG)
	"DCEG_CFG"
#endif
};

static char *s_SCALER_REG[] =
{
#if defined(BCHP_M2MC_SCALER_CTRL)
	"SCALER_CTRL",
#endif
#if defined(BCHP_M2MC_HORIZ_AVERAGER_COUNT)
	"HORIZ_AVERAGER_COUNT",
#endif
#if defined(BCHP_M2MC_HORIZ_AVERAGER_COEFF)
	"HORIZ_AVERAGER_COEFF",
#endif
#if defined(BCHP_M2MC_VERT_AVERAGER_COUNT)
	"VERT_AVERAGER_COUNT",
#endif
#if defined(BCHP_M2MC_VERT_AVERAGER_COEFF)
	"VERT_AVERAGER_COEFF",
#endif
#if defined(BCHP_M2MC_HORIZ_SCALER_0_INITIAL_PHASE)
	"HORIZ_SCALER_0_INITIAL_PHASE",
#endif
#if defined(BCHP_M2MC_HORIZ_SCALER_0_STEP)
	"HORIZ_SCALER_0_STEP",
#endif
#if defined(BCHP_M2MC_HORIZ_SCALER_1_INITIAL_PHASE)
	"HORIZ_SCALER_1_INITIAL_PHASE",
#endif
#if defined(BCHP_M2MC_HORIZ_SCALER_1_STEP)
	"HORIZ_SCALER_1_STEP",
#endif
#if defined(BCHP_M2MC_VERT_SCALER_0_INITIAL_PHASE)
	"VERT_SCALER_0_INITIAL_PHASE",
#endif
#if defined(BCHP_M2MC_VERT_SCALER_0_STEP)
	"VERT_SCALER_0_STEP",
#endif
#if defined(BCHP_M2MC_VERT_SCALER_1_INITIAL_PHASE)
	"VERT_SCALER_1_INITIAL_PHASE",
#endif
#if defined(BCHP_M2MC_VERT_SCALER_1_STEP)
	"VERT_SCALER_1_STEP"
#endif
};

static char *s_BLEND_REG[] =
{
#if defined(BCHP_M2MC_BLEND_COLOR_OP)
	"BLEND_COLOR_OP",
#endif
#if defined(BCHP_M2MC_BLEND_ALPHA_OP)
	"BLEND_ALPHA_OP",
#endif
#if defined(BCHP_M2MC_BLEND_CONSTANT_COLOR)
	"BLEND_CONSTANT_COLOR",
#endif
#if defined(BCHP_M2MC_BLEND_COLOR_KEY_ACTION)
	"BLEND_COLOR_KEY_ACTION "
#endif
};

static char *s_ROP_REG[] =
{
#if defined(BCHP_M2MC_ROP_OPERATION)
	"ROP_OPERATION",
#endif
#if defined(BCHP_M2MC_ROP_PATTERN_TOP)
	"ROP_PATTERN_TOP",
#endif
#if defined(BCHP_M2MC_ROP_PATTERN_BOTTOM)
	"ROP_PATTERN_BOTTOM",
#endif
#if defined(BCHP_M2MC_ROP_PATTERN_COLOR_0)
	"ROP_PATTERN_COLOR_0",
#endif
#if defined(BCHP_M2MC_ROP_PATTERN_COLOR_1)
	"ROP_PATTERN_COLOR_1"
#endif
};

static char *s_SRC_COLOR_KEY_REG[] =
{
#if defined(BCHP_M2MC_SRC_COLOR_KEY_HIGH)
	"SRC_COLOR_KEY_HIGH",
#endif
#if defined(BCHP_M2MC_SRC_COLOR_KEY_LOW)
	"SRC_COLOR_KEY_LOW",
#endif
#if defined(BCHP_M2MC_SRC_COLOR_KEY_MASK)
	"SRC_COLOR_KEY_MASK",
#endif
#if defined(BCHP_M2MC_SRC_COLOR_KEY_REPLACEMENT)
	"SRC_COLOR_KEY_REPLACEMENT",
#endif
#if defined(BCHP_M2MC_SRC_COLOR_KEY_REPLACEMENT_MASK)
	"SRC_COLOR_KEY_REPLACEMENT_MASK"
#endif
};

static char *s_DEST_COLOR_KEY_REG[] =
{
#if defined(BCHP_M2MC_DEST_COLOR_KEY_HIGH)
	"DEST_COLOR_KEY_HIGH",
#endif
#if defined(BCHP_M2MC_DEST_COLOR_KEY_LOW)
	"DEST_COLOR_KEY_LOW",
#endif
#if defined(BCHP_M2MC_DEST_COLOR_KEY_MASK)
	"DEST_COLOR_KEY_MASK",
#endif
#if defined(BCHP_M2MC_DEST_COLOR_KEY_REPLACEMENT)
	"DEST_COLOR_KEY_REPLACEMENT",
#endif
#if defined(BCHP_M2MC_DEST_COLOR_KEY_REPLACEMENT_MASK)
	"DEST_COLOR_KEY_REPLACEMENT_MASK "
#endif
};

static char *s_SCALE_COEF_REG[] =
{
#if defined(BCHP_M2MC_HORIZ_FIR_0_COEFF_PHASE0_01)
	"HORIZ_FIR_0_COEFF_PHASE0_01",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_0_COEFF_PHASE0_2)
	"HORIZ_FIR_0_COEFF_PHASE0_2",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_0_COEFF_PHASE1_01)
	"HORIZ_FIR_0_COEFF_PHASE1_01",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_0_COEFF_PHASE1_2)
	"HORIZ_FIR_0_COEFF_PHASE1_2",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_1_COEFF_PHASE0_01)
	"HORIZ_FIR_1_COEFF_PHASE0_01",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_1_COEFF_PHASE0_2)
	"HORIZ_FIR_1_COEFF_PHASE0_2",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_1_COEFF_PHASE1_01)
	"HORIZ_FIR_1_COEFF_PHASE1_01",
#endif
#if defined(BCHP_M2MC_HORIZ_FIR_1_COEFF_PHASE1_2)
	"HORIZ_FIR_1_COEFF_PHASE1_2",
#endif
#if defined(BCHP_M2MC_VERT_FIR_0_COEFF_PHASE0_01)
	"VERT_FIR_0_COEFF_PHASE0_01",
#endif
#if defined(BCHP_M2MC_VERT_FIR_0_COEFF_PHASE0_2)
	"VERT_FIR_0_COEFF_PHASE0_2",
#endif
#if defined(BCHP_M2MC_VERT_FIR_0_COEFF_PHASE1_01)
	"VERT_FIR_0_COEFF_PHASE1_01",
#endif
#if defined(BCHP_M2MC_VERT_FIR_0_COEFF_PHASE1_2)
	"VERT_FIR_0_COEFF_PHASE1_2",
#endif
#if defined(BCHP_M2MC_VERT_FIR_1_COEFF_PHASE0_01)
	"VERT_FIR_1_COEFF_PHASE0_01",
#endif
#if defined(BCHP_M2MC_VERT_FIR_1_COEFF_PHASE0_2)
	"VERT_FIR_1_COEFF_PHASE0_2",
#endif
#if defined(BCHP_M2MC_VERT_FIR_1_COEFF_PHASE1_01)
	"VERT_FIR_1_COEFF_PHASE1_01",
#endif
	#if defined(BCHP_M2MC_VERT_FIR_1_COEFF_PHASE1_2)
	"VERT_FIR_1_COEFF_PHASE1_2"
#endif
};

static char *s_SRC_CM_REG[] =
{
#if defined(BCHP_M2MC_SRC_CM_C00_C01)
	"SRC_CM_C00_C01",
#endif
#if defined(BCHP_M2MC_SRC_CM_C02_C03)
	"SRC_CM_C02_C03",
#endif
#if defined(BCHP_M2MC_SRC_CM_C04)
	"SRC_CM_C04",
#endif
#if defined(BCHP_M2MC_SRC_CM_C10_C11)
	"SRC_CM_C10_C11",
#endif
#if defined(BCHP_M2MC_SRC_CM_C12_C13)
	"SRC_CM_C12_C13",
#endif
#if defined(BCHP_M2MC_SRC_CM_C14)
	"SRC_CM_C14",
#endif
#if defined(BCHP_M2MC_SRC_CM_C20_C21)
	"SRC_CM_C20_C21",
#endif
#if defined(BCHP_M2MC_SRC_CM_C22_C23)
	"SRC_CM_C22_C23",
#endif
#if defined(BCHP_M2MC_SRC_CM_C24)
	"SRC_CM_C24",
#endif
#if defined(BCHP_M2MC_SRC_CM_C30_C31)
	"SRC_CM_C30_C31",
#endif
#if defined(BCHP_M2MC_SRC_CM_C32_C33)
	"SRC_CM_C32_C33",
#endif
#if defined(BCHP_M2MC_SRC_CM_C34)
	"SRC_CM_C34"
#endif
};

static char *s_SRC_CLUT[] =
{
#if BGRC_P_64BITS_ADDR
	"SRC_CLUT starting addr MSB",
	"SRC_CLUT starting addr LSB",
#else
	"SRC_CLUT starting addr"
#endif
};

static char **s_BGRC_PACKET_P_GRP_REGS_NAME[] =
{
	NULL,
	&s_SRC_CLUT[0],
	NULL,
	NULL,
	&s_SRC_CM_REG[0],
	&s_SCALE_COEF_REG[0],
	&s_DEST_COLOR_KEY_REG[0],
	&s_SRC_COLOR_KEY_REG[0],
	&s_ROP_REG[0],
	&s_BLEND_REG[0],
	&s_SCALER_REG[0],
	&s_BLIT_REG[0],
	&s_OUTPUT_FEEDER_REG[0],
	&s_DEST_FEEDER_REG[0],
	&s_SRC_FEEDER_REG[0]
};

static uint32_t s_BGRC_PACKET_P_DeviceGroupSizes[] =
{
	0,
#if BGRC_P_64BITS_ADDR
	sizeof (unsigned long long),
#else
	sizeof (uint32_t),
#endif
	0,
	0,
	BGRC_M2MC(SRC_CM_C34) - BGRC_M2MC(SRC_CM_C00_C01) + sizeof (uint32_t),
	BGRC_M2MC(SRC_CM_C00_C01) - BGRC_M2MC(HORIZ_FIR_0_COEFF_PHASE0_01),
	BGRC_M2MC(HORIZ_FIR_0_COEFF_PHASE0_01) - BGRC_M2MC(DEST_COLOR_KEY_HIGH),
	BGRC_M2MC(DEST_COLOR_KEY_HIGH) - BGRC_M2MC(SRC_COLOR_KEY_HIGH),
	BGRC_M2MC(SRC_COLOR_KEY_HIGH) - BGRC_M2MC(ROP_OPERATION),
	BGRC_M2MC(ROP_OPERATION) - BGRC_M2MC(BLEND_COLOR_OP),
	BGRC_M2MC(BLEND_COLOR_OP) - BGRC_M2MC(SCALER_CTRL),
#if ((BGRC_M2MC(SCALER_CTRL) - BGRC_M2MC(BLIT_CTRL)) == 8) && !defined(BCHP_M2MC_DCEG_CFG)
	BGRC_M2MC(SCALER_CTRL) - 4 - BGRC_M2MC(BLIT_HEADER),
#else
	BGRC_M2MC(SCALER_CTRL) - BGRC_M2MC(BLIT_HEADER),
#endif
#if (BGRC_P_64BITS_ADDR)
	BGRC_M2MC(BLIT_HEADER) - BGRC_M2MC(OUTPUT_FEEDER_ENABLE) - 8,
	BGRC_M2MC(OUTPUT_FEEDER_ENABLE) - BGRC_M2MC(DEST_FEEDER_ENABLE) - 8,
	BGRC_M2MC(DEST_FEEDER_ENABLE) - BGRC_M2MC(SRC_FEEDER_ENABLE) - 8
#else
	BGRC_M2MC(BLIT_HEADER) - BGRC_M2MC(OUTPUT_FEEDER_ENABLE),
	BGRC_M2MC(OUTPUT_FEEDER_ENABLE) - BGRC_M2MC(DEST_FEEDER_ENABLE),
	BGRC_M2MC(DEST_FEEDER_ENABLE) - BGRC_M2MC(SRC_FEEDER_ENABLE)
#endif
};

int main(void)
{
	uint32_t ulAddr, ulValue;
	uint32_t ulMask, ulNext = 0;
	int groups = sizeof s_BGRC_PACKET_P_DeviceGroupSizes / sizeof (uint32_t);
	int ii, jj;
	bool bLast = 0;
	bool bLocked = 0;
	bool bTryHead2 = 0;
	bool bFirstLine = 1;
#if (BGRC_P_64BITS_ADDR)
	uint32_t ulPrevAddr, ulPrevValue;
#endif

	/* assert for packet change with new chips */
	for( ii = groups - 1; ii >= 4; --ii )
	{
		if (s_BGRC_PACKET_P_DeviceGroupSizes[ii] == sizeof(s_BGRC_PACKET_P_GRP_REGS_NAME[ii]))
		{
			printf("Size mismatch with name group starting at %s, porting needed\n", &(s_BGRC_PACKET_P_GRP_REGS_NAME[ii][0]));
			return 0;
		}
	}

	while (!bLast && (2==scanf("%x,%x", &ulAddr, &ulValue)))
	{
		/* handle pkt headr */
		while (1)
		{
			if (!bLocked)
			{
				/* find the starting ptr of the 1st valid pkt */
				if (!bTryHead2)
				{
					if (((ulValue > ulAddr) && (ulValue <= ulAddr + PKT_MAX_SIZE)) ||
						((bFirstLine) && (ulValue == 0x1)))
					{
						bTryHead2 = 1;
						ulNext = ulValue;
					}
					else
					{
#if (BGRC_P_64BITS_ADDR)
						if (ulPrevAddr)
							printf("0x%08x,0x%08x  ...\n", ulPrevAddr, ulPrevValue);
						ulPrevAddr = ulAddr;
						ulPrevValue = ulValue;
#else
						printf("0x%08x,0x%08x  ...\n", ulAddr, ulValue);
#endif
					}

					bFirstLine = 0;
					if (2!=scanf("%x,%x", &ulAddr, &ulValue))
						return 0;
				}
				else
				{
					if ((0 != ulValue) && (0 == (ulValue & ~PKT_FULL_GRP_MSK)))
					{
						/* locked! */
						bLocked = 1;
						ulMask = ulValue;
#if (BGRC_P_64BITS_ADDR)
						printf("0x%08x,0x%08x <-- next_high\n", ulPrevAddr, ulPrevValue);
						printf("0x%08x,0x%08x <-- next_low\n", ulAddr - 4, ulNext);
#else
						printf("0x%08x,0x%08x <-- next\n", ulAddr - 4, ulNext);
#endif
						printf("0x%08x,0x%8x     grp mask\n", ulAddr, ulMask);
						break;
					}
					else
					{
						/* try to match head 1 again */
						bTryHead2 = 0;
						printf("0x%08x,0x%08x  ... broken\n", ulAddr - 4, ulNext);
					}
				}
			}
			else /* handle following pkt */
			{
				if (ulAddr == ulNext)
				{
#if (BGRC_P_64BITS_ADDR)
					printf("0x%08x,0x%08x <-- next_high\n", ulAddr, ulValue);
					if (2!=scanf("%x,%x", &ulAddr, &ulValue))
						return;
					printf("0x%08x,0x%08x <-- next_low\n", ulAddr, ulValue);
#else
					printf("0x%08x,0x%08x <-- next\n", ulAddr, ulValue);
#endif
					ulNext = ulValue;

					if (ulValue == 1)
					{
						bLast = 1;
					}


					if (2!=scanf("%x,%x", &ulAddr, &ulMask))
						return;
					printf("0x%08x,0x%8x     grp mask\n", ulAddr, ulMask);

					break;
				}
				else
				{
					printf("0x%08x,0x%08x  ...\n", ulAddr, ulValue);
					if (2!=scanf("%x,%x", &ulAddr, &ulValue))
						return 0;
				}
			}
		}

		/* pkt body */
		for( ii = groups - 1; ii >= 0; --ii )
		{
			uint32_t group_mask = ulMask & (1 << ii);
			if( group_mask )
			{
				int count = s_BGRC_PACKET_P_DeviceGroupSizes[ii] / 4;
				char **pName = s_BGRC_PACKET_P_GRP_REGS_NAME[ii];
				for( jj = 0; jj < count; ++jj )
				{
					if (2!=scanf("%x,%x", &ulAddr, &ulValue))
					{
						printf("... ...\n");
						return 0;
					}

					if (jj==0)
						printf("0x%08x,0x%08x %s(%d)\n", ulAddr, ulValue, *pName, count);
					else
						printf("0x%08x,0x%08x %s\n", ulAddr, ulValue, *(pName+jj));
				}
			}
		}
	}

	return 0;
}
