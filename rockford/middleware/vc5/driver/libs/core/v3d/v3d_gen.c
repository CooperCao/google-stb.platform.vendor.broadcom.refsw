/*=============================================================================
Broadcom Proprietary and Confidential. (c)2014 Broadcom.
All rights reserved.
*** Do not edit this file. It is automatically generated by scripts/codegen/codegen.py ***
=============================================================================*/
#include "libs/util/gfx_util/gfx_util.h"
#include "v3d_common.h"
#include "v3d_gen.h"
#include <stddef.h>
#include <stdio.h>
const char *v3d_maybe_desc_threading(v3d_threading_t threading)
{
   switch (threading) {
   case V3D_THREADING_T1: return "t1";
   case V3D_THREADING_T2: return "t2";
   case V3D_THREADING_T4: return "t4";
   default:               return NULL;
   }
}
const char *v3d_desc_threading(v3d_threading_t threading)
{
   const char *desc = v3d_maybe_desc_threading(threading);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_attr_type(v3d_attr_type_t attr_type)
{
   switch (attr_type) {
   case V3D_ATTR_TYPE_DISABLED:      return "disabled";
   case V3D_ATTR_TYPE_HALF_FLOAT:    return "half_float";
   case V3D_ATTR_TYPE_FLOAT:         return "float";
   case V3D_ATTR_TYPE_FIXED:         return "fixed";
   case V3D_ATTR_TYPE_BYTE:          return "byte";
   case V3D_ATTR_TYPE_SHORT:         return "short";
   case V3D_ATTR_TYPE_INT:           return "int";
   case V3D_ATTR_TYPE_INT2_10_10_10: return "int2_10_10_10";
   default:                          return NULL;
   }
}
const char *v3d_desc_attr_type(v3d_attr_type_t attr_type)
{
   const char *desc = v3d_maybe_desc_attr_type(attr_type);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tmu_type(v3d_tmu_type_t tmu_type)
{
   switch (tmu_type)
   {
   case V3D_TMU_TYPE_YCBCR_LUMA:
   case V3D_TMU_TYPE_YCBCR_420_CHROMA:
   case V3D_TMU_TYPE_R8I:
   case V3D_TMU_TYPE_R8UI:
   case V3D_TMU_TYPE_RG8I:
   case V3D_TMU_TYPE_RG8UI:
   case V3D_TMU_TYPE_RGBA8I:
   case V3D_TMU_TYPE_RGBA8UI:
   case V3D_TMU_TYPE_R16I:
   case V3D_TMU_TYPE_R16UI:
   case V3D_TMU_TYPE_RG16I:
   case V3D_TMU_TYPE_RG16UI:
   case V3D_TMU_TYPE_RGBA16I:
   case V3D_TMU_TYPE_RGBA16UI:
   case V3D_TMU_TYPE_R32I:
   case V3D_TMU_TYPE_R32UI:
   case V3D_TMU_TYPE_RG32I:
   case V3D_TMU_TYPE_RG32UI:
   case V3D_TMU_TYPE_RGBA32I:
   case V3D_TMU_TYPE_RGBA32UI:
   case V3D_TMU_TYPE_RGB10_A2UI:
   case V3D_TMU_TYPE_R8:
   case V3D_TMU_TYPE_R8_SNORM:
   case V3D_TMU_TYPE_RG8:
   case V3D_TMU_TYPE_RG8_SNORM:
   case V3D_TMU_TYPE_RGBA8:
   case V3D_TMU_TYPE_RGBA8_SNORM:
   case V3D_TMU_TYPE_RGB565:
   case V3D_TMU_TYPE_RGBA4:
   case V3D_TMU_TYPE_RGB5_A1:
   case V3D_TMU_TYPE_RGB10_A2:
   case V3D_TMU_TYPE_R16:
   case V3D_TMU_TYPE_R16_SNORM:
   case V3D_TMU_TYPE_RG16:
   case V3D_TMU_TYPE_RG16_SNORM:
   case V3D_TMU_TYPE_RGBA16:
   case V3D_TMU_TYPE_RGBA16_SNORM:
   case V3D_TMU_TYPE_R16F:
   case V3D_TMU_TYPE_RG16F:
   case V3D_TMU_TYPE_RGBA16F:
   case V3D_TMU_TYPE_R11F_G11F_B10F:
   case V3D_TMU_TYPE_RGB9_E5:
   case V3D_TMU_TYPE_DEPTH_COMP16:
   case V3D_TMU_TYPE_DEPTH_COMP24:
   case V3D_TMU_TYPE_DEPTH_COMP32F:
   case V3D_TMU_TYPE_DEPTH24_X8:
   case V3D_TMU_TYPE_R4:
   case V3D_TMU_TYPE_R1:
   case V3D_TMU_TYPE_S8:
   case V3D_TMU_TYPE_S16:
   case V3D_TMU_TYPE_R32F:
   case V3D_TMU_TYPE_RG32F:
   case V3D_TMU_TYPE_RGBA32F:
   case V3D_TMU_TYPE_C_RGB8_ETC2:
   case V3D_TMU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
   case V3D_TMU_TYPE_C_R11_EAC:
   case V3D_TMU_TYPE_C_SIGNED_R11_EAC:
   case V3D_TMU_TYPE_C_RG11_EAC:
   case V3D_TMU_TYPE_C_SIGNED_RG11_EAC:
   case V3D_TMU_TYPE_C_RGBA8_ETC2_EAC:
   case V3D_TMU_TYPE_C_BC1:
   case V3D_TMU_TYPE_C_BC2:
   case V3D_TMU_TYPE_C_BC3:
   case V3D_TMU_TYPE_C_ASTC_4X4:
   case V3D_TMU_TYPE_C_ASTC_5X4:
   case V3D_TMU_TYPE_C_ASTC_5X5:
   case V3D_TMU_TYPE_C_ASTC_6X5:
   case V3D_TMU_TYPE_C_ASTC_6X6:
   case V3D_TMU_TYPE_C_ASTC_8X5:
   case V3D_TMU_TYPE_C_ASTC_8X6:
   case V3D_TMU_TYPE_C_ASTC_8X8:
   case V3D_TMU_TYPE_C_ASTC_10X5:
   case V3D_TMU_TYPE_C_ASTC_10X6:
   case V3D_TMU_TYPE_C_ASTC_10X8:
   case V3D_TMU_TYPE_C_ASTC_10X10:
   case V3D_TMU_TYPE_C_ASTC_12X10:
   case V3D_TMU_TYPE_C_ASTC_12X12:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tmu_type(v3d_tmu_type_t tmu_type)
{
   switch (tmu_type) {
   case V3D_TMU_TYPE_YCBCR_LUMA:                      return "ycbcr_luma";
   case V3D_TMU_TYPE_YCBCR_420_CHROMA:                return "ycbcr_420_chroma";
   case V3D_TMU_TYPE_R8I:                             return "r8i";
   case V3D_TMU_TYPE_R8UI:                            return "r8ui";
   case V3D_TMU_TYPE_RG8I:                            return "rg8i";
   case V3D_TMU_TYPE_RG8UI:                           return "rg8ui";
   case V3D_TMU_TYPE_RGBA8I:                          return "rgba8i";
   case V3D_TMU_TYPE_RGBA8UI:                         return "rgba8ui";
   case V3D_TMU_TYPE_R16I:                            return "r16i";
   case V3D_TMU_TYPE_R16UI:                           return "r16ui";
   case V3D_TMU_TYPE_RG16I:                           return "rg16i";
   case V3D_TMU_TYPE_RG16UI:                          return "rg16ui";
   case V3D_TMU_TYPE_RGBA16I:                         return "rgba16i";
   case V3D_TMU_TYPE_RGBA16UI:                        return "rgba16ui";
   case V3D_TMU_TYPE_R32I:                            return "r32i";
   case V3D_TMU_TYPE_R32UI:                           return "r32ui";
   case V3D_TMU_TYPE_RG32I:                           return "rg32i";
   case V3D_TMU_TYPE_RG32UI:                          return "rg32ui";
   case V3D_TMU_TYPE_RGBA32I:                         return "rgba32i";
   case V3D_TMU_TYPE_RGBA32UI:                        return "rgba32ui";
   case V3D_TMU_TYPE_RGB10_A2UI:                      return "rgb10_a2ui";
   case V3D_TMU_TYPE_R8:                              return "r8";
   case V3D_TMU_TYPE_R8_SNORM:                        return "r8_snorm";
   case V3D_TMU_TYPE_RG8:                             return "rg8";
   case V3D_TMU_TYPE_RG8_SNORM:                       return "rg8_snorm";
   case V3D_TMU_TYPE_RGBA8:                           return "rgba8";
   case V3D_TMU_TYPE_RGBA8_SNORM:                     return "rgba8_snorm";
   case V3D_TMU_TYPE_RGB565:                          return "rgb565";
   case V3D_TMU_TYPE_RGBA4:                           return "rgba4";
   case V3D_TMU_TYPE_RGB5_A1:                         return "rgb5_a1";
   case V3D_TMU_TYPE_RGB10_A2:                        return "rgb10_a2";
   case V3D_TMU_TYPE_R16:                             return "r16";
   case V3D_TMU_TYPE_R16_SNORM:                       return "r16_snorm";
   case V3D_TMU_TYPE_RG16:                            return "rg16";
   case V3D_TMU_TYPE_RG16_SNORM:                      return "rg16_snorm";
   case V3D_TMU_TYPE_RGBA16:                          return "rgba16";
   case V3D_TMU_TYPE_RGBA16_SNORM:                    return "rgba16_snorm";
   case V3D_TMU_TYPE_R16F:                            return "r16f";
   case V3D_TMU_TYPE_RG16F:                           return "rg16f";
   case V3D_TMU_TYPE_RGBA16F:                         return "rgba16f";
   case V3D_TMU_TYPE_R11F_G11F_B10F:                  return "r11f_g11f_b10f";
   case V3D_TMU_TYPE_RGB9_E5:                         return "rgb9_e5";
   case V3D_TMU_TYPE_DEPTH_COMP16:                    return "depth_comp16";
   case V3D_TMU_TYPE_DEPTH_COMP24:                    return "depth_comp24";
   case V3D_TMU_TYPE_DEPTH_COMP32F:                   return "depth_comp32f";
   case V3D_TMU_TYPE_DEPTH24_X8:                      return "depth24_x8";
   case V3D_TMU_TYPE_R4:                              return "r4";
   case V3D_TMU_TYPE_R1:                              return "r1";
   case V3D_TMU_TYPE_S8:                              return "s8";
   case V3D_TMU_TYPE_S16:                             return "s16";
   case V3D_TMU_TYPE_R32F:                            return "r32f";
   case V3D_TMU_TYPE_RG32F:                           return "rg32f";
   case V3D_TMU_TYPE_RGBA32F:                         return "rgba32f";
   case V3D_TMU_TYPE_C_RGB8_ETC2:                     return "c_rgb8_etc2";
   case V3D_TMU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: return "c_rgb8_punchthrough_alpha1_etc2";
   case V3D_TMU_TYPE_C_R11_EAC:                       return "c_r11_eac";
   case V3D_TMU_TYPE_C_SIGNED_R11_EAC:                return "c_signed_r11_eac";
   case V3D_TMU_TYPE_C_RG11_EAC:                      return "c_rg11_eac";
   case V3D_TMU_TYPE_C_SIGNED_RG11_EAC:               return "c_signed_rg11_eac";
   case V3D_TMU_TYPE_C_RGBA8_ETC2_EAC:                return "c_rgba8_etc2_eac";
   case V3D_TMU_TYPE_C_BC1:                           return "c_bc1";
   case V3D_TMU_TYPE_C_BC2:                           return "c_bc2";
   case V3D_TMU_TYPE_C_BC3:                           return "c_bc3";
   case V3D_TMU_TYPE_C_ASTC_4X4:                      return "c_astc_4x4";
   case V3D_TMU_TYPE_C_ASTC_5X4:                      return "c_astc_5x4";
   case V3D_TMU_TYPE_C_ASTC_5X5:                      return "c_astc_5x5";
   case V3D_TMU_TYPE_C_ASTC_6X5:                      return "c_astc_6x5";
   case V3D_TMU_TYPE_C_ASTC_6X6:                      return "c_astc_6x6";
   case V3D_TMU_TYPE_C_ASTC_8X5:                      return "c_astc_8x5";
   case V3D_TMU_TYPE_C_ASTC_8X6:                      return "c_astc_8x6";
   case V3D_TMU_TYPE_C_ASTC_8X8:                      return "c_astc_8x8";
   case V3D_TMU_TYPE_C_ASTC_10X5:                     return "c_astc_10x5";
   case V3D_TMU_TYPE_C_ASTC_10X6:                     return "c_astc_10x6";
   case V3D_TMU_TYPE_C_ASTC_10X8:                     return "c_astc_10x8";
   case V3D_TMU_TYPE_C_ASTC_10X10:                    return "c_astc_10x10";
   case V3D_TMU_TYPE_C_ASTC_12X10:                    return "c_astc_12x10";
   case V3D_TMU_TYPE_C_ASTC_12X12:                    return "c_astc_12x12";
   default:                                           return NULL;
   }
}
const char *v3d_desc_tmu_type(v3d_tmu_type_t tmu_type)
{
   const char *desc = v3d_maybe_desc_tmu_type(tmu_type);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tfu_type(v3d_tfu_type_t tfu_type)
{
   switch (tfu_type)
   {
   case V3D_TFU_TYPE_YUV_420_2PLANE_REC709:
   case V3D_TFU_TYPE_YUV_420_2PLANE_REC601:
   case V3D_TFU_TYPE_YUV_420_2PLANE_JPEG:
   case V3D_TFU_TYPE_YUV_422_2PLANE_REC709:
   case V3D_TFU_TYPE_YUV_422_2PLANE_REC601:
   case V3D_TFU_TYPE_YUV_422_2PLANE_JPEG:
   case V3D_TFU_TYPE_YUYV_422_1PLANE_REC709:
   case V3D_TFU_TYPE_YUYV_422_1PLANE_REC601:
   case V3D_TFU_TYPE_YUYV_422_1PLANE_JPEG:
   case V3D_TFU_TYPE_YUV_420_3PLANE_REC601:
   case V3D_TFU_TYPE_YUV_420_3PLANE_REC709:
   case V3D_TFU_TYPE_YUV_420_3PLANE_JPEG:
   case V3D_TFU_TYPE_R8:
   case V3D_TFU_TYPE_R8_SNORM:
   case V3D_TFU_TYPE_RG8:
   case V3D_TFU_TYPE_RG8_SNORM:
   case V3D_TFU_TYPE_RGBA8:
   case V3D_TFU_TYPE_RGBA8_SNORM:
   case V3D_TFU_TYPE_RGB565:
   case V3D_TFU_TYPE_RGBA4:
   case V3D_TFU_TYPE_RGB5_A1:
   case V3D_TFU_TYPE_RGB10_A2:
   case V3D_TFU_TYPE_R16:
   case V3D_TFU_TYPE_R16_SNORM:
   case V3D_TFU_TYPE_RG16:
   case V3D_TFU_TYPE_RG16_SNORM:
   case V3D_TFU_TYPE_RGBA16:
   case V3D_TFU_TYPE_RGBA16_SNORM:
   case V3D_TFU_TYPE_R16F:
   case V3D_TFU_TYPE_RG16F:
   case V3D_TFU_TYPE_RGBA16F:
   case V3D_TFU_TYPE_R11F_G11F_B10F:
   case V3D_TFU_TYPE_RGB9_E5:
   case V3D_TFU_TYPE_DEPTH_COMP16:
   case V3D_TFU_TYPE_DEPTH_COMP24:
   case V3D_TFU_TYPE_DEPTH_COMP32F:
   case V3D_TFU_TYPE_DEPTH24_X8:
   case V3D_TFU_TYPE_R4:
   case V3D_TFU_TYPE_R1:
   case V3D_TFU_TYPE_S8:
   case V3D_TFU_TYPE_S16:
   case V3D_TFU_TYPE_R32F:
   case V3D_TFU_TYPE_RG32F:
   case V3D_TFU_TYPE_RGBA32F:
   case V3D_TFU_TYPE_C_RGB8_ETC2:
   case V3D_TFU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
   case V3D_TFU_TYPE_C_R11_EAC:
   case V3D_TFU_TYPE_C_SIGNED_R11_EAC:
   case V3D_TFU_TYPE_C_RG11_EAC:
   case V3D_TFU_TYPE_C_SIGNED_RG11_EAC:
   case V3D_TFU_TYPE_C_RGBA8_ETC2_EAC:
   case V3D_TFU_TYPE_C_BC1:
   case V3D_TFU_TYPE_C_BC2:
   case V3D_TFU_TYPE_C_BC3:
   case V3D_TFU_TYPE_C_ASTC_4X4:
   case V3D_TFU_TYPE_C_ASTC_5X4:
   case V3D_TFU_TYPE_C_ASTC_5X5:
   case V3D_TFU_TYPE_C_ASTC_6X5:
   case V3D_TFU_TYPE_C_ASTC_6X6:
   case V3D_TFU_TYPE_C_ASTC_8X5:
   case V3D_TFU_TYPE_C_ASTC_8X6:
   case V3D_TFU_TYPE_C_ASTC_8X8:
   case V3D_TFU_TYPE_C_ASTC_10X5:
   case V3D_TFU_TYPE_C_ASTC_10X6:
   case V3D_TFU_TYPE_C_ASTC_10X8:
   case V3D_TFU_TYPE_C_ASTC_10X10:
   case V3D_TFU_TYPE_C_ASTC_12X10:
   case V3D_TFU_TYPE_C_ASTC_12X12:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tfu_type(v3d_tfu_type_t tfu_type)
{
   switch (tfu_type) {
   case V3D_TFU_TYPE_YUV_420_2PLANE_REC709:           return "yuv_420_2plane_rec709";
   case V3D_TFU_TYPE_YUV_420_2PLANE_REC601:           return "yuv_420_2plane_rec601";
   case V3D_TFU_TYPE_YUV_420_2PLANE_JPEG:             return "yuv_420_2plane_jpeg";
   case V3D_TFU_TYPE_YUV_422_2PLANE_REC709:           return "yuv_422_2plane_rec709";
   case V3D_TFU_TYPE_YUV_422_2PLANE_REC601:           return "yuv_422_2plane_rec601";
   case V3D_TFU_TYPE_YUV_422_2PLANE_JPEG:             return "yuv_422_2plane_jpeg";
   case V3D_TFU_TYPE_YUYV_422_1PLANE_REC709:          return "yuyv_422_1plane_rec709";
   case V3D_TFU_TYPE_YUYV_422_1PLANE_REC601:          return "yuyv_422_1plane_rec601";
   case V3D_TFU_TYPE_YUYV_422_1PLANE_JPEG:            return "yuyv_422_1plane_jpeg";
   case V3D_TFU_TYPE_YUV_420_3PLANE_REC601:           return "yuv_420_3plane_rec601";
   case V3D_TFU_TYPE_YUV_420_3PLANE_REC709:           return "yuv_420_3plane_rec709";
   case V3D_TFU_TYPE_YUV_420_3PLANE_JPEG:             return "yuv_420_3plane_jpeg";
   case V3D_TFU_TYPE_R8:                              return "r8";
   case V3D_TFU_TYPE_R8_SNORM:                        return "r8_snorm";
   case V3D_TFU_TYPE_RG8:                             return "rg8";
   case V3D_TFU_TYPE_RG8_SNORM:                       return "rg8_snorm";
   case V3D_TFU_TYPE_RGBA8:                           return "rgba8";
   case V3D_TFU_TYPE_RGBA8_SNORM:                     return "rgba8_snorm";
   case V3D_TFU_TYPE_RGB565:                          return "rgb565";
   case V3D_TFU_TYPE_RGBA4:                           return "rgba4";
   case V3D_TFU_TYPE_RGB5_A1:                         return "rgb5_a1";
   case V3D_TFU_TYPE_RGB10_A2:                        return "rgb10_a2";
   case V3D_TFU_TYPE_R16:                             return "r16";
   case V3D_TFU_TYPE_R16_SNORM:                       return "r16_snorm";
   case V3D_TFU_TYPE_RG16:                            return "rg16";
   case V3D_TFU_TYPE_RG16_SNORM:                      return "rg16_snorm";
   case V3D_TFU_TYPE_RGBA16:                          return "rgba16";
   case V3D_TFU_TYPE_RGBA16_SNORM:                    return "rgba16_snorm";
   case V3D_TFU_TYPE_R16F:                            return "r16f";
   case V3D_TFU_TYPE_RG16F:                           return "rg16f";
   case V3D_TFU_TYPE_RGBA16F:                         return "rgba16f";
   case V3D_TFU_TYPE_R11F_G11F_B10F:                  return "r11f_g11f_b10f";
   case V3D_TFU_TYPE_RGB9_E5:                         return "rgb9_e5";
   case V3D_TFU_TYPE_DEPTH_COMP16:                    return "depth_comp16";
   case V3D_TFU_TYPE_DEPTH_COMP24:                    return "depth_comp24";
   case V3D_TFU_TYPE_DEPTH_COMP32F:                   return "depth_comp32f";
   case V3D_TFU_TYPE_DEPTH24_X8:                      return "depth24_x8";
   case V3D_TFU_TYPE_R4:                              return "r4";
   case V3D_TFU_TYPE_R1:                              return "r1";
   case V3D_TFU_TYPE_S8:                              return "s8";
   case V3D_TFU_TYPE_S16:                             return "s16";
   case V3D_TFU_TYPE_R32F:                            return "r32f";
   case V3D_TFU_TYPE_RG32F:                           return "rg32f";
   case V3D_TFU_TYPE_RGBA32F:                         return "rgba32f";
   case V3D_TFU_TYPE_C_RGB8_ETC2:                     return "c_rgb8_etc2";
   case V3D_TFU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: return "c_rgb8_punchthrough_alpha1_etc2";
   case V3D_TFU_TYPE_C_R11_EAC:                       return "c_r11_eac";
   case V3D_TFU_TYPE_C_SIGNED_R11_EAC:                return "c_signed_r11_eac";
   case V3D_TFU_TYPE_C_RG11_EAC:                      return "c_rg11_eac";
   case V3D_TFU_TYPE_C_SIGNED_RG11_EAC:               return "c_signed_rg11_eac";
   case V3D_TFU_TYPE_C_RGBA8_ETC2_EAC:                return "c_rgba8_etc2_eac";
   case V3D_TFU_TYPE_C_BC1:                           return "c_bc1";
   case V3D_TFU_TYPE_C_BC2:                           return "c_bc2";
   case V3D_TFU_TYPE_C_BC3:                           return "c_bc3";
   case V3D_TFU_TYPE_C_ASTC_4X4:                      return "c_astc_4x4";
   case V3D_TFU_TYPE_C_ASTC_5X4:                      return "c_astc_5x4";
   case V3D_TFU_TYPE_C_ASTC_5X5:                      return "c_astc_5x5";
   case V3D_TFU_TYPE_C_ASTC_6X5:                      return "c_astc_6x5";
   case V3D_TFU_TYPE_C_ASTC_6X6:                      return "c_astc_6x6";
   case V3D_TFU_TYPE_C_ASTC_8X5:                      return "c_astc_8x5";
   case V3D_TFU_TYPE_C_ASTC_8X6:                      return "c_astc_8x6";
   case V3D_TFU_TYPE_C_ASTC_8X8:                      return "c_astc_8x8";
   case V3D_TFU_TYPE_C_ASTC_10X5:                     return "c_astc_10x5";
   case V3D_TFU_TYPE_C_ASTC_10X6:                     return "c_astc_10x6";
   case V3D_TFU_TYPE_C_ASTC_10X8:                     return "c_astc_10x8";
   case V3D_TFU_TYPE_C_ASTC_10X10:                    return "c_astc_10x10";
   case V3D_TFU_TYPE_C_ASTC_12X10:                    return "c_astc_12x10";
   case V3D_TFU_TYPE_C_ASTC_12X12:                    return "c_astc_12x12";
   default:                                           return NULL;
   }
}
const char *v3d_desc_tfu_type(v3d_tfu_type_t tfu_type)
{
   const char *desc = v3d_maybe_desc_tfu_type(tfu_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tmu_wrap(v3d_tmu_wrap_t tmu_wrap)
{
   switch (tmu_wrap) {
   case V3D_TMU_WRAP_REPEAT:      return "repeat";
   case V3D_TMU_WRAP_CLAMP:       return "clamp";
   case V3D_TMU_WRAP_MIRROR:      return "mirror";
   case V3D_TMU_WRAP_BORDER:      return "border";
   case V3D_TMU_WRAP_MIRROR_ONCE: return "mirror_once";
   default:                       return NULL;
   }
}
const char *v3d_desc_tmu_wrap(v3d_tmu_wrap_t tmu_wrap)
{
   const char *desc = v3d_maybe_desc_tmu_wrap(tmu_wrap);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tmu_wrap_i(v3d_tmu_wrap_i_t tmu_wrap_i)
{
   switch (tmu_wrap_i) {
   case V3D_TMU_WRAP_I_CLAMP:  return "clamp";
   case V3D_TMU_WRAP_I_BORDER: return "border";
   default:                    return NULL;
   }
}
const char *v3d_desc_tmu_wrap_i(v3d_tmu_wrap_i_t tmu_wrap_i)
{
   const char *desc = v3d_maybe_desc_tmu_wrap_i(tmu_wrap_i);
   assert(desc);
   return desc;
}
#if !V3D_HAS_NEW_TMU_CFG
const char *v3d_maybe_desc_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0)
{
   switch (tmu_wrap_cfg0) {
   case V3D_TMU_WRAP_CFG0_REPEAT: return "repeat";
   case V3D_TMU_WRAP_CFG0_CLAMP:  return "clamp";
   case V3D_TMU_WRAP_CFG0_MIRROR: return "mirror";
   case V3D_TMU_WRAP_CFG0_1D:     return "1d";
   default:                       return NULL;
   }
}
const char *v3d_desc_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0)
{
   const char *desc = v3d_maybe_desc_tmu_wrap_cfg0(tmu_wrap_cfg0);
   assert(desc);
   return desc;
}
#endif
const char *v3d_maybe_desc_tmu_filter(v3d_tmu_filter_t tmu_filter)
{
   switch (tmu_filter) {
   case V3D_TMU_FILTER_MIN_LIN_MAG_LIN:            return "min_lin_mag_lin";
   case V3D_TMU_FILTER_MIN_LIN_MAG_NEAR:           return "min_lin_mag_near";
   case V3D_TMU_FILTER_MIN_NEAR_MAG_LIN:           return "min_near_mag_lin";
   case V3D_TMU_FILTER_MIN_NEAR_MAG_NEAR:          return "min_near_mag_near";
   case V3D_TMU_FILTER_MIN_NEAR_MIP_NEAR_MAG_LIN:  return "min_near_mip_near_mag_lin";
   case V3D_TMU_FILTER_MIN_NEAR_MIP_NEAR_MAG_NEAR: return "min_near_mip_near_mag_near";
   case V3D_TMU_FILTER_MIN_NEAR_MIP_LIN_MAG_LIN:   return "min_near_mip_lin_mag_lin";
   case V3D_TMU_FILTER_MIN_NEAR_MIP_LIN_MAG_NEAR:  return "min_near_mip_lin_mag_near";
   case V3D_TMU_FILTER_MIN_LIN_MIP_NEAR_MAG_LIN:   return "min_lin_mip_near_mag_lin";
   case V3D_TMU_FILTER_MIN_LIN_MIP_NEAR_MAG_NEAR:  return "min_lin_mip_near_mag_near";
   case V3D_TMU_FILTER_MIN_LIN_MIP_LIN_MAG_LIN:    return "min_lin_mip_lin_mag_lin";
   case V3D_TMU_FILTER_MIN_LIN_MIP_LIN_MAG_NEAR:   return "min_lin_mip_lin_mag_near";
   case V3D_TMU_FILTER_ANISOTROPIC2:               return "anisotropic2";
   case V3D_TMU_FILTER_ANISOTROPIC4:               return "anisotropic4";
   case V3D_TMU_FILTER_ANISOTROPIC8:               return "anisotropic8";
   case V3D_TMU_FILTER_ANISOTROPIC16:              return "anisotropic16";
   default:                                        return NULL;
   }
}
const char *v3d_desc_tmu_filter(v3d_tmu_filter_t tmu_filter)
{
   const char *desc = v3d_maybe_desc_tmu_filter(tmu_filter);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tmu_ltype(v3d_tmu_ltype_t tmu_ltype)
{
   switch (tmu_ltype)
   {
   case V3D_TMU_LTYPE_2D:
   case V3D_TMU_LTYPE_2D_ARRAY:
   case V3D_TMU_LTYPE_3D:
   case V3D_TMU_LTYPE_CUBE_MAP:
   case V3D_TMU_LTYPE_1D:
   case V3D_TMU_LTYPE_1D_ARRAY:
   case V3D_TMU_LTYPE_CHILD_IMAGE:
#if V3D_HAS_NEW_TMU_CFG
   case V3D_TMU_LTYPE_CUBE_MAP_ARRAY:
#endif
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tmu_ltype(v3d_tmu_ltype_t tmu_ltype)
{
   switch (tmu_ltype) {
   case V3D_TMU_LTYPE_2D:             return "2d";
   case V3D_TMU_LTYPE_2D_ARRAY:       return "2d_array";
   case V3D_TMU_LTYPE_3D:             return "3d";
   case V3D_TMU_LTYPE_CUBE_MAP:       return "cube_map";
   case V3D_TMU_LTYPE_1D:             return "1d";
   case V3D_TMU_LTYPE_1D_ARRAY:       return "1d_array";
   case V3D_TMU_LTYPE_CHILD_IMAGE:    return "child_image";
#if V3D_HAS_NEW_TMU_CFG
   case V3D_TMU_LTYPE_CUBE_MAP_ARRAY: return "cube_map_array";
#endif
   default:                           return NULL;
   }
}
const char *v3d_desc_tmu_ltype(v3d_tmu_ltype_t tmu_ltype)
{
   const char *desc = v3d_maybe_desc_tmu_ltype(tmu_ltype);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle)
{
   switch (tmu_swizzle) {
   case V3D_TMU_SWIZZLE_0: return "0";
   case V3D_TMU_SWIZZLE_1: return "1";
   case V3D_TMU_SWIZZLE_R: return "r";
   case V3D_TMU_SWIZZLE_G: return "g";
   case V3D_TMU_SWIZZLE_B: return "b";
   case V3D_TMU_SWIZZLE_A: return "a";
   default:                return NULL;
   }
}
const char *v3d_desc_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle)
{
   const char *desc = v3d_maybe_desc_tmu_swizzle(tmu_swizzle);
   assert(desc);
   return desc;
}
#if !V3D_HAS_NEW_TMU_CFG
const char *v3d_maybe_desc_tmu_output_type(v3d_tmu_output_type_t tmu_output_type)
{
   switch (tmu_output_type) {
   case V3D_TMU_OUTPUT_TYPE_16:   return "16";
   case V3D_TMU_OUTPUT_TYPE_32:   return "32";
   case V3D_TMU_OUTPUT_TYPE_AUTO: return "auto";
   default:                       return NULL;
   }
}
const char *v3d_desc_tmu_output_type(v3d_tmu_output_type_t tmu_output_type)
{
   const char *desc = v3d_maybe_desc_tmu_output_type(tmu_output_type);
   assert(desc);
   return desc;
}
#endif
const char *v3d_maybe_desc_tmu_general_type(v3d_tmu_general_type_t tmu_general_type)
{
   switch (tmu_general_type) {
   case V3D_TMU_GENERAL_TYPE_S8:   return "s8";
   case V3D_TMU_GENERAL_TYPE_S16:  return "s16";
   case V3D_TMU_GENERAL_TYPE_VEC2: return "vec2";
   case V3D_TMU_GENERAL_TYPE_VEC3: return "vec3";
   case V3D_TMU_GENERAL_TYPE_VEC4: return "vec4";
   case V3D_TMU_GENERAL_TYPE_8:    return "8";
   case V3D_TMU_GENERAL_TYPE_16:   return "16";
   case V3D_TMU_GENERAL_TYPE_32:   return "32";
   default:                        return NULL;
   }
}
const char *v3d_desc_tmu_general_type(v3d_tmu_general_type_t tmu_general_type)
{
   const char *desc = v3d_maybe_desc_tmu_general_type(tmu_general_type);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tmu_op(v3d_tmu_op_t tmu_op)
{
   switch (tmu_op)
   {
   case V3D_TMU_OP_WR_ADD_RD_PREFETCH:
   case V3D_TMU_OP_WR_SUB_RD_CLEAR:
   case V3D_TMU_OP_WR_XCHG_RD_FLUSH:
   case V3D_TMU_OP_WR_CMPXCHG_RD_CLEAN:
   case V3D_TMU_OP_WR_UMIN_RD_FULL_L1_CLEAR:
   case V3D_TMU_OP_WR_UMAX:
   case V3D_TMU_OP_WR_SMIN:
   case V3D_TMU_OP_WR_SMAX:
   case V3D_TMU_OP_WR_AND_RD_INC:
   case V3D_TMU_OP_WR_OR_RD_DEC:
   case V3D_TMU_OP_WR_XOR_RD_NOT:
   case V3D_TMU_OP_REGULAR:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tmu_op(v3d_tmu_op_t tmu_op)
{
   switch (tmu_op) {
   case V3D_TMU_OP_WR_ADD_RD_PREFETCH:       return "wr_add_rd_prefetch";
   case V3D_TMU_OP_WR_SUB_RD_CLEAR:          return "wr_sub_rd_clear";
   case V3D_TMU_OP_WR_XCHG_RD_FLUSH:         return "wr_xchg_rd_flush";
   case V3D_TMU_OP_WR_CMPXCHG_RD_CLEAN:      return "wr_cmpxchg_rd_clean";
   case V3D_TMU_OP_WR_UMIN_RD_FULL_L1_CLEAR: return "wr_umin_rd_full_l1_clear";
   case V3D_TMU_OP_WR_UMAX:                  return "wr_umax";
   case V3D_TMU_OP_WR_SMIN:                  return "wr_smin";
   case V3D_TMU_OP_WR_SMAX:                  return "wr_smax";
   case V3D_TMU_OP_WR_AND_RD_INC:            return "wr_and_rd_inc";
   case V3D_TMU_OP_WR_OR_RD_DEC:             return "wr_or_rd_dec";
   case V3D_TMU_OP_WR_XOR_RD_NOT:            return "wr_xor_rd_not";
   case V3D_TMU_OP_REGULAR:                  return "regular";
   default:                                  return NULL;
   }
}
const char *v3d_desc_tmu_op(v3d_tmu_op_t tmu_op)
{
   const char *desc = v3d_maybe_desc_tmu_op(tmu_op);
   assert(desc);
   return desc;
}
#if V3D_HAS_NEW_TMU_CFG
bool v3d_is_valid_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol)
{
   switch (tmu_std_bcol)
   {
   case V3D_TMU_STD_BCOL_0000:
   case V3D_TMU_STD_BCOL_0001:
   case V3D_TMU_STD_BCOL_1111:
   case V3D_TMU_STD_BCOL_NON_STD:
   return true;
   default:
      return false;
   }
}
#endif
#if V3D_HAS_NEW_TMU_CFG
const char *v3d_maybe_desc_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol)
{
   switch (tmu_std_bcol) {
   case V3D_TMU_STD_BCOL_0000:    return "0000";
   case V3D_TMU_STD_BCOL_0001:    return "0001";
   case V3D_TMU_STD_BCOL_1111:    return "1111";
   case V3D_TMU_STD_BCOL_NON_STD: return "non_std";
   default:                       return NULL;
   }
}
const char *v3d_desc_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol)
{
   const char *desc = v3d_maybe_desc_tmu_std_bcol(tmu_std_bcol);
   assert(desc);
   return desc;
}
#endif
const char *v3d_maybe_desc_shader_type(v3d_shader_type_t shader_type)
{
   switch (shader_type) {
   case V3D_SHADER_TYPE_VERTEX: return "vertex";
   case V3D_SHADER_TYPE_TESSC:  return "tessc";
   case V3D_SHADER_TYPE_TESSE:  return "tesse";
   case V3D_SHADER_TYPE_GEOM:   return "geom";
   case V3D_SHADER_TYPE_FRAG:   return "frag";
   case V3D_SHADER_TYPE_USER:   return "user";
   default:                     return NULL;
   }
}
const char *v3d_desc_shader_type(v3d_shader_type_t shader_type)
{
   const char *desc = v3d_maybe_desc_shader_type(shader_type);
   assert(desc);
   return desc;
}
bool v3d_is_valid_qpu_opcode(v3d_qpu_opcode_t qpu_opcode)
{
   switch (qpu_opcode)
   {
   case V3D_QPU_OP_NOP:
   case V3D_QPU_OP_TIDX:
   case V3D_QPU_OP_EIDX:
   case V3D_QPU_OP_LR:
   case V3D_QPU_OP_VFLA:
   case V3D_QPU_OP_VFLNA:
   case V3D_QPU_OP_VFLB:
   case V3D_QPU_OP_VFLNB:
   case V3D_QPU_OP_FXCD:
   case V3D_QPU_OP_XCD:
   case V3D_QPU_OP_FYCD:
   case V3D_QPU_OP_YCD:
   case V3D_QPU_OP_MSF:
   case V3D_QPU_OP_REVF:
   case V3D_QPU_OP_IID:
   case V3D_QPU_OP_SAMPID:
   case V3D_QPU_OP_PATCHID:
   case V3D_QPU_OP_TMUWT:
   case V3D_QPU_OP_VPMWT:
   case V3D_QPU_OP_NOT:
   case V3D_QPU_OP_NEG:
   case V3D_QPU_OP_FLAPUSH:
   case V3D_QPU_OP_FLBPUSH:
   case V3D_QPU_OP_FLPOP:
   case V3D_QPU_OP_SETMSF:
   case V3D_QPU_OP_SETREVF:
   case V3D_QPU_OP_VPMSETUP:
   case V3D_QPU_OP_FROUND:
   case V3D_QPU_OP_FTOIN:
   case V3D_QPU_OP_FTRUNC:
   case V3D_QPU_OP_FTOIZ:
   case V3D_QPU_OP_FFLOOR:
   case V3D_QPU_OP_FTOUZ:
   case V3D_QPU_OP_FCEIL:
   case V3D_QPU_OP_FTOC:
   case V3D_QPU_OP_FDX:
   case V3D_QPU_OP_FDY:
   case V3D_QPU_OP_ITOF:
   case V3D_QPU_OP_CLZ:
   case V3D_QPU_OP_UTOF:
   case V3D_QPU_OP_FMOV:
   case V3D_QPU_OP_MOV:
   case V3D_QPU_OP_LDVPMV_IN:
   case V3D_QPU_OP_LDVPMV_OUT:
   case V3D_QPU_OP_LDVPMD_IN:
   case V3D_QPU_OP_LDVPMD_OUT:
   case V3D_QPU_OP_LDVPMP:
   case V3D_QPU_OP_TMUWRCFG:
   case V3D_QPU_OP_TLBWRCFG:
   case V3D_QPU_OP_VPMWRCFG:
   case V3D_QPU_OP_VFMOV:
   case V3D_QPU_OP_VFMOVABS:
   case V3D_QPU_OP_VFMOVNEG:
   case V3D_QPU_OP_VFMOVNAB:
   case V3D_QPU_OP_VFABSMOV:
   case V3D_QPU_OP_VFABS:
   case V3D_QPU_OP_VFABSNEG:
   case V3D_QPU_OP_VFABSNAB:
   case V3D_QPU_OP_VFNEGMOV:
   case V3D_QPU_OP_VFNEGABS:
   case V3D_QPU_OP_VFNEG:
   case V3D_QPU_OP_VFNEGNAB:
   case V3D_QPU_OP_VFNABMOV:
   case V3D_QPU_OP_VFNABABS:
   case V3D_QPU_OP_VFNABNEG:
   case V3D_QPU_OP_VFNABS:
   case V3D_QPU_OP_FADD:
   case V3D_QPU_OP_FADDNF:
   case V3D_QPU_OP_FSUB:
   case V3D_QPU_OP_FMIN:
   case V3D_QPU_OP_FMAX:
   case V3D_QPU_OP_FCMP:
   case V3D_QPU_OP_FMUL:
   case V3D_QPU_OP_VFPACK:
   case V3D_QPU_OP_VFMIN:
   case V3D_QPU_OP_VFMAX:
   case V3D_QPU_OP_VFMUL:
   case V3D_QPU_OP_ADD:
   case V3D_QPU_OP_SUB:
   case V3D_QPU_OP_MIN:
   case V3D_QPU_OP_MAX:
   case V3D_QPU_OP_UMIN:
   case V3D_QPU_OP_UMAX:
   case V3D_QPU_OP_SMUL24:
   case V3D_QPU_OP_UMUL24:
   case V3D_QPU_OP_MULTOP:
   case V3D_QPU_OP_VADD:
   case V3D_QPU_OP_VSUB:
   case V3D_QPU_OP_SHL:
   case V3D_QPU_OP_SHR:
   case V3D_QPU_OP_ASR:
   case V3D_QPU_OP_ROR:
   case V3D_QPU_OP_AND:
   case V3D_QPU_OP_OR:
   case V3D_QPU_OP_XOR:
   case V3D_QPU_OP_STVPMV:
   case V3D_QPU_OP_STVPMD:
   case V3D_QPU_OP_STVPMP:
   case V3D_QPU_OP_LDVPMG_IN:
   case V3D_QPU_OP_LDVPMG_OUT:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_qpu_opcode(v3d_qpu_opcode_t qpu_opcode)
{
   switch (qpu_opcode) {
   case V3D_QPU_OP_NOP:        return "nop";
   case V3D_QPU_OP_TIDX:       return "tidx";
   case V3D_QPU_OP_EIDX:       return "eidx";
   case V3D_QPU_OP_LR:         return "lr";
   case V3D_QPU_OP_VFLA:       return "vfla";
   case V3D_QPU_OP_VFLNA:      return "vflna";
   case V3D_QPU_OP_VFLB:       return "vflb";
   case V3D_QPU_OP_VFLNB:      return "vflnb";
   case V3D_QPU_OP_FXCD:       return "fxcd";
   case V3D_QPU_OP_XCD:        return "xcd";
   case V3D_QPU_OP_FYCD:       return "fycd";
   case V3D_QPU_OP_YCD:        return "ycd";
   case V3D_QPU_OP_MSF:        return "msf";
   case V3D_QPU_OP_REVF:       return "revf";
   case V3D_QPU_OP_IID:        return "iid";
   case V3D_QPU_OP_SAMPID:     return "sampid";
   case V3D_QPU_OP_PATCHID:    return "patchid";
   case V3D_QPU_OP_TMUWT:      return "tmuwt";
   case V3D_QPU_OP_VPMWT:      return "vpmwt";
   case V3D_QPU_OP_NOT:        return "not";
   case V3D_QPU_OP_NEG:        return "neg";
   case V3D_QPU_OP_FLAPUSH:    return "flapush";
   case V3D_QPU_OP_FLBPUSH:    return "flbpush";
   case V3D_QPU_OP_FLPOP:      return "flpop";
   case V3D_QPU_OP_SETMSF:     return "setmsf";
   case V3D_QPU_OP_SETREVF:    return "setrevf";
   case V3D_QPU_OP_VPMSETUP:   return "vpmsetup";
   case V3D_QPU_OP_FROUND:     return "fround";
   case V3D_QPU_OP_FTOIN:      return "ftoin";
   case V3D_QPU_OP_FTRUNC:     return "ftrunc";
   case V3D_QPU_OP_FTOIZ:      return "ftoiz";
   case V3D_QPU_OP_FFLOOR:     return "ffloor";
   case V3D_QPU_OP_FTOUZ:      return "ftouz";
   case V3D_QPU_OP_FCEIL:      return "fceil";
   case V3D_QPU_OP_FTOC:       return "ftoc";
   case V3D_QPU_OP_FDX:        return "fdx";
   case V3D_QPU_OP_FDY:        return "fdy";
   case V3D_QPU_OP_ITOF:       return "itof";
   case V3D_QPU_OP_CLZ:        return "clz";
   case V3D_QPU_OP_UTOF:       return "utof";
   case V3D_QPU_OP_FMOV:       return "fmov";
   case V3D_QPU_OP_MOV:        return "mov";
   case V3D_QPU_OP_LDVPMV_IN:  return "ldvpmv_in";
   case V3D_QPU_OP_LDVPMV_OUT: return "ldvpmv_out";
   case V3D_QPU_OP_LDVPMD_IN:  return "ldvpmd_in";
   case V3D_QPU_OP_LDVPMD_OUT: return "ldvpmd_out";
   case V3D_QPU_OP_LDVPMP:     return "ldvpmp";
   case V3D_QPU_OP_TMUWRCFG:   return "tmuwrcfg";
   case V3D_QPU_OP_TLBWRCFG:   return "tlbwrcfg";
   case V3D_QPU_OP_VPMWRCFG:   return "vpmwrcfg";
   case V3D_QPU_OP_VFMOV:      return "vfmov";
   case V3D_QPU_OP_VFMOVABS:   return "vfmovabs";
   case V3D_QPU_OP_VFMOVNEG:   return "vfmovneg";
   case V3D_QPU_OP_VFMOVNAB:   return "vfmovnab";
   case V3D_QPU_OP_VFABSMOV:   return "vfabsmov";
   case V3D_QPU_OP_VFABS:      return "vfabs";
   case V3D_QPU_OP_VFABSNEG:   return "vfabsneg";
   case V3D_QPU_OP_VFABSNAB:   return "vfabsnab";
   case V3D_QPU_OP_VFNEGMOV:   return "vfnegmov";
   case V3D_QPU_OP_VFNEGABS:   return "vfnegabs";
   case V3D_QPU_OP_VFNEG:      return "vfneg";
   case V3D_QPU_OP_VFNEGNAB:   return "vfnegnab";
   case V3D_QPU_OP_VFNABMOV:   return "vfnabmov";
   case V3D_QPU_OP_VFNABABS:   return "vfnababs";
   case V3D_QPU_OP_VFNABNEG:   return "vfnabneg";
   case V3D_QPU_OP_VFNABS:     return "vfnabs";
   case V3D_QPU_OP_FADD:       return "fadd";
   case V3D_QPU_OP_FADDNF:     return "faddnf";
   case V3D_QPU_OP_FSUB:       return "fsub";
   case V3D_QPU_OP_FMIN:       return "fmin";
   case V3D_QPU_OP_FMAX:       return "fmax";
   case V3D_QPU_OP_FCMP:       return "fcmp";
   case V3D_QPU_OP_FMUL:       return "fmul";
   case V3D_QPU_OP_VFPACK:     return "vfpack";
   case V3D_QPU_OP_VFMIN:      return "vfmin";
   case V3D_QPU_OP_VFMAX:      return "vfmax";
   case V3D_QPU_OP_VFMUL:      return "vfmul";
   case V3D_QPU_OP_ADD:        return "add";
   case V3D_QPU_OP_SUB:        return "sub";
   case V3D_QPU_OP_MIN:        return "min";
   case V3D_QPU_OP_MAX:        return "max";
   case V3D_QPU_OP_UMIN:       return "umin";
   case V3D_QPU_OP_UMAX:       return "umax";
   case V3D_QPU_OP_SMUL24:     return "smul24";
   case V3D_QPU_OP_UMUL24:     return "umul24";
   case V3D_QPU_OP_MULTOP:     return "multop";
   case V3D_QPU_OP_VADD:       return "vadd";
   case V3D_QPU_OP_VSUB:       return "vsub";
   case V3D_QPU_OP_SHL:        return "shl";
   case V3D_QPU_OP_SHR:        return "shr";
   case V3D_QPU_OP_ASR:        return "asr";
   case V3D_QPU_OP_ROR:        return "ror";
   case V3D_QPU_OP_AND:        return "and";
   case V3D_QPU_OP_OR:         return "or";
   case V3D_QPU_OP_XOR:        return "xor";
   case V3D_QPU_OP_STVPMV:     return "stvpmv";
   case V3D_QPU_OP_STVPMD:     return "stvpmd";
   case V3D_QPU_OP_STVPMP:     return "stvpmp";
   case V3D_QPU_OP_LDVPMG_IN:  return "ldvpmg_in";
   case V3D_QPU_OP_LDVPMG_OUT: return "ldvpmg_out";
   default:                    return NULL;
   }
}
const char *v3d_desc_qpu_opcode(v3d_qpu_opcode_t qpu_opcode)
{
   const char *desc = v3d_maybe_desc_qpu_opcode(qpu_opcode);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_setf(v3d_qpu_setf_t qpu_setf)
{
   switch (qpu_setf) {
   case V3D_QPU_SETF_NONE:  return "none";
   case V3D_QPU_SETF_PUSHZ: return "pushz";
   case V3D_QPU_SETF_PUSHN: return "pushn";
   case V3D_QPU_SETF_PUSHC: return "pushc";
   case V3D_QPU_SETF_ANDZ:  return "andz";
   case V3D_QPU_SETF_ANDNZ: return "andnz";
   case V3D_QPU_SETF_NORNZ: return "nornz";
   case V3D_QPU_SETF_NORZ:  return "norz";
   case V3D_QPU_SETF_ANDN:  return "andn";
   case V3D_QPU_SETF_ANDNN: return "andnn";
   case V3D_QPU_SETF_NORNN: return "nornn";
   case V3D_QPU_SETF_NORN:  return "norn";
   case V3D_QPU_SETF_ANDC:  return "andc";
   case V3D_QPU_SETF_ANDNC: return "andnc";
   case V3D_QPU_SETF_NORNC: return "nornc";
   case V3D_QPU_SETF_NORC:  return "norc";
   default:                 return NULL;
   }
}
const char *v3d_desc_qpu_setf(v3d_qpu_setf_t qpu_setf)
{
   const char *desc = v3d_maybe_desc_qpu_setf(qpu_setf);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_cond(v3d_qpu_cond_t qpu_cond)
{
   switch (qpu_cond) {
   case V3D_QPU_COND_IFA:    return "ifa";
   case V3D_QPU_COND_IFB:    return "ifb";
   case V3D_QPU_COND_IFNA:   return "ifna";
   case V3D_QPU_COND_IFNB:   return "ifnb";
   case V3D_QPU_COND_ALWAYS: return "always";
   default:                  return NULL;
   }
}
const char *v3d_desc_qpu_cond(v3d_qpu_cond_t qpu_cond)
{
   const char *desc = v3d_maybe_desc_qpu_cond(qpu_cond);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_unpack(v3d_qpu_unpack_t qpu_unpack)
{
   switch (qpu_unpack) {
   case V3D_QPU_UNPACK_32F_ABS:              return "32f_abs";
   case V3D_QPU_UNPACK_NONE:                 return "none";
   case V3D_QPU_UNPACK_16F_LOW_TO_32F:       return "16f_low_to_32f";
   case V3D_QPU_UNPACK_16F_HIGH_TO_32F:      return "16f_high_to_32f";
   case V3D_QPU_UNPACK_32F_TO_16F_REPLICATE: return "32f_to_16f_replicate";
   case V3D_QPU_UNPACK_REPLICATE_LOW_16:     return "replicate_low_16";
   case V3D_QPU_UNPACK_REPLICATE_HIGH_16:    return "replicate_high_16";
   case V3D_QPU_UNPACK_SWAP_16:              return "swap_16";
   default:                                  return NULL;
   }
}
const char *v3d_desc_qpu_unpack(v3d_qpu_unpack_t qpu_unpack)
{
   const char *desc = v3d_maybe_desc_qpu_unpack(qpu_unpack);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_pack(v3d_qpu_pack_t qpu_pack)
{
   switch (qpu_pack) {
   case V3D_QPU_PACK_NONE:            return "none";
   case V3D_QPU_PACK_32F_TO_16F_LOW:  return "32f_to_16f_low";
   case V3D_QPU_PACK_32F_TO_16F_HIGH: return "32f_to_16f_high";
   default:                           return NULL;
   }
}
const char *v3d_desc_qpu_pack(v3d_qpu_pack_t qpu_pack)
{
   const char *desc = v3d_maybe_desc_qpu_pack(qpu_pack);
   assert(desc);
   return desc;
}
bool v3d_is_valid_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr)
{
   switch (qpu_magic_waddr)
   {
   case V3D_QPU_MAGIC_WADDR_R0:
   case V3D_QPU_MAGIC_WADDR_R1:
   case V3D_QPU_MAGIC_WADDR_R2:
   case V3D_QPU_MAGIC_WADDR_R3:
   case V3D_QPU_MAGIC_WADDR_R4:
   case V3D_QPU_MAGIC_WADDR_R5QUAD:
   case V3D_QPU_MAGIC_WADDR_NOP:
   case V3D_QPU_MAGIC_WADDR_TLB:
   case V3D_QPU_MAGIC_WADDR_TLBU:
#if !V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMU:
#endif
#if !V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUL:
#endif
   case V3D_QPU_MAGIC_WADDR_TMUD:
   case V3D_QPU_MAGIC_WADDR_TMUA:
   case V3D_QPU_MAGIC_WADDR_TMUAU:
#if !V3D_HAS_LDVPM
   case V3D_QPU_MAGIC_WADDR_VPM:
#endif
#if !V3D_HAS_LDVPM
   case V3D_QPU_MAGIC_WADDR_VPMU:
#endif
   case V3D_QPU_MAGIC_WADDR_SYNC:
   case V3D_QPU_MAGIC_WADDR_SYNCU:
   case V3D_QPU_MAGIC_WADDR_RECIP:
   case V3D_QPU_MAGIC_WADDR_RSQRT:
   case V3D_QPU_MAGIC_WADDR_EXP:
   case V3D_QPU_MAGIC_WADDR_LOG:
   case V3D_QPU_MAGIC_WADDR_SIN:
#if V3D_VER_AT_LEAST(3,3,0,0)
   case V3D_QPU_MAGIC_WADDR_RSQRT2:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUC:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUS:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUT:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUR:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUI:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUB:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUDREF:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUOFF:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSCM:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSFETCH:
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSLOD:
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHS:
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSCM:
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSFETCH:
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSLOD:
#endif
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr)
{
   switch (qpu_magic_waddr) {
   case V3D_QPU_MAGIC_WADDR_R0:         return "r0";
   case V3D_QPU_MAGIC_WADDR_R1:         return "r1";
   case V3D_QPU_MAGIC_WADDR_R2:         return "r2";
   case V3D_QPU_MAGIC_WADDR_R3:         return "r3";
   case V3D_QPU_MAGIC_WADDR_R4:         return "r4";
   case V3D_QPU_MAGIC_WADDR_R5QUAD:     return "r5quad";
   case V3D_QPU_MAGIC_WADDR_NOP:        return "nop";
   case V3D_QPU_MAGIC_WADDR_TLB:        return "tlb";
   case V3D_QPU_MAGIC_WADDR_TLBU:       return "tlbu";
#if !V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMU:        return "tmu";
#endif
#if !V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUL:       return "tmul";
#endif
   case V3D_QPU_MAGIC_WADDR_TMUD:       return "tmud";
   case V3D_QPU_MAGIC_WADDR_TMUA:       return "tmua";
   case V3D_QPU_MAGIC_WADDR_TMUAU:      return "tmuau";
#if !V3D_HAS_LDVPM
   case V3D_QPU_MAGIC_WADDR_VPM:        return "vpm";
#endif
#if !V3D_HAS_LDVPM
   case V3D_QPU_MAGIC_WADDR_VPMU:       return "vpmu";
#endif
   case V3D_QPU_MAGIC_WADDR_SYNC:       return "sync";
   case V3D_QPU_MAGIC_WADDR_SYNCU:      return "syncu";
   case V3D_QPU_MAGIC_WADDR_RECIP:      return "recip";
   case V3D_QPU_MAGIC_WADDR_RSQRT:      return "rsqrt";
   case V3D_QPU_MAGIC_WADDR_EXP:        return "exp";
   case V3D_QPU_MAGIC_WADDR_LOG:        return "log";
   case V3D_QPU_MAGIC_WADDR_SIN:        return "sin";
#if V3D_VER_AT_LEAST(3,3,0,0)
   case V3D_QPU_MAGIC_WADDR_RSQRT2:     return "rsqrt2";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUC:       return "tmuc";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUS:       return "tmus";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUT:       return "tmut";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUR:       return "tmur";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUI:       return "tmui";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUB:       return "tmub";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUDREF:    return "tmudref";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUOFF:     return "tmuoff";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSCM:     return "tmuscm";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSFETCH:  return "tmusfetch";
#endif
#if V3D_HAS_NEW_TMU_CFG
   case V3D_QPU_MAGIC_WADDR_TMUSLOD:    return "tmuslod";
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHS:      return "tmuhs";
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSCM:    return "tmuhscm";
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSFETCH: return "tmuhsfetch";
#endif
#if V3D_HAS_TMU_PRIORITY
   case V3D_QPU_MAGIC_WADDR_TMUHSLOD:   return "tmuhslod";
#endif
   default:                             return NULL;
   }
}
const char *v3d_desc_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr)
{
   const char *desc = v3d_maybe_desc_qpu_magic_waddr(qpu_magic_waddr);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_in_source(v3d_qpu_in_source_t qpu_in_source)
{
   switch (qpu_in_source) {
   case V3D_QPU_IN_SOURCE_R0: return "r0";
   case V3D_QPU_IN_SOURCE_R1: return "r1";
   case V3D_QPU_IN_SOURCE_R2: return "r2";
   case V3D_QPU_IN_SOURCE_R3: return "r3";
   case V3D_QPU_IN_SOURCE_R4: return "r4";
   case V3D_QPU_IN_SOURCE_R5: return "r5";
   case V3D_QPU_IN_SOURCE_A:  return "a";
   case V3D_QPU_IN_SOURCE_B:  return "b";
   default:                   return NULL;
   }
}
const char *v3d_desc_qpu_in_source(v3d_qpu_in_source_t qpu_in_source)
{
   const char *desc = v3d_maybe_desc_qpu_in_source(qpu_in_source);
   assert(desc);
   return desc;
}
bool v3d_is_valid_qpu_bcond(v3d_qpu_bcond_t qpu_bcond)
{
   switch (qpu_bcond)
   {
   case V3D_QPU_BCOND_ALWAYS:
   case V3D_QPU_BCOND_A0:
   case V3D_QPU_BCOND_NA0:
   case V3D_QPU_BCOND_ALLA:
   case V3D_QPU_BCOND_ANYNA:
   case V3D_QPU_BCOND_ANYA:
   case V3D_QPU_BCOND_ALLNA:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_qpu_bcond(v3d_qpu_bcond_t qpu_bcond)
{
   switch (qpu_bcond) {
   case V3D_QPU_BCOND_ALWAYS: return "always";
   case V3D_QPU_BCOND_A0:     return "a0";
   case V3D_QPU_BCOND_NA0:    return "na0";
   case V3D_QPU_BCOND_ALLA:   return "alla";
   case V3D_QPU_BCOND_ANYNA:  return "anyna";
   case V3D_QPU_BCOND_ANYA:   return "anya";
   case V3D_QPU_BCOND_ALLNA:  return "allna";
   default:                   return NULL;
   }
}
const char *v3d_desc_qpu_bcond(v3d_qpu_bcond_t qpu_bcond)
{
   const char *desc = v3d_maybe_desc_qpu_bcond(qpu_bcond);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_msfign(v3d_qpu_msfign_t qpu_msfign)
{
   switch (qpu_msfign) {
   case V3D_QPU_MSFIGN_NONE:  return "none";
   case V3D_QPU_MSFIGN_PIXEL: return "pixel";
   case V3D_QPU_MSFIGN_QUAD:  return "quad";
   default:                   return NULL;
   }
}
const char *v3d_desc_qpu_msfign(v3d_qpu_msfign_t qpu_msfign)
{
   const char *desc = v3d_maybe_desc_qpu_msfign(qpu_msfign);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_bdest(v3d_qpu_bdest_t qpu_bdest)
{
   switch (qpu_bdest) {
   case V3D_QPU_BDEST_ABS:      return "abs";
   case V3D_QPU_BDEST_REL:      return "rel";
   case V3D_QPU_BDEST_LINK_REG: return "link_reg";
   case V3D_QPU_BDEST_REGFILE:  return "regfile";
   default:                     return NULL;
   }
}
const char *v3d_desc_qpu_bdest(v3d_qpu_bdest_t qpu_bdest)
{
   const char *desc = v3d_maybe_desc_qpu_bdest(qpu_bdest);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode)
{
   switch (qpu_ldi_mode) {
   case V3D_QPU_LDI_MODE_32:          return "32";
   case V3D_QPU_LDI_MODE_EL_UNSIGNED: return "el_unsigned";
   case V3D_QPU_LDI_MODE_EL_SIGNED:   return "el_signed";
   default:                           return NULL;
   }
}
const char *v3d_desc_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode)
{
   const char *desc = v3d_maybe_desc_qpu_ldi_mode(qpu_ldi_mode);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tsy_op(v3d_tsy_op_t tsy_op)
{
   switch (tsy_op)
   {
   case V3D_TSY_OP_SET_QUORUM:
   case V3D_TSY_OP_INC_WAITERS:
   case V3D_TSY_OP_DEC_WAITERS:
   case V3D_TSY_OP_INC_QUORUM:
   case V3D_TSY_OP_DEC_QUORUM:
   case V3D_TSY_OP_FREE_ALL:
   case V3D_TSY_OP_RELEASE:
   case V3D_TSY_OP_ACQUIRE:
   case V3D_TSY_OP_WAIT:
   case V3D_TSY_OP_WAIT_INC:
   case V3D_TSY_OP_WAIT_CHECK:
   case V3D_TSY_OP_WAIT_INC_CHECK:
   case V3D_TSY_OP_WAIT_CV:
   case V3D_TSY_OP_INC_SEMAPHORE:
   case V3D_TSY_OP_DEC_SEMAPHORE:
   case V3D_TSY_OP_SET_QUORUM_FREE_ALL:
   case V3D_TSY_OP_IN_DATA:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tsy_op(v3d_tsy_op_t tsy_op)
{
   switch (tsy_op) {
   case V3D_TSY_OP_SET_QUORUM:          return "set_quorum";
   case V3D_TSY_OP_INC_WAITERS:         return "inc_waiters";
   case V3D_TSY_OP_DEC_WAITERS:         return "dec_waiters";
   case V3D_TSY_OP_INC_QUORUM:          return "inc_quorum";
   case V3D_TSY_OP_DEC_QUORUM:          return "dec_quorum";
   case V3D_TSY_OP_FREE_ALL:            return "free_all";
   case V3D_TSY_OP_RELEASE:             return "release";
   case V3D_TSY_OP_ACQUIRE:             return "acquire";
   case V3D_TSY_OP_WAIT:                return "wait";
   case V3D_TSY_OP_WAIT_INC:            return "wait_inc";
   case V3D_TSY_OP_WAIT_CHECK:          return "wait_check";
   case V3D_TSY_OP_WAIT_INC_CHECK:      return "wait_inc_check";
   case V3D_TSY_OP_WAIT_CV:             return "wait_cv";
   case V3D_TSY_OP_INC_SEMAPHORE:       return "inc_semaphore";
   case V3D_TSY_OP_DEC_SEMAPHORE:       return "dec_semaphore";
   case V3D_TSY_OP_SET_QUORUM_FREE_ALL: return "set_quorum_free_all";
   case V3D_TSY_OP_IN_DATA:             return "in_data";
   default:                             return NULL;
   }
}
const char *v3d_desc_tsy_op(v3d_tsy_op_t tsy_op)
{
   const char *desc = v3d_maybe_desc_tsy_op(tsy_op);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type)
{
   switch (tlb_rw_type) {
   case V3D_TLB_RW_TYPE_COLOR_F16:  return "color_f16";
   case V3D_TLB_RW_TYPE_COLOR_32:   return "color_32";
   case V3D_TLB_RW_TYPE_Z:          return "z";
   case V3D_TLB_RW_TYPE_ALPHA_MASK: return "alpha_mask";
   default:                         return NULL;
   }
}
const char *v3d_desc_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type)
{
   const char *desc = v3d_maybe_desc_tlb_rw_type(tlb_rw_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type)
{
   switch (tlb_rw_color_type) {
   case V3D_TLB_RW_COLOR_TYPE_FLOAT16:         return "float16";
   case V3D_TLB_RW_COLOR_TYPE_FLOAT16_SWAPPED: return "float16_swapped";
   case V3D_TLB_RW_COLOR_TYPE_FLOAT32:         return "float32";
   case V3D_TLB_RW_COLOR_TYPE_INT32:           return "int32";
   default:                                    return NULL;
   }
}
const char *v3d_desc_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type)
{
   const char *desc = v3d_maybe_desc_tlb_rw_color_type(tlb_rw_color_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_compare_func(v3d_compare_func_t compare_func)
{
   switch (compare_func) {
   case V3D_COMPARE_FUNC_NEVER:    return "never";
   case V3D_COMPARE_FUNC_LESS:     return "less";
   case V3D_COMPARE_FUNC_EQUAL:    return "equal";
   case V3D_COMPARE_FUNC_LEQUAL:   return "lequal";
   case V3D_COMPARE_FUNC_GREATER:  return "greater";
   case V3D_COMPARE_FUNC_NOTEQUAL: return "notequal";
   case V3D_COMPARE_FUNC_GEQUAL:   return "gequal";
   case V3D_COMPARE_FUNC_ALWAYS:   return "always";
   default:                        return NULL;
   }
}
const char *v3d_desc_compare_func(v3d_compare_func_t compare_func)
{
   const char *desc = v3d_maybe_desc_compare_func(compare_func);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tmu_min_filt(v3d_tmu_min_filt_t tmu_min_filt)
{
   switch (tmu_min_filt) {
   case V3D_TMU_MIN_FILT_LINEAR:        return "linear";
   case V3D_TMU_MIN_FILT_NEAREST:       return "nearest";
   case V3D_TMU_MIN_FILT_NEAR_MIP_NEAR: return "near_mip_near";
   case V3D_TMU_MIN_FILT_NEAR_MIP_LIN:  return "near_mip_lin";
   case V3D_TMU_MIN_FILT_LIN_MIP_NEAR:  return "lin_mip_near";
   case V3D_TMU_MIN_FILT_LIN_MIP_LIN:   return "lin_mip_lin";
   default:                             return NULL;
   }
}
const char *v3d_desc_tmu_min_filt(v3d_tmu_min_filt_t tmu_min_filt)
{
   const char *desc = v3d_maybe_desc_tmu_min_filt(tmu_min_filt);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tmu_mag_filt(v3d_tmu_mag_filt_t tmu_mag_filt)
{
   switch (tmu_mag_filt) {
   case V3D_TMU_MAG_FILT_LINEAR:  return "linear";
   case V3D_TMU_MAG_FILT_NEAREST: return "nearest";
   default:                       return NULL;
   }
}
const char *v3d_desc_tmu_mag_filt(v3d_tmu_mag_filt_t tmu_mag_filt)
{
   const char *desc = v3d_maybe_desc_tmu_mag_filt(tmu_mag_filt);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_ms(v3d_ms_t ms)
{
   switch (ms) {
   case V3D_MS_1X:  return "1x";
   case V3D_MS_4X:  return "4x";
   case V3D_MS_16X: return "16x";
   default:         return NULL;
   }
}
const char *v3d_desc_ms(v3d_ms_t ms)
{
   const char *desc = v3d_maybe_desc_ms(ms);
   assert(desc);
   return desc;
}
bool v3d_is_valid_prim_mode(v3d_prim_mode_t prim_mode)
{
   switch (prim_mode)
   {
   case V3D_PRIM_MODE_POINTS:
   case V3D_PRIM_MODE_LINES:
   case V3D_PRIM_MODE_LINE_LOOP:
   case V3D_PRIM_MODE_LINE_STRIP:
   case V3D_PRIM_MODE_TRIS:
   case V3D_PRIM_MODE_TRI_STRIP:
   case V3D_PRIM_MODE_TRI_FAN:
   case V3D_PRIM_MODE_LINES_ADJ:
   case V3D_PRIM_MODE_LINE_STRIP_ADJ:
   case V3D_PRIM_MODE_TRIS_ADJ:
   case V3D_PRIM_MODE_TRI_STRIP_ADJ:
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_POINTS_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINES_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINE_LOOP_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINE_STRIP_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRIS_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRI_STRIP_TF:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRI_FAN_TF:
#endif
   case V3D_PRIM_MODE_PATCH1:
   case V3D_PRIM_MODE_PATCH2:
   case V3D_PRIM_MODE_PATCH3:
   case V3D_PRIM_MODE_PATCH4:
   case V3D_PRIM_MODE_PATCH5:
   case V3D_PRIM_MODE_PATCH6:
   case V3D_PRIM_MODE_PATCH7:
   case V3D_PRIM_MODE_PATCH8:
   case V3D_PRIM_MODE_PATCH9:
   case V3D_PRIM_MODE_PATCH10:
   case V3D_PRIM_MODE_PATCH11:
   case V3D_PRIM_MODE_PATCH12:
   case V3D_PRIM_MODE_PATCH13:
   case V3D_PRIM_MODE_PATCH14:
   case V3D_PRIM_MODE_PATCH15:
   case V3D_PRIM_MODE_PATCH16:
   case V3D_PRIM_MODE_PATCH17:
   case V3D_PRIM_MODE_PATCH18:
   case V3D_PRIM_MODE_PATCH19:
   case V3D_PRIM_MODE_PATCH20:
   case V3D_PRIM_MODE_PATCH21:
   case V3D_PRIM_MODE_PATCH22:
   case V3D_PRIM_MODE_PATCH23:
   case V3D_PRIM_MODE_PATCH24:
   case V3D_PRIM_MODE_PATCH25:
   case V3D_PRIM_MODE_PATCH26:
   case V3D_PRIM_MODE_PATCH27:
   case V3D_PRIM_MODE_PATCH28:
   case V3D_PRIM_MODE_PATCH29:
   case V3D_PRIM_MODE_PATCH30:
   case V3D_PRIM_MODE_PATCH31:
   case V3D_PRIM_MODE_PATCH32:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_prim_mode(v3d_prim_mode_t prim_mode)
{
   switch (prim_mode) {
   case V3D_PRIM_MODE_POINTS:         return "points";
   case V3D_PRIM_MODE_LINES:          return "lines";
   case V3D_PRIM_MODE_LINE_LOOP:      return "line_loop";
   case V3D_PRIM_MODE_LINE_STRIP:     return "line_strip";
   case V3D_PRIM_MODE_TRIS:           return "tris";
   case V3D_PRIM_MODE_TRI_STRIP:      return "tri_strip";
   case V3D_PRIM_MODE_TRI_FAN:        return "tri_fan";
   case V3D_PRIM_MODE_LINES_ADJ:      return "lines_adj";
   case V3D_PRIM_MODE_LINE_STRIP_ADJ: return "line_strip_adj";
   case V3D_PRIM_MODE_TRIS_ADJ:       return "tris_adj";
   case V3D_PRIM_MODE_TRI_STRIP_ADJ:  return "tri_strip_adj";
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_POINTS_TF:      return "points_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINES_TF:       return "lines_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINE_LOOP_TF:   return "line_loop_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_LINE_STRIP_TF:  return "line_strip_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRIS_TF:        return "tris_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRI_STRIP_TF:   return "tri_strip_tf";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_PRIM_MODE_TRI_FAN_TF:     return "tri_fan_tf";
#endif
   case V3D_PRIM_MODE_PATCH1:         return "patch1";
   case V3D_PRIM_MODE_PATCH2:         return "patch2";
   case V3D_PRIM_MODE_PATCH3:         return "patch3";
   case V3D_PRIM_MODE_PATCH4:         return "patch4";
   case V3D_PRIM_MODE_PATCH5:         return "patch5";
   case V3D_PRIM_MODE_PATCH6:         return "patch6";
   case V3D_PRIM_MODE_PATCH7:         return "patch7";
   case V3D_PRIM_MODE_PATCH8:         return "patch8";
   case V3D_PRIM_MODE_PATCH9:         return "patch9";
   case V3D_PRIM_MODE_PATCH10:        return "patch10";
   case V3D_PRIM_MODE_PATCH11:        return "patch11";
   case V3D_PRIM_MODE_PATCH12:        return "patch12";
   case V3D_PRIM_MODE_PATCH13:        return "patch13";
   case V3D_PRIM_MODE_PATCH14:        return "patch14";
   case V3D_PRIM_MODE_PATCH15:        return "patch15";
   case V3D_PRIM_MODE_PATCH16:        return "patch16";
   case V3D_PRIM_MODE_PATCH17:        return "patch17";
   case V3D_PRIM_MODE_PATCH18:        return "patch18";
   case V3D_PRIM_MODE_PATCH19:        return "patch19";
   case V3D_PRIM_MODE_PATCH20:        return "patch20";
   case V3D_PRIM_MODE_PATCH21:        return "patch21";
   case V3D_PRIM_MODE_PATCH22:        return "patch22";
   case V3D_PRIM_MODE_PATCH23:        return "patch23";
   case V3D_PRIM_MODE_PATCH24:        return "patch24";
   case V3D_PRIM_MODE_PATCH25:        return "patch25";
   case V3D_PRIM_MODE_PATCH26:        return "patch26";
   case V3D_PRIM_MODE_PATCH27:        return "patch27";
   case V3D_PRIM_MODE_PATCH28:        return "patch28";
   case V3D_PRIM_MODE_PATCH29:        return "patch29";
   case V3D_PRIM_MODE_PATCH30:        return "patch30";
   case V3D_PRIM_MODE_PATCH31:        return "patch31";
   case V3D_PRIM_MODE_PATCH32:        return "patch32";
   default:                           return NULL;
   }
}
const char *v3d_desc_prim_mode(v3d_prim_mode_t prim_mode)
{
   const char *desc = v3d_maybe_desc_prim_mode(prim_mode);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_index_type(v3d_index_type_t index_type)
{
   switch (index_type) {
   case V3D_INDEX_TYPE_8BIT:     return "8bit";
   case V3D_INDEX_TYPE_16BIT:    return "16bit";
   case V3D_INDEX_TYPE_32BIT:    return "32bit";
   case V3D_INDEX_TYPE_32BIT_XY: return "32bit_xy";
   default:                      return NULL;
   }
}
const char *v3d_desc_index_type(v3d_index_type_t index_type)
{
   const char *desc = v3d_maybe_desc_index_type(index_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cov_update(v3d_cov_update_t cov_update)
{
   switch (cov_update) {
   case V3D_COV_UPDATE_NONZERO: return "nonzero";
   case V3D_COV_UPDATE_ODD:     return "odd";
   case V3D_COV_UPDATE_OR:      return "or";
   case V3D_COV_UPDATE_ZERO:    return "zero";
   default:                     return NULL;
   }
}
const char *v3d_desc_cov_update(v3d_cov_update_t cov_update)
{
   const char *desc = v3d_maybe_desc_cov_update(cov_update);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_wireframe_mode(v3d_wireframe_mode_t wireframe_mode)
{
   switch (wireframe_mode) {
   case V3D_WIREFRAME_MODE_LINES:  return "lines";
   case V3D_WIREFRAME_MODE_POINTS: return "points";
   default:                        return NULL;
   }
}
const char *v3d_desc_wireframe_mode(v3d_wireframe_mode_t wireframe_mode)
{
   const char *desc = v3d_maybe_desc_wireframe_mode(wireframe_mode);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_blend_eqn(v3d_blend_eqn_t blend_eqn)
{
   switch (blend_eqn) {
   case V3D_BLEND_EQN_ADD:     return "add";
   case V3D_BLEND_EQN_SUB:     return "sub";
   case V3D_BLEND_EQN_RSUB:    return "rsub";
   case V3D_BLEND_EQN_MIN:     return "min";
   case V3D_BLEND_EQN_MAX:     return "max";
   case V3D_BLEND_EQN_MUL:     return "mul";
   case V3D_BLEND_EQN_SCREEN:  return "screen";
   case V3D_BLEND_EQN_DARKEN:  return "darken";
   case V3D_BLEND_EQN_LIGHTEN: return "lighten";
   default:                    return NULL;
   }
}
const char *v3d_desc_blend_eqn(v3d_blend_eqn_t blend_eqn)
{
   const char *desc = v3d_maybe_desc_blend_eqn(blend_eqn);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_blend_mul(v3d_blend_mul_t blend_mul)
{
   switch (blend_mul) {
   case V3D_BLEND_MUL_ZERO:           return "zero";
   case V3D_BLEND_MUL_ONE:            return "one";
   case V3D_BLEND_MUL_SRC:            return "src";
   case V3D_BLEND_MUL_OM_SRC:         return "om_src";
   case V3D_BLEND_MUL_DST:            return "dst";
   case V3D_BLEND_MUL_OM_DST:         return "om_dst";
   case V3D_BLEND_MUL_SRC_ALPHA:      return "src_alpha";
   case V3D_BLEND_MUL_OM_SRC_ALPHA:   return "om_src_alpha";
   case V3D_BLEND_MUL_DST_ALPHA:      return "dst_alpha";
   case V3D_BLEND_MUL_OM_DST_ALPHA:   return "om_dst_alpha";
   case V3D_BLEND_MUL_CONST:          return "const";
   case V3D_BLEND_MUL_OM_CONST:       return "om_const";
   case V3D_BLEND_MUL_CONST_ALPHA:    return "const_alpha";
   case V3D_BLEND_MUL_OM_CONST_ALPHA: return "om_const_alpha";
   case V3D_BLEND_MUL_SRC_ALPHA_SAT:  return "src_alpha_sat";
   default:                           return NULL;
   }
}
const char *v3d_desc_blend_mul(v3d_blend_mul_t blend_mul)
{
   const char *desc = v3d_maybe_desc_blend_mul(blend_mul);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode)
{
   switch (blend_vg_mode) {
   case V3D_BLEND_VG_MODE_NORMAL:      return "normal";
   case V3D_BLEND_VG_MODE_COVERAGE:    return "coverage";
   case V3D_BLEND_VG_MODE_COVERAGE_AM: return "coverage_am";
   default:                            return NULL;
   }
}
const char *v3d_desc_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode)
{
   const char *desc = v3d_maybe_desc_blend_vg_mode(blend_vg_mode);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_ldst_buf(v3d_ldst_buf_t ldst_buf)
{
   switch (ldst_buf) {
   case V3D_LDST_BUF_COLOR0:               return "color0";
   case V3D_LDST_BUF_COLOR1:               return "color1";
   case V3D_LDST_BUF_COLOR2:               return "color2";
   case V3D_LDST_BUF_COLOR3:               return "color3";
   case V3D_LDST_BUF_COLOR4:               return "color4";
   case V3D_LDST_BUF_COLOR5:               return "color5";
   case V3D_LDST_BUF_COLOR6:               return "color6";
   case V3D_LDST_BUF_COLOR7:               return "color7";
   case V3D_LDST_BUF_NONE:                 return "none";
   case V3D_LDST_BUF_DEPTH:                return "depth";
   case V3D_LDST_BUF_STENCIL:              return "stencil";
   case V3D_LDST_BUF_PACKED_DEPTH_STENCIL: return "packed_depth_stencil";
   default:                                return NULL;
   }
}
const char *v3d_desc_ldst_buf(v3d_ldst_buf_t ldst_buf)
{
   const char *desc = v3d_maybe_desc_ldst_buf(ldst_buf);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size)
{
   switch (tile_alloc_block_size) {
   case V3D_TILE_ALLOC_BLOCK_SIZE_64:  return "64";
   case V3D_TILE_ALLOC_BLOCK_SIZE_128: return "128";
   case V3D_TILE_ALLOC_BLOCK_SIZE_256: return "256";
   default:                            return NULL;
   }
}
const char *v3d_desc_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size)
{
   const char *desc = v3d_maybe_desc_tile_alloc_block_size(tile_alloc_block_size);
   assert(desc);
   return desc;
}
v3d_tile_alloc_block_size_t v3d_translate_tile_alloc_block_size(uint32_t x)
{
   switch (x) {
   case 64:  return V3D_TILE_ALLOC_BLOCK_SIZE_64;
   case 128: return V3D_TILE_ALLOC_BLOCK_SIZE_128;
   case 256: return V3D_TILE_ALLOC_BLOCK_SIZE_256;
   default:  unreachable(); return V3D_TILE_ALLOC_BLOCK_SIZE_INVALID;
   }
}
uint32_t v3d_translate_from_tile_alloc_block_size(v3d_tile_alloc_block_size_t x)
{
   switch (x) {
   case V3D_TILE_ALLOC_BLOCK_SIZE_64:  return 64;
   case V3D_TILE_ALLOC_BLOCK_SIZE_128: return 128;
   case V3D_TILE_ALLOC_BLOCK_SIZE_256: return 256;
   default:                            unreachable(); return 0;
   }
}
const char *v3d_maybe_desc_rt_bpp(v3d_rt_bpp_t rt_bpp)
{
   switch (rt_bpp) {
   case V3D_RT_BPP_32:  return "32";
   case V3D_RT_BPP_64:  return "64";
   case V3D_RT_BPP_128: return "128";
   default:             return NULL;
   }
}
const char *v3d_desc_rt_bpp(v3d_rt_bpp_t rt_bpp)
{
   const char *desc = v3d_maybe_desc_rt_bpp(rt_bpp);
   assert(desc);
   return desc;
}
v3d_rt_bpp_t v3d_translate_rt_bpp(uint32_t x)
{
   switch (x) {
   case 32:  return V3D_RT_BPP_32;
   case 64:  return V3D_RT_BPP_64;
   case 128: return V3D_RT_BPP_128;
   default:  unreachable(); return V3D_RT_BPP_INVALID;
   }
}
uint32_t v3d_translate_from_rt_bpp(v3d_rt_bpp_t x)
{
   switch (x) {
   case V3D_RT_BPP_32:  return 32;
   case V3D_RT_BPP_64:  return 64;
   case V3D_RT_BPP_128: return 128;
   default:             unreachable(); return 0;
   }
}
bool v3d_is_valid_rt_type(v3d_rt_type_t rt_type)
{
   switch (rt_type)
   {
   case V3D_RT_TYPE_8I:
   case V3D_RT_TYPE_8UI:
   case V3D_RT_TYPE_8:
   case V3D_RT_TYPE_16I:
   case V3D_RT_TYPE_16UI:
   case V3D_RT_TYPE_16F:
   case V3D_RT_TYPE_32I:
   case V3D_RT_TYPE_32UI:
   case V3D_RT_TYPE_32F:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_rt_type(v3d_rt_type_t rt_type)
{
   switch (rt_type) {
   case V3D_RT_TYPE_8I:   return "8i";
   case V3D_RT_TYPE_8UI:  return "8ui";
   case V3D_RT_TYPE_8:    return "8";
   case V3D_RT_TYPE_16I:  return "16i";
   case V3D_RT_TYPE_16UI: return "16ui";
   case V3D_RT_TYPE_16F:  return "16f";
   case V3D_RT_TYPE_32I:  return "32i";
   case V3D_RT_TYPE_32UI: return "32ui";
   case V3D_RT_TYPE_32F:  return "32f";
   default:               return NULL;
   }
}
const char *v3d_desc_rt_type(v3d_rt_type_t rt_type)
{
   const char *desc = v3d_maybe_desc_rt_type(rt_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_depth_type(v3d_depth_type_t depth_type)
{
   switch (depth_type) {
   case V3D_DEPTH_TYPE_32F: return "32f";
   case V3D_DEPTH_TYPE_24:  return "24";
   case V3D_DEPTH_TYPE_16:  return "16";
   default:                 return NULL;
   }
}
const char *v3d_desc_depth_type(v3d_depth_type_t depth_type)
{
   const char *desc = v3d_maybe_desc_depth_type(depth_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_ez_direction(v3d_ez_direction_t ez_direction)
{
   switch (ez_direction) {
   case V3D_EZ_DIRECTION_LT_LE: return "lt_le";
   case V3D_EZ_DIRECTION_GT_GE: return "gt_ge";
   default:                     return NULL;
   }
}
const char *v3d_desc_ez_direction(v3d_ez_direction_t ez_direction)
{
   const char *desc = v3d_maybe_desc_ez_direction(ez_direction);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_decimate(v3d_decimate_t decimate)
{
   switch (decimate) {
   case V3D_DECIMATE_SAMPLE0:     return "sample0";
   case V3D_DECIMATE_4X:          return "4x";
   case V3D_DECIMATE_16X:         return "16x";
   case V3D_DECIMATE_ALL_SAMPLES: return "all_samples";
   default:                       return NULL;
   }
}
const char *v3d_desc_decimate(v3d_decimate_t decimate)
{
   const char *desc = v3d_maybe_desc_decimate(decimate);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_dither(v3d_dither_t dither)
{
   switch (dither) {
   case V3D_DITHER_OFF:  return "off";
   case V3D_DITHER_RGB:  return "rgb";
   case V3D_DITHER_A:    return "a";
   case V3D_DITHER_RGBA: return "rgba";
   default:              return NULL;
   }
}
const char *v3d_desc_dither(v3d_dither_t dither)
{
   const char *desc = v3d_maybe_desc_dither(dither);
   assert(desc);
   return desc;
}
#if !V3D_HAS_NEW_TLB_CFG
const char *v3d_maybe_desc_depth_format(v3d_depth_format_t depth_format)
{
   switch (depth_format) {
   case V3D_DEPTH_FORMAT_32F:         return "32f";
   case V3D_DEPTH_FORMAT_24:          return "24";
   case V3D_DEPTH_FORMAT_16:          return "16";
   case V3D_DEPTH_FORMAT_24_STENCIL8: return "24_stencil8";
   default:                           return NULL;
   }
}
const char *v3d_desc_depth_format(v3d_depth_format_t depth_format)
{
   const char *desc = v3d_maybe_desc_depth_format(depth_format);
   assert(desc);
   return desc;
}
#endif
bool v3d_is_valid_pixel_format(v3d_pixel_format_t pixel_format)
{
   switch (pixel_format)
   {
   case V3D_PIXEL_FORMAT_SRGB8_ALPHA8:
   case V3D_PIXEL_FORMAT_SRGB8:
   case V3D_PIXEL_FORMAT_RGB10_A2UI:
   case V3D_PIXEL_FORMAT_RGB10_A2:
   case V3D_PIXEL_FORMAT_A1_BGR5:
   case V3D_PIXEL_FORMAT_A1_BGR5_AM:
   case V3D_PIXEL_FORMAT_ABGR4:
   case V3D_PIXEL_FORMAT_BGR565:
   case V3D_PIXEL_FORMAT_R11F_G11F_B10F:
   case V3D_PIXEL_FORMAT_RGBA32F:
   case V3D_PIXEL_FORMAT_RG32F:
   case V3D_PIXEL_FORMAT_R32F:
   case V3D_PIXEL_FORMAT_RGBA32I:
   case V3D_PIXEL_FORMAT_RG32I:
   case V3D_PIXEL_FORMAT_R32I:
   case V3D_PIXEL_FORMAT_RGBA32UI:
   case V3D_PIXEL_FORMAT_RG32UI:
   case V3D_PIXEL_FORMAT_R32UI:
   case V3D_PIXEL_FORMAT_RGBA16F:
   case V3D_PIXEL_FORMAT_RG16F:
   case V3D_PIXEL_FORMAT_R16F:
   case V3D_PIXEL_FORMAT_RGBA16I:
   case V3D_PIXEL_FORMAT_RG16I:
   case V3D_PIXEL_FORMAT_R16I:
   case V3D_PIXEL_FORMAT_RGBA16UI:
   case V3D_PIXEL_FORMAT_RG16UI:
   case V3D_PIXEL_FORMAT_R16UI:
   case V3D_PIXEL_FORMAT_RGBA8:
   case V3D_PIXEL_FORMAT_RGB8:
   case V3D_PIXEL_FORMAT_RG8:
   case V3D_PIXEL_FORMAT_R8:
   case V3D_PIXEL_FORMAT_RGBA8I:
   case V3D_PIXEL_FORMAT_RG8I:
   case V3D_PIXEL_FORMAT_R8I:
   case V3D_PIXEL_FORMAT_RGBA8UI:
   case V3D_PIXEL_FORMAT_RG8UI:
   case V3D_PIXEL_FORMAT_R8UI:
   case V3D_PIXEL_FORMAT_SRGBX8:
   case V3D_PIXEL_FORMAT_RGBX8:
   case V3D_PIXEL_FORMAT_BSTC:
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D32F:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D24:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D16:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D24S8:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_S8:
#endif
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_pixel_format(v3d_pixel_format_t pixel_format)
{
   switch (pixel_format) {
   case V3D_PIXEL_FORMAT_SRGB8_ALPHA8:   return "srgb8_alpha8";
   case V3D_PIXEL_FORMAT_SRGB8:          return "srgb8";
   case V3D_PIXEL_FORMAT_RGB10_A2UI:     return "rgb10_a2ui";
   case V3D_PIXEL_FORMAT_RGB10_A2:       return "rgb10_a2";
   case V3D_PIXEL_FORMAT_A1_BGR5:        return "a1_bgr5";
   case V3D_PIXEL_FORMAT_A1_BGR5_AM:     return "a1_bgr5_am";
   case V3D_PIXEL_FORMAT_ABGR4:          return "abgr4";
   case V3D_PIXEL_FORMAT_BGR565:         return "bgr565";
   case V3D_PIXEL_FORMAT_R11F_G11F_B10F: return "r11f_g11f_b10f";
   case V3D_PIXEL_FORMAT_RGBA32F:        return "rgba32f";
   case V3D_PIXEL_FORMAT_RG32F:          return "rg32f";
   case V3D_PIXEL_FORMAT_R32F:           return "r32f";
   case V3D_PIXEL_FORMAT_RGBA32I:        return "rgba32i";
   case V3D_PIXEL_FORMAT_RG32I:          return "rg32i";
   case V3D_PIXEL_FORMAT_R32I:           return "r32i";
   case V3D_PIXEL_FORMAT_RGBA32UI:       return "rgba32ui";
   case V3D_PIXEL_FORMAT_RG32UI:         return "rg32ui";
   case V3D_PIXEL_FORMAT_R32UI:          return "r32ui";
   case V3D_PIXEL_FORMAT_RGBA16F:        return "rgba16f";
   case V3D_PIXEL_FORMAT_RG16F:          return "rg16f";
   case V3D_PIXEL_FORMAT_R16F:           return "r16f";
   case V3D_PIXEL_FORMAT_RGBA16I:        return "rgba16i";
   case V3D_PIXEL_FORMAT_RG16I:          return "rg16i";
   case V3D_PIXEL_FORMAT_R16I:           return "r16i";
   case V3D_PIXEL_FORMAT_RGBA16UI:       return "rgba16ui";
   case V3D_PIXEL_FORMAT_RG16UI:         return "rg16ui";
   case V3D_PIXEL_FORMAT_R16UI:          return "r16ui";
   case V3D_PIXEL_FORMAT_RGBA8:          return "rgba8";
   case V3D_PIXEL_FORMAT_RGB8:           return "rgb8";
   case V3D_PIXEL_FORMAT_RG8:            return "rg8";
   case V3D_PIXEL_FORMAT_R8:             return "r8";
   case V3D_PIXEL_FORMAT_RGBA8I:         return "rgba8i";
   case V3D_PIXEL_FORMAT_RG8I:           return "rg8i";
   case V3D_PIXEL_FORMAT_R8I:            return "r8i";
   case V3D_PIXEL_FORMAT_RGBA8UI:        return "rgba8ui";
   case V3D_PIXEL_FORMAT_RG8UI:          return "rg8ui";
   case V3D_PIXEL_FORMAT_R8UI:           return "r8ui";
   case V3D_PIXEL_FORMAT_SRGBX8:         return "srgbx8";
   case V3D_PIXEL_FORMAT_RGBX8:          return "rgbx8";
   case V3D_PIXEL_FORMAT_BSTC:           return "bstc";
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D32F:           return "d32f";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D24:            return "d24";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D16:            return "d16";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_D24S8:          return "d24s8";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_PIXEL_FORMAT_S8:             return "s8";
#endif
   default:                              return NULL;
   }
}
const char *v3d_desc_pixel_format(v3d_pixel_format_t pixel_format)
{
   const char *desc = v3d_maybe_desc_pixel_format(pixel_format);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_memory_format(v3d_memory_format_t memory_format)
{
   switch (memory_format) {
   case V3D_MEMORY_FORMAT_RASTER:     return "raster";
   case V3D_MEMORY_FORMAT_LINEARTILE: return "lineartile";
   case V3D_MEMORY_FORMAT_UBLINEAR_1: return "ublinear_1";
   case V3D_MEMORY_FORMAT_UBLINEAR_2: return "ublinear_2";
   case V3D_MEMORY_FORMAT_UIF_NO_XOR: return "uif_no_xor";
   case V3D_MEMORY_FORMAT_UIF_XOR:    return "uif_xor";
   default:                           return NULL;
   }
}
const char *v3d_desc_memory_format(v3d_memory_format_t memory_format)
{
   const char *desc = v3d_maybe_desc_memory_format(memory_format);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format)
{
   switch (ldst_memory_format) {
   case V3D_LDST_MEMORY_FORMAT_UIF_NO_XOR: return "uif_no_xor";
   case V3D_LDST_MEMORY_FORMAT_UIF_XOR:    return "uif_xor";
   default:                                return NULL;
   }
}
const char *v3d_desc_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format)
{
   const char *desc = v3d_maybe_desc_ldst_memory_format(ldst_memory_format);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_stencil_op(v3d_stencil_op_t stencil_op)
{
   switch (stencil_op) {
   case V3D_STENCIL_OP_ZERO:    return "zero";
   case V3D_STENCIL_OP_KEEP:    return "keep";
   case V3D_STENCIL_OP_REPLACE: return "replace";
   case V3D_STENCIL_OP_INCR:    return "incr";
   case V3D_STENCIL_OP_DECR:    return "decr";
   case V3D_STENCIL_OP_INVERT:  return "invert";
   case V3D_STENCIL_OP_INCWRAP: return "incwrap";
   case V3D_STENCIL_OP_DECWRAP: return "decwrap";
   default:                     return NULL;
   }
}
const char *v3d_desc_stencil_op(v3d_stencil_op_t stencil_op)
{
   const char *desc = v3d_maybe_desc_stencil_op(stencil_op);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_flags_action(v3d_flags_action_t flags_action)
{
   switch (flags_action) {
   case V3D_FLAGS_ACTION_KEEP: return "keep";
   case V3D_FLAGS_ACTION_ZERO: return "zero";
   case V3D_FLAGS_ACTION_SET:  return "set";
   default:                    return NULL;
   }
}
const char *v3d_desc_flags_action(v3d_flags_action_t flags_action)
{
   const char *desc = v3d_maybe_desc_flags_action(flags_action);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_bcfg_type(v3d_bcfg_type_t bcfg_type)
{
   switch (bcfg_type) {
   case V3D_BCFG_TYPE_PART1: return "part1";
   case V3D_BCFG_TYPE_PART2: return "part2";
   default:                  return NULL;
   }
}
const char *v3d_desc_bcfg_type(v3d_bcfg_type_t bcfg_type)
{
   const char *desc = v3d_maybe_desc_bcfg_type(bcfg_type);
   assert(desc);
   return desc;
}
bool v3d_is_valid_rcfg_type(v3d_rcfg_type_t rcfg_type)
{
   switch (rcfg_type)
   {
   case V3D_RCFG_TYPE_COMMON:
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_RCFG_TYPE_Z_STENCIL:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_RCFG_TYPE_SEPARATE_STENCIL:
#endif
   case V3D_RCFG_TYPE_COLOR:
   case V3D_RCFG_TYPE_ZS_CLEAR_VALUES:
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART1:
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART2:
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART3:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_rcfg_type(v3d_rcfg_type_t rcfg_type)
{
   switch (rcfg_type) {
   case V3D_RCFG_TYPE_COMMON:             return "common";
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_RCFG_TYPE_Z_STENCIL:          return "z_stencil";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_RCFG_TYPE_SEPARATE_STENCIL:   return "separate_stencil";
#endif
   case V3D_RCFG_TYPE_COLOR:              return "color";
   case V3D_RCFG_TYPE_ZS_CLEAR_VALUES:    return "zs_clear_values";
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART1: return "clear_colors_part1";
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART2: return "clear_colors_part2";
   case V3D_RCFG_TYPE_CLEAR_COLORS_PART3: return "clear_colors_part3";
   default:                               return NULL;
   }
}
const char *v3d_desc_rcfg_type(v3d_rcfg_type_t rcfg_type)
{
   const char *desc = v3d_maybe_desc_rcfg_type(rcfg_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_supertile_order(v3d_supertile_order_t supertile_order)
{
   switch (supertile_order) {
   case V3D_SUPERTILE_ORDER_MORTON: return "morton";
   case V3D_SUPERTILE_ORDER_RASTER: return "raster";
   default:                         return NULL;
   }
}
const char *v3d_desc_supertile_order(v3d_supertile_order_t supertile_order)
{
   const char *desc = v3d_maybe_desc_supertile_order(supertile_order);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord)
{
   switch (tfu_rgbord) {
   case V3D_TFU_RGBORD_RGBA_OR_RG_YUYV_OR_UV: return "rgba_or_rg_yuyv_or_uv";
   case V3D_TFU_RGBORD_ABGR_OR_GR_VYUY_OR_VU: return "abgr_or_gr_vyuy_or_vu";
   case V3D_TFU_RGBORD_ARGB_OR_YYUV:          return "argb_or_yyuv";
   case V3D_TFU_RGBORD_BGRA_OR_VUYY:          return "bgra_or_vuyy";
   default:                                   return NULL;
   }
}
const char *v3d_desc_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord)
{
   const char *desc = v3d_maybe_desc_tfu_rgbord(tfu_rgbord);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tfu_iformat(v3d_tfu_iformat_t tfu_iformat)
{
   switch (tfu_iformat)
   {
   case V3D_TFU_IFORMAT_RASTER:
   case V3D_TFU_IFORMAT_SAND_128:
   case V3D_TFU_IFORMAT_SAND_256:
   case V3D_TFU_IFORMAT_LINEARTILE:
   case V3D_TFU_IFORMAT_UBLINEAR_1:
   case V3D_TFU_IFORMAT_UBLINEAR_2:
   case V3D_TFU_IFORMAT_UIF_NO_XOR:
   case V3D_TFU_IFORMAT_UIF_XOR:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tfu_iformat(v3d_tfu_iformat_t tfu_iformat)
{
   switch (tfu_iformat) {
   case V3D_TFU_IFORMAT_RASTER:     return "raster";
   case V3D_TFU_IFORMAT_SAND_128:   return "sand_128";
   case V3D_TFU_IFORMAT_SAND_256:   return "sand_256";
   case V3D_TFU_IFORMAT_LINEARTILE: return "lineartile";
   case V3D_TFU_IFORMAT_UBLINEAR_1: return "ublinear_1";
   case V3D_TFU_IFORMAT_UBLINEAR_2: return "ublinear_2";
   case V3D_TFU_IFORMAT_UIF_NO_XOR: return "uif_no_xor";
   case V3D_TFU_IFORMAT_UIF_XOR:    return "uif_xor";
   default:                         return NULL;
   }
}
const char *v3d_desc_tfu_iformat(v3d_tfu_iformat_t tfu_iformat)
{
   const char *desc = v3d_maybe_desc_tfu_iformat(tfu_iformat);
   assert(desc);
   return desc;
}
bool v3d_is_valid_tfu_oformat(v3d_tfu_oformat_t tfu_oformat)
{
   switch (tfu_oformat)
   {
   case V3D_TFU_OFORMAT_LINEARTILE:
   case V3D_TFU_OFORMAT_UBLINEAR_1:
   case V3D_TFU_OFORMAT_UBLINEAR_2:
   case V3D_TFU_OFORMAT_UIF_NO_XOR:
   case V3D_TFU_OFORMAT_UIF_XOR:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_tfu_oformat(v3d_tfu_oformat_t tfu_oformat)
{
   switch (tfu_oformat) {
   case V3D_TFU_OFORMAT_LINEARTILE: return "lineartile";
   case V3D_TFU_OFORMAT_UBLINEAR_1: return "ublinear_1";
   case V3D_TFU_OFORMAT_UBLINEAR_2: return "ublinear_2";
   case V3D_TFU_OFORMAT_UIF_NO_XOR: return "uif_no_xor";
   case V3D_TFU_OFORMAT_UIF_XOR:    return "uif_xor";
   default:                         return NULL;
   }
}
const char *v3d_desc_tfu_oformat(v3d_tfu_oformat_t tfu_oformat)
{
   const char *desc = v3d_maybe_desc_tfu_oformat(tfu_oformat);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode)
{
   switch (l2t_flush_mode) {
   case V3D_L2T_FLUSH_MODE_FLUSH: return "flush";
   case V3D_L2T_FLUSH_MODE_CLEAR: return "clear";
   case V3D_L2T_FLUSH_MODE_CLEAN: return "clean";
   default:                       return NULL;
   }
}
const char *v3d_desc_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode)
{
   const char *desc = v3d_maybe_desc_l2t_flush_mode(l2t_flush_mode);
   assert(desc);
   return desc;
}
#if V3D_HAS_NEW_TF
bool v3d_is_valid_pcf_operation(v3d_pcf_operation_t pcf_operation)
{
   switch (pcf_operation)
   {
   case V3D_PCF_OPERATION_ST_PRIM_COUNTS:
   case V3D_PCF_OPERATION_ST_PRIM_COUNTS_AND_ZERO:
   case V3D_PCF_OPERATION_ST_BUF_STATE_RAW:
   case V3D_PCF_OPERATION_ST_BUF_STATE_CL:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT0:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT1:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT2:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT3:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT4:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT5:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT6:
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT7:
   return true;
   default:
      return false;
   }
}
#endif
#if V3D_HAS_NEW_TF
const char *v3d_maybe_desc_pcf_operation(v3d_pcf_operation_t pcf_operation)
{
   switch (pcf_operation) {
   case V3D_PCF_OPERATION_ST_PRIM_COUNTS:          return "st_prim_counts";
   case V3D_PCF_OPERATION_ST_PRIM_COUNTS_AND_ZERO: return "st_prim_counts_and_zero";
   case V3D_PCF_OPERATION_ST_BUF_STATE_RAW:        return "st_buf_state_raw";
   case V3D_PCF_OPERATION_ST_BUF_STATE_CL:         return "st_buf_state_cl";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT0:      return "ld_buf_state_wait0";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT1:      return "ld_buf_state_wait1";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT2:      return "ld_buf_state_wait2";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT3:      return "ld_buf_state_wait3";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT4:      return "ld_buf_state_wait4";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT5:      return "ld_buf_state_wait5";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT6:      return "ld_buf_state_wait6";
   case V3D_PCF_OPERATION_LD_BUF_STATE_WAIT7:      return "ld_buf_state_wait7";
   default:                                        return NULL;
   }
}
const char *v3d_desc_pcf_operation(v3d_pcf_operation_t pcf_operation)
{
   const char *desc = v3d_maybe_desc_pcf_operation(pcf_operation);
   assert(desc);
   return desc;
}
#endif
const char *v3d_maybe_desc_vri_size(v3d_vri_size_t vri_size)
{
   switch (vri_size) {
   case V3D_VRI_SIZE_HALF: return "half";
   case V3D_VRI_SIZE_FULL: return "full";
   default:                return NULL;
   }
}
const char *v3d_desc_vri_size(v3d_vri_size_t vri_size)
{
   const char *desc = v3d_maybe_desc_vri_size(vri_size);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tlb_size(v3d_tlb_size_t tlb_size)
{
   switch (tlb_size) {
   case V3D_TLB_SIZE_QUARTER: return "quarter";
   case V3D_TLB_SIZE_HALF:    return "half";
   case V3D_TLB_SIZE_FULL:    return "full";
   default:                   return NULL;
   }
}
const char *v3d_desc_tlb_size(v3d_tlb_size_t tlb_size)
{
   const char *desc = v3d_maybe_desc_tlb_size(tlb_size);
   assert(desc);
   return desc;
}
bool v3d_is_valid_iuc_size(v3d_iuc_size_t iuc_size)
{
   switch (iuc_size)
   {
   case V3D_IUC_SIZE_1KB:
   case V3D_IUC_SIZE_2KB:
   case V3D_IUC_SIZE_4KB:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_iuc_size(v3d_iuc_size_t iuc_size)
{
   switch (iuc_size) {
   case V3D_IUC_SIZE_1KB: return "1kb";
   case V3D_IUC_SIZE_2KB: return "2kb";
   case V3D_IUC_SIZE_4KB: return "4kb";
   default:               return NULL;
   }
}
const char *v3d_desc_iuc_size(v3d_iuc_size_t iuc_size)
{
   const char *desc = v3d_maybe_desc_iuc_size(iuc_size);
   assert(desc);
   return desc;
}
bool v3d_is_valid_ip_recipient(v3d_ip_recipient_t ip_recipient)
{
   switch (ip_recipient)
   {
   case V3D_IP_RECIPIENT_NONE:
   case V3D_IP_RECIPIENT_7260:
   case V3D_IP_RECIPIENT_TAHITI_B:
   case V3D_IP_RECIPIENT_ARUBA:
   case V3D_IP_RECIPIENT_TAHITI_P:
   case V3D_IP_RECIPIENT_BCG:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_ip_recipient(v3d_ip_recipient_t ip_recipient)
{
   switch (ip_recipient) {
   case V3D_IP_RECIPIENT_NONE:     return "none";
   case V3D_IP_RECIPIENT_7260:     return "7260";
   case V3D_IP_RECIPIENT_TAHITI_B: return "tahiti_b";
   case V3D_IP_RECIPIENT_ARUBA:    return "aruba";
   case V3D_IP_RECIPIENT_TAHITI_P: return "tahiti_p";
   case V3D_IP_RECIPIENT_BCG:      return "bcg";
   default:                        return NULL;
   }
}
const char *v3d_desc_ip_recipient(v3d_ip_recipient_t ip_recipient)
{
   const char *desc = v3d_maybe_desc_ip_recipient(ip_recipient);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_ctsubsrun(v3d_ctsubsrun_t ctsubsrun)
{
   switch (ctsubsrun) {
   case V3D_CTSUBSRUN_STOPPED_AT_END:   return "stopped_at_end";
   case V3D_CTSUBSRUN_STOPPED_AT_HALT:  return "stopped_at_halt";
   case V3D_CTSUBSRUN_RUNNING_NORMALLY: return "running_normally";
   case V3D_CTSUBSRUN_STALLED:          return "stalled";
   default:                             return NULL;
   }
}
const char *v3d_desc_ctsubsrun(v3d_ctsubsrun_t ctsubsrun)
{
   const char *desc = v3d_maybe_desc_ctsubsrun(ctsubsrun);
   assert(desc);
   return desc;
}
bool v3d_is_valid_cl_compr_type(v3d_cl_compr_type_t cl_compr_type)
{
   switch (cl_compr_type)
   {
   case V3D_CL_COMPR_TYPE_C0:
   case V3D_CL_COMPR_TYPE_C1:
   case V3D_CL_COMPR_TYPE_C2:
   case V3D_CL_COMPR_TYPE_C3:
   case V3D_CL_COMPR_TYPE_C4:
   case V3D_CL_COMPR_TYPE_C5:
   case V3D_CL_COMPR_TYPE_C6:
   case V3D_CL_COMPR_TYPE_IID8:
   case V3D_CL_COMPR_TYPE_IID32:
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_REL_BRANCH:
#endif
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_BRANCH:
#endif
   case V3D_CL_COMPR_TYPE_ESCAPE:
   case V3D_CL_COMPR_TYPE_NOT_COMMON:
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_PRIM_ID8:
#endif
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_PRIM_ID32:
#endif
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_CLIPPED_PRIM:
#endif
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_cl_compr_type(v3d_cl_compr_type_t cl_compr_type)
{
   switch (cl_compr_type) {
   case V3D_CL_COMPR_TYPE_C0:           return "c0";
   case V3D_CL_COMPR_TYPE_C1:           return "c1";
   case V3D_CL_COMPR_TYPE_C2:           return "c2";
   case V3D_CL_COMPR_TYPE_C3:           return "c3";
   case V3D_CL_COMPR_TYPE_C4:           return "c4";
   case V3D_CL_COMPR_TYPE_C5:           return "c5";
   case V3D_CL_COMPR_TYPE_C6:           return "c6";
   case V3D_CL_COMPR_TYPE_IID8:         return "iid8";
   case V3D_CL_COMPR_TYPE_IID32:        return "iid32";
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_REL_BRANCH:   return "rel_branch";
#endif
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_BRANCH:       return "branch";
#endif
   case V3D_CL_COMPR_TYPE_ESCAPE:       return "escape";
   case V3D_CL_COMPR_TYPE_NOT_COMMON:   return "not_common";
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_PRIM_ID8:     return "prim_id8";
#endif
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_PRIM_ID32:    return "prim_id32";
#endif
#if V3D_HAS_INLINE_CLIP
   case V3D_CL_COMPR_TYPE_CLIPPED_PRIM: return "clipped_prim";
#endif
   default:                             return NULL;
   }
}
const char *v3d_desc_cl_compr_type(v3d_cl_compr_type_t cl_compr_type)
{
   const char *desc = v3d_maybe_desc_cl_compr_type(cl_compr_type);
   assert(desc);
   return desc;
}
#if V3D_HAS_TNG
const char *v3d_maybe_desc_cl_compr_serial_type(v3d_cl_compr_serial_type_t cl_compr_serial_type)
{
   switch (cl_compr_serial_type) {
   case V3D_CL_COMPR_SERIAL_TYPE_C0:           return "c0";
   case V3D_CL_COMPR_SERIAL_TYPE_C1:           return "c1";
   case V3D_CL_COMPR_SERIAL_TYPE_C2:           return "c2";
   case V3D_CL_COMPR_SERIAL_TYPE_C3:           return "c3";
   case V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM: return "clipped_prim";
   case V3D_CL_COMPR_SERIAL_TYPE_TG_MODE:      return "tg_mode";
   case V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL:    return "end_level";
   default:                                    return NULL;
   }
}
const char *v3d_desc_cl_compr_serial_type(v3d_cl_compr_serial_type_t cl_compr_serial_type)
{
   const char *desc = v3d_maybe_desc_cl_compr_serial_type(cl_compr_serial_type);
   assert(desc);
   return desc;
}
#endif
const char *v3d_maybe_desc_cl_vpm_pack(v3d_cl_vpm_pack_t cl_vpm_pack)
{
   switch (cl_vpm_pack) {
   case V3D_CL_VPM_PACK_X16: return "x16";
   case V3D_CL_VPM_PACK_X8:  return "x8";
   case V3D_CL_VPM_PACK_X4:  return "x4";
   default:                  return NULL;
   }
}
const char *v3d_desc_cl_vpm_pack(v3d_cl_vpm_pack_t cl_vpm_pack)
{
   const char *desc = v3d_maybe_desc_cl_vpm_pack(cl_vpm_pack);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cl_tess_type(v3d_cl_tess_type_t cl_tess_type)
{
   switch (cl_tess_type) {
   case V3D_CL_TESS_TYPE_TRIANGLE: return "triangle";
   case V3D_CL_TESS_TYPE_QUAD:     return "quad";
   case V3D_CL_TESS_TYPE_ISOLINES: return "isolines";
   default:                        return NULL;
   }
}
const char *v3d_desc_cl_tess_type(v3d_cl_tess_type_t cl_tess_type)
{
   const char *desc = v3d_maybe_desc_cl_tess_type(cl_tess_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing)
{
   switch (cl_tess_edge_spacing) {
   case V3D_CL_TESS_EDGE_SPACING_EQUAL:           return "equal";
   case V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_EVEN: return "fractional_even";
   case V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_ODD:  return "fractional_odd";
   default:                                       return NULL;
   }
}
const char *v3d_desc_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing)
{
   const char *desc = v3d_maybe_desc_cl_tess_edge_spacing(cl_tess_edge_spacing);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode)
{
   switch (cl_tcs_batch_flush_mode) {
   case V3D_CL_TCS_BATCH_FLUSH_MODE_FULLY_PACKED:            return "fully_packed";
   case V3D_CL_TCS_BATCH_FLUSH_MODE_SINGLE_PATCH:            return "single_patch";
   case V3D_CL_TCS_BATCH_FLUSH_MODE_PACKED_COMPLETE_PATCHES: return "packed_complete_patches";
   default:                                                  return NULL;
   }
}
const char *v3d_desc_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode)
{
   const char *desc = v3d_maybe_desc_cl_tcs_batch_flush_mode(cl_tcs_batch_flush_mode);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type)
{
   switch (cl_geom_prim_type) {
   case V3D_CL_GEOM_PRIM_TYPE_POINTS:         return "points";
   case V3D_CL_GEOM_PRIM_TYPE_LINE_STRIP:     return "line_strip";
   case V3D_CL_GEOM_PRIM_TYPE_TRIANGLE_STRIP: return "triangle_strip";
   default:                                   return NULL;
   }
}
const char *v3d_desc_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type)
{
   const char *desc = v3d_maybe_desc_cl_geom_prim_type(cl_geom_prim_type);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack)
{
   switch (cl_geom_output_pack) {
   case V3D_CL_GEOM_OUTPUT_PACK_X16: return "x16";
   case V3D_CL_GEOM_OUTPUT_PACK_X8:  return "x8";
   case V3D_CL_GEOM_OUTPUT_PACK_X4:  return "x4";
   case V3D_CL_GEOM_OUTPUT_PACK_X1:  return "x1";
   default:                          return NULL;
   }
}
const char *v3d_desc_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack)
{
   const char *desc = v3d_maybe_desc_cl_geom_output_pack(cl_geom_output_pack);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse)
{
   switch (tri_ind_reuse) {
   case V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_21: return "new_01_eq_prev_21";
   case V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_02: return "new_01_eq_prev_02";
   case V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_10: return "new_01_eq_prev_10";
   default:                                  return NULL;
   }
}
const char *v3d_desc_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse)
{
   const char *desc = v3d_maybe_desc_tri_ind_reuse(tri_ind_reuse);
   assert(desc);
   return desc;
}
const char *v3d_maybe_desc_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse)
{
   switch (line_ind_reuse) {
   case V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_1: return "new_0_eq_prev_1";
   case V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_0: return "new_0_eq_prev_0";
   default:                                 return NULL;
   }
}
const char *v3d_desc_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse)
{
   const char *desc = v3d_maybe_desc_line_ind_reuse(line_ind_reuse);
   assert(desc);
   return desc;
}
#if V3D_VER_AT_LEAST(3,3,0,0)
const char *v3d_maybe_desc_dram_map_version(v3d_dram_map_version_t dram_map_version)
{
   switch (dram_map_version) {
   case V3D_DRAM_MAP_VERSION_2: return "2";
   case V3D_DRAM_MAP_VERSION_5: return "5";
   case V3D_DRAM_MAP_VERSION_8: return "8";
   default:                     return NULL;
   }
}
const char *v3d_desc_dram_map_version(v3d_dram_map_version_t dram_map_version)
{
   const char *desc = v3d_maybe_desc_dram_map_version(dram_map_version);
   assert(desc);
   return desc;
}
#endif
#if V3D_VER_AT_LEAST(3,3,0,0)
v3d_dram_map_version_t v3d_translate_dram_map_version(uint32_t x)
{
   switch (x) {
   case 2:  return V3D_DRAM_MAP_VERSION_2;
   case 5:  return V3D_DRAM_MAP_VERSION_5;
   case 8:  return V3D_DRAM_MAP_VERSION_8;
   default: unreachable(); return V3D_DRAM_MAP_VERSION_INVALID;
   }
}
uint32_t v3d_translate_from_dram_map_version(v3d_dram_map_version_t x)
{
   switch (x) {
   case V3D_DRAM_MAP_VERSION_2: return 2;
   case V3D_DRAM_MAP_VERSION_5: return 5;
   case V3D_DRAM_MAP_VERSION_8: return 8;
   default:                     unreachable(); return 0;
   }
}
#endif
bool v3d_is_valid_cl_opcode(v3d_cl_opcode_t cl_opcode)
{
   switch (cl_opcode)
   {
   case V3D_CL_HALT:
   case V3D_CL_NOP:
   case V3D_CL_FLUSH:
   case V3D_CL_FLUSH_ALL_STATE:
   case V3D_CL_START_TILE_BINNING:
   case V3D_CL_INCR_SEMAPHORE:
   case V3D_CL_WAIT_SEMAPHORE:
   case V3D_CL_WAIT_PREV_FRAME:
   case V3D_CL_ENABLE_Z_ONLY:
   case V3D_CL_DISABLE_Z_ONLY:
   case V3D_CL_END_Z_ONLY:
   case V3D_CL_END_RENDER:
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK:
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB:
   case V3D_CL_RETURN:
   case V3D_CL_FLUSH_VCD_CACHE:
   case V3D_CL_GENERIC_TILE_LIST:
   case V3D_CL_BRANCH_IMPLICIT_TILE:
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE:
   case V3D_CL_SUPERTILE_COORDS:
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE:
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL:
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT:
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST:
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST:
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST:
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST:
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST:
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS:
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS:
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS:
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS:
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE:
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS:
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS:
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS:
   case V3D_CL_VG_INLINE_PRIMS:
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO:
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID:
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
#endif
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID:
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID:
#endif
   case V3D_CL_PRIM_LIST_FORMAT:
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START:
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER:
   case V3D_CL_VG_SHADER:
   case V3D_CL_VG_INLINE_SHADER:
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE:
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK:
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER:
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE:
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE:
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA:
   case V3D_CL_L1_CACHE_FLUSH_CONTROL:
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL:
   case V3D_CL_L2C_CACHE_FLUSH:
   case V3D_CL_STENCIL_CFG:
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG:
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES:
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG:
#endif
   case V3D_CL_BLEND_CCOLOR:
   case V3D_CL_COLOR_WMASKS:
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS:
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS:
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS:
   case V3D_CL_SAMPLE_COVERAGE:
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE:
   case V3D_CL_CFG_BITS:
   case V3D_CL_POINT_SIZE:
   case V3D_CL_LINE_WIDTH:
   case V3D_CL_DEPTH_OFFSET:
   case V3D_CL_CLIP:
   case V3D_CL_VIEWPORT_OFFSET:
   case V3D_CL_CLIPZ:
   case V3D_CL_CLIPPER_XY:
   case V3D_CL_CLIPPER_Z:
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS:
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG:
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG:
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG:
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG:
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE:
   case V3D_CL_TILE_COORDS:
   case V3D_CL_IMPLICIT_TILE_COORDS:
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE:
   return true;
   default:
      return false;
   }
}
const char *v3d_maybe_desc_cl_opcode(v3d_cl_opcode_t cl_opcode)
{
   switch (cl_opcode) {
   case V3D_CL_HALT:                               return "halt";
   case V3D_CL_NOP:                                return "nop";
   case V3D_CL_FLUSH:                              return "flush";
   case V3D_CL_FLUSH_ALL_STATE:                    return "flush_all_state";
   case V3D_CL_START_TILE_BINNING:                 return "start_tile_binning";
   case V3D_CL_INCR_SEMAPHORE:                     return "incr_semaphore";
   case V3D_CL_WAIT_SEMAPHORE:                     return "wait_semaphore";
   case V3D_CL_WAIT_PREV_FRAME:                    return "wait_prev_frame";
   case V3D_CL_ENABLE_Z_ONLY:                      return "enable_z_only";
   case V3D_CL_DISABLE_Z_ONLY:                     return "disable_z_only";
   case V3D_CL_END_Z_ONLY:                         return "end_z_only";
   case V3D_CL_END_RENDER:                         return "end_render";
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK:            return "wait_transform_feedback";
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:               return "branch_sub_autochain";
   case V3D_CL_BRANCH:                             return "branch";
   case V3D_CL_BRANCH_SUB:                         return "branch_sub";
   case V3D_CL_RETURN:                             return "return";
   case V3D_CL_FLUSH_VCD_CACHE:                    return "flush_vcd_cache";
   case V3D_CL_GENERIC_TILE_LIST:                  return "generic_tile_list";
   case V3D_CL_BRANCH_IMPLICIT_TILE:               return "branch_implicit_tile";
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE:          return "branch_explicit_supertile";
   case V3D_CL_SUPERTILE_COORDS:                   return "supertile_coords";
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR:                              return "clear";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS:                          return "end_loads";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE:                           return "end_tile";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE:                              return "store";
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD:                               return "load";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE:                    return "store_subsample";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX:                 return "store_subsample_ex";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD:                               return "load";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE:                           return "end_tile";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL:                      return "store_general";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL:                       return "load_general";
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT:            return "tf_draw_flush_and_count";
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST:                  return "indexed_prim_list";
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST:                  return "indexed_prim_list";
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST:         return "indirect_indexed_prim_list";
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST:        return "indexed_instanced_prim_list";
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST:        return "indexed_instanced_prim_list";
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS:                 return "vertex_array_prims";
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS:        return "indirect_vertex_array_prims";
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS:       return "vertex_array_instanced_prims";
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: return "vertex_array_single_instance_prims";
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE:          return "base_vertex_base_instance";
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS:          return "indirect_primitive_limits";
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS:          return "indirect_primitive_limits";
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS:               return "vg_coord_array_prims";
   case V3D_CL_VG_INLINE_PRIMS:                    return "vg_inline_prims";
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO:      return "compressed_prim_list_iid_zero";
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID:   return "compressed_prim_list_current_iid";
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:              return "clipped_prim_iid_zero";
#endif
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID:           return "clipped_prim_current_iid";
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID:                    return "set_instance_id";
#endif
   case V3D_CL_PRIM_LIST_FORMAT:                   return "prim_list_format";
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START:           return "serial_number_list_start";
#endif
   case V3D_CL_GL_SHADER:                          return "gl_shader";
   case V3D_CL_GL_T_SHADER:                        return "gl_t_shader";
   case V3D_CL_GL_G_SHADER:                        return "gl_g_shader";
   case V3D_CL_GL_TG_SHADER:                       return "gl_tg_shader";
   case V3D_CL_NV_SHADER:                          return "nv_shader";
   case V3D_CL_VG_SHADER:                          return "vg_shader";
   case V3D_CL_VG_INLINE_SHADER:                   return "vg_inline_shader";
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE:                     return "vcm_cache_size";
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK:               return "prim_counts_feedback";
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER:          return "transform_feedback_buffer";
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS:           return "transform_feedback_specs";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE:                     return "vcm_cache_size";
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE:          return "transform_feedback_enable";
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA:      return "flush_transform_feedback_data";
   case V3D_CL_L1_CACHE_FLUSH_CONTROL:             return "l1_cache_flush_control";
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL:            return "l2t_cache_flush_control";
   case V3D_CL_L2C_CACHE_FLUSH:                    return "l2c_cache_flush";
   case V3D_CL_STENCIL_CFG:                        return "stencil_cfg";
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG:                          return "blend_cfg";
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES:                      return "blend_enables";
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG:                          return "blend_cfg";
#endif
   case V3D_CL_BLEND_CCOLOR:                       return "blend_ccolor";
   case V3D_CL_COLOR_WMASKS:                       return "color_wmasks";
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS:            return "zero_all_centroid_flags";
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS:           return "zero_all_flatshade_flags";
   case V3D_CL_CENTROID_FLAGS:                     return "centroid_flags";
   case V3D_CL_FLATSHADE_FLAGS:                    return "flatshade_flags";
   case V3D_CL_SAMPLE_COVERAGE:                    return "sample_coverage";
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE:     return "occlusion_query_counter_enable";
   case V3D_CL_CFG_BITS:                           return "cfg_bits";
   case V3D_CL_POINT_SIZE:                         return "point_size";
   case V3D_CL_LINE_WIDTH:                         return "line_width";
   case V3D_CL_DEPTH_OFFSET:                       return "depth_offset";
   case V3D_CL_CLIP:                               return "clip";
   case V3D_CL_VIEWPORT_OFFSET:                    return "viewport_offset";
   case V3D_CL_CLIPZ:                              return "clipz";
   case V3D_CL_CLIPPER_XY:                         return "clipper_xy";
   case V3D_CL_CLIPPER_Z:                          return "clipper_z";
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS:                         return "num_layers";
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG:              return "tile_binning_mode_cfg";
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG:            return "tile_rendering_mode_cfg";
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG:            return "tile_rendering_mode_cfg";
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG:  return "multicore_rendering_supertile_cfg";
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: return "multicore_rendering_tile_list_base";
   case V3D_CL_TILE_COORDS:                        return "tile_coords";
   case V3D_CL_IMPLICIT_TILE_COORDS:               return "implicit_tile_coords";
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE:       return "tile_list_initial_block_size";
   default:                                        return NULL;
   }
}
const char *v3d_desc_cl_opcode(v3d_cl_opcode_t cl_opcode)
{
   const char *desc = v3d_maybe_desc_cl_opcode(cl_opcode);
   assert(desc);
   return desc;
}
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 4 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 5 & 1;
   (*unpacked).z_write = packed[0] >> 6 & 1;
   (*unpacked).no_ez = packed[0] >> 7 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 8 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 9 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 11 & 1;
   (*unpacked).disable_scb = packed[0] >> 12 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 16 & 255, 0, 64);
   (*unpacked).cs_output_size = packed[1] & 255;
   (*unpacked).cs_input_size = packed[1] >> 8 & 255;
   (*unpacked).vs_output_size = packed[1] >> 16 & 255;
   (*unpacked).vs_input_size = packed[1] >> 24;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 4 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 5 & 1;
   (*unpacked).z_write = packed[0] >> 6 & 1;
   (*unpacked).no_ez = packed[0] >> 7 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 8 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 9 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 11 & 1;
   (*unpacked).disable_scb = packed[0] >> 12 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 16 & 255, 0, 64);
   (*unpacked).cs_output_size = packed[1] & 255;
   (*unpacked).cs_input_size = packed[1] >> 8 & 255;
   (*unpacked).vs_output_size = packed[1] >> 16 & 255;
   (*unpacked).vs_input_size = packed[1] >> 24;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 4 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 5 & 1;
   (*unpacked).z_write = packed[0] >> 6 & 1;
   (*unpacked).no_ez = packed[0] >> 7 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 8 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 9 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 11 & 1;
   (*unpacked).disable_scb = packed[0] >> 12 & 1;
   (*unpacked).prim_id_used = packed[0] >> 13 & 1;
   (*unpacked).prim_id_to_fs = packed[0] >> 14 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 16 & 255, 0, 64);
   (*unpacked).cs_output_size = packed[1] & 255;
   (*unpacked).cs_input_size = packed[1] >> 8 & 255;
   (*unpacked).vs_output_size = packed[1] >> 16 & 255;
   (*unpacked).vs_input_size = packed[1] >> 24;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 4 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 5 & 1;
   (*unpacked).z_write = packed[0] >> 6 & 1;
   (*unpacked).no_ez = packed[0] >> 7 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 8 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 9 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 11 & 1;
   (*unpacked).disable_scb = packed[0] >> 12 & 1;
   (*unpacked).prim_id_used = packed[0] >> 13 & 1;
   (*unpacked).prim_id_to_fs = packed[0] >> 14 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 16 & 255, 0, 64);
   (*unpacked).cs_output_size = packed[1] & 255;
   (*unpacked).cs_input_size = packed[1] >> 8 & 255;
   (*unpacked).vs_output_size = packed[1] >> 16 & 255;
   (*unpacked).vs_input_size = packed[1] >> 24;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).cs_baseinstance = packed[0] >> 4 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 5 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 6 & 1;
   (*unpacked).vs_baseinstance = packed[0] >> 7 & 1;
   (*unpacked).z_write = packed[0] >> 8 & 1;
   (*unpacked).no_ez = packed[0] >> 9 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 10 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 11 & 1;
   (*unpacked).disable_scb = packed[0] >> 16 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 17 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 24, 0, 64);
   (*unpacked).cs_output_size.sectors = gfx_unpack_uint_0_is_max(packed[1] & 15, 4);
   (*unpacked).cs_output_size.min_extra_req = packed[1] >> 4 & 3;
   (*unpacked).cs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).cs_input_size.sectors = packed[1] >> 8 & 15;
   (*unpacked).cs_input_size.min_req = (packed[1] >> 12 & 3) + 1;
   (*unpacked).vs_output_size.sectors =
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4);
   (*unpacked).vs_output_size.min_extra_req = packed[1] >> 20 & 3;
   (*unpacked).vs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).vs_input_size.sectors = packed[1] >> 24 & 15;
   (*unpacked).vs_input_size.min_req = (packed[1] >> 28 & 3) + 1;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).cs_baseinstance = packed[0] >> 4 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 5 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 6 & 1;
   (*unpacked).vs_baseinstance = packed[0] >> 7 & 1;
   (*unpacked).z_write = packed[0] >> 8 & 1;
   (*unpacked).no_ez = packed[0] >> 9 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 10 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 11 & 1;
   (*unpacked).sample_rate_shading = packed[0] >> 13 & 1;
   (*unpacked).disable_scb = packed[0] >> 16 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 17 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 24, 0, 64);
   (*unpacked).cs_output_size.sectors = gfx_unpack_uint_0_is_max(packed[1] & 15, 4);
   (*unpacked).cs_output_size.min_extra_req = packed[1] >> 4 & 3;
   (*unpacked).cs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).cs_input_size.sectors = packed[1] >> 8 & 15;
   (*unpacked).cs_input_size.min_req = (packed[1] >> 12 & 3) + 1;
   (*unpacked).vs_output_size.sectors =
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4);
   (*unpacked).vs_output_size.min_extra_req = packed[1] >> 20 & 3;
   (*unpacked).vs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).vs_input_size.sectors = packed[1] >> 24 & 15;
   (*unpacked).vs_input_size.min_req = (packed[1] >> 28 & 3) + 1;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).cs_baseinstance = packed[0] >> 4 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 5 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 6 & 1;
   (*unpacked).vs_baseinstance = packed[0] >> 7 & 1;
   (*unpacked).z_write = packed[0] >> 8 & 1;
   (*unpacked).no_ez = packed[0] >> 9 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 10 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 11 & 1;
   (*unpacked).prim_id_used = packed[0] >> 14 & 1;
   (*unpacked).prim_id_to_fs = packed[0] >> 15 & 1;
   (*unpacked).disable_scb = packed[0] >> 16 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 17 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 24, 0, 64);
   (*unpacked).cs_output_size.sectors = gfx_unpack_uint_0_is_max(packed[1] & 15, 4);
   (*unpacked).cs_output_size.min_extra_req = packed[1] >> 4 & 3;
   (*unpacked).cs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).cs_input_size.sectors = packed[1] >> 8 & 15;
   (*unpacked).cs_input_size.min_req = (packed[1] >> 12 & 3) + 1;
   (*unpacked).vs_output_size.sectors =
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4);
   (*unpacked).vs_output_size.min_extra_req = packed[1] >> 20 & 3;
   (*unpacked).vs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).vs_input_size.sectors = packed[1] >> 24 & 15;
   (*unpacked).vs_input_size.min_req = (packed[1] >> 28 & 3) + 1;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).cs_baseinstance = packed[0] >> 4 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 5 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 6 & 1;
   (*unpacked).vs_baseinstance = packed[0] >> 7 & 1;
   (*unpacked).z_write = packed[0] >> 8 & 1;
   (*unpacked).no_ez = packed[0] >> 9 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 10 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 11 & 1;
   (*unpacked).sample_rate_shading = packed[0] >> 13 & 1;
   (*unpacked).prim_id_used = packed[0] >> 14 & 1;
   (*unpacked).prim_id_to_fs = packed[0] >> 15 & 1;
   (*unpacked).disable_scb = packed[0] >> 16 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 17 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 24, 0, 64);
   (*unpacked).cs_output_size.sectors = gfx_unpack_uint_0_is_max(packed[1] & 15, 4);
   (*unpacked).cs_output_size.min_extra_req = packed[1] >> 4 & 3;
   (*unpacked).cs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).cs_input_size.sectors = packed[1] >> 8 & 15;
   (*unpacked).cs_input_size.min_req = (packed[1] >> 12 & 3) + 1;
   (*unpacked).vs_output_size.sectors =
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4);
   (*unpacked).vs_output_size.min_extra_req = packed[1] >> 20 & 3;
   (*unpacked).vs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).vs_input_size.sectors = packed[1] >> 24 & 15;
   (*unpacked).vs_input_size.min_req = (packed[1] >> 28 & 3) + 1;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && V3D_HAS_VARY_DISABLE
void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed)
{
   (*unpacked).point_size_included = packed[0] & 1;
   (*unpacked).clipping = packed[0] >> 1 & 1;
   (*unpacked).cs_vertex_id = packed[0] >> 2 & 1;
   (*unpacked).cs_instance_id = packed[0] >> 3 & 1;
   (*unpacked).cs_baseinstance = packed[0] >> 4 & 1;
   (*unpacked).vs_vertex_id = packed[0] >> 5 & 1;
   (*unpacked).vs_instance_id = packed[0] >> 6 & 1;
   (*unpacked).vs_baseinstance = packed[0] >> 7 & 1;
   (*unpacked).z_write = packed[0] >> 8 & 1;
   (*unpacked).no_ez = packed[0] >> 9 & 1;
   (*unpacked).cs_separate_blocks = packed[0] >> 10 & 1;
   (*unpacked).vs_separate_blocks = packed[0] >> 11 & 1;
   (*unpacked).sample_rate_shading = packed[0] >> 13 & 1;
   (*unpacked).prim_id_used = packed[0] >> 14 & 1;
   (*unpacked).prim_id_to_fs = packed[0] >> 15 & 1;
   (*unpacked).disable_scb = packed[0] >> 16 & 1;
   (*unpacked).scb_wait_on_first_thrsw = packed[0] >> 17 & 1;
   (*unpacked).disable_implicit_varys = packed[0] >> 18 & 1;
   (*unpacked).num_varys = gfx_check_urange(packed[0] >> 24, 0, 64);
   (*unpacked).cs_output_size.sectors = gfx_unpack_uint_0_is_max(packed[1] & 15, 4);
   (*unpacked).cs_output_size.min_extra_req = packed[1] >> 4 & 3;
   (*unpacked).cs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).cs_input_size.sectors = packed[1] >> 8 & 15;
   (*unpacked).cs_input_size.min_req = (packed[1] >> 12 & 3) + 1;
   (*unpacked).vs_output_size.sectors =
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4);
   (*unpacked).vs_output_size.min_extra_req = packed[1] >> 20 & 3;
   (*unpacked).vs_output_size.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).vs_input_size.sectors = packed[1] >> 24 & 15;
   (*unpacked).vs_input_size.min_req = (packed[1] >> 28 & 3) + 1;
   (*unpacked).defaults = packed[2];
   (*unpacked).fs.threading = (v3d_threading_t)(packed[3] & 3);
   (*unpacked).fs.propagate_nans = packed[3] >> 2 & 1;
   (*unpacked).fs.addr = packed[3] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[4];
   (*unpacked).vs.threading = (v3d_threading_t)(packed[5] & 3);
   (*unpacked).vs.propagate_nans = packed[5] >> 2 & 1;
   (*unpacked).vs.addr = packed[5] >> 3 << 3;
   (*unpacked).vs.unifs_addr = packed[6];
   (*unpacked).cs.threading = (v3d_threading_t)(packed[7] & 3);
   (*unpacked).cs.propagate_nans = packed[7] >> 2 & 1;
   (*unpacked).cs.addr = packed[7] >> 3 << 3;
   (*unpacked).cs.unifs_addr = packed[8];
}
#endif
void v3d_unpack_shadrec_gl_geom(V3D_SHADREC_GL_GEOM_T *unpacked, const uint32_t *packed)
{
   (*unpacked).gs_bin.threading = (v3d_threading_t)(packed[0] & 3);
   (*unpacked).gs_bin.propagate_nans = packed[0] >> 2 & 1;
   (*unpacked).gs_bin.addr = packed[0] >> 3 << 3;
   (*unpacked).gs_bin.unifs_addr = packed[1];
   (*unpacked).gs_render.threading = (v3d_threading_t)(packed[2] & 3);
   (*unpacked).gs_render.propagate_nans = packed[2] >> 2 & 1;
   (*unpacked).gs_render.addr = packed[2] >> 3 << 3;
   (*unpacked).gs_render.unifs_addr = packed[3];
}
void v3d_unpack_shadrec_gl_tess(V3D_SHADREC_GL_TESS_T *unpacked, const uint32_t *packed)
{
   (*unpacked).tcs_bin.threading = (v3d_threading_t)(packed[0] & 3);
   (*unpacked).tcs_bin.propagate_nans = packed[0] >> 2 & 1;
   (*unpacked).tcs_bin.addr = packed[0] >> 3 << 3;
   (*unpacked).tcs_bin.unifs_addr = packed[1];
   (*unpacked).tcs_render.threading = (v3d_threading_t)(packed[2] & 3);
   (*unpacked).tcs_render.propagate_nans = packed[2] >> 2 & 1;
   (*unpacked).tcs_render.addr = packed[2] >> 3 << 3;
   (*unpacked).tcs_render.unifs_addr = packed[3];
   (*unpacked).tes_bin.threading = (v3d_threading_t)(packed[4] & 3);
   (*unpacked).tes_bin.propagate_nans = packed[4] >> 2 & 1;
   (*unpacked).tes_bin.addr = packed[4] >> 3 << 3;
   (*unpacked).tes_bin.unifs_addr = packed[5];
   (*unpacked).tes_render.threading = (v3d_threading_t)(packed[6] & 3);
   (*unpacked).tes_render.propagate_nans = packed[6] >> 2 & 1;
   (*unpacked).tes_render.addr = packed[6] >> 3 << 3;
   (*unpacked).tes_render.unifs_addr = packed[7];
}
#if !V3D_HAS_SREC_TG_TWEAK
void v3d_unpack_shadrec_gl_tess_or_geom(V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked, const uint32_t *packed)
{
   (*unpacked).tess_type = (v3d_cl_tess_type_t)(packed[0] >> 1 & 3);
   (*unpacked).tess_point_mode = packed[0] >> 3 & 1;
   (*unpacked).tess_edge_spacing = (v3d_cl_tess_edge_spacing_t)(packed[0] >> 4 & 3);
   (*unpacked).tess_clockwise = packed[0] >> 6 & 1;
   (*unpacked).tcs_bypass = packed[0] >> 8 & 1;
   (*unpacked).tcs_bypass_render = packed[0] >> 9 & 1;
   (*unpacked).tcs_batch_flush =
      (v3d_cl_tcs_batch_flush_mode_t)(packed[0] >> 10 & 3);
   (*unpacked).tes_no_inp_verts = packed[0] >> 12 & 1;
   (*unpacked).per_patch_depth_bin =
      gfx_unpack_uint_0_is_max(packed[0] >> 16 & 15, 4);
   (*unpacked).per_patch_depth_render =
      gfx_unpack_uint_0_is_max(packed[0] >> 20 & 15, 4);
   (*unpacked).num_tcs_invocations = gfx_check_urange(packed[0] >> 24, 1, 32);
   (*unpacked).tcs_output_bin.size_sectors =
      gfx_check_urange(packed[1] & 63, 0, 16);
   (*unpacked).tcs_output_bin.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).tcs_output_render.size_sectors =
      gfx_check_urange(packed[1] >> 8 & 63, 0, 16);
   (*unpacked).tcs_output_render.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 14 & 3);
   (*unpacked).tes_output_bin.size_sectors =
      gfx_check_urange(packed[1] >> 16 & 63, 0, 16);
   (*unpacked).tes_output_bin.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).tes_output_render.size_sectors =
      gfx_check_urange(packed[1] >> 24 & 63, 0, 16);
   (*unpacked).tes_output_render.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 30);
   (*unpacked).geom_output = (v3d_cl_geom_prim_type_t)(packed[2] >> 1 & 3);
   (*unpacked).geom_num_instances = gfx_check_urange(packed[2] >> 8 & 255, 1, 32);
   (*unpacked).geom_output_bin.size_sectors =
      gfx_check_urange(packed[2] >> 16 & 63, 0, 16);
   (*unpacked).geom_output_bin.pack =
      (v3d_cl_geom_output_pack_t)(packed[2] >> 22 & 3);
   (*unpacked).geom_output_render.size_sectors =
      gfx_check_urange(packed[2] >> 24 & 63, 0, 16);
   (*unpacked).geom_output_render.pack =
      (v3d_cl_geom_output_pack_t)(packed[2] >> 30);
   (*unpacked).max_patches_per_tcs_batch = (packed[3] & 7) + 1;
   (*unpacked).min_tcs_segs_bin = (packed[3] >> 3 & 7) + 1;
   (*unpacked).min_tcs_segs_render = (packed[3] >> 6 & 7) + 1;
   (*unpacked).min_per_patch_segs_bin = (packed[3] >> 9 & 3) + 1;
   (*unpacked).min_per_patch_segs_render = (packed[3] >> 11 & 3) + 1;
   (*unpacked).max_patches_per_tes_batch = (packed[3] >> 14 & 7) + 1;
   (*unpacked).min_tes_segs_bin = (packed[3] >> 17 & 7) + 1;
   (*unpacked).min_tes_segs_render = (packed[3] >> 20 & 7) + 1;
   (*unpacked).max_patches_per_gs_batch = (packed[3] >> 23 & 7) + 1;
   (*unpacked).min_gs_segs_bin = (packed[3] >> 26 & 7) + 1;
   (*unpacked).min_gs_segs_render = (packed[3] >> 29) + 1;
}
#endif
#if V3D_HAS_SREC_TG_TWEAK
void v3d_unpack_shadrec_gl_tess_or_geom(V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked, const uint32_t *packed)
{
   (*unpacked).tess_type = (v3d_cl_tess_type_t)(packed[0] >> 1 & 3);
   (*unpacked).tess_point_mode = packed[0] >> 3 & 1;
   (*unpacked).tess_edge_spacing = (v3d_cl_tess_edge_spacing_t)(packed[0] >> 4 & 3);
   (*unpacked).tess_clockwise = packed[0] >> 6 & 1;
   (*unpacked).tcs_bypass = packed[0] >> 7 & 1;
   (*unpacked).tcs_bypass_render = packed[0] >> 8 & 1;
   (*unpacked).tcs_batch_flush =
      (v3d_cl_tcs_batch_flush_mode_t)(packed[0] >> 9 & 3);
   (*unpacked).tes_no_inp_verts = packed[0] >> 11 & 1;
   (*unpacked).num_tcs_invocations =
      gfx_unpack_uint_0_is_max(packed[0] >> 12 & 31, 5);
   (*unpacked).geom_output = (v3d_cl_geom_prim_type_t)(packed[0] >> 17 & 3);
   (*unpacked).geom_num_instances =
      gfx_unpack_uint_0_is_max(packed[0] >> 19 & 31, 5);
   (*unpacked).per_patch_depth_bin =
      gfx_unpack_uint_0_is_max(packed[0] >> 24 & 15, 4);
   (*unpacked).per_patch_depth_render =
      gfx_unpack_uint_0_is_max(packed[0] >> 28, 4);
   (*unpacked).tcs_output_bin.size_sectors =
      gfx_check_urange(packed[1] & 63, 0, 16);
   (*unpacked).tcs_output_bin.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3);
   (*unpacked).tcs_output_render.size_sectors =
      gfx_check_urange(packed[1] >> 8 & 63, 0, 16);
   (*unpacked).tcs_output_render.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 14 & 3);
   (*unpacked).tes_output_bin.size_sectors =
      gfx_check_urange(packed[1] >> 16 & 63, 0, 16);
   (*unpacked).tes_output_bin.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3);
   (*unpacked).tes_output_render.size_sectors =
      gfx_check_urange(packed[1] >> 24 & 63, 0, 16);
   (*unpacked).tes_output_render.pack = (v3d_cl_vpm_pack_t)(packed[1] >> 30);
   (*unpacked).geom_output_bin.size_sectors =
      gfx_check_urange(packed[2] & 63, 0, 16);
   (*unpacked).geom_output_bin.pack =
      (v3d_cl_geom_output_pack_t)(packed[2] >> 6 & 3);
   (*unpacked).geom_output_render.size_sectors =
      gfx_check_urange(packed[2] >> 8 & 63, 0, 16);
   (*unpacked).geom_output_render.pack =
      (v3d_cl_geom_output_pack_t)(packed[2] >> 14 & 3);
   (*unpacked).max_patches_per_tcs_batch = (packed[2] >> 16 & 15) + 1;
   (*unpacked).max_extra_vert_segs_per_tcs_batch_bin = packed[2] >> 20 & 3;
   (*unpacked).max_extra_vert_segs_per_tcs_batch_render = packed[2] >> 22 & 3;
   (*unpacked).min_tcs_segs_bin = (packed[2] >> 24 & 7) + 1;
   (*unpacked).min_tcs_segs_render = (packed[2] >> 27 & 7) + 1;
   (*unpacked).min_per_patch_segs_bin = (packed[2] >> 30) + 1;
   (*unpacked).min_per_patch_segs_render = (packed[3] & 3) + 1;
   (*unpacked).max_patches_per_tes_batch = (packed[3] >> 2 & 15) + 1;
   (*unpacked).max_extra_vert_segs_per_tes_batch_bin = packed[3] >> 6 & 3;
   (*unpacked).max_extra_vert_segs_per_tes_batch_render = packed[3] >> 8 & 3;
   (*unpacked).max_tcs_segs_per_tes_batch_bin = (packed[3] >> 10 & 7) + 1;
   (*unpacked).max_tcs_segs_per_tes_batch_render = (packed[3] >> 13 & 7) + 1;
   (*unpacked).min_tes_segs_bin = (packed[3] >> 16 & 7) + 1;
   (*unpacked).min_tes_segs_render = (packed[3] >> 19 & 7) + 1;
   (*unpacked).max_extra_vert_segs_per_gs_batch_bin = packed[3] >> 22 & 3;
   (*unpacked).max_extra_vert_segs_per_gs_batch_render = packed[3] >> 24 & 3;
   (*unpacked).min_gs_segs_bin = (packed[3] >> 26 & 7) + 1;
   (*unpacked).min_gs_segs_render = (packed[3] >> 29) + 1;
}
#endif
void v3d_unpack_shadrec_gl_attr(V3D_SHADREC_GL_ATTR_T *unpacked, const uint32_t *packed)
{
   (*unpacked).addr = packed[0];
   (*unpacked).size = gfx_unpack_uint_0_is_max(packed[1] & 3, 2);
   (*unpacked).type = (v3d_attr_type_t)(packed[1] >> 2 & 7);
   (*unpacked).signed_int = packed[1] >> 5 & 1;
   (*unpacked).normalised_int = packed[1] >> 6 & 1;
   (*unpacked).read_as_int = packed[1] >> 7 & 1;
   (*unpacked).cs_num_reads = gfx_check_urange(packed[1] >> 8 & 15, 0, 4);
   (*unpacked).vs_num_reads = gfx_check_urange(packed[1] >> 12 & 15, 0, 4);
   (*unpacked).divisor = packed[1] >> 16;
   (*unpacked).stride = packed[2];
}
void v3d_unpack_shadrec_vg(V3D_SHADREC_VG_T *unpacked, const uint32_t *packed)
{
   (*unpacked).fs.threading = (v3d_threading_t)(packed[1] & 3);
   (*unpacked).fs.propagate_nans = packed[1] >> 2 & 1;
   (*unpacked).fs.addr = packed[1] >> 3 << 3;
   (*unpacked).fs.unifs_addr = packed[2];
}
void v3d_unpack_unif_raw(V3D_UNIF_RAW_T *unpacked, uint32_t packed0)
{
   (*unpacked).unif = packed0;
}
void v3d_unpack_unif_addr(V3D_UNIF_ADDR_T *unpacked, uint32_t packed0)
{
   (*unpacked).addr = packed0;
}
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0)
{
   if ((packed0 >> 9 & 1) == 0)
   {
      (*unpacked).cfg = 0;
      (*unpacked).u.cfg0.type = (v3d_tmu_type_t)(packed0 & 127);
      (*unpacked).u.cfg0.srgb = packed0 >> 7 & 1;
      (*unpacked).u.cfg0.pix_mask = packed0 >> 8 & 1;
      assert((packed0 >> 9 & 1) == 0);
      (*unpacked).u.cfg0.width = gfx_unpack_uint_0_is_max(packed0 >> 10 & 0x7ff, 11);
      (*unpacked).u.cfg0.height = gfx_unpack_uint_0_is_max(packed0 >> 21, 11);
   }
   else if ((packed0 >> 9 & 1) == 1)
   {
      (*unpacked).cfg = 1;
      (*unpacked).u.cfg1.ltype = (v3d_tmu_ltype_t)(packed0 & 7);
      (*unpacked).u.cfg1.fetch = packed0 >> 3 & 1;
      (*unpacked).u.cfg1.gather = packed0 >> 4 & 1;
      (*unpacked).u.cfg1.bias = packed0 >> 5 & 1;
      (*unpacked).u.cfg1.bslod = packed0 >> 6 & 1;
      (*unpacked).u.cfg1.coefficient = packed0 >> 7 & 1;
      (*unpacked).u.cfg1.shadow = packed0 >> 8 & 1;
      assert((packed0 >> 9 & 1) == 1);
      (*unpacked).u.cfg1.wrap_s = (v3d_tmu_wrap_t)(packed0 >> 10 & 7);
      (*unpacked).u.cfg1.wrap_t = (v3d_tmu_wrap_t)(packed0 >> 13 & 7);
      (*unpacked).u.cfg1.wrap_r = (v3d_tmu_wrap_t)(packed0 >> 16 & 7);
      (*unpacked).u.cfg1.tex_off_s = gfx_sext(packed0 >> 19 & 15, 4);
      (*unpacked).u.cfg1.tex_off_t = gfx_sext(packed0 >> 23 & 15, 4);
      (*unpacked).u.cfg1.tex_off_r = gfx_sext(packed0 >> 27 & 15, 4);
      (*unpacked).u.cfg1.pix_mask = packed0 >> 31;
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_param1_cfg0(V3D_TMU_PARAM1_CFG0_T *unpacked, uint32_t packed0)
{
   (*unpacked).wrap_s = (v3d_tmu_wrap_cfg0_t)(packed0 & 3);
   (*unpacked).wrap_t = (v3d_tmu_wrap_cfg0_t)(packed0 >> 2 & 3);
   (*unpacked).filter = (v3d_tmu_filter_t)(packed0 >> 4 & 15);
   (*unpacked).bslod = packed0 >> 8 & 1;
   (*unpacked).base = packed0 >> 9 << 9;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_param1_cfg1(V3D_TMU_PARAM1_CFG1_T *unpacked, uint32_t packed0)
{
   (*unpacked).word0_en = packed0 & 1;
   (*unpacked).word1_en = packed0 >> 1 & 1;
   (*unpacked).word2_en = packed0 >> 2 & 1;
   (*unpacked).word3_en = packed0 >> 3 & 1;
   (*unpacked).unnorm = packed0 >> 4 & 1;
   (*unpacked).ts_base = packed0 >> 5 << 5;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0)
{
   (*unpacked).word_en[0] = packed0 & 1;
   (*unpacked).word_en[1] = packed0 >> 1 & 1;
   (*unpacked).word_en[2] = packed0 >> 2 & 1;
   (*unpacked).word_en[3] = packed0 >> 3 & 1;
   (*unpacked).tex_state_addr = packed0 >> 4 << 4;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_param1(V3D_TMU_PARAM1_T *unpacked, uint32_t packed0)
{
   (*unpacked).output_32 = packed0 & 1;
   (*unpacked).unnorm = packed0 >> 1 & 1;
   (*unpacked).pix_mask = packed0 >> 2 & 1;
   (*unpacked).sampler_addr = packed0 >> 3 << 3;
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_TEX_WRITE
void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0)
{
   (*unpacked).tmuoff_4x = packed0 & 1;
   (*unpacked).bslod = packed0 >> 1 & 1;
   (*unpacked).coeff_sample = packed0 >> 2 & 3;
   (*unpacked).coefficient = packed0 >> 4 & 1;
   (*unpacked).gather_comp = packed0 >> 5 & 3;
   (*unpacked).gather = packed0 >> 7 & 1;
   (*unpacked).offsets[0] = gfx_sext(packed0 >> 8 & 15, 4);
   (*unpacked).offsets[1] = gfx_sext(packed0 >> 12 & 15, 4);
   (*unpacked).offsets[2] = gfx_sext(packed0 >> 16 & 15, 4);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_TEX_WRITE
void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0)
{
   (*unpacked).tmuoff_4x = packed0 & 1;
   (*unpacked).bslod = packed0 >> 1 & 1;
   (*unpacked).coeff_sample = packed0 >> 2 & 3;
   (*unpacked).coefficient = packed0 >> 4 & 1;
   (*unpacked).gather_comp = packed0 >> 5 & 3;
   (*unpacked).gather = packed0 >> 7 & 1;
   (*unpacked).offsets[0] = gfx_sext(packed0 >> 8 & 15, 4);
   (*unpacked).offsets[1] = gfx_sext(packed0 >> 12 & 15, 4);
   (*unpacked).offsets[2] = gfx_sext(packed0 >> 16 & 15, 4);
   (*unpacked).op = (v3d_tmu_op_t)(packed0 >> 20 & 15);
}
#endif
void v3d_unpack_tmu_general_config(V3D_TMU_GENERAL_CONFIG_T *unpacked, uint8_t packed0)
{
   (*unpacked).type = (v3d_tmu_general_type_t)(uint32_t)(packed0 & 7);
   (*unpacked).op = (v3d_tmu_op_t)(uint32_t)(packed0 >> 3 & 15);
   (*unpacked).per_pixel_enable = (uint32_t)(packed0 >> 7);
}
void v3d_unpack_tsy_config(V3D_TSY_CONFIG_T *unpacked, uint8_t packed0)
{
   (*unpacked).op = (v3d_tsy_op_t)(uint32_t)(packed0 & 31);
   (*unpacked).gfxh_1370_do_not_change = (uint32_t)(packed0 >> 5);
}
void v3d_unpack_tlb_config(V3D_TLB_CONFIG_T *unpacked, uint8_t packed0)
{
   if ((uint32_t)(packed0 >> 6) == 3)
   {
      (*unpacked).type = V3D_TLB_RW_TYPE_COLOR_F16;
      (*unpacked).u.color_f16.num_words = (uint32_t)(packed0 & 1) + 1;
      (*unpacked).u.color_f16.no_swap = (uint32_t)(packed0 >> 1 & 1);
      (*unpacked).u.color_f16.all_samples_same_data = (uint32_t)(packed0 >> 2 & 1);
      (*unpacked).u.color_f16.rt = gfx_mask(3) - (uint32_t)(packed0 >> 3 & 7);
      assert((uint32_t)(packed0 >> 6) == 3);
   }
   else if ((uint32_t)(packed0 >> 7) == 0)
   {
      (*unpacked).type = V3D_TLB_RW_TYPE_COLOR_32;
      (*unpacked).u.color_32.num_words = (uint32_t)(packed0 & 3) + 1;
      (*unpacked).u.color_32.all_samples_same_data = (uint32_t)(packed0 >> 2 & 1);
      (*unpacked).u.color_32.rt = gfx_mask(3) - (uint32_t)(packed0 >> 3 & 7);
      (*unpacked).u.color_32.as_int = (uint32_t)(packed0 >> 6 & 1);
      assert((uint32_t)(packed0 >> 7) == 0);
   }
   else if ((uint32_t)(packed0 >> 4) == 8)
   {
      (*unpacked).type = V3D_TLB_RW_TYPE_Z;
      (*unpacked).u.z.use_written_z = (uint32_t)(packed0 >> 2 & 1);
      assert((uint32_t)(packed0 >> 4) == 8);
   }
   else if ((uint32_t)(packed0 >> 4) == 9)
   {
      (*unpacked).type = V3D_TLB_RW_TYPE_ALPHA_MASK;
      assert((uint32_t)(packed0 >> 4) == 9);
   }
   else
   {
      unreachable();
   }
}
void v3d_unpack_unif_branch(V3D_UNIF_BRANCH_T *unpacked, uint32_t packed0)
{
   (*unpacked).bcond = (v3d_qpu_bcond_t)(packed0 & 7);
   (*unpacked).msfign = (v3d_qpu_msfign_t)(packed0 >> 7 & 3);
   (*unpacked).ulr = packed0 >> 9 & 1;
   (*unpacked).rel_i_addr = gfx_sext(packed0 >> 10 & 0x7ff, 11) << 3;
   (*unpacked).rel_u_addr = gfx_sext(packed0 >> 21, 11) << 2;
}
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_indirect_not_child_image(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed)
{
   (*unpacked).filter = (v3d_tmu_filter_t)(packed[0] & 15);
   (*unpacked).border_rrra = packed[0] >> 5 & 1;
   (*unpacked).base = packed[0] >> 6 << 6;
   (*unpacked).arr_str = (packed[1] & 0x3ffffff) << 6;
   (*unpacked).width = gfx_unpack_uint_0_is_max(
      packed[1] >> 26 | (packed[2] & 255) << 6, 14);
   (*unpacked).height = gfx_unpack_uint_0_is_max(packed[2] >> 8 & 0x3fff, 14);
   (*unpacked).depth = gfx_unpack_uint_0_is_max(
      packed[2] >> 22 | (packed[3] & 15) << 10, 14);
   (*unpacked).ttype = (v3d_tmu_type_t)(packed[3] >> 4 & 127);
   (*unpacked).srgb = packed[3] >> 11 & 1;
   (*unpacked).ahdr = packed[3] >> 12 & 1;
   (*unpacked).compare_func = (v3d_compare_func_t)(packed[3] >> 13 & 7);
   (*unpacked).swizzles[0] = (v3d_tmu_swizzle_t)(packed[3] >> 16 & 7);
   (*unpacked).swizzles[1] = (v3d_tmu_swizzle_t)(packed[3] >> 19 & 7);
   (*unpacked).swizzles[2] = (v3d_tmu_swizzle_t)(packed[3] >> 22 & 7);
   (*unpacked).swizzles[3] = (v3d_tmu_swizzle_t)(packed[3] >> 25 & 7);
   (*unpacked).flipx = packed[3] >> 28 & 1;
   (*unpacked).flipy = packed[3] >> 29 & 1;
   (*unpacked).etcflip = packed[3] >> 30 & 1;
   (*unpacked).bcolour = (uint64_t)packed[4] | (uint64_t)packed[5] << 32;
   (*unpacked).u.not_child_image.min_lod = gfx_sext(packed[6] & 0xffff, 16);
   (*unpacked).u.not_child_image.max_lod = gfx_sext(packed[6] >> 16, 16);
   (*unpacked).u.not_child_image.fixed_bias = gfx_sext(packed[7] & 0xffff, 16);
   (*unpacked).u.not_child_image.base_level = packed[7] >> 16 & 15;
   (*unpacked).u.not_child_image.samp_num = packed[7] >> 20 & 3;
   (*unpacked).u.not_child_image.output_type =
      (v3d_tmu_output_type_t)(packed[7] >> 22 & 3);
   (*unpacked).ub_pad = packed[7] >> 24 & 15;
   (*unpacked).ub_xor = packed[7] >> 28 & 1;
   (*unpacked).uif_top = packed[7] >> 30 & 1;
   (*unpacked).xor_dis = packed[7] >> 31;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_indirect_child_image(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed)
{
   (*unpacked).filter = (v3d_tmu_filter_t)(packed[0] & 15);
   (*unpacked).border_rrra = packed[0] >> 5 & 1;
   (*unpacked).base = packed[0] >> 6 << 6;
   (*unpacked).arr_str = (packed[1] & 0x3ffffff) << 6;
   (*unpacked).width = gfx_unpack_uint_0_is_max(
      packed[1] >> 26 | (packed[2] & 255) << 6, 14);
   (*unpacked).height = gfx_unpack_uint_0_is_max(packed[2] >> 8 & 0x3fff, 14);
   (*unpacked).depth = gfx_unpack_uint_0_is_max(
      packed[2] >> 22 | (packed[3] & 15) << 10, 14);
   (*unpacked).ttype = (v3d_tmu_type_t)(packed[3] >> 4 & 127);
   (*unpacked).srgb = packed[3] >> 11 & 1;
   (*unpacked).ahdr = packed[3] >> 12 & 1;
   (*unpacked).compare_func = (v3d_compare_func_t)(packed[3] >> 13 & 7);
   (*unpacked).swizzles[0] = (v3d_tmu_swizzle_t)(packed[3] >> 16 & 7);
   (*unpacked).swizzles[1] = (v3d_tmu_swizzle_t)(packed[3] >> 19 & 7);
   (*unpacked).swizzles[2] = (v3d_tmu_swizzle_t)(packed[3] >> 22 & 7);
   (*unpacked).swizzles[3] = (v3d_tmu_swizzle_t)(packed[3] >> 25 & 7);
   (*unpacked).flipx = packed[3] >> 28 & 1;
   (*unpacked).flipy = packed[3] >> 29 & 1;
   (*unpacked).etcflip = packed[3] >> 30 & 1;
   (*unpacked).bcolour = (uint64_t)packed[4] | (uint64_t)packed[5] << 32;
   (*unpacked).u.child_image.cwidth = packed[6] & 0x3fff;
   (*unpacked).u.child_image.cheight = packed[6] >> 14 & 0x3fff;
   (*unpacked).u.child_image.cxoff = packed[6] >> 28 | (packed[7] & 0x3ff) << 4;
   (*unpacked).u.child_image.cyoff = packed[7] >> 10 & 0x3fff;
   (*unpacked).ub_pad = packed[7] >> 24 & 15;
   (*unpacked).ub_xor = packed[7] >> 28 & 1;
   (*unpacked).uif_top = packed[7] >> 30 & 1;
   (*unpacked).xor_dis = packed[7] >> 31;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_tex_state(V3D_TMU_TEX_STATE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).flipx = (uint32_t)(packed[0] & 1);
   (*unpacked).flipy = (uint32_t)(packed[0] >> 1 & 1);
   (*unpacked).srgb = (uint32_t)(packed[0] >> 3 & 1);
   (*unpacked).ahdr = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).reverse_std_bcol = (uint32_t)(packed[0] >> 5 & 1);
   (*unpacked).l0_addr = ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6;
   (*unpacked).arr_str = ((uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)(packed[7] & 3) << 24) << 6;
   (*unpacked).width = gfx_unpack_uint_0_is_max(
      (uint32_t)(packed[7] >> 2) | (uint32_t)packed[8] << 6, 14);
   (*unpacked).height = gfx_unpack_uint_0_is_max(
      (uint32_t)packed[9] | (uint32_t)(packed[10] & 63) << 8, 14);
   (*unpacked).depth = gfx_unpack_uint_0_is_max(
      (uint32_t)(packed[10] >> 6) | (uint32_t)packed[11] << 2 |
      (uint32_t)(packed[12] & 15) << 10, 14);
   (*unpacked).type = (v3d_tmu_type_t)((uint32_t)(packed[12] >> 4) |
      (uint32_t)(packed[13] & 7) << 4);
   (*unpacked).extended = (uint32_t)(packed[13] >> 3 & 1);
   (*unpacked).swizzles[0] = (v3d_tmu_swizzle_t)(uint32_t)(packed[13] >> 4 & 7);
   (*unpacked).swizzles[1] = (v3d_tmu_swizzle_t)((uint32_t)(packed[13] >> 7) |
      (uint32_t)(packed[14] & 3) << 1);
   (*unpacked).swizzles[2] = (v3d_tmu_swizzle_t)(uint32_t)(packed[14] >> 2 & 7);
   (*unpacked).swizzles[3] = (v3d_tmu_swizzle_t)(uint32_t)(packed[14] >> 5);
   (*unpacked).max_level = (uint32_t)(packed[15] & 15);
   (*unpacked).base_level = (uint32_t)(packed[15] >> 4);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_unpack_tmu_tex_extension(V3D_TMU_TEX_EXTENSION_T *unpacked, const uint8_t *packed)
{
   (*unpacked).ub_pad = (uint32_t)(packed[0] & 15);
   (*unpacked).ub_xor = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).uif_top = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).xor_dis = (uint32_t)(packed[0] >> 7);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_WRAP_I
void v3d_unpack_tmu_sampler(V3D_TMU_SAMPLER_T *unpacked, const uint8_t *packed)
{
   (*unpacked).filter = (v3d_tmu_filter_t)(uint32_t)(packed[0] & 15);
   (*unpacked).compare_func = (v3d_compare_func_t)(uint32_t)(packed[0] >> 4 & 7);
   (*unpacked).srgb_override = (uint32_t)(packed[0] >> 7);
   (*unpacked).min_lod = (uint32_t)packed[1] | (uint32_t)(packed[2] & 15) << 8;
   (*unpacked).max_lod = (uint32_t)(packed[2] >> 4) | (uint32_t)packed[3] << 4;
   (*unpacked).fixed_bias = gfx_sext(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 16);
   (*unpacked).wrap_s = (v3d_tmu_wrap_t)(uint32_t)(packed[6] & 7);
   (*unpacked).wrap_t = (v3d_tmu_wrap_t)(uint32_t)(packed[6] >> 3 & 7);
   (*unpacked).wrap_r = (v3d_tmu_wrap_t)((uint32_t)(packed[6] >> 6) |
      (uint32_t)(packed[7] & 1) << 2);
   (*unpacked).std_bcol = (v3d_tmu_std_bcol_t)(uint32_t)(packed[7] >> 1 & 7);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_WRAP_I
void v3d_unpack_tmu_sampler(V3D_TMU_SAMPLER_T *unpacked, const uint8_t *packed)
{
   (*unpacked).filter = (v3d_tmu_filter_t)(uint32_t)(packed[0] & 15);
   (*unpacked).compare_func = (v3d_compare_func_t)(uint32_t)(packed[0] >> 4 & 7);
   (*unpacked).srgb_override = (uint32_t)(packed[0] >> 7);
   (*unpacked).min_lod = (uint32_t)packed[1] | (uint32_t)(packed[2] & 15) << 8;
   (*unpacked).max_lod = (uint32_t)(packed[2] >> 4) | (uint32_t)packed[3] << 4;
   (*unpacked).fixed_bias = gfx_sext(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 16);
   (*unpacked).wrap_s = (v3d_tmu_wrap_t)(uint32_t)(packed[6] & 7);
   (*unpacked).wrap_t = (v3d_tmu_wrap_t)(uint32_t)(packed[6] >> 3 & 7);
   (*unpacked).wrap_r = (v3d_tmu_wrap_t)((uint32_t)(packed[6] >> 6) |
      (uint32_t)(packed[7] & 1) << 2);
   (*unpacked).wrap_i = (v3d_tmu_wrap_i_t)(uint32_t)(packed[7] >> 1 & 1);
   (*unpacked).std_bcol = (v3d_tmu_std_bcol_t)(uint32_t)(packed[7] >> 2 & 7);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_unpack_tf_spec(V3D_TF_SPEC_T *unpacked, const uint8_t *packed)
{
   (*unpacked).first = (uint32_t)packed[0];
   (*unpacked).count = (uint32_t)(packed[1] & 15) + 1;
   (*unpacked).buffer = (uint32_t)(packed[1] >> 4 & 3);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_unpack_tf_spec(V3D_TF_SPEC_T *unpacked, const uint8_t *packed)
{
   (*unpacked).first = (uint32_t)packed[0];
   (*unpacked).count = (uint32_t)(packed[1] & 15) + 1;
   (*unpacked).buffer = (uint32_t)(packed[1] >> 4 & 3);
   (*unpacked).stream = (uint32_t)(packed[1] >> 6);
}
#endif
#if !V3D_HAS_NEW_TILE_STATE
void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed)
{
   (*unpacked).cl_pos = packed[0];
   (*unpacked).prev_indices[0] = packed[1];
   (*unpacked).prev_indices[1] = packed[2];
   (*unpacked).prev_indices[2] = packed[3];
   (*unpacked).curr_xy_mode = packed[4] & 1;
   (*unpacked).prev_reverse_flag = packed[4] >> 1 & 1;
   (*unpacked).ctr = packed[4] >> 2 & 0x7fff;
   (*unpacked).blksize = (v3d_tile_alloc_block_size_t)(packed[4] >> 17 & 3);
   (*unpacked).halfwrt = packed[4] >> 19 & 1;
}
#endif
#if V3D_HAS_NEW_TILE_STATE && !V3D_HAS_INLINE_CLIP
void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed)
{
   (*unpacked).cl_pos = packed[0];
   (*unpacked).prev_indices[0] = packed[1];
   (*unpacked).prev_indices[1] = packed[2];
   (*unpacked).prev_indices[2] = packed[3];
   (*unpacked).curr_xy_mode = packed[4] & 1;
   (*unpacked).prev_reverse_flag = packed[4] >> 1 & 1;
   (*unpacked).ctr = packed[4] >> 2 & 0xffffff;
   (*unpacked).blksize = (v3d_tile_alloc_block_size_t)(packed[4] >> 26 & 3);
   (*unpacked).halfwrt = packed[4] >> 28 & 1;
}
#endif
#if V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG
void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed)
{
   (*unpacked).cl_pos = packed[0];
   (*unpacked).prev_indices[0] = packed[1];
   (*unpacked).prev_indices[1] = packed[2];
   (*unpacked).prev_indices[2] = packed[3];
   (*unpacked).prev_prim_id = packed[4];
   (*unpacked).curr_xy_mode = packed[5] & 1;
   (*unpacked).prev_reverse_flag = packed[5] >> 1 & 1;
   (*unpacked).ctr = packed[5] >> 2 & 0xffffff;
   (*unpacked).blksize = (v3d_tile_alloc_block_size_t)(packed[5] >> 26 & 3);
   (*unpacked).halfwrt = packed[5] >> 28 & 1;
}
#endif
#if V3D_HAS_TNG && !V3D_HAS_TL_START_UNC
void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed)
{
   (*unpacked).cl_pos = packed[0];
   (*unpacked).sn_pos = packed[1];
   (*unpacked).prev_indices[0] = packed[2];
   (*unpacked).prev_indices[1] = packed[3];
   (*unpacked).prev_indices[2] = packed[4];
   (*unpacked).prev_serials[0] = packed[5];
   (*unpacked).prev_serials[1] = packed[6];
   (*unpacked).prev_serials[2] = packed[7];
   (*unpacked).prev_prim_id = packed[8];
   (*unpacked).curr_xy_mode = packed[9] & 1;
   (*unpacked).in_generic_ind_list = packed[9] >> 1 & 1;
   (*unpacked).prev_reverse_flag = packed[9] >> 2 & 1;
   (*unpacked).ctr = packed[9] >> 3 & 0xffffff;
   (*unpacked).blksize = (v3d_tile_alloc_block_size_t)(packed[9] >> 27 & 3);
   (*unpacked).halfwrt = packed[9] >> 29 & 1;
   (*unpacked).deferred_sn = packed[9] >> 30 | (packed[10] & 0x3fffff) << 2;
   (*unpacked).cur_sn_level = packed[10] >> 22 & 3;
   (*unpacked).tg_tess = packed[10] >> 24 & 1;
   (*unpacked).tg_geom = packed[10] >> 25 & 1;
   (*unpacked).tg_geom_inst = packed[10] >> 26 & 1;
}
#endif
#if V3D_HAS_TL_START_UNC
void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed)
{
   (*unpacked).cl_pos = packed[0];
   (*unpacked).sn_pos = packed[1];
   (*unpacked).prev_indices[0] = packed[2];
   (*unpacked).prev_indices[1] = packed[3];
   (*unpacked).prev_indices[2] = packed[4];
   (*unpacked).prev_serials[0] = packed[5];
   (*unpacked).prev_serials[1] = packed[6];
   (*unpacked).prev_serials[2] = packed[7];
   (*unpacked).prev_prim_id = packed[8];
   (*unpacked).curr_xy_mode = packed[9] & 1;
   (*unpacked).in_generic_ind_list = packed[9] >> 1 & 1;
   (*unpacked).in_prim_list = packed[9] >> 2 & 1;
   (*unpacked).prev_reverse_flag = packed[9] >> 3 & 1;
   (*unpacked).ctr = packed[9] >> 4 & 0xffffff;
   (*unpacked).blksize = (v3d_tile_alloc_block_size_t)(packed[9] >> 28 & 3);
   (*unpacked).halfwrt = packed[9] >> 30 & 1;
   (*unpacked).deferred_sn = packed[9] >> 31 | (packed[10] & 0x7fffff) << 1;
   (*unpacked).cur_sn_level = packed[10] >> 23 & 3;
   (*unpacked).tg_tess = packed[10] >> 25 & 1;
   (*unpacked).tg_geom = packed[10] >> 26 & 1;
   (*unpacked).tg_geom_inst = packed[10] >> 27 & 1;
}
#endif
void v3d_unpack_indirect_indexed_record(V3D_INDIRECT_INDEXED_RECORD_T *unpacked, const uint32_t *packed)
{
   (*unpacked).num_indices = packed[0];
   (*unpacked).num_instances = packed[1];
   (*unpacked).index_of_first_index = packed[2];
   (*unpacked).base_vertex = (int32_t)packed[3];
   (*unpacked).base_instance = packed[4];
}
void v3d_unpack_indirect_arrays_record(V3D_INDIRECT_ARRAYS_RECORD_T *unpacked, const uint32_t *packed)
{
   (*unpacked).num_vertices = packed[0];
   (*unpacked).num_instances = packed[1];
   (*unpacked).first_index = packed[2];
   (*unpacked).base_instance = packed[3];
}
void v3d_unpack_clip_record(V3D_CLIP_RECORD_T *unpacked, const uint32_t *packed)
{
   (*unpacked).xs = (int32_t)packed[0];
   (*unpacked).ys = (int32_t)packed[1];
   (*unpacked).zs = gfx_float_from_bits(packed[2]);
   (*unpacked).rw = gfx_float_from_bits(packed[3]);
   (*unpacked).vcoeff[0] = gfx_float_from_bits(packed[4]);
   (*unpacked).vcoeff[1] = gfx_float_from_bits(packed[5]);
   (*unpacked).vcoeff[2] = gfx_float_from_bits(packed[6]);
}
void v3d_unpack_autochain_link(V3D_AUTOCHAIN_LINK_T *unpacked, const uint8_t *packed)
{
   (*unpacked).next_block_size =
      (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3);
   (*unpacked).more = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).next_block_addr =
      ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6;
}
#if !V3D_HAS_INLINE_CLIP
void v3d_unpack_cl_compr_ind_common(V3D_CL_COMPR_IND_COMMON_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)packed[0] == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID8;
      assert((uint32_t)packed[0] == 3);
      (*unpacked).u.iid8.iid = (uint32_t)packed[1];
   }
   else if ((uint32_t)packed[0] == 35)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID32;
      assert((uint32_t)packed[0] == 35);
      (*unpacked).u.iid32.iid = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)packed[0] == 19)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_REL_BRANCH;
      assert((uint32_t)packed[0] == 19);
      (*unpacked).u.rel_branch.rel_addr = gfx_sext(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 16) << 5;
   }
   else if ((uint32_t)packed[0] == 195)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_BRANCH;
      assert((uint32_t)packed[0] == 195);
      (*unpacked).u.branch.addr =
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5;
   }
   else if ((uint32_t)packed[0] == 227)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_ESCAPE;
      assert((uint32_t)packed[0] == 227);
   }
   else if (true)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_NOT_COMMON;
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_INLINE_CLIP
void v3d_unpack_cl_compr_ind_common(V3D_CL_COMPR_IND_COMMON_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)packed[0] == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID8;
      assert((uint32_t)packed[0] == 3);
      (*unpacked).u.iid8.iid = (uint32_t)packed[1];
   }
   else if ((uint32_t)packed[0] == 35)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID32;
      assert((uint32_t)packed[0] == 35);
      (*unpacked).u.iid32.iid = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)packed[0] == 19)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_PRIM_ID8;
      assert((uint32_t)packed[0] == 19);
      (*unpacked).u.prim_id8.rel_id = (uint32_t)packed[1];
   }
   else if ((uint32_t)packed[0] == 195)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_PRIM_ID32;
      assert((uint32_t)packed[0] == 195);
      (*unpacked).u.prim_id32.id = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_CLIPPED_PRIM;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.clipped_prim.is_first = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 3);
      (*unpacked).u.clipped_prim.clip_vert[0] = (uint32_t)(packed[1] & 1);
      (*unpacked).u.clipped_prim.clip_vert[1] = (uint32_t)(packed[1] >> 1 & 1);
      (*unpacked).u.clipped_prim.clip_vert[2] = (uint32_t)(packed[1] >> 2 & 1);
      (*unpacked).u.clipped_prim.flat_zw = (uint32_t)(packed[1] >> 3 & 1);
      (*unpacked).u.clipped_prim.addr =
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5;
   }
   else if ((uint32_t)packed[0] == 227)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_ESCAPE;
      assert((uint32_t)packed[0] == 227);
   }
   else if (true)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_NOT_COMMON;
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG
void v3d_unpack_cl_compr_serial(V3D_CL_COMPR_SERIAL_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_C0;
      assert((uint32_t)(packed[0] & 1) == 0);
      (*unpacked).u.c0.is_last = (uint32_t)(packed[0] >> 1 & 1);
      (*unpacked).u.c0.rel_value = (uint32_t)(packed[0] >> 2);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_C1;
      assert((uint32_t)(packed[0] & 3) == 1);
      (*unpacked).u.c1.is_last = (uint32_t)(packed[0] >> 2 & 1);
      (*unpacked).u.c1.rel_value =
         (uint32_t)(packed[0] >> 3) | (uint32_t)packed[1] << 5;
   }
   else if ((uint32_t)(packed[0] & 7) == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_C2;
      assert((uint32_t)(packed[0] & 7) == 3);
      (*unpacked).u.c2.count = (uint32_t)(packed[0] >> 3);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_C3;
      assert((uint32_t)(packed[0] & 15) == 7);
      (*unpacked).u.c3.is_last = (uint32_t)(packed[0] >> 4 & 1);
      (*unpacked).u.c3.value =
         (uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
         (uint32_t)packed[2] << 11;
   }
   else if ((uint32_t)(packed[0] & 15) == 15 && (uint32_t)(packed[0] >> 5) == 0)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM;
      assert((uint32_t)(packed[0] & 15) == 15);
      (*unpacked).u.clipped_prim.is_first = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 0);
      (*unpacked).u.clipped_prim.clip_vert[0] = (uint32_t)(packed[1] & 1);
      (*unpacked).u.clipped_prim.clip_vert[1] = (uint32_t)(packed[1] >> 1 & 1);
      (*unpacked).u.clipped_prim.clip_vert[2] = (uint32_t)(packed[1] >> 2 & 1);
      (*unpacked).u.clipped_prim.flat_zw = (uint32_t)(packed[1] >> 3 & 1);
      (*unpacked).u.clipped_prim.addr =
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5;
   }
   else if ((uint32_t)packed[0] == 47)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_TG_MODE;
      assert((uint32_t)packed[0] == 47);
      (*unpacked).u.tg_mode.tess = (uint32_t)(packed[1] & 1);
      (*unpacked).u.tg_mode.geom = (uint32_t)(packed[1] >> 1 & 1);
      (*unpacked).u.tg_mode.geom_iid = (uint32_t)(packed[1] >> 2 & 1);
   }
   else if ((uint32_t)(packed[0] & 15) == 15 && (uint32_t)(packed[0] >> 4) == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL;
      assert((uint32_t)(packed[0] & 15) == 15);
      assert((uint32_t)(packed[0] >> 4) == 3);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG && V3D_HAS_INLINE_CLIP
void v3d_unpack_cl_compr_ind_generic(V3D_CL_COMPR_IND_GENERIC_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      assert((uint32_t)(packed[0] & 1) == 0);
      (*unpacked).u.c0.diff = gfx_sext((uint32_t)(packed[0] >> 1), 7);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 3) == 1);
      (*unpacked).u.c1.diff = gfx_sext(
         (uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6, 14);
   }
   else if ((uint32_t)(packed[0] & 7) == 3)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 7) == 3);
      (*unpacked).u.c2.value = (uint32_t)(packed[0] >> 3);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)(packed[0] & 15) == 7);
      (*unpacked).u.c3.value = (uint32_t)(packed[0] >> 4) | (uint32_t)packed[1] << 4;
   }
   else if ((uint32_t)(packed[0] & 31) == 15)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C4;
      assert((uint32_t)(packed[0] & 31) == 15);
      (*unpacked).u.c4.value =
         (uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
         (uint32_t)packed[2] << 11;
   }
   else if ((uint32_t)packed[0] == 31)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C5;
      assert((uint32_t)packed[0] == 31);
      (*unpacked).u.c5.value = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
   }
   else if ((uint32_t)packed[0] == 63)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C6;
      assert((uint32_t)packed[0] == 63);
      (*unpacked).u.c6.value = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)packed[0] == 95)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID8;
      assert((uint32_t)packed[0] == 95);
      (*unpacked).u.iid8.iid = (uint32_t)packed[1];
   }
   else if ((uint32_t)packed[0] == 127)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_IID32;
      assert((uint32_t)packed[0] == 127);
      (*unpacked).u.iid32.iid = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)packed[0] == 159)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_PRIM_ID8;
      assert((uint32_t)packed[0] == 159);
      (*unpacked).u.prim_id8.diff = (uint32_t)packed[1];
   }
   else if ((uint32_t)packed[0] == 191)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_PRIM_ID32;
      assert((uint32_t)packed[0] == 191);
      (*unpacked).u.prim_id32.value =
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24;
   }
   else if ((uint32_t)packed[0] == 255)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_ESCAPE;
      assert((uint32_t)packed[0] == 255);
   }
   else
   {
      unreachable();
   }
}
#endif
void v3d_unpack_cl_compr_ind_tri(V3D_CL_COMPR_IND_TRI_T *unpacked, const uint8_t *packed)
{
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      (*unpacked).u.c0.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3);
      (*unpacked).u.c0.diff2 = gfx_sext((uint32_t)(packed[0] >> 2), 6);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 15) == 7);
      (*unpacked).u.c1.diff0 = gfx_sext((uint32_t)(packed[0] >> 4), 4);
      (*unpacked).u.c1.diff1 = gfx_sext((uint32_t)(packed[1] & 15), 4);
      (*unpacked).u.c1.diff2 = gfx_sext((uint32_t)(packed[1] >> 4), 4);
   }
   else if ((uint32_t)(packed[0] & 15) == 11)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 15) == 11);
      (*unpacked).u.c2.diff1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6);
      (*unpacked).u.c2.diff2 = gfx_sext((uint32_t)(packed[1] >> 2), 6);
      (*unpacked).u.c2.idx0 = (uint32_t)packed[2] | (uint32_t)packed[3] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)(packed[0] & 15) == 15);
      (*unpacked).u.c3.diff1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6);
      (*unpacked).u.c3.diff2 = gfx_sext((uint32_t)(packed[1] >> 2), 6);
      (*unpacked).u.c3.idx0 = (uint32_t)packed[2] | (uint32_t)packed[3] << 8 |
         (uint32_t)packed[4] << 16;
   }
   else if ((uint32_t)packed[0] == 131)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C4;
      assert((uint32_t)packed[0] == 131);
      (*unpacked).u.c4.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.c4.idx1 = (uint32_t)packed[3] | (uint32_t)packed[4] << 8;
      (*unpacked).u.c4.idx2 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8;
   }
   else if ((uint32_t)packed[0] == 163)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C5;
      assert((uint32_t)packed[0] == 163);
      (*unpacked).u.c5.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
      (*unpacked).u.c5.idx1 = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
         (uint32_t)packed[6] << 16;
      (*unpacked).u.c5.idx2 = (uint32_t)packed[7] | (uint32_t)packed[8] << 8 |
         (uint32_t)packed[9] << 16;
   }
   else if ((uint32_t)packed[0] == 67)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C6;
      assert((uint32_t)packed[0] == 67);
      (*unpacked).u.c6.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
      (*unpacked).u.c6.idx1 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
         (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
      (*unpacked).u.c6.idx2 = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
         (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   }
   else
   {
      unreachable();
   }
}
void v3d_unpack_cl_compr_ind_d3dpvsf_tri(V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked, const uint8_t *packed)
{
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      (*unpacked).u.c0.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3);
      (*unpacked).u.c0.diff2 = gfx_sext((uint32_t)(packed[0] >> 2 & 31), 5);
      (*unpacked).u.c0.prov_vtx = (uint32_t)(packed[0] >> 7);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 15) == 7);
      (*unpacked).u.c1.diff0 = gfx_sext((uint32_t)(packed[0] >> 4 & 7), 3);
      (*unpacked).u.c1.prov_vtx = (uint32_t)(packed[0] >> 7);
      (*unpacked).u.c1.diff1 = gfx_sext((uint32_t)(packed[1] & 15), 4);
      (*unpacked).u.c1.diff2 = gfx_sext((uint32_t)(packed[1] >> 4), 4);
   }
   else if ((uint32_t)(packed[0] & 15) == 11)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 15) == 11);
      (*unpacked).u.c2.diff1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6);
      (*unpacked).u.c2.diff2 = gfx_sext((uint32_t)(packed[1] >> 2), 6);
      (*unpacked).u.c2.idx0 = (uint32_t)packed[2] | (uint32_t)(packed[3] & 127) << 8;
      (*unpacked).u.c2.prov_vtx = (uint32_t)(packed[3] >> 7);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)(packed[0] & 15) == 15);
      (*unpacked).u.c3.diff1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6);
      (*unpacked).u.c3.diff2 = gfx_sext((uint32_t)(packed[1] >> 2), 6);
      (*unpacked).u.c3.idx0 = (uint32_t)packed[2] | (uint32_t)packed[3] << 8 |
         (uint32_t)(packed[4] & 127) << 16;
      (*unpacked).u.c3.prov_vtx = (uint32_t)(packed[4] >> 7);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C4;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c4.prov_vtx = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 4);
      (*unpacked).u.c4.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.c4.idx1 = (uint32_t)packed[3] | (uint32_t)packed[4] << 8;
      (*unpacked).u.c4.idx2 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C5;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c5.prov_vtx = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 5);
      (*unpacked).u.c5.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
      (*unpacked).u.c5.idx1 = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
         (uint32_t)packed[6] << 16;
      (*unpacked).u.c5.idx2 = (uint32_t)packed[7] | (uint32_t)packed[8] << 8 |
         (uint32_t)packed[9] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C6;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c6.prov_vtx = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 2);
      (*unpacked).u.c6.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
      (*unpacked).u.c6.idx1 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
         (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
      (*unpacked).u.c6.idx2 = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
         (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   }
   else
   {
      unreachable();
   }
}
void v3d_unpack_cl_compr_ind_line(V3D_CL_COMPR_IND_LINE_T *unpacked, const uint8_t *packed)
{
   if (v3d_is_valid_line_ind_reuse((v3d_line_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      (*unpacked).u.c0.reuse = (v3d_line_ind_reuse_t)(uint32_t)(packed[0] & 3);
      (*unpacked).u.c0.diff1 = gfx_sext((uint32_t)(packed[0] >> 2), 6);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 15) == 7);
      (*unpacked).u.c1.diff0 = gfx_sext((uint32_t)(packed[0] >> 4), 4);
      (*unpacked).u.c1.diff1 = gfx_sext((uint32_t)(packed[1] & 15), 4);
      (*unpacked).u.c1.reversed = (uint32_t)(packed[1] >> 4 & 1);
   }
   else if ((uint32_t)(packed[0] & 3) == 2)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 3) == 2);
      (*unpacked).u.c2.diff1 = gfx_sext((uint32_t)(packed[0] >> 2), 6);
      (*unpacked).u.c2.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && (uint32_t)(packed[0] >> 3 & 1) == 1)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)(packed[0] & 3) == 3);
      (*unpacked).u.c3.reversed = (uint32_t)(packed[0] >> 2 & 1);
      assert((uint32_t)(packed[0] >> 3 & 1) == 1);
      (*unpacked).u.c3.diff1 = gfx_sext((uint32_t)(packed[0] >> 4), 4);
      (*unpacked).u.c3.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C4;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c4.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 4);
      (*unpacked).u.c4.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.c4.idx1 = (uint32_t)packed[3] | (uint32_t)packed[4] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C5;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c5.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 5);
      (*unpacked).u.c5.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
      (*unpacked).u.c5.idx1 = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
         (uint32_t)packed[6] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C6;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c6.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 2);
      (*unpacked).u.c6.idx0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
      (*unpacked).u.c6.idx1 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
         (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   }
   else
   {
      unreachable();
   }
}
void v3d_unpack_cl_compr_ind_point(V3D_CL_COMPR_IND_POINT_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 3) == 0)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      assert((uint32_t)(packed[0] & 3) == 0);
      (*unpacked).u.c0.diff = gfx_sext((uint32_t)(packed[0] >> 2), 6);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 3) == 1);
      (*unpacked).u.c1.diff = gfx_sext((uint32_t)(packed[0] >> 2) |
         (uint32_t)(packed[1] & 127) << 6, 13);
      (*unpacked).u.c1.reversed = (uint32_t)(packed[1] >> 7);
   }
   else if ((uint32_t)(packed[0] & 3) == 2)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 3) == 2);
      (*unpacked).u.c2.diff = gfx_sext((uint32_t)(packed[0] >> 2), 6);
      (*unpacked).u.c2.count = (uint32_t)(packed[1] & 127) + 1;
      (*unpacked).u.c2.reversed = (uint32_t)(packed[1] >> 7);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C4;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c4.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 4);
      (*unpacked).u.c4.idx = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C5;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c5.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 5);
      (*unpacked).u.c5.idx = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C6;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.c6.reversed = (uint32_t)(packed[0] >> 4 & 1);
      assert((uint32_t)(packed[0] >> 5) == 2);
      (*unpacked).u.c6.idx = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
         (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   }
   else
   {
      unreachable();
   }
}
#if V3D_HAS_INLINE_CLIP
void v3d_unpack_cl_compr_xy_tri(V3D_CL_COMPR_XY_TRI_T *unpacked, const uint8_t *packed)
{
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)) &&
      -62 <= gfx_sext(gfx_rol(
      (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      (*unpacked).u.c0.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3);
      (*unpacked).u.c0.dx2 = gfx_sext(gfx_rol(
         (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7);
      (*unpacked).u.c0.dy2 = gfx_sext((uint32_t)(packed[1] >> 1), 7);
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && v3d_is_valid_tri_ind_reuse(
      (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 3) == 3);
      (*unpacked).u.c1.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3);
      (*unpacked).u.c1.dx2 = gfx_sext((uint32_t)(packed[0] >> 4) |
         (uint32_t)(packed[1] & 63) << 4, 10);
      (*unpacked).u.c1.dy2 = gfx_sext(
         (uint32_t)(packed[1] >> 6) | (uint32_t)packed[2] << 2, 10);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 15) == 15);
      (*unpacked).u.c2.dx1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 7) << 4, 7);
      (*unpacked).u.c2.dy1 = gfx_sext(
         (uint32_t)(packed[1] >> 3) | (uint32_t)(packed[2] & 3) << 5, 7);
      (*unpacked).u.c2.dx2 = gfx_sext(
         (uint32_t)(packed[2] >> 2) | (uint32_t)(packed[3] & 1) << 6, 7);
      (*unpacked).u.c2.dy2 = gfx_sext((uint32_t)(packed[3] >> 1), 7);
      (*unpacked).u.c2.x0 = (uint32_t)packed[4] | (uint32_t)packed[5] << 8;
      (*unpacked).u.c2.y0 = (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   }
   else if ((uint32_t)packed[0] == 129)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)packed[0] == 129);
      (*unpacked).u.c3.x0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.c3.y0 = (uint32_t)packed[3] | (uint32_t)packed[4] << 8;
      (*unpacked).u.c3.x1 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8;
      (*unpacked).u.c3.y1 = (uint32_t)packed[7] | (uint32_t)packed[8] << 8;
      (*unpacked).u.c3.x2 = (uint32_t)packed[9] | (uint32_t)packed[10] << 8;
      (*unpacked).u.c3.y2 = (uint32_t)packed[11] | (uint32_t)packed[12] << 8;
   }
   else if ((uint32_t)packed[0] == 128)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_ESCAPE;
      assert((uint32_t)packed[0] == 128);
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_HAS_INLINE_CLIP
void v3d_unpack_cl_compr_xy_tri(V3D_CL_COMPR_XY_TRI_T *unpacked, const uint8_t *packed)
{
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)) &&
      -62 <= gfx_sext(gfx_rol(
      (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C0;
      (*unpacked).u.c0.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3);
      (*unpacked).u.c0.dx2 = gfx_sext(gfx_rol(
         (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7);
      (*unpacked).u.c0.dy2 = gfx_sext((uint32_t)(packed[1] >> 1), 7);
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && v3d_is_valid_tri_ind_reuse(
      (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)))
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C1;
      assert((uint32_t)(packed[0] & 3) == 3);
      (*unpacked).u.c1.reuse = (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3);
      (*unpacked).u.c1.dx2 = gfx_sext((uint32_t)(packed[0] >> 4) |
         (uint32_t)(packed[1] & 63) << 4, 10);
      (*unpacked).u.c1.dy2 = gfx_sext(
         (uint32_t)(packed[1] >> 6) | (uint32_t)packed[2] << 2, 10);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C2;
      assert((uint32_t)(packed[0] & 15) == 15);
      (*unpacked).u.c2.dx1 = gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 7) << 4, 7);
      (*unpacked).u.c2.dy1 = gfx_sext(
         (uint32_t)(packed[1] >> 3) | (uint32_t)(packed[2] & 3) << 5, 7);
      (*unpacked).u.c2.dx2 = gfx_sext(
         (uint32_t)(packed[2] >> 2) | (uint32_t)(packed[3] & 1) << 6, 7);
      (*unpacked).u.c2.dy2 = gfx_sext((uint32_t)(packed[3] >> 1), 7);
      (*unpacked).u.c2.x0 = (uint32_t)packed[4] | (uint32_t)packed[5] << 8;
      (*unpacked).u.c2.y0 = (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   }
   else if ((uint32_t)packed[0] == 129)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_C3;
      assert((uint32_t)packed[0] == 129);
      (*unpacked).u.c3.x0 = (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.c3.y0 = (uint32_t)packed[3] | (uint32_t)packed[4] << 8;
      (*unpacked).u.c3.x1 = (uint32_t)packed[5] | (uint32_t)packed[6] << 8;
      (*unpacked).u.c3.y1 = (uint32_t)packed[7] | (uint32_t)packed[8] << 8;
      (*unpacked).u.c3.x2 = (uint32_t)packed[9] | (uint32_t)packed[10] << 8;
      (*unpacked).u.c3.y2 = (uint32_t)packed[11] | (uint32_t)packed[12] << 8;
   }
   else if ((uint32_t)packed[0] == 130)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_REL_BRANCH;
      assert((uint32_t)packed[0] == 130);
      (*unpacked).u.rel_branch.rel_addr = gfx_sext(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 16) << 5;
   }
   else if ((uint32_t)packed[0] == 128)
   {
      (*unpacked).type = V3D_CL_COMPR_TYPE_ESCAPE;
      assert((uint32_t)packed[0] == 128);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG
void v3d_unpack_gs_vpm_fmt(V3D_GS_VPM_FMT_T *unpacked, uint32_t packed0)
{
   (*unpacked).start_prim = packed0 & 1;
   (*unpacked).stream_idx = packed0 >> 1 & 3;
   (*unpacked).length = packed0 >> 8 & 255;
   (*unpacked).layer_idx = packed0 >> 16 & 255;
   (*unpacked).viewport_idx = packed0 >> 24 & 15;
}
#endif
void v3d_unpack_bstc_block(V3D_BSTC_BLOCK_T *unpacked, const uint8_t *packed)
{
   if (((uint32_t)(packed[23] >> 4 & 1) == 0 ||
      (uint32_t)(packed[23] >> 4 & 1) == 1) &&
      (((uint32_t)(packed[3] >> 6 & 1) == 0 ||
      (uint32_t)(packed[3] >> 6 & 1) == 1) && ((uint32_t)(packed[9] >> 5 & 1) == 0 ||
      (uint32_t)(packed[9] >> 5 & 1) == 1)) && (uint32_t)(packed[3] >> 7) == 0)
   {
      assert((uint32_t)(packed[3] >> 7) == 0);
      if ((uint32_t)(packed[3] >> 6 & 1) == 0)
      {
         assert((uint32_t)(packed[3] >> 6 & 1) == 0);
         (*unpacked).u.three_plane.rg[0].u.normal_range.min =
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 63) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.max =
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 63) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[0] =
            (uint32_t)(packed[1] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[1] =
            (uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[2] =
            (uint32_t)(packed[0] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[3] =
            (uint32_t)(packed[7] >> 6) | (uint32_t)(packed[0] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[4] =
            (uint32_t)(packed[7] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[5] =
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[6] =
            (uint32_t)(packed[6] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[7] =
            (uint32_t)(packed[5] >> 6) | (uint32_t)(packed[6] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[8] =
            (uint32_t)(packed[5] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[9] =
            (uint32_t)(packed[4] >> 6) | (uint32_t)(packed[5] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[10] =
            (uint32_t)(packed[4] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[11] =
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[12] =
            (uint32_t)(packed[11] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[13] =
            (uint32_t)(packed[10] >> 6) | (uint32_t)(packed[11] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[14] =
            (uint32_t)(packed[10] >> 2 & 15);
         (*unpacked).u.three_plane.rg[0].u.normal_range.weights[15] =
            (uint32_t)(packed[9] >> 6) | (uint32_t)(packed[10] & 3) << 2;
         (*unpacked).u.three_plane.rg[0].max_range = false;
      }
      else if ((uint32_t)(packed[3] >> 6 & 1) == 1)
      {
         (*unpacked).u.three_plane.rg[0].max_range = true;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[0] =
            (uint32_t)(packed[3] >> 1 & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[1] =
            (uint32_t)(packed[2] >> 4) | (uint32_t)(packed[3] & 1) << 4;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[2] =
            (uint32_t)(packed[1] >> 7) | (uint32_t)(packed[2] & 15) << 1;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[3] =
            (uint32_t)(packed[1] >> 2 & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[4] =
            (uint32_t)(packed[0] >> 5) | (uint32_t)(packed[1] & 3) << 3;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[5] =
            (uint32_t)(packed[0] & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[6] =
            (uint32_t)(packed[7] >> 3);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[7] =
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 7) << 2;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[8] =
            (uint32_t)(packed[6] >> 1 & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[9] =
            (uint32_t)(packed[5] >> 4) | (uint32_t)(packed[6] & 1) << 4;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[10] =
            (uint32_t)(packed[4] >> 7) | (uint32_t)(packed[5] & 15) << 1;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[11] =
            (uint32_t)(packed[4] >> 2 & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[12] =
            (uint32_t)(packed[11] >> 5) | (uint32_t)(packed[4] & 3) << 3;
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[13] =
            (uint32_t)(packed[11] & 31);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[14] =
            (uint32_t)(packed[10] >> 3);
         (*unpacked).u.three_plane.rg[0].u.max_range.weights[15] =
            (uint32_t)(packed[9] >> 6) | (uint32_t)(packed[10] & 7) << 2;
         assert((uint32_t)(packed[3] >> 6 & 1) == 1);
      }
      else
      {
         unreachable();
      }
      if ((uint32_t)(packed[9] >> 5 & 1) == 0)
      {
         assert((uint32_t)(packed[9] >> 5 & 1) == 0);
         (*unpacked).u.three_plane.rg[1].u.normal_range.min =
            (uint32_t)(packed[8] >> 5) | (uint32_t)(packed[9] & 31) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.max =
            (uint32_t)(packed[15] >> 5) | (uint32_t)(packed[8] & 31) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[0] =
            (uint32_t)(packed[15] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[1] =
            (uint32_t)(packed[14] >> 5) | (uint32_t)(packed[15] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[2] =
            (uint32_t)(packed[14] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[3] =
            (uint32_t)(packed[13] >> 5) | (uint32_t)(packed[14] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[4] =
            (uint32_t)(packed[13] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[5] =
            (uint32_t)(packed[12] >> 5) | (uint32_t)(packed[13] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[6] =
            (uint32_t)(packed[12] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[7] =
            (uint32_t)(packed[19] >> 5) | (uint32_t)(packed[12] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[8] =
            (uint32_t)(packed[19] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[9] =
            (uint32_t)(packed[18] >> 5) | (uint32_t)(packed[19] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[10] =
            (uint32_t)(packed[18] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[11] =
            (uint32_t)(packed[17] >> 5) | (uint32_t)(packed[18] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[12] =
            (uint32_t)(packed[17] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[13] =
            (uint32_t)(packed[16] >> 5) | (uint32_t)(packed[17] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[14] =
            (uint32_t)(packed[16] >> 1 & 15);
         (*unpacked).u.three_plane.rg[1].u.normal_range.weights[15] =
            (uint32_t)(packed[23] >> 5) | (uint32_t)(packed[16] & 1) << 3;
         (*unpacked).u.three_plane.rg[1].max_range = false;
      }
      else if ((uint32_t)(packed[9] >> 5 & 1) == 1)
      {
         (*unpacked).u.three_plane.rg[1].max_range = true;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[0] =
            (uint32_t)(packed[9] & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[1] =
            (uint32_t)(packed[8] >> 3);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[2] =
            (uint32_t)(packed[15] >> 6) | (uint32_t)(packed[8] & 7) << 2;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[3] =
            (uint32_t)(packed[15] >> 1 & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[4] =
            (uint32_t)(packed[14] >> 4) | (uint32_t)(packed[15] & 1) << 4;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[5] =
            (uint32_t)(packed[13] >> 7) | (uint32_t)(packed[14] & 15) << 1;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[6] =
            (uint32_t)(packed[13] >> 2 & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[7] =
            (uint32_t)(packed[12] >> 5) | (uint32_t)(packed[13] & 3) << 3;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[8] =
            (uint32_t)(packed[12] & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[9] =
            (uint32_t)(packed[19] >> 3);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[10] =
            (uint32_t)(packed[18] >> 6) | (uint32_t)(packed[19] & 7) << 2;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[11] =
            (uint32_t)(packed[18] >> 1 & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[12] =
            (uint32_t)(packed[17] >> 4) | (uint32_t)(packed[18] & 1) << 4;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[13] =
            (uint32_t)(packed[16] >> 7) | (uint32_t)(packed[17] & 15) << 1;
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[14] =
            (uint32_t)(packed[16] >> 2 & 31);
         (*unpacked).u.three_plane.rg[1].u.max_range.weights[15] =
            (uint32_t)(packed[23] >> 5) | (uint32_t)(packed[16] & 3) << 3;
         assert((uint32_t)(packed[9] >> 5 & 1) == 1);
      }
      else
      {
         unreachable();
      }
      if ((uint32_t)(packed[23] >> 4 & 1) == 0)
      {
         assert((uint32_t)(packed[23] >> 4 & 1) == 0);
         (*unpacked).u.three_plane.ba.u.normal_range.min_b =
            (uint32_t)(packed[22] >> 4) | (uint32_t)(packed[23] & 15) << 4;
         (*unpacked).u.three_plane.ba.u.normal_range.max_b =
            (uint32_t)(packed[21] >> 4) | (uint32_t)(packed[22] & 15) << 4;
         (*unpacked).u.three_plane.ba.u.normal_range.min_a =
            (uint32_t)(packed[20] >> 6) | (uint32_t)(packed[21] & 15) << 2;
         (*unpacked).u.three_plane.ba.u.normal_range.max_a = (uint32_t)(packed[20] & 63);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[0] =
            (uint32_t)(packed[27] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[1] =
            (uint32_t)(packed[27] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[2] =
            (uint32_t)(packed[26] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[3] =
            (uint32_t)(packed[26] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[4] =
            (uint32_t)(packed[25] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[5] =
            (uint32_t)(packed[25] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[6] =
            (uint32_t)(packed[24] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[7] =
            (uint32_t)(packed[24] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[8] =
            (uint32_t)(packed[31] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[9] =
            (uint32_t)(packed[31] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[10] =
            (uint32_t)(packed[30] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[11] =
            (uint32_t)(packed[30] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[12] =
            (uint32_t)(packed[29] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[13] =
            (uint32_t)(packed[29] & 15);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[14] =
            (uint32_t)(packed[28] >> 4);
         (*unpacked).u.three_plane.ba.u.normal_range.weights[15] =
            (uint32_t)(packed[28] & 15);
         (*unpacked).u.three_plane.ba.max_range = false;
      }
      else if ((uint32_t)(packed[23] >> 4 & 1) == 1)
      {
         assert((uint32_t)(packed[23] >> 4 & 1) == 1);
         (*unpacked).u.three_plane.ba.u.max_range.min_a = (uint32_t)(packed[22] >> 6) |
            (uint32_t)(packed[23] & 15) << 2;
         (*unpacked).u.three_plane.ba.u.max_range.max_a = (uint32_t)(packed[22] & 63);
         (*unpacked).u.three_plane.ba.u.max_range.weights[0] =
            (uint32_t)(packed[21] >> 3);
         (*unpacked).u.three_plane.ba.u.max_range.weights[1] =
            (uint32_t)(packed[20] >> 6) | (uint32_t)(packed[21] & 7) << 2;
         (*unpacked).u.three_plane.ba.u.max_range.weights[2] =
            (uint32_t)(packed[20] >> 1 & 31);
         (*unpacked).u.three_plane.ba.u.max_range.weights[3] =
            (uint32_t)(packed[27] >> 4) | (uint32_t)(packed[20] & 1) << 4;
         (*unpacked).u.three_plane.ba.u.max_range.weights[4] =
            (uint32_t)(packed[26] >> 7) | (uint32_t)(packed[27] & 15) << 1;
         (*unpacked).u.three_plane.ba.u.max_range.weights[5] =
            (uint32_t)(packed[26] >> 2 & 31);
         (*unpacked).u.three_plane.ba.u.max_range.weights[6] =
            (uint32_t)(packed[25] >> 5) | (uint32_t)(packed[26] & 3) << 3;
         (*unpacked).u.three_plane.ba.u.max_range.weights[7] =
            (uint32_t)(packed[25] & 31);
         (*unpacked).u.three_plane.ba.u.max_range.weights[8] =
            (uint32_t)(packed[24] >> 3);
         (*unpacked).u.three_plane.ba.u.max_range.weights[9] =
            (uint32_t)(packed[31] >> 6) | (uint32_t)(packed[24] & 7) << 2;
         (*unpacked).u.three_plane.ba.u.max_range.weights[10] =
            (uint32_t)(packed[31] >> 1 & 31);
         (*unpacked).u.three_plane.ba.u.max_range.weights[11] =
            (uint32_t)(packed[30] >> 4) | (uint32_t)(packed[31] & 1) << 4;
         (*unpacked).u.three_plane.ba.u.max_range.weights[12] =
            (uint32_t)(packed[29] >> 7) | (uint32_t)(packed[30] & 15) << 1;
         (*unpacked).u.three_plane.ba.u.max_range.weights[13] =
            (uint32_t)(packed[29] >> 2 & 31);
         (*unpacked).u.three_plane.ba.u.max_range.weights[14] =
            (uint32_t)(packed[28] >> 5) | (uint32_t)(packed[29] & 3) << 3;
         (*unpacked).u.three_plane.ba.u.max_range.weights[15] =
            (uint32_t)(packed[28] & 31);
         (*unpacked).u.three_plane.ba.max_range = true;
      }
      else
      {
         unreachable();
      }
      (*unpacked).four_plane = false;
   }
   else if (((uint32_t)(packed[3] >> 6 & 1) == 0 || (uint32_t)(packed[3] >> 6 & 1) == 1) &&
      ((uint32_t)(packed[11] >> 5 & 1) == 0 ||
      (uint32_t)(packed[11] >> 5 & 1) == 1) &&
      ((uint32_t)(packed[19] >> 4 & 1) == 0 ||
      (uint32_t)(packed[19] >> 4 & 1) == 1) && (uint32_t)(packed[3] >> 7) == 1)
   {
      assert((uint32_t)(packed[3] >> 7) == 1);
      if ((uint32_t)(packed[3] >> 6 & 1) == 0)
      {
         assert((uint32_t)(packed[3] >> 6 & 1) == 0);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.min =
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 63) << 2;
         (*unpacked).u.four_plane.rgb[0].u.normal_range.max =
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 63) << 2;
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[0] =
            (uint32_t)(packed[1] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[1] =
            (uint32_t)(packed[1] & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[2] =
            (uint32_t)(packed[0] >> 5);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[3] =
            (uint32_t)(packed[0] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[4] =
            (uint32_t)(packed[7] >> 7) | (uint32_t)(packed[0] & 3) << 1;
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[5] =
            (uint32_t)(packed[7] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[6] =
            (uint32_t)(packed[7] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[7] =
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 1) << 2;
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[8] =
            (uint32_t)(packed[6] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[9] =
            (uint32_t)(packed[6] & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[10] =
            (uint32_t)(packed[5] >> 5);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[11] =
            (uint32_t)(packed[5] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[12] =
            (uint32_t)(packed[4] >> 7) | (uint32_t)(packed[5] & 3) << 1;
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[13] =
            (uint32_t)(packed[4] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[14] =
            (uint32_t)(packed[4] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[15] =
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 1) << 2;
         (*unpacked).u.four_plane.rgb[0].max_range = false;
      }
      else if ((uint32_t)(packed[3] >> 6 & 1) == 1)
      {
         (*unpacked).u.four_plane.rgb[0].max_range = true;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[0] =
            (uint32_t)(packed[3] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[1] =
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[2] =
            (uint32_t)(packed[2] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[3] =
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[4] =
            (uint32_t)(packed[1] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[5] =
            (uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[6] =
            (uint32_t)(packed[0] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[7] =
            (uint32_t)(packed[7] >> 6) | (uint32_t)(packed[0] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[8] =
            (uint32_t)(packed[7] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[9] =
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[10] =
            (uint32_t)(packed[6] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[11] =
            (uint32_t)(packed[5] >> 6) | (uint32_t)(packed[6] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[12] =
            (uint32_t)(packed[5] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[13] =
            (uint32_t)(packed[4] >> 6) | (uint32_t)(packed[5] & 3) << 2;
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[14] =
            (uint32_t)(packed[4] >> 2 & 15);
         (*unpacked).u.four_plane.rgb[0].u.max_range.weights[15] =
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 3) << 2;
         assert((uint32_t)(packed[3] >> 6 & 1) == 1);
      }
      else
      {
         unreachable();
      }
      if ((uint32_t)(packed[11] >> 5 & 1) == 0)
      {
         assert((uint32_t)(packed[11] >> 5 & 1) == 0);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.min =
            (uint32_t)(packed[10] >> 5) | (uint32_t)(packed[11] & 31) << 3;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.max =
            (uint32_t)(packed[9] >> 5) | (uint32_t)(packed[10] & 31) << 3;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[0] =
            (uint32_t)(packed[9] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[1] =
            (uint32_t)(packed[8] >> 7) | (uint32_t)(packed[9] & 3) << 1;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[2] =
            (uint32_t)(packed[8] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[3] =
            (uint32_t)(packed[8] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[4] =
            (uint32_t)(packed[15] >> 6) | (uint32_t)(packed[8] & 1) << 2;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[5] =
            (uint32_t)(packed[15] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[6] =
            (uint32_t)(packed[15] & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[7] =
            (uint32_t)(packed[14] >> 5);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[8] =
            (uint32_t)(packed[14] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[9] =
            (uint32_t)(packed[13] >> 7) | (uint32_t)(packed[14] & 3) << 1;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[10] =
            (uint32_t)(packed[13] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[11] =
            (uint32_t)(packed[13] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[12] =
            (uint32_t)(packed[12] >> 6) | (uint32_t)(packed[13] & 1) << 2;
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[13] =
            (uint32_t)(packed[12] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[14] =
            (uint32_t)(packed[12] & 7);
         (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[15] =
            (uint32_t)(packed[19] >> 5);
         (*unpacked).u.four_plane.rgb[1].max_range = false;
      }
      else if ((uint32_t)(packed[11] >> 5 & 1) == 1)
      {
         (*unpacked).u.four_plane.rgb[1].max_range = true;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[0] =
            (uint32_t)(packed[11] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[1] =
            (uint32_t)(packed[10] >> 5) | (uint32_t)(packed[11] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[2] =
            (uint32_t)(packed[10] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[3] =
            (uint32_t)(packed[9] >> 5) | (uint32_t)(packed[10] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[4] =
            (uint32_t)(packed[9] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[5] =
            (uint32_t)(packed[8] >> 5) | (uint32_t)(packed[9] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[6] =
            (uint32_t)(packed[8] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[7] =
            (uint32_t)(packed[15] >> 5) | (uint32_t)(packed[8] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[8] =
            (uint32_t)(packed[15] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[9] =
            (uint32_t)(packed[14] >> 5) | (uint32_t)(packed[15] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[10] =
            (uint32_t)(packed[14] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[11] =
            (uint32_t)(packed[13] >> 5) | (uint32_t)(packed[14] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[12] =
            (uint32_t)(packed[13] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[13] =
            (uint32_t)(packed[12] >> 5) | (uint32_t)(packed[13] & 1) << 3;
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[14] =
            (uint32_t)(packed[12] >> 1 & 15);
         (*unpacked).u.four_plane.rgb[1].u.max_range.weights[15] =
            (uint32_t)(packed[19] >> 5) | (uint32_t)(packed[12] & 1) << 3;
         assert((uint32_t)(packed[11] >> 5 & 1) == 1);
      }
      else
      {
         unreachable();
      }
      if ((uint32_t)(packed[19] >> 4 & 1) == 0)
      {
         assert((uint32_t)(packed[19] >> 4 & 1) == 0);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.min =
            (uint32_t)(packed[18] >> 4) | (uint32_t)(packed[19] & 15) << 4;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.max =
            (uint32_t)(packed[17] >> 4) | (uint32_t)(packed[18] & 15) << 4;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[0] =
            (uint32_t)(packed[17] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[1] =
            (uint32_t)(packed[16] >> 6) | (uint32_t)(packed[17] & 1) << 2;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[2] =
            (uint32_t)(packed[16] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[3] =
            (uint32_t)(packed[16] & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[4] =
            (uint32_t)(packed[23] >> 5);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[5] =
            (uint32_t)(packed[23] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[6] =
            (uint32_t)(packed[22] >> 7) | (uint32_t)(packed[23] & 3) << 1;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[7] =
            (uint32_t)(packed[22] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[8] =
            (uint32_t)(packed[22] >> 1 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[9] =
            (uint32_t)(packed[21] >> 6) | (uint32_t)(packed[22] & 1) << 2;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[10] =
            (uint32_t)(packed[21] >> 3 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[11] =
            (uint32_t)(packed[21] & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[12] =
            (uint32_t)(packed[20] >> 5);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[13] =
            (uint32_t)(packed[20] >> 2 & 7);
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[14] =
            (uint32_t)(packed[27] >> 7) | (uint32_t)(packed[20] & 3) << 1;
         (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[15] =
            (uint32_t)(packed[27] >> 4 & 7);
         (*unpacked).u.four_plane.rgb[2].max_range = false;
      }
      else if ((uint32_t)(packed[19] >> 4 & 1) == 1)
      {
         (*unpacked).u.four_plane.rgb[2].max_range = true;
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[0] =
            (uint32_t)(packed[19] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[1] =
            (uint32_t)(packed[18] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[2] =
            (uint32_t)(packed[18] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[3] =
            (uint32_t)(packed[17] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[4] =
            (uint32_t)(packed[17] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[5] =
            (uint32_t)(packed[16] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[6] =
            (uint32_t)(packed[16] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[7] =
            (uint32_t)(packed[23] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[8] =
            (uint32_t)(packed[23] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[9] =
            (uint32_t)(packed[22] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[10] =
            (uint32_t)(packed[22] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[11] =
            (uint32_t)(packed[21] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[12] =
            (uint32_t)(packed[21] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[13] =
            (uint32_t)(packed[20] >> 4);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[14] =
            (uint32_t)(packed[20] & 15);
         (*unpacked).u.four_plane.rgb[2].u.max_range.weights[15] =
            (uint32_t)(packed[27] >> 4);
         assert((uint32_t)(packed[19] >> 4 & 1) == 1);
      }
      else
      {
         unreachable();
      }
      (*unpacked).u.four_plane.a.min = (uint32_t)(packed[26] >> 6) |
         (uint32_t)(packed[27] & 15) << 2;
      (*unpacked).u.four_plane.a.max = (uint32_t)(packed[26] & 63);
      (*unpacked).u.four_plane.a.weights[0] = (uint32_t)(packed[25] >> 5);
      (*unpacked).u.four_plane.a.weights[1] = (uint32_t)(packed[25] >> 2 & 7);
      (*unpacked).u.four_plane.a.weights[2] = (uint32_t)(packed[24] >> 7) |
         (uint32_t)(packed[25] & 3) << 1;
      (*unpacked).u.four_plane.a.weights[3] = (uint32_t)(packed[24] >> 4 & 7);
      (*unpacked).u.four_plane.a.weights[4] = (uint32_t)(packed[24] >> 1 & 7);
      (*unpacked).u.four_plane.a.weights[5] = (uint32_t)(packed[31] >> 6) |
         (uint32_t)(packed[24] & 1) << 2;
      (*unpacked).u.four_plane.a.weights[6] = (uint32_t)(packed[31] >> 3 & 7);
      (*unpacked).u.four_plane.a.weights[7] = (uint32_t)(packed[31] & 7);
      (*unpacked).u.four_plane.a.weights[8] = (uint32_t)(packed[30] >> 5);
      (*unpacked).u.four_plane.a.weights[9] = (uint32_t)(packed[30] >> 2 & 7);
      (*unpacked).u.four_plane.a.weights[10] = (uint32_t)(packed[29] >> 7) |
         (uint32_t)(packed[30] & 3) << 1;
      (*unpacked).u.four_plane.a.weights[11] = (uint32_t)(packed[29] >> 4 & 7);
      (*unpacked).u.four_plane.a.weights[12] = (uint32_t)(packed[29] >> 1 & 7);
      (*unpacked).u.four_plane.a.weights[13] = (uint32_t)(packed[28] >> 6) |
         (uint32_t)(packed[29] & 1) << 2;
      (*unpacked).u.four_plane.a.weights[14] = (uint32_t)(packed[28] >> 3 & 7);
      (*unpacked).u.four_plane.a.weights[15] = (uint32_t)(packed[28] & 7);
      (*unpacked).four_plane = true;
   }
   else
   {
      unreachable();
   }
}
void v3d_unpack_hub_ident0(uint32_t packed0)
{
   assert(packed0 == 0x42554856);
}
void v3d_unpack_hub_ident1(V3D_HUB_IDENT1_T *unpacked, uint32_t packed0)
{
   (*unpacked).v3d_tech_version = packed0 & 15;
   (*unpacked).v3d_revision = packed0 >> 4 & 15;
   (*unpacked).num_cores = gfx_unpack_uint_0_is_max(packed0 >> 8 & 15, 4);
   (*unpacked).num_hosts = gfx_check_urange(packed0 >> 12 & 15, 1, 15);
   (*unpacked).has_l3c = packed0 >> 16 & 1;
   (*unpacked).has_tfu = packed0 >> 17 & 1;
   (*unpacked).has_tsy = packed0 >> 18 & 1;
   (*unpacked).has_mso = packed0 >> 19 & 1;
   (*unpacked).l3c_associativity = packed0 >> 20 & 15;
   (*unpacked).l3c_banks = packed0 >> 24 & 15;
}
void v3d_unpack_hub_ident2(V3D_HUB_IDENT2_T *unpacked, uint32_t packed0)
{
   (*unpacked).l3c_size_in_multiples_of_64kb = packed0 & 255;
   (*unpacked).has_mmu = packed0 >> 8 & 1;
}
void v3d_unpack_hub_ident3(V3D_HUB_IDENT3_T *unpacked, uint32_t packed0)
{
   (*unpacked).ip_recipient = (v3d_ip_recipient_t)(packed0 & 255);
   (*unpacked).v3d_sub_rev = packed0 >> 8 & 255;
}
void v3d_unpack_hub_ident(V3D_HUB_IDENT_T *unpacked, uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3)
{
   assert(packed0 == 0x42554856);
   (*unpacked).v3d_tech_version = packed1 & 15;
   (*unpacked).v3d_revision = packed1 >> 4 & 15;
   (*unpacked).num_cores = gfx_unpack_uint_0_is_max(packed1 >> 8 & 15, 4);
   (*unpacked).num_hosts = gfx_check_urange(packed1 >> 12 & 15, 1, 15);
   (*unpacked).has_l3c = packed1 >> 16 & 1;
   (*unpacked).has_tfu = packed1 >> 17 & 1;
   (*unpacked).has_tsy = packed1 >> 18 & 1;
   (*unpacked).has_mso = packed1 >> 19 & 1;
   (*unpacked).l3c_associativity = packed1 >> 20 & 15;
   (*unpacked).l3c_banks = packed1 >> 24 & 15;
   (*unpacked).l3c_size_in_multiples_of_64kb = packed2 & 255;
   (*unpacked).has_mmu = packed2 >> 8 & 1;
   (*unpacked).ip_recipient = (v3d_ip_recipient_t)(packed3 & 255);
   (*unpacked).v3d_sub_rev = packed3 >> 8 & 255;
}
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident0(V3D_IDENT0_T *unpacked, uint32_t packed0)
{
   assert((packed0 & 0xffffff) == 0x443356);
   (*unpacked).v3d_tech_version = packed0 >> 24;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident1(V3D_IDENT1_T *unpacked, uint32_t packed0)
{
   (*unpacked).v3d_revision = packed0 & 15;
   (*unpacked).num_slices = gfx_check_urange(packed0 >> 4 & 15, 1, 15);
   (*unpacked).num_qpus_per_slice = gfx_check_urange(packed0 >> 8 & 15, 1, 15);
   (*unpacked).num_tmus = gfx_check_urange(packed0 >> 12 & 15, 1, 15);
   (*unpacked).vpm_size_in_multiples_of_8kb = packed0 >> 28;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident2(V3D_IDENT2_T *unpacked, uint32_t packed0)
{
   (*unpacked).vri_size = (v3d_vri_size_t)(packed0 & 15);
   (*unpacked).tlb_size = (v3d_tlb_size_t)(packed0 >> 4 & 15);
   (*unpacked).tlb_double_buf_support = packed0 >> 8 & 1;
   (*unpacked).icache_size = (v3d_iuc_size_t)(packed0 >> 12 & 15);
   (*unpacked).ucache_size = (v3d_iuc_size_t)(packed0 >> 16 & 15);
   (*unpacked).bigend = packed0 >> 20 & 1;
   (*unpacked).endswp_support = packed0 >> 21 & 1;
   (*unpacked).axi_rw_reorder_support = packed0 >> 22 & 1;
   (*unpacked).no_earlyz_support = packed0 >> 23 & 1;
   (*unpacked).core_index = packed0 >> 24 & 15;
   (*unpacked).bcg_interrupt_control = packed0 >> 28 & 1;
   (*unpacked).has_astc = packed0 >> 30 & 1;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident3(V3D_IDENT3_T *unpacked, uint32_t packed0)
{
   (*unpacked).ip_recipient = (v3d_ip_recipient_t)(packed0 & 255);
   (*unpacked).v3d_sub_rev = packed0 >> 8 & 255;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident(V3D_IDENT_T *unpacked, uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3)
{
   assert((packed0 & 0xffffff) == 0x443356);
   (*unpacked).v3d_tech_version = packed0 >> 24;
   (*unpacked).v3d_revision = packed1 & 15;
   (*unpacked).num_slices = gfx_check_urange(packed1 >> 4 & 15, 1, 15);
   (*unpacked).num_qpus_per_slice = gfx_check_urange(packed1 >> 8 & 15, 1, 15);
   (*unpacked).num_tmus = gfx_check_urange(packed1 >> 12 & 15, 1, 15);
   (*unpacked).vpm_size_in_multiples_of_8kb = packed1 >> 28;
   (*unpacked).vri_size = (v3d_vri_size_t)(packed2 & 15);
   (*unpacked).tlb_size = (v3d_tlb_size_t)(packed2 >> 4 & 15);
   (*unpacked).tlb_double_buf_support = packed2 >> 8 & 1;
   (*unpacked).icache_size = (v3d_iuc_size_t)(packed2 >> 12 & 15);
   (*unpacked).ucache_size = (v3d_iuc_size_t)(packed2 >> 16 & 15);
   (*unpacked).bigend = packed2 >> 20 & 1;
   (*unpacked).endswp_support = packed2 >> 21 & 1;
   (*unpacked).axi_rw_reorder_support = packed2 >> 22 & 1;
   (*unpacked).no_earlyz_support = packed2 >> 23 & 1;
   (*unpacked).core_index = packed2 >> 24 & 15;
   (*unpacked).bcg_interrupt_control = packed2 >> 28 & 1;
   (*unpacked).has_astc = packed2 >> 30 & 1;
   (*unpacked).ip_recipient = (v3d_ip_recipient_t)(packed3 & 255);
   (*unpacked).v3d_sub_rev = packed3 >> 8 & 255;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident0(V3D_IDENT0_T *unpacked, uint32_t packed0)
{
   assert((packed0 & 0xffffff) == 0x443356);
   (*unpacked).v3d_tech_version = packed0 >> 24;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident1(V3D_IDENT1_T *unpacked, uint32_t packed0)
{
   (*unpacked).v3d_revision = packed0 & 15;
   (*unpacked).num_slices = gfx_check_urange(packed0 >> 4 & 15, 1, 15);
   (*unpacked).num_qpus_per_slice = gfx_check_urange(packed0 >> 8 & 15, 1, 15);
   (*unpacked).num_tmus = gfx_check_urange(packed0 >> 12 & 15, 1, 15);
   (*unpacked).vpm_size_in_multiples_of_8kb = packed0 >> 28;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident2(V3D_IDENT2_T *unpacked, uint32_t packed0)
{
   (*unpacked).vri_size = (v3d_vri_size_t)(packed0 & 15);
   (*unpacked).tlb_size = (v3d_tlb_size_t)(packed0 >> 4 & 15);
   (*unpacked).tlb_double_buf_support = packed0 >> 8 & 1;
   (*unpacked).icache_size = (v3d_iuc_size_t)(packed0 >> 12 & 15);
   (*unpacked).ucache_size = (v3d_iuc_size_t)(packed0 >> 16 & 15);
   (*unpacked).bigend = packed0 >> 20 & 1;
   (*unpacked).endswp_support = packed0 >> 21 & 1;
   (*unpacked).axi_rw_reorder_support = packed0 >> 22 & 1;
   (*unpacked).no_earlyz_support = packed0 >> 23 & 1;
   (*unpacked).core_index = packed0 >> 24 & 15;
   (*unpacked).bcg_interrupt_control = packed0 >> 28 & 1;
   (*unpacked).has_astc = packed0 >> 30 & 1;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident3(V3D_IDENT3_T *unpacked, uint32_t packed0)
{
   (*unpacked).l2t_ways = packed0 & 15;
   (*unpacked).l2t_way_depth = packed0 >> 4 & 15;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_unpack_ident(V3D_IDENT_T *unpacked, uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3)
{
   assert((packed0 & 0xffffff) == 0x443356);
   (*unpacked).v3d_tech_version = packed0 >> 24;
   (*unpacked).v3d_revision = packed1 & 15;
   (*unpacked).num_slices = gfx_check_urange(packed1 >> 4 & 15, 1, 15);
   (*unpacked).num_qpus_per_slice = gfx_check_urange(packed1 >> 8 & 15, 1, 15);
   (*unpacked).num_tmus = gfx_check_urange(packed1 >> 12 & 15, 1, 15);
   (*unpacked).vpm_size_in_multiples_of_8kb = packed1 >> 28;
   (*unpacked).vri_size = (v3d_vri_size_t)(packed2 & 15);
   (*unpacked).tlb_size = (v3d_tlb_size_t)(packed2 >> 4 & 15);
   (*unpacked).tlb_double_buf_support = packed2 >> 8 & 1;
   (*unpacked).icache_size = (v3d_iuc_size_t)(packed2 >> 12 & 15);
   (*unpacked).ucache_size = (v3d_iuc_size_t)(packed2 >> 16 & 15);
   (*unpacked).bigend = packed2 >> 20 & 1;
   (*unpacked).endswp_support = packed2 >> 21 & 1;
   (*unpacked).axi_rw_reorder_support = packed2 >> 22 & 1;
   (*unpacked).no_earlyz_support = packed2 >> 23 & 1;
   (*unpacked).core_index = packed2 >> 24 & 15;
   (*unpacked).bcg_interrupt_control = packed2 >> 28 & 1;
   (*unpacked).has_astc = packed2 >> 30 & 1;
   (*unpacked).l2t_ways = packed3 & 15;
   (*unpacked).l2t_way_depth = packed3 >> 4 & 15;
}
#endif
void v3d_unpack_gs_inst_fifo_thrsh(V3D_GS_INST_FIFO_THRSH_T *unpacked, uint32_t packed0)
{
   (*unpacked).cle = packed0 & 255;
   (*unpacked).gbg = packed0 >> 8 & 255;
   (*unpacked).tpg = packed0 >> 16 & 255;
}
void v3d_unpack_gs_tess_fifo_thrsh(V3D_GS_TESS_FIFO_THRSH_T *unpacked, uint32_t packed0)
{
   (*unpacked).cle = packed0 & 255;
   (*unpacked).tpg = packed0 >> 8 & 255;
}
void v3d_unpack_hub_intr(V3D_HUB_INTR_T *unpacked, uint32_t packed0)
{
   (*unpacked).tfu_fifo_free_over_threshold = packed0 & 1;
   (*unpacked).tfu_conv_complete = packed0 >> 1 & 1;
   (*unpacked).mso_obj_reached_state = packed0 >> 2 & 1;
   (*unpacked).mmu_cap = packed0 >> 3 & 1;
   (*unpacked).mmu_pti = packed0 >> 4 & 1;
   (*unpacked).mmu_wrv = packed0 >> 5 & 1;
}
void v3d_unpack_intr(V3D_INTR_T *unpacked, uint32_t packed0)
{
   (*unpacked).render_done = packed0 & 1;
   (*unpacked).bin_done = packed0 >> 1 & 1;
   (*unpacked).outomem = packed0 >> 2 & 1;
   (*unpacked).spilluse = packed0 >> 3 & 1;
   (*unpacked).trfb = packed0 >> 4 & 1;
   (*unpacked).gmpv = packed0 >> 5 & 1;
   (*unpacked).qpu[0] = packed0 >> 16 & 1;
   (*unpacked).qpu[1] = packed0 >> 17 & 1;
   (*unpacked).qpu[2] = packed0 >> 18 & 1;
   (*unpacked).qpu[3] = packed0 >> 19 & 1;
   (*unpacked).qpu[4] = packed0 >> 20 & 1;
   (*unpacked).qpu[5] = packed0 >> 21 & 1;
   (*unpacked).qpu[6] = packed0 >> 22 & 1;
   (*unpacked).qpu[7] = packed0 >> 23 & 1;
   (*unpacked).qpu[8] = packed0 >> 24 & 1;
   (*unpacked).qpu[9] = packed0 >> 25 & 1;
   (*unpacked).qpu[10] = packed0 >> 26 & 1;
   (*unpacked).qpu[11] = packed0 >> 27 & 1;
   (*unpacked).qpu[12] = packed0 >> 28 & 1;
   (*unpacked).qpu[13] = packed0 >> 29 & 1;
   (*unpacked).qpu[14] = packed0 >> 30 & 1;
   (*unpacked).qpu[15] = packed0 >> 31;
}
void v3d_unpack_ct0cs(V3D_CT0CS_T *unpacked, uint32_t packed0)
{
   (*unpacked).ctooberr = packed0 >> 2 & 1;
   (*unpacked).cterr = packed0 >> 3 & 1;
   (*unpacked).ctsubsrun = (v3d_ctsubsrun_t)(packed0 >> 4 & 3);
   (*unpacked).ctqdep = packed0 >> 6 & 1;
   (*unpacked).ctrtsd = packed0 >> 8 & 3;
   (*unpacked).ctsema = packed0 >> 12 & 7;
   (*unpacked).ctrsta = packed0 >> 15 & 1;
}
void v3d_unpack_ct1cs(V3D_CT1CS_T *unpacked, uint32_t packed0)
{
   (*unpacked).ctetstop = packed0 >> 2 & 1;
   (*unpacked).cterr = packed0 >> 3 & 1;
   (*unpacked).ctsubsrun = (v3d_ctsubsrun_t)(packed0 >> 4 & 3);
   (*unpacked).ctqdep = packed0 >> 6 & 1;
   (*unpacked).ctrtsd = packed0 >> 8 & 3;
   (*unpacked).ctsema = packed0 >> 12 & 7;
   (*unpacked).ctrsta = packed0 >> 15 & 1;
}
void v3d_unpack_ct1cfg(V3D_CT1CFG_T *unpacked, uint32_t packed0)
{
   (*unpacked).disable_multicore = packed0 & 1;
   (*unpacked).ets_flush = packed0 >> 1 & 1;
   (*unpacked).max_tiles_in_flight = packed0 >> 2 & 3;
   (*unpacked).mcs_mask_set = packed0 >> 4 & 1;
   (*unpacked).mcs_frame_id = packed0 >> 5 & 1;
}
void v3d_unpack_ct1tilect(V3D_CT1TILECT_T *unpacked, uint32_t packed0)
{
   (*unpacked).tiles_completed_in_curr_st = packed0 & 0xffff;
   (*unpacked).supertiles_completed = packed0 >> 16 & 0x1ff;
   (*unpacked).tiles_in_flight = packed0 >> 25 & 3;
}
void v3d_unpack_ct1ptct(V3D_CT1PTCT_T *unpacked, uint32_t packed0)
{
   (*unpacked).tiles_completed_in_curr_st = packed0 & 0xffff;
   (*unpacked).supertiles_completed = packed0 >> 16 & 0x1ff;
   (*unpacked).mcs_mask_set = packed0 >> 28 & 1;
   (*unpacked).mcs_frame_id = packed0 >> 29 & 1;
   (*unpacked).etstop = packed0 >> 31;
}
void v3d_unpack_pcs(V3D_PCS_T *unpacked, uint32_t packed0)
{
   (*unpacked).bmactive = packed0 & 1;
   (*unpacked).rmactive = packed0 >> 2 & 1;
   (*unpacked).bmoom = packed0 >> 8 & 1;
}
void v3d_unpack_tfucs(V3D_TFUCS_T *unpacked, uint32_t packed0)
{
   (*unpacked).busy = packed0 & 1;
   (*unpacked).nfree = packed0 >> 8 & 63;
   (*unpacked).cvtct = packed0 >> 16 & 255;
   (*unpacked).tfurst = packed0 >> 31;
}
void v3d_unpack_tfusu(V3D_TFUSU_T *unpacked, uint32_t packed0)
{
   (*unpacked).throttle = packed0 & 3;
   (*unpacked).crc = packed0 >> 3 & 1;
   (*unpacked).crcchain = packed0 >> 4 & 1;
   (*unpacked).fintthr = packed0 >> 8 & 63;
}
void v3d_unpack_tfuicfg(V3D_TFUICFG_T *unpacked, uint32_t packed0)
{
   (*unpacked).ioc = packed0 & 1;
   (*unpacked).rgbord = (v3d_tfu_rgbord_t)(packed0 >> 1 & 3);
   (*unpacked).flipy = packed0 >> 3 & 1;
   (*unpacked).srgb = packed0 >> 4 & 1;
   (*unpacked).nummm = (packed0 >> 5 & 15) + 1;
   (*unpacked).ttype = (v3d_tfu_type_t)(packed0 >> 9 & 127);
   (*unpacked).iformat = (v3d_tfu_iformat_t)(packed0 >> 18 & 15);
   (*unpacked).opad = packed0 >> 22;
}
void v3d_unpack_tfuiis(V3D_TFUIIS_T *unpacked, uint32_t packed0)
{
   (*unpacked).stride0 = packed0 & 0xffff;
   (*unpacked).stride1 = packed0 >> 16;
}
void v3d_unpack_tfuioa(V3D_TFUIOA_T *unpacked, uint32_t packed0)
{
   (*unpacked).dimtw = packed0 & 1;
   (*unpacked).oformat = (v3d_tfu_oformat_t)(packed0 >> 3 & 7);
   (*unpacked).oaddr = packed0 >> 6 << 6;
}
void v3d_unpack_tfuios(V3D_TFUIOS_T *unpacked, uint32_t packed0)
{
   (*unpacked).xsize = gfx_check_urange(packed0 & 0xffff, 0, 0x4000);
   (*unpacked).ysize = gfx_check_urange(packed0 >> 16, 0, 0x4000);
}
void v3d_unpack_tfucoef0(V3D_TFUCOEF0_T *unpacked, uint32_t packed0)
{
   (*unpacked).ay = packed0 & 0xfff;
   (*unpacked).arc = packed0 >> 16 & 0xfff;
   (*unpacked).usecoef = packed0 >> 31;
}
void v3d_unpack_tfucoef1(V3D_TFUCOEF1_T *unpacked, uint32_t packed0)
{
   (*unpacked).agc = packed0 & 0xfff;
   (*unpacked).abc = packed0 >> 16 & 0xfff;
}
void v3d_unpack_tfucoef2(V3D_TFUCOEF2_T *unpacked, uint32_t packed0)
{
   (*unpacked).agr = packed0 & 0xfff;
   (*unpacked).arr = packed0 >> 16 & 0xfff;
}
void v3d_unpack_tfucoef3(V3D_TFUCOEF3_T *unpacked, uint32_t packed0)
{
   (*unpacked).abb = packed0 & 0xfff;
   (*unpacked).agb = packed0 >> 16 & 0xfff;
}
void v3d_unpack_srqcs(V3D_SRQCS_T *unpacked, uint32_t packed0)
{
   (*unpacked).num_queued = packed0 & 63;
   (*unpacked).queue_error = packed0 >> 7 & 1;
   (*unpacked).num_requests = packed0 >> 8 & 255;
   (*unpacked).num_completed = packed0 >> 16 & 255;
}
void v3d_unpack_uifcfg(V3D_UIFCFG_T *unpacked, uint32_t packed0)
{
   (*unpacked).page_size = gfx_check_urange(packed0 & 3, 0, 2);
   (*unpacked).num_banks = packed0 >> 2 & 3;
   (*unpacked).xor_addr = packed0 >> 4 & 15;
}
#if V3D_VER_AT_LEAST(3,3,0,0)
void v3d_unpack_dram_map_version(V3D_DRAM_MAP_VERSION_T *unpacked, uint32_t packed0)
{
   (*unpacked).version = (v3d_dram_map_version_t)(packed0 & 15);
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_unpack_misccfg(V3D_MISCCFG_T *unpacked, uint32_t packed0)
{
   (*unpacked).ovrtmuout = packed0 & 1;
}
#endif
void v3d_unpack_mmu_ctrl(V3D_MMU_CTRL_T *unpacked, uint32_t packed0)
{
   (*unpacked).enable = packed0 & 1;
   (*unpacked).stats_enable = packed0 >> 1 & 1;
   (*unpacked).tlb_clear = packed0 >> 2 & 1;
   (*unpacked).stats_clear = packed0 >> 3 & 1;
   (*unpacked).tlb_clearing = packed0 >> 7 & 1;
   (*unpacked).wrv_exception = packed0 >> 9 & 1;
   (*unpacked).wrv_interrupt = packed0 >> 10 & 1;
   (*unpacked).wrv_abort = packed0 >> 11 & 1;
   (*unpacked).wrv = packed0 >> 12 & 1;
   (*unpacked).pti_enable = packed0 >> 16 & 1;
   (*unpacked).pti_exception = packed0 >> 17 & 1;
   (*unpacked).pti_interrupt = packed0 >> 18 & 1;
   (*unpacked).pti_abort = packed0 >> 19 & 1;
   (*unpacked).pti = packed0 >> 20 & 1;
   (*unpacked).capex_exception = packed0 >> 24 & 1;
   (*unpacked).capex_interrupt = packed0 >> 25 & 1;
   (*unpacked).capex_abort = packed0 >> 26 & 1;
   (*unpacked).capex = packed0 >> 27 & 1;
}
void v3d_unpack_mmu_addr_cap(V3D_MMU_ADDR_CAP_T *unpacked, uint32_t packed0)
{
   (*unpacked).mpage = packed0 & 0xfff;
   (*unpacked).enable = packed0 >> 31;
}
void v3d_unpack_mmu_bypass(V3D_MMU_BYPASS_T *unpacked, uint32_t packed0)
{
   (*unpacked).mpage = packed0 & 0xfff;
   (*unpacked).enable = packed0 >> 31;
}
void v3d_unpack_mmu_illegal(V3D_MMU_ILLEGAL_T *unpacked, uint32_t packed0)
{
   (*unpacked).page = packed0 & 0x7fffffff;
   (*unpacked).enable = packed0 >> 31;
}
void v3d_unpack_mmu_debug_info(V3D_MMU_DEBUG_INFO_T *unpacked, uint32_t packed0)
{
   (*unpacked).version = packed0 & 15;
   (*unpacked).va_width = packed0 >> 4 & 15;
   (*unpacked).pa_width = packed0 >> 8 & 15;
}
void v3d_unpack_mmuc_control(V3D_MMUC_CONTROL_T *unpacked, uint32_t packed0)
{
   (*unpacked).enable = packed0 & 1;
   (*unpacked).flush = packed0 >> 1 & 1;
   (*unpacked).flushing = packed0 >> 2 & 1;
   (*unpacked).clear_stats = packed0 >> 3 & 1;
   (*unpacked).cache_size = packed0 >> 4 & 3;
}
void v3d_unpack_gmp_cfg(V3D_GMP_CFG_T *unpacked, uint32_t packed0)
{
   (*unpacked).enable = packed0 & 1;
   (*unpacked).stop_request = packed0 >> 1 & 1;
   (*unpacked).page_cross_detect_enable = packed0 >> 2 & 1;
   (*unpacked).long_burst_detect_enable = packed0 >> 3 & 1;
}
void v3d_unpack_gmp_status(V3D_GMP_STATUS_T *unpacked, uint32_t packed0)
{
   (*unpacked).violation = packed0 & 1;
   (*unpacked).invalid_table = packed0 >> 1 & 1;
   (*unpacked).counter_overflow = packed0 >> 2 & 1;
   (*unpacked).cfg_update = packed0 >> 3 & 1;
   (*unpacked).read_active = packed0 >> 4 & 1;
   (*unpacked).write_active = packed0 >> 5 & 1;
   (*unpacked).read_count = packed0 >> 16 & 127;
   (*unpacked).write_count = packed0 >> 24 & 127;
   (*unpacked).reset = packed0 >> 31;
}
void v3d_unpack_umr_axi_control(V3D_UMR_AXI_CONTROL_T *unpacked, uint32_t packed0)
{
   (*unpacked).reg_data = packed0 & 0xffff;
   (*unpacked).reg_addr = packed0 >> 24 & 31;
   (*unpacked).write = packed0 >> 31;
}
void v3d_unpack_umr_axi_burst(V3D_UMR_AXI_BURST_T *unpacked, uint16_t packed0)
{
   (*unpacked).axi_len = (uint32_t)(packed0 & 0x3ff);
   (*unpacked).axi_size = (uint32_t)(packed0 >> 13);
}
void v3d_unpack_umr_axi_id(V3D_UMR_AXI_ID_T *unpacked, uint16_t packed0)
{
   (*unpacked).axi_id = (uint32_t)(packed0 & 0x1fff);
   (*unpacked).axi_prot = (uint32_t)(packed0 >> 13);
}
void v3d_unpack_umr_axi_status(V3D_UMR_AXI_STATUS_T *unpacked, uint16_t packed0)
{
   (*unpacked).write = (uint32_t)(packed0 & 1);
   (*unpacked).read = (uint32_t)(packed0 >> 1 & 1);
   (*unpacked).rd_fifo_almost_full = (uint32_t)(packed0 >> 4 & 1);
   (*unpacked).wr_fifo_almost_empty = (uint32_t)(packed0 >> 5 & 1);
   (*unpacked).fpga_num = (uint32_t)(packed0 >> 8 & 15);
   (*unpacked).master_error = (uint32_t)(packed0 >> 14 & 1);
   (*unpacked).axi_idle = (uint32_t)(packed0 >> 15);
}
void v3d_unpack_umr_axi_error(V3D_UMR_AXI_ERROR_T *unpacked, uint16_t packed0)
{
   (*unpacked).axi_response = (uint32_t)(packed0 & 3);
   (*unpacked).axi_timeout = (uint32_t)(packed0 >> 2 & 1);
   (*unpacked).rd_fifo_missed = (uint32_t)(packed0 >> 3 & 1);
   (*unpacked).rd_fifo_rd = (uint32_t)(packed0 >> 4 & 1);
   (*unpacked).rd_fifo_wr = (uint32_t)(packed0 >> 5 & 1);
   (*unpacked).wr_fifo_rd = (uint32_t)(packed0 >> 6 & 1);
   (*unpacked).wr_fifo_wr = (uint32_t)(packed0 >> 7 & 1);
   (*unpacked).wr_data_left = (uint32_t)(packed0 >> 8 & 1);
   (*unpacked).wr_no_data = (uint32_t)(packed0 >> 9 & 1);
   (*unpacked).rd_data_left = (uint32_t)(packed0 >> 10 & 1);
   (*unpacked).start_when_busy = (uint32_t)(packed0 >> 11 & 1);
   (*unpacked).start_error = (uint32_t)(packed0 >> 13 & 1);
   (*unpacked).fifo_error = (uint32_t)(packed0 >> 14 & 1);
   (*unpacked).axi_error = (uint32_t)(packed0 >> 15);
}
void v3d_unpack_umr_axi_flags(V3D_UMR_AXI_FLAGS_T *unpacked, uint16_t packed0)
{
   (*unpacked).read_req = (uint32_t)(packed0 & 1);
   (*unpacked).write_req = (uint32_t)(packed0 >> 1 & 1);
   (*unpacked).clear_error = (uint32_t)(packed0 >> 14 & 1);
   (*unpacked).fifo_reset = (uint32_t)(packed0 >> 15);
}
void v3d_unpack_umr_axi_fifo_flags(V3D_UMR_AXI_FIFO_FLAGS_T *unpacked, uint16_t packed0)
{
   (*unpacked).wr_full = (uint32_t)(packed0 & 1);
   (*unpacked).wr_empty = (uint32_t)(packed0 >> 1 & 1);
   (*unpacked).wr_almost_empty = (uint32_t)(packed0 >> 2 & 1);
   (*unpacked).wr_data_left = (uint32_t)(packed0 >> 3 & 1);
   (*unpacked).rd_full = (uint32_t)(packed0 >> 4 & 1);
   (*unpacked).rd_empty = (uint32_t)(packed0 >> 5 & 1);
   (*unpacked).rd_almost_full = (uint32_t)(packed0 >> 6 & 1);
   (*unpacked).rd_data_left = (uint32_t)(packed0 >> 7 & 1);
   (*unpacked).resetting = (uint32_t)(packed0 >> 15);
}
void v3d_unpack_umr_sysmon_infra_status(V3D_UMR_SYSMON_INFRA_STATUS_T *unpacked, uint32_t packed0)
{
   (*unpacked).slave_error = packed0 & 255;
   (*unpacked).mastr_done = packed0 >> 8 & 255;
   (*unpacked).num_slaves = packed0 >> 16 & 15;
   (*unpacked).design_reset = packed0 >> 21 & 1;
   (*unpacked).local_done = packed0 >> 22 & 1;
   (*unpacked).iodely_rdy = packed0 >> 23 & 1;
   (*unpacked).reset_state = packed0 >> 24 & 15;
   (*unpacked).parity_error = packed0 >> 29 & 1;
   (*unpacked).pll_locked = packed0 >> 30 & 1;
   (*unpacked).infra_error = packed0 >> 31;
}
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 4 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 5 |
      gfx_bits((*unpacked).z_write, 1) << 6 | gfx_bits((*unpacked).no_ez, 1) << 7 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 8 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 9 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 12 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 16;
   packed[1] = gfx_bits((*unpacked).cs_output_size, 8) |
      gfx_bits((*unpacked).cs_input_size, 8) << 8 |
      gfx_bits((*unpacked).vs_output_size, 8) << 16 |
      gfx_bits((*unpacked).vs_input_size, 8) << 24;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 4 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 5 |
      gfx_bits((*unpacked).z_write, 1) << 6 | gfx_bits((*unpacked).no_ez, 1) << 7 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 8 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 9 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 12 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 16;
   packed[1] = gfx_bits((*unpacked).cs_output_size, 8) |
      gfx_bits((*unpacked).cs_input_size, 8) << 8 |
      gfx_bits((*unpacked).vs_output_size, 8) << 16 |
      gfx_bits((*unpacked).vs_input_size, 8) << 24;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 4 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 5 |
      gfx_bits((*unpacked).z_write, 1) << 6 | gfx_bits((*unpacked).no_ez, 1) << 7 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 8 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 9 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 12 |
      gfx_bits((*unpacked).prim_id_used, 1) << 13 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 14 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 16;
   packed[1] = gfx_bits((*unpacked).cs_output_size, 8) |
      gfx_bits((*unpacked).cs_input_size, 8) << 8 |
      gfx_bits((*unpacked).vs_output_size, 8) << 16 |
      gfx_bits((*unpacked).vs_input_size, 8) << 24;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 4 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 5 |
      gfx_bits((*unpacked).z_write, 1) << 6 | gfx_bits((*unpacked).no_ez, 1) << 7 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 8 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 9 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 12 |
      gfx_bits((*unpacked).prim_id_used, 1) << 13 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 14 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 16;
   packed[1] = gfx_bits((*unpacked).cs_output_size, 8) |
      gfx_bits((*unpacked).cs_input_size, 8) << 8 |
      gfx_bits((*unpacked).vs_output_size, 8) << 16 |
      gfx_bits((*unpacked).vs_input_size, 8) << 24;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_output_size.pack, 2) << 6 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_output_size.pack, 2) << 22 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).sample_rate_shading, 1) << 13 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_output_size.pack, 2) << 6 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_output_size.pack, 2) << 22 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).prim_id_used, 1) << 14 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 15 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_output_size.pack, 2) << 6 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_output_size.pack, 2) << 22 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).sample_rate_shading, 1) << 13 |
      gfx_bits((*unpacked).prim_id_used, 1) << 14 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 15 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_output_size.pack, 2) << 6 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_output_size.pack, 2) << 22 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && V3D_HAS_VARY_DISABLE
void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).point_size_included, 1) |
      gfx_bits((*unpacked).clipping, 1) << 1 |
      gfx_bits((*unpacked).cs_vertex_id, 1) << 2 |
      gfx_bits((*unpacked).cs_instance_id, 1) << 3 |
      gfx_bits((*unpacked).cs_baseinstance, 1) << 4 |
      gfx_bits((*unpacked).vs_vertex_id, 1) << 5 |
      gfx_bits((*unpacked).vs_instance_id, 1) << 6 |
      gfx_bits((*unpacked).vs_baseinstance, 1) << 7 |
      gfx_bits((*unpacked).z_write, 1) << 8 | gfx_bits((*unpacked).no_ez, 1) << 9 |
      gfx_bits((*unpacked).cs_separate_blocks, 1) << 10 |
      gfx_bits((*unpacked).vs_separate_blocks, 1) << 11 |
      gfx_bits((*unpacked).sample_rate_shading, 1) << 13 |
      gfx_bits((*unpacked).prim_id_used, 1) << 14 |
      gfx_bits((*unpacked).prim_id_to_fs, 1) << 15 |
      gfx_bits((*unpacked).disable_scb, 1) << 16 |
      gfx_bits((*unpacked).scb_wait_on_first_thrsw, 1) << 17 |
      gfx_bits((*unpacked).disable_implicit_varys, 1) << 18 |
      gfx_check_urange((*unpacked).num_varys, 0, 64) << 24;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).cs_output_size.sectors, 4) |
      gfx_bits((*unpacked).cs_output_size.min_extra_req, 2) << 4 |
      gfx_bits((*unpacked).cs_output_size.pack, 2) << 6 |
      gfx_bits((*unpacked).cs_input_size.sectors, 4) << 8 |
      gfx_pack_uint_minus_1((*unpacked).cs_input_size.min_req, 2) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).vs_output_size.sectors, 4) << 16 |
      gfx_bits((*unpacked).vs_output_size.min_extra_req, 2) << 20 |
      gfx_bits((*unpacked).vs_output_size.pack, 2) << 22 |
      gfx_bits((*unpacked).vs_input_size.sectors, 4) << 24 |
      gfx_pack_uint_minus_1((*unpacked).vs_input_size.min_req, 2) << 28;
   packed[2] = (*unpacked).defaults;
   packed[3] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[4] = (*unpacked).fs.unifs_addr;
   packed[5] = gfx_bits((*unpacked).vs.threading, 2) |
      gfx_bits((*unpacked).vs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).vs.addr, 3) << 3;
   packed[6] = (*unpacked).vs.unifs_addr;
   packed[7] = gfx_bits((*unpacked).cs.threading, 2) |
      gfx_bits((*unpacked).cs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).cs.addr, 3) << 3;
   packed[8] = (*unpacked).cs.unifs_addr;
}
#endif
void v3d_pack_shadrec_gl_geom(uint32_t *packed, const V3D_SHADREC_GL_GEOM_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).gs_bin.threading, 2) |
      gfx_bits((*unpacked).gs_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).gs_bin.addr, 3) << 3;
   packed[1] = (*unpacked).gs_bin.unifs_addr;
   packed[2] = gfx_bits((*unpacked).gs_render.threading, 2) |
      gfx_bits((*unpacked).gs_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).gs_render.addr, 3) << 3;
   packed[3] = (*unpacked).gs_render.unifs_addr;
}
void v3d_pack_shadrec_gl_tess(uint32_t *packed, const V3D_SHADREC_GL_TESS_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).tcs_bin.threading, 2) |
      gfx_bits((*unpacked).tcs_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tcs_bin.addr, 3) << 3;
   packed[1] = (*unpacked).tcs_bin.unifs_addr;
   packed[2] = gfx_bits((*unpacked).tcs_render.threading, 2) |
      gfx_bits((*unpacked).tcs_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tcs_render.addr, 3) << 3;
   packed[3] = (*unpacked).tcs_render.unifs_addr;
   packed[4] = gfx_bits((*unpacked).tes_bin.threading, 2) |
      gfx_bits((*unpacked).tes_bin.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tes_bin.addr, 3) << 3;
   packed[5] = (*unpacked).tes_bin.unifs_addr;
   packed[6] = gfx_bits((*unpacked).tes_render.threading, 2) |
      gfx_bits((*unpacked).tes_render.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).tes_render.addr, 3) << 3;
   packed[7] = (*unpacked).tes_render.unifs_addr;
}
#if !V3D_HAS_SREC_TG_TWEAK
void v3d_pack_shadrec_gl_tess_or_geom(uint32_t *packed, const V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).tess_type, 2) << 1 |
      gfx_bits((*unpacked).tess_point_mode, 1) << 3 |
      gfx_bits((*unpacked).tess_edge_spacing, 2) << 4 |
      gfx_bits((*unpacked).tess_clockwise, 1) << 6 |
      gfx_bits((*unpacked).tcs_bypass, 1) << 8 |
      gfx_bits((*unpacked).tcs_bypass_render, 1) << 9 |
      gfx_bits((*unpacked).tcs_batch_flush, 2) << 10 |
      gfx_bits((*unpacked).tes_no_inp_verts, 1) << 12 |
      gfx_pack_uint_0_is_max((*unpacked).per_patch_depth_bin, 4) << 16 |
      gfx_pack_uint_0_is_max((*unpacked).per_patch_depth_render, 4) << 20 |
      gfx_check_urange((*unpacked).num_tcs_invocations, 1, 32) << 24;
   packed[1] = gfx_check_urange((*unpacked).tcs_output_bin.size_sectors, 0, 16) |
      gfx_bits((*unpacked).tcs_output_bin.pack, 2) << 6 | gfx_check_urange(
      (*unpacked).tcs_output_render.size_sectors, 0, 16) << 8 |
      gfx_bits((*unpacked).tcs_output_render.pack, 2) << 14 | gfx_check_urange(
      (*unpacked).tes_output_bin.size_sectors, 0, 16) << 16 |
      gfx_bits((*unpacked).tes_output_bin.pack, 2) << 22 | gfx_check_urange(
      (*unpacked).tes_output_render.size_sectors, 0, 16) << 24 |
      gfx_bits((*unpacked).tes_output_render.pack, 2) << 30;
   packed[2] = gfx_bits((*unpacked).geom_output, 2) << 1 |
      gfx_check_urange((*unpacked).geom_num_instances, 1, 32) << 8 | gfx_check_urange(
      (*unpacked).geom_output_bin.size_sectors, 0, 16) << 16 |
      gfx_bits((*unpacked).geom_output_bin.pack, 2) << 22 | gfx_check_urange(
      (*unpacked).geom_output_render.size_sectors, 0, 16) << 24 |
      gfx_bits((*unpacked).geom_output_render.pack, 2) << 30;
   packed[3] = gfx_pack_uint_minus_1((*unpacked).max_patches_per_tcs_batch, 3) |
      gfx_pack_uint_minus_1((*unpacked).min_tcs_segs_bin, 3) << 3 |
      gfx_pack_uint_minus_1((*unpacked).min_tcs_segs_render, 3) << 6 |
      gfx_pack_uint_minus_1((*unpacked).min_per_patch_segs_bin, 2) << 9 |
      gfx_pack_uint_minus_1((*unpacked).min_per_patch_segs_render, 2) << 11 |
      gfx_pack_uint_minus_1((*unpacked).max_patches_per_tes_batch, 3) << 14 |
      gfx_pack_uint_minus_1((*unpacked).min_tes_segs_bin, 3) << 17 |
      gfx_pack_uint_minus_1((*unpacked).min_tes_segs_render, 3) << 20 |
      gfx_pack_uint_minus_1((*unpacked).max_patches_per_gs_batch, 3) << 23 |
      gfx_pack_uint_minus_1((*unpacked).min_gs_segs_bin, 3) << 26 |
      gfx_pack_uint_minus_1((*unpacked).min_gs_segs_render, 3) << 29;
}
#endif
#if V3D_HAS_SREC_TG_TWEAK
void v3d_pack_shadrec_gl_tess_or_geom(uint32_t *packed, const V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).tess_type, 2) << 1 |
      gfx_bits((*unpacked).tess_point_mode, 1) << 3 |
      gfx_bits((*unpacked).tess_edge_spacing, 2) << 4 |
      gfx_bits((*unpacked).tess_clockwise, 1) << 6 |
      gfx_bits((*unpacked).tcs_bypass, 1) << 7 |
      gfx_bits((*unpacked).tcs_bypass_render, 1) << 8 |
      gfx_bits((*unpacked).tcs_batch_flush, 2) << 9 |
      gfx_bits((*unpacked).tes_no_inp_verts, 1) << 11 |
      gfx_pack_uint_0_is_max((*unpacked).num_tcs_invocations, 5) << 12 |
      gfx_bits((*unpacked).geom_output, 2) << 17 |
      gfx_pack_uint_0_is_max((*unpacked).geom_num_instances, 5) << 19 |
      gfx_pack_uint_0_is_max((*unpacked).per_patch_depth_bin, 4) << 24 |
      gfx_pack_uint_0_is_max((*unpacked).per_patch_depth_render, 4) << 28;
   packed[1] = gfx_check_urange((*unpacked).tcs_output_bin.size_sectors, 0, 16) |
      gfx_bits((*unpacked).tcs_output_bin.pack, 2) << 6 | gfx_check_urange(
      (*unpacked).tcs_output_render.size_sectors, 0, 16) << 8 |
      gfx_bits((*unpacked).tcs_output_render.pack, 2) << 14 | gfx_check_urange(
      (*unpacked).tes_output_bin.size_sectors, 0, 16) << 16 |
      gfx_bits((*unpacked).tes_output_bin.pack, 2) << 22 | gfx_check_urange(
      (*unpacked).tes_output_render.size_sectors, 0, 16) << 24 |
      gfx_bits((*unpacked).tes_output_render.pack, 2) << 30;
   packed[2] = gfx_check_urange((*unpacked).geom_output_bin.size_sectors, 0, 16) |
      gfx_bits((*unpacked).geom_output_bin.pack, 2) << 6 | gfx_check_urange(
      (*unpacked).geom_output_render.size_sectors, 0, 16) << 8 |
      gfx_bits((*unpacked).geom_output_render.pack, 2) << 14 | gfx_pack_uint_minus_1(
      (*unpacked).max_patches_per_tcs_batch, 4) << 16 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_tcs_batch_bin, 2) << 20 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_tcs_batch_render, 2) << 22 |
      gfx_pack_uint_minus_1((*unpacked).min_tcs_segs_bin, 3) << 24 |
      gfx_pack_uint_minus_1((*unpacked).min_tcs_segs_render, 3) << 27 |
      gfx_pack_uint_minus_1((*unpacked).min_per_patch_segs_bin, 2) << 30;
   packed[3] = gfx_pack_uint_minus_1((*unpacked).min_per_patch_segs_render, 2) |
      gfx_pack_uint_minus_1((*unpacked).max_patches_per_tes_batch, 4) << 2 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_tes_batch_bin, 2) << 6 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_tes_batch_render, 2) << 8 |
      gfx_pack_uint_minus_1((*unpacked).max_tcs_segs_per_tes_batch_bin, 3) << 10 |
      gfx_pack_uint_minus_1((*unpacked).max_tcs_segs_per_tes_batch_render, 3) << 13 |
      gfx_pack_uint_minus_1((*unpacked).min_tes_segs_bin, 3) << 16 |
      gfx_pack_uint_minus_1((*unpacked).min_tes_segs_render, 3) << 19 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_gs_batch_bin, 2) << 22 | gfx_bits(
      (*unpacked).max_extra_vert_segs_per_gs_batch_render, 2) << 24 |
      gfx_pack_uint_minus_1((*unpacked).min_gs_segs_bin, 3) << 26 |
      gfx_pack_uint_minus_1((*unpacked).min_gs_segs_render, 3) << 29;
}
#endif
void v3d_pack_shadrec_gl_attr(uint32_t *packed, const V3D_SHADREC_GL_ATTR_T *unpacked)
{
   packed[0] = (*unpacked).addr;
   packed[1] = gfx_pack_uint_0_is_max((*unpacked).size, 2) |
      gfx_bits((*unpacked).type, 3) << 2 | gfx_bits((*unpacked).signed_int, 1) << 5 |
      gfx_bits((*unpacked).normalised_int, 1) << 6 |
      gfx_bits((*unpacked).read_as_int, 1) << 7 |
      gfx_check_urange((*unpacked).cs_num_reads, 0, 4) << 8 |
      gfx_check_urange((*unpacked).vs_num_reads, 0, 4) << 12 |
      gfx_bits((*unpacked).divisor, 16) << 16;
   packed[2] = (*unpacked).stride;
}
void v3d_pack_shadrec_vg(uint32_t *packed, const V3D_SHADREC_VG_T *unpacked)
{
   packed[0] = 0;
   packed[1] = gfx_bits((*unpacked).fs.threading, 2) |
      gfx_bits((*unpacked).fs.propagate_nans, 1) << 2 |
      gfx_exact_lsr((*unpacked).fs.addr, 3) << 3;
   packed[2] = (*unpacked).fs.unifs_addr;
}
uint32_t v3d_pack_unif_raw(const V3D_UNIF_RAW_T *unpacked)
{
   return (*unpacked).unif;
}
uint32_t v3d_pack_unif_addr(const V3D_UNIF_ADDR_T *unpacked)
{
   return (*unpacked).addr;
}
#if !V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param0_cfg0(const V3D_TMU_PARAM0_CFG0_T *unpacked)
{
   return gfx_bits((*unpacked).type, 7) | gfx_bits((*unpacked).srgb, 1) << 7 |
      gfx_bits((*unpacked).pix_mask, 1) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).width, 11) << 10 |
      gfx_pack_uint_0_is_max((*unpacked).height, 11) << 21;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param0_cfg1(const V3D_TMU_PARAM0_CFG1_T *unpacked)
{
   return gfx_bits((*unpacked).ltype, 3) | gfx_bits((*unpacked).fetch, 1) << 3 |
      gfx_bits((*unpacked).gather, 1) << 4 | gfx_bits((*unpacked).bias, 1) << 5 |
      gfx_bits((*unpacked).bslod, 1) << 6 |
      gfx_bits((*unpacked).coefficient, 1) << 7 |
      gfx_bits((*unpacked).shadow, 1) << 8 | 1 << 9 |
      gfx_bits((*unpacked).wrap_s, 3) << 10 | gfx_bits((*unpacked).wrap_t, 3) << 13 |
      gfx_bits((*unpacked).wrap_r, 3) << 16 |
      gfx_pack_sint((*unpacked).tex_off_s, 4) << 19 |
      gfx_pack_sint((*unpacked).tex_off_t, 4) << 23 |
      gfx_pack_sint((*unpacked).tex_off_r, 4) << 27 |
      gfx_bits((*unpacked).pix_mask, 1) << 31;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param1_cfg0(const V3D_TMU_PARAM1_CFG0_T *unpacked)
{
   return gfx_bits((*unpacked).wrap_s, 2) | gfx_bits((*unpacked).wrap_t, 2) << 2 |
      gfx_bits((*unpacked).filter, 4) << 4 | gfx_bits((*unpacked).bslod, 1) << 8 |
      gfx_exact_lsr((*unpacked).base, 9) << 9;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param1_cfg1(const V3D_TMU_PARAM1_CFG1_T *unpacked)
{
   return gfx_bits((*unpacked).word0_en, 1) |
      gfx_bits((*unpacked).word1_en, 1) << 1 |
      gfx_bits((*unpacked).word2_en, 1) << 2 |
      gfx_bits((*unpacked).word3_en, 1) << 3 | gfx_bits((*unpacked).unnorm, 1) << 4 |
      gfx_exact_lsr((*unpacked).ts_base, 5) << 5;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param0(const V3D_TMU_PARAM0_T *unpacked)
{
   return gfx_bits((*unpacked).word_en[0], 1) |
      gfx_bits((*unpacked).word_en[1], 1) << 1 |
      gfx_bits((*unpacked).word_en[2], 1) << 2 |
      gfx_bits((*unpacked).word_en[3], 1) << 3 |
      gfx_exact_lsr((*unpacked).tex_state_addr, 4) << 4;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_tmu_param1(const V3D_TMU_PARAM1_T *unpacked)
{
   return gfx_bits((*unpacked).output_32, 1) |
      gfx_bits((*unpacked).unnorm, 1) << 1 | gfx_bits((*unpacked).pix_mask, 1) << 2 |
      gfx_exact_lsr((*unpacked).sampler_addr, 3) << 3;
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_TEX_WRITE
uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked)
{
   return gfx_bits((*unpacked).tmuoff_4x, 1) |
      gfx_bits((*unpacked).bslod, 1) << 1 |
      gfx_bits((*unpacked).coeff_sample, 2) << 2 |
      gfx_bits((*unpacked).coefficient, 1) << 4 |
      gfx_bits((*unpacked).gather_comp, 2) << 5 |
      gfx_bits((*unpacked).gather, 1) << 7 |
      gfx_pack_sint((*unpacked).offsets[0], 4) << 8 |
      gfx_pack_sint((*unpacked).offsets[1], 4) << 12 |
      gfx_pack_sint((*unpacked).offsets[2], 4) << 16;
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_TEX_WRITE
uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked)
{
   return gfx_bits((*unpacked).tmuoff_4x, 1) |
      gfx_bits((*unpacked).bslod, 1) << 1 |
      gfx_bits((*unpacked).coeff_sample, 2) << 2 |
      gfx_bits((*unpacked).coefficient, 1) << 4 |
      gfx_bits((*unpacked).gather_comp, 2) << 5 |
      gfx_bits((*unpacked).gather, 1) << 7 |
      gfx_pack_sint((*unpacked).offsets[0], 4) << 8 |
      gfx_pack_sint((*unpacked).offsets[1], 4) << 12 |
      gfx_pack_sint((*unpacked).offsets[2], 4) << 16 |
      gfx_bits((*unpacked).op, 4) << 20;
}
#endif
uint8_t v3d_pack_tmu_general_config(const V3D_TMU_GENERAL_CONFIG_T *unpacked)
{
   return (uint8_t)gfx_bits((*unpacked).type, 3) |
      (uint8_t)(gfx_bits((*unpacked).op, 4) << 3) |
      (uint8_t)(gfx_bits((*unpacked).per_pixel_enable, 1) << 7);
}
uint8_t v3d_pack_tsy_config(const V3D_TSY_CONFIG_T *unpacked)
{
   return (uint8_t)gfx_bits((*unpacked).op, 5) |
      (uint8_t)(gfx_bits((*unpacked).gfxh_1370_do_not_change, 3) << 5);
}
uint8_t v3d_pack_tlb_config_color_f16(const V3D_TLB_CONFIG_COLOR_F16_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 1) |
      (uint8_t)(gfx_bits((*unpacked).no_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) | (uint8_t)(3 << 6);
}
uint8_t v3d_pack_tlb_config_color_32(const V3D_TLB_CONFIG_COLOR_32_T *unpacked)
{
   return (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_words, 2) |
      (uint8_t)(gfx_bits((*unpacked).all_samples_same_data, 1) << 2) |
      (uint8_t)((gfx_mask(3) - gfx_bits((*unpacked).rt, 3)) << 3) |
      (uint8_t)(gfx_bits((*unpacked).as_int, 1) << 6) | (uint8_t)0;
}
uint8_t v3d_pack_tlb_config_z(const V3D_TLB_CONFIG_Z_T *unpacked)
{
   return (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).use_written_z, 1) << 2) |
      (uint8_t)0 | (uint8_t)(8 << 4);
}
uint8_t v3d_pack_tlb_config_alpha_mask(void)
{
   return (uint8_t)0 | (uint8_t)(9 << 4);
}
uint32_t v3d_pack_unif_branch(const V3D_UNIF_BRANCH_T *unpacked)
{
   return gfx_bits((*unpacked).bcond, 3) | gfx_bits((*unpacked).msfign, 2) << 7 |
      gfx_bits((*unpacked).ulr, 1) << 9 |
      gfx_pack_sint(gfx_exact_asr((*unpacked).rel_i_addr, 3), 11) << 10 |
      gfx_pack_sint(gfx_exact_asr((*unpacked).rel_u_addr, 2), 11) << 21;
}
#if !V3D_HAS_NEW_TMU_CFG
void v3d_pack_tmu_indirect_not_child_image(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).filter, 4) |
      gfx_bits((*unpacked).border_rrra, 1) << 5 |
      gfx_exact_lsr((*unpacked).base, 6) << 6;
   packed[1] = gfx_exact_lsr((*unpacked).arr_str, 6) |
      gfx_pack_uint_0_is_max((*unpacked).width, 14) << 26;
   packed[2] = gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6 |
      gfx_pack_uint_0_is_max((*unpacked).height, 14) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 22;
   packed[3] = gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10 |
      gfx_bits((*unpacked).ttype, 7) << 4 | gfx_bits((*unpacked).srgb, 1) << 11 |
      gfx_bits((*unpacked).ahdr, 1) << 12 |
      gfx_bits((*unpacked).compare_func, 3) << 13 |
      gfx_bits((*unpacked).swizzles[0], 3) << 16 |
      gfx_bits((*unpacked).swizzles[1], 3) << 19 |
      gfx_bits((*unpacked).swizzles[2], 3) << 22 |
      gfx_bits((*unpacked).swizzles[3], 3) << 25 |
      gfx_bits((*unpacked).flipx, 1) << 28 | gfx_bits((*unpacked).flipy, 1) << 29 |
      gfx_bits((*unpacked).etcflip, 1) << 30;
   packed[4] = (uint32_t)(*unpacked).bcolour;
   packed[5] = (uint32_t)((*unpacked).bcolour >> 32);
   packed[6] = gfx_pack_sint((*unpacked).u.not_child_image.min_lod, 16) |
      gfx_pack_sint((*unpacked).u.not_child_image.max_lod, 16) << 16;
   packed[7] = gfx_pack_sint((*unpacked).u.not_child_image.fixed_bias, 16) |
      gfx_bits((*unpacked).u.not_child_image.base_level, 4) << 16 |
      gfx_bits((*unpacked).u.not_child_image.samp_num, 2) << 20 |
      gfx_bits((*unpacked).u.not_child_image.output_type, 2) << 22 |
      gfx_bits((*unpacked).ub_pad, 4) << 24 | gfx_bits((*unpacked).ub_xor, 1) << 28 |
      gfx_bits((*unpacked).uif_top, 1) << 30 | gfx_bits((*unpacked).xor_dis, 1) << 31;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_pack_tmu_indirect_child_image(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).filter, 4) |
      gfx_bits((*unpacked).border_rrra, 1) << 5 |
      gfx_exact_lsr((*unpacked).base, 6) << 6;
   packed[1] = gfx_exact_lsr((*unpacked).arr_str, 6) |
      gfx_pack_uint_0_is_max((*unpacked).width, 14) << 26;
   packed[2] = gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6 |
      gfx_pack_uint_0_is_max((*unpacked).height, 14) << 8 |
      gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 22;
   packed[3] = gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10 |
      gfx_bits((*unpacked).ttype, 7) << 4 | gfx_bits((*unpacked).srgb, 1) << 11 |
      gfx_bits((*unpacked).ahdr, 1) << 12 |
      gfx_bits((*unpacked).compare_func, 3) << 13 |
      gfx_bits((*unpacked).swizzles[0], 3) << 16 |
      gfx_bits((*unpacked).swizzles[1], 3) << 19 |
      gfx_bits((*unpacked).swizzles[2], 3) << 22 |
      gfx_bits((*unpacked).swizzles[3], 3) << 25 |
      gfx_bits((*unpacked).flipx, 1) << 28 | gfx_bits((*unpacked).flipy, 1) << 29 |
      gfx_bits((*unpacked).etcflip, 1) << 30;
   packed[4] = (uint32_t)(*unpacked).bcolour;
   packed[5] = (uint32_t)((*unpacked).bcolour >> 32);
   packed[6] = gfx_bits((*unpacked).u.child_image.cwidth, 14) |
      gfx_bits((*unpacked).u.child_image.cheight, 14) << 14 |
      gfx_bits((*unpacked).u.child_image.cxoff, 14) << 28;
   packed[7] = gfx_bits((*unpacked).u.child_image.cxoff, 14) >> 4 |
      gfx_bits((*unpacked).u.child_image.cyoff, 14) << 10 |
      gfx_bits((*unpacked).ub_pad, 4) << 24 | gfx_bits((*unpacked).ub_xor, 1) << 28 |
      gfx_bits((*unpacked).uif_top, 1) << 30 | gfx_bits((*unpacked).xor_dis, 1) << 31;
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_pack_tmu_tex_state(uint8_t *packed, const V3D_TMU_TEX_STATE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).flipx, 1) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).srgb, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).ahdr, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).reverse_std_bcol, 1) << 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) << 6);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 2);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 10);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).l0_addr, 6) >> 18);
   packed[4] = (uint8_t)gfx_exact_lsr((*unpacked).arr_str, 6);
   packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 8);
   packed[6] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 16);
   packed[7] = (uint8_t)(gfx_exact_lsr((*unpacked).arr_str, 6) >> 24) |
      (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).width, 14) << 2);
   packed[8] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).width, 14) >> 6);
   packed[9] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).height, 14);
   packed[10] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).height, 14) >> 8) |
      (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) << 6);
   packed[11] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 2);
   packed[12] = (uint8_t)(gfx_pack_uint_0_is_max((*unpacked).depth, 14) >> 10) |
      (uint8_t)(gfx_bits((*unpacked).type, 7) << 4);
   packed[13] = (uint8_t)(gfx_bits((*unpacked).type, 7) >> 4) |
      (uint8_t)(gfx_bits((*unpacked).extended, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[0], 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[1], 3) << 7);
   packed[14] = (uint8_t)(gfx_bits((*unpacked).swizzles[1], 3) >> 1) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[2], 3) << 2) |
      (uint8_t)(gfx_bits((*unpacked).swizzles[3], 3) << 5);
   packed[15] = (uint8_t)gfx_bits((*unpacked).max_level, 4) |
      (uint8_t)(gfx_bits((*unpacked).base_level, 4) << 4);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_pack_tmu_tex_extension(uint8_t *packed, const V3D_TMU_TEX_EXTENSION_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).ub_pad, 4) |
      (uint8_t)(gfx_bits((*unpacked).ub_xor, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).uif_top, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).xor_dis, 1) << 7);
   packed[1] = (uint8_t)0;
   packed[2] = (uint8_t)0;
   packed[3] = (uint8_t)0;
   packed[4] = (uint8_t)0;
   packed[5] = (uint8_t)0;
   packed[6] = (uint8_t)0;
   packed[7] = (uint8_t)0;
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_WRAP_I
void v3d_pack_tmu_sampler(uint8_t *packed, const V3D_TMU_SAMPLER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).filter, 4) |
      (uint8_t)(gfx_bits((*unpacked).compare_func, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).srgb_override, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).min_lod, 12);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).min_lod, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).max_lod, 12) << 4);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).max_lod, 12) >> 4);
   packed[4] = (uint8_t)gfx_pack_sint((*unpacked).fixed_bias, 16);
   packed[5] = (uint8_t)(gfx_pack_sint((*unpacked).fixed_bias, 16) >> 8);
   packed[6] = (uint8_t)gfx_bits((*unpacked).wrap_s, 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_t, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) << 6);
   packed[7] = (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).std_bcol, 3) << 1) | (uint8_t)0;
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_WRAP_I
void v3d_pack_tmu_sampler(uint8_t *packed, const V3D_TMU_SAMPLER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).filter, 4) |
      (uint8_t)(gfx_bits((*unpacked).compare_func, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).srgb_override, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).min_lod, 12);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).min_lod, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).max_lod, 12) << 4);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).max_lod, 12) >> 4);
   packed[4] = (uint8_t)gfx_pack_sint((*unpacked).fixed_bias, 16);
   packed[5] = (uint8_t)(gfx_pack_sint((*unpacked).fixed_bias, 16) >> 8);
   packed[6] = (uint8_t)gfx_bits((*unpacked).wrap_s, 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_t, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) << 6);
   packed[7] = (uint8_t)(gfx_bits((*unpacked).wrap_r, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).wrap_i, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).std_bcol, 3) << 2) | (uint8_t)0;
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_pack_tf_spec(uint8_t *packed, const V3D_TF_SPEC_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).first, 8);
   packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).count, 4) |
      (uint8_t)(gfx_bits((*unpacked).buffer, 2) << 4) | (uint8_t)0;
}
#endif
#if V3D_HAS_NEW_TF
void v3d_pack_tf_spec(uint8_t *packed, const V3D_TF_SPEC_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).first, 8);
   packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).count, 4) |
      (uint8_t)(gfx_bits((*unpacked).buffer, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).stream, 2) << 6);
}
#endif
#if !V3D_HAS_NEW_TILE_STATE
void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).prev_indices[0];
   packed[2] = (*unpacked).prev_indices[1];
   packed[3] = (*unpacked).prev_indices[2];
   packed[4] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 1 |
      gfx_bits((*unpacked).ctr, 15) << 2 | gfx_bits((*unpacked).blksize, 2) << 17 |
      gfx_bits((*unpacked).halfwrt, 1) << 19;
   packed[5] = 0;
   packed[6] = 0;
   packed[7] = 0;
   packed[8] = 0;
   packed[9] = 0;
   packed[10] = 0;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
}
#endif
#if V3D_HAS_NEW_TILE_STATE && !V3D_HAS_INLINE_CLIP
void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).prev_indices[0];
   packed[2] = (*unpacked).prev_indices[1];
   packed[3] = (*unpacked).prev_indices[2];
   packed[4] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 1 |
      gfx_bits((*unpacked).ctr, 24) << 2 | gfx_bits((*unpacked).blksize, 2) << 26 |
      gfx_bits((*unpacked).halfwrt, 1) << 28;
   packed[5] = 0;
   packed[6] = 0;
   packed[7] = 0;
   packed[8] = 0;
   packed[9] = 0;
   packed[10] = 0;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
#if V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG
void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).prev_indices[0];
   packed[2] = (*unpacked).prev_indices[1];
   packed[3] = (*unpacked).prev_indices[2];
   packed[4] = (*unpacked).prev_prim_id;
   packed[5] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 1 |
      gfx_bits((*unpacked).ctr, 24) << 2 | gfx_bits((*unpacked).blksize, 2) << 26 |
      gfx_bits((*unpacked).halfwrt, 1) << 28;
   packed[6] = 0;
   packed[7] = 0;
   packed[8] = 0;
   packed[9] = 0;
   packed[10] = 0;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
#if V3D_HAS_TNG && !V3D_HAS_TL_START_UNC
void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).sn_pos;
   packed[2] = (*unpacked).prev_indices[0];
   packed[3] = (*unpacked).prev_indices[1];
   packed[4] = (*unpacked).prev_indices[2];
   packed[5] = (*unpacked).prev_serials[0];
   packed[6] = (*unpacked).prev_serials[1];
   packed[7] = (*unpacked).prev_serials[2];
   packed[8] = (*unpacked).prev_prim_id;
   packed[9] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).in_generic_ind_list, 1) << 1 |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 2 |
      gfx_bits((*unpacked).ctr, 24) << 3 | gfx_bits((*unpacked).blksize, 2) << 27 |
      gfx_bits((*unpacked).halfwrt, 1) << 29 |
      gfx_bits((*unpacked).deferred_sn, 24) << 30;
   packed[10] = gfx_bits((*unpacked).deferred_sn, 24) >> 2 |
      gfx_bits((*unpacked).cur_sn_level, 2) << 22 |
      gfx_bits((*unpacked).tg_tess, 1) << 24 |
      gfx_bits((*unpacked).tg_geom, 1) << 25 |
      gfx_bits((*unpacked).tg_geom_inst, 1) << 26;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
#if V3D_HAS_TL_START_UNC
void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked)
{
   packed[0] = (*unpacked).cl_pos;
   packed[1] = (*unpacked).sn_pos;
   packed[2] = (*unpacked).prev_indices[0];
   packed[3] = (*unpacked).prev_indices[1];
   packed[4] = (*unpacked).prev_indices[2];
   packed[5] = (*unpacked).prev_serials[0];
   packed[6] = (*unpacked).prev_serials[1];
   packed[7] = (*unpacked).prev_serials[2];
   packed[8] = (*unpacked).prev_prim_id;
   packed[9] = gfx_bits((*unpacked).curr_xy_mode, 1) |
      gfx_bits((*unpacked).in_generic_ind_list, 1) << 1 |
      gfx_bits((*unpacked).in_prim_list, 1) << 2 |
      gfx_bits((*unpacked).prev_reverse_flag, 1) << 3 |
      gfx_bits((*unpacked).ctr, 24) << 4 | gfx_bits((*unpacked).blksize, 2) << 28 |
      gfx_bits((*unpacked).halfwrt, 1) << 30 |
      gfx_bits((*unpacked).deferred_sn, 24) << 31;
   packed[10] = gfx_bits((*unpacked).deferred_sn, 24) >> 1 |
      gfx_bits((*unpacked).cur_sn_level, 2) << 23 |
      gfx_bits((*unpacked).tg_tess, 1) << 25 |
      gfx_bits((*unpacked).tg_geom, 1) << 26 |
      gfx_bits((*unpacked).tg_geom_inst, 1) << 27;
   packed[11] = 0;
   packed[12] = 0;
   packed[13] = 0;
   packed[14] = 0;
   packed[15] = 0;
   packed[16] = 0;
   packed[17] = 0;
   packed[18] = 0;
   packed[19] = 0;
   packed[20] = 0;
   packed[21] = 0;
   packed[22] = 0;
   packed[23] = 0;
   packed[24] = 0;
   packed[25] = 0;
   packed[26] = 0;
   packed[27] = 0;
   packed[28] = 0;
   packed[29] = 0;
   packed[30] = 0;
   packed[31] = 0;
   packed[32] = 0;
   packed[33] = 0;
   packed[34] = 0;
   packed[35] = 0;
   packed[36] = 0;
   packed[37] = 0;
   packed[38] = 0;
   packed[39] = 0;
   packed[40] = 0;
   packed[41] = 0;
   packed[42] = 0;
   packed[43] = 0;
   packed[44] = 0;
   packed[45] = 0;
   packed[46] = 0;
   packed[47] = 0;
   packed[48] = 0;
   packed[49] = 0;
   packed[50] = 0;
   packed[51] = 0;
   packed[52] = 0;
   packed[53] = 0;
   packed[54] = 0;
   packed[55] = 0;
   packed[56] = 0;
   packed[57] = 0;
   packed[58] = 0;
   packed[59] = 0;
   packed[60] = 0;
   packed[61] = 0;
   packed[62] = 0;
   packed[63] = 0;
}
#endif
void v3d_pack_indirect_indexed_record(uint32_t *packed, const V3D_INDIRECT_INDEXED_RECORD_T *unpacked)
{
   packed[0] = (*unpacked).num_indices;
   packed[1] = (*unpacked).num_instances;
   packed[2] = (*unpacked).index_of_first_index;
   packed[3] = (uint32_t)(*unpacked).base_vertex;
   packed[4] = (*unpacked).base_instance;
}
void v3d_pack_indirect_arrays_record(uint32_t *packed, const V3D_INDIRECT_ARRAYS_RECORD_T *unpacked)
{
   packed[0] = (*unpacked).num_vertices;
   packed[1] = (*unpacked).num_instances;
   packed[2] = (*unpacked).first_index;
   packed[3] = (*unpacked).base_instance;
}
void v3d_pack_clip_record(uint32_t *packed, const V3D_CLIP_RECORD_T *unpacked)
{
   packed[0] = (uint32_t)(*unpacked).xs;
   packed[1] = (uint32_t)(*unpacked).ys;
   packed[2] = gfx_float_to_bits((*unpacked).zs);
   packed[3] = gfx_float_to_bits((*unpacked).rw);
   packed[4] = gfx_float_to_bits((*unpacked).vcoeff[0]);
   packed[5] = gfx_float_to_bits((*unpacked).vcoeff[1]);
   packed[6] = gfx_float_to_bits((*unpacked).vcoeff[2]);
   packed[7] = 0;
}
void v3d_pack_autochain_link(uint8_t *packed, const V3D_AUTOCHAIN_LINK_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).next_block_size, 2) |
      (uint8_t)(gfx_bits((*unpacked).more, 1) << 2) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) << 6);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 2);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 10);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).next_block_addr, 6) >> 18);
}
#if !V3D_HAS_INLINE_CLIP
void v3d_pack_cl_compr_ind_common(uint8_t *packed, const V3D_CL_COMPR_IND_COMMON_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)3;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)35;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH);
      packed[0] = (uint8_t)19;
      packed[1] = (uint8_t)gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16);
      packed[2] = (uint8_t)(gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_BRANCH);
      packed[0] = (uint8_t)195;
      packed[1] = (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.branch.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)227;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_INLINE_CLIP
void v3d_pack_cl_compr_ind_common(uint8_t *packed, const V3D_CL_COMPR_IND_COMMON_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)3;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)35;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8);
      packed[0] = (uint8_t)19;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.prim_id8.rel_id, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32);
      packed[0] = (uint8_t)195;
      packed[1] = (uint8_t)(*unpacked).u.prim_id32.id;
      packed[2] = (uint8_t)((*unpacked).u.prim_id32.id >> 8);
      packed[3] = (uint8_t)((*unpacked).u.prim_id32.id >> 16);
      packed[4] = (uint8_t)((*unpacked).u.prim_id32.id >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_CLIPPED_PRIM)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_CLIPPED_PRIM);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first, 1) << 4) |
         (uint8_t)(3 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.clipped_prim.clip_vert[0], 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[1], 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[2], 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.flat_zw, 1) << 3) | (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)227;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_NOT_COMMON);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG
void v3d_pack_cl_compr_serial(uint8_t *packed, const V3D_CL_COMPR_SERIAL_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C0);
      packed[0] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.c0.is_last, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.c0.rel_value, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_bits((*unpacked).u.c1.is_last, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.rel_value, 13) << 3);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c1.rel_value, 13) >> 5);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C2);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c2.count, 5) << 3);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_C3);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_bits((*unpacked).u.c3.is_last, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) << 5);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) >> 3);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 19) >> 11);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.is_first, 1) << 4) | (uint8_t)0;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.clipped_prim.clip_vert[0], 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[1], 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.clip_vert[2], 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.clipped_prim.flat_zw, 1) << 3) | (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) << 5);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 3);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 11);
      packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).u.clipped_prim.addr, 5) >> 19);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_TG_MODE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_TG_MODE);
      packed[0] = (uint8_t)47;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.tg_mode.tess, 1) |
         (uint8_t)(gfx_bits((*unpacked).u.tg_mode.geom, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.tg_mode.geom_iid, 1) << 2) | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL)
   {
      assert((*unpacked).type == V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL);
      packed[0] = (uint8_t)15 | (uint8_t)(3 << 4);
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG && V3D_HAS_INLINE_CLIP
void v3d_pack_cl_compr_ind_generic(uint8_t *packed, const V3D_CL_COMPR_IND_GENERIC_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 14) << 2);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 14) >> 6);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c2.value, 5) << 3);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)7 | (uint8_t)(gfx_bits((*unpacked).u.c3.value, 12) << 4);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c3.value, 12) >> 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) << 5);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) >> 3);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.value, 19) >> 11);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)31;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.value, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.value, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.value, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)63;
      packed[1] = (uint8_t)(*unpacked).u.c6.value;
      packed[2] = (uint8_t)((*unpacked).u.c6.value >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.value >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.value >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID8);
      packed[0] = (uint8_t)95;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.iid8.iid, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_IID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_IID32);
      packed[0] = (uint8_t)127;
      packed[1] = (uint8_t)(*unpacked).u.iid32.iid;
      packed[2] = (uint8_t)((*unpacked).u.iid32.iid >> 8);
      packed[3] = (uint8_t)((*unpacked).u.iid32.iid >> 16);
      packed[4] = (uint8_t)((*unpacked).u.iid32.iid >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID8);
      packed[0] = (uint8_t)159;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.prim_id8.diff, 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_PRIM_ID32);
      packed[0] = (uint8_t)191;
      packed[1] = (uint8_t)(*unpacked).u.prim_id32.value;
      packed[2] = (uint8_t)((*unpacked).u.prim_id32.value >> 8);
      packed[3] = (uint8_t)((*unpacked).u.prim_id32.value >> 16);
      packed[4] = (uint8_t)((*unpacked).u.prim_id32.value >> 24);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)255;
   }
   else
   {
      unreachable();
   }
}
#endif
void v3d_pack_cl_compr_ind_tri(uint8_t *packed, const V3D_CL_COMPR_IND_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff2, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 4) << 4);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff2, 4) << 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)11 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 16);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 24);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 8);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)131;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c4.idx2, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)163;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c5.idx2, 24);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 8);
      packed[9] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)67;
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
      packed[9] = (uint8_t)(*unpacked).u.c6.idx2;
      packed[10] = (uint8_t)((*unpacked).u.c6.idx2 >> 8);
      packed[11] = (uint8_t)((*unpacked).u.c6.idx2 >> 16);
      packed[12] = (uint8_t)((*unpacked).u.c6.idx2 >> 24);
   }
   else
   {
      unreachable();
   }
}
void v3d_pack_cl_compr_ind_d3dpvsf_tri(uint8_t *packed, const V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff2, 5) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.c0.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.prov_vtx, 1) << 7);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff2, 4) << 4);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)11 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 15);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 15) >> 8) |
         (uint8_t)(gfx_bits((*unpacked).u.c2.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)15 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 6) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff2, 6) << 2);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 23);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 23) >> 8);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 23) >> 16) |
         (uint8_t)(gfx_bits((*unpacked).u.c3.prov_vtx, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.prov_vtx, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c4.idx2, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.prov_vtx, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c5.idx2, 24);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 8);
      packed[9] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx2, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.prov_vtx, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
      packed[9] = (uint8_t)(*unpacked).u.c6.idx2;
      packed[10] = (uint8_t)((*unpacked).u.c6.idx2 >> 8);
      packed[11] = (uint8_t)((*unpacked).u.c6.idx2 >> 16);
      packed[12] = (uint8_t)((*unpacked).u.c6.idx2 >> 24);
   }
   else
   {
      unreachable();
   }
}
void v3d_pack_cl_compr_ind_line(uint8_t *packed, const V3D_CL_COMPR_IND_LINE_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff1, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)7 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff0, 4) << 4);
      packed[1] = (uint8_t)gfx_pack_sint((*unpacked).u.c1.diff1, 4) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.reversed, 1) << 4) | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff1, 6) << 2);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c2.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c2.idx0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c3.reversed, 1) << 2) | (uint8_t)(1 << 3) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c3.diff1, 4) << 4);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c3.idx0, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.reversed, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c4.idx1, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx1, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.reversed, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx0, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx0, 24) >> 16);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c5.idx1, 24);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 8);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx1, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.reversed, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx0;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx0 >> 24);
      packed[5] = (uint8_t)(*unpacked).u.c6.idx1;
      packed[6] = (uint8_t)((*unpacked).u.c6.idx1 >> 8);
      packed[7] = (uint8_t)((*unpacked).u.c6.idx1 >> 16);
      packed[8] = (uint8_t)((*unpacked).u.c6.idx1 >> 24);
   }
   else
   {
      unreachable();
   }
}
void v3d_pack_cl_compr_ind_point(uint8_t *packed, const V3D_CL_COMPR_IND_POINT_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.diff, 6) << 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) << 2);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.diff, 13) >> 6) |
         (uint8_t)(gfx_bits((*unpacked).u.c1.reversed, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)2 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.diff, 6) << 2);
      packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).u.c2.count, 7) |
         (uint8_t)(gfx_bits((*unpacked).u.c2.reversed, 1) << 7);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C4)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C4);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c4.reversed, 1) << 4) | (uint8_t)(4 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c4.idx, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c4.idx, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C5)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C5);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c5.reversed, 1) << 4) | (uint8_t)(5 << 5);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c5.idx, 24);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 8);
      packed[3] = (uint8_t)(gfx_bits((*unpacked).u.c5.idx, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C6)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C6);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_bits((*unpacked).u.c6.reversed, 1) << 4) | (uint8_t)(2 << 5);
      packed[1] = (uint8_t)(*unpacked).u.c6.idx;
      packed[2] = (uint8_t)((*unpacked).u.c6.idx >> 8);
      packed[3] = (uint8_t)((*unpacked).u.c6.idx >> 16);
      packed[4] = (uint8_t)((*unpacked).u.c6.idx >> 24);
   }
   else
   {
      unreachable();
   }
}
#if V3D_HAS_INLINE_CLIP
void v3d_pack_cl_compr_xy_tri(uint8_t *packed, const V3D_CL_COMPR_XY_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) << 2);
      packed[1] = (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) >>
         6) | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.dy2, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c1.reuse, 2) << 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) << 6);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) >> 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) << 3);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) >> 5) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) << 2);
      packed[3] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) >> 6) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy2, 7) << 1);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c2.x0, 16);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c2.x0, 16) >> 8);
      packed[6] = (uint8_t)gfx_bits((*unpacked).u.c2.y0, 16);
      packed[7] = (uint8_t)(gfx_bits((*unpacked).u.c2.y0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)129;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.x0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.x0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c3.y0, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.y0, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c3.x1, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c3.x1, 16) >> 8);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c3.y1, 16);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c3.y1, 16) >> 8);
      packed[9] = (uint8_t)gfx_bits((*unpacked).u.c3.x2, 16);
      packed[10] = (uint8_t)(gfx_bits((*unpacked).u.c3.x2, 16) >> 8);
      packed[11] = (uint8_t)gfx_bits((*unpacked).u.c3.y2, 16);
      packed[12] = (uint8_t)(gfx_bits((*unpacked).u.c3.y2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)128;
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_HAS_INLINE_CLIP
void v3d_pack_cl_compr_xy_tri(uint8_t *packed, const V3D_CL_COMPR_XY_TRI_T *unpacked)
{
   if ((*unpacked).type == V3D_CL_COMPR_TYPE_C0)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C0);
      packed[0] = (uint8_t)gfx_bits((*unpacked).u.c0.reuse, 2) |
         (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) << 2);
      packed[1] = (uint8_t)(gfx_ror(gfx_pack_sint((*unpacked).u.c0.dx2, 7), 1, 7) >>
         6) | (uint8_t)(gfx_pack_sint((*unpacked).u.c0.dy2, 7) << 1);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C1)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C1);
      packed[0] = (uint8_t)3 | (uint8_t)(gfx_bits((*unpacked).u.c1.reuse, 2) << 2) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dx2, 10) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) << 6);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c1.dy2, 10) >> 2);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C2)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C2);
      packed[0] = (uint8_t)15 | (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) << 4);
      packed[1] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx1, 7) >> 4) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) << 3);
      packed[2] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy1, 7) >> 5) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) << 2);
      packed[3] = (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dx2, 7) >> 6) |
         (uint8_t)(gfx_pack_sint((*unpacked).u.c2.dy2, 7) << 1);
      packed[4] = (uint8_t)gfx_bits((*unpacked).u.c2.x0, 16);
      packed[5] = (uint8_t)(gfx_bits((*unpacked).u.c2.x0, 16) >> 8);
      packed[6] = (uint8_t)gfx_bits((*unpacked).u.c2.y0, 16);
      packed[7] = (uint8_t)(gfx_bits((*unpacked).u.c2.y0, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_C3)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_C3);
      packed[0] = (uint8_t)129;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.c3.x0, 16);
      packed[2] = (uint8_t)(gfx_bits((*unpacked).u.c3.x0, 16) >> 8);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.c3.y0, 16);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.c3.y0, 16) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.c3.x1, 16);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.c3.x1, 16) >> 8);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.c3.y1, 16);
      packed[8] = (uint8_t)(gfx_bits((*unpacked).u.c3.y1, 16) >> 8);
      packed[9] = (uint8_t)gfx_bits((*unpacked).u.c3.x2, 16);
      packed[10] = (uint8_t)(gfx_bits((*unpacked).u.c3.x2, 16) >> 8);
      packed[11] = (uint8_t)gfx_bits((*unpacked).u.c3.y2, 16);
      packed[12] = (uint8_t)(gfx_bits((*unpacked).u.c3.y2, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_REL_BRANCH);
      packed[0] = (uint8_t)130;
      packed[1] = (uint8_t)gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16);
      packed[2] = (uint8_t)(gfx_pack_sint(
         gfx_exact_asr((*unpacked).u.rel_branch.rel_addr, 5), 16) >> 8);
   }
   else if ((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE)
   {
      assert((*unpacked).type == V3D_CL_COMPR_TYPE_ESCAPE);
      packed[0] = (uint8_t)128;
   }
   else
   {
      unreachable();
   }
}
#endif
#if V3D_HAS_TNG
void v3d_pack_gs_vpm_fmt(uint32_t *packed, const V3D_GS_VPM_FMT_T *unpacked)
{
   packed[0] = gfx_bits((*unpacked).start_prim, 1) |
      gfx_bits((*unpacked).stream_idx, 2) << 1 |
      gfx_bits((*unpacked).length, 8) << 8 |
      gfx_bits((*unpacked).layer_idx, 8) << 16 |
      gfx_bits((*unpacked).viewport_idx, 4) << 24;
}
#endif
void v3d_pack_bstc_block(uint8_t *packed, const V3D_BSTC_BLOCK_T *unpacked)
{
   if ((*unpacked).four_plane == false &&
      ((*unpacked).u.three_plane.ba.max_range == false ||
      (*unpacked).u.three_plane.ba.max_range == true) &&
      (((*unpacked).u.three_plane.rg[0].max_range == false ||
      (*unpacked).u.three_plane.rg[0].max_range == true) &&
      ((*unpacked).u.three_plane.rg[1].max_range == false ||
      (*unpacked).u.three_plane.rg[1].max_range == true)))
   {
      packed[3] = (uint8_t)0 | (packed[3] & ~128);
      if ((*unpacked).u.three_plane.rg[0].max_range == false)
      {
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[15], 4) << 6) |
            (packed[9] & ~192);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[13], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[14],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[15], 4) >> 2);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[11], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[12],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[13], 4) >> 2);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[9], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[10],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[11], 4) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[7], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[8],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[9], 4) >> 2);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[5], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[6],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[7], 4) >> 2);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[3], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[4],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[5], 4) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[1], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[2],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[3], 4) >> 2);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.max, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.weights[0],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.weights[1], 4) >> 2);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.min, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.normal_range.max, 8) >> 2);
         packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.normal_range.min, 8) >> 2) |
            (packed[3] & ~127);
         assert((*unpacked).u.three_plane.rg[0].max_range == false);
      }
      else if ((*unpacked).u.three_plane.rg[0].max_range == true)
      {
         assert((*unpacked).u.three_plane.rg[0].max_range == true);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[15], 5) << 6) |
            (packed[9] & ~192);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[14], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[15],
            5) >> 2);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[12], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[13], 5);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[10], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[11],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[12], 5) >> 3);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[9], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[10],
            5) >> 1);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[7], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[8],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[9], 5) >> 4);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[6], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[7],
            5) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[4], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[5], 5);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[2], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[3],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[4], 5) >> 3);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[1], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[2],
            5) >> 1);
         packed[3] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[0].u.max_range.weights[0], 5) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[0].u.max_range.weights[1],
            5) >> 4) | (uint8_t)(1 << 6) | (packed[3] & ~127);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.three_plane.rg[1].max_range == false)
      {
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[15], 4) << 5) |
            (packed[23] & ~224);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[13], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[14],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[15], 4) >> 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[11], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[12],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[13], 4) >> 3);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[9], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[10],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[11], 4) >> 3);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[7], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[8],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[9], 4) >> 3);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[5], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[6],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[7], 4) >> 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[3], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[4],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[5], 4) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[1], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[2],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[3], 4) >> 3);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.max, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.weights[0],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.weights[1], 4) >> 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.min, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.normal_range.max, 8) >> 3);
         packed[9] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.normal_range.min, 8) >> 3) | (packed[9] & ~63);
         assert((*unpacked).u.three_plane.rg[1].max_range == false);
      }
      else if ((*unpacked).u.three_plane.rg[1].max_range == true)
      {
         assert((*unpacked).u.three_plane.rg[1].max_range == true);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[15], 5) << 5) |
            (packed[23] & ~224);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[13], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[14],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[15], 5) >> 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[12], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[13],
            5) >> 1);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[10], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[11],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[12], 5) >> 4);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[9], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[10],
            5) >> 2);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[7], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[8], 5);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[5], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[6],
            5) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[7], 5) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[4], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[5],
            5) >> 1);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[2], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[3],
            5) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[4], 5) >> 4);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[1], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.rg[1].u.max_range.weights[2],
            5) >> 2);
         packed[9] = (uint8_t)gfx_bits(
            (*unpacked).u.three_plane.rg[1].u.max_range.weights[0], 5) |
            (uint8_t)(1 << 5) | (packed[9] & ~63);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.three_plane.ba.max_range == false)
      {
         packed[28] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[14], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[15], 4);
         packed[29] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[12], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[13], 4);
         packed[30] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[10], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[11], 4);
         packed[31] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[8], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[9], 4);
         packed[24] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[6], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[7], 4);
         packed[25] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[4], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[5], 4);
         packed[26] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[2], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[3], 4);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.weights[0], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.weights[1], 4);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_a, 6) << 6) | (uint8_t)gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.max_a, 6);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.max_b, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.min_a, 6) >> 2);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_b, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.normal_range.max_b, 8) >> 4);
         packed[23] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.normal_range.min_b, 8) >> 4) | (packed[23] & ~31);
         assert((*unpacked).u.three_plane.ba.max_range == false);
      }
      else if ((*unpacked).u.three_plane.ba.max_range == true)
      {
         packed[28] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[14], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[15], 5);
         packed[29] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[12], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[13], 5) <<
            2) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[14],
            5) >> 3);
         packed[30] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[11], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[12], 5) >>
            1);
         packed[31] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[9], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[10], 5) <<
            1) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[11],
            5) >> 4);
         packed[24] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[8], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[9], 5) >> 2);
         packed[25] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[6], 5) << 5) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[7], 5);
         packed[26] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[4], 5) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[5], 5) <<
            2) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[6],
            5) >> 3);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[3], 5) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[4], 5) >> 1);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[1], 5) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[2], 5) <<
            1) | (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[3],
            5) >> 4);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.three_plane.ba.u.max_range.weights[0], 5) << 3) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.weights[1], 5) >> 2);
         packed[22] =
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.min_a, 6) << 6) |
            (uint8_t)gfx_bits((*unpacked).u.three_plane.ba.u.max_range.max_a, 6);
         packed[23] = (uint8_t)(1 << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.three_plane.ba.u.max_range.min_a, 6) >> 2) |
            (packed[23] & ~31);
         assert((*unpacked).u.three_plane.ba.max_range == true);
      }
      else
      {
         unreachable();
      }
      assert((*unpacked).four_plane == false);
   }
   else if ((*unpacked).four_plane == true &&
      (((*unpacked).u.four_plane.rgb[0].max_range == false ||
      (*unpacked).u.four_plane.rgb[0].max_range == true) &&
      ((*unpacked).u.four_plane.rgb[1].max_range == false ||
      (*unpacked).u.four_plane.rgb[1].max_range == true) &&
      ((*unpacked).u.four_plane.rgb[2].max_range == false ||
      (*unpacked).u.four_plane.rgb[2].max_range == true)))
   {
      packed[3] = (uint8_t)(1 << 7) | (packed[3] & ~128);
      if ((*unpacked).u.four_plane.rgb[0].max_range == false)
      {
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[15], 3) << 6) |
            (packed[11] & ~192);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[12], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[13],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[14], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[15],
            3) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[10], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[11],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[12], 3) >> 1);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[7], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[8],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[9], 3);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[4], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[5],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[6], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[7],
            3) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[2], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[3],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[4], 3) >> 1);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.max, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.weights[0],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.weights[1], 3);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.min, 8) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.normal_range.max, 8) >> 2);
         packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.normal_range.min, 8) >> 2) |
            (packed[3] & ~127);
         assert((*unpacked).u.four_plane.rgb[0].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[0].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[0].max_range == true);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[15], 4) << 6) |
            (packed[11] & ~192);
         packed[4] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[13], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[14],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[15], 4) >> 2);
         packed[5] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[11], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[12],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[13], 4) >> 2);
         packed[6] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[9], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[10],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[11], 4) >> 2);
         packed[7] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[7], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[8],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[9], 4) >> 2);
         packed[0] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[5], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[6],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[7], 4) >> 2);
         packed[1] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[3], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[4],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[5], 4) >> 2);
         packed[2] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[1], 4) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[2],
            4) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[3], 4) >> 2);
         packed[3] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[0].u.max_range.weights[0], 4) << 2) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[0].u.max_range.weights[1],
            4) >> 2) | (uint8_t)(1 << 6) | (packed[3] & ~127);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.four_plane.rgb[1].max_range == false)
      {
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[15], 3) << 5) |
            (packed[19] & ~224);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[12], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[13],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[14], 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[9], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[10],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[11], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[12],
            3) >> 2);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[7], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[8],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[9], 3) >> 1);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[4], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[5],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[6], 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[1], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[2],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[3], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[4],
            3) >> 2);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.max, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.weights[0],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.weights[1], 3) >> 1);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.min, 8) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.normal_range.max, 8) >> 3);
         packed[11] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.normal_range.min, 8) >> 3) |
            (packed[11] & ~63);
         assert((*unpacked).u.four_plane.rgb[1].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[1].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[1].max_range == true);
         packed[19] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[15], 4) << 5) |
            (packed[19] & ~224);
         packed[12] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[13], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[14],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[15], 4) >> 3);
         packed[13] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[11], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[12],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[13], 4) >> 3);
         packed[14] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[9], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[10],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[11], 4) >> 3);
         packed[15] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[7], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[8],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[9], 4) >> 3);
         packed[8] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[5], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[6],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[7], 4) >> 3);
         packed[9] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[3], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[4],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[5], 4) >> 3);
         packed[10] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[1], 4) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[2],
            4) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[3], 4) >> 3);
         packed[11] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[1].u.max_range.weights[0], 4) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[1].u.max_range.weights[1],
            4) >> 3) | (uint8_t)(1 << 5) | (packed[11] & ~63);
      }
      else
      {
         unreachable();
      }
      if ((*unpacked).u.four_plane.rgb[2].max_range == false)
      {
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[14], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[15],
            3) << 4) | (packed[27] & ~240);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[12], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[13],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[14], 3) >> 1);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[9], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[10],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[11], 3);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[6], 3) << 7) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[7],
            3) << 4) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[8], 3) << 1) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[9],
            3) >> 2);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[4], 3) << 5) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[5],
            3) << 2) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[6], 3) >> 1);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[1], 3) << 6) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[2],
            3) << 3) | (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[3], 3);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.max, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.weights[0],
            3) << 1) | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.weights[1], 3) >> 2);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.min, 8) << 4) |
            (uint8_t)(gfx_bits((*unpacked).u.four_plane.rgb[2].u.normal_range.max, 8) >> 4);
         packed[19] = (uint8_t)0 | (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.normal_range.min, 8) >> 4) |
            (packed[19] & ~31);
         assert((*unpacked).u.four_plane.rgb[2].max_range == false);
      }
      else if ((*unpacked).u.four_plane.rgb[2].max_range == true)
      {
         assert((*unpacked).u.four_plane.rgb[2].max_range == true);
         packed[27] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[15], 4) << 4) |
            (packed[27] & ~240);
         packed[20] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[13], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[14], 4);
         packed[21] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[11], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[12], 4);
         packed[22] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[9], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[10], 4);
         packed[23] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[7], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[8], 4);
         packed[16] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[5], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[6], 4);
         packed[17] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[3], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[4], 4);
         packed[18] = (uint8_t)(gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[1], 4) << 4) |
            (uint8_t)gfx_bits((*unpacked).u.four_plane.rgb[2].u.max_range.weights[2], 4);
         packed[19] = (uint8_t)gfx_bits(
            (*unpacked).u.four_plane.rgb[2].u.max_range.weights[0], 4) |
            (uint8_t)(1 << 4) | (packed[19] & ~31);
      }
      else
      {
         unreachable();
      }
      packed[28] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[13], 3) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[14], 3) << 3) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.weights[15], 3);
      packed[29] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[10], 3) << 7) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[11], 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[12], 3) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[13], 3) >> 2);
      packed[30] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[8], 3) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[9], 3) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[10], 3) >> 1);
      packed[31] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[5], 3) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[6], 3) << 3) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.weights[7], 3);
      packed[24] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[2], 3) << 7) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[3], 3) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[4], 3) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[5], 3) >> 2);
      packed[25] =
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[0], 3) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[1], 3) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.weights[2], 3) >> 1);
      packed[26] = (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.min, 6) << 6) |
         (uint8_t)gfx_bits((*unpacked).u.four_plane.a.max, 6);
      packed[27] = (uint8_t)(gfx_bits((*unpacked).u.four_plane.a.min, 6) >> 2) |
         (packed[27] & ~15);
      assert((*unpacked).four_plane == true);
   }
   else
   {
      unreachable();
   }
}
uint32_t v3d_pack_hub_ident0(void)
{
   return 0x42554856;
}
uint32_t v3d_pack_hub_ident1(const V3D_HUB_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).v3d_tech_version, 4) |
      gfx_bits((*unpacked).v3d_revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_l3c, 1) << 16 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 |
      gfx_bits((*unpacked).has_mso, 1) << 19 |
      gfx_bits((*unpacked).l3c_associativity, 4) << 20 |
      gfx_bits((*unpacked).l3c_banks, 4) << 24;
}
uint32_t v3d_pack_hub_ident2(const V3D_HUB_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).l3c_size_in_multiples_of_64kb, 8) |
      gfx_bits((*unpacked).has_mmu, 1) << 8;
}
uint32_t v3d_pack_hub_ident3(const V3D_HUB_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).v3d_sub_rev, 8) << 8;
}
void v3d_pack_hub_ident(uint32_t *packed, const V3D_HUB_IDENT_T *unpacked)
{
   packed[0] = 0x42554856;
   packed[1] = gfx_bits((*unpacked).v3d_tech_version, 4) |
      gfx_bits((*unpacked).v3d_revision, 4) << 4 |
      gfx_pack_uint_0_is_max((*unpacked).num_cores, 4) << 8 |
      gfx_check_urange((*unpacked).num_hosts, 1, 15) << 12 |
      gfx_bits((*unpacked).has_l3c, 1) << 16 |
      gfx_bits((*unpacked).has_tfu, 1) << 17 |
      gfx_bits((*unpacked).has_tsy, 1) << 18 |
      gfx_bits((*unpacked).has_mso, 1) << 19 |
      gfx_bits((*unpacked).l3c_associativity, 4) << 20 |
      gfx_bits((*unpacked).l3c_banks, 4) << 24;
   packed[2] = gfx_bits((*unpacked).l3c_size_in_multiples_of_64kb, 8) |
      gfx_bits((*unpacked).has_mmu, 1) << 8;
   packed[3] = gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).v3d_sub_rev, 8) << 8;
}
#if !V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident0(const V3D_IDENT0_T *unpacked)
{
   return 0x443356 | gfx_bits((*unpacked).v3d_tech_version, 8) << 24;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident1(const V3D_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).v3d_revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident2(const V3D_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident3(const V3D_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).v3d_sub_rev, 8) << 8;
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_pack_ident(uint32_t *packed, const V3D_IDENT_T *unpacked)
{
   packed[0] = 0x443356 | gfx_bits((*unpacked).v3d_tech_version, 8) << 24;
   packed[1] = gfx_bits((*unpacked).v3d_revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
   packed[2] = gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
   packed[3] = gfx_bits((*unpacked).ip_recipient, 8) |
      gfx_bits((*unpacked).v3d_sub_rev, 8) << 8;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident0(const V3D_IDENT0_T *unpacked)
{
   return 0x443356 | gfx_bits((*unpacked).v3d_tech_version, 8) << 24;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident1(const V3D_IDENT1_T *unpacked)
{
   return gfx_bits((*unpacked).v3d_revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident2(const V3D_IDENT2_T *unpacked)
{
   return gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
uint32_t v3d_pack_ident3(const V3D_IDENT3_T *unpacked)
{
   return gfx_bits((*unpacked).l2t_ways, 4) |
      gfx_bits((*unpacked).l2t_way_depth, 4) << 4;
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_pack_ident(uint32_t *packed, const V3D_IDENT_T *unpacked)
{
   packed[0] = 0x443356 | gfx_bits((*unpacked).v3d_tech_version, 8) << 24;
   packed[1] = gfx_bits((*unpacked).v3d_revision, 4) |
      gfx_check_urange((*unpacked).num_slices, 1, 15) << 4 |
      gfx_check_urange((*unpacked).num_qpus_per_slice, 1, 15) << 8 |
      gfx_check_urange((*unpacked).num_tmus, 1, 15) << 12 |
      gfx_bits((*unpacked).vpm_size_in_multiples_of_8kb, 4) << 28;
   packed[2] = gfx_bits((*unpacked).vri_size, 4) |
      gfx_bits((*unpacked).tlb_size, 4) << 4 |
      gfx_bits((*unpacked).tlb_double_buf_support, 1) << 8 |
      gfx_bits((*unpacked).icache_size, 4) << 12 |
      gfx_bits((*unpacked).ucache_size, 4) << 16 |
      gfx_bits((*unpacked).bigend, 1) << 20 |
      gfx_bits((*unpacked).endswp_support, 1) << 21 |
      gfx_bits((*unpacked).axi_rw_reorder_support, 1) << 22 |
      gfx_bits((*unpacked).no_earlyz_support, 1) << 23 |
      gfx_bits((*unpacked).core_index, 4) << 24 |
      gfx_bits((*unpacked).bcg_interrupt_control, 1) << 28 |
      gfx_bits((*unpacked).has_astc, 1) << 30;
   packed[3] = gfx_bits((*unpacked).l2t_ways, 4) |
      gfx_bits((*unpacked).l2t_way_depth, 4) << 4;
}
#endif
uint32_t v3d_pack_gs_inst_fifo_thrsh(const V3D_GS_INST_FIFO_THRSH_T *unpacked)
{
   return gfx_bits((*unpacked).cle, 8) | gfx_bits((*unpacked).gbg, 8) << 8 |
      gfx_bits((*unpacked).tpg, 8) << 16;
}
uint32_t v3d_pack_gs_tess_fifo_thrsh(const V3D_GS_TESS_FIFO_THRSH_T *unpacked)
{
   return gfx_bits((*unpacked).cle, 8) | gfx_bits((*unpacked).tpg, 8) << 8;
}
uint32_t v3d_pack_hub_intr(const V3D_HUB_INTR_T *unpacked)
{
   return gfx_bits((*unpacked).tfu_fifo_free_over_threshold, 1) |
      gfx_bits((*unpacked).tfu_conv_complete, 1) << 1 |
      gfx_bits((*unpacked).mso_obj_reached_state, 1) << 2 |
      gfx_bits((*unpacked).mmu_cap, 1) << 3 | gfx_bits((*unpacked).mmu_pti, 1) << 4 |
      gfx_bits((*unpacked).mmu_wrv, 1) << 5;
}
uint32_t v3d_pack_intr(const V3D_INTR_T *unpacked)
{
   return gfx_bits((*unpacked).render_done, 1) |
      gfx_bits((*unpacked).bin_done, 1) << 1 |
      gfx_bits((*unpacked).outomem, 1) << 2 |
      gfx_bits((*unpacked).spilluse, 1) << 3 | gfx_bits((*unpacked).trfb, 1) << 4 |
      gfx_bits((*unpacked).gmpv, 1) << 5 | gfx_bits((*unpacked).qpu[0], 1) << 16 |
      gfx_bits((*unpacked).qpu[1], 1) << 17 | gfx_bits((*unpacked).qpu[2], 1) << 18 |
      gfx_bits((*unpacked).qpu[3], 1) << 19 | gfx_bits((*unpacked).qpu[4], 1) << 20 |
      gfx_bits((*unpacked).qpu[5], 1) << 21 | gfx_bits((*unpacked).qpu[6], 1) << 22 |
      gfx_bits((*unpacked).qpu[7], 1) << 23 | gfx_bits((*unpacked).qpu[8], 1) << 24 |
      gfx_bits((*unpacked).qpu[9], 1) << 25 |
      gfx_bits((*unpacked).qpu[10], 1) << 26 |
      gfx_bits((*unpacked).qpu[11], 1) << 27 |
      gfx_bits((*unpacked).qpu[12], 1) << 28 |
      gfx_bits((*unpacked).qpu[13], 1) << 29 |
      gfx_bits((*unpacked).qpu[14], 1) << 30 | gfx_bits((*unpacked).qpu[15], 1) << 31;
}
uint32_t v3d_pack_ct0cs(const V3D_CT0CS_T *unpacked)
{
   return gfx_bits((*unpacked).ctooberr, 1) << 2 |
      gfx_bits((*unpacked).cterr, 1) << 3 | gfx_bits((*unpacked).ctsubsrun, 2) << 4 |
      gfx_bits((*unpacked).ctqdep, 1) << 6 | gfx_bits((*unpacked).ctrtsd, 2) << 8 |
      gfx_bits((*unpacked).ctsema, 3) << 12 | gfx_bits((*unpacked).ctrsta, 1) << 15;
}
uint32_t v3d_pack_ct1cs(const V3D_CT1CS_T *unpacked)
{
   return gfx_bits((*unpacked).ctetstop, 1) << 2 |
      gfx_bits((*unpacked).cterr, 1) << 3 | gfx_bits((*unpacked).ctsubsrun, 2) << 4 |
      gfx_bits((*unpacked).ctqdep, 1) << 6 | gfx_bits((*unpacked).ctrtsd, 2) << 8 |
      gfx_bits((*unpacked).ctsema, 3) << 12 | gfx_bits((*unpacked).ctrsta, 1) << 15;
}
uint32_t v3d_pack_ct1cfg(const V3D_CT1CFG_T *unpacked)
{
   return gfx_bits((*unpacked).disable_multicore, 1) |
      gfx_bits((*unpacked).ets_flush, 1) << 1 |
      gfx_bits((*unpacked).max_tiles_in_flight, 2) << 2 |
      gfx_bits((*unpacked).mcs_mask_set, 1) << 4 |
      gfx_bits((*unpacked).mcs_frame_id, 1) << 5;
}
uint32_t v3d_pack_ct1tilect(const V3D_CT1TILECT_T *unpacked)
{
   return gfx_bits((*unpacked).tiles_completed_in_curr_st, 16) |
      gfx_bits((*unpacked).supertiles_completed, 9) << 16 |
      gfx_bits((*unpacked).tiles_in_flight, 2) << 25;
}
uint32_t v3d_pack_ct1ptct(const V3D_CT1PTCT_T *unpacked)
{
   return gfx_bits((*unpacked).tiles_completed_in_curr_st, 16) |
      gfx_bits((*unpacked).supertiles_completed, 9) << 16 |
      gfx_bits((*unpacked).mcs_mask_set, 1) << 28 |
      gfx_bits((*unpacked).mcs_frame_id, 1) << 29 |
      gfx_bits((*unpacked).etstop, 1) << 31;
}
uint32_t v3d_pack_pcs(const V3D_PCS_T *unpacked)
{
   return gfx_bits((*unpacked).bmactive, 1) |
      gfx_bits((*unpacked).rmactive, 1) << 2 | gfx_bits((*unpacked).bmoom, 1) << 8;
}
uint32_t v3d_pack_tfucs(const V3D_TFUCS_T *unpacked)
{
   return gfx_bits((*unpacked).busy, 1) | gfx_bits((*unpacked).nfree, 6) << 8 |
      gfx_bits((*unpacked).cvtct, 8) << 16 | gfx_bits((*unpacked).tfurst, 1) << 31;
}
uint32_t v3d_pack_tfusu(const V3D_TFUSU_T *unpacked)
{
   return gfx_bits((*unpacked).throttle, 2) | gfx_bits((*unpacked).crc, 1) << 3 |
      gfx_bits((*unpacked).crcchain, 1) << 4 | gfx_bits((*unpacked).fintthr, 6) << 8;
}
uint32_t v3d_pack_tfuicfg(const V3D_TFUICFG_T *unpacked)
{
   return gfx_bits((*unpacked).ioc, 1) | gfx_bits((*unpacked).rgbord, 2) << 1 |
      gfx_bits((*unpacked).flipy, 1) << 3 | gfx_bits((*unpacked).srgb, 1) << 4 |
      gfx_pack_uint_minus_1((*unpacked).nummm, 4) << 5 |
      gfx_bits((*unpacked).ttype, 7) << 9 | gfx_bits((*unpacked).iformat, 4) << 18 |
      gfx_bits((*unpacked).opad, 10) << 22;
}
uint32_t v3d_pack_tfuiis(const V3D_TFUIIS_T *unpacked)
{
   return gfx_bits((*unpacked).stride0, 16) |
      gfx_bits((*unpacked).stride1, 16) << 16;
}
uint32_t v3d_pack_tfuioa(const V3D_TFUIOA_T *unpacked)
{
   return gfx_bits((*unpacked).dimtw, 1) | gfx_bits((*unpacked).oformat, 3) << 3 |
      gfx_exact_lsr((*unpacked).oaddr, 6) << 6;
}
uint32_t v3d_pack_tfuios(const V3D_TFUIOS_T *unpacked)
{
   return gfx_check_urange((*unpacked).xsize, 0, 0x4000) |
      gfx_check_urange((*unpacked).ysize, 0, 0x4000) << 16;
}
uint32_t v3d_pack_tfucoef0(const V3D_TFUCOEF0_T *unpacked)
{
   return gfx_bits((*unpacked).ay, 12) | gfx_bits((*unpacked).arc, 12) << 16 |
      gfx_bits((*unpacked).usecoef, 1) << 31;
}
uint32_t v3d_pack_tfucoef1(const V3D_TFUCOEF1_T *unpacked)
{
   return gfx_bits((*unpacked).agc, 12) | gfx_bits((*unpacked).abc, 12) << 16;
}
uint32_t v3d_pack_tfucoef2(const V3D_TFUCOEF2_T *unpacked)
{
   return gfx_bits((*unpacked).agr, 12) | gfx_bits((*unpacked).arr, 12) << 16;
}
uint32_t v3d_pack_tfucoef3(const V3D_TFUCOEF3_T *unpacked)
{
   return gfx_bits((*unpacked).abb, 12) | gfx_bits((*unpacked).agb, 12) << 16;
}
uint32_t v3d_pack_srqcs(const V3D_SRQCS_T *unpacked)
{
   return gfx_bits((*unpacked).num_queued, 6) |
      gfx_bits((*unpacked).queue_error, 1) << 7 |
      gfx_bits((*unpacked).num_requests, 8) << 8 |
      gfx_bits((*unpacked).num_completed, 8) << 16;
}
uint32_t v3d_pack_uifcfg(const V3D_UIFCFG_T *unpacked)
{
   return gfx_check_urange((*unpacked).page_size, 0, 2) |
      gfx_bits((*unpacked).num_banks, 2) << 2 | gfx_bits((*unpacked).xor_addr, 4) << 4;
}
#if V3D_VER_AT_LEAST(3,3,0,0)
uint32_t v3d_pack_dram_map_version(const V3D_DRAM_MAP_VERSION_T *unpacked)
{
   return gfx_bits((*unpacked).version, 4);
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
uint32_t v3d_pack_misccfg(const V3D_MISCCFG_T *unpacked)
{
   return gfx_bits((*unpacked).ovrtmuout, 1);
}
#endif
uint32_t v3d_pack_mmu_ctrl(const V3D_MMU_CTRL_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stats_enable, 1) << 1 |
      gfx_bits((*unpacked).tlb_clear, 1) << 2 |
      gfx_bits((*unpacked).stats_clear, 1) << 3 |
      gfx_bits((*unpacked).tlb_clearing, 1) << 7 |
      gfx_bits((*unpacked).wrv_exception, 1) << 9 |
      gfx_bits((*unpacked).wrv_interrupt, 1) << 10 |
      gfx_bits((*unpacked).wrv_abort, 1) << 11 | gfx_bits((*unpacked).wrv, 1) << 12 |
      gfx_bits((*unpacked).pti_enable, 1) << 16 |
      gfx_bits((*unpacked).pti_exception, 1) << 17 |
      gfx_bits((*unpacked).pti_interrupt, 1) << 18 |
      gfx_bits((*unpacked).pti_abort, 1) << 19 | gfx_bits((*unpacked).pti, 1) << 20 |
      gfx_bits((*unpacked).capex_exception, 1) << 24 |
      gfx_bits((*unpacked).capex_interrupt, 1) << 25 |
      gfx_bits((*unpacked).capex_abort, 1) << 26 |
      gfx_bits((*unpacked).capex, 1) << 27;
}
uint32_t v3d_pack_mmu_addr_cap(const V3D_MMU_ADDR_CAP_T *unpacked)
{
   return gfx_bits((*unpacked).mpage, 12) | gfx_bits((*unpacked).enable, 1) << 31;
}
uint32_t v3d_pack_mmu_bypass(const V3D_MMU_BYPASS_T *unpacked)
{
   return gfx_bits((*unpacked).mpage, 12) | gfx_bits((*unpacked).enable, 1) << 31;
}
uint32_t v3d_pack_mmu_illegal(const V3D_MMU_ILLEGAL_T *unpacked)
{
   return gfx_bits((*unpacked).page, 31) | gfx_bits((*unpacked).enable, 1) << 31;
}
uint32_t v3d_pack_mmu_debug_info(const V3D_MMU_DEBUG_INFO_T *unpacked)
{
   return gfx_bits((*unpacked).version, 4) |
      gfx_bits((*unpacked).va_width, 4) << 4 | gfx_bits((*unpacked).pa_width, 4) << 8;
}
uint32_t v3d_pack_mmuc_control(const V3D_MMUC_CONTROL_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) | gfx_bits((*unpacked).flush, 1) << 1 |
      gfx_bits((*unpacked).flushing, 1) << 2 |
      gfx_bits((*unpacked).clear_stats, 1) << 3 |
      gfx_bits((*unpacked).cache_size, 2) << 4;
}
uint32_t v3d_pack_gmp_cfg(const V3D_GMP_CFG_T *unpacked)
{
   return gfx_bits((*unpacked).enable, 1) |
      gfx_bits((*unpacked).stop_request, 1) << 1 |
      gfx_bits((*unpacked).page_cross_detect_enable, 1) << 2 |
      gfx_bits((*unpacked).long_burst_detect_enable, 1) << 3;
}
uint32_t v3d_pack_gmp_status(const V3D_GMP_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).violation, 1) |
      gfx_bits((*unpacked).invalid_table, 1) << 1 |
      gfx_bits((*unpacked).counter_overflow, 1) << 2 |
      gfx_bits((*unpacked).cfg_update, 1) << 3 |
      gfx_bits((*unpacked).read_active, 1) << 4 |
      gfx_bits((*unpacked).write_active, 1) << 5 |
      gfx_bits((*unpacked).read_count, 7) << 16 |
      gfx_bits((*unpacked).write_count, 7) << 24 |
      gfx_bits((*unpacked).reset, 1) << 31;
}
uint32_t v3d_pack_umr_axi_control(const V3D_UMR_AXI_CONTROL_T *unpacked)
{
   return gfx_bits((*unpacked).reg_data, 16) |
      gfx_bits((*unpacked).reg_addr, 5) << 24 | gfx_bits((*unpacked).write, 1) << 31;
}
uint16_t v3d_pack_umr_axi_burst(const V3D_UMR_AXI_BURST_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_len, 10) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).axi_size, 3) << 13);
}
uint16_t v3d_pack_umr_axi_id(const V3D_UMR_AXI_ID_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_id, 13) |
      (uint16_t)(gfx_bits((*unpacked).axi_prot, 3) << 13);
}
uint16_t v3d_pack_umr_axi_status(const V3D_UMR_AXI_STATUS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).write, 1) |
      (uint16_t)(gfx_bits((*unpacked).read, 1) << 1) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_almost_full, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_almost_empty, 1) << 5) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).fpga_num, 4) << 8) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).master_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).axi_idle, 1) << 15);
}
uint16_t v3d_pack_umr_axi_error(const V3D_UMR_AXI_ERROR_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).axi_response, 2) |
      (uint16_t)(gfx_bits((*unpacked).axi_timeout, 1) << 2) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_missed, 1) << 3) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_rd, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).rd_fifo_wr, 1) << 5) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_rd, 1) << 6) |
      (uint16_t)(gfx_bits((*unpacked).wr_fifo_wr, 1) << 7) |
      (uint16_t)(gfx_bits((*unpacked).wr_data_left, 1) << 8) |
      (uint16_t)(gfx_bits((*unpacked).wr_no_data, 1) << 9) |
      (uint16_t)(gfx_bits((*unpacked).rd_data_left, 1) << 10) |
      (uint16_t)(gfx_bits((*unpacked).start_when_busy, 1) << 11) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).start_error, 1) << 13) |
      (uint16_t)(gfx_bits((*unpacked).fifo_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).axi_error, 1) << 15);
}
uint16_t v3d_pack_umr_axi_flags(const V3D_UMR_AXI_FLAGS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).read_req, 1) |
      (uint16_t)(gfx_bits((*unpacked).write_req, 1) << 1) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).clear_error, 1) << 14) |
      (uint16_t)(gfx_bits((*unpacked).fifo_reset, 1) << 15);
}
uint16_t v3d_pack_umr_axi_fifo_flags(const V3D_UMR_AXI_FIFO_FLAGS_T *unpacked)
{
   return (uint16_t)gfx_bits((*unpacked).wr_full, 1) |
      (uint16_t)(gfx_bits((*unpacked).wr_empty, 1) << 1) |
      (uint16_t)(gfx_bits((*unpacked).wr_almost_empty, 1) << 2) |
      (uint16_t)(gfx_bits((*unpacked).wr_data_left, 1) << 3) |
      (uint16_t)(gfx_bits((*unpacked).rd_full, 1) << 4) |
      (uint16_t)(gfx_bits((*unpacked).rd_empty, 1) << 5) |
      (uint16_t)(gfx_bits((*unpacked).rd_almost_full, 1) << 6) |
      (uint16_t)(gfx_bits((*unpacked).rd_data_left, 1) << 7) | (uint16_t)0 |
      (uint16_t)(gfx_bits((*unpacked).resetting, 1) << 15);
}
uint32_t v3d_pack_umr_sysmon_infra_status(const V3D_UMR_SYSMON_INFRA_STATUS_T *unpacked)
{
   return gfx_bits((*unpacked).slave_error, 8) |
      gfx_bits((*unpacked).mastr_done, 8) << 8 |
      gfx_bits((*unpacked).num_slaves, 4) << 16 |
      gfx_bits((*unpacked).design_reset, 1) << 21 |
      gfx_bits((*unpacked).local_done, 1) << 22 |
      gfx_bits((*unpacked).iodely_rdy, 1) << 23 |
      gfx_bits((*unpacked).reset_state, 4) << 24 |
      gfx_bits((*unpacked).parity_error, 1) << 29 |
      gfx_bits((*unpacked).pll_locked, 1) << 30 |
      gfx_bits((*unpacked).infra_error, 1) << 31;
}
#if !V3D_HAS_INLINE_CLIP
uint32_t v3d_cl_compr_ind_common_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_IID8:       return 2;
   case V3D_CL_COMPR_TYPE_IID32:      return 5;
   case V3D_CL_COMPR_TYPE_REL_BRANCH: return 3;
   case V3D_CL_COMPR_TYPE_BRANCH:     return 5;
   case V3D_CL_COMPR_TYPE_ESCAPE:     return 1;
   case V3D_CL_COMPR_TYPE_NOT_COMMON: return 0;
   default:                           unreachable(); return 0;
   }
}
#endif
#if V3D_HAS_INLINE_CLIP
uint32_t v3d_cl_compr_ind_common_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_IID8:         return 2;
   case V3D_CL_COMPR_TYPE_IID32:        return 5;
   case V3D_CL_COMPR_TYPE_PRIM_ID8:     return 2;
   case V3D_CL_COMPR_TYPE_PRIM_ID32:    return 5;
   case V3D_CL_COMPR_TYPE_CLIPPED_PRIM: return 5;
   case V3D_CL_COMPR_TYPE_ESCAPE:       return 1;
   case V3D_CL_COMPR_TYPE_NOT_COMMON:   return 0;
   default:                             unreachable(); return 0;
   }
}
#endif
#if V3D_HAS_TNG
uint32_t v3d_cl_compr_serial_packed_size(v3d_cl_compr_serial_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_SERIAL_TYPE_C0:           return 1;
   case V3D_CL_COMPR_SERIAL_TYPE_C1:           return 2;
   case V3D_CL_COMPR_SERIAL_TYPE_C2:           return 1;
   case V3D_CL_COMPR_SERIAL_TYPE_C3:           return 3;
   case V3D_CL_COMPR_SERIAL_TYPE_CLIPPED_PRIM: return 5;
   case V3D_CL_COMPR_SERIAL_TYPE_TG_MODE:      return 2;
   case V3D_CL_COMPR_SERIAL_TYPE_END_LEVEL:    return 1;
   default:                                    unreachable(); return 0;
   }
}
#endif
#if V3D_HAS_TNG && V3D_HAS_INLINE_CLIP
uint32_t v3d_cl_compr_ind_generic_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0:        return 1;
   case V3D_CL_COMPR_TYPE_C1:        return 2;
   case V3D_CL_COMPR_TYPE_C2:        return 1;
   case V3D_CL_COMPR_TYPE_C3:        return 2;
   case V3D_CL_COMPR_TYPE_C4:        return 3;
   case V3D_CL_COMPR_TYPE_C5:        return 4;
   case V3D_CL_COMPR_TYPE_C6:        return 5;
   case V3D_CL_COMPR_TYPE_IID8:      return 2;
   case V3D_CL_COMPR_TYPE_IID32:     return 5;
   case V3D_CL_COMPR_TYPE_PRIM_ID8:  return 2;
   case V3D_CL_COMPR_TYPE_PRIM_ID32: return 5;
   case V3D_CL_COMPR_TYPE_ESCAPE:    return 1;
   default:                          unreachable(); return 0;
   }
}
#endif
uint32_t v3d_cl_compr_ind_tri_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0: return 1;
   case V3D_CL_COMPR_TYPE_C1: return 2;
   case V3D_CL_COMPR_TYPE_C2: return 4;
   case V3D_CL_COMPR_TYPE_C3: return 5;
   case V3D_CL_COMPR_TYPE_C4: return 7;
   case V3D_CL_COMPR_TYPE_C5: return 10;
   case V3D_CL_COMPR_TYPE_C6: return 13;
   default:                   unreachable(); return 0;
   }
}
uint32_t v3d_cl_compr_ind_d3dpvsf_tri_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0: return 1;
   case V3D_CL_COMPR_TYPE_C1: return 2;
   case V3D_CL_COMPR_TYPE_C2: return 4;
   case V3D_CL_COMPR_TYPE_C3: return 5;
   case V3D_CL_COMPR_TYPE_C4: return 7;
   case V3D_CL_COMPR_TYPE_C5: return 10;
   case V3D_CL_COMPR_TYPE_C6: return 13;
   default:                   unreachable(); return 0;
   }
}
uint32_t v3d_cl_compr_ind_line_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0: return 1;
   case V3D_CL_COMPR_TYPE_C1: return 2;
   case V3D_CL_COMPR_TYPE_C2: return 3;
   case V3D_CL_COMPR_TYPE_C3: return 4;
   case V3D_CL_COMPR_TYPE_C4: return 5;
   case V3D_CL_COMPR_TYPE_C5: return 7;
   case V3D_CL_COMPR_TYPE_C6: return 9;
   default:                   unreachable(); return 0;
   }
}
uint32_t v3d_cl_compr_ind_point_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0: return 1;
   case V3D_CL_COMPR_TYPE_C1: return 2;
   case V3D_CL_COMPR_TYPE_C2: return 2;
   case V3D_CL_COMPR_TYPE_C4: return 3;
   case V3D_CL_COMPR_TYPE_C5: return 4;
   case V3D_CL_COMPR_TYPE_C6: return 5;
   default:                   unreachable(); return 0;
   }
}
#if V3D_HAS_INLINE_CLIP
uint32_t v3d_cl_compr_xy_tri_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0:     return 2;
   case V3D_CL_COMPR_TYPE_C1:     return 3;
   case V3D_CL_COMPR_TYPE_C2:     return 8;
   case V3D_CL_COMPR_TYPE_C3:     return 13;
   case V3D_CL_COMPR_TYPE_ESCAPE: return 1;
   default:                       unreachable(); return 0;
   }
}
#endif
#if !V3D_HAS_INLINE_CLIP
uint32_t v3d_cl_compr_xy_tri_packed_size(v3d_cl_compr_type_t type)
{
   switch (type)
   {
   case V3D_CL_COMPR_TYPE_C0:         return 2;
   case V3D_CL_COMPR_TYPE_C1:         return 3;
   case V3D_CL_COMPR_TYPE_C2:         return 8;
   case V3D_CL_COMPR_TYPE_C3:         return 13;
   case V3D_CL_COMPR_TYPE_REL_BRANCH: return 3;
   case V3D_CL_COMPR_TYPE_ESCAPE:     return 1;
   default:                           unreachable(); return 0;
   }
}
#endif
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 12 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 16 & 255, 0, 64));
   printer->vtbl->field(printer, "cs_output_size", "%" PRIu32 "", packed[1] & 255);
   printer->vtbl->field(printer, "cs_input_size", "%" PRIu32 "",
      packed[1] >> 8 & 255);
   printer->vtbl->field(printer, "vs_output_size", "%" PRIu32 "",
      packed[1] >> 16 & 255);
   printer->vtbl->field(printer, "vs_input_size", "%" PRIu32 "", packed[1] >> 24);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 12 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 16 & 255, 0, 64));
   printer->vtbl->field(printer, "cs_output_size", "%" PRIu32 "", packed[1] & 255);
   printer->vtbl->field(printer, "cs_input_size", "%" PRIu32 "",
      packed[1] >> 8 & 255);
   printer->vtbl->field(printer, "vs_output_size", "%" PRIu32 "",
      packed[1] >> 16 & 255);
   printer->vtbl->field(printer, "vs_input_size", "%" PRIu32 "", packed[1] >> 24);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 12 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_used", packed[0] >> 13 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_to_fs", packed[0] >> 14 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 16 & 255, 0, 64));
   printer->vtbl->field(printer, "cs_output_size", "%" PRIu32 "", packed[1] & 255);
   printer->vtbl->field(printer, "cs_input_size", "%" PRIu32 "",
      packed[1] >> 8 & 255);
   printer->vtbl->field(printer, "vs_output_size", "%" PRIu32 "",
      packed[1] >> 16 & 255);
   printer->vtbl->field(printer, "vs_input_size", "%" PRIu32 "", packed[1] >> 24);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 12 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_used", packed[0] >> 13 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_to_fs", packed[0] >> 14 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 16 & 255, 0, 64));
   printer->vtbl->field(printer, "cs_output_size", "%" PRIu32 "", packed[1] & 255);
   printer->vtbl->field(printer, "cs_input_size", "%" PRIu32 "",
      packed[1] >> 8 & 255);
   printer->vtbl->field(printer, "vs_output_size", "%" PRIu32 "",
      packed[1] >> 16 & 255);
   printer->vtbl->field(printer, "vs_input_size", "%" PRIu32 "", packed[1] >> 24);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "cs_baseinstance", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "vs_baseinstance", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 10 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 16 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 17 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 0, 64));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 4 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 8 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 12 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 20 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 24 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 28 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SRS && !V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "cs_baseinstance", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "vs_baseinstance", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 10 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "sample_rate_shading",
      packed[0] >> 13 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 16 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 17 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 0, 64));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 4 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 8 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 12 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 20 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 24 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 28 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "cs_baseinstance", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "vs_baseinstance", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 10 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_used", packed[0] >> 14 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_to_fs", packed[0] >> 15 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 16 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 17 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 0, 64));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 4 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 8 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 12 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 20 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 24 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 28 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && !V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "cs_baseinstance", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "vs_baseinstance", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 10 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "sample_rate_shading",
      packed[0] >> 13 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_used", packed[0] >> 14 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_to_fs", packed[0] >> 15 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 16 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 17 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 0, 64));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 4 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 8 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 12 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 20 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 24 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 28 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SRS && V3D_HAS_INLINE_CLIP && V3D_HAS_TNG && V3D_HAS_VARY_DISABLE
void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "point_size_included", packed[0] & 1);
   printer->vtbl->boolean_field(printer, "clipping", packed[0] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "cs_vertex_id", packed[0] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cs_instance_id", packed[0] >> 3 & 1);
   printer->vtbl->boolean_field(printer, "cs_baseinstance", packed[0] >> 4 & 1);
   printer->vtbl->boolean_field(printer, "vs_vertex_id", packed[0] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "vs_instance_id", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "vs_baseinstance", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "z_write", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "no_ez", packed[0] >> 9 & 1);
   printer->vtbl->boolean_field(printer, "cs_separate_blocks", packed[0] >> 10 & 1);
   printer->vtbl->boolean_field(printer, "vs_separate_blocks", packed[0] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "sample_rate_shading",
      packed[0] >> 13 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_used", packed[0] >> 14 & 1);
   printer->vtbl->boolean_field(printer, "prim_id_to_fs", packed[0] >> 15 & 1);
   printer->vtbl->boolean_field(printer, "disable_scb", packed[0] >> 16 & 1);
   printer->vtbl->boolean_field(printer, "scb_wait_on_first_thrsw",
      packed[0] >> 17 & 1);
   printer->vtbl->boolean_field(printer, "disable_implicit_varys",
      packed[0] >> 18 & 1);
   printer->vtbl->field(printer, "num_varys", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 0, 64));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 4 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 8 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 12 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_output_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] >> 16 & 15, 4));
   printer->vtbl->field(printer, "min_extra_req", "%" PRIu32 "",
      packed[1] >> 20 & 3);
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs_input_size", false);
   printer->vtbl->field(printer, "sectors", "%" PRIu32 "", packed[1] >> 24 & 15);
   printer->vtbl->field(printer, "min_req", "%" PRIu32 "",
      (packed[1] >> 28 & 3) + 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "defaults", packed[2]);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[3] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[3] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[3] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "vs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[5] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[5] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[5] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[6]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[7] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[7] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[7] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[8]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_shadrec_gl_geom(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "gs_bin", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[0] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[0] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[0] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[1]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "gs_render", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[2] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[2] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[2] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[3]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_shadrec_gl_tess(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_bin", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[0] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[0] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[0] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[1]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_render", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[2] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[2] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[2] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[3]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_bin", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[4] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[4] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[4] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[5]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_render", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[6] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[6] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[6] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[7]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_SREC_TG_TWEAK
void v3d_print_shadrec_gl_tess_or_geom(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "tess_type", "%s", v3d_desc_cl_tess_type(
      (v3d_cl_tess_type_t)(packed[0] >> 1 & 3)));
   printer->vtbl->boolean_field(printer, "tess_point_mode", packed[0] >> 3 & 1);
   printer->vtbl->field(printer, "tess_edge_spacing", "%s",
      v3d_desc_cl_tess_edge_spacing((v3d_cl_tess_edge_spacing_t)(packed[0] >> 4 & 3)));
   printer->vtbl->boolean_field(printer, "tess_clockwise", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "tcs_bypass", packed[0] >> 8 & 1);
   printer->vtbl->boolean_field(printer, "tcs_bypass_render", packed[0] >> 9 & 1);
   printer->vtbl->field(printer, "tcs_batch_flush", "%s",
      v3d_desc_cl_tcs_batch_flush_mode(
      (v3d_cl_tcs_batch_flush_mode_t)(packed[0] >> 10 & 3)));
   printer->vtbl->boolean_field(printer, "tes_no_inp_verts", packed[0] >> 12 & 1);
   printer->vtbl->field(printer, "per_patch_depth_bin", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 16 & 15, 4));
   printer->vtbl->field(printer, "per_patch_depth_render", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 20 & 15, 4));
   printer->vtbl->field(printer, "num_tcs_invocations", "%" PRIu32 "",
      gfx_check_urange(packed[0] >> 24, 1, 32));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 8 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 14 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 16 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 24 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s",
      v3d_desc_cl_vpm_pack((v3d_cl_vpm_pack_t)(packed[1] >> 30)));
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "geom_output", "%s", v3d_desc_cl_geom_prim_type(
      (v3d_cl_geom_prim_type_t)(packed[2] >> 1 & 3)));
   printer->vtbl->field(printer, "geom_num_instances", "%" PRIu32 "",
      gfx_check_urange(packed[2] >> 8 & 255, 1, 32));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "geom_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[2] >> 16 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_geom_output_pack(
      (v3d_cl_geom_output_pack_t)(packed[2] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "geom_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[2] >> 24 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_geom_output_pack(
      (v3d_cl_geom_output_pack_t)(packed[2] >> 30)));
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "max_patches_per_tcs_batch", "%" PRIu32 "",
      (packed[3] & 7) + 1);
   printer->vtbl->field(printer, "min_tcs_segs_bin", "%" PRIu32 "",
      (packed[3] >> 3 & 7) + 1);
   printer->vtbl->field(printer, "min_tcs_segs_render", "%" PRIu32 "",
      (packed[3] >> 6 & 7) + 1);
   printer->vtbl->field(printer, "min_per_patch_segs_bin", "%" PRIu32 "",
      (packed[3] >> 9 & 3) + 1);
   printer->vtbl->field(printer, "min_per_patch_segs_render", "%" PRIu32 "",
      (packed[3] >> 11 & 3) + 1);
   printer->vtbl->field(printer, "max_patches_per_tes_batch", "%" PRIu32 "",
      (packed[3] >> 14 & 7) + 1);
   printer->vtbl->field(printer, "min_tes_segs_bin", "%" PRIu32 "",
      (packed[3] >> 17 & 7) + 1);
   printer->vtbl->field(printer, "min_tes_segs_render", "%" PRIu32 "",
      (packed[3] >> 20 & 7) + 1);
   printer->vtbl->field(printer, "max_patches_per_gs_batch", "%" PRIu32 "",
      (packed[3] >> 23 & 7) + 1);
   printer->vtbl->field(printer, "min_gs_segs_bin", "%" PRIu32 "",
      (packed[3] >> 26 & 7) + 1);
   printer->vtbl->field(printer, "min_gs_segs_render", "%" PRIu32 "",
      (packed[3] >> 29) + 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_SREC_TG_TWEAK
void v3d_print_shadrec_gl_tess_or_geom(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "tess_type", "%s", v3d_desc_cl_tess_type(
      (v3d_cl_tess_type_t)(packed[0] >> 1 & 3)));
   printer->vtbl->boolean_field(printer, "tess_point_mode", packed[0] >> 3 & 1);
   printer->vtbl->field(printer, "tess_edge_spacing", "%s",
      v3d_desc_cl_tess_edge_spacing((v3d_cl_tess_edge_spacing_t)(packed[0] >> 4 & 3)));
   printer->vtbl->boolean_field(printer, "tess_clockwise", packed[0] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "tcs_bypass", packed[0] >> 7 & 1);
   printer->vtbl->boolean_field(printer, "tcs_bypass_render", packed[0] >> 8 & 1);
   printer->vtbl->field(printer, "tcs_batch_flush", "%s",
      v3d_desc_cl_tcs_batch_flush_mode(
      (v3d_cl_tcs_batch_flush_mode_t)(packed[0] >> 9 & 3)));
   printer->vtbl->boolean_field(printer, "tes_no_inp_verts", packed[0] >> 11 & 1);
   printer->vtbl->field(printer, "num_tcs_invocations", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 12 & 31, 5));
   printer->vtbl->field(printer, "geom_output", "%s", v3d_desc_cl_geom_prim_type(
      (v3d_cl_geom_prim_type_t)(packed[0] >> 17 & 3)));
   printer->vtbl->field(printer, "geom_num_instances", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 19 & 31, 5));
   printer->vtbl->field(printer, "per_patch_depth_bin", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 24 & 15, 4));
   printer->vtbl->field(printer, "per_patch_depth_render", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[0] >> 28, 4));
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tcs_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 8 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 14 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 16 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_vpm_pack(
      (v3d_cl_vpm_pack_t)(packed[1] >> 22 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tes_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 24 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s",
      v3d_desc_cl_vpm_pack((v3d_cl_vpm_pack_t)(packed[1] >> 30)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "geom_output_bin", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[2] & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_geom_output_pack(
      (v3d_cl_geom_output_pack_t)(packed[2] >> 6 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "geom_output_render", false);
   printer->vtbl->field(printer, "size_sectors", "%" PRIu32 "",
      gfx_check_urange(packed[2] >> 8 & 63, 0, 16));
   printer->vtbl->field(printer, "pack", "%s", v3d_desc_cl_geom_output_pack(
      (v3d_cl_geom_output_pack_t)(packed[2] >> 14 & 3)));
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "max_patches_per_tcs_batch", "%" PRIu32 "",
      (packed[2] >> 16 & 15) + 1);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_tcs_batch_bin",
      "%" PRIu32 "", packed[2] >> 20 & 3);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_tcs_batch_render",
      "%" PRIu32 "", packed[2] >> 22 & 3);
   printer->vtbl->field(printer, "min_tcs_segs_bin", "%" PRIu32 "",
      (packed[2] >> 24 & 7) + 1);
   printer->vtbl->field(printer, "min_tcs_segs_render", "%" PRIu32 "",
      (packed[2] >> 27 & 7) + 1);
   printer->vtbl->field(printer, "min_per_patch_segs_bin", "%" PRIu32 "",
      (packed[2] >> 30) + 1);
   printer->vtbl->field(printer, "min_per_patch_segs_render", "%" PRIu32 "",
      (packed[3] & 3) + 1);
   printer->vtbl->field(printer, "max_patches_per_tes_batch", "%" PRIu32 "",
      (packed[3] >> 2 & 15) + 1);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_tes_batch_bin",
      "%" PRIu32 "", packed[3] >> 6 & 3);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_tes_batch_render",
      "%" PRIu32 "", packed[3] >> 8 & 3);
   printer->vtbl->field(printer, "max_tcs_segs_per_tes_batch_bin", "%" PRIu32 "",
      (packed[3] >> 10 & 7) + 1);
   printer->vtbl->field(printer, "max_tcs_segs_per_tes_batch_render",
      "%" PRIu32 "", (packed[3] >> 13 & 7) + 1);
   printer->vtbl->field(printer, "min_tes_segs_bin", "%" PRIu32 "",
      (packed[3] >> 16 & 7) + 1);
   printer->vtbl->field(printer, "min_tes_segs_render", "%" PRIu32 "",
      (packed[3] >> 19 & 7) + 1);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_gs_batch_bin",
      "%" PRIu32 "", packed[3] >> 22 & 3);
   printer->vtbl->field(printer, "max_extra_vert_segs_per_gs_batch_render",
      "%" PRIu32 "", packed[3] >> 24 & 3);
   printer->vtbl->field(printer, "min_gs_segs_bin", "%" PRIu32 "",
      (packed[3] >> 26 & 7) + 1);
   printer->vtbl->field(printer, "min_gs_segs_render", "%" PRIu32 "",
      (packed[3] >> 29) + 1);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_shadrec_gl_attr(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "addr", packed[0]);
   printer->vtbl->field(printer, "size", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[1] & 3, 2));
   printer->vtbl->field(printer, "type", "%s",
      v3d_desc_attr_type((v3d_attr_type_t)(packed[1] >> 2 & 7)));
   printer->vtbl->boolean_field(printer, "signed_int", packed[1] >> 5 & 1);
   printer->vtbl->boolean_field(printer, "normalised_int", packed[1] >> 6 & 1);
   printer->vtbl->boolean_field(printer, "read_as_int", packed[1] >> 7 & 1);
   printer->vtbl->field(printer, "cs_num_reads", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 8 & 15, 0, 4));
   printer->vtbl->field(printer, "vs_num_reads", "%" PRIu32 "",
      gfx_check_urange(packed[1] >> 12 & 15, 0, 4));
   printer->vtbl->field(printer, "divisor", "%" PRIu32 "", packed[1] >> 16);
   printer->vtbl->field(printer, "stride", "%" PRIu32 "", packed[2]);
   printer->vtbl->end(printer);
}
void v3d_print_shadrec_vg(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s",
      v3d_desc_threading((v3d_threading_t)(packed[1] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans", packed[1] >> 2 & 1);
   printer->vtbl->addr_field(printer, "addr", packed[1] >> 3 << 3);
   printer->vtbl->addr_field(printer, "unifs_addr", packed[2]);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_unif_raw(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "unif", "0x%08x", packed0);
   printer->vtbl->end(printer);
}
void v3d_print_unif_addr(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "addr", packed0);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((packed0 >> 9 & 1) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cfg0", false);
      printer->vtbl->field(printer, "type", "%s",
         v3d_desc_tmu_type((v3d_tmu_type_t)(packed0 & 127)));
      printer->vtbl->boolean_field(printer, "srgb", packed0 >> 7 & 1);
      printer->vtbl->boolean_field(printer, "pix_mask", packed0 >> 8 & 1);
      printer->vtbl->field(printer, "width", "%" PRIu32 "",
         gfx_unpack_uint_0_is_max(packed0 >> 10 & 0x7ff, 11));
      printer->vtbl->field(printer, "height", "%" PRIu32 "",
         gfx_unpack_uint_0_is_max(packed0 >> 21, 11));
      printer->vtbl->end(printer);
   }
   else if ((packed0 >> 9 & 1) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "cfg1", false);
      printer->vtbl->field(printer, "ltype", "%s",
         v3d_desc_tmu_ltype((v3d_tmu_ltype_t)(packed0 & 7)));
      printer->vtbl->boolean_field(printer, "fetch", packed0 >> 3 & 1);
      printer->vtbl->boolean_field(printer, "gather", packed0 >> 4 & 1);
      printer->vtbl->boolean_field(printer, "bias", packed0 >> 5 & 1);
      printer->vtbl->boolean_field(printer, "bslod", packed0 >> 6 & 1);
      printer->vtbl->boolean_field(printer, "coefficient", packed0 >> 7 & 1);
      printer->vtbl->boolean_field(printer, "shadow", packed0 >> 8 & 1);
      printer->vtbl->field(printer, "wrap_s", "%s",
         v3d_desc_tmu_wrap((v3d_tmu_wrap_t)(packed0 >> 10 & 7)));
      printer->vtbl->field(printer, "wrap_t", "%s",
         v3d_desc_tmu_wrap((v3d_tmu_wrap_t)(packed0 >> 13 & 7)));
      printer->vtbl->field(printer, "wrap_r", "%s",
         v3d_desc_tmu_wrap((v3d_tmu_wrap_t)(packed0 >> 16 & 7)));
      printer->vtbl->field(printer, "tex_off_s", "%" PRId32 "",
         gfx_sext(packed0 >> 19 & 15, 4));
      printer->vtbl->field(printer, "tex_off_t", "%" PRId32 "",
         gfx_sext(packed0 >> 23 & 15, 4));
      printer->vtbl->field(printer, "tex_off_r", "%" PRId32 "",
         gfx_sext(packed0 >> 27 & 15, 4));
      printer->vtbl->boolean_field(printer, "pix_mask", packed0 >> 31);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_param1_cfg0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "wrap_s", "%s",
      v3d_desc_tmu_wrap_cfg0((v3d_tmu_wrap_cfg0_t)(packed0 & 3)));
   printer->vtbl->field(printer, "wrap_t", "%s", v3d_desc_tmu_wrap_cfg0(
      (v3d_tmu_wrap_cfg0_t)(packed0 >> 2 & 3)));
   printer->vtbl->field(printer, "filter", "%s",
      v3d_desc_tmu_filter((v3d_tmu_filter_t)(packed0 >> 4 & 15)));
   printer->vtbl->boolean_field(printer, "bslod", packed0 >> 8 & 1);
   printer->vtbl->addr_field(printer, "base", packed0 >> 9 << 9);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_param1_cfg1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "word0_en", packed0 & 1);
   printer->vtbl->boolean_field(printer, "word1_en", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "word2_en", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "word3_en", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "unnorm", packed0 >> 4 & 1);
   printer->vtbl->addr_field(printer, "ts_base", packed0 >> 5 << 5);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "word_en", false);
   printer->vtbl->boolean_field(printer, "0", packed0 & 1);
   printer->vtbl->boolean_field(printer, "1", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "2", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "3", packed0 >> 3 & 1);
   printer->vtbl->end(printer);
   printer->vtbl->addr_field(printer, "tex_state_addr", packed0 >> 4 << 4);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_param1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "output_32", packed0 & 1);
   printer->vtbl->boolean_field(printer, "unnorm", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "pix_mask", packed0 >> 2 & 1);
   printer->vtbl->addr_field(printer, "sampler_addr", packed0 >> 3 << 3);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_TEX_WRITE
void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "tmuoff_4x", packed0 & 1);
   printer->vtbl->boolean_field(printer, "bslod", packed0 >> 1 & 1);
   printer->vtbl->field(printer, "coeff_sample", "%" PRIu32 "", packed0 >> 2 & 3);
   printer->vtbl->boolean_field(printer, "coefficient", packed0 >> 4 & 1);
   printer->vtbl->field(printer, "gather_comp", "%" PRIu32 "", packed0 >> 5 & 3);
   printer->vtbl->boolean_field(printer, "gather", packed0 >> 7 & 1);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "offsets", false);
   printer->vtbl->field(printer, "0", "%" PRId32 "",
      gfx_sext(packed0 >> 8 & 15, 4));
   printer->vtbl->field(printer, "1", "%" PRId32 "",
      gfx_sext(packed0 >> 12 & 15, 4));
   printer->vtbl->field(printer, "2", "%" PRId32 "",
      gfx_sext(packed0 >> 16 & 15, 4));
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_TEX_WRITE
void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "tmuoff_4x", packed0 & 1);
   printer->vtbl->boolean_field(printer, "bslod", packed0 >> 1 & 1);
   printer->vtbl->field(printer, "coeff_sample", "%" PRIu32 "", packed0 >> 2 & 3);
   printer->vtbl->boolean_field(printer, "coefficient", packed0 >> 4 & 1);
   printer->vtbl->field(printer, "gather_comp", "%" PRIu32 "", packed0 >> 5 & 3);
   printer->vtbl->boolean_field(printer, "gather", packed0 >> 7 & 1);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "offsets", false);
   printer->vtbl->field(printer, "0", "%" PRId32 "",
      gfx_sext(packed0 >> 8 & 15, 4));
   printer->vtbl->field(printer, "1", "%" PRId32 "",
      gfx_sext(packed0 >> 12 & 15, 4));
   printer->vtbl->field(printer, "2", "%" PRId32 "",
      gfx_sext(packed0 >> 16 & 15, 4));
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "op", "%s",
      v3d_desc_tmu_op((v3d_tmu_op_t)(packed0 >> 20 & 15)));
   printer->vtbl->end(printer);
}
#endif
void v3d_print_tmu_general_config(uint8_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "type", "%s", v3d_desc_tmu_general_type(
      (v3d_tmu_general_type_t)(uint32_t)(packed0 & 7)));
   printer->vtbl->field(printer, "op", "%s", v3d_desc_tmu_op(
      (v3d_tmu_op_t)(uint32_t)(packed0 >> 3 & 15)));
   printer->vtbl->boolean_field(printer, "per_pixel_enable",
      (uint32_t)(packed0 >> 7));
   printer->vtbl->end(printer);
}
void v3d_print_tsy_config(uint8_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "op", "%s",
      v3d_desc_tsy_op((v3d_tsy_op_t)(uint32_t)(packed0 & 31)));
   printer->vtbl->field(printer, "gfxh_1370_do_not_change", "%" PRIu32 "",
      (uint32_t)(packed0 >> 5));
   printer->vtbl->end(printer);
}
void v3d_print_tlb_config(uint8_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed0 >> 6) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "color_f16", false);
      printer->vtbl->field(printer, "num_words", "%" PRIu32 "",
         (uint32_t)(packed0 & 1) + 1);
      printer->vtbl->boolean_field(printer, "no_swap", (uint32_t)(packed0 >> 1 & 1));
      printer->vtbl->boolean_field(printer, "all_samples_same_data",
         (uint32_t)(packed0 >> 2 & 1));
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_mask(3) - (uint32_t)(packed0 >> 3 & 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed0 >> 7) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "color_32", false);
      printer->vtbl->field(printer, "num_words", "%" PRIu32 "",
         (uint32_t)(packed0 & 3) + 1);
      printer->vtbl->boolean_field(printer, "all_samples_same_data",
         (uint32_t)(packed0 >> 2 & 1));
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_mask(3) - (uint32_t)(packed0 >> 3 & 7));
      printer->vtbl->boolean_field(printer, "as_int", (uint32_t)(packed0 >> 6 & 1));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed0 >> 4) == 8)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "z", false);
      printer->vtbl->boolean_field(printer, "use_written_z",
         (uint32_t)(packed0 >> 2 & 1));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed0 >> 4) == 9)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "alpha_mask", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_unif_branch(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "bcond", "%s",
      v3d_desc_qpu_bcond((v3d_qpu_bcond_t)(packed0 & 7)));
   printer->vtbl->field(printer, "msfign", "%s",
      v3d_desc_qpu_msfign((v3d_qpu_msfign_t)(packed0 >> 7 & 3)));
   printer->vtbl->boolean_field(printer, "ulr", packed0 >> 9 & 1);
   printer->vtbl->field(printer, "rel_i_addr", "%" PRId32 "",
      gfx_sext(packed0 >> 10 & 0x7ff, 11) << 3);
   printer->vtbl->field(printer, "rel_u_addr", "%" PRId32 "",
      gfx_sext(packed0 >> 21, 11) << 2);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_indirect(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "filter", "%s",
      v3d_desc_tmu_filter((v3d_tmu_filter_t)(packed[0] & 15)));
   printer->vtbl->boolean_field(printer, "border_rrra", packed[0] >> 5 & 1);
   printer->vtbl->addr_field(printer, "base", packed[0] >> 6 << 6);
   printer->vtbl->field(printer, "arr_str", "%" PRIu32 "",
      (packed[1] & 0x3ffffff) << 6);
   printer->vtbl->field(printer, "width", "%" PRIu32 "", gfx_unpack_uint_0_is_max(
      packed[1] >> 26 | (packed[2] & 255) << 6, 14));
   printer->vtbl->field(printer, "height", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed[2] >> 8 & 0x3fff, 14));
   printer->vtbl->field(printer, "depth", "%" PRIu32 "", gfx_unpack_uint_0_is_max(
      packed[2] >> 22 | (packed[3] & 15) << 10, 14));
   printer->vtbl->field(printer, "ttype", "%s",
      v3d_desc_tmu_type((v3d_tmu_type_t)(packed[3] >> 4 & 127)));
   printer->vtbl->boolean_field(printer, "srgb", packed[3] >> 11 & 1);
   printer->vtbl->boolean_field(printer, "ahdr", packed[3] >> 12 & 1);
   printer->vtbl->field(printer, "compare_func", "%s", v3d_desc_compare_func(
      (v3d_compare_func_t)(packed[3] >> 13 & 7)));
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "swizzles", false);
   printer->vtbl->field(printer, "0", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(packed[3] >> 16 & 7)));
   printer->vtbl->field(printer, "1", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(packed[3] >> 19 & 7)));
   printer->vtbl->field(printer, "2", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(packed[3] >> 22 & 7)));
   printer->vtbl->field(printer, "3", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(packed[3] >> 25 & 7)));
   printer->vtbl->end(printer);
   printer->vtbl->boolean_field(printer, "flipx", packed[3] >> 28 & 1);
   printer->vtbl->boolean_field(printer, "flipy", packed[3] >> 29 & 1);
   printer->vtbl->boolean_field(printer, "etcflip", packed[3] >> 30 & 1);
   printer->vtbl->field(printer, "bcolour", "%" PRIu64 "",
      (uint64_t)packed[4] | (uint64_t)packed[5] << 32);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", false);
   if (true)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "not_child_image", false);
      printer->vtbl->field(printer, "min_lod", "%" PRId32 "",
         gfx_sext(packed[6] & 0xffff, 16));
      printer->vtbl->field(printer, "max_lod", "%" PRId32 "",
         gfx_sext(packed[6] >> 16, 16));
      printer->vtbl->field(printer, "fixed_bias", "%" PRId32 "",
         gfx_sext(packed[7] & 0xffff, 16));
      printer->vtbl->field(printer, "base_level", "%" PRIu32 "", packed[7] >> 16 & 15);
      printer->vtbl->field(printer, "samp_num", "%" PRIu32 "", packed[7] >> 20 & 3);
      printer->vtbl->field(printer, "output_type", "%s", v3d_desc_tmu_output_type(
         (v3d_tmu_output_type_t)(packed[7] >> 22 & 3)));
      printer->vtbl->end(printer);
   }
   else if (true)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "child_image", false);
      printer->vtbl->field(printer, "cwidth", "%" PRIu32 "", packed[6] & 0x3fff);
      printer->vtbl->field(printer, "cheight", "%" PRIu32 "",
         packed[6] >> 14 & 0x3fff);
      printer->vtbl->field(printer, "cxoff", "%" PRIu32 "",
         packed[6] >> 28 | (packed[7] & 0x3ff) << 4);
      printer->vtbl->field(printer, "cyoff", "%" PRIu32 "", packed[7] >> 10 & 0x3fff);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "ub_pad", "%" PRIu32 "", packed[7] >> 24 & 15);
   printer->vtbl->boolean_field(printer, "ub_xor", packed[7] >> 28 & 1);
   printer->vtbl->boolean_field(printer, "uif_top", packed[7] >> 30 & 1);
   printer->vtbl->boolean_field(printer, "xor_dis", packed[7] >> 31);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_tex_state(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "flipx", (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "flipy", (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "srgb", (uint32_t)(packed[0] >> 3 & 1));
   printer->vtbl->boolean_field(printer, "ahdr", (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "reverse_std_bcol",
      (uint32_t)(packed[0] >> 5 & 1));
   printer->vtbl->addr_field(printer, "l0_addr",
      ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6);
   printer->vtbl->field(printer, "arr_str", "%" PRIu32 "",
      ((uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)(packed[7] & 3) << 24) << 6);
   printer->vtbl->field(printer, "width", "%" PRIu32 "", gfx_unpack_uint_0_is_max(
      (uint32_t)(packed[7] >> 2) | (uint32_t)packed[8] << 6, 14));
   printer->vtbl->field(printer, "height", "%" PRIu32 "", gfx_unpack_uint_0_is_max(
      (uint32_t)packed[9] | (uint32_t)(packed[10] & 63) << 8, 14));
   printer->vtbl->field(printer, "depth", "%" PRIu32 "", gfx_unpack_uint_0_is_max(
      (uint32_t)(packed[10] >> 6) | (uint32_t)packed[11] << 2 |
      (uint32_t)(packed[12] & 15) << 10, 14));
   printer->vtbl->field(printer, "type", "%s", v3d_desc_tmu_type(
      (v3d_tmu_type_t)((uint32_t)(packed[12] >> 4) |
      (uint32_t)(packed[13] & 7) << 4)));
   printer->vtbl->boolean_field(printer, "extended",
      (uint32_t)(packed[13] >> 3 & 1));
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "swizzles", false);
   printer->vtbl->field(printer, "0", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(uint32_t)(packed[13] >> 4 & 7)));
   printer->vtbl->field(printer, "1", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)((uint32_t)(packed[13] >> 7) |
      (uint32_t)(packed[14] & 3) << 1)));
   printer->vtbl->field(printer, "2", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(uint32_t)(packed[14] >> 2 & 7)));
   printer->vtbl->field(printer, "3", "%s", v3d_desc_tmu_swizzle(
      (v3d_tmu_swizzle_t)(uint32_t)(packed[14] >> 5)));
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "max_level", "%" PRIu32 "",
      (uint32_t)(packed[15] & 15));
   printer->vtbl->field(printer, "base_level", "%" PRIu32 "",
      (uint32_t)(packed[15] >> 4));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG
void v3d_print_tmu_tex_extension(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "ub_pad", "%" PRIu32 "",
      (uint32_t)(packed[0] & 15));
   printer->vtbl->boolean_field(printer, "ub_xor", (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "uif_top", (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "xor_dis", (uint32_t)(packed[0] >> 7));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && !V3D_HAS_TMU_WRAP_I
void v3d_print_tmu_sampler(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "filter", "%s", v3d_desc_tmu_filter(
      (v3d_tmu_filter_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "compare_func", "%s", v3d_desc_compare_func(
      (v3d_compare_func_t)(uint32_t)(packed[0] >> 4 & 7)));
   printer->vtbl->boolean_field(printer, "srgb_override",
      (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "min_lod", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)(packed[2] & 15) << 8);
   printer->vtbl->field(printer, "max_lod", "%" PRIu32 "",
      (uint32_t)(packed[2] >> 4) | (uint32_t)packed[3] << 4);
   printer->vtbl->field(printer, "fixed_bias", "%" PRId32 "", gfx_sext(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 16));
   printer->vtbl->field(printer, "wrap_s", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)(uint32_t)(packed[6] & 7)));
   printer->vtbl->field(printer, "wrap_t", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)(uint32_t)(packed[6] >> 3 & 7)));
   printer->vtbl->field(printer, "wrap_r", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)((uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 1) << 2)));
   printer->vtbl->field(printer, "std_bcol", "%s", v3d_desc_tmu_std_bcol(
      (v3d_tmu_std_bcol_t)(uint32_t)(packed[7] >> 1 & 7)));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TMU_CFG && V3D_HAS_TMU_WRAP_I
void v3d_print_tmu_sampler(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "filter", "%s", v3d_desc_tmu_filter(
      (v3d_tmu_filter_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "compare_func", "%s", v3d_desc_compare_func(
      (v3d_compare_func_t)(uint32_t)(packed[0] >> 4 & 7)));
   printer->vtbl->boolean_field(printer, "srgb_override",
      (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "min_lod", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)(packed[2] & 15) << 8);
   printer->vtbl->field(printer, "max_lod", "%" PRIu32 "",
      (uint32_t)(packed[2] >> 4) | (uint32_t)packed[3] << 4);
   printer->vtbl->field(printer, "fixed_bias", "%" PRId32 "", gfx_sext(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 16));
   printer->vtbl->field(printer, "wrap_s", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)(uint32_t)(packed[6] & 7)));
   printer->vtbl->field(printer, "wrap_t", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)(uint32_t)(packed[6] >> 3 & 7)));
   printer->vtbl->field(printer, "wrap_r", "%s", v3d_desc_tmu_wrap(
      (v3d_tmu_wrap_t)((uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 1) << 2)));
   printer->vtbl->field(printer, "wrap_i", "%s", v3d_desc_tmu_wrap_i(
      (v3d_tmu_wrap_i_t)(uint32_t)(packed[7] >> 1 & 1)));
   printer->vtbl->field(printer, "std_bcol", "%s", v3d_desc_tmu_std_bcol(
      (v3d_tmu_std_bcol_t)(uint32_t)(packed[7] >> 2 & 7)));
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_print_tf_spec(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "first", "%" PRIu32 "", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "count", "%" PRIu32 "",
      (uint32_t)(packed[1] & 15) + 1);
   printer->vtbl->field(printer, "buffer", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 4 & 3));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_print_tf_spec(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "first", "%" PRIu32 "", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "count", "%" PRIu32 "",
      (uint32_t)(packed[1] & 15) + 1);
   printer->vtbl->field(printer, "buffer", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 4 & 3));
   printer->vtbl->field(printer, "stream", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 6));
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TILE_STATE
void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "cl_pos", packed[0]);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_indices", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[1]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[3]);
   printer->vtbl->end(printer);
   printer->vtbl->boolean_field(printer, "curr_xy_mode", packed[4] & 1);
   printer->vtbl->boolean_field(printer, "prev_reverse_flag", packed[4] >> 1 & 1);
   printer->vtbl->field(printer, "ctr", "%" PRIu32 "", packed[4] >> 2 & 0x7fff);
   printer->vtbl->field(printer, "blksize", "%s", v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(packed[4] >> 17 & 3)));
   printer->vtbl->boolean_field(printer, "halfwrt", packed[4] >> 19 & 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TILE_STATE && !V3D_HAS_INLINE_CLIP
void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "cl_pos", packed[0]);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_indices", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[1]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[3]);
   printer->vtbl->end(printer);
   printer->vtbl->boolean_field(printer, "curr_xy_mode", packed[4] & 1);
   printer->vtbl->boolean_field(printer, "prev_reverse_flag", packed[4] >> 1 & 1);
   printer->vtbl->field(printer, "ctr", "%" PRIu32 "", packed[4] >> 2 & 0xffffff);
   printer->vtbl->field(printer, "blksize", "%s", v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(packed[4] >> 26 & 3)));
   printer->vtbl->boolean_field(printer, "halfwrt", packed[4] >> 28 & 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_INLINE_CLIP && !V3D_HAS_TNG
void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "cl_pos", packed[0]);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_indices", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[1]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[3]);
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "prev_prim_id", "%" PRIu32 "", packed[4]);
   printer->vtbl->boolean_field(printer, "curr_xy_mode", packed[5] & 1);
   printer->vtbl->boolean_field(printer, "prev_reverse_flag", packed[5] >> 1 & 1);
   printer->vtbl->field(printer, "ctr", "%" PRIu32 "", packed[5] >> 2 & 0xffffff);
   printer->vtbl->field(printer, "blksize", "%s", v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(packed[5] >> 26 & 3)));
   printer->vtbl->boolean_field(printer, "halfwrt", packed[5] >> 28 & 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TNG && !V3D_HAS_TL_START_UNC
void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "cl_pos", packed[0]);
   printer->vtbl->addr_field(printer, "sn_pos", packed[1]);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_indices", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[3]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_serials", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[5]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[6]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[7]);
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "prev_prim_id", "%" PRIu32 "", packed[8]);
   printer->vtbl->boolean_field(printer, "curr_xy_mode", packed[9] & 1);
   printer->vtbl->boolean_field(printer, "in_generic_ind_list", packed[9] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "prev_reverse_flag", packed[9] >> 2 & 1);
   printer->vtbl->field(printer, "ctr", "%" PRIu32 "", packed[9] >> 3 & 0xffffff);
   printer->vtbl->field(printer, "blksize", "%s", v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(packed[9] >> 27 & 3)));
   printer->vtbl->boolean_field(printer, "halfwrt", packed[9] >> 29 & 1);
   printer->vtbl->field(printer, "deferred_sn", "%" PRIu32 "",
      packed[9] >> 30 | (packed[10] & 0x3fffff) << 2);
   printer->vtbl->field(printer, "cur_sn_level", "%" PRIu32 "",
      packed[10] >> 22 & 3);
   printer->vtbl->boolean_field(printer, "tg_tess", packed[10] >> 24 & 1);
   printer->vtbl->boolean_field(printer, "tg_geom", packed[10] >> 25 & 1);
   printer->vtbl->boolean_field(printer, "tg_geom_inst", packed[10] >> 26 & 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TL_START_UNC
void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "cl_pos", packed[0]);
   printer->vtbl->addr_field(printer, "sn_pos", packed[1]);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_indices", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[3]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[4]);
   printer->vtbl->end(printer);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "prev_serials", false);
   printer->vtbl->field(printer, "0", "%" PRIu32 "", packed[5]);
   printer->vtbl->field(printer, "1", "%" PRIu32 "", packed[6]);
   printer->vtbl->field(printer, "2", "%" PRIu32 "", packed[7]);
   printer->vtbl->end(printer);
   printer->vtbl->field(printer, "prev_prim_id", "%" PRIu32 "", packed[8]);
   printer->vtbl->boolean_field(printer, "curr_xy_mode", packed[9] & 1);
   printer->vtbl->boolean_field(printer, "in_generic_ind_list", packed[9] >> 1 & 1);
   printer->vtbl->boolean_field(printer, "in_prim_list", packed[9] >> 2 & 1);
   printer->vtbl->boolean_field(printer, "prev_reverse_flag", packed[9] >> 3 & 1);
   printer->vtbl->field(printer, "ctr", "%" PRIu32 "", packed[9] >> 4 & 0xffffff);
   printer->vtbl->field(printer, "blksize", "%s", v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(packed[9] >> 28 & 3)));
   printer->vtbl->boolean_field(printer, "halfwrt", packed[9] >> 30 & 1);
   printer->vtbl->field(printer, "deferred_sn", "%" PRIu32 "",
      packed[9] >> 31 | (packed[10] & 0x7fffff) << 1);
   printer->vtbl->field(printer, "cur_sn_level", "%" PRIu32 "",
      packed[10] >> 23 & 3);
   printer->vtbl->boolean_field(printer, "tg_tess", packed[10] >> 25 & 1);
   printer->vtbl->boolean_field(printer, "tg_geom", packed[10] >> 26 & 1);
   printer->vtbl->boolean_field(printer, "tg_geom_inst", packed[10] >> 27 & 1);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_indirect_indexed_record(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_indices", "%" PRIu32 "", packed[0]);
   printer->vtbl->field(printer, "num_instances", "%" PRIu32 "", packed[1]);
   printer->vtbl->field(printer, "index_of_first_index", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "base_vertex", "%" PRId32 "", (int32_t)packed[3]);
   printer->vtbl->field(printer, "base_instance", "%" PRIu32 "", packed[4]);
   printer->vtbl->end(printer);
}
void v3d_print_indirect_arrays_record(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_vertices", "%" PRIu32 "", packed[0]);
   printer->vtbl->field(printer, "num_instances", "%" PRIu32 "", packed[1]);
   printer->vtbl->field(printer, "first_index", "%" PRIu32 "", packed[2]);
   printer->vtbl->field(printer, "base_instance", "%" PRIu32 "", packed[3]);
   printer->vtbl->end(printer);
}
void v3d_print_clip_record(const uint32_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "xs", "%" PRId32 "", (int32_t)packed[0]);
   printer->vtbl->field(printer, "ys", "%" PRId32 "", (int32_t)packed[1]);
   printer->vtbl->field(printer, "zs", "%.9g", gfx_float_from_bits(packed[2]));
   printer->vtbl->field(printer, "rw", "%.9g", gfx_float_from_bits(packed[3]));
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "vcoeff", false);
   printer->vtbl->field(printer, "0", "%.9g", gfx_float_from_bits(packed[4]));
   printer->vtbl->field(printer, "1", "%.9g", gfx_float_from_bits(packed[5]));
   printer->vtbl->field(printer, "2", "%.9g", gfx_float_from_bits(packed[6]));
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_autochain_link(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "next_block_size", "%s",
      v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3)));
   printer->vtbl->boolean_field(printer, "more", (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->addr_field(printer, "next_block_addr",
      ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_INLINE_CLIP
void v3d_print_cl_compr_ind_common(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)packed[0] == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid8", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "", (uint32_t)packed[1]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 35)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid32", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 19)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "rel_branch", false);
      printer->vtbl->field(printer, "rel_addr", "%" PRId32 "", gfx_sext(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 16) << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 195)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "branch", false);
      printer->vtbl->addr_field(printer, "addr",
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 227)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "escape", false);
      printer->vtbl->end(printer);
   }
   else if (true)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "not_common", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_INLINE_CLIP
void v3d_print_cl_compr_ind_common(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)packed[0] == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid8", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "", (uint32_t)packed[1]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 35)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid32", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 19)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "prim_id8", false);
      printer->vtbl->field(printer, "rel_id", "%" PRIu32 "", (uint32_t)packed[1]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 195)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "prim_id32", false);
      printer->vtbl->field(printer, "id", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clipped_prim", false);
      printer->vtbl->boolean_field(printer, "is_first",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "clip_vert", false);
      printer->vtbl->boolean_field(printer, "0", (uint32_t)(packed[1] & 1));
      printer->vtbl->boolean_field(printer, "1", (uint32_t)(packed[1] >> 1 & 1));
      printer->vtbl->boolean_field(printer, "2", (uint32_t)(packed[1] >> 2 & 1));
      printer->vtbl->end(printer);
      printer->vtbl->boolean_field(printer, "flat_zw", (uint32_t)(packed[1] >> 3 & 1));
      printer->vtbl->addr_field(printer, "addr",
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 227)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "escape", false);
      printer->vtbl->end(printer);
   }
   else if (true)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "not_common", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TNG
void v3d_print_cl_compr_serial(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->boolean_field(printer, "is_last", (uint32_t)(packed[0] >> 1 & 1));
      printer->vtbl->field(printer, "rel_value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 2));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->boolean_field(printer, "is_last", (uint32_t)(packed[0] >> 2 & 1));
      printer->vtbl->field(printer, "rel_value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 3) | (uint32_t)packed[1] << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 7) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "count", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 3));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->boolean_field(printer, "is_last", (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
         (uint32_t)packed[2] << 11);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15 && (uint32_t)(packed[0] >> 5) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clipped_prim", false);
      printer->vtbl->boolean_field(printer, "is_first",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "clip_vert", false);
      printer->vtbl->boolean_field(printer, "0", (uint32_t)(packed[1] & 1));
      printer->vtbl->boolean_field(printer, "1", (uint32_t)(packed[1] >> 1 & 1));
      printer->vtbl->boolean_field(printer, "2", (uint32_t)(packed[1] >> 2 & 1));
      printer->vtbl->end(printer);
      printer->vtbl->boolean_field(printer, "flat_zw", (uint32_t)(packed[1] >> 3 & 1));
      printer->vtbl->addr_field(printer, "addr",
         ((uint32_t)(packed[1] >> 5) | (uint32_t)packed[2] << 3 |
         (uint32_t)packed[3] << 11 | (uint32_t)packed[4] << 19) << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 47)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "tg_mode", false);
      printer->vtbl->boolean_field(printer, "tess", (uint32_t)(packed[1] & 1));
      printer->vtbl->boolean_field(printer, "geom", (uint32_t)(packed[1] >> 1 & 1));
      printer->vtbl->boolean_field(printer, "geom_iid",
         (uint32_t)(packed[1] >> 2 & 1));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15 && (uint32_t)(packed[0] >> 4) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "end_level", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TNG && V3D_HAS_INLINE_CLIP
void v3d_print_cl_compr_ind_generic(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "diff", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 1), 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "diff", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6, 14));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 7) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 3));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 4) | (uint32_t)packed[1] << 4);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 31) == 15)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c4", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
         (uint32_t)packed[2] << 11);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 31)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c5", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 63)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c6", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 95)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid8", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "", (uint32_t)packed[1]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 127)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "iid32", false);
      printer->vtbl->field(printer, "iid", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 159)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "prim_id8", false);
      printer->vtbl->field(printer, "diff", "%" PRIu32 "", (uint32_t)packed[1]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 191)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "prim_id32", false);
      printer->vtbl->field(printer, "value", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 255)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "escape", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_cl_compr_ind_tri(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2), 6));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "diff0", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 4), 4));
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] & 15), 4));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 4), 4));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 11)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "diff1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 2), 6));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->field(printer, "diff1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 2), 6));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 131)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c4", false);
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 163)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c5", false);
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[7] | (uint32_t)packed[8] << 8 | (uint32_t)packed[9] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 67)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c6", false);
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
         (uint32_t)packed[8] << 24);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
         (uint32_t)packed[12] << 24);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_cl_compr_ind_d3dpvsf_tri(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2 & 31), 5));
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "diff0", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 4 & 7), 3));
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 7));
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] & 15), 4));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 4), 4));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 11)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "diff1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 2), 6));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[2] | (uint32_t)(packed[3] & 127) << 8);
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[3] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->field(printer, "diff1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 3) << 4, 6));
      printer->vtbl->field(printer, "diff2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 2), 6));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 |
         (uint32_t)(packed[4] & 127) << 16);
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[4] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c4", false);
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c5", false);
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[7] | (uint32_t)packed[8] << 8 | (uint32_t)packed[9] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c6", false);
      printer->vtbl->field(printer, "prov_vtx", "%" PRIu32 "",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
         (uint32_t)packed[8] << 24);
      printer->vtbl->field(printer, "idx2", "%" PRIu32 "",
         (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
         (uint32_t)packed[12] << 24);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_cl_compr_ind_line(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (v3d_is_valid_line_ind_reuse((v3d_line_ind_reuse_t)(uint32_t)(packed[0] & 3)))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_line_ind_reuse(
         (v3d_line_ind_reuse_t)(uint32_t)(packed[0] & 3)));
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2), 6));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 7)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "diff0", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 4), 4));
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] & 15), 4));
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[1] >> 4 & 1));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2), 6));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && (uint32_t)(packed[0] >> 3 & 1) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 2 & 1));
      printer->vtbl->field(printer, "diff1", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 4), 4));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c4", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c5", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c6", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->field(printer, "idx1", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
         (uint32_t)packed[8] << 24);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_cl_compr_ind_point(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 3) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "diff", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2), 6));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "diff", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 127) << 6, 13));
      printer->vtbl->boolean_field(printer, "reversed", (uint32_t)(packed[1] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "diff", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[0] >> 2), 6));
      printer->vtbl->field(printer, "count", "%" PRIu32 "",
         (uint32_t)(packed[1] & 127) + 1);
      printer->vtbl->boolean_field(printer, "reversed", (uint32_t)(packed[1] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 4)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c4", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 5)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c5", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3 && (uint32_t)(packed[0] >> 5) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c6", false);
      printer->vtbl->boolean_field(printer, "reversed",
         (uint32_t)(packed[0] >> 4 & 1));
      printer->vtbl->field(printer, "idx", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#if V3D_HAS_INLINE_CLIP
void v3d_print_cl_compr_xy_tri(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)) &&
      -62 <= gfx_sext(gfx_rol(
      (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(gfx_rol(
         (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 1), 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && v3d_is_valid_tri_ind_reuse(
      (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 63) << 4, 10));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[1] >> 6) | (uint32_t)packed[2] << 2, 10));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "dx1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 7) << 4, 7));
      printer->vtbl->field(printer, "dy1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[1] >> 3) | (uint32_t)(packed[2] & 3) << 5, 7));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[2] >> 2) | (uint32_t)(packed[3] & 1) << 6, 7));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[3] >> 1), 7));
      printer->vtbl->field(printer, "x0", "%" PRIu32 "",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8);
      printer->vtbl->field(printer, "y0", "%" PRIu32 "",
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 129)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->field(printer, "x0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "y0", "%" PRIu32 "",
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8);
      printer->vtbl->field(printer, "x1", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8);
      printer->vtbl->field(printer, "y1", "%" PRIu32 "",
         (uint32_t)packed[7] | (uint32_t)packed[8] << 8);
      printer->vtbl->field(printer, "x2", "%" PRIu32 "",
         (uint32_t)packed[9] | (uint32_t)packed[10] << 8);
      printer->vtbl->field(printer, "y2", "%" PRIu32 "",
         (uint32_t)packed[11] | (uint32_t)packed[12] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 128)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "escape", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_INLINE_CLIP
void v3d_print_cl_compr_xy_tri(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (v3d_is_valid_tri_ind_reuse((v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)) &&
      -62 <= gfx_sext(gfx_rol(
      (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c0", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] & 3)));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(gfx_rol(
         (uint32_t)(packed[0] >> 2) | (uint32_t)(packed[1] & 1) << 6, 1, 7), 7));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[1] >> 1), 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 3) == 3 && v3d_is_valid_tri_ind_reuse(
      (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)))
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c1", false);
      printer->vtbl->field(printer, "reuse", "%s", v3d_desc_tri_ind_reuse(
         (v3d_tri_ind_reuse_t)(uint32_t)(packed[0] >> 2 & 3)));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 63) << 4, 10));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[1] >> 6) | (uint32_t)packed[2] << 2, 10));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 15)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c2", false);
      printer->vtbl->field(printer, "dx1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[0] >> 4) | (uint32_t)(packed[1] & 7) << 4, 7));
      printer->vtbl->field(printer, "dy1", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[1] >> 3) | (uint32_t)(packed[2] & 3) << 5, 7));
      printer->vtbl->field(printer, "dx2", "%" PRId32 "", gfx_sext(
         (uint32_t)(packed[2] >> 2) | (uint32_t)(packed[3] & 1) << 6, 7));
      printer->vtbl->field(printer, "dy2", "%" PRId32 "",
         gfx_sext((uint32_t)(packed[3] >> 1), 7));
      printer->vtbl->field(printer, "x0", "%" PRIu32 "",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8);
      printer->vtbl->field(printer, "y0", "%" PRIu32 "",
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 129)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "c3", false);
      printer->vtbl->field(printer, "x0", "%" PRIu32 "",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "y0", "%" PRIu32 "",
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8);
      printer->vtbl->field(printer, "x1", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8);
      printer->vtbl->field(printer, "y1", "%" PRIu32 "",
         (uint32_t)packed[7] | (uint32_t)packed[8] << 8);
      printer->vtbl->field(printer, "x2", "%" PRIu32 "",
         (uint32_t)packed[9] | (uint32_t)packed[10] << 8);
      printer->vtbl->field(printer, "y2", "%" PRIu32 "",
         (uint32_t)packed[11] | (uint32_t)packed[12] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 130)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "rel_branch", false);
      printer->vtbl->field(printer, "rel_addr", "%" PRId32 "", gfx_sext(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 16) << 5);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)packed[0] == 128)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "escape", false);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TNG
void v3d_print_gs_vpm_fmt(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "start_prim", packed0 & 1);
   printer->vtbl->field(printer, "stream_idx", "%" PRIu32 "", packed0 >> 1 & 3);
   printer->vtbl->field(printer, "length", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->field(printer, "layer_idx", "%" PRIu32 "", packed0 >> 16 & 255);
   printer->vtbl->field(printer, "viewport_idx", "%" PRIu32 "", packed0 >> 24 & 15);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_bstc_block(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if (((uint32_t)(packed[23] >> 4 & 1) == 0 ||
      (uint32_t)(packed[23] >> 4 & 1) == 1) &&
      (((uint32_t)(packed[3] >> 6 & 1) == 0 ||
      (uint32_t)(packed[3] >> 6 & 1) == 1) && ((uint32_t)(packed[9] >> 5 & 1) == 0 ||
      (uint32_t)(packed[9] >> 5 & 1) == 1)) && (uint32_t)(packed[3] >> 7) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "three_plane", false);
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "rg", false);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "0", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[3] >> 6 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min", "%" PRIu32 "",
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 63) << 2);
         printer->vtbl->field(printer, "max", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 63) << 2);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 2 & 15));
         printer->vtbl->field(printer, "1", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 2 & 15));
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 6) | (uint32_t)(packed[0] & 3) << 2);
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 2 & 15));
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 3) << 2);
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 2 & 15));
         printer->vtbl->field(printer, "7", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 6) | (uint32_t)(packed[6] & 3) << 2);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 2 & 15));
         printer->vtbl->field(printer, "9", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 6) | (uint32_t)(packed[5] & 3) << 2);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 2 & 15));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 3) << 2);
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 2 & 15));
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[10] >> 6) | (uint32_t)(packed[11] & 3) << 2);
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[10] >> 2 & 15));
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[9] >> 6) |
            (uint32_t)(packed[10] & 3) << 2);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[3] >> 6 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[3] >> 1 & 31));
         printer->vtbl->field(printer, "1", "%" PRIu32 "",
            (uint32_t)(packed[2] >> 4) | (uint32_t)(packed[3] & 1) << 4);
         printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[1] >> 7) |
            (uint32_t)(packed[2] & 15) << 1);
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 2 & 31));
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 5) | (uint32_t)(packed[1] & 3) << 3);
         printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[0] & 31));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[7] >> 3));
         printer->vtbl->field(printer, "7", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 7) << 2);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 1 & 31));
         printer->vtbl->field(printer, "9", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 4) | (uint32_t)(packed[6] & 1) << 4);
         printer->vtbl->field(printer, "10", "%" PRIu32 "", (uint32_t)(packed[4] >> 7) |
            (uint32_t)(packed[5] & 15) << 1);
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 2 & 31));
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 5) | (uint32_t)(packed[4] & 3) << 3);
         printer->vtbl->field(printer, "13", "%" PRIu32 "", (uint32_t)(packed[11] & 31));
         printer->vtbl->field(printer, "14", "%" PRIu32 "", (uint32_t)(packed[10] >> 3));
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[9] >> 6) |
            (uint32_t)(packed[10] & 7) << 2);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "1", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[9] >> 5 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 5) | (uint32_t)(packed[9] & 31) << 3);
         printer->vtbl->field(printer, "max", "%" PRIu32 "",
            (uint32_t)(packed[15] >> 5) | (uint32_t)(packed[8] & 31) << 3);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[15] >> 1 & 15));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[14] >> 5) |
            (uint32_t)(packed[15] & 1) << 3);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[14] >> 1 & 15));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[13] >> 5) |
            (uint32_t)(packed[14] & 1) << 3);
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 1 & 15));
         printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[12] >> 5) |
            (uint32_t)(packed[13] & 1) << 3);
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[12] >> 1 & 15));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[19] >> 5) |
            (uint32_t)(packed[12] & 1) << 3);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[19] >> 1 & 15));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[18] >> 5) |
            (uint32_t)(packed[19] & 1) << 3);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[18] >> 1 & 15));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[17] >> 5) | (uint32_t)(packed[18] & 1) << 3);
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[17] >> 1 & 15));
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[16] >> 5) | (uint32_t)(packed[17] & 1) << 3);
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[16] >> 1 & 15));
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[23] >> 5) | (uint32_t)(packed[16] & 1) << 3);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[9] >> 5 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "", (uint32_t)(packed[9] & 31));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[8] >> 3));
         printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[15] >> 6) |
            (uint32_t)(packed[8] & 7) << 2);
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[15] >> 1 & 31));
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[14] >> 4) |
            (uint32_t)(packed[15] & 1) << 4);
         printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[13] >> 7) |
            (uint32_t)(packed[14] & 15) << 1);
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 2 & 31));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[12] >> 5) |
            (uint32_t)(packed[13] & 3) << 3);
         printer->vtbl->field(printer, "8", "%" PRIu32 "", (uint32_t)(packed[12] & 31));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[19] >> 3));
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[18] >> 6) | (uint32_t)(packed[19] & 7) << 2);
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[18] >> 1 & 31));
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[17] >> 4) | (uint32_t)(packed[18] & 1) << 4);
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[16] >> 7) | (uint32_t)(packed[17] & 15) << 1);
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[16] >> 2 & 31));
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[23] >> 5) | (uint32_t)(packed[16] & 3) << 3);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "ba", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[23] >> 4 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min_b", "%" PRIu32 "",
            (uint32_t)(packed[22] >> 4) | (uint32_t)(packed[23] & 15) << 4);
         printer->vtbl->field(printer, "max_b", "%" PRIu32 "",
            (uint32_t)(packed[21] >> 4) | (uint32_t)(packed[22] & 15) << 4);
         printer->vtbl->field(printer, "min_a", "%" PRIu32 "",
            (uint32_t)(packed[20] >> 6) | (uint32_t)(packed[21] & 15) << 2);
         printer->vtbl->field(printer, "max_a", "%" PRIu32 "",
            (uint32_t)(packed[20] & 63));
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "", (uint32_t)(packed[27] >> 4));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[27] & 15));
         printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[26] >> 4));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[26] & 15));
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[25] >> 4));
         printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[25] & 15));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[24] >> 4));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[24] & 15));
         printer->vtbl->field(printer, "8", "%" PRIu32 "", (uint32_t)(packed[31] >> 4));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[31] & 15));
         printer->vtbl->field(printer, "10", "%" PRIu32 "", (uint32_t)(packed[30] >> 4));
         printer->vtbl->field(printer, "11", "%" PRIu32 "", (uint32_t)(packed[30] & 15));
         printer->vtbl->field(printer, "12", "%" PRIu32 "", (uint32_t)(packed[29] >> 4));
         printer->vtbl->field(printer, "13", "%" PRIu32 "", (uint32_t)(packed[29] & 15));
         printer->vtbl->field(printer, "14", "%" PRIu32 "", (uint32_t)(packed[28] >> 4));
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[28] & 15));
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[23] >> 4 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->field(printer, "min_a", "%" PRIu32 "",
            (uint32_t)(packed[22] >> 6) | (uint32_t)(packed[23] & 15) << 2);
         printer->vtbl->field(printer, "max_a", "%" PRIu32 "",
            (uint32_t)(packed[22] & 63));
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "", (uint32_t)(packed[21] >> 3));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[20] >> 6) |
            (uint32_t)(packed[21] & 7) << 2);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[20] >> 1 & 31));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[27] >> 4) |
            (uint32_t)(packed[20] & 1) << 4);
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[26] >> 7) |
            (uint32_t)(packed[27] & 15) << 1);
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[26] >> 2 & 31));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[25] >> 5) |
            (uint32_t)(packed[26] & 3) << 3);
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[25] & 31));
         printer->vtbl->field(printer, "8", "%" PRIu32 "", (uint32_t)(packed[24] >> 3));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[31] >> 6) |
            (uint32_t)(packed[24] & 7) << 2);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[31] >> 1 & 31));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[30] >> 4) | (uint32_t)(packed[31] & 1) << 4);
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[29] >> 7) | (uint32_t)(packed[30] & 15) << 1);
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[29] >> 2 & 31));
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[28] >> 5) | (uint32_t)(packed[29] & 3) << 3);
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[28] & 31));
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
   }
   else if (((uint32_t)(packed[3] >> 6 & 1) == 0 || (uint32_t)(packed[3] >> 6 & 1) == 1) &&
      ((uint32_t)(packed[11] >> 5 & 1) == 0 ||
      (uint32_t)(packed[11] >> 5 & 1) == 1) &&
      ((uint32_t)(packed[19] >> 4 & 1) == 0 ||
      (uint32_t)(packed[19] >> 4 & 1) == 1) && (uint32_t)(packed[3] >> 7) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "four_plane", false);
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "rgb", false);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "0", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[3] >> 6 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min", "%" PRIu32 "",
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 63) << 2);
         printer->vtbl->field(printer, "max", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 63) << 2);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 3 & 7));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[1] & 7));
         printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[0] >> 5));
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 2 & 7));
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 7) | (uint32_t)(packed[0] & 3) << 1);
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 4 & 7));
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 1 & 7));
         printer->vtbl->field(printer, "7", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 1) << 2);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 3 & 7));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[6] & 7));
         printer->vtbl->field(printer, "10", "%" PRIu32 "", (uint32_t)(packed[5] >> 5));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 2 & 7));
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 7) | (uint32_t)(packed[5] & 3) << 1);
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 4 & 7));
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 1 & 7));
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 1) << 2);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[3] >> 6 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[3] >> 2 & 15));
         printer->vtbl->field(printer, "1", "%" PRIu32 "",
            (uint32_t)(packed[2] >> 6) | (uint32_t)(packed[3] & 3) << 2);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[2] >> 2 & 15));
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 6) | (uint32_t)(packed[2] & 3) << 2);
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[1] >> 2 & 15));
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2);
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[0] >> 2 & 15));
         printer->vtbl->field(printer, "7", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 6) | (uint32_t)(packed[0] & 3) << 2);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[7] >> 2 & 15));
         printer->vtbl->field(printer, "9", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 6) | (uint32_t)(packed[7] & 3) << 2);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[6] >> 2 & 15));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 6) | (uint32_t)(packed[6] & 3) << 2);
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[5] >> 2 & 15));
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 6) | (uint32_t)(packed[5] & 3) << 2);
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[4] >> 2 & 15));
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 6) | (uint32_t)(packed[4] & 3) << 2);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "1", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[11] >> 5 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min", "%" PRIu32 "",
            (uint32_t)(packed[10] >> 5) | (uint32_t)(packed[11] & 31) << 3);
         printer->vtbl->field(printer, "max", "%" PRIu32 "",
            (uint32_t)(packed[9] >> 5) | (uint32_t)(packed[10] & 31) << 3);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[9] >> 2 & 7));
         printer->vtbl->field(printer, "1", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 7) | (uint32_t)(packed[9] & 3) << 1);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 4 & 7));
         printer->vtbl->field(printer, "3", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 1 & 7));
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[15] >> 6) |
            (uint32_t)(packed[8] & 1) << 2);
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[15] >> 3 & 7));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[15] & 7));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[14] >> 5));
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[14] >> 2 & 7));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[13] >> 7) |
            (uint32_t)(packed[14] & 3) << 1);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 4 & 7));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 1 & 7));
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[12] >> 6) | (uint32_t)(packed[13] & 1) << 2);
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[12] >> 3 & 7));
         printer->vtbl->field(printer, "14", "%" PRIu32 "", (uint32_t)(packed[12] & 7));
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[19] >> 5));
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[11] >> 5 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[11] >> 1 & 15));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[10] >> 5) |
            (uint32_t)(packed[11] & 1) << 3);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[10] >> 1 & 15));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[9] >> 5) |
            (uint32_t)(packed[10] & 1) << 3);
         printer->vtbl->field(printer, "4", "%" PRIu32 "",
            (uint32_t)(packed[9] >> 1 & 15));
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 5) | (uint32_t)(packed[9] & 1) << 3);
         printer->vtbl->field(printer, "6", "%" PRIu32 "",
            (uint32_t)(packed[8] >> 1 & 15));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[15] >> 5) |
            (uint32_t)(packed[8] & 1) << 3);
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[15] >> 1 & 15));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[14] >> 5) |
            (uint32_t)(packed[15] & 1) << 3);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[14] >> 1 & 15));
         printer->vtbl->field(printer, "11", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 5) | (uint32_t)(packed[14] & 1) << 3);
         printer->vtbl->field(printer, "12", "%" PRIu32 "",
            (uint32_t)(packed[13] >> 1 & 15));
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[12] >> 5) | (uint32_t)(packed[13] & 1) << 3);
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[12] >> 1 & 15));
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[19] >> 5) | (uint32_t)(packed[12] & 1) << 3);
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "2", false);
      printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
      if ((uint32_t)(packed[19] >> 4 & 1) == 0)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "normal_range", false);
         printer->vtbl->field(printer, "min", "%" PRIu32 "",
            (uint32_t)(packed[18] >> 4) | (uint32_t)(packed[19] & 15) << 4);
         printer->vtbl->field(printer, "max", "%" PRIu32 "",
            (uint32_t)(packed[17] >> 4) | (uint32_t)(packed[18] & 15) << 4);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "",
            (uint32_t)(packed[17] >> 1 & 7));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[16] >> 6) |
            (uint32_t)(packed[17] & 1) << 2);
         printer->vtbl->field(printer, "2", "%" PRIu32 "",
            (uint32_t)(packed[16] >> 3 & 7));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[16] & 7));
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[23] >> 5));
         printer->vtbl->field(printer, "5", "%" PRIu32 "",
            (uint32_t)(packed[23] >> 2 & 7));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[22] >> 7) |
            (uint32_t)(packed[23] & 3) << 1);
         printer->vtbl->field(printer, "7", "%" PRIu32 "",
            (uint32_t)(packed[22] >> 4 & 7));
         printer->vtbl->field(printer, "8", "%" PRIu32 "",
            (uint32_t)(packed[22] >> 1 & 7));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[21] >> 6) |
            (uint32_t)(packed[22] & 1) << 2);
         printer->vtbl->field(printer, "10", "%" PRIu32 "",
            (uint32_t)(packed[21] >> 3 & 7));
         printer->vtbl->field(printer, "11", "%" PRIu32 "", (uint32_t)(packed[21] & 7));
         printer->vtbl->field(printer, "12", "%" PRIu32 "", (uint32_t)(packed[20] >> 5));
         printer->vtbl->field(printer, "13", "%" PRIu32 "",
            (uint32_t)(packed[20] >> 2 & 7));
         printer->vtbl->field(printer, "14", "%" PRIu32 "",
            (uint32_t)(packed[27] >> 7) | (uint32_t)(packed[20] & 3) << 1);
         printer->vtbl->field(printer, "15", "%" PRIu32 "",
            (uint32_t)(packed[27] >> 4 & 7));
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else if ((uint32_t)(packed[19] >> 4 & 1) == 1)
      {
         printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "max_range", false);
         printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
         printer->vtbl->field(printer, "0", "%" PRIu32 "", (uint32_t)(packed[19] & 15));
         printer->vtbl->field(printer, "1", "%" PRIu32 "", (uint32_t)(packed[18] >> 4));
         printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[18] & 15));
         printer->vtbl->field(printer, "3", "%" PRIu32 "", (uint32_t)(packed[17] >> 4));
         printer->vtbl->field(printer, "4", "%" PRIu32 "", (uint32_t)(packed[17] & 15));
         printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[16] >> 4));
         printer->vtbl->field(printer, "6", "%" PRIu32 "", (uint32_t)(packed[16] & 15));
         printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[23] >> 4));
         printer->vtbl->field(printer, "8", "%" PRIu32 "", (uint32_t)(packed[23] & 15));
         printer->vtbl->field(printer, "9", "%" PRIu32 "", (uint32_t)(packed[22] >> 4));
         printer->vtbl->field(printer, "10", "%" PRIu32 "", (uint32_t)(packed[22] & 15));
         printer->vtbl->field(printer, "11", "%" PRIu32 "", (uint32_t)(packed[21] >> 4));
         printer->vtbl->field(printer, "12", "%" PRIu32 "", (uint32_t)(packed[21] & 15));
         printer->vtbl->field(printer, "13", "%" PRIu32 "", (uint32_t)(packed[20] >> 4));
         printer->vtbl->field(printer, "14", "%" PRIu32 "", (uint32_t)(packed[20] & 15));
         printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[27] >> 4));
         printer->vtbl->end(printer);
         printer->vtbl->end(printer);
      }
      else
      {
         unreachable();
      }
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "a", false);
      printer->vtbl->field(printer, "min", "%" PRIu32 "",
         (uint32_t)(packed[26] >> 6) | (uint32_t)(packed[27] & 15) << 2);
      printer->vtbl->field(printer, "max", "%" PRIu32 "", (uint32_t)(packed[26] & 63));
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "weights", false);
      printer->vtbl->field(printer, "0", "%" PRIu32 "", (uint32_t)(packed[25] >> 5));
      printer->vtbl->field(printer, "1", "%" PRIu32 "",
         (uint32_t)(packed[25] >> 2 & 7));
      printer->vtbl->field(printer, "2", "%" PRIu32 "", (uint32_t)(packed[24] >> 7) |
         (uint32_t)(packed[25] & 3) << 1);
      printer->vtbl->field(printer, "3", "%" PRIu32 "",
         (uint32_t)(packed[24] >> 4 & 7));
      printer->vtbl->field(printer, "4", "%" PRIu32 "",
         (uint32_t)(packed[24] >> 1 & 7));
      printer->vtbl->field(printer, "5", "%" PRIu32 "", (uint32_t)(packed[31] >> 6) |
         (uint32_t)(packed[24] & 1) << 2);
      printer->vtbl->field(printer, "6", "%" PRIu32 "",
         (uint32_t)(packed[31] >> 3 & 7));
      printer->vtbl->field(printer, "7", "%" PRIu32 "", (uint32_t)(packed[31] & 7));
      printer->vtbl->field(printer, "8", "%" PRIu32 "", (uint32_t)(packed[30] >> 5));
      printer->vtbl->field(printer, "9", "%" PRIu32 "",
         (uint32_t)(packed[30] >> 2 & 7));
      printer->vtbl->field(printer, "10", "%" PRIu32 "",
         (uint32_t)(packed[29] >> 7) | (uint32_t)(packed[30] & 3) << 1);
      printer->vtbl->field(printer, "11", "%" PRIu32 "",
         (uint32_t)(packed[29] >> 4 & 7));
      printer->vtbl->field(printer, "12", "%" PRIu32 "",
         (uint32_t)(packed[29] >> 1 & 7));
      printer->vtbl->field(printer, "13", "%" PRIu32 "",
         (uint32_t)(packed[28] >> 6) | (uint32_t)(packed[29] & 1) << 2);
      printer->vtbl->field(printer, "14", "%" PRIu32 "",
         (uint32_t)(packed[28] >> 3 & 7));
      printer->vtbl->field(printer, "15", "%" PRIu32 "", (uint32_t)(packed[28] & 7));
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_hub_ident0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_print_hub_ident1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed0 & 15);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed0 >> 4 & 15);
   printer->vtbl->field(printer, "num_cores", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed0 >> 8 & 15, 4));
   printer->vtbl->field(printer, "num_hosts", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 12 & 15, 1, 15));
   printer->vtbl->boolean_field(printer, "has_l3c", packed0 >> 16 & 1);
   printer->vtbl->boolean_field(printer, "has_tfu", packed0 >> 17 & 1);
   printer->vtbl->boolean_field(printer, "has_tsy", packed0 >> 18 & 1);
   printer->vtbl->boolean_field(printer, "has_mso", packed0 >> 19 & 1);
   printer->vtbl->field(printer, "l3c_associativity", "%" PRIu32 "",
      packed0 >> 20 & 15);
   printer->vtbl->field(printer, "l3c_banks", "%" PRIu32 "", packed0 >> 24 & 15);
   printer->vtbl->end(printer);
}
void v3d_print_hub_ident2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "l3c_size_in_multiples_of_64kb", "%" PRIu32 "",
      packed0 & 255);
   printer->vtbl->boolean_field(printer, "has_mmu", packed0 >> 8 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_hub_ident3(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "ip_recipient", "%s",
      v3d_desc_ip_recipient((v3d_ip_recipient_t)(packed0 & 255)));
   printer->vtbl->field(printer, "v3d_sub_rev", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->end(printer);
}
void v3d_print_hub_ident(uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed1 & 15);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed1 >> 4 & 15);
   printer->vtbl->field(printer, "num_cores", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max(packed1 >> 8 & 15, 4));
   printer->vtbl->field(printer, "num_hosts", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 12 & 15, 1, 15));
   printer->vtbl->boolean_field(printer, "has_l3c", packed1 >> 16 & 1);
   printer->vtbl->boolean_field(printer, "has_tfu", packed1 >> 17 & 1);
   printer->vtbl->boolean_field(printer, "has_tsy", packed1 >> 18 & 1);
   printer->vtbl->boolean_field(printer, "has_mso", packed1 >> 19 & 1);
   printer->vtbl->field(printer, "l3c_associativity", "%" PRIu32 "",
      packed1 >> 20 & 15);
   printer->vtbl->field(printer, "l3c_banks", "%" PRIu32 "", packed1 >> 24 & 15);
   printer->vtbl->field(printer, "l3c_size_in_multiples_of_64kb", "%" PRIu32 "",
      packed2 & 255);
   printer->vtbl->boolean_field(printer, "has_mmu", packed2 >> 8 & 1);
   printer->vtbl->field(printer, "ip_recipient", "%s",
      v3d_desc_ip_recipient((v3d_ip_recipient_t)(packed3 & 255)));
   printer->vtbl->field(printer, "v3d_sub_rev", "%" PRIu32 "", packed3 >> 8 & 255);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed0 >> 24);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed0 & 15);
   printer->vtbl->field(printer, "num_slices", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 4 & 15, 1, 15));
   printer->vtbl->field(printer, "num_qpus_per_slice", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 8 & 15, 1, 15));
   printer->vtbl->field(printer, "num_tmus", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 12 & 15, 1, 15));
   printer->vtbl->field(printer, "vpm_size_in_multiples_of_8kb", "%" PRIu32 "",
      packed0 >> 28);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "vri_size", "%s",
      v3d_desc_vri_size((v3d_vri_size_t)(packed0 & 15)));
   printer->vtbl->field(printer, "tlb_size", "%s",
      v3d_desc_tlb_size((v3d_tlb_size_t)(packed0 >> 4 & 15)));
   printer->vtbl->boolean_field(printer, "tlb_double_buf_support",
      packed0 >> 8 & 1);
   printer->vtbl->field(printer, "icache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed0 >> 12 & 15)));
   printer->vtbl->field(printer, "ucache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed0 >> 16 & 15)));
   printer->vtbl->boolean_field(printer, "bigend", packed0 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "endswp_support", packed0 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "axi_rw_reorder_support",
      packed0 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "no_earlyz_support", packed0 >> 23 & 1);
   printer->vtbl->field(printer, "core_index", "%" PRIu32 "", packed0 >> 24 & 15);
   printer->vtbl->boolean_field(printer, "bcg_interrupt_control",
      packed0 >> 28 & 1);
   printer->vtbl->boolean_field(printer, "has_astc", packed0 >> 30 & 1);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident3(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "ip_recipient", "%s",
      v3d_desc_ip_recipient((v3d_ip_recipient_t)(packed0 & 255)));
   printer->vtbl->field(printer, "v3d_sub_rev", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident(uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed0 >> 24);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed1 & 15);
   printer->vtbl->field(printer, "num_slices", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 4 & 15, 1, 15));
   printer->vtbl->field(printer, "num_qpus_per_slice", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 8 & 15, 1, 15));
   printer->vtbl->field(printer, "num_tmus", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 12 & 15, 1, 15));
   printer->vtbl->field(printer, "vpm_size_in_multiples_of_8kb", "%" PRIu32 "",
      packed1 >> 28);
   printer->vtbl->field(printer, "vri_size", "%s",
      v3d_desc_vri_size((v3d_vri_size_t)(packed2 & 15)));
   printer->vtbl->field(printer, "tlb_size", "%s",
      v3d_desc_tlb_size((v3d_tlb_size_t)(packed2 >> 4 & 15)));
   printer->vtbl->boolean_field(printer, "tlb_double_buf_support",
      packed2 >> 8 & 1);
   printer->vtbl->field(printer, "icache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed2 >> 12 & 15)));
   printer->vtbl->field(printer, "ucache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed2 >> 16 & 15)));
   printer->vtbl->boolean_field(printer, "bigend", packed2 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "endswp_support", packed2 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "axi_rw_reorder_support",
      packed2 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "no_earlyz_support", packed2 >> 23 & 1);
   printer->vtbl->field(printer, "core_index", "%" PRIu32 "", packed2 >> 24 & 15);
   printer->vtbl->boolean_field(printer, "bcg_interrupt_control",
      packed2 >> 28 & 1);
   printer->vtbl->boolean_field(printer, "has_astc", packed2 >> 30 & 1);
   printer->vtbl->field(printer, "ip_recipient", "%s",
      v3d_desc_ip_recipient((v3d_ip_recipient_t)(packed3 & 255)));
   printer->vtbl->field(printer, "v3d_sub_rev", "%" PRIu32 "", packed3 >> 8 & 255);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed0 >> 24);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed0 & 15);
   printer->vtbl->field(printer, "num_slices", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 4 & 15, 1, 15));
   printer->vtbl->field(printer, "num_qpus_per_slice", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 8 & 15, 1, 15));
   printer->vtbl->field(printer, "num_tmus", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 12 & 15, 1, 15));
   printer->vtbl->field(printer, "vpm_size_in_multiples_of_8kb", "%" PRIu32 "",
      packed0 >> 28);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "vri_size", "%s",
      v3d_desc_vri_size((v3d_vri_size_t)(packed0 & 15)));
   printer->vtbl->field(printer, "tlb_size", "%s",
      v3d_desc_tlb_size((v3d_tlb_size_t)(packed0 >> 4 & 15)));
   printer->vtbl->boolean_field(printer, "tlb_double_buf_support",
      packed0 >> 8 & 1);
   printer->vtbl->field(printer, "icache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed0 >> 12 & 15)));
   printer->vtbl->field(printer, "ucache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed0 >> 16 & 15)));
   printer->vtbl->boolean_field(printer, "bigend", packed0 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "endswp_support", packed0 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "axi_rw_reorder_support",
      packed0 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "no_earlyz_support", packed0 >> 23 & 1);
   printer->vtbl->field(printer, "core_index", "%" PRIu32 "", packed0 >> 24 & 15);
   printer->vtbl->boolean_field(printer, "bcg_interrupt_control",
      packed0 >> 28 & 1);
   printer->vtbl->boolean_field(printer, "has_astc", packed0 >> 30 & 1);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident3(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "l2t_ways", "%" PRIu32 "", packed0 & 15);
   printer->vtbl->field(printer, "l2t_way_depth", "%" PRIu32 "", packed0 >> 4 & 15);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_IDENT_WITH_L2T
void v3d_print_ident(uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "v3d_tech_version", "%" PRIu32 "", packed0 >> 24);
   printer->vtbl->field(printer, "v3d_revision", "%" PRIu32 "", packed1 & 15);
   printer->vtbl->field(printer, "num_slices", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 4 & 15, 1, 15));
   printer->vtbl->field(printer, "num_qpus_per_slice", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 8 & 15, 1, 15));
   printer->vtbl->field(printer, "num_tmus", "%" PRIu32 "",
      gfx_check_urange(packed1 >> 12 & 15, 1, 15));
   printer->vtbl->field(printer, "vpm_size_in_multiples_of_8kb", "%" PRIu32 "",
      packed1 >> 28);
   printer->vtbl->field(printer, "vri_size", "%s",
      v3d_desc_vri_size((v3d_vri_size_t)(packed2 & 15)));
   printer->vtbl->field(printer, "tlb_size", "%s",
      v3d_desc_tlb_size((v3d_tlb_size_t)(packed2 >> 4 & 15)));
   printer->vtbl->boolean_field(printer, "tlb_double_buf_support",
      packed2 >> 8 & 1);
   printer->vtbl->field(printer, "icache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed2 >> 12 & 15)));
   printer->vtbl->field(printer, "ucache_size", "%s",
      v3d_desc_iuc_size((v3d_iuc_size_t)(packed2 >> 16 & 15)));
   printer->vtbl->boolean_field(printer, "bigend", packed2 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "endswp_support", packed2 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "axi_rw_reorder_support",
      packed2 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "no_earlyz_support", packed2 >> 23 & 1);
   printer->vtbl->field(printer, "core_index", "%" PRIu32 "", packed2 >> 24 & 15);
   printer->vtbl->boolean_field(printer, "bcg_interrupt_control",
      packed2 >> 28 & 1);
   printer->vtbl->boolean_field(printer, "has_astc", packed2 >> 30 & 1);
   printer->vtbl->field(printer, "l2t_ways", "%" PRIu32 "", packed3 & 15);
   printer->vtbl->field(printer, "l2t_way_depth", "%" PRIu32 "", packed3 >> 4 & 15);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_gs_inst_fifo_thrsh(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "cle", "%" PRIu32 "", packed0 & 255);
   printer->vtbl->field(printer, "gbg", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->field(printer, "tpg", "%" PRIu32 "", packed0 >> 16 & 255);
   printer->vtbl->end(printer);
}
void v3d_print_gs_tess_fifo_thrsh(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "cle", "%" PRIu32 "", packed0 & 255);
   printer->vtbl->field(printer, "tpg", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->end(printer);
}
void v3d_print_hub_intr(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "tfu_fifo_free_over_threshold",
      packed0 & 1);
   printer->vtbl->boolean_field(printer, "tfu_conv_complete", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "mso_obj_reached_state", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "mmu_cap", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "mmu_pti", packed0 >> 4 & 1);
   printer->vtbl->boolean_field(printer, "mmu_wrv", packed0 >> 5 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_intr(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "render_done", packed0 & 1);
   printer->vtbl->boolean_field(printer, "bin_done", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "outomem", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "spilluse", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "trfb", packed0 >> 4 & 1);
   printer->vtbl->boolean_field(printer, "gmpv", packed0 >> 5 & 1);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "qpu", false);
   printer->vtbl->boolean_field(printer, "0", packed0 >> 16 & 1);
   printer->vtbl->boolean_field(printer, "1", packed0 >> 17 & 1);
   printer->vtbl->boolean_field(printer, "2", packed0 >> 18 & 1);
   printer->vtbl->boolean_field(printer, "3", packed0 >> 19 & 1);
   printer->vtbl->boolean_field(printer, "4", packed0 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "5", packed0 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "6", packed0 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "7", packed0 >> 23 & 1);
   printer->vtbl->boolean_field(printer, "8", packed0 >> 24 & 1);
   printer->vtbl->boolean_field(printer, "9", packed0 >> 25 & 1);
   printer->vtbl->boolean_field(printer, "10", packed0 >> 26 & 1);
   printer->vtbl->boolean_field(printer, "11", packed0 >> 27 & 1);
   printer->vtbl->boolean_field(printer, "12", packed0 >> 28 & 1);
   printer->vtbl->boolean_field(printer, "13", packed0 >> 29 & 1);
   printer->vtbl->boolean_field(printer, "14", packed0 >> 30 & 1);
   printer->vtbl->boolean_field(printer, "15", packed0 >> 31);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
void v3d_print_ct0cs(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "ctooberr", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cterr", packed0 >> 3 & 1);
   printer->vtbl->field(printer, "ctsubsrun", "%s",
      v3d_desc_ctsubsrun((v3d_ctsubsrun_t)(packed0 >> 4 & 3)));
   printer->vtbl->field(printer, "ctqdep", "%" PRIu32 "", packed0 >> 6 & 1);
   printer->vtbl->field(printer, "ctrtsd", "%" PRIu32 "", packed0 >> 8 & 3);
   printer->vtbl->field(printer, "ctsema", "%" PRIu32 "", packed0 >> 12 & 7);
   printer->vtbl->boolean_field(printer, "ctrsta", packed0 >> 15 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_ct1cs(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "ctetstop", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cterr", packed0 >> 3 & 1);
   printer->vtbl->field(printer, "ctsubsrun", "%s",
      v3d_desc_ctsubsrun((v3d_ctsubsrun_t)(packed0 >> 4 & 3)));
   printer->vtbl->field(printer, "ctqdep", "%" PRIu32 "", packed0 >> 6 & 1);
   printer->vtbl->field(printer, "ctrtsd", "%" PRIu32 "", packed0 >> 8 & 3);
   printer->vtbl->field(printer, "ctsema", "%" PRIu32 "", packed0 >> 12 & 7);
   printer->vtbl->boolean_field(printer, "ctrsta", packed0 >> 15 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_ct1cfg(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "disable_multicore", packed0 & 1);
   printer->vtbl->boolean_field(printer, "ets_flush", packed0 >> 1 & 1);
   printer->vtbl->field(printer, "max_tiles_in_flight", "%" PRIu32 "",
      packed0 >> 2 & 3);
   printer->vtbl->field(printer, "mcs_mask_set", "%" PRIu32 "", packed0 >> 4 & 1);
   printer->vtbl->field(printer, "mcs_frame_id", "%" PRIu32 "", packed0 >> 5 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_ct1tilect(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "tiles_completed_in_curr_st", "%" PRIu32 "",
      packed0 & 0xffff);
   printer->vtbl->field(printer, "supertiles_completed", "%" PRIu32 "",
      packed0 >> 16 & 0x1ff);
   printer->vtbl->field(printer, "tiles_in_flight", "%" PRIu32 "",
      packed0 >> 25 & 3);
   printer->vtbl->end(printer);
}
void v3d_print_ct1ptct(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "tiles_completed_in_curr_st", "%" PRIu32 "",
      packed0 & 0xffff);
   printer->vtbl->field(printer, "supertiles_completed", "%" PRIu32 "",
      packed0 >> 16 & 0x1ff);
   printer->vtbl->field(printer, "mcs_mask_set", "%" PRIu32 "", packed0 >> 28 & 1);
   printer->vtbl->field(printer, "mcs_frame_id", "%" PRIu32 "", packed0 >> 29 & 1);
   printer->vtbl->boolean_field(printer, "etstop", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_pcs(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "bmactive", packed0 & 1);
   printer->vtbl->boolean_field(printer, "rmactive", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "bmoom", packed0 >> 8 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_tfucs(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "busy", packed0 & 1);
   printer->vtbl->field(printer, "nfree", "%" PRIu32 "", packed0 >> 8 & 63);
   printer->vtbl->field(printer, "cvtct", "%" PRIu32 "", packed0 >> 16 & 255);
   printer->vtbl->boolean_field(printer, "tfurst", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_tfusu(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "throttle", "%" PRIu32 "", packed0 & 3);
   printer->vtbl->boolean_field(printer, "crc", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "crcchain", packed0 >> 4 & 1);
   printer->vtbl->field(printer, "fintthr", "%" PRIu32 "", packed0 >> 8 & 63);
   printer->vtbl->end(printer);
}
void v3d_print_tfuicfg(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "ioc", packed0 & 1);
   printer->vtbl->field(printer, "rgbord", "%s",
      v3d_desc_tfu_rgbord((v3d_tfu_rgbord_t)(packed0 >> 1 & 3)));
   printer->vtbl->boolean_field(printer, "flipy", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "srgb", packed0 >> 4 & 1);
   printer->vtbl->field(printer, "nummm", "%" PRIu32 "", (packed0 >> 5 & 15) + 1);
   printer->vtbl->field(printer, "ttype", "%s",
      v3d_desc_tfu_type((v3d_tfu_type_t)(packed0 >> 9 & 127)));
   printer->vtbl->field(printer, "iformat", "%s", v3d_desc_tfu_iformat(
      (v3d_tfu_iformat_t)(packed0 >> 18 & 15)));
   printer->vtbl->field(printer, "opad", "%" PRIu32 "", packed0 >> 22);
   printer->vtbl->end(printer);
}
void v3d_print_tfuiis(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "stride0", "%" PRIu32 "", packed0 & 0xffff);
   printer->vtbl->field(printer, "stride1", "%" PRIu32 "", packed0 >> 16);
   printer->vtbl->end(printer);
}
void v3d_print_tfuioa(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "dimtw", packed0 & 1);
   printer->vtbl->field(printer, "oformat", "%s",
      v3d_desc_tfu_oformat((v3d_tfu_oformat_t)(packed0 >> 3 & 7)));
   printer->vtbl->addr_field(printer, "oaddr", packed0 >> 6 << 6);
   printer->vtbl->end(printer);
}
void v3d_print_tfuios(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "xsize", "%" PRIu32 "",
      gfx_check_urange(packed0 & 0xffff, 0, 0x4000));
   printer->vtbl->field(printer, "ysize", "%" PRIu32 "",
      gfx_check_urange(packed0 >> 16, 0, 0x4000));
   printer->vtbl->end(printer);
}
void v3d_print_tfucoef0(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "ay", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->field(printer, "arc", "%" PRIu32 "", packed0 >> 16 & 0xfff);
   printer->vtbl->boolean_field(printer, "usecoef", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_tfucoef1(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "agc", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->field(printer, "abc", "%" PRIu32 "", packed0 >> 16 & 0xfff);
   printer->vtbl->end(printer);
}
void v3d_print_tfucoef2(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "agr", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->field(printer, "arr", "%" PRIu32 "", packed0 >> 16 & 0xfff);
   printer->vtbl->end(printer);
}
void v3d_print_tfucoef3(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "abb", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->field(printer, "agb", "%" PRIu32 "", packed0 >> 16 & 0xfff);
   printer->vtbl->end(printer);
}
void v3d_print_srqcs(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_queued", "%" PRIu32 "", packed0 & 63);
   printer->vtbl->boolean_field(printer, "queue_error", packed0 >> 7 & 1);
   printer->vtbl->field(printer, "num_requests", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->field(printer, "num_completed", "%" PRIu32 "",
      packed0 >> 16 & 255);
   printer->vtbl->end(printer);
}
void v3d_print_uifcfg(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "page_size", "%" PRIu32 "",
      gfx_check_urange(packed0 & 3, 0, 2));
   printer->vtbl->field(printer, "num_banks", "%" PRIu32 "", packed0 >> 2 & 3);
   printer->vtbl->field(printer, "xor_addr", "%" PRIu32 "", packed0 >> 4 & 15);
   printer->vtbl->end(printer);
}
#if V3D_VER_AT_LEAST(3,3,0,0)
void v3d_print_dram_map_version(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "version", "%s", v3d_desc_dram_map_version(
      (v3d_dram_map_version_t)(packed0 & 15)));
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
void v3d_print_misccfg(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "ovrtmuout", packed0 & 1);
   printer->vtbl->end(printer);
}
#endif
void v3d_print_mmu_ctrl(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "enable", packed0 & 1);
   printer->vtbl->boolean_field(printer, "stats_enable", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "tlb_clear", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "stats_clear", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "tlb_clearing", packed0 >> 7 & 1);
   printer->vtbl->boolean_field(printer, "wrv_exception", packed0 >> 9 & 1);
   printer->vtbl->boolean_field(printer, "wrv_interrupt", packed0 >> 10 & 1);
   printer->vtbl->boolean_field(printer, "wrv_abort", packed0 >> 11 & 1);
   printer->vtbl->boolean_field(printer, "wrv", packed0 >> 12 & 1);
   printer->vtbl->boolean_field(printer, "pti_enable", packed0 >> 16 & 1);
   printer->vtbl->boolean_field(printer, "pti_exception", packed0 >> 17 & 1);
   printer->vtbl->boolean_field(printer, "pti_interrupt", packed0 >> 18 & 1);
   printer->vtbl->boolean_field(printer, "pti_abort", packed0 >> 19 & 1);
   printer->vtbl->boolean_field(printer, "pti", packed0 >> 20 & 1);
   printer->vtbl->boolean_field(printer, "capex_exception", packed0 >> 24 & 1);
   printer->vtbl->boolean_field(printer, "capex_interrupt", packed0 >> 25 & 1);
   printer->vtbl->boolean_field(printer, "capex_abort", packed0 >> 26 & 1);
   printer->vtbl->boolean_field(printer, "capex", packed0 >> 27 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_mmu_addr_cap(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "mpage", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->boolean_field(printer, "enable", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_mmu_bypass(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "mpage", "%" PRIu32 "", packed0 & 0xfff);
   printer->vtbl->boolean_field(printer, "enable", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_mmu_illegal(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "page", "%" PRIu32 "", packed0 & 0x7fffffff);
   printer->vtbl->boolean_field(printer, "enable", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_mmu_debug_info(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "version", "%" PRIu32 "", packed0 & 15);
   printer->vtbl->field(printer, "va_width", "%" PRIu32 "", packed0 >> 4 & 15);
   printer->vtbl->field(printer, "pa_width", "%" PRIu32 "", packed0 >> 8 & 15);
   printer->vtbl->end(printer);
}
void v3d_print_mmuc_control(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "enable", packed0 & 1);
   printer->vtbl->boolean_field(printer, "flush", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "flushing", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "clear_stats", packed0 >> 3 & 1);
   printer->vtbl->field(printer, "cache_size", "%" PRIu32 "", packed0 >> 4 & 3);
   printer->vtbl->end(printer);
}
void v3d_print_gmp_cfg(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "enable", packed0 & 1);
   printer->vtbl->boolean_field(printer, "stop_request", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "page_cross_detect_enable",
      packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "long_burst_detect_enable",
      packed0 >> 3 & 1);
   printer->vtbl->end(printer);
}
void v3d_print_gmp_status(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "violation", packed0 & 1);
   printer->vtbl->boolean_field(printer, "invalid_table", packed0 >> 1 & 1);
   printer->vtbl->boolean_field(printer, "counter_overflow", packed0 >> 2 & 1);
   printer->vtbl->boolean_field(printer, "cfg_update", packed0 >> 3 & 1);
   printer->vtbl->boolean_field(printer, "read_active", packed0 >> 4 & 1);
   printer->vtbl->boolean_field(printer, "write_active", packed0 >> 5 & 1);
   printer->vtbl->field(printer, "read_count", "%" PRIu32 "", packed0 >> 16 & 127);
   printer->vtbl->field(printer, "write_count", "%" PRIu32 "", packed0 >> 24 & 127);
   printer->vtbl->boolean_field(printer, "reset", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_control(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "reg_data", "%" PRIu32 "", packed0 & 0xffff);
   printer->vtbl->field(printer, "reg_addr", "%" PRIu32 "", packed0 >> 24 & 31);
   printer->vtbl->boolean_field(printer, "write", packed0 >> 31);
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_burst(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "axi_len", "%" PRIu32 "",
      (uint32_t)(packed0 & 0x3ff));
   printer->vtbl->field(printer, "axi_size", "%" PRIu32 "",
      (uint32_t)(packed0 >> 13));
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_id(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "axi_id", "%" PRIu32 "",
      (uint32_t)(packed0 & 0x1fff));
   printer->vtbl->field(printer, "axi_prot", "%" PRIu32 "",
      (uint32_t)(packed0 >> 13));
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_status(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "write", (uint32_t)(packed0 & 1));
   printer->vtbl->boolean_field(printer, "read", (uint32_t)(packed0 >> 1 & 1));
   printer->vtbl->boolean_field(printer, "rd_fifo_almost_full",
      (uint32_t)(packed0 >> 4 & 1));
   printer->vtbl->boolean_field(printer, "wr_fifo_almost_empty",
      (uint32_t)(packed0 >> 5 & 1));
   printer->vtbl->field(printer, "fpga_num", "%" PRIu32 "",
      (uint32_t)(packed0 >> 8 & 15));
   printer->vtbl->boolean_field(printer, "master_error",
      (uint32_t)(packed0 >> 14 & 1));
   printer->vtbl->boolean_field(printer, "axi_idle", (uint32_t)(packed0 >> 15));
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_error(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "axi_response", "%" PRIu32 "",
      (uint32_t)(packed0 & 3));
   printer->vtbl->boolean_field(printer, "axi_timeout",
      (uint32_t)(packed0 >> 2 & 1));
   printer->vtbl->boolean_field(printer, "rd_fifo_missed",
      (uint32_t)(packed0 >> 3 & 1));
   printer->vtbl->boolean_field(printer, "rd_fifo_rd",
      (uint32_t)(packed0 >> 4 & 1));
   printer->vtbl->boolean_field(printer, "rd_fifo_wr",
      (uint32_t)(packed0 >> 5 & 1));
   printer->vtbl->boolean_field(printer, "wr_fifo_rd",
      (uint32_t)(packed0 >> 6 & 1));
   printer->vtbl->boolean_field(printer, "wr_fifo_wr",
      (uint32_t)(packed0 >> 7 & 1));
   printer->vtbl->boolean_field(printer, "wr_data_left",
      (uint32_t)(packed0 >> 8 & 1));
   printer->vtbl->boolean_field(printer, "wr_no_data",
      (uint32_t)(packed0 >> 9 & 1));
   printer->vtbl->boolean_field(printer, "rd_data_left",
      (uint32_t)(packed0 >> 10 & 1));
   printer->vtbl->boolean_field(printer, "start_when_busy",
      (uint32_t)(packed0 >> 11 & 1));
   printer->vtbl->boolean_field(printer, "start_error",
      (uint32_t)(packed0 >> 13 & 1));
   printer->vtbl->boolean_field(printer, "fifo_error",
      (uint32_t)(packed0 >> 14 & 1));
   printer->vtbl->boolean_field(printer, "axi_error", (uint32_t)(packed0 >> 15));
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_flags(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "read_req", (uint32_t)(packed0 & 1));
   printer->vtbl->boolean_field(printer, "write_req", (uint32_t)(packed0 >> 1 & 1));
   printer->vtbl->boolean_field(printer, "clear_error",
      (uint32_t)(packed0 >> 14 & 1));
   printer->vtbl->boolean_field(printer, "fifo_reset", (uint32_t)(packed0 >> 15));
   printer->vtbl->end(printer);
}
void v3d_print_umr_axi_fifo_flags(uint16_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "wr_full", (uint32_t)(packed0 & 1));
   printer->vtbl->boolean_field(printer, "wr_empty", (uint32_t)(packed0 >> 1 & 1));
   printer->vtbl->boolean_field(printer, "wr_almost_empty",
      (uint32_t)(packed0 >> 2 & 1));
   printer->vtbl->boolean_field(printer, "wr_data_left",
      (uint32_t)(packed0 >> 3 & 1));
   printer->vtbl->boolean_field(printer, "rd_full", (uint32_t)(packed0 >> 4 & 1));
   printer->vtbl->boolean_field(printer, "rd_empty", (uint32_t)(packed0 >> 5 & 1));
   printer->vtbl->boolean_field(printer, "rd_almost_full",
      (uint32_t)(packed0 >> 6 & 1));
   printer->vtbl->boolean_field(printer, "rd_data_left",
      (uint32_t)(packed0 >> 7 & 1));
   printer->vtbl->boolean_field(printer, "resetting", (uint32_t)(packed0 >> 15));
   printer->vtbl->end(printer);
}
void v3d_print_umr_sysmon_infra_status(uint32_t packed0, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "slave_error", "%" PRIu32 "", packed0 & 255);
   printer->vtbl->field(printer, "mastr_done", "%" PRIu32 "", packed0 >> 8 & 255);
   printer->vtbl->field(printer, "num_slaves", "%" PRIu32 "", packed0 >> 16 & 15);
   printer->vtbl->boolean_field(printer, "design_reset", packed0 >> 21 & 1);
   printer->vtbl->boolean_field(printer, "local_done", packed0 >> 22 & 1);
   printer->vtbl->boolean_field(printer, "iodely_rdy", packed0 >> 23 & 1);
   printer->vtbl->field(printer, "reset_state", "%" PRIu32 "", packed0 >> 24 & 15);
   printer->vtbl->boolean_field(printer, "parity_error", packed0 >> 29 & 1);
   printer->vtbl->boolean_field(printer, "pll_locked", packed0 >> 30 & 1);
   printer->vtbl->boolean_field(printer, "infra_error", packed0 >> 31);
   printer->vtbl->end(printer);
}
uint32_t v3d_cl_instr_size(v3d_cl_opcode_t opcode)
{
   switch (opcode) {
   case V3D_CL_HALT: return V3D_CL_HALT_SIZE;
   case V3D_CL_NOP: return V3D_CL_NOP_SIZE;
   case V3D_CL_FLUSH: return V3D_CL_FLUSH_SIZE;
   case V3D_CL_FLUSH_ALL_STATE: return V3D_CL_FLUSH_ALL_STATE_SIZE;
   case V3D_CL_START_TILE_BINNING: return V3D_CL_START_TILE_BINNING_SIZE;
   case V3D_CL_INCR_SEMAPHORE: return V3D_CL_INCR_SEMAPHORE_SIZE;
   case V3D_CL_WAIT_SEMAPHORE: return V3D_CL_WAIT_SEMAPHORE_SIZE;
   case V3D_CL_WAIT_PREV_FRAME: return V3D_CL_WAIT_PREV_FRAME_SIZE;
   case V3D_CL_ENABLE_Z_ONLY: return V3D_CL_ENABLE_Z_ONLY_SIZE;
   case V3D_CL_DISABLE_Z_ONLY: return V3D_CL_DISABLE_Z_ONLY_SIZE;
   case V3D_CL_END_Z_ONLY: return V3D_CL_END_Z_ONLY_SIZE;
   case V3D_CL_END_RENDER: return V3D_CL_END_RENDER_SIZE;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: return V3D_CL_WAIT_TRANSFORM_FEEDBACK_SIZE;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: return V3D_CL_BRANCH_SIZE;
   case V3D_CL_RETURN: return V3D_CL_RETURN_SIZE;
   case V3D_CL_FLUSH_VCD_CACHE: return V3D_CL_FLUSH_VCD_CACHE_SIZE;
   case V3D_CL_GENERIC_TILE_LIST: return V3D_CL_GENERIC_TILE_LIST_SIZE;
   case V3D_CL_BRANCH_IMPLICIT_TILE: return V3D_CL_BRANCH_IMPLICIT_TILE_SIZE;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: return V3D_CL_BRANCH_EXPLICIT_SUPERTILE_SIZE;
   case V3D_CL_SUPERTILE_COORDS: return V3D_CL_SUPERTILE_COORDS_SIZE;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: return V3D_CL_CLEAR_SIZE;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: return V3D_CL_END_LOADS_SIZE;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return V3D_CL_END_TILE_SIZE;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: return V3D_CL_STORE_SIZE;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return V3D_CL_LOAD_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: return V3D_CL_STORE_SUBSAMPLE_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: return V3D_CL_STORE_SUBSAMPLE_EX_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return V3D_CL_LOAD_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return V3D_CL_END_TILE_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: return V3D_CL_STORE_GENERAL_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: return V3D_CL_LOAD_GENERAL_SIZE;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: return V3D_CL_TF_DRAW_FLUSH_AND_COUNT_SIZE;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return V3D_CL_INDEXED_PRIM_LIST_SIZE;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return V3D_CL_INDEXED_PRIM_LIST_SIZE;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: return V3D_CL_INDIRECT_INDEXED_PRIM_LIST_SIZE;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return V3D_CL_INDEXED_INSTANCED_PRIM_LIST_SIZE;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return V3D_CL_INDEXED_INSTANCED_PRIM_LIST_SIZE;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: return V3D_CL_VERTEX_ARRAY_PRIMS_SIZE;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: return V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_SIZE;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: return V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_SIZE;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: return V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_SIZE;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: return V3D_CL_BASE_VERTEX_BASE_INSTANCE_SIZE;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return V3D_CL_INDIRECT_PRIMITIVE_LIMITS_SIZE;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return V3D_CL_INDIRECT_PRIMITIVE_LIMITS_SIZE;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: return V3D_CL_VG_COORD_ARRAY_PRIMS_SIZE;
   case V3D_CL_VG_INLINE_PRIMS: return V3D_CL_VG_INLINE_PRIMS_SIZE;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: return V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO_SIZE;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: return V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID_SIZE;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: return V3D_CL_CLIPPED_PRIM_SIZE;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: return V3D_CL_SET_INSTANCE_ID_SIZE;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: return V3D_CL_PRIM_LIST_FORMAT_SIZE;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: return V3D_CL_SERIAL_NUMBER_LIST_START_SIZE;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: return V3D_CL_GL_SHADER_SIZE;
   case V3D_CL_VG_SHADER: return V3D_CL_VG_SHADER_SIZE;
   case V3D_CL_VG_INLINE_SHADER: return V3D_CL_VG_INLINE_SHADER_SIZE;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return V3D_CL_VCM_CACHE_SIZE_SIZE;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: return V3D_CL_PRIM_COUNTS_FEEDBACK_SIZE;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: return V3D_CL_TRANSFORM_FEEDBACK_BUFFER_SIZE;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: return V3D_CL_TRANSFORM_FEEDBACK_SPECS_SIZE;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return V3D_CL_VCM_CACHE_SIZE_SIZE;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: return V3D_CL_TRANSFORM_FEEDBACK_ENABLE_SIZE;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: return V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA_SIZE;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: return V3D_CL_L1_CACHE_FLUSH_CONTROL_SIZE;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: return V3D_CL_L2T_CACHE_FLUSH_CONTROL_SIZE;
   case V3D_CL_L2C_CACHE_FLUSH: return V3D_CL_L2C_CACHE_FLUSH_SIZE;
   case V3D_CL_STENCIL_CFG: return V3D_CL_STENCIL_CFG_SIZE;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return V3D_CL_BLEND_CFG_SIZE;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: return V3D_CL_BLEND_ENABLES_SIZE;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return V3D_CL_BLEND_CFG_SIZE;
#endif
   case V3D_CL_BLEND_CCOLOR: return V3D_CL_BLEND_CCOLOR_SIZE;
   case V3D_CL_COLOR_WMASKS: return V3D_CL_COLOR_WMASKS_SIZE;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: return V3D_CL_ZERO_ALL_CENTROID_FLAGS_SIZE;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: return V3D_CL_ZERO_ALL_FLATSHADE_FLAGS_SIZE;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: return V3D_CL_VARY_FLAGS_SIZE;
   case V3D_CL_SAMPLE_COVERAGE: return V3D_CL_SAMPLE_COVERAGE_SIZE;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: return V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_SIZE;
   case V3D_CL_CFG_BITS: return V3D_CL_CFG_BITS_SIZE;
   case V3D_CL_POINT_SIZE: return V3D_CL_POINT_SIZE_SIZE;
   case V3D_CL_LINE_WIDTH: return V3D_CL_LINE_WIDTH_SIZE;
   case V3D_CL_DEPTH_OFFSET: return V3D_CL_DEPTH_OFFSET_SIZE;
   case V3D_CL_CLIP: return V3D_CL_CLIP_SIZE;
   case V3D_CL_VIEWPORT_OFFSET: return V3D_CL_VIEWPORT_OFFSET_SIZE;
   case V3D_CL_CLIPZ: return V3D_CL_CLIPZ_SIZE;
   case V3D_CL_CLIPPER_XY: return V3D_CL_CLIPPER_XY_SIZE;
   case V3D_CL_CLIPPER_Z: return V3D_CL_CLIPPER_Z_SIZE;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: return V3D_CL_NUM_LAYERS_SIZE;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: return V3D_CL_TILE_BINNING_MODE_CFG_SIZE;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return V3D_CL_TILE_RENDERING_MODE_CFG_SIZE;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return V3D_CL_TILE_RENDERING_MODE_CFG_SIZE;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: return V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_SIZE;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: return V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_SIZE;
   case V3D_CL_TILE_COORDS: return V3D_CL_TILE_COORDS_SIZE;
   case V3D_CL_IMPLICIT_TILE_COORDS: return V3D_CL_IMPLICIT_TILE_COORDS_SIZE;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: return V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_SIZE;
   default: unreachable(); return 0;
   }
}
bool v3d_cl_instr_ok_in_bin(v3d_cl_opcode_t opcode)
{
   switch (opcode) {
   case V3D_CL_HALT: return true;
   case V3D_CL_NOP: return true;
   case V3D_CL_FLUSH: return true;
   case V3D_CL_FLUSH_ALL_STATE: return true;
   case V3D_CL_START_TILE_BINNING: return true;
   case V3D_CL_INCR_SEMAPHORE: return true;
   case V3D_CL_WAIT_SEMAPHORE: return true;
   case V3D_CL_WAIT_PREV_FRAME: return true;
   case V3D_CL_ENABLE_Z_ONLY: return false;
   case V3D_CL_DISABLE_Z_ONLY: return false;
   case V3D_CL_END_Z_ONLY: return true;
   case V3D_CL_END_RENDER: return false;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: return true;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: return true;
   case V3D_CL_RETURN: return true;
   case V3D_CL_FLUSH_VCD_CACHE: return true;
   case V3D_CL_GENERIC_TILE_LIST: return false;
   case V3D_CL_BRANCH_IMPLICIT_TILE: return false;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: return false;
   case V3D_CL_SUPERTILE_COORDS: return false;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: return false;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: return true;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return true;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return true;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: return true;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return true;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return true;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: return true;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: return true;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: return true;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: return true;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: return true;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return true;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return true;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: return true;
   case V3D_CL_VG_INLINE_PRIMS: return true;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: return false;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: return false;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: return false;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: return true;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: return false;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: return false;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: return true;
   case V3D_CL_VG_SHADER: return true;
   case V3D_CL_VG_INLINE_SHADER: return true;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: return true;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: return true;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: return true;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: return true;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: return true;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: return false;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: return true;
   case V3D_CL_L2C_CACHE_FLUSH: return false;
   case V3D_CL_STENCIL_CFG: return true;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
   case V3D_CL_BLEND_CCOLOR: return true;
   case V3D_CL_COLOR_WMASKS: return true;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: return true;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: return true;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: return true;
   case V3D_CL_SAMPLE_COVERAGE: return true;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: return true;
   case V3D_CL_CFG_BITS: return true;
   case V3D_CL_POINT_SIZE: return true;
   case V3D_CL_LINE_WIDTH: return true;
   case V3D_CL_DEPTH_OFFSET: return true;
   case V3D_CL_CLIP: return true;
   case V3D_CL_VIEWPORT_OFFSET: return true;
   case V3D_CL_CLIPZ: return true;
   case V3D_CL_CLIPPER_XY: return true;
   case V3D_CL_CLIPPER_Z: return true;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: return true;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: return true;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return false;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: return false;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: return false;
   case V3D_CL_TILE_COORDS: return false;
   case V3D_CL_IMPLICIT_TILE_COORDS: return false;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: return false;
   default: unreachable(); return false;
   }
}
bool v3d_cl_instr_ok_in_render(v3d_cl_opcode_t opcode)
{
   switch (opcode) {
   case V3D_CL_HALT: return true;
   case V3D_CL_NOP: return true;
   case V3D_CL_FLUSH: return false;
   case V3D_CL_FLUSH_ALL_STATE: return false;
   case V3D_CL_START_TILE_BINNING: return false;
   case V3D_CL_INCR_SEMAPHORE: return true;
   case V3D_CL_WAIT_SEMAPHORE: return true;
   case V3D_CL_WAIT_PREV_FRAME: return true;
   case V3D_CL_ENABLE_Z_ONLY: return true;
   case V3D_CL_DISABLE_Z_ONLY: return true;
   case V3D_CL_END_Z_ONLY: return true;
   case V3D_CL_END_RENDER: return true;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: return false;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: return true;
   case V3D_CL_RETURN: return true;
   case V3D_CL_FLUSH_VCD_CACHE: return true;
   case V3D_CL_GENERIC_TILE_LIST: return true;
   case V3D_CL_BRANCH_IMPLICIT_TILE: return true;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: return true;
   case V3D_CL_SUPERTILE_COORDS: return true;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: return true;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: return true;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return true;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: return true;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: return true;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: return false;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return false;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: return false;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return false;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: return false;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: return false;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: return false;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: return false;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: return false;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return false;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: return false;
   case V3D_CL_VG_INLINE_PRIMS: return false;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: return true;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: return true;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: return true;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: return true;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: return true;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: return true;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: return true;
   case V3D_CL_VG_SHADER: return true;
   case V3D_CL_VG_INLINE_SHADER: return true;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: return false;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: return false;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: return false;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: return false;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: return false;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: return true;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: return true;
   case V3D_CL_L2C_CACHE_FLUSH: return true;
   case V3D_CL_STENCIL_CFG: return true;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
   case V3D_CL_BLEND_CCOLOR: return true;
   case V3D_CL_COLOR_WMASKS: return true;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: return true;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: return true;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: return true;
   case V3D_CL_SAMPLE_COVERAGE: return true;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: return true;
   case V3D_CL_CFG_BITS: return true;
   case V3D_CL_POINT_SIZE: return true;
   case V3D_CL_LINE_WIDTH: return true;
   case V3D_CL_DEPTH_OFFSET: return true;
   case V3D_CL_CLIP: return true;
   case V3D_CL_VIEWPORT_OFFSET: return true;
   case V3D_CL_CLIPZ: return true;
   case V3D_CL_CLIPPER_XY: return false;
   case V3D_CL_CLIPPER_Z: return false;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: return false;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: return false;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return true;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return true;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: return true;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: return true;
   case V3D_CL_TILE_COORDS: return true;
   case V3D_CL_IMPLICIT_TILE_COORDS: return true;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: return true;
   default: unreachable(); return false;
   }
}
bool v3d_cl_instr_ok_in_tile_list(v3d_cl_opcode_t opcode)
{
   switch (opcode) {
   case V3D_CL_HALT: return false;
   case V3D_CL_NOP: return true;
   case V3D_CL_FLUSH: return false;
   case V3D_CL_FLUSH_ALL_STATE: return false;
   case V3D_CL_START_TILE_BINNING: return false;
   case V3D_CL_INCR_SEMAPHORE: return false;
   case V3D_CL_WAIT_SEMAPHORE: return false;
   case V3D_CL_WAIT_PREV_FRAME: return false;
   case V3D_CL_ENABLE_Z_ONLY: return false;
   case V3D_CL_DISABLE_Z_ONLY: return false;
   case V3D_CL_END_Z_ONLY: return true;
   case V3D_CL_END_RENDER: return false;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: return false;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: return true;
   case V3D_CL_RETURN: return true;
   case V3D_CL_FLUSH_VCD_CACHE: return false;
   case V3D_CL_GENERIC_TILE_LIST: return false;
   case V3D_CL_BRANCH_IMPLICIT_TILE: return false;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: return false;
   case V3D_CL_SUPERTILE_COORDS: return false;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: return false;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: return false;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: return false;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: return false;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: return false;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: return false;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: return false;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: return false;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: return false;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: return false;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: return false;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return false;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: return false;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: return false;
   case V3D_CL_VG_INLINE_PRIMS: return false;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: return true;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: return true;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: return true;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: return true;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: return true;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: return true;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: return true;
   case V3D_CL_VG_SHADER: return true;
   case V3D_CL_VG_INLINE_SHADER: return true;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: return false;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: return false;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: return false;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: return true;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: return false;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: return false;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: return false;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: return false;
   case V3D_CL_L2C_CACHE_FLUSH: return false;
   case V3D_CL_STENCIL_CFG: return true;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: return true;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: return true;
#endif
   case V3D_CL_BLEND_CCOLOR: return true;
   case V3D_CL_COLOR_WMASKS: return true;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: return true;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: return true;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: return true;
   case V3D_CL_SAMPLE_COVERAGE: return true;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: return true;
   case V3D_CL_CFG_BITS: return true;
   case V3D_CL_POINT_SIZE: return true;
   case V3D_CL_LINE_WIDTH: return true;
   case V3D_CL_DEPTH_OFFSET: return true;
   case V3D_CL_CLIP: return true;
   case V3D_CL_VIEWPORT_OFFSET: return true;
   case V3D_CL_CLIPZ: return true;
   case V3D_CL_CLIPPER_XY: return false;
   case V3D_CL_CLIPPER_Z: return false;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: return false;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: return false;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return false;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: return false;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: return false;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: return false;
   case V3D_CL_TILE_COORDS: return false;
   case V3D_CL_IMPLICIT_TILE_COORDS: return false;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: return false;
   default: unreachable(); return false;
   }
}
void v3d_cl_print_halt(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_nop(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_flush(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_flush_all_state(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_start_tile_binning(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_incr_semaphore(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_wait_semaphore(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_wait_prev_frame(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_enable_z_only(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_disable_z_only(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_end_z_only(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_end_render(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_wait_transform_feedback(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "%" PRIu32 "", (uint32_t)packed[0]);
}
void v3d_cl_print_branch(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->addr_field(printer, NULL,
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_print_return(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_flush_vcd_cache(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_generic_tile_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "addr",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   printer->vtbl->addr_field(printer, "end",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_branch_implicit_tile(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "%" PRIu32 "", (uint32_t)packed[0]);
}
void v3d_cl_print_branch_explicit_supertile(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "x", "%" PRIu32 "", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "y", "%" PRIu32 "", (uint32_t)packed[1]);
   printer->vtbl->field(printer, "supertile", "%" PRIu32 "", (uint32_t)packed[2]);
   printer->vtbl->addr_field(printer, "addr",
      (uint32_t)packed[3] | (uint32_t)packed[4] << 8 | (uint32_t)packed[5] << 16 |
      (uint32_t)packed[6] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_supertile_coords(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "x", "%" PRIu32 "", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "y", "%" PRIu32 "", (uint32_t)packed[1]);
   printer->vtbl->end(printer);
}
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_clear(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "rts", (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "depth_stencil",
      (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_end_loads(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_end_tile(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_store(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "buffer", "%s", v3d_desc_ldst_buf(
      (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "memory_format", "%s", v3d_desc_memory_format(
      (v3d_memory_format_t)(uint32_t)(packed[0] >> 4 & 7)));
   printer->vtbl->boolean_field(printer, "flipy", (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "dither", "%s",
      v3d_desc_dither((v3d_dither_t)(uint32_t)(packed[1] & 3)));
   printer->vtbl->field(printer, "decimate", "%s", v3d_desc_decimate(
      (v3d_decimate_t)(uint32_t)(packed[1] >> 2 & 3)));
   printer->vtbl->field(printer, "pixel_format", "%s", v3d_desc_pixel_format(
      (v3d_pixel_format_t)((uint32_t)(packed[1] >> 4) |
      (uint32_t)(packed[2] & 3) << 4)));
   printer->vtbl->boolean_field(printer, "clear", (uint32_t)(packed[2] >> 2 & 1));
   printer->vtbl->field(printer, "stride", "%" PRIu32 "",
      (uint32_t)(packed[3] >> 4) | (uint32_t)packed[4] << 4 |
      (uint32_t)packed[5] << 12);
   printer->vtbl->field(printer, "height", "%" PRIu32 "",
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
   printer->vtbl->addr_field(printer, "addr",
      (uint32_t)packed[8] | (uint32_t)packed[9] << 8 | (uint32_t)packed[10] << 16 |
      (uint32_t)packed[11] << 24);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_load(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "buffer", "%s", v3d_desc_ldst_buf(
      (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "memory_format", "%s", v3d_desc_memory_format(
      (v3d_memory_format_t)(uint32_t)(packed[0] >> 4 & 7)));
   printer->vtbl->boolean_field(printer, "flipy", (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "decimate", "%s", v3d_desc_decimate(
      (v3d_decimate_t)(uint32_t)(packed[1] >> 2 & 3)));
   printer->vtbl->field(printer, "pixel_format", "%s", v3d_desc_pixel_format(
      (v3d_pixel_format_t)((uint32_t)(packed[1] >> 4) |
      (uint32_t)(packed[2] & 3) << 4)));
   printer->vtbl->field(printer, "stride", "%" PRIu32 "",
      (uint32_t)(packed[3] >> 4) | (uint32_t)packed[4] << 4 |
      (uint32_t)packed[5] << 12);
   printer->vtbl->field(printer, "height", "%" PRIu32 "",
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
   printer->vtbl->addr_field(printer, "addr",
      (uint32_t)packed[8] | (uint32_t)packed[9] << 8 | (uint32_t)packed[10] << 16 |
      (uint32_t)packed[11] << 24);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_store_subsample(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_store_subsample_ex(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "eof", (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "disable_owo_or_double_buf_swap",
      (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "disable_depth_clear",
      (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->boolean_field(printer, "disable_stencil_clear",
      (uint32_t)(packed[0] >> 3 & 1));
   printer->vtbl->boolean_field(printer, "disable_color_clear",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "stencil_store",
      (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "depth_store", (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "disable_rt_store_mask", "0x%02x",
      (uint32_t)packed[1]);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_load(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "stencil_load",
      (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "depth_load", (uint32_t)(packed[0] >> 7));
   printer->vtbl->field(printer, "disable_rt_load_mask", "0x%02x",
      (uint32_t)packed[1]);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_end_tile(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_store_general(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "buffer", "%s", v3d_desc_ldst_buf(
      (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->boolean_field(printer, "raw_mode",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "disable_depth_clear",
      (uint32_t)(packed[0] >> 5 & 1));
   printer->vtbl->boolean_field(printer, "disable_stencil_clear",
      (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "disable_color_clear",
      (uint32_t)(packed[0] >> 7));
   printer->vtbl->boolean_field(printer, "eof", (uint32_t)(packed[1] & 1));
   printer->vtbl->boolean_field(printer, "disable_double_buf_swap",
      (uint32_t)(packed[1] >> 1 & 1));
   printer->vtbl->field(printer, "memory_format", "%s",
      v3d_desc_ldst_memory_format(
      (v3d_ldst_memory_format_t)(uint32_t)(packed[1] >> 2 & 1)));
   printer->vtbl->field(printer, "uif_height_in_ub", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 3) | (uint32_t)packed[2] << 5);
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)packed[3] | (uint32_t)packed[4] << 8 | (uint32_t)packed[5] << 16) <<
      8);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_load_general(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "buffer", "%s", v3d_desc_ldst_buf(
      (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->boolean_field(printer, "raw_mode",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->field(printer, "memory_format", "%s",
      v3d_desc_ldst_memory_format(
      (v3d_ldst_memory_format_t)(uint32_t)(packed[1] >> 2 & 1)));
   printer->vtbl->field(printer, "uif_height_in_ub", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 3) | (uint32_t)packed[2] << 5);
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)packed[3] | (uint32_t)packed[4] << 8 | (uint32_t)packed[5] << 16) <<
      8);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_TF_EXPLICIT_FC
void v3d_cl_print_tf_draw_flush_and_count(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_32BIT_INDS
void v3d_cl_print_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "index_type", "%s", v3d_desc_index_type(
      (v3d_index_type_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "num_indices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)(packed[4] & 127) << 24);
   printer->vtbl->boolean_field(printer, "prim_restart",
      (uint32_t)(packed[4] >> 7));
   printer->vtbl->addr_field(printer, "indices_addr",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->field(printer, "min_index", "%" PRIu32 "",
      (uint32_t)packed[13] | (uint32_t)packed[14] << 8 | (uint32_t)packed[15] << 16 |
      (uint32_t)packed[16] << 24);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_print_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "index_type", "%s", v3d_desc_index_type(
      (v3d_index_type_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "num_indices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->addr_field(printer, "indices_addr",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)(packed[12] & 127) << 24);
   printer->vtbl->boolean_field(printer, "prim_restart",
      (uint32_t)(packed[12] >> 7));
   printer->vtbl->field(printer, "min_index", "%" PRIu32 "",
      (uint32_t)packed[13] | (uint32_t)packed[14] << 8 | (uint32_t)packed[15] << 16 |
      (uint32_t)packed[16] << 24);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_indirect_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "index_type", "%s", v3d_desc_index_type(
      (v3d_index_type_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "num_indirect", "%" PRIu32 "", gfx_check_urange(
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)(packed[4] & 127) << 24, 1, 0x7fffffff));
   printer->vtbl->boolean_field(printer, "prim_restart",
      (uint32_t)(packed[4] >> 7));
   printer->vtbl->addr_field(printer, "indirect_addr",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->addr_field(printer, "indices_addr",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->field(printer, "indirect_stride", "%" PRIu32 "",
      (uint32_t)packed[13] << 2);
   printer->vtbl->end(printer);
}
#if V3D_HAS_32BIT_INDS
void v3d_cl_print_indexed_instanced_prim_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "index_type", "%s", v3d_desc_index_type(
      (v3d_index_type_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "num_indices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)(packed[4] & 127) << 24);
   printer->vtbl->boolean_field(printer, "prim_restart",
      (uint32_t)(packed[4] >> 7));
   printer->vtbl->field(printer, "num_instances", "%" PRIu32 "",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->addr_field(printer, "indices_addr",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[13] | (uint32_t)packed[14] << 8 | (uint32_t)packed[15] << 16 |
      (uint32_t)packed[16] << 24);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_print_indexed_instanced_prim_list(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "index_type", "%s", v3d_desc_index_type(
      (v3d_index_type_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "num_indices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->field(printer, "num_instances", "%" PRIu32 "",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->addr_field(printer, "indices_addr",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[13] | (uint32_t)packed[14] << 8 | (uint32_t)packed[15] << 16 |
      (uint32_t)(packed[16] & 127) << 24);
   printer->vtbl->boolean_field(printer, "prim_restart",
      (uint32_t)(packed[16] >> 7));
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "num_vertices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->field(printer, "first_index", "%" PRIu32 "",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_indirect_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "num_indirect", "%" PRIu32 "", gfx_check_urange(
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24, 1, 0xffffffff));
   printer->vtbl->addr_field(printer, "indirect_addr",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->field(printer, "indirect_stride", "%" PRIu32 "",
      (uint32_t)packed[9] << 2);
   printer->vtbl->end(printer);
}
void v3d_cl_print_vertex_array_instanced_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "num_vertices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->field(printer, "num_instances", "%" PRIu32 "",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->field(printer, "first_index", "%" PRIu32 "",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_vertex_array_single_instance_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->field(printer, "num_vertices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->field(printer, "instance_id", "%" PRIu32 "",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->field(printer, "first_index", "%" PRIu32 "",
      (uint32_t)packed[9] | (uint32_t)packed[10] << 8 | (uint32_t)packed[11] << 16 |
      (uint32_t)packed[12] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_base_vertex_base_instance(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "base_vertex", "%" PRId32 "",
      (int32_t)((uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24));
   printer->vtbl->field(printer, "base_instance", "%" PRIu32 "",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->end(printer);
}
#if V3D_HAS_32BIT_INDS
void v3d_cl_print_indirect_primitive_limits(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   printer->vtbl->field(printer, "max_instance", "%" PRIu32 "",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->field(printer, "index_buffer_size", "%" PRIu32 "",
      (uint32_t)packed[8] | (uint32_t)packed[9] << 8 | (uint32_t)packed[10] << 16 |
      (uint32_t)packed[11] << 24);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_print_indirect_primitive_limits(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "max_index", "%" PRIu32 "",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16);
   printer->vtbl->field(printer, "max_instance", "%" PRIu32 "",
      (uint32_t)packed[3] | (uint32_t)packed[4] << 8 | (uint32_t)packed[5] << 16 |
      (uint32_t)packed[6] << 24);
   printer->vtbl->field(printer, "index_buffer_size", "%" PRIu32 "",
      (uint32_t)packed[7] | (uint32_t)packed[8] << 8 | (uint32_t)packed[9] << 16 |
      (uint32_t)packed[10] << 24);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_vg_coord_array_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->boolean_field(printer, "continuation",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->field(printer, "num_vertices", "%" PRIu32 "",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24);
   printer->vtbl->addr_field(printer, "coords_addr",
      (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16 |
      (uint32_t)packed[8] << 24);
   printer->vtbl->end(printer);
}
void v3d_cl_print_vg_inline_prims(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "prim_mode", "%s", v3d_desc_prim_mode(
      (v3d_prim_mode_t)(uint32_t)(packed[0] & 63)));
   printer->vtbl->boolean_field(printer, "continuation",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->end(printer);
}
void v3d_cl_print_compressed_prim_list_iid_zero(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_compressed_prim_list_current_iid(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_INLINE_CLIP
void v3d_cl_print_clipped_prim(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "clip", false);
   printer->vtbl->boolean_field(printer, "0", (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "1", (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "2", (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->end(printer);
   printer->vtbl->boolean_field(printer, "flat_zw", (uint32_t)(packed[0] >> 3 & 1));
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_BASEINSTANCE
void v3d_cl_print_set_instance_id(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "instance_id", "%" PRIu32 "",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_prim_list_format(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "n_verts", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 63) + 1, 1, 32));
   printer->vtbl->boolean_field(printer, "xy", (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "d3dpvsf", (uint32_t)(packed[0] >> 7));
   printer->vtbl->end(printer);
}
#if V3D_HAS_TNG
void v3d_cl_print_serial_number_list_start(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "initial_block_size", "%s",
      v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3)));
   printer->vtbl->addr_field(printer, "address",
      ((uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6 |
      (uint32_t)packed[2] << 14 | (uint32_t)packed[3] << 22) << 2);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_gl_shader(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_attr_arrays", "%" PRIu32 "",
      gfx_unpack_uint_0_is_max((uint32_t)(packed[0] & 31), 5));
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5);
   printer->vtbl->end(printer);
}
void v3d_cl_print_vg_shader(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->addr_field(printer, NULL,
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_print_vg_inline_shader(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "fs", false);
   printer->vtbl->field(printer, "threading", "%s", v3d_desc_threading(
      (v3d_threading_t)(uint32_t)(packed[0] & 3)));
   printer->vtbl->boolean_field(printer, "propagate_nans",
      (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)(packed[0] >> 3) | (uint32_t)packed[1] << 5 |
      (uint32_t)packed[2] << 13 | (uint32_t)packed[3] << 21) << 3);
   printer->vtbl->addr_field(printer, "unifs_addr",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#if V3D_HAS_NEW_TF
void v3d_cl_print_vcm_cache_size(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_batches_bin", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 15), 1, 4));
   printer->vtbl->field(printer, "num_batches_render", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] >> 4), 1, 4));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_print_prim_counts_feedback(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "operation", "%s", v3d_desc_pcf_operation(
      (v3d_pcf_operation_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->boolean_field(printer, "rw64", (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_print_transform_feedback_buffer(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "buffer_num", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 3), 0, 3));
   printer->vtbl->field(printer, "size_words", "%" PRIu32 "",
      (uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6 |
      (uint32_t)packed[2] << 14 | (uint32_t)packed[3] << 22);
   printer->vtbl->addr_field(printer, "buffer_addr",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_print_transform_feedback_specs(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_specs", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 31), 0, 16));
   printer->vtbl->boolean_field(printer, "enable", (uint32_t)(packed[0] >> 7));
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_cl_print_vcm_cache_size(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_batches_bin", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 15), 1, 4));
   printer->vtbl->field(printer, "num_batches_render", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] >> 4), 1, 4));
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_cl_print_transform_feedback_enable(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "id", "%" PRIu32 "", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "num_addrs", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[1] & 7), 0, 4));
   printer->vtbl->field(printer, "num_specs", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[1] >> 3), 1, 16));
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_flush_transform_feedback_data(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_l1_cache_flush_control(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "icache_clear_slice_0",
      (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "icache_clear_slice_1",
      (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "icache_clear_slice_2",
      (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->boolean_field(printer, "icache_clear_slice_3",
      (uint32_t)(packed[0] >> 3 & 1));
   printer->vtbl->boolean_field(printer, "ucache_clear_slice_0",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "ucache_clear_slice_1",
      (uint32_t)(packed[0] >> 5 & 1));
   printer->vtbl->boolean_field(printer, "ucache_clear_slice_2",
      (uint32_t)(packed[0] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "ucache_clear_slice_3",
      (uint32_t)(packed[0] >> 7));
   printer->vtbl->boolean_field(printer, "tmu_data_cache_clear_0",
      (uint32_t)(packed[1] & 1));
   printer->vtbl->boolean_field(printer, "tmu_data_cache_clear_1",
      (uint32_t)(packed[1] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "tmu_data_cache_clear_2",
      (uint32_t)(packed[1] >> 2 & 1));
   printer->vtbl->boolean_field(printer, "tmu_data_cache_clear_3",
      (uint32_t)(packed[1] >> 3 & 1));
   printer->vtbl->boolean_field(printer, "tmu_config_cache_clear_0",
      (uint32_t)(packed[1] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "tmu_config_cache_clear_1",
      (uint32_t)(packed[1] >> 5 & 1));
   printer->vtbl->boolean_field(printer, "tmu_config_cache_clear_2",
      (uint32_t)(packed[1] >> 6 & 1));
   printer->vtbl->boolean_field(printer, "tmu_config_cache_clear_3",
      (uint32_t)(packed[1] >> 7));
   printer->vtbl->end(printer);
}
void v3d_cl_print_l2t_cache_flush_control(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->addr_field(printer, "l2t_flush_start_address",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   printer->vtbl->addr_field(printer, "l2t_flush_end_address",
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
   printer->vtbl->field(printer, "l2t_flush_mode", "%s", v3d_desc_l2t_flush_mode(
      (v3d_l2t_flush_mode_t)(uint32_t)(packed[8] & 3)));
   printer->vtbl->end(printer);
}
void v3d_cl_print_l2c_cache_flush(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_stencil_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "reference", "0x%02x", (uint32_t)packed[0]);
   printer->vtbl->field(printer, "mask", "0x%02x", (uint32_t)packed[1]);
   printer->vtbl->field(printer, "func", "%s", v3d_desc_compare_func(
      (v3d_compare_func_t)(uint32_t)(packed[2] & 7)));
   printer->vtbl->field(printer, "fail_op", "%s", v3d_desc_stencil_op(
      (v3d_stencil_op_t)(uint32_t)(packed[2] >> 3 & 7)));
   printer->vtbl->field(printer, "depth_fail_op", "%s", v3d_desc_stencil_op(
      (v3d_stencil_op_t)((uint32_t)(packed[2] >> 6) |
      (uint32_t)(packed[3] & 1) << 2)));
   printer->vtbl->field(printer, "pass_op", "%s", v3d_desc_stencil_op(
      (v3d_stencil_op_t)(uint32_t)(packed[3] >> 1 & 7)));
   printer->vtbl->boolean_field(printer, "front_cfg",
      (uint32_t)(packed[3] >> 4 & 1));
   printer->vtbl->boolean_field(printer, "back_cfg",
      (uint32_t)(packed[3] >> 5 & 1));
   printer->vtbl->field(printer, "write_mask", "0x%02x", (uint32_t)packed[4]);
   printer->vtbl->end(printer);
}
#if !V3D_HAS_PER_RT_BLEND
void v3d_cl_print_blend_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "a_eqn", "%s", v3d_desc_blend_eqn(
      (v3d_blend_eqn_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "a_src", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[0] >> 4)));
   printer->vtbl->field(printer, "a_dst", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[1] & 15)));
   printer->vtbl->field(printer, "c_eqn", "%s", v3d_desc_blend_eqn(
      (v3d_blend_eqn_t)(uint32_t)(packed[1] >> 4)));
   printer->vtbl->field(printer, "c_src", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[2] & 15)));
   printer->vtbl->field(printer, "c_dst", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[2] >> 4)));
   printer->vtbl->field(printer, "vg_mode", "%s", v3d_desc_blend_vg_mode(
      (v3d_blend_vg_mode_t)(uint32_t)(packed[3] >> 4 & 3)));
   printer->vtbl->end(printer);
}
#endif
#if V3D_HAS_PER_RT_BLEND
void v3d_cl_print_blend_enables(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "0x%02x", (uint32_t)packed[0]);
}
#endif
#if V3D_HAS_PER_RT_BLEND
void v3d_cl_print_blend_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "a_eqn", "%s", v3d_desc_blend_eqn(
      (v3d_blend_eqn_t)(uint32_t)(packed[0] & 15)));
   printer->vtbl->field(printer, "a_src", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[0] >> 4)));
   printer->vtbl->field(printer, "a_dst", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[1] & 15)));
   printer->vtbl->field(printer, "c_eqn", "%s", v3d_desc_blend_eqn(
      (v3d_blend_eqn_t)(uint32_t)(packed[1] >> 4)));
   printer->vtbl->field(printer, "c_src", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[2] & 15)));
   printer->vtbl->field(printer, "c_dst", "%s", v3d_desc_blend_mul(
      (v3d_blend_mul_t)(uint32_t)(packed[2] >> 4)));
   printer->vtbl->field(printer, "rt_mask", "0x%01x", (uint32_t)(packed[3] & 15));
   printer->vtbl->field(printer, "vg_mode", "%s", v3d_desc_blend_vg_mode(
      (v3d_blend_vg_mode_t)(uint32_t)(packed[3] >> 4 & 3)));
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_blend_ccolor(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "r", "%.5g", gfx_float16_to_float(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8));
   printer->vtbl->field(printer, "g", "%.5g", gfx_float16_to_float(
      (uint32_t)packed[2] | (uint32_t)packed[3] << 8));
   printer->vtbl->field(printer, "b", "%.5g", gfx_float16_to_float(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8));
   printer->vtbl->field(printer, "a", "%.5g", gfx_float16_to_float(
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8));
   printer->vtbl->end(printer);
}
void v3d_cl_print_color_wmasks(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "0x%08x",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_print_zero_all_centroid_flags(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_zero_all_flatshade_flags(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_vary_flags(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "offset", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[0] & 15), 0, 2));
   printer->vtbl->field(printer, "lower_action", "%s", v3d_desc_flags_action(
      (v3d_flags_action_t)(uint32_t)(packed[0] >> 4 & 3)));
   printer->vtbl->field(printer, "higher_action", "%s", v3d_desc_flags_action(
      (v3d_flags_action_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->field(printer, "flags", "0x%06x",
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16);
   printer->vtbl->end(printer);
}
void v3d_cl_print_sample_coverage(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
}
void v3d_cl_print_occlusion_query_counter_enable(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->addr_field(printer, NULL,
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_print_cfg_bits(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->boolean_field(printer, "front_prims", (uint32_t)(packed[0] & 1));
   printer->vtbl->boolean_field(printer, "back_prims",
      (uint32_t)(packed[0] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "cwise_is_front",
      (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->boolean_field(printer, "depth_offset",
      (uint32_t)(packed[0] >> 3 & 1));
   printer->vtbl->boolean_field(printer, "aa_lines",
      (uint32_t)(packed[0] >> 4 & 1));
   printer->vtbl->field(printer, "rast_oversample", "%s",
      v3d_desc_ms((v3d_ms_t)(uint32_t)(packed[0] >> 6)));
   printer->vtbl->boolean_field(printer, "cov_pipe", (uint32_t)(packed[1] & 1));
   printer->vtbl->field(printer, "cov_update", "%s", v3d_desc_cov_update(
      (v3d_cov_update_t)(uint32_t)(packed[1] >> 1 & 3)));
   printer->vtbl->boolean_field(printer, "wireframe_tris",
      (uint32_t)(packed[1] >> 3 & 1));
   printer->vtbl->field(printer, "depth_test", "%s", v3d_desc_compare_func(
      (v3d_compare_func_t)(uint32_t)(packed[1] >> 4 & 7)));
   printer->vtbl->boolean_field(printer, "depth_update",
      (uint32_t)(packed[1] >> 7));
   printer->vtbl->boolean_field(printer, "ez", (uint32_t)(packed[2] & 1));
   printer->vtbl->boolean_field(printer, "ez_update",
      (uint32_t)(packed[2] >> 1 & 1));
   printer->vtbl->boolean_field(printer, "stencil", (uint32_t)(packed[2] >> 2 & 1));
   printer->vtbl->boolean_field(printer, "blend", (uint32_t)(packed[2] >> 3 & 1));
   printer->vtbl->field(printer, "wireframe_mode", "%s", v3d_desc_wireframe_mode(
      (v3d_wireframe_mode_t)(uint32_t)(packed[2] >> 4 & 1)));
   printer->vtbl->boolean_field(printer, "d3d_prov_vtx",
      (uint32_t)(packed[2] >> 5 & 1));
   printer->vtbl->end(printer);
}
void v3d_cl_print_point_size(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
}
void v3d_cl_print_line_width(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->field(printer, NULL, "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
}
void v3d_cl_print_depth_offset(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "factor", "%.4g", gfx_float_from_bits(
      ((uint32_t)packed[0] | (uint32_t)packed[1] << 8) << 16));
   printer->vtbl->field(printer, "units", "%.4g", gfx_float_from_bits(
      ((uint32_t)packed[2] | (uint32_t)packed[3] << 8) << 16));
   printer->vtbl->end(printer);
}
void v3d_cl_print_clip(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "x", "%" PRIu32 "",
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8);
   printer->vtbl->field(printer, "y", "%" PRIu32 "",
      (uint32_t)packed[2] | (uint32_t)packed[3] << 8);
   printer->vtbl->field(printer, "width", "%" PRIu32 "", gfx_check_urange(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 1, 0x1000));
   printer->vtbl->field(printer, "height", "%" PRIu32 "", gfx_check_urange(
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8, 1, 0x1000));
   printer->vtbl->end(printer);
}
void v3d_cl_print_viewport_offset(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "x", "%" PRId32 "",
      (int32_t)((uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24));
   printer->vtbl->field(printer, "y", "%" PRId32 "",
      (int32_t)((uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24));
   printer->vtbl->end(printer);
}
void v3d_cl_print_clipz(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "min", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
   printer->vtbl->field(printer, "max", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24));
   printer->vtbl->end(printer);
}
void v3d_cl_print_clipper_xy(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "scale_x", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
   printer->vtbl->field(printer, "scale_y", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24));
   printer->vtbl->end(printer);
}
void v3d_cl_print_clipper_z(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "scale", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24));
   printer->vtbl->field(printer, "offset", "%.9g", gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24));
   printer->vtbl->end(printer);
}
#if V3D_HAS_RENDER_LAYERS
void v3d_cl_print_num_layers(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "num_layers", "%" PRIu32 "",
      (uint32_t)packed[0] + 1);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_tile_binning_mode_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "part1", false);
      printer->vtbl->boolean_field(printer, "auto_init_tile_state",
         (uint32_t)(packed[0] >> 1 & 1));
      printer->vtbl->field(printer, "tile_alloc_initial_block_size", "%s",
         v3d_desc_tile_alloc_block_size(
         (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] >> 2 & 3)));
      printer->vtbl->field(printer, "tile_alloc_block_size", "%s",
         v3d_desc_tile_alloc_block_size(
         (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] >> 4 & 3)));
      printer->vtbl->addr_field(printer, "tile_state_addr",
         ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
         (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6);
      printer->vtbl->field(printer, "w_in_tiles", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)packed[4] | (uint32_t)(packed[5] & 15) << 8, 1, 0xfff));
      printer->vtbl->field(printer, "h_in_tiles", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)(packed[5] >> 4) | (uint32_t)packed[6] << 4, 1, 0xfff));
      printer->vtbl->field(printer, "num_rts", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[7] & 15), 0, 8));
      printer->vtbl->field(printer, "max_bpp", "%s", v3d_desc_rt_bpp(
         (v3d_rt_bpp_t)(uint32_t)(packed[7] >> 4 & 3)));
      printer->vtbl->boolean_field(printer, "ms_mode", (uint32_t)(packed[7] >> 6 & 1));
      printer->vtbl->boolean_field(printer, "double_buffer",
         (uint32_t)(packed[7] >> 7));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 1) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "part2", false);
      printer->vtbl->field(printer, "tile_alloc_size", "%" PRIu32 "",
         ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
         (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6);
      printer->vtbl->addr_field(printer, "tile_alloc_addr",
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_tile_rendering_mode_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 15) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "common", false);
      printer->vtbl->field(printer, "num_rts", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4) + 1, 1, 8));
      printer->vtbl->field(printer, "frame_width", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 1, 0xffff));
      printer->vtbl->field(printer, "frame_height", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8, 1, 0xffff));
      printer->vtbl->field(printer, "max_bpp", "%s",
         v3d_desc_rt_bpp((v3d_rt_bpp_t)(uint32_t)(packed[5] & 3)));
      printer->vtbl->boolean_field(printer, "ms_mode", (uint32_t)(packed[5] >> 2 & 1));
      printer->vtbl->boolean_field(printer, "double_buffer",
         (uint32_t)(packed[5] >> 3 & 1));
      printer->vtbl->boolean_field(printer, "cov_mode",
         (uint32_t)(packed[5] >> 4 & 1));
      printer->vtbl->field(printer, "ez_direction", "%s", v3d_desc_ez_direction(
         (v3d_ez_direction_t)(uint32_t)(packed[5] >> 5 & 1)));
      printer->vtbl->boolean_field(printer, "ez_disable",
         (uint32_t)(packed[5] >> 6 & 1));
      printer->vtbl->field(printer, "internal_depth_type", "%s", v3d_desc_depth_type(
         (v3d_depth_type_t)((uint32_t)(packed[5] >> 7) |
         (uint32_t)(packed[6] & 7) << 1)));
      printer->vtbl->boolean_field(printer, "early_ds_clear",
         (uint32_t)(packed[6] >> 3 & 1));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "color", false);
      printer->vtbl->begin(printer, V3D_PRINTER_ARRAY, "rts", false);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "0", false);
      printer->vtbl->field(printer, "internal_bpp", "%s", v3d_desc_rt_bpp(
         (v3d_rt_bpp_t)(uint32_t)(packed[0] >> 4 & 3)));
      printer->vtbl->field(printer, "internal_type", "%s", v3d_desc_rt_type(
         (v3d_rt_type_t)((uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2)));
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "1", false);
      printer->vtbl->field(printer, "internal_bpp", "%s", v3d_desc_rt_bpp(
         (v3d_rt_bpp_t)(uint32_t)(packed[1] >> 2 & 3)));
      printer->vtbl->field(printer, "internal_type", "%s",
         v3d_desc_rt_type((v3d_rt_type_t)(uint32_t)(packed[1] >> 4)));
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "2", false);
      printer->vtbl->field(printer, "internal_bpp", "%s",
         v3d_desc_rt_bpp((v3d_rt_bpp_t)(uint32_t)(packed[2] & 3)));
      printer->vtbl->field(printer, "internal_type", "%s", v3d_desc_rt_type(
         (v3d_rt_type_t)(uint32_t)(packed[2] >> 2 & 15)));
      printer->vtbl->end(printer);
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "3", false);
      printer->vtbl->field(printer, "internal_bpp", "%s",
         v3d_desc_rt_bpp((v3d_rt_bpp_t)(uint32_t)(packed[2] >> 6)));
      printer->vtbl->field(printer, "internal_type", "%s",
         v3d_desc_rt_type((v3d_rt_type_t)(uint32_t)(packed[3] & 15)));
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "zs_clear_values", false);
      printer->vtbl->field(printer, "stencil_clear", "0x%02x", (uint32_t)packed[1]);
      printer->vtbl->field(printer, "depth_clear", "%.9g", gfx_float_from_bits(
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part1", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_0", "0x%08x",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->field(printer, "clear_col_1_andm24", "0x%06x",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 4)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part2", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_1_shift24", "0x%02x",
         (uint32_t)packed[1]);
      printer->vtbl->field(printer, "clear_col_2", "0x%08x",
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24);
      printer->vtbl->field(printer, "clear_col_3_andm16", "0x%04x",
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 5)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part3", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_3_shift16", "0x%04x",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_print_tile_rendering_mode_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->begin(printer, V3D_PRINTER_UNION, "u", true);
   if ((uint32_t)(packed[0] & 15) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "common", false);
      printer->vtbl->field(printer, "num_rts", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4) + 1, 1, 8));
      printer->vtbl->field(printer, "frame_width", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 1, 0xffff));
      printer->vtbl->field(printer, "frame_height", "%" PRIu32 "", gfx_check_urange(
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8, 1, 0xffff));
      printer->vtbl->field(printer, "max_bpp", "%s",
         v3d_desc_rt_bpp((v3d_rt_bpp_t)(uint32_t)(packed[5] & 3)));
      printer->vtbl->boolean_field(printer, "ms_mode", (uint32_t)(packed[5] >> 2 & 1));
      printer->vtbl->boolean_field(printer, "double_buffer",
         (uint32_t)(packed[5] >> 3 & 1));
      printer->vtbl->boolean_field(printer, "cov_mode",
         (uint32_t)(packed[5] >> 4 & 1));
      printer->vtbl->field(printer, "ez_direction", "%s", v3d_desc_ez_direction(
         (v3d_ez_direction_t)(uint32_t)(packed[5] >> 5 & 1)));
      printer->vtbl->boolean_field(printer, "ez_disable",
         (uint32_t)(packed[5] >> 6 & 1));
      printer->vtbl->boolean_field(printer, "stencil_store",
         (uint32_t)(packed[6] >> 6 & 1));
      printer->vtbl->boolean_field(printer, "depth_store", (uint32_t)(packed[6] >> 7));
      printer->vtbl->field(printer, "disable_rt_store_mask", "0x%02x",
         (uint32_t)packed[7]);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 1 && (uint32_t)(packed[0] >> 4) == 0)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "z_stencil", false);
      printer->vtbl->field(printer, "internal_type", "%s", v3d_desc_depth_type(
         (v3d_depth_type_t)(uint32_t)(packed[1] >> 2 & 15)));
      printer->vtbl->field(printer, "decimate_mode", "%s", v3d_desc_decimate(
         (v3d_decimate_t)(uint32_t)(packed[1] >> 6)));
      printer->vtbl->field(printer, "output_format", "%s", v3d_desc_depth_format(
         (v3d_depth_format_t)(uint32_t)(packed[2] & 63)));
      printer->vtbl->field(printer, "memory_format", "%s", v3d_desc_memory_format(
         (v3d_memory_format_t)((uint32_t)(packed[2] >> 6) |
         (uint32_t)(packed[3] & 1) << 2)));
      printer->vtbl->field(printer, "uif_height_in_ub", "%" PRIu32 "",
         (uint32_t)(packed[3] >> 1) | (uint32_t)(packed[4] & 63) << 7);
      printer->vtbl->addr_field(printer, "addr",
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 1 && (uint32_t)(packed[0] >> 4) == 1)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "separate_stencil", false);
      printer->vtbl->field(printer, "decimate_mode", "%s", v3d_desc_decimate(
         (v3d_decimate_t)(uint32_t)(packed[1] >> 6)));
      printer->vtbl->field(printer, "memory_format", "%s", v3d_desc_memory_format(
         (v3d_memory_format_t)((uint32_t)(packed[2] >> 6) |
         (uint32_t)(packed[3] & 1) << 2)));
      printer->vtbl->field(printer, "uif_height_in_ub", "%" PRIu32 "",
         (uint32_t)(packed[3] >> 1) | (uint32_t)(packed[4] & 63) << 7);
      printer->vtbl->addr_field(printer, "addr",
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 2)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "color", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "internal_bpp", "%s",
         v3d_desc_rt_bpp((v3d_rt_bpp_t)(uint32_t)(packed[1] & 3)));
      printer->vtbl->field(printer, "internal_type", "%s", v3d_desc_rt_type(
         (v3d_rt_type_t)(uint32_t)(packed[1] >> 2 & 15)));
      printer->vtbl->field(printer, "decimate_mode", "%s", v3d_desc_decimate(
         (v3d_decimate_t)(uint32_t)(packed[1] >> 6)));
      printer->vtbl->field(printer, "output_format", "%s", v3d_desc_pixel_format(
         (v3d_pixel_format_t)(uint32_t)(packed[2] & 63)));
      printer->vtbl->field(printer, "dither_mode", "%s",
         v3d_desc_dither((v3d_dither_t)(uint32_t)(packed[2] >> 6)));
      printer->vtbl->field(printer, "memory_format", "%s", v3d_desc_memory_format(
         (v3d_memory_format_t)(uint32_t)(packed[3] & 7)));
      printer->vtbl->boolean_field(printer, "flipy", (uint32_t)(packed[3] >> 3 & 1));
      printer->vtbl->field(printer, "pad", "%" PRIu32 "", (uint32_t)(packed[3] >> 4));
      printer->vtbl->addr_field(printer, "addr",
         (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
         (uint32_t)packed[7] << 24);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 3)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "zs_clear_values", false);
      printer->vtbl->field(printer, "stencil_clear", "0x%02x", (uint32_t)packed[1]);
      printer->vtbl->field(printer, "depth_clear", "%.9g", gfx_float_from_bits(
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24));
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 4)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part1", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_0", "0x%08x",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24);
      printer->vtbl->field(printer, "clear_col_1_andm24", "0x%06x",
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 5)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part2", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_1_shift24", "0x%02x",
         (uint32_t)packed[1]);
      printer->vtbl->field(printer, "clear_col_2", "0x%08x",
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24);
      printer->vtbl->field(printer, "clear_col_3_andm16", "0x%04x",
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
      printer->vtbl->end(printer);
   }
   else if ((uint32_t)(packed[0] & 15) == 6)
   {
      printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, "clear_colors_part3", false);
      printer->vtbl->field(printer, "rt", "%" PRIu32 "",
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7));
      printer->vtbl->field(printer, "clear_col_3_shift16", "0x%04x",
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8);
      printer->vtbl->field(printer, "raster_padded_width_or_nonraster_height",
         "%" PRIu32 "", gfx_check_urange((uint32_t)packed[3] | (uint32_t)packed[4] << 8,
         0, 0x1fff));
      printer->vtbl->field(printer, "uif_height_in_ub", "%" PRIu32 "",
         (uint32_t)packed[5] | (uint32_t)(packed[6] & 31) << 8);
      printer->vtbl->end(printer);
   }
   else
   {
      unreachable();
   }
   printer->vtbl->end(printer);
   printer->vtbl->end(printer);
}
#endif
void v3d_cl_print_multicore_rendering_supertile_cfg(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "supertile_w_in_tiles", "%" PRIu32 "",
      (uint32_t)packed[0] + 1);
   printer->vtbl->field(printer, "supertile_h_in_tiles", "%" PRIu32 "",
      (uint32_t)packed[1] + 1);
   printer->vtbl->field(printer, "frame_w_in_supertiles", "%" PRIu32 "",
      gfx_check_urange((uint32_t)packed[2], 1, 255));
   printer->vtbl->field(printer, "frame_h_in_supertiles", "%" PRIu32 "",
      gfx_check_urange((uint32_t)packed[3], 1, 255));
   printer->vtbl->field(printer, "frame_w_in_tiles", "%" PRIu32 "",
      gfx_check_urange((uint32_t)packed[4] | (uint32_t)(packed[5] & 15) << 8, 1,
      0xfff));
   printer->vtbl->field(printer, "frame_h_in_tiles", "%" PRIu32 "",
      gfx_check_urange((uint32_t)(packed[5] >> 4) | (uint32_t)packed[6] << 4, 1,
      0xfff));
   printer->vtbl->boolean_field(printer, "multicore", (uint32_t)(packed[7] & 1));
   printer->vtbl->field(printer, "supertile_order", "%s", v3d_desc_supertile_order(
      (v3d_supertile_order_t)(uint32_t)(packed[7] >> 4 & 1)));
   printer->vtbl->field(printer, "num_bin_tile_lists", "%" PRIu32 "",
      (uint32_t)(packed[7] >> 5) + 1);
   printer->vtbl->end(printer);
}
void v3d_cl_print_multicore_rendering_tile_list_base(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "set", "%" PRIu32 "", (uint32_t)(packed[0] & 15));
   printer->vtbl->addr_field(printer, "addr",
      ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6);
   printer->vtbl->end(printer);
}
void v3d_cl_print_tile_coords(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "x", "%" PRIu32 "",
      (uint32_t)packed[0] | (uint32_t)(packed[1] & 15) << 8);
   printer->vtbl->field(printer, "y", "%" PRIu32 "",
      (uint32_t)(packed[1] >> 4) | (uint32_t)packed[2] << 4);
   printer->vtbl->end(printer);
}
void v3d_cl_print_implicit_tile_coords(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->end(printer);
}
void v3d_cl_print_tile_list_initial_block_size(const uint8_t *packed, struct v3d_printer *printer)
{
   printer->vtbl->begin(printer, V3D_PRINTER_STRUCT, NULL, false);
   printer->vtbl->field(printer, "block_size", "%s",
      v3d_desc_tile_alloc_block_size(
      (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3)));
   printer->vtbl->boolean_field(printer, "chain", (uint32_t)(packed[0] >> 2 & 1));
   printer->vtbl->end(printer);
}
void v3d_cl_print_instr(const uint8_t *packed_instr, struct v3d_printer *printer)
{
   switch ((v3d_cl_opcode_t)packed_instr[0]) {
   case V3D_CL_HALT: v3d_cl_print_halt(packed_instr + 1, printer); break;
   case V3D_CL_NOP: v3d_cl_print_nop(packed_instr + 1, printer); break;
   case V3D_CL_FLUSH: v3d_cl_print_flush(packed_instr + 1, printer); break;
   case V3D_CL_FLUSH_ALL_STATE: v3d_cl_print_flush_all_state(packed_instr + 1, printer); break;
   case V3D_CL_START_TILE_BINNING: v3d_cl_print_start_tile_binning(packed_instr + 1, printer); break;
   case V3D_CL_INCR_SEMAPHORE: v3d_cl_print_incr_semaphore(packed_instr + 1, printer); break;
   case V3D_CL_WAIT_SEMAPHORE: v3d_cl_print_wait_semaphore(packed_instr + 1, printer); break;
   case V3D_CL_WAIT_PREV_FRAME: v3d_cl_print_wait_prev_frame(packed_instr + 1, printer); break;
   case V3D_CL_ENABLE_Z_ONLY: v3d_cl_print_enable_z_only(packed_instr + 1, printer); break;
   case V3D_CL_DISABLE_Z_ONLY: v3d_cl_print_disable_z_only(packed_instr + 1, printer); break;
   case V3D_CL_END_Z_ONLY: v3d_cl_print_end_z_only(packed_instr + 1, printer); break;
   case V3D_CL_END_RENDER: v3d_cl_print_end_render(packed_instr + 1, printer); break;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: v3d_cl_print_wait_transform_feedback(packed_instr + 1, printer); break;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: v3d_cl_print_branch(packed_instr + 1, printer); break;
   case V3D_CL_RETURN: v3d_cl_print_return(packed_instr + 1, printer); break;
   case V3D_CL_FLUSH_VCD_CACHE: v3d_cl_print_flush_vcd_cache(packed_instr + 1, printer); break;
   case V3D_CL_GENERIC_TILE_LIST: v3d_cl_print_generic_tile_list(packed_instr + 1, printer); break;
   case V3D_CL_BRANCH_IMPLICIT_TILE: v3d_cl_print_branch_implicit_tile(packed_instr + 1, printer); break;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: v3d_cl_print_branch_explicit_supertile(packed_instr + 1, printer); break;
   case V3D_CL_SUPERTILE_COORDS: v3d_cl_print_supertile_coords(packed_instr + 1, printer); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: v3d_cl_print_clear(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: v3d_cl_print_end_loads(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: v3d_cl_print_end_tile(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: v3d_cl_print_store(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_print_load(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: v3d_cl_print_store_subsample(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: v3d_cl_print_store_subsample_ex(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_print_load(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: v3d_cl_print_end_tile(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: v3d_cl_print_store_general(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: v3d_cl_print_load_general(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: v3d_cl_print_tf_draw_flush_and_count(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_print_indexed_prim_list(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_print_indexed_prim_list(packed_instr + 1, printer); break;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: v3d_cl_print_indirect_indexed_prim_list(packed_instr + 1, printer); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_print_indexed_instanced_prim_list(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_print_indexed_instanced_prim_list(packed_instr + 1, printer); break;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: v3d_cl_print_vertex_array_prims(packed_instr + 1, printer); break;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: v3d_cl_print_indirect_vertex_array_prims(packed_instr + 1, printer); break;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: v3d_cl_print_vertex_array_instanced_prims(packed_instr + 1, printer); break;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: v3d_cl_print_vertex_array_single_instance_prims(packed_instr + 1, printer); break;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: v3d_cl_print_base_vertex_base_instance(packed_instr + 1, printer); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_print_indirect_primitive_limits(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_print_indirect_primitive_limits(packed_instr + 1, printer); break;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: v3d_cl_print_vg_coord_array_prims(packed_instr + 1, printer); break;
   case V3D_CL_VG_INLINE_PRIMS: v3d_cl_print_vg_inline_prims(packed_instr + 1, printer); break;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: v3d_cl_print_compressed_prim_list_iid_zero(packed_instr + 1, printer); break;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: v3d_cl_print_compressed_prim_list_current_iid(packed_instr + 1, printer); break;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: v3d_cl_print_clipped_prim(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: v3d_cl_print_set_instance_id(packed_instr + 1, printer); break;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: v3d_cl_print_prim_list_format(packed_instr + 1, printer); break;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: v3d_cl_print_serial_number_list_start(packed_instr + 1, printer); break;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: v3d_cl_print_gl_shader(packed_instr + 1, printer); break;
   case V3D_CL_VG_SHADER: v3d_cl_print_vg_shader(packed_instr + 1, printer); break;
   case V3D_CL_VG_INLINE_SHADER: v3d_cl_print_vg_inline_shader(packed_instr + 1, printer); break;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_print_vcm_cache_size(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: v3d_cl_print_prim_counts_feedback(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: v3d_cl_print_transform_feedback_buffer(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: v3d_cl_print_transform_feedback_specs(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_print_vcm_cache_size(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: v3d_cl_print_transform_feedback_enable(packed_instr + 1, printer); break;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: v3d_cl_print_flush_transform_feedback_data(packed_instr + 1, printer); break;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: v3d_cl_print_l1_cache_flush_control(packed_instr + 1, printer); break;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: v3d_cl_print_l2t_cache_flush_control(packed_instr + 1, printer); break;
   case V3D_CL_L2C_CACHE_FLUSH: v3d_cl_print_l2c_cache_flush(packed_instr + 1, printer); break;
   case V3D_CL_STENCIL_CFG: v3d_cl_print_stencil_cfg(packed_instr + 1, printer); break;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_print_blend_cfg(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: v3d_cl_print_blend_enables(packed_instr + 1, printer); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_print_blend_cfg(packed_instr + 1, printer); break;
#endif
   case V3D_CL_BLEND_CCOLOR: v3d_cl_print_blend_ccolor(packed_instr + 1, printer); break;
   case V3D_CL_COLOR_WMASKS: v3d_cl_print_color_wmasks(packed_instr + 1, printer); break;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: v3d_cl_print_zero_all_centroid_flags(packed_instr + 1, printer); break;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: v3d_cl_print_zero_all_flatshade_flags(packed_instr + 1, printer); break;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: v3d_cl_print_vary_flags(packed_instr + 1, printer); break;
   case V3D_CL_SAMPLE_COVERAGE: v3d_cl_print_sample_coverage(packed_instr + 1, printer); break;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: v3d_cl_print_occlusion_query_counter_enable(packed_instr + 1, printer); break;
   case V3D_CL_CFG_BITS: v3d_cl_print_cfg_bits(packed_instr + 1, printer); break;
   case V3D_CL_POINT_SIZE: v3d_cl_print_point_size(packed_instr + 1, printer); break;
   case V3D_CL_LINE_WIDTH: v3d_cl_print_line_width(packed_instr + 1, printer); break;
   case V3D_CL_DEPTH_OFFSET: v3d_cl_print_depth_offset(packed_instr + 1, printer); break;
   case V3D_CL_CLIP: v3d_cl_print_clip(packed_instr + 1, printer); break;
   case V3D_CL_VIEWPORT_OFFSET: v3d_cl_print_viewport_offset(packed_instr + 1, printer); break;
   case V3D_CL_CLIPZ: v3d_cl_print_clipz(packed_instr + 1, printer); break;
   case V3D_CL_CLIPPER_XY: v3d_cl_print_clipper_xy(packed_instr + 1, printer); break;
   case V3D_CL_CLIPPER_Z: v3d_cl_print_clipper_z(packed_instr + 1, printer); break;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: v3d_cl_print_num_layers(packed_instr + 1, printer); break;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: v3d_cl_print_tile_binning_mode_cfg(packed_instr + 1, printer); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_print_tile_rendering_mode_cfg(packed_instr + 1, printer); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_print_tile_rendering_mode_cfg(packed_instr + 1, printer); break;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: v3d_cl_print_multicore_rendering_supertile_cfg(packed_instr + 1, printer); break;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: v3d_cl_print_multicore_rendering_tile_list_base(packed_instr + 1, printer); break;
   case V3D_CL_TILE_COORDS: v3d_cl_print_tile_coords(packed_instr + 1, printer); break;
   case V3D_CL_IMPLICIT_TILE_COORDS: v3d_cl_print_implicit_tile_coords(packed_instr + 1, printer); break;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: v3d_cl_print_tile_list_initial_block_size(packed_instr + 1, printer); break;
   default: unreachable();
   }
}
void v3d_cl_pack_wait_transform_feedback(uint8_t *packed, const uint32_t *unpacked)
{
   packed[0] = (uint8_t)gfx_bits(*unpacked, 8);
}
void v3d_cl_unpack_wait_transform_feedback(uint32_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0];
}
void v3d_cl_pack_branch(uint8_t *packed, const v3d_addr_t *unpacked)
{
   packed[0] = (uint8_t)*unpacked;
   packed[1] = (uint8_t)(*unpacked >> 8);
   packed[2] = (uint8_t)(*unpacked >> 16);
   packed[3] = (uint8_t)(*unpacked >> 24);
}
void v3d_cl_unpack_branch(v3d_addr_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
}
void v3d_cl_pack_generic_tile_list(uint8_t *packed, const V3D_CL_GENERIC_TILE_LIST_T *unpacked)
{
   packed[0] = (uint8_t)(*unpacked).addr;
   packed[1] = (uint8_t)((*unpacked).addr >> 8);
   packed[2] = (uint8_t)((*unpacked).addr >> 16);
   packed[3] = (uint8_t)((*unpacked).addr >> 24);
   packed[4] = (uint8_t)(*unpacked).end;
   packed[5] = (uint8_t)((*unpacked).end >> 8);
   packed[6] = (uint8_t)((*unpacked).end >> 16);
   packed[7] = (uint8_t)((*unpacked).end >> 24);
}
void v3d_cl_unpack_generic_tile_list(V3D_CL_GENERIC_TILE_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).addr = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
   (*unpacked).end = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
}
void v3d_cl_pack_branch_implicit_tile(uint8_t *packed, const uint32_t *unpacked)
{
   packed[0] = (uint8_t)gfx_bits(*unpacked, 8);
}
void v3d_cl_unpack_branch_implicit_tile(uint32_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0];
}
void v3d_cl_pack_branch_explicit_supertile(uint8_t *packed, const V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   packed[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
   packed[2] = (uint8_t)gfx_bits((*unpacked).supertile, 8);
   packed[3] = (uint8_t)(*unpacked).addr;
   packed[4] = (uint8_t)((*unpacked).addr >> 8);
   packed[5] = (uint8_t)((*unpacked).addr >> 16);
   packed[6] = (uint8_t)((*unpacked).addr >> 24);
}
void v3d_cl_unpack_branch_explicit_supertile(V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).x = (uint32_t)packed[0];
   (*unpacked).y = (uint32_t)packed[1];
   (*unpacked).supertile = (uint32_t)packed[2];
   (*unpacked).addr = (uint32_t)packed[3] | (uint32_t)packed[4] << 8 |
      (uint32_t)packed[5] << 16 | (uint32_t)packed[6] << 24;
}
void v3d_cl_pack_supertile_coords(uint8_t *packed, const V3D_CL_SUPERTILE_COORDS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   packed[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
}
void v3d_cl_unpack_supertile_coords(V3D_CL_SUPERTILE_COORDS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).x = (uint32_t)packed[0];
   (*unpacked).y = (uint32_t)packed[1];
}
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_clear(uint8_t *packed, const V3D_CL_CLEAR_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).rts, 1) |
      (uint8_t)(gfx_bits((*unpacked).depth_stencil, 1) << 1) | (uint8_t)0;
}
void v3d_cl_unpack_clear(V3D_CL_CLEAR_T *unpacked, const uint8_t *packed)
{
   (*unpacked).rts = (uint32_t)(packed[0] & 1);
   (*unpacked).depth_stencil = (uint32_t)(packed[0] >> 1 & 1);
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_store(uint8_t *packed, const V3D_CL_STORE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).dither, 2) |
      (uint8_t)(gfx_bits((*unpacked).decimate, 2) << 2) |
      (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) << 4);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) >> 4) |
      (uint8_t)(gfx_bits((*unpacked).clear, 1) << 2) | (uint8_t)0;
   packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stride, 20) << 4);
   packed[4] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 4);
   packed[5] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 12);
   packed[6] = (uint8_t)gfx_bits((*unpacked).height, 16);
   packed[7] = (uint8_t)(gfx_bits((*unpacked).height, 16) >> 8);
   packed[8] = (uint8_t)(*unpacked).addr;
   packed[9] = (uint8_t)((*unpacked).addr >> 8);
   packed[10] = (uint8_t)((*unpacked).addr >> 16);
   packed[11] = (uint8_t)((*unpacked).addr >> 24);
}
void v3d_cl_unpack_store(V3D_CL_STORE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).buffer = (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15);
   (*unpacked).memory_format = (v3d_memory_format_t)(uint32_t)(packed[0] >> 4 & 7);
   (*unpacked).flipy = (uint32_t)(packed[0] >> 7);
   (*unpacked).dither = (v3d_dither_t)(uint32_t)(packed[1] & 3);
   (*unpacked).decimate = (v3d_decimate_t)(uint32_t)(packed[1] >> 2 & 3);
   (*unpacked).pixel_format = (v3d_pixel_format_t)((uint32_t)(packed[1] >> 4) |
      (uint32_t)(packed[2] & 3) << 4);
   (*unpacked).clear = (uint32_t)(packed[2] >> 2 & 1);
   (*unpacked).stride = (uint32_t)(packed[3] >> 4) | (uint32_t)packed[4] << 4 |
      (uint32_t)packed[5] << 12;
   (*unpacked).height = (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   (*unpacked).addr = (uint32_t)packed[8] | (uint32_t)packed[9] << 8 |
      (uint32_t)packed[10] << 16 | (uint32_t)packed[11] << 24;
}
#endif
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_load(uint8_t *packed, const V3D_CL_LOAD_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).flipy, 1) << 7);
   packed[1] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).decimate, 2) << 2) |
      (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) << 4);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).pixel_format, 6) >> 4) | (uint8_t)0;
   packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stride, 20) << 4);
   packed[4] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 4);
   packed[5] = (uint8_t)(gfx_bits((*unpacked).stride, 20) >> 12);
   packed[6] = (uint8_t)gfx_bits((*unpacked).height, 16);
   packed[7] = (uint8_t)(gfx_bits((*unpacked).height, 16) >> 8);
   packed[8] = (uint8_t)(*unpacked).addr;
   packed[9] = (uint8_t)((*unpacked).addr >> 8);
   packed[10] = (uint8_t)((*unpacked).addr >> 16);
   packed[11] = (uint8_t)((*unpacked).addr >> 24);
}
void v3d_cl_unpack_load(V3D_CL_LOAD_T *unpacked, const uint8_t *packed)
{
   (*unpacked).buffer = (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15);
   (*unpacked).memory_format = (v3d_memory_format_t)(uint32_t)(packed[0] >> 4 & 7);
   (*unpacked).flipy = (uint32_t)(packed[0] >> 7);
   (*unpacked).decimate = (v3d_decimate_t)(uint32_t)(packed[1] >> 2 & 3);
   (*unpacked).pixel_format = (v3d_pixel_format_t)((uint32_t)(packed[1] >> 4) |
      (uint32_t)(packed[2] & 3) << 4);
   (*unpacked).stride = (uint32_t)(packed[3] >> 4) | (uint32_t)packed[4] << 4 |
      (uint32_t)packed[5] << 12;
   (*unpacked).height = (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   (*unpacked).addr = (uint32_t)packed[8] | (uint32_t)packed[9] << 8 |
      (uint32_t)packed[10] << 16 | (uint32_t)packed[11] << 24;
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_store_subsample_ex(uint8_t *packed, const V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_owo_or_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_store, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_store_mask, 8);
}
void v3d_cl_unpack_store_subsample_ex(V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked, const uint8_t *packed)
{
   (*unpacked).eof = (uint32_t)(packed[0] & 1);
   (*unpacked).disable_owo_or_double_buf_swap = (uint32_t)(packed[0] >> 1 & 1);
   (*unpacked).disable_depth_clear = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).disable_stencil_clear = (uint32_t)(packed[0] >> 3 & 1);
   (*unpacked).disable_color_clear = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).stencil_store = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).depth_store = (uint32_t)(packed[0] >> 7);
   (*unpacked).disable_rt_store_mask = (uint32_t)packed[1];
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_load(uint8_t *packed, const V3D_CL_LOAD_T *unpacked)
{
   packed[0] = (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).stencil_load, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_load, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_load_mask, 8);
}
void v3d_cl_unpack_load(V3D_CL_LOAD_T *unpacked, const uint8_t *packed)
{
   (*unpacked).stencil_load = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).depth_load = (uint32_t)(packed[0] >> 7);
   (*unpacked).disable_rt_load_mask = (uint32_t)packed[1];
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_store_general(uint8_t *packed, const V3D_CL_STORE_GENERAL_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   packed[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
}
void v3d_cl_unpack_store_general(V3D_CL_STORE_GENERAL_T *unpacked, const uint8_t *packed)
{
   (*unpacked).buffer = (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15);
   (*unpacked).raw_mode = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).disable_depth_clear = (uint32_t)(packed[0] >> 5 & 1);
   (*unpacked).disable_stencil_clear = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).disable_color_clear = (uint32_t)(packed[0] >> 7);
   (*unpacked).eof = (uint32_t)(packed[1] & 1);
   (*unpacked).disable_double_buf_swap = (uint32_t)(packed[1] >> 1 & 1);
   (*unpacked).memory_format =
      (v3d_ldst_memory_format_t)(uint32_t)(packed[1] >> 2 & 1);
   (*unpacked).uif_height_in_ub =
      (uint32_t)(packed[1] >> 3) | (uint32_t)packed[2] << 5;
   (*unpacked).addr = ((uint32_t)packed[3] | (uint32_t)packed[4] << 8 |
      (uint32_t)packed[5] << 16) << 8;
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_load_general(uint8_t *packed, const V3D_CL_LOAD_GENERAL_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) | (uint8_t)0;
   packed[1] = (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   packed[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   packed[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
}
void v3d_cl_unpack_load_general(V3D_CL_LOAD_GENERAL_T *unpacked, const uint8_t *packed)
{
   (*unpacked).buffer = (v3d_ldst_buf_t)(uint32_t)(packed[0] & 15);
   (*unpacked).raw_mode = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).memory_format =
      (v3d_ldst_memory_format_t)(uint32_t)(packed[1] >> 2 & 1);
   (*unpacked).uif_height_in_ub =
      (uint32_t)(packed[1] >> 3) | (uint32_t)packed[2] << 5;
   (*unpacked).addr = ((uint32_t)packed[3] | (uint32_t)packed[4] << 8 |
      (uint32_t)packed[5] << 16) << 8;
}
#endif
#if V3D_HAS_32BIT_INDS
void v3d_cl_pack_indexed_prim_list(uint8_t *packed, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   packed[1] = (uint8_t)gfx_bits((*unpacked).num_indices, 31);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 8);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 16);
   packed[4] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   packed[5] = (uint8_t)(*unpacked).indices_addr;
   packed[6] = (uint8_t)((*unpacked).indices_addr >> 8);
   packed[7] = (uint8_t)((*unpacked).indices_addr >> 16);
   packed[8] = (uint8_t)((*unpacked).indices_addr >> 24);
   packed[9] = (uint8_t)(*unpacked).max_index;
   packed[10] = (uint8_t)((*unpacked).max_index >> 8);
   packed[11] = (uint8_t)((*unpacked).max_index >> 16);
   packed[12] = (uint8_t)((*unpacked).max_index >> 24);
   packed[13] = (uint8_t)(*unpacked).min_index;
   packed[14] = (uint8_t)((*unpacked).min_index >> 8);
   packed[15] = (uint8_t)((*unpacked).min_index >> 16);
   packed[16] = (uint8_t)((*unpacked).min_index >> 24);
}
void v3d_cl_unpack_indexed_prim_list(V3D_CL_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).index_type = (v3d_index_type_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).num_indices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)(packed[4] & 127) << 24;
   (*unpacked).prim_restart = (uint32_t)(packed[4] >> 7);
   (*unpacked).indices_addr = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).max_index = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   (*unpacked).min_index = (uint32_t)packed[13] | (uint32_t)packed[14] << 8 |
      (uint32_t)packed[15] << 16 | (uint32_t)packed[16] << 24;
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_pack_indexed_prim_list(uint8_t *packed, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   packed[1] = (uint8_t)(*unpacked).num_indices;
   packed[2] = (uint8_t)((*unpacked).num_indices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_indices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_indices >> 24);
   packed[5] = (uint8_t)(*unpacked).indices_addr;
   packed[6] = (uint8_t)((*unpacked).indices_addr >> 8);
   packed[7] = (uint8_t)((*unpacked).indices_addr >> 16);
   packed[8] = (uint8_t)((*unpacked).indices_addr >> 24);
   packed[9] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   packed[10] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   packed[11] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   packed[12] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   packed[13] = (uint8_t)(*unpacked).min_index;
   packed[14] = (uint8_t)((*unpacked).min_index >> 8);
   packed[15] = (uint8_t)((*unpacked).min_index >> 16);
   packed[16] = (uint8_t)((*unpacked).min_index >> 24);
}
void v3d_cl_unpack_indexed_prim_list(V3D_CL_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).index_type = (v3d_index_type_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).num_indices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).indices_addr = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).max_index = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)(packed[12] & 127) << 24;
   (*unpacked).prim_restart = (uint32_t)(packed[12] >> 7);
   (*unpacked).min_index = (uint32_t)packed[13] | (uint32_t)packed[14] << 8 |
      (uint32_t)packed[15] << 16 | (uint32_t)packed[16] << 24;
}
#endif
void v3d_cl_pack_indirect_indexed_prim_list(uint8_t *packed, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   packed[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff);
   packed[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 8);
   packed[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 16);
   packed[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   packed[5] = (uint8_t)(*unpacked).indirect_addr;
   packed[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   packed[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   packed[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   packed[9] = (uint8_t)(*unpacked).indices_addr;
   packed[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   packed[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   packed[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   packed[13] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
}
void v3d_cl_unpack_indirect_indexed_prim_list(V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).index_type = (v3d_index_type_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).num_indirect = gfx_check_urange(
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)(packed[4] & 127) << 24, 1, 0x7fffffff);
   (*unpacked).prim_restart = (uint32_t)(packed[4] >> 7);
   (*unpacked).indirect_addr = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).indices_addr = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   (*unpacked).indirect_stride = (uint32_t)packed[13] << 2;
}
#if V3D_HAS_32BIT_INDS
void v3d_cl_pack_indexed_instanced_prim_list(uint8_t *packed, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   packed[1] = (uint8_t)gfx_bits((*unpacked).num_indices, 31);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 8);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 16);
   packed[4] = (uint8_t)(gfx_bits((*unpacked).num_indices, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   packed[5] = (uint8_t)(*unpacked).num_instances;
   packed[6] = (uint8_t)((*unpacked).num_instances >> 8);
   packed[7] = (uint8_t)((*unpacked).num_instances >> 16);
   packed[8] = (uint8_t)((*unpacked).num_instances >> 24);
   packed[9] = (uint8_t)(*unpacked).indices_addr;
   packed[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   packed[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   packed[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   packed[13] = (uint8_t)(*unpacked).max_index;
   packed[14] = (uint8_t)((*unpacked).max_index >> 8);
   packed[15] = (uint8_t)((*unpacked).max_index >> 16);
   packed[16] = (uint8_t)((*unpacked).max_index >> 24);
}
void v3d_cl_unpack_indexed_instanced_prim_list(V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).index_type = (v3d_index_type_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).num_indices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)(packed[4] & 127) << 24;
   (*unpacked).prim_restart = (uint32_t)(packed[4] >> 7);
   (*unpacked).num_instances = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).indices_addr = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   (*unpacked).max_index = (uint32_t)packed[13] | (uint32_t)packed[14] << 8 |
      (uint32_t)packed[15] << 16 | (uint32_t)packed[16] << 24;
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_pack_indexed_instanced_prim_list(uint8_t *packed, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   packed[1] = (uint8_t)(*unpacked).num_indices;
   packed[2] = (uint8_t)((*unpacked).num_indices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_indices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_indices >> 24);
   packed[5] = (uint8_t)(*unpacked).num_instances;
   packed[6] = (uint8_t)((*unpacked).num_instances >> 8);
   packed[7] = (uint8_t)((*unpacked).num_instances >> 16);
   packed[8] = (uint8_t)((*unpacked).num_instances >> 24);
   packed[9] = (uint8_t)(*unpacked).indices_addr;
   packed[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   packed[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   packed[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   packed[13] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   packed[14] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   packed[15] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   packed[16] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
}
void v3d_cl_unpack_indexed_instanced_prim_list(V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).index_type = (v3d_index_type_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).num_indices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).num_instances = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).indices_addr = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
   (*unpacked).max_index = (uint32_t)packed[13] | (uint32_t)packed[14] << 8 |
      (uint32_t)packed[15] << 16 | (uint32_t)(packed[16] & 127) << 24;
   (*unpacked).prim_restart = (uint32_t)(packed[16] >> 7);
}
#endif
void v3d_cl_pack_vertex_array_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   packed[1] = (uint8_t)(*unpacked).num_vertices;
   packed[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   packed[5] = (uint8_t)(*unpacked).first_index;
   packed[6] = (uint8_t)((*unpacked).first_index >> 8);
   packed[7] = (uint8_t)((*unpacked).first_index >> 16);
   packed[8] = (uint8_t)((*unpacked).first_index >> 24);
}
void v3d_cl_unpack_vertex_array_prims(V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).num_vertices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).first_index = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
}
void v3d_cl_pack_indirect_vertex_array_prims(uint8_t *packed, const V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   packed[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff);
   packed[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 8);
   packed[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 16);
   packed[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 24);
   packed[5] = (uint8_t)(*unpacked).indirect_addr;
   packed[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   packed[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   packed[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   packed[9] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
}
void v3d_cl_unpack_indirect_vertex_array_prims(V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).num_indirect = gfx_check_urange(
      (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
      (uint32_t)packed[4] << 24, 1, 0xffffffff);
   (*unpacked).indirect_addr = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).indirect_stride = (uint32_t)packed[9] << 2;
}
void v3d_cl_pack_vertex_array_instanced_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   packed[1] = (uint8_t)(*unpacked).num_vertices;
   packed[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   packed[5] = (uint8_t)(*unpacked).num_instances;
   packed[6] = (uint8_t)((*unpacked).num_instances >> 8);
   packed[7] = (uint8_t)((*unpacked).num_instances >> 16);
   packed[8] = (uint8_t)((*unpacked).num_instances >> 24);
   packed[9] = (uint8_t)(*unpacked).first_index;
   packed[10] = (uint8_t)((*unpacked).first_index >> 8);
   packed[11] = (uint8_t)((*unpacked).first_index >> 16);
   packed[12] = (uint8_t)((*unpacked).first_index >> 24);
}
void v3d_cl_unpack_vertex_array_instanced_prims(V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).num_vertices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).num_instances = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).first_index = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
}
void v3d_cl_pack_vertex_array_single_instance_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   packed[1] = (uint8_t)(*unpacked).num_vertices;
   packed[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   packed[5] = (uint8_t)(*unpacked).instance_id;
   packed[6] = (uint8_t)((*unpacked).instance_id >> 8);
   packed[7] = (uint8_t)((*unpacked).instance_id >> 16);
   packed[8] = (uint8_t)((*unpacked).instance_id >> 24);
   packed[9] = (uint8_t)(*unpacked).first_index;
   packed[10] = (uint8_t)((*unpacked).first_index >> 8);
   packed[11] = (uint8_t)((*unpacked).first_index >> 16);
   packed[12] = (uint8_t)((*unpacked).first_index >> 24);
}
void v3d_cl_unpack_vertex_array_single_instance_prims(V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 63);
   (*unpacked).num_vertices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).instance_id = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
   (*unpacked).first_index = (uint32_t)packed[9] | (uint32_t)packed[10] << 8 |
      (uint32_t)packed[11] << 16 | (uint32_t)packed[12] << 24;
}
void v3d_cl_pack_base_vertex_base_instance(uint8_t *packed, const V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked)
{
   packed[0] = (uint8_t)(uint32_t)(*unpacked).base_vertex;
   packed[1] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 8);
   packed[2] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 16);
   packed[3] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 24);
   packed[4] = (uint8_t)(*unpacked).base_instance;
   packed[5] = (uint8_t)((*unpacked).base_instance >> 8);
   packed[6] = (uint8_t)((*unpacked).base_instance >> 16);
   packed[7] = (uint8_t)((*unpacked).base_instance >> 24);
}
void v3d_cl_unpack_base_vertex_base_instance(V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).base_vertex =
      (int32_t)((uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24);
   (*unpacked).base_instance = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
}
#if V3D_HAS_32BIT_INDS
void v3d_cl_pack_indirect_primitive_limits(uint8_t *packed, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked)
{
   packed[0] = (uint8_t)(*unpacked).max_index;
   packed[1] = (uint8_t)((*unpacked).max_index >> 8);
   packed[2] = (uint8_t)((*unpacked).max_index >> 16);
   packed[3] = (uint8_t)((*unpacked).max_index >> 24);
   packed[4] = (uint8_t)(*unpacked).max_instance;
   packed[5] = (uint8_t)((*unpacked).max_instance >> 8);
   packed[6] = (uint8_t)((*unpacked).max_instance >> 16);
   packed[7] = (uint8_t)((*unpacked).max_instance >> 24);
   packed[8] = (uint8_t)(*unpacked).index_buffer_size;
   packed[9] = (uint8_t)((*unpacked).index_buffer_size >> 8);
   packed[10] = (uint8_t)((*unpacked).index_buffer_size >> 16);
   packed[11] = (uint8_t)((*unpacked).index_buffer_size >> 24);
}
void v3d_cl_unpack_indirect_primitive_limits(V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).max_index = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
   (*unpacked).max_instance = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
   (*unpacked).index_buffer_size =
      (uint32_t)packed[8] | (uint32_t)packed[9] << 8 | (uint32_t)packed[10] << 16 |
      (uint32_t)packed[11] << 24;
}
#endif
#if !V3D_HAS_32BIT_INDS
void v3d_cl_pack_indirect_primitive_limits(uint8_t *packed, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).max_index, 24);
   packed[1] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 8);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 16);
   packed[3] = (uint8_t)(*unpacked).max_instance;
   packed[4] = (uint8_t)((*unpacked).max_instance >> 8);
   packed[5] = (uint8_t)((*unpacked).max_instance >> 16);
   packed[6] = (uint8_t)((*unpacked).max_instance >> 24);
   packed[7] = (uint8_t)(*unpacked).index_buffer_size;
   packed[8] = (uint8_t)((*unpacked).index_buffer_size >> 8);
   packed[9] = (uint8_t)((*unpacked).index_buffer_size >> 16);
   packed[10] = (uint8_t)((*unpacked).index_buffer_size >> 24);
}
void v3d_cl_unpack_indirect_primitive_limits(V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).max_index = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16;
   (*unpacked).max_instance = (uint32_t)packed[3] | (uint32_t)packed[4] << 8 |
      (uint32_t)packed[5] << 16 | (uint32_t)packed[6] << 24;
   (*unpacked).index_buffer_size =
      (uint32_t)packed[7] | (uint32_t)packed[8] << 8 | (uint32_t)packed[9] << 16 |
      (uint32_t)packed[10] << 24;
}
#endif
void v3d_cl_pack_vg_coord_array_prims(uint8_t *packed, const V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
   packed[1] = (uint8_t)(*unpacked).num_vertices;
   packed[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   packed[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   packed[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   packed[5] = (uint8_t)(*unpacked).coords_addr;
   packed[6] = (uint8_t)((*unpacked).coords_addr >> 8);
   packed[7] = (uint8_t)((*unpacked).coords_addr >> 16);
   packed[8] = (uint8_t)((*unpacked).coords_addr >> 24);
}
void v3d_cl_unpack_vg_coord_array_prims(V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 15);
   (*unpacked).continuation = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).num_vertices = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16 | (uint32_t)packed[4] << 24;
   (*unpacked).coords_addr = (uint32_t)packed[5] | (uint32_t)packed[6] << 8 |
      (uint32_t)packed[7] << 16 | (uint32_t)packed[8] << 24;
}
void v3d_cl_pack_vg_inline_prims(uint8_t *packed, const V3D_CL_VG_INLINE_PRIMS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
}
void v3d_cl_unpack_vg_inline_prims(V3D_CL_VG_INLINE_PRIMS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).prim_mode = (v3d_prim_mode_t)(uint32_t)(packed[0] & 15);
   (*unpacked).continuation = (uint32_t)(packed[0] >> 4 & 1);
}
#if !V3D_HAS_INLINE_CLIP
void v3d_cl_pack_clipped_prim(uint8_t *packed, const V3D_CL_CLIPPED_PRIM_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).clip[0], 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[1], 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[2], 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).flat_zw, 1) << 3) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
}
void v3d_cl_unpack_clipped_prim(V3D_CL_CLIPPED_PRIM_T *unpacked, const uint8_t *packed)
{
   (*unpacked).clip[0] = (uint32_t)(packed[0] & 1);
   (*unpacked).clip[1] = (uint32_t)(packed[0] >> 1 & 1);
   (*unpacked).clip[2] = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).flat_zw = (uint32_t)(packed[0] >> 3 & 1);
   (*unpacked).addr = ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5;
}
#endif
#if V3D_HAS_BASEINSTANCE
void v3d_cl_pack_set_instance_id(uint8_t *packed, const V3D_CL_SET_INSTANCE_ID_T *unpacked)
{
   packed[0] = (uint8_t)(*unpacked).instance_id;
   packed[1] = (uint8_t)((*unpacked).instance_id >> 8);
   packed[2] = (uint8_t)((*unpacked).instance_id >> 16);
   packed[3] = (uint8_t)((*unpacked).instance_id >> 24);
}
void v3d_cl_unpack_set_instance_id(V3D_CL_SET_INSTANCE_ID_T *unpacked, const uint8_t *packed)
{
   (*unpacked).instance_id = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
}
#endif
void v3d_cl_pack_prim_list_format(uint8_t *packed, const V3D_CL_PRIM_LIST_FORMAT_T *unpacked)
{
   packed[0] = (uint8_t)gfx_pack_uint_minus_1(
      gfx_check_urange((*unpacked).n_verts, 1, 32), 6) |
      (uint8_t)(gfx_bits((*unpacked).xy, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).d3dpvsf, 1) << 7);
}
void v3d_cl_unpack_prim_list_format(V3D_CL_PRIM_LIST_FORMAT_T *unpacked, const uint8_t *packed)
{
   (*unpacked).n_verts = gfx_check_urange((uint32_t)(packed[0] & 63) + 1, 1, 32);
   (*unpacked).xy = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).d3dpvsf = (uint32_t)(packed[0] >> 7);
}
#if V3D_HAS_TNG
void v3d_cl_pack_serial_number_list_start(uint8_t *packed, const V3D_CL_SERIAL_NUMBER_LIST_START_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).initial_block_size, 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) << 2);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 6);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 14);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).address, 2) >> 22);
}
void v3d_cl_unpack_serial_number_list_start(V3D_CL_SERIAL_NUMBER_LIST_START_T *unpacked, const uint8_t *packed)
{
   (*unpacked).initial_block_size =
      (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3);
   (*unpacked).address = ((uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6 |
      (uint32_t)packed[2] << 14 | (uint32_t)packed[3] << 22) << 2;
}
#endif
void v3d_cl_pack_gl_shader(uint8_t *packed, const V3D_CL_GL_SHADER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
}
void v3d_cl_unpack_gl_shader(V3D_CL_GL_SHADER_T *unpacked, const uint8_t *packed)
{
   (*unpacked).num_attr_arrays =
      gfx_unpack_uint_0_is_max((uint32_t)(packed[0] & 31), 5);
   (*unpacked).addr = ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5;
}
void v3d_cl_pack_vg_shader(uint8_t *packed, const v3d_addr_t *unpacked)
{
   packed[0] = (uint8_t)*unpacked;
   packed[1] = (uint8_t)(*unpacked >> 8);
   packed[2] = (uint8_t)(*unpacked >> 16);
   packed[3] = (uint8_t)(*unpacked >> 24);
}
void v3d_cl_unpack_vg_shader(v3d_addr_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
}
void v3d_cl_pack_vg_inline_shader(uint8_t *packed, const V3D_CL_VG_INLINE_SHADER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).fs.threading, 2) |
      (uint8_t)(gfx_bits((*unpacked).fs.propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) << 3);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 5);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 13);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 21);
   packed[4] = (uint8_t)(*unpacked).fs.unifs_addr;
   packed[5] = (uint8_t)((*unpacked).fs.unifs_addr >> 8);
   packed[6] = (uint8_t)((*unpacked).fs.unifs_addr >> 16);
   packed[7] = (uint8_t)((*unpacked).fs.unifs_addr >> 24);
}
void v3d_cl_unpack_vg_inline_shader(V3D_CL_VG_INLINE_SHADER_T *unpacked, const uint8_t *packed)
{
   (*unpacked).fs.threading = (v3d_threading_t)(uint32_t)(packed[0] & 3);
   (*unpacked).fs.propagate_nans = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).fs.addr = ((uint32_t)(packed[0] >> 3) | (uint32_t)packed[1] << 5 |
      (uint32_t)packed[2] << 13 | (uint32_t)packed[3] << 21) << 3;
   (*unpacked).fs.unifs_addr = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
}
#if V3D_HAS_NEW_TF
void v3d_cl_pack_vcm_cache_size(uint8_t *packed, const V3D_CL_VCM_CACHE_SIZE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_check_urange((*unpacked).num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_batches_render, 1, 4) << 4);
}
void v3d_cl_unpack_vcm_cache_size(V3D_CL_VCM_CACHE_SIZE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).num_batches_bin = gfx_check_urange((uint32_t)(packed[0] & 15), 1, 4);
   (*unpacked).num_batches_render =
      gfx_check_urange((uint32_t)(packed[0] >> 4), 1, 4);
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_pack_prim_counts_feedback(uint8_t *packed, const V3D_CL_PRIM_COUNTS_FEEDBACK_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).operation, 4) |
      (uint8_t)(gfx_bits((*unpacked).rw64, 1) << 4) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
}
void v3d_cl_unpack_prim_counts_feedback(V3D_CL_PRIM_COUNTS_FEEDBACK_T *unpacked, const uint8_t *packed)
{
   (*unpacked).operation = (v3d_pcf_operation_t)(uint32_t)(packed[0] & 15);
   (*unpacked).rw64 = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).addr = ((uint32_t)(packed[0] >> 5) | (uint32_t)packed[1] << 3 |
      (uint32_t)packed[2] << 11 | (uint32_t)packed[3] << 19) << 5;
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_pack_transform_feedback_buffer(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T *unpacked)
{
   packed[0] = (uint8_t)gfx_check_urange((*unpacked).buffer_num, 0, 3) |
      (uint8_t)(gfx_bits((*unpacked).size_words, 30) << 2);
   packed[1] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 6);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 14);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).size_words, 30) >> 22);
   packed[4] = (uint8_t)(*unpacked).buffer_addr;
   packed[5] = (uint8_t)((*unpacked).buffer_addr >> 8);
   packed[6] = (uint8_t)((*unpacked).buffer_addr >> 16);
   packed[7] = (uint8_t)((*unpacked).buffer_addr >> 24);
}
void v3d_cl_unpack_transform_feedback_buffer(V3D_CL_TRANSFORM_FEEDBACK_BUFFER_T *unpacked, const uint8_t *packed)
{
   (*unpacked).buffer_num = gfx_check_urange((uint32_t)(packed[0] & 3), 0, 3);
   (*unpacked).size_words =
      (uint32_t)(packed[0] >> 2) | (uint32_t)packed[1] << 6 |
      (uint32_t)packed[2] << 14 | (uint32_t)packed[3] << 22;
   (*unpacked).buffer_addr = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
}
#endif
#if V3D_HAS_NEW_TF
void v3d_cl_pack_transform_feedback_specs(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_SPECS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_check_urange((*unpacked).num_specs, 0, 16) |
      (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).enable, 1) << 7);
}
void v3d_cl_unpack_transform_feedback_specs(V3D_CL_TRANSFORM_FEEDBACK_SPECS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).num_specs = gfx_check_urange((uint32_t)(packed[0] & 31), 0, 16);
   (*unpacked).enable = (uint32_t)(packed[0] >> 7);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_cl_pack_vcm_cache_size(uint8_t *packed, const V3D_CL_VCM_CACHE_SIZE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_check_urange((*unpacked).num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_batches_render, 1, 4) << 4);
}
void v3d_cl_unpack_vcm_cache_size(V3D_CL_VCM_CACHE_SIZE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).num_batches_bin = gfx_check_urange((uint32_t)(packed[0] & 15), 1, 4);
   (*unpacked).num_batches_render =
      gfx_check_urange((uint32_t)(packed[0] >> 4), 1, 4);
}
#endif
#if !V3D_HAS_NEW_TF
void v3d_cl_pack_transform_feedback_enable(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).id, 8);
   packed[1] = (uint8_t)gfx_check_urange((*unpacked).num_addrs, 0, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_specs, 1, 16) << 3);
}
void v3d_cl_unpack_transform_feedback_enable(V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).id = (uint32_t)packed[0];
   (*unpacked).num_addrs = gfx_check_urange((uint32_t)(packed[1] & 7), 0, 4);
   (*unpacked).num_specs = gfx_check_urange((uint32_t)(packed[1] >> 3), 1, 16);
}
#endif
void v3d_cl_pack_l1_cache_flush_control(uint8_t *packed, const V3D_CL_L1_CACHE_FLUSH_CONTROL_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).icache_clear_slice_0, 1) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_1, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_2, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_3, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_0, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_1, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_2, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_3, 1) << 7);
   packed[1] = (uint8_t)gfx_bits((*unpacked).tmu_data_cache_clear_0, 1) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_1, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_2, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_3, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_0, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_1, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_2, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_3, 1) << 7);
}
void v3d_cl_unpack_l1_cache_flush_control(V3D_CL_L1_CACHE_FLUSH_CONTROL_T *unpacked, const uint8_t *packed)
{
   (*unpacked).icache_clear_slice_0 = (uint32_t)(packed[0] & 1);
   (*unpacked).icache_clear_slice_1 = (uint32_t)(packed[0] >> 1 & 1);
   (*unpacked).icache_clear_slice_2 = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).icache_clear_slice_3 = (uint32_t)(packed[0] >> 3 & 1);
   (*unpacked).ucache_clear_slice_0 = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).ucache_clear_slice_1 = (uint32_t)(packed[0] >> 5 & 1);
   (*unpacked).ucache_clear_slice_2 = (uint32_t)(packed[0] >> 6 & 1);
   (*unpacked).ucache_clear_slice_3 = (uint32_t)(packed[0] >> 7);
   (*unpacked).tmu_data_cache_clear_0 = (uint32_t)(packed[1] & 1);
   (*unpacked).tmu_data_cache_clear_1 = (uint32_t)(packed[1] >> 1 & 1);
   (*unpacked).tmu_data_cache_clear_2 = (uint32_t)(packed[1] >> 2 & 1);
   (*unpacked).tmu_data_cache_clear_3 = (uint32_t)(packed[1] >> 3 & 1);
   (*unpacked).tmu_config_cache_clear_0 = (uint32_t)(packed[1] >> 4 & 1);
   (*unpacked).tmu_config_cache_clear_1 = (uint32_t)(packed[1] >> 5 & 1);
   (*unpacked).tmu_config_cache_clear_2 = (uint32_t)(packed[1] >> 6 & 1);
   (*unpacked).tmu_config_cache_clear_3 = (uint32_t)(packed[1] >> 7);
}
void v3d_cl_pack_l2t_cache_flush_control(uint8_t *packed, const V3D_CL_L2T_CACHE_FLUSH_CONTROL_T *unpacked)
{
   packed[0] = (uint8_t)(*unpacked).l2t_flush_start_address;
   packed[1] = (uint8_t)((*unpacked).l2t_flush_start_address >> 8);
   packed[2] = (uint8_t)((*unpacked).l2t_flush_start_address >> 16);
   packed[3] = (uint8_t)((*unpacked).l2t_flush_start_address >> 24);
   packed[4] = (uint8_t)(*unpacked).l2t_flush_end_address;
   packed[5] = (uint8_t)((*unpacked).l2t_flush_end_address >> 8);
   packed[6] = (uint8_t)((*unpacked).l2t_flush_end_address >> 16);
   packed[7] = (uint8_t)((*unpacked).l2t_flush_end_address >> 24);
   packed[8] = (uint8_t)gfx_bits((*unpacked).l2t_flush_mode, 2) | (uint8_t)0;
}
void v3d_cl_unpack_l2t_cache_flush_control(V3D_CL_L2T_CACHE_FLUSH_CONTROL_T *unpacked, const uint8_t *packed)
{
   (*unpacked).l2t_flush_start_address =
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24;
   (*unpacked).l2t_flush_end_address =
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24;
   (*unpacked).l2t_flush_mode = (v3d_l2t_flush_mode_t)(uint32_t)(packed[8] & 3);
}
void v3d_cl_pack_stencil_cfg(uint8_t *packed, const V3D_CL_STENCIL_CFG_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).reference, 8);
   packed[1] = (uint8_t)gfx_bits((*unpacked).mask, 8);
   packed[2] = (uint8_t)gfx_bits((*unpacked).func, 3) |
      (uint8_t)(gfx_bits((*unpacked).fail_op, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) << 6);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).pass_op, 3) << 1) |
      (uint8_t)(gfx_bits((*unpacked).front_cfg, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).back_cfg, 1) << 5) | (uint8_t)0;
   packed[4] = (uint8_t)gfx_bits((*unpacked).write_mask, 8);
}
void v3d_cl_unpack_stencil_cfg(V3D_CL_STENCIL_CFG_T *unpacked, const uint8_t *packed)
{
   (*unpacked).reference = (uint32_t)packed[0];
   (*unpacked).mask = (uint32_t)packed[1];
   (*unpacked).func = (v3d_compare_func_t)(uint32_t)(packed[2] & 7);
   (*unpacked).fail_op = (v3d_stencil_op_t)(uint32_t)(packed[2] >> 3 & 7);
   (*unpacked).depth_fail_op = (v3d_stencil_op_t)((uint32_t)(packed[2] >> 6) |
      (uint32_t)(packed[3] & 1) << 2);
   (*unpacked).pass_op = (v3d_stencil_op_t)(uint32_t)(packed[3] >> 1 & 7);
   (*unpacked).front_cfg = (uint32_t)(packed[3] >> 4 & 1);
   (*unpacked).back_cfg = (uint32_t)(packed[3] >> 5 & 1);
   (*unpacked).write_mask = (uint32_t)packed[4];
}
#if !V3D_HAS_PER_RT_BLEND
void v3d_cl_pack_blend_cfg(uint8_t *packed, const V3D_CL_BLEND_CFG_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).a_eqn, 4) |
      (uint8_t)(gfx_bits((*unpacked).a_src, 4) << 4);
   packed[1] = (uint8_t)gfx_bits((*unpacked).a_dst, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_eqn, 4) << 4);
   packed[2] = (uint8_t)gfx_bits((*unpacked).c_src, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_dst, 4) << 4);
   packed[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).vg_mode, 2) << 4) |
      (uint8_t)0;
}
void v3d_cl_unpack_blend_cfg(V3D_CL_BLEND_CFG_T *unpacked, const uint8_t *packed)
{
   (*unpacked).a_eqn = (v3d_blend_eqn_t)(uint32_t)(packed[0] & 15);
   (*unpacked).a_src = (v3d_blend_mul_t)(uint32_t)(packed[0] >> 4);
   (*unpacked).a_dst = (v3d_blend_mul_t)(uint32_t)(packed[1] & 15);
   (*unpacked).c_eqn = (v3d_blend_eqn_t)(uint32_t)(packed[1] >> 4);
   (*unpacked).c_src = (v3d_blend_mul_t)(uint32_t)(packed[2] & 15);
   (*unpacked).c_dst = (v3d_blend_mul_t)(uint32_t)(packed[2] >> 4);
   (*unpacked).vg_mode = (v3d_blend_vg_mode_t)(uint32_t)(packed[3] >> 4 & 3);
}
#endif
#if V3D_HAS_PER_RT_BLEND
void v3d_cl_pack_blend_enables(uint8_t *packed, const uint32_t *unpacked)
{
   packed[0] = (uint8_t)gfx_bits(*unpacked, 8);
}
void v3d_cl_unpack_blend_enables(uint32_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0];
}
#endif
#if V3D_HAS_PER_RT_BLEND
void v3d_cl_pack_blend_cfg(uint8_t *packed, const V3D_CL_BLEND_CFG_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).a_eqn, 4) |
      (uint8_t)(gfx_bits((*unpacked).a_src, 4) << 4);
   packed[1] = (uint8_t)gfx_bits((*unpacked).a_dst, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_eqn, 4) << 4);
   packed[2] = (uint8_t)gfx_bits((*unpacked).c_src, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_dst, 4) << 4);
   packed[3] = (uint8_t)gfx_bits((*unpacked).rt_mask, 4) |
      (uint8_t)(gfx_bits((*unpacked).vg_mode, 2) << 4) | (uint8_t)0;
}
void v3d_cl_unpack_blend_cfg(V3D_CL_BLEND_CFG_T *unpacked, const uint8_t *packed)
{
   (*unpacked).a_eqn = (v3d_blend_eqn_t)(uint32_t)(packed[0] & 15);
   (*unpacked).a_src = (v3d_blend_mul_t)(uint32_t)(packed[0] >> 4);
   (*unpacked).a_dst = (v3d_blend_mul_t)(uint32_t)(packed[1] & 15);
   (*unpacked).c_eqn = (v3d_blend_eqn_t)(uint32_t)(packed[1] >> 4);
   (*unpacked).c_src = (v3d_blend_mul_t)(uint32_t)(packed[2] & 15);
   (*unpacked).c_dst = (v3d_blend_mul_t)(uint32_t)(packed[2] >> 4);
   (*unpacked).rt_mask = (uint32_t)(packed[3] & 15);
   (*unpacked).vg_mode = (v3d_blend_vg_mode_t)(uint32_t)(packed[3] >> 4 & 3);
}
#endif
void v3d_cl_pack_blend_ccolor(uint8_t *packed, const V3D_CL_BLEND_CCOLOR_T *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_float16((*unpacked).r);
   packed[1] = (uint8_t)(gfx_float_to_float16((*unpacked).r) >> 8);
   packed[2] = (uint8_t)gfx_float_to_float16((*unpacked).g);
   packed[3] = (uint8_t)(gfx_float_to_float16((*unpacked).g) >> 8);
   packed[4] = (uint8_t)gfx_float_to_float16((*unpacked).b);
   packed[5] = (uint8_t)(gfx_float_to_float16((*unpacked).b) >> 8);
   packed[6] = (uint8_t)gfx_float_to_float16((*unpacked).a);
   packed[7] = (uint8_t)(gfx_float_to_float16((*unpacked).a) >> 8);
}
void v3d_cl_unpack_blend_ccolor(V3D_CL_BLEND_CCOLOR_T *unpacked, const uint8_t *packed)
{
   (*unpacked).r = gfx_float16_to_float(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8);
   (*unpacked).g = gfx_float16_to_float(
      (uint32_t)packed[2] | (uint32_t)packed[3] << 8);
   (*unpacked).b = gfx_float16_to_float(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8);
   (*unpacked).a = gfx_float16_to_float(
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8);
}
void v3d_cl_pack_color_wmasks(uint8_t *packed, const uint32_t *unpacked)
{
   packed[0] = (uint8_t)*unpacked;
   packed[1] = (uint8_t)(*unpacked >> 8);
   packed[2] = (uint8_t)(*unpacked >> 16);
   packed[3] = (uint8_t)(*unpacked >> 24);
}
void v3d_cl_unpack_color_wmasks(uint32_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
}
void v3d_cl_pack_vary_flags(uint8_t *packed, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   packed[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
}
void v3d_cl_unpack_vary_flags(V3D_CL_VARY_FLAGS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).offset = gfx_check_urange((uint32_t)(packed[0] & 15), 0, 2);
   (*unpacked).lower_action = (v3d_flags_action_t)(uint32_t)(packed[0] >> 4 & 3);
   (*unpacked).higher_action = (v3d_flags_action_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).flags = (uint32_t)packed[1] | (uint32_t)packed[2] << 8 |
      (uint32_t)packed[3] << 16;
}
void v3d_cl_pack_sample_coverage(uint8_t *packed, const float *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   packed[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
}
void v3d_cl_unpack_sample_coverage(float *unpacked, const uint8_t *packed)
{
   *unpacked = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_pack_occlusion_query_counter_enable(uint8_t *packed, const v3d_addr_t *unpacked)
{
   packed[0] = (uint8_t)*unpacked;
   packed[1] = (uint8_t)(*unpacked >> 8);
   packed[2] = (uint8_t)(*unpacked >> 16);
   packed[3] = (uint8_t)(*unpacked >> 24);
}
void v3d_cl_unpack_occlusion_query_counter_enable(v3d_addr_t *unpacked, const uint8_t *packed)
{
   *unpacked = (uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24;
}
void v3d_cl_pack_cfg_bits(uint8_t *packed, const V3D_CL_CFG_BITS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).front_prims, 1) |
      (uint8_t)(gfx_bits((*unpacked).back_prims, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).cwise_is_front, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).depth_offset, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).aa_lines, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).rast_oversample, 2) << 6);
   packed[1] = (uint8_t)gfx_bits((*unpacked).cov_pipe, 1) |
      (uint8_t)(gfx_bits((*unpacked).cov_update, 2) << 1) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_tris, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_test, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).depth_update, 1) << 7);
   packed[2] = (uint8_t)gfx_bits((*unpacked).ez, 1) |
      (uint8_t)(gfx_bits((*unpacked).ez_update, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).stencil, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).blend, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).d3d_prov_vtx, 1) << 5) | (uint8_t)0;
}
void v3d_cl_unpack_cfg_bits(V3D_CL_CFG_BITS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).front_prims = (uint32_t)(packed[0] & 1);
   (*unpacked).back_prims = (uint32_t)(packed[0] >> 1 & 1);
   (*unpacked).cwise_is_front = (uint32_t)(packed[0] >> 2 & 1);
   (*unpacked).depth_offset = (uint32_t)(packed[0] >> 3 & 1);
   (*unpacked).aa_lines = (uint32_t)(packed[0] >> 4 & 1);
   (*unpacked).rast_oversample = (v3d_ms_t)(uint32_t)(packed[0] >> 6);
   (*unpacked).cov_pipe = (uint32_t)(packed[1] & 1);
   (*unpacked).cov_update = (v3d_cov_update_t)(uint32_t)(packed[1] >> 1 & 3);
   (*unpacked).wireframe_tris = (uint32_t)(packed[1] >> 3 & 1);
   (*unpacked).depth_test = (v3d_compare_func_t)(uint32_t)(packed[1] >> 4 & 7);
   (*unpacked).depth_update = (uint32_t)(packed[1] >> 7);
   (*unpacked).ez = (uint32_t)(packed[2] & 1);
   (*unpacked).ez_update = (uint32_t)(packed[2] >> 1 & 1);
   (*unpacked).stencil = (uint32_t)(packed[2] >> 2 & 1);
   (*unpacked).blend = (uint32_t)(packed[2] >> 3 & 1);
   (*unpacked).wireframe_mode =
      (v3d_wireframe_mode_t)(uint32_t)(packed[2] >> 4 & 1);
   (*unpacked).d3d_prov_vtx = (uint32_t)(packed[2] >> 5 & 1);
}
void v3d_cl_pack_point_size(uint8_t *packed, const float *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   packed[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
}
void v3d_cl_unpack_point_size(float *unpacked, const uint8_t *packed)
{
   *unpacked = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_pack_line_width(uint8_t *packed, const float *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   packed[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
}
void v3d_cl_unpack_line_width(float *unpacked, const uint8_t *packed)
{
   *unpacked = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
}
void v3d_cl_pack_depth_offset(uint8_t *packed, const V3D_CL_DEPTH_OFFSET_T *unpacked)
{
   packed[0] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16);
   packed[1] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16 >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16 >> 8);
}
void v3d_cl_unpack_depth_offset(V3D_CL_DEPTH_OFFSET_T *unpacked, const uint8_t *packed)
{
   (*unpacked).factor = gfx_float_from_bits(
      ((uint32_t)packed[0] | (uint32_t)packed[1] << 8) << 16);
   (*unpacked).units = gfx_float_from_bits(
      ((uint32_t)packed[2] | (uint32_t)packed[3] << 8) << 16);
}
void v3d_cl_pack_clip(uint8_t *packed, const V3D_CL_CLIP_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).x, 16);
   packed[1] = (uint8_t)(gfx_bits((*unpacked).x, 16) >> 8);
   packed[2] = (uint8_t)gfx_bits((*unpacked).y, 16);
   packed[3] = (uint8_t)(gfx_bits((*unpacked).y, 16) >> 8);
   packed[4] = (uint8_t)gfx_check_urange((*unpacked).width, 1, 0x1000);
   packed[5] = (uint8_t)(gfx_check_urange((*unpacked).width, 1, 0x1000) >> 8);
   packed[6] = (uint8_t)gfx_check_urange((*unpacked).height, 1, 0x1000);
   packed[7] = (uint8_t)(gfx_check_urange((*unpacked).height, 1, 0x1000) >> 8);
}
void v3d_cl_unpack_clip(V3D_CL_CLIP_T *unpacked, const uint8_t *packed)
{
   (*unpacked).x = (uint32_t)packed[0] | (uint32_t)packed[1] << 8;
   (*unpacked).y = (uint32_t)packed[2] | (uint32_t)packed[3] << 8;
   (*unpacked).width = gfx_check_urange(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8, 1, 0x1000);
   (*unpacked).height = gfx_check_urange(
      (uint32_t)packed[6] | (uint32_t)packed[7] << 8, 1, 0x1000);
}
void v3d_cl_pack_viewport_offset(uint8_t *packed, const V3D_CL_VIEWPORT_OFFSET_T *unpacked)
{
   packed[0] = (uint8_t)(uint32_t)(*unpacked).x;
   packed[1] = (uint8_t)((uint32_t)(*unpacked).x >> 8);
   packed[2] = (uint8_t)((uint32_t)(*unpacked).x >> 16);
   packed[3] = (uint8_t)((uint32_t)(*unpacked).x >> 24);
   packed[4] = (uint8_t)(uint32_t)(*unpacked).y;
   packed[5] = (uint8_t)((uint32_t)(*unpacked).y >> 8);
   packed[6] = (uint8_t)((uint32_t)(*unpacked).y >> 16);
   packed[7] = (uint8_t)((uint32_t)(*unpacked).y >> 24);
}
void v3d_cl_unpack_viewport_offset(V3D_CL_VIEWPORT_OFFSET_T *unpacked, const uint8_t *packed)
{
   (*unpacked).x = (int32_t)((uint32_t)packed[0] | (uint32_t)packed[1] << 8 |
      (uint32_t)packed[2] << 16 | (uint32_t)packed[3] << 24);
   (*unpacked).y = (int32_t)((uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
      (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24);
}
void v3d_cl_pack_clipz(uint8_t *packed, const V3D_CL_CLIPZ_T *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits((*unpacked).min);
   packed[1] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 24);
   packed[4] = (uint8_t)gfx_float_to_bits((*unpacked).max);
   packed[5] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 8);
   packed[6] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 16);
   packed[7] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 24);
}
void v3d_cl_unpack_clipz(V3D_CL_CLIPZ_T *unpacked, const uint8_t *packed)
{
   (*unpacked).min = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   (*unpacked).max = gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
}
void v3d_cl_pack_clipper_xy(uint8_t *packed, const V3D_CL_CLIPPER_XY_T *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale_x);
   packed[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 24);
   packed[4] = (uint8_t)gfx_float_to_bits((*unpacked).scale_y);
   packed[5] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 8);
   packed[6] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 16);
   packed[7] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 24);
}
void v3d_cl_unpack_clipper_xy(V3D_CL_CLIPPER_XY_T *unpacked, const uint8_t *packed)
{
   (*unpacked).scale_x = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   (*unpacked).scale_y = gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
}
void v3d_cl_pack_clipper_z(uint8_t *packed, const V3D_CL_CLIPPER_Z_T *unpacked)
{
   packed[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale);
   packed[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 8);
   packed[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 16);
   packed[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 24);
   packed[4] = (uint8_t)gfx_float_to_bits((*unpacked).offset);
   packed[5] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 8);
   packed[6] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 16);
   packed[7] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 24);
}
void v3d_cl_unpack_clipper_z(V3D_CL_CLIPPER_Z_T *unpacked, const uint8_t *packed)
{
   (*unpacked).scale = gfx_float_from_bits(
      (uint32_t)packed[0] | (uint32_t)packed[1] << 8 | (uint32_t)packed[2] << 16 |
      (uint32_t)packed[3] << 24);
   (*unpacked).offset = gfx_float_from_bits(
      (uint32_t)packed[4] | (uint32_t)packed[5] << 8 | (uint32_t)packed[6] << 16 |
      (uint32_t)packed[7] << 24);
}
#if V3D_HAS_RENDER_LAYERS
void v3d_cl_pack_num_layers(uint8_t *packed, const V3D_CL_NUM_LAYERS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).num_layers, 8);
}
void v3d_cl_unpack_num_layers(V3D_CL_NUM_LAYERS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).num_layers = (uint32_t)packed[0] + 1;
}
#endif
void v3d_cl_pack_tile_binning_mode_cfg(uint8_t *packed, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked)
{
   if ((*unpacked).type == V3D_BCFG_TYPE_PART1)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART1);
      packed[0] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.part1.auto_init_tile_state, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_initial_block_size, 2) <<
         2) | (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_block_size, 2) << 4) |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) << 6);
      packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         2);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         10);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         18);
      packed[4] = (uint8_t)gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff);
      packed[5] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff) >> 8) |
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) << 4);
      packed[6] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) >> 4);
      packed[7] = (uint8_t)gfx_check_urange((*unpacked).u.part1.num_rts, 0, 8) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.max_bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.ms_mode, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.double_buffer, 1) << 7);
   }
   else if ((*unpacked).type == V3D_BCFG_TYPE_PART2)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART2);
      packed[0] = (uint8_t)1 | (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) << 6);
      packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         2);
      packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         10);
      packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         18);
      packed[4] = (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) << 6);
      packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         2);
      packed[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         10);
      packed[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         18);
   }
   else
   {
      unreachable();
   }
}
void v3d_cl_unpack_tile_binning_mode_cfg(V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 1) == 0)
   {
      (*unpacked).type = V3D_BCFG_TYPE_PART1;
      assert((uint32_t)(packed[0] & 1) == 0);
      (*unpacked).u.part1.auto_init_tile_state = (uint32_t)(packed[0] >> 1 & 1);
      (*unpacked).u.part1.tile_alloc_initial_block_size =
         (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] >> 2 & 3);
      (*unpacked).u.part1.tile_alloc_block_size =
         (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] >> 4 & 3);
      (*unpacked).u.part1.tile_state_addr =
         ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
         (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6;
      (*unpacked).u.part1.w_in_tiles = gfx_check_urange(
         (uint32_t)packed[4] | (uint32_t)(packed[5] & 15) << 8, 1, 0xfff);
      (*unpacked).u.part1.h_in_tiles = gfx_check_urange(
         (uint32_t)(packed[5] >> 4) | (uint32_t)packed[6] << 4, 1, 0xfff);
      (*unpacked).u.part1.num_rts = gfx_check_urange((uint32_t)(packed[7] & 15), 0, 8);
      (*unpacked).u.part1.max_bpp = (v3d_rt_bpp_t)(uint32_t)(packed[7] >> 4 & 3);
      (*unpacked).u.part1.ms_mode = (uint32_t)(packed[7] >> 6 & 1);
      (*unpacked).u.part1.double_buffer = (uint32_t)(packed[7] >> 7);
   }
   else if ((uint32_t)(packed[0] & 1) == 1)
   {
      (*unpacked).type = V3D_BCFG_TYPE_PART2;
      assert((uint32_t)(packed[0] & 1) == 1);
      (*unpacked).u.part2.tile_alloc_size =
         ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
         (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6;
      (*unpacked).u.part2.tile_alloc_addr =
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6;
   }
   else
   {
      unreachable();
   }
}
#if V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_tile_rendering_mode_cfg(uint8_t *packed, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked)
{
   if ((*unpacked).type == V3D_RCFG_TYPE_COMMON)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COMMON);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_uint_minus_1(
         gfx_check_urange((*unpacked).u.common.num_rts, 1, 8), 4) << 4);
      packed[1] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff);
      packed[2] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff) >> 8);
      packed[3] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff);
      packed[4] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.common.max_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ms_mode, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.double_buffer, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.common.cov_mode, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_direction, 1) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_disable, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.common.internal_depth_type, 4) << 7);
      packed[6] = (uint8_t)(gfx_bits((*unpacked).u.common.internal_depth_type, 4) >>
         1) | (uint8_t)(gfx_bits((*unpacked).u.common.early_ds_clear, 1) << 3) |
         (uint8_t)0;
      packed[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_COLOR)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COLOR);
      packed[0] = (uint8_t)1 |
         (uint8_t)(gfx_bits((*unpacked).u.color.rts[0].internal_bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rts[0].internal_type, 4) << 6);
      packed[1] = (uint8_t)(gfx_bits((*unpacked).u.color.rts[0].internal_type, 4) >>
         2) | (uint8_t)(gfx_bits((*unpacked).u.color.rts[1].internal_bpp, 2) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rts[1].internal_type, 4) << 4);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.color.rts[2].internal_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rts[2].internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.rts[3].internal_bpp, 2) << 6);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.color.rts[3].internal_type, 4) |
         (uint8_t)0;
      packed[4] = (uint8_t)0;
      packed[5] = (uint8_t)0;
      packed[6] = (uint8_t)0;
      packed[7] = (uint8_t)0 | (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES);
      packed[0] = (uint8_t)2 | (uint8_t)0;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.zs_clear_values.stencil_clear, 8);
      packed[2] = (uint8_t)gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear);
      packed[3] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 8);
      packed[4] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 16);
      packed[5] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 24);
      packed[6] = (uint8_t)0;
      packed[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1);
      packed[0] = (uint8_t)3 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part1.rt, 0, 7) << 4);
      packed[1] = (uint8_t)(*unpacked).u.clear_colors_part1.clear_col_0;
      packed[2] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 24);
      packed[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24);
      packed[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 8);
      packed[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2);
      packed[0] = (uint8_t)4 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part2.rt, 0, 7) << 4);
      packed[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_1_shift24, 8);
      packed[2] = (uint8_t)(*unpacked).u.clear_colors_part2.clear_col_2;
      packed[3] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 8);
      packed[4] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 16);
      packed[5] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 24);
      packed[6] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16);
      packed[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3);
      packed[0] = (uint8_t)5 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.rt, 0, 7) << 4);
      packed[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16);
      packed[2] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16) >> 8);
      packed[3] = (uint8_t)0;
      packed[4] = (uint8_t)0;
      packed[5] = (uint8_t)0;
      packed[6] = (uint8_t)0;
      packed[7] = (uint8_t)0;
   }
   else
   {
      unreachable();
   }
}
void v3d_cl_unpack_tile_rendering_mode_cfg(V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 15) == 0)
   {
      (*unpacked).type = V3D_RCFG_TYPE_COMMON;
      assert((uint32_t)(packed[0] & 15) == 0);
      (*unpacked).u.common.num_rts =
         gfx_check_urange((uint32_t)(packed[0] >> 4) + 1, 1, 8);
      (*unpacked).u.common.frame_width = gfx_check_urange(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 1, 0xffff);
      (*unpacked).u.common.frame_height = gfx_check_urange(
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8, 1, 0xffff);
      (*unpacked).u.common.max_bpp = (v3d_rt_bpp_t)(uint32_t)(packed[5] & 3);
      (*unpacked).u.common.ms_mode = (uint32_t)(packed[5] >> 2 & 1);
      (*unpacked).u.common.double_buffer = (uint32_t)(packed[5] >> 3 & 1);
      (*unpacked).u.common.cov_mode = (uint32_t)(packed[5] >> 4 & 1);
      (*unpacked).u.common.ez_direction =
         (v3d_ez_direction_t)(uint32_t)(packed[5] >> 5 & 1);
      (*unpacked).u.common.ez_disable = (uint32_t)(packed[5] >> 6 & 1);
      (*unpacked).u.common.internal_depth_type =
         (v3d_depth_type_t)((uint32_t)(packed[5] >> 7) | (uint32_t)(packed[6] & 7) << 1);
      (*unpacked).u.common.early_ds_clear = (uint32_t)(packed[6] >> 3 & 1);
   }
   else if ((uint32_t)(packed[0] & 15) == 1)
   {
      (*unpacked).type = V3D_RCFG_TYPE_COLOR;
      assert((uint32_t)(packed[0] & 15) == 1);
      (*unpacked).u.color.rts[0].internal_bpp =
         (v3d_rt_bpp_t)(uint32_t)(packed[0] >> 4 & 3);
      (*unpacked).u.color.rts[0].internal_type =
         (v3d_rt_type_t)((uint32_t)(packed[0] >> 6) | (uint32_t)(packed[1] & 3) << 2);
      (*unpacked).u.color.rts[1].internal_bpp =
         (v3d_rt_bpp_t)(uint32_t)(packed[1] >> 2 & 3);
      (*unpacked).u.color.rts[1].internal_type =
         (v3d_rt_type_t)(uint32_t)(packed[1] >> 4);
      (*unpacked).u.color.rts[2].internal_bpp =
         (v3d_rt_bpp_t)(uint32_t)(packed[2] & 3);
      (*unpacked).u.color.rts[2].internal_type =
         (v3d_rt_type_t)(uint32_t)(packed[2] >> 2 & 15);
      (*unpacked).u.color.rts[3].internal_bpp =
         (v3d_rt_bpp_t)(uint32_t)(packed[2] >> 6);
      (*unpacked).u.color.rts[3].internal_type =
         (v3d_rt_type_t)(uint32_t)(packed[3] & 15);
   }
   else if ((uint32_t)(packed[0] & 15) == 2)
   {
      (*unpacked).type = V3D_RCFG_TYPE_ZS_CLEAR_VALUES;
      assert((uint32_t)(packed[0] & 15) == 2);
      (*unpacked).u.zs_clear_values.stencil_clear = (uint32_t)packed[1];
      (*unpacked).u.zs_clear_values.depth_clear = gfx_float_from_bits(
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24);
   }
   else if ((uint32_t)(packed[0] & 15) == 3)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART1;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.clear_colors_part1.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part1.clear_col_0 =
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24;
      (*unpacked).u.clear_colors_part1.clear_col_1_andm24 =
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 4)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART2;
      assert((uint32_t)(packed[0] & 15) == 4);
      (*unpacked).u.clear_colors_part2.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part2.clear_col_1_shift24 = (uint32_t)packed[1];
      (*unpacked).u.clear_colors_part2.clear_col_2 =
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24;
      (*unpacked).u.clear_colors_part2.clear_col_3_andm16 =
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 5)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART3;
      assert((uint32_t)(packed[0] & 15) == 5);
      (*unpacked).u.clear_colors_part3.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part3.clear_col_3_shift16 =
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
   }
   else
   {
      unreachable();
   }
}
#endif
#if !V3D_HAS_NEW_TLB_CFG
void v3d_cl_pack_tile_rendering_mode_cfg(uint8_t *packed, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked)
{
   if ((*unpacked).type == V3D_RCFG_TYPE_COMMON)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COMMON);
      packed[0] = (uint8_t)0 | (uint8_t)(gfx_pack_uint_minus_1(
         gfx_check_urange((*unpacked).u.common.num_rts, 1, 8), 4) << 4);
      packed[1] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff);
      packed[2] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff) >> 8);
      packed[3] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff);
      packed[4] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff) >> 8);
      packed[5] = (uint8_t)gfx_bits((*unpacked).u.common.max_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ms_mode, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.double_buffer, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.common.cov_mode, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_direction, 1) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_disable, 1) << 6) | (uint8_t)0;
      packed[6] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.common.stencil_store, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.common.depth_store, 1) << 7);
      packed[7] = (uint8_t)gfx_bits((*unpacked).u.common.disable_rt_store_mask, 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL);
      packed[0] = (uint8_t)1 | (uint8_t)0;
      packed[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.decimate_mode, 2) << 6);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.z_stencil.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) << 6);
      packed[3] =
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) << 1);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) >>
         7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) << 6);
      packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 2);
      packed[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 10);
      packed[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL);
      packed[0] = (uint8_t)1 | (uint8_t)(1 << 4);
      packed[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.decimate_mode, 2) << 6);
      packed[2] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) << 6);
      packed[3] =
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub, 13) << 1);
      packed[4] = (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub,
         13) >> 7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) <<
         6);
      packed[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         2);
      packed[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         10);
      packed[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_COLOR)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COLOR);
      packed[0] = (uint8_t)2 |
         (uint8_t)(gfx_check_urange((*unpacked).u.color.rt, 0, 7) << 4);
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.color.internal_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.decimate_mode, 2) << 6);
      packed[2] = (uint8_t)gfx_bits((*unpacked).u.color.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.color.dither_mode, 2) << 6);
      packed[3] = (uint8_t)gfx_bits((*unpacked).u.color.memory_format, 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.flipy, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.pad, 4) << 4);
      packed[4] = (uint8_t)(*unpacked).u.color.addr;
      packed[5] = (uint8_t)((*unpacked).u.color.addr >> 8);
      packed[6] = (uint8_t)((*unpacked).u.color.addr >> 16);
      packed[7] = (uint8_t)((*unpacked).u.color.addr >> 24);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES);
      packed[0] = (uint8_t)3 | (uint8_t)0;
      packed[1] = (uint8_t)gfx_bits((*unpacked).u.zs_clear_values.stencil_clear, 8);
      packed[2] = (uint8_t)gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear);
      packed[3] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 8);
      packed[4] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 16);
      packed[5] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 24);
      packed[6] = (uint8_t)0;
      packed[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1);
      packed[0] = (uint8_t)4 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part1.rt, 0, 7) << 4);
      packed[1] = (uint8_t)(*unpacked).u.clear_colors_part1.clear_col_0;
      packed[2] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 8);
      packed[3] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 16);
      packed[4] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 24);
      packed[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24);
      packed[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 8);
      packed[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2);
      packed[0] = (uint8_t)5 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part2.rt, 0, 7) << 4);
      packed[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_1_shift24, 8);
      packed[2] = (uint8_t)(*unpacked).u.clear_colors_part2.clear_col_2;
      packed[3] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 8);
      packed[4] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 16);
      packed[5] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 24);
      packed[6] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16);
      packed[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3);
      packed[0] = (uint8_t)6 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.rt, 0, 7) << 4);
      packed[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16);
      packed[2] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16) >> 8);
      packed[3] = (uint8_t)gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff);
      packed[4] = (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff) >> 8);
      packed[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.uif_height_in_ub, 13);
      packed[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.uif_height_in_ub, 13) >> 8) | (uint8_t)0;
      packed[7] = (uint8_t)0;
   }
   else
   {
      unreachable();
   }
}
void v3d_cl_unpack_tile_rendering_mode_cfg(V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked, const uint8_t *packed)
{
   if ((uint32_t)(packed[0] & 15) == 0)
   {
      (*unpacked).type = V3D_RCFG_TYPE_COMMON;
      assert((uint32_t)(packed[0] & 15) == 0);
      (*unpacked).u.common.num_rts =
         gfx_check_urange((uint32_t)(packed[0] >> 4) + 1, 1, 8);
      (*unpacked).u.common.frame_width = gfx_check_urange(
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8, 1, 0xffff);
      (*unpacked).u.common.frame_height = gfx_check_urange(
         (uint32_t)packed[3] | (uint32_t)packed[4] << 8, 1, 0xffff);
      (*unpacked).u.common.max_bpp = (v3d_rt_bpp_t)(uint32_t)(packed[5] & 3);
      (*unpacked).u.common.ms_mode = (uint32_t)(packed[5] >> 2 & 1);
      (*unpacked).u.common.double_buffer = (uint32_t)(packed[5] >> 3 & 1);
      (*unpacked).u.common.cov_mode = (uint32_t)(packed[5] >> 4 & 1);
      (*unpacked).u.common.ez_direction =
         (v3d_ez_direction_t)(uint32_t)(packed[5] >> 5 & 1);
      (*unpacked).u.common.ez_disable = (uint32_t)(packed[5] >> 6 & 1);
      (*unpacked).u.common.stencil_store = (uint32_t)(packed[6] >> 6 & 1);
      (*unpacked).u.common.depth_store = (uint32_t)(packed[6] >> 7);
      (*unpacked).u.common.disable_rt_store_mask = (uint32_t)packed[7];
   }
   else if ((uint32_t)(packed[0] & 15) == 1 && (uint32_t)(packed[0] >> 4) == 0)
   {
      (*unpacked).type = V3D_RCFG_TYPE_Z_STENCIL;
      assert((uint32_t)(packed[0] & 15) == 1);
      assert((uint32_t)(packed[0] >> 4) == 0);
      (*unpacked).u.z_stencil.internal_type =
         (v3d_depth_type_t)(uint32_t)(packed[1] >> 2 & 15);
      (*unpacked).u.z_stencil.decimate_mode =
         (v3d_decimate_t)(uint32_t)(packed[1] >> 6);
      (*unpacked).u.z_stencil.output_format =
         (v3d_depth_format_t)(uint32_t)(packed[2] & 63);
      (*unpacked).u.z_stencil.memory_format =
         (v3d_memory_format_t)((uint32_t)(packed[2] >> 6) |
         (uint32_t)(packed[3] & 1) << 2);
      (*unpacked).u.z_stencil.uif_height_in_ub = (uint32_t)(packed[3] >> 1) |
         (uint32_t)(packed[4] & 63) << 7;
      (*unpacked).u.z_stencil.addr =
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6;
   }
   else if ((uint32_t)(packed[0] & 15) == 1 && (uint32_t)(packed[0] >> 4) == 1)
   {
      (*unpacked).type = V3D_RCFG_TYPE_SEPARATE_STENCIL;
      assert((uint32_t)(packed[0] & 15) == 1);
      assert((uint32_t)(packed[0] >> 4) == 1);
      (*unpacked).u.separate_stencil.decimate_mode =
         (v3d_decimate_t)(uint32_t)(packed[1] >> 6);
      (*unpacked).u.separate_stencil.memory_format =
         (v3d_memory_format_t)((uint32_t)(packed[2] >> 6) |
         (uint32_t)(packed[3] & 1) << 2);
      (*unpacked).u.separate_stencil.uif_height_in_ub = (uint32_t)(packed[3] >> 1) |
         (uint32_t)(packed[4] & 63) << 7;
      (*unpacked).u.separate_stencil.addr =
         ((uint32_t)(packed[4] >> 6) | (uint32_t)packed[5] << 2 |
         (uint32_t)packed[6] << 10 | (uint32_t)packed[7] << 18) << 6;
   }
   else if ((uint32_t)(packed[0] & 15) == 2)
   {
      (*unpacked).type = V3D_RCFG_TYPE_COLOR;
      assert((uint32_t)(packed[0] & 15) == 2);
      (*unpacked).u.color.rt = gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.color.internal_bpp = (v3d_rt_bpp_t)(uint32_t)(packed[1] & 3);
      (*unpacked).u.color.internal_type =
         (v3d_rt_type_t)(uint32_t)(packed[1] >> 2 & 15);
      (*unpacked).u.color.decimate_mode = (v3d_decimate_t)(uint32_t)(packed[1] >> 6);
      (*unpacked).u.color.output_format =
         (v3d_pixel_format_t)(uint32_t)(packed[2] & 63);
      (*unpacked).u.color.dither_mode = (v3d_dither_t)(uint32_t)(packed[2] >> 6);
      (*unpacked).u.color.memory_format =
         (v3d_memory_format_t)(uint32_t)(packed[3] & 7);
      (*unpacked).u.color.flipy = (uint32_t)(packed[3] >> 3 & 1);
      (*unpacked).u.color.pad = (uint32_t)(packed[3] >> 4);
      (*unpacked).u.color.addr = (uint32_t)packed[4] | (uint32_t)packed[5] << 8 |
         (uint32_t)packed[6] << 16 | (uint32_t)packed[7] << 24;
   }
   else if ((uint32_t)(packed[0] & 15) == 3)
   {
      (*unpacked).type = V3D_RCFG_TYPE_ZS_CLEAR_VALUES;
      assert((uint32_t)(packed[0] & 15) == 3);
      (*unpacked).u.zs_clear_values.stencil_clear = (uint32_t)packed[1];
      (*unpacked).u.zs_clear_values.depth_clear = gfx_float_from_bits(
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24);
   }
   else if ((uint32_t)(packed[0] & 15) == 4)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART1;
      assert((uint32_t)(packed[0] & 15) == 4);
      (*unpacked).u.clear_colors_part1.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part1.clear_col_0 =
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8 | (uint32_t)packed[3] << 16 |
         (uint32_t)packed[4] << 24;
      (*unpacked).u.clear_colors_part1.clear_col_1_andm24 =
         (uint32_t)packed[5] | (uint32_t)packed[6] << 8 | (uint32_t)packed[7] << 16;
   }
   else if ((uint32_t)(packed[0] & 15) == 5)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART2;
      assert((uint32_t)(packed[0] & 15) == 5);
      (*unpacked).u.clear_colors_part2.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part2.clear_col_1_shift24 = (uint32_t)packed[1];
      (*unpacked).u.clear_colors_part2.clear_col_2 =
         (uint32_t)packed[2] | (uint32_t)packed[3] << 8 | (uint32_t)packed[4] << 16 |
         (uint32_t)packed[5] << 24;
      (*unpacked).u.clear_colors_part2.clear_col_3_andm16 =
         (uint32_t)packed[6] | (uint32_t)packed[7] << 8;
   }
   else if ((uint32_t)(packed[0] & 15) == 6)
   {
      (*unpacked).type = V3D_RCFG_TYPE_CLEAR_COLORS_PART3;
      assert((uint32_t)(packed[0] & 15) == 6);
      (*unpacked).u.clear_colors_part3.rt =
         gfx_check_urange((uint32_t)(packed[0] >> 4), 0, 7);
      (*unpacked).u.clear_colors_part3.clear_col_3_shift16 =
         (uint32_t)packed[1] | (uint32_t)packed[2] << 8;
      (*unpacked).u.clear_colors_part3.raster_padded_width_or_nonraster_height =
         gfx_check_urange((uint32_t)packed[3] | (uint32_t)packed[4] << 8, 0, 0x1fff);
      (*unpacked).u.clear_colors_part3.uif_height_in_ub =
         (uint32_t)packed[5] | (uint32_t)(packed[6] & 31) << 8;
   }
   else
   {
      unreachable();
   }
}
#endif
void v3d_cl_pack_multicore_rendering_supertile_cfg(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked)
{
   packed[0] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_w_in_tiles, 8);
   packed[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_h_in_tiles, 8);
   packed[2] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_supertiles, 1, 255);
   packed[3] = (uint8_t)gfx_check_urange((*unpacked).frame_h_in_supertiles, 1, 255);
   packed[4] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff);
   packed[5] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) << 4);
   packed[6] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) >> 4);
   packed[7] = (uint8_t)gfx_bits((*unpacked).multicore, 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).supertile_order, 1) << 4) |
      (uint8_t)(gfx_pack_uint_minus_1((*unpacked).num_bin_tile_lists, 3) << 5);
}
void v3d_cl_unpack_multicore_rendering_supertile_cfg(V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked, const uint8_t *packed)
{
   (*unpacked).supertile_w_in_tiles = (uint32_t)packed[0] + 1;
   (*unpacked).supertile_h_in_tiles = (uint32_t)packed[1] + 1;
   (*unpacked).frame_w_in_supertiles =
      gfx_check_urange((uint32_t)packed[2], 1, 255);
   (*unpacked).frame_h_in_supertiles =
      gfx_check_urange((uint32_t)packed[3], 1, 255);
   (*unpacked).frame_w_in_tiles = gfx_check_urange(
      (uint32_t)packed[4] | (uint32_t)(packed[5] & 15) << 8, 1, 0xfff);
   (*unpacked).frame_h_in_tiles = gfx_check_urange(
      (uint32_t)(packed[5] >> 4) | (uint32_t)packed[6] << 4, 1, 0xfff);
   (*unpacked).multicore = (uint32_t)(packed[7] & 1);
   (*unpacked).supertile_order =
      (v3d_supertile_order_t)(uint32_t)(packed[7] >> 4 & 1);
   (*unpacked).num_bin_tile_lists = (uint32_t)(packed[7] >> 5) + 1;
}
void v3d_cl_pack_multicore_rendering_tile_list_base(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).set, 4) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) << 6);
   packed[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 2);
   packed[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 10);
   packed[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 18);
}
void v3d_cl_unpack_multicore_rendering_tile_list_base(V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).set = (uint32_t)(packed[0] & 15);
   (*unpacked).addr = ((uint32_t)(packed[0] >> 6) | (uint32_t)packed[1] << 2 |
      (uint32_t)packed[2] << 10 | (uint32_t)packed[3] << 18) << 6;
}
void v3d_cl_pack_tile_coords(uint8_t *packed, const V3D_CL_TILE_COORDS_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).x, 12);
   packed[1] = (uint8_t)(gfx_bits((*unpacked).x, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).y, 12) << 4);
   packed[2] = (uint8_t)(gfx_bits((*unpacked).y, 12) >> 4);
}
void v3d_cl_unpack_tile_coords(V3D_CL_TILE_COORDS_T *unpacked, const uint8_t *packed)
{
   (*unpacked).x = (uint32_t)packed[0] | (uint32_t)(packed[1] & 15) << 8;
   (*unpacked).y = (uint32_t)(packed[1] >> 4) | (uint32_t)packed[2] << 4;
}
void v3d_cl_pack_tile_list_initial_block_size(uint8_t *packed, const V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked)
{
   packed[0] = (uint8_t)gfx_bits((*unpacked).block_size, 2) |
      (uint8_t)(gfx_bits((*unpacked).chain, 1) << 2) | (uint8_t)0;
}
void v3d_cl_unpack_tile_list_initial_block_size(V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked, const uint8_t *packed)
{
   (*unpacked).block_size = (v3d_tile_alloc_block_size_t)(uint32_t)(packed[0] & 3);
   (*unpacked).chain = (uint32_t)(packed[0] >> 2 & 1);
}
void v3d_cl_pack_instr(uint8_t *packed_instr, const V3D_CL_INSTR_T *instr)
{
   packed_instr[0] = (uint8_t)instr->opcode;
   switch (instr->opcode) {
   case V3D_CL_HALT: break;
   case V3D_CL_NOP: break;
   case V3D_CL_FLUSH: break;
   case V3D_CL_FLUSH_ALL_STATE: break;
   case V3D_CL_START_TILE_BINNING: break;
   case V3D_CL_INCR_SEMAPHORE: break;
   case V3D_CL_WAIT_SEMAPHORE: break;
   case V3D_CL_WAIT_PREV_FRAME: break;
   case V3D_CL_ENABLE_Z_ONLY: break;
   case V3D_CL_DISABLE_Z_ONLY: break;
   case V3D_CL_END_Z_ONLY: break;
   case V3D_CL_END_RENDER: break;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: v3d_cl_pack_wait_transform_feedback(packed_instr + 1, &instr->u.wait_transform_feedback); break;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: v3d_cl_pack_branch(packed_instr + 1, &instr->u.branch); break;
   case V3D_CL_RETURN: break;
   case V3D_CL_FLUSH_VCD_CACHE: break;
   case V3D_CL_GENERIC_TILE_LIST: v3d_cl_pack_generic_tile_list(packed_instr + 1, &instr->u.generic_tile_list); break;
   case V3D_CL_BRANCH_IMPLICIT_TILE: v3d_cl_pack_branch_implicit_tile(packed_instr + 1, &instr->u.branch_implicit_tile); break;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: v3d_cl_pack_branch_explicit_supertile(packed_instr + 1, &instr->u.branch_explicit_supertile); break;
   case V3D_CL_SUPERTILE_COORDS: v3d_cl_pack_supertile_coords(packed_instr + 1, &instr->u.supertile_coords); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: v3d_cl_pack_clear(packed_instr + 1, &instr->u.clear); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: v3d_cl_pack_store(packed_instr + 1, &instr->u.store); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_pack_load(packed_instr + 1, &instr->u.load); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: v3d_cl_pack_store_subsample_ex(packed_instr + 1, &instr->u.store_subsample_ex); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_pack_load(packed_instr + 1, &instr->u.load); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: v3d_cl_pack_store_general(packed_instr + 1, &instr->u.store_general); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: v3d_cl_pack_load_general(packed_instr + 1, &instr->u.load_general); break;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: break;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_pack_indexed_prim_list(packed_instr + 1, &instr->u.indexed_prim_list); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_pack_indexed_prim_list(packed_instr + 1, &instr->u.indexed_prim_list); break;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: v3d_cl_pack_indirect_indexed_prim_list(packed_instr + 1, &instr->u.indirect_indexed_prim_list); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_pack_indexed_instanced_prim_list(packed_instr + 1, &instr->u.indexed_instanced_prim_list); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_pack_indexed_instanced_prim_list(packed_instr + 1, &instr->u.indexed_instanced_prim_list); break;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: v3d_cl_pack_vertex_array_prims(packed_instr + 1, &instr->u.vertex_array_prims); break;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: v3d_cl_pack_indirect_vertex_array_prims(packed_instr + 1, &instr->u.indirect_vertex_array_prims); break;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: v3d_cl_pack_vertex_array_instanced_prims(packed_instr + 1, &instr->u.vertex_array_instanced_prims); break;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: v3d_cl_pack_vertex_array_single_instance_prims(packed_instr + 1, &instr->u.vertex_array_single_instance_prims); break;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: v3d_cl_pack_base_vertex_base_instance(packed_instr + 1, &instr->u.base_vertex_base_instance); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_pack_indirect_primitive_limits(packed_instr + 1, &instr->u.indirect_primitive_limits); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_pack_indirect_primitive_limits(packed_instr + 1, &instr->u.indirect_primitive_limits); break;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: v3d_cl_pack_vg_coord_array_prims(packed_instr + 1, &instr->u.vg_coord_array_prims); break;
   case V3D_CL_VG_INLINE_PRIMS: v3d_cl_pack_vg_inline_prims(packed_instr + 1, &instr->u.vg_inline_prims); break;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: break;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: break;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: v3d_cl_pack_clipped_prim(packed_instr + 1, &instr->u.clipped_prim); break;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: v3d_cl_pack_set_instance_id(packed_instr + 1, &instr->u.set_instance_id); break;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: v3d_cl_pack_prim_list_format(packed_instr + 1, &instr->u.prim_list_format); break;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: v3d_cl_pack_serial_number_list_start(packed_instr + 1, &instr->u.serial_number_list_start); break;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: v3d_cl_pack_gl_shader(packed_instr + 1, &instr->u.gl_shader); break;
   case V3D_CL_VG_SHADER: v3d_cl_pack_vg_shader(packed_instr + 1, &instr->u.vg_shader); break;
   case V3D_CL_VG_INLINE_SHADER: v3d_cl_pack_vg_inline_shader(packed_instr + 1, &instr->u.vg_inline_shader); break;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_pack_vcm_cache_size(packed_instr + 1, &instr->u.vcm_cache_size); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: v3d_cl_pack_prim_counts_feedback(packed_instr + 1, &instr->u.prim_counts_feedback); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: v3d_cl_pack_transform_feedback_buffer(packed_instr + 1, &instr->u.transform_feedback_buffer); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: v3d_cl_pack_transform_feedback_specs(packed_instr + 1, &instr->u.transform_feedback_specs); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_pack_vcm_cache_size(packed_instr + 1, &instr->u.vcm_cache_size); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: v3d_cl_pack_transform_feedback_enable(packed_instr + 1, &instr->u.transform_feedback_enable); break;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: break;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: v3d_cl_pack_l1_cache_flush_control(packed_instr + 1, &instr->u.l1_cache_flush_control); break;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: v3d_cl_pack_l2t_cache_flush_control(packed_instr + 1, &instr->u.l2t_cache_flush_control); break;
   case V3D_CL_L2C_CACHE_FLUSH: break;
   case V3D_CL_STENCIL_CFG: v3d_cl_pack_stencil_cfg(packed_instr + 1, &instr->u.stencil_cfg); break;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_pack_blend_cfg(packed_instr + 1, &instr->u.blend_cfg); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: v3d_cl_pack_blend_enables(packed_instr + 1, &instr->u.blend_enables); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_pack_blend_cfg(packed_instr + 1, &instr->u.blend_cfg); break;
#endif
   case V3D_CL_BLEND_CCOLOR: v3d_cl_pack_blend_ccolor(packed_instr + 1, &instr->u.blend_ccolor); break;
   case V3D_CL_COLOR_WMASKS: v3d_cl_pack_color_wmasks(packed_instr + 1, &instr->u.color_wmasks); break;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: break;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: break;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: v3d_cl_pack_vary_flags(packed_instr + 1, &instr->u.vary_flags); break;
   case V3D_CL_SAMPLE_COVERAGE: v3d_cl_pack_sample_coverage(packed_instr + 1, &instr->u.sample_coverage); break;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: v3d_cl_pack_occlusion_query_counter_enable(packed_instr + 1, &instr->u.occlusion_query_counter_enable); break;
   case V3D_CL_CFG_BITS: v3d_cl_pack_cfg_bits(packed_instr + 1, &instr->u.cfg_bits); break;
   case V3D_CL_POINT_SIZE: v3d_cl_pack_point_size(packed_instr + 1, &instr->u.point_size); break;
   case V3D_CL_LINE_WIDTH: v3d_cl_pack_line_width(packed_instr + 1, &instr->u.line_width); break;
   case V3D_CL_DEPTH_OFFSET: v3d_cl_pack_depth_offset(packed_instr + 1, &instr->u.depth_offset); break;
   case V3D_CL_CLIP: v3d_cl_pack_clip(packed_instr + 1, &instr->u.clip); break;
   case V3D_CL_VIEWPORT_OFFSET: v3d_cl_pack_viewport_offset(packed_instr + 1, &instr->u.viewport_offset); break;
   case V3D_CL_CLIPZ: v3d_cl_pack_clipz(packed_instr + 1, &instr->u.clipz); break;
   case V3D_CL_CLIPPER_XY: v3d_cl_pack_clipper_xy(packed_instr + 1, &instr->u.clipper_xy); break;
   case V3D_CL_CLIPPER_Z: v3d_cl_pack_clipper_z(packed_instr + 1, &instr->u.clipper_z); break;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: v3d_cl_pack_num_layers(packed_instr + 1, &instr->u.num_layers); break;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: v3d_cl_pack_tile_binning_mode_cfg(packed_instr + 1, &instr->u.tile_binning_mode_cfg); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_pack_tile_rendering_mode_cfg(packed_instr + 1, &instr->u.tile_rendering_mode_cfg); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_pack_tile_rendering_mode_cfg(packed_instr + 1, &instr->u.tile_rendering_mode_cfg); break;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: v3d_cl_pack_multicore_rendering_supertile_cfg(packed_instr + 1, &instr->u.multicore_rendering_supertile_cfg); break;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: v3d_cl_pack_multicore_rendering_tile_list_base(packed_instr + 1, &instr->u.multicore_rendering_tile_list_base); break;
   case V3D_CL_TILE_COORDS: v3d_cl_pack_tile_coords(packed_instr + 1, &instr->u.tile_coords); break;
   case V3D_CL_IMPLICIT_TILE_COORDS: break;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: v3d_cl_pack_tile_list_initial_block_size(packed_instr + 1, &instr->u.tile_list_initial_block_size); break;
   default: unreachable();
   }
}
void v3d_cl_unpack_instr(V3D_CL_INSTR_T *instr, const uint8_t *packed_instr)
{
   instr->opcode = (v3d_cl_opcode_t)packed_instr[0];
   switch (instr->opcode) {
   case V3D_CL_HALT: break;
   case V3D_CL_NOP: break;
   case V3D_CL_FLUSH: break;
   case V3D_CL_FLUSH_ALL_STATE: break;
   case V3D_CL_START_TILE_BINNING: break;
   case V3D_CL_INCR_SEMAPHORE: break;
   case V3D_CL_WAIT_SEMAPHORE: break;
   case V3D_CL_WAIT_PREV_FRAME: break;
   case V3D_CL_ENABLE_Z_ONLY: break;
   case V3D_CL_DISABLE_Z_ONLY: break;
   case V3D_CL_END_Z_ONLY: break;
   case V3D_CL_END_RENDER: break;
   case V3D_CL_WAIT_TRANSFORM_FEEDBACK: v3d_cl_unpack_wait_transform_feedback(&instr->u.wait_transform_feedback, packed_instr + 1); break;
   case V3D_CL_BRANCH_SUB_AUTOCHAIN:
   case V3D_CL_BRANCH:
   case V3D_CL_BRANCH_SUB: v3d_cl_unpack_branch(&instr->u.branch, packed_instr + 1); break;
   case V3D_CL_RETURN: break;
   case V3D_CL_FLUSH_VCD_CACHE: break;
   case V3D_CL_GENERIC_TILE_LIST: v3d_cl_unpack_generic_tile_list(&instr->u.generic_tile_list, packed_instr + 1); break;
   case V3D_CL_BRANCH_IMPLICIT_TILE: v3d_cl_unpack_branch_implicit_tile(&instr->u.branch_implicit_tile, packed_instr + 1); break;
   case V3D_CL_BRANCH_EXPLICIT_SUPERTILE: v3d_cl_unpack_branch_explicit_supertile(&instr->u.branch_explicit_supertile, packed_instr + 1); break;
   case V3D_CL_SUPERTILE_COORDS: v3d_cl_unpack_supertile_coords(&instr->u.supertile_coords, packed_instr + 1); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_CLEAR: v3d_cl_unpack_clear(&instr->u.clear, packed_instr + 1); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_LOADS: break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE: v3d_cl_unpack_store(&instr->u.store, packed_instr + 1); break;
#endif
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_unpack_load(&instr->u.load, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE: break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_SUBSAMPLE_EX: v3d_cl_unpack_store_subsample_ex(&instr->u.store_subsample_ex, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD: v3d_cl_unpack_load(&instr->u.load, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_END_TILE: break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_STORE_GENERAL: v3d_cl_unpack_store_general(&instr->u.store_general, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_LOAD_GENERAL: v3d_cl_unpack_load_general(&instr->u.load_general, packed_instr + 1); break;
#endif
#if V3D_HAS_TF_EXPLICIT_FC
   case V3D_CL_TF_DRAW_FLUSH_AND_COUNT: break;
#endif
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_unpack_indexed_prim_list(&instr->u.indexed_prim_list, packed_instr + 1); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_PRIM_LIST: v3d_cl_unpack_indexed_prim_list(&instr->u.indexed_prim_list, packed_instr + 1); break;
#endif
   case V3D_CL_INDIRECT_INDEXED_PRIM_LIST: v3d_cl_unpack_indirect_indexed_prim_list(&instr->u.indirect_indexed_prim_list, packed_instr + 1); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_unpack_indexed_instanced_prim_list(&instr->u.indexed_instanced_prim_list, packed_instr + 1); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDEXED_INSTANCED_PRIM_LIST: v3d_cl_unpack_indexed_instanced_prim_list(&instr->u.indexed_instanced_prim_list, packed_instr + 1); break;
#endif
   case V3D_CL_VERTEX_ARRAY_PRIMS: v3d_cl_unpack_vertex_array_prims(&instr->u.vertex_array_prims, packed_instr + 1); break;
   case V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS: v3d_cl_unpack_indirect_vertex_array_prims(&instr->u.indirect_vertex_array_prims, packed_instr + 1); break;
   case V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS: v3d_cl_unpack_vertex_array_instanced_prims(&instr->u.vertex_array_instanced_prims, packed_instr + 1); break;
   case V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS: v3d_cl_unpack_vertex_array_single_instance_prims(&instr->u.vertex_array_single_instance_prims, packed_instr + 1); break;
   case V3D_CL_BASE_VERTEX_BASE_INSTANCE: v3d_cl_unpack_base_vertex_base_instance(&instr->u.base_vertex_base_instance, packed_instr + 1); break;
#if V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_unpack_indirect_primitive_limits(&instr->u.indirect_primitive_limits, packed_instr + 1); break;
#endif
#if !V3D_HAS_32BIT_INDS
   case V3D_CL_INDIRECT_PRIMITIVE_LIMITS: v3d_cl_unpack_indirect_primitive_limits(&instr->u.indirect_primitive_limits, packed_instr + 1); break;
#endif
   case V3D_CL_VG_COORD_ARRAY_PRIMS: v3d_cl_unpack_vg_coord_array_prims(&instr->u.vg_coord_array_prims, packed_instr + 1); break;
   case V3D_CL_VG_INLINE_PRIMS: v3d_cl_unpack_vg_inline_prims(&instr->u.vg_inline_prims, packed_instr + 1); break;
   case V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO: break;
   case V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID: break;
#if !V3D_HAS_INLINE_CLIP
   case V3D_CL_CLIPPED_PRIM_IID_ZERO:
   case V3D_CL_CLIPPED_PRIM_CURRENT_IID: v3d_cl_unpack_clipped_prim(&instr->u.clipped_prim, packed_instr + 1); break;
#endif
#if V3D_HAS_BASEINSTANCE
   case V3D_CL_SET_INSTANCE_ID: v3d_cl_unpack_set_instance_id(&instr->u.set_instance_id, packed_instr + 1); break;
#endif
   case V3D_CL_PRIM_LIST_FORMAT: v3d_cl_unpack_prim_list_format(&instr->u.prim_list_format, packed_instr + 1); break;
#if V3D_HAS_TNG
   case V3D_CL_SERIAL_NUMBER_LIST_START: v3d_cl_unpack_serial_number_list_start(&instr->u.serial_number_list_start, packed_instr + 1); break;
#endif
   case V3D_CL_GL_SHADER:
   case V3D_CL_GL_T_SHADER:
   case V3D_CL_GL_G_SHADER:
   case V3D_CL_GL_TG_SHADER:
   case V3D_CL_NV_SHADER: v3d_cl_unpack_gl_shader(&instr->u.gl_shader, packed_instr + 1); break;
   case V3D_CL_VG_SHADER: v3d_cl_unpack_vg_shader(&instr->u.vg_shader, packed_instr + 1); break;
   case V3D_CL_VG_INLINE_SHADER: v3d_cl_unpack_vg_inline_shader(&instr->u.vg_inline_shader, packed_instr + 1); break;
#if V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_unpack_vcm_cache_size(&instr->u.vcm_cache_size, packed_instr + 1); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_PRIM_COUNTS_FEEDBACK: v3d_cl_unpack_prim_counts_feedback(&instr->u.prim_counts_feedback, packed_instr + 1); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_BUFFER: v3d_cl_unpack_transform_feedback_buffer(&instr->u.transform_feedback_buffer, packed_instr + 1); break;
#endif
#if V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_SPECS: v3d_cl_unpack_transform_feedback_specs(&instr->u.transform_feedback_specs, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_VCM_CACHE_SIZE: v3d_cl_unpack_vcm_cache_size(&instr->u.vcm_cache_size, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TF
   case V3D_CL_TRANSFORM_FEEDBACK_ENABLE: v3d_cl_unpack_transform_feedback_enable(&instr->u.transform_feedback_enable, packed_instr + 1); break;
#endif
   case V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA: break;
   case V3D_CL_L1_CACHE_FLUSH_CONTROL: v3d_cl_unpack_l1_cache_flush_control(&instr->u.l1_cache_flush_control, packed_instr + 1); break;
   case V3D_CL_L2T_CACHE_FLUSH_CONTROL: v3d_cl_unpack_l2t_cache_flush_control(&instr->u.l2t_cache_flush_control, packed_instr + 1); break;
   case V3D_CL_L2C_CACHE_FLUSH: break;
   case V3D_CL_STENCIL_CFG: v3d_cl_unpack_stencil_cfg(&instr->u.stencil_cfg, packed_instr + 1); break;
#if !V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_unpack_blend_cfg(&instr->u.blend_cfg, packed_instr + 1); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_ENABLES: v3d_cl_unpack_blend_enables(&instr->u.blend_enables, packed_instr + 1); break;
#endif
#if V3D_HAS_PER_RT_BLEND
   case V3D_CL_BLEND_CFG: v3d_cl_unpack_blend_cfg(&instr->u.blend_cfg, packed_instr + 1); break;
#endif
   case V3D_CL_BLEND_CCOLOR: v3d_cl_unpack_blend_ccolor(&instr->u.blend_ccolor, packed_instr + 1); break;
   case V3D_CL_COLOR_WMASKS: v3d_cl_unpack_color_wmasks(&instr->u.color_wmasks, packed_instr + 1); break;
   case V3D_CL_ZERO_ALL_CENTROID_FLAGS: break;
   case V3D_CL_ZERO_ALL_FLATSHADE_FLAGS: break;
   case V3D_CL_CENTROID_FLAGS:
   case V3D_CL_FLATSHADE_FLAGS: v3d_cl_unpack_vary_flags(&instr->u.vary_flags, packed_instr + 1); break;
   case V3D_CL_SAMPLE_COVERAGE: v3d_cl_unpack_sample_coverage(&instr->u.sample_coverage, packed_instr + 1); break;
   case V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE: v3d_cl_unpack_occlusion_query_counter_enable(&instr->u.occlusion_query_counter_enable, packed_instr + 1); break;
   case V3D_CL_CFG_BITS: v3d_cl_unpack_cfg_bits(&instr->u.cfg_bits, packed_instr + 1); break;
   case V3D_CL_POINT_SIZE: v3d_cl_unpack_point_size(&instr->u.point_size, packed_instr + 1); break;
   case V3D_CL_LINE_WIDTH: v3d_cl_unpack_line_width(&instr->u.line_width, packed_instr + 1); break;
   case V3D_CL_DEPTH_OFFSET: v3d_cl_unpack_depth_offset(&instr->u.depth_offset, packed_instr + 1); break;
   case V3D_CL_CLIP: v3d_cl_unpack_clip(&instr->u.clip, packed_instr + 1); break;
   case V3D_CL_VIEWPORT_OFFSET: v3d_cl_unpack_viewport_offset(&instr->u.viewport_offset, packed_instr + 1); break;
   case V3D_CL_CLIPZ: v3d_cl_unpack_clipz(&instr->u.clipz, packed_instr + 1); break;
   case V3D_CL_CLIPPER_XY: v3d_cl_unpack_clipper_xy(&instr->u.clipper_xy, packed_instr + 1); break;
   case V3D_CL_CLIPPER_Z: v3d_cl_unpack_clipper_z(&instr->u.clipper_z, packed_instr + 1); break;
#if V3D_HAS_RENDER_LAYERS
   case V3D_CL_NUM_LAYERS: v3d_cl_unpack_num_layers(&instr->u.num_layers, packed_instr + 1); break;
#endif
   case V3D_CL_TILE_BINNING_MODE_CFG: v3d_cl_unpack_tile_binning_mode_cfg(&instr->u.tile_binning_mode_cfg, packed_instr + 1); break;
#if V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_unpack_tile_rendering_mode_cfg(&instr->u.tile_rendering_mode_cfg, packed_instr + 1); break;
#endif
#if !V3D_HAS_NEW_TLB_CFG
   case V3D_CL_TILE_RENDERING_MODE_CFG: v3d_cl_unpack_tile_rendering_mode_cfg(&instr->u.tile_rendering_mode_cfg, packed_instr + 1); break;
#endif
   case V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG: v3d_cl_unpack_multicore_rendering_supertile_cfg(&instr->u.multicore_rendering_supertile_cfg, packed_instr + 1); break;
   case V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE: v3d_cl_unpack_multicore_rendering_tile_list_base(&instr->u.multicore_rendering_tile_list_base, packed_instr + 1); break;
   case V3D_CL_TILE_COORDS: v3d_cl_unpack_tile_coords(&instr->u.tile_coords, packed_instr + 1); break;
   case V3D_CL_IMPLICIT_TILE_COORDS: break;
   case V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE: v3d_cl_unpack_tile_list_initial_block_size(&instr->u.tile_list_initial_block_size, packed_instr + 1); break;
   default: unreachable();
   }
}
