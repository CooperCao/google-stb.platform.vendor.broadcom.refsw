/*=============================================================================
Broadcom Proprietary and Confidential. (c)2014 Broadcom.
All rights reserved.

Project  :  helpers
Module   :

FILE DESCRIPTION
=============================================================================*/

#ifndef V3D_CL_H
#define V3D_CL_H

#include "v3d_common.h"
#include "v3d_gen.h"
#include "v3d_util.h"
#include "libs/util/gfx_util/gfx_util.h"
#include <string.h>
#include <stdio.h>

VCOS_EXTERN_C_BEGIN

/* TODO this should be generated by codegen.py */
#define V3D_CL_TILE_BINNING_MODE_CFG_PART2_TILE_ALLOC_SIZE_OFFSET 1

extern bool v3d_prim_mode_is_patch(v3d_prim_mode_t prim_mode);
extern v3d_prim_type_t v3d_prim_type_from_mode(v3d_prim_mode_t prim_mode);
extern v3d_prim_type_t v3d_prim_type_from_tess_type(v3d_cl_tess_type_t tess_type);
extern bool v3d_prim_type_is_patch(v3d_prim_type_t prim_type);
extern uint32_t v3d_prim_mode_num_verts(v3d_prim_mode_t prim_mode);
extern uint32_t v3d_prim_type_num_verts(v3d_prim_type_t prim_type);

static inline v3d_prim_type_t v3d_prim_type_from_wireframe_mode(v3d_wireframe_mode_t mode)
{
   switch (mode)
   {
   case V3D_WIREFRAME_MODE_LINES:   return V3D_PRIM_TYPE_LINE;
   case V3D_WIREFRAME_MODE_POINTS:  return V3D_PRIM_TYPE_POINT;
   default:                         unreachable(); return V3D_PRIM_TYPE_INVALID;
   }
}

extern v3d_pixel_format_t v3d_raw_mode_pixel_format(v3d_rt_type_t type, v3d_rt_bpp_t bpp);

extern void v3d_pixel_format_internal_type_and_bpp(
   v3d_rt_type_t *type, v3d_rt_bpp_t *bpp,
   v3d_pixel_format_t pixel_format);

static inline v3d_rt_type_t v3d_pixel_format_internal_type(v3d_pixel_format_t pixel_format)
{
   v3d_rt_type_t type;
   v3d_rt_bpp_t bpp;
   v3d_pixel_format_internal_type_and_bpp(&type, &bpp, pixel_format);
   return type;
}

static inline v3d_rt_bpp_t v3d_pixel_format_internal_bpp(v3d_pixel_format_t pixel_format)
{
   v3d_rt_type_t type;
   v3d_rt_bpp_t bpp;
   v3d_pixel_format_internal_type_and_bpp(&type, &bpp, pixel_format);
   return bpp;
}

static inline v3d_pixel_format_t v3d_pixel_format_raw_mode(v3d_pixel_format_t pixel_format)
{
   return v3d_raw_mode_pixel_format(
      v3d_pixel_format_internal_type(pixel_format),
      v3d_pixel_format_internal_bpp(pixel_format));
}

static inline bool v3d_memory_and_pixel_formats_compatible(
   v3d_memory_format_t memory_format, v3d_pixel_format_t pixel_format)
{
   switch (pixel_format)
   {
   case V3D_PIXEL_FORMAT_SRGB8:
   case V3D_PIXEL_FORMAT_RGB8:
      /* 24-bit formats only compatible with raster */
      return memory_format == V3D_MEMORY_FORMAT_RASTER;
   default:
      /* No restrictions on other pixel formats */
      return true;
   }
}

void v3d_pack_clear_color(uint32_t packed[4], const uint32_t col[4],
                          v3d_rt_type_t type, v3d_rt_bpp_t bpp);

static inline uint32_t v3d_cl_rcfg_clear_colors_size(
   v3d_rt_bpp_t bpp, uint32_t pad)
{
   return V3D_CL_TILE_RENDERING_MODE_CFG_SIZE * (
      /* Always have clear colors 1 */
      1 +
      /* Have clear colors 2 if >= 64 bits */
      (((bpp == V3D_RT_BPP_64) || (bpp == V3D_RT_BPP_128)) ? 1 : 0) +
      /* Have clear colors 3 if 128 bits or need to use the extra fields */
      (((bpp == V3D_RT_BPP_128) || (pad == 15)) ? 1 : 0));
}

void v3d_cl_rcfg_clear_colors(uint8_t **cl, uint32_t rt,
   const uint32_t col[4],
   v3d_rt_type_t type, v3d_rt_bpp_t bpp,
   uint32_t pad,
   uint32_t clear3_raster_padded_width_or_nonraster_height,
   uint32_t clear3_uif_height_in_ub);

extern v3d_depth_type_t v3d_depth_format_internal_type(v3d_depth_format_t depth_format);

extern float v3d_snap_depth(float depth, v3d_depth_type_t depth_type);

static inline bool v3d_dither_rgb(v3d_dither_t dither)
{
   switch (dither) {
   case V3D_DITHER_OFF:
   case V3D_DITHER_A:
      return false;
   case V3D_DITHER_RGB:
   case V3D_DITHER_RGBA:
      return true;
   default:
      unreachable();
      return false;
   }
}

static inline bool v3d_dither_a(v3d_dither_t dither)
{
   switch (dither) {
   case V3D_DITHER_OFF:
   case V3D_DITHER_RGB:
      return false;
   case V3D_DITHER_A:
   case V3D_DITHER_RGBA:
      return true;
   default:
      unreachable();
      return false;
   }
}

static inline bool v3d_blend_needs_cc (v3d_blend_mul_t factor)
{
   switch (factor) {
   case V3D_BLEND_MUL_ZERO          :  return false;
   case V3D_BLEND_MUL_ONE           :  return false;
   case V3D_BLEND_MUL_SRC           :  return false;
   case V3D_BLEND_MUL_OM_SRC        :  return false;
   case V3D_BLEND_MUL_DST           :  return false;
   case V3D_BLEND_MUL_OM_DST        :  return false;
   case V3D_BLEND_MUL_SRC_ALPHA     :  return false;
   case V3D_BLEND_MUL_OM_SRC_ALPHA  :  return false;
   case V3D_BLEND_MUL_DST_ALPHA     :  return false;
   case V3D_BLEND_MUL_OM_DST_ALPHA  :  return false;
   case V3D_BLEND_MUL_CONST         :  return true;
   case V3D_BLEND_MUL_OM_CONST      :  return true;
   case V3D_BLEND_MUL_CONST_ALPHA   :  return true;
   case V3D_BLEND_MUL_OM_CONST_ALPHA:  return true;
   case V3D_BLEND_MUL_SRC_ALPHA_SAT :  return false;
   case V3D_BLEND_MUL_INVALID       :  return false;
   default:                            return false;
   }
}

typedef enum {
   V3D_LDST_BUF_CLASS_NONE,
   V3D_LDST_BUF_CLASS_COLOR,
   V3D_LDST_BUF_CLASS_DEPTH_STENCIL,
   V3D_LDST_BUF_CLASS_INVALID
} v3d_ldst_buf_class_t;

static inline v3d_ldst_buf_class_t v3d_classify_ldst_buf(v3d_ldst_buf_t buf)
{
   if (buf <= V3D_LDST_BUF_COLOR7) {
      return V3D_LDST_BUF_CLASS_COLOR;
   }
   switch (buf) {
   case V3D_LDST_BUF_NONE:
      return V3D_LDST_BUF_CLASS_NONE;
   case V3D_LDST_BUF_DEPTH:
   case V3D_LDST_BUF_STENCIL:
   case V3D_LDST_BUF_PACKED_DEPTH_STENCIL:
      return V3D_LDST_BUF_CLASS_DEPTH_STENCIL;
   default:
      unreachable();
      return V3D_LDST_BUF_CLASS_INVALID;
   }
}

static inline uint32_t v3d_ldst_buf_rt(v3d_ldst_buf_t buf)
{
   assert(v3d_classify_ldst_buf(buf) == V3D_LDST_BUF_CLASS_COLOR);
   return buf - V3D_LDST_BUF_COLOR0;
}

static inline v3d_ldst_buf_t v3d_ldst_buf_color(uint32_t i)
{
   v3d_ldst_buf_t buf = (v3d_ldst_buf_t)(V3D_LDST_BUF_COLOR0 + i);
   assert(v3d_classify_ldst_buf(buf) == V3D_LDST_BUF_CLASS_COLOR);
   return buf;
}

static inline bool v3d_ldst_do_depth(v3d_ldst_buf_t buf)
{
   switch (buf) {
   case V3D_LDST_BUF_DEPTH:
   case V3D_LDST_BUF_PACKED_DEPTH_STENCIL:
      return true;
   case V3D_LDST_BUF_STENCIL:
      return false;
   default:
      unreachable();
      return false;
   }
}

static inline bool v3d_ldst_do_stencil(v3d_ldst_buf_t buf)
{
   switch (buf) {
   case V3D_LDST_BUF_DEPTH:
      return false;
   case V3D_LDST_BUF_STENCIL:
   case V3D_LDST_BUF_PACKED_DEPTH_STENCIL:
      return true;
   default:
      unreachable();
      return false;
   }
}

static inline v3d_ldst_buf_t v3d_ldst_buf_depth_stencil(
   bool do_depth, bool do_stencil)
{
   if (do_depth)
      return do_stencil ? V3D_LDST_BUF_PACKED_DEPTH_STENCIL : V3D_LDST_BUF_DEPTH;
   assert(do_stencil);
   return V3D_LDST_BUF_STENCIL;
}

static inline v3d_memory_format_t v3d_memory_format_from_ldst(
   v3d_ldst_memory_format_t ldst_memory_format)
{
   switch (ldst_memory_format) {
   case V3D_LDST_MEMORY_FORMAT_UIF_NO_XOR:   return V3D_MEMORY_FORMAT_UIF_NO_XOR;
   case V3D_LDST_MEMORY_FORMAT_UIF_XOR:      return V3D_MEMORY_FORMAT_UIF_XOR;
   default:                                  unreachable(); return V3D_MEMORY_FORMAT_INVALID;
   }
}

static inline v3d_ldst_memory_format_t v3d_memory_format_to_ldst(
   v3d_memory_format_t memory_format)
{
   switch (memory_format) {
   case V3D_MEMORY_FORMAT_UIF_NO_XOR:  return V3D_LDST_MEMORY_FORMAT_UIF_NO_XOR;
   case V3D_MEMORY_FORMAT_UIF_XOR:     return V3D_LDST_MEMORY_FORMAT_UIF_XOR;
   default:                            unreachable(); return V3D_LDST_MEMORY_FORMAT_INVALID;
   }
}

static inline uint32_t v3d_index_type_bytes(v3d_index_type_t index_type)
{
   switch (index_type)
   {
   case V3D_INDEX_TYPE_8BIT:  return 1;
   case V3D_INDEX_TYPE_16BIT: return 2;
   case V3D_INDEX_TYPE_32BIT: return 4;
   default:                   unreachable(); return 0;
   }
}

static inline bool v3d_depth_format_has_stencil(v3d_depth_format_t depth_format)
{
   switch (depth_format)
   {
   case V3D_DEPTH_FORMAT_32F:
   case V3D_DEPTH_FORMAT_24:
   case V3D_DEPTH_FORMAT_16:
      return false;
   case V3D_DEPTH_FORMAT_24_STENCIL8:
      return true;
   default:
      unreachable();
      return false;
   }
}

typedef union
{
   v3d_pixel_format_t pixel; /* V3D_LDST_BUF_CLASS_COLOR */
   v3d_depth_format_t depth; /* V3D_LDST_BUF_CLASS_DEPTH_STENCIL */
} v3d_output_format_t;

extern const char *v3d_desc_output_format(
   v3d_ldst_buf_t buf, v3d_output_format_t output_format);

struct v3d_ldst_params
{
   v3d_addr_t addr;
   v3d_memory_format_t memory_format;
   v3d_output_format_t output_format;
   v3d_decimate_t decimate;
   v3d_dither_t dither; /* Only used for stores */
   uint32_t uif_height_in_ub; /* Valid iff memory_format is UIF */
   uint32_t raster_padded_width_dec; /* Valid iff memory_format is raster */
   bool flipy;
};

#define V3D_DECIMATE_MAX_X_SCALE 2
#define V3D_DECIMATE_MAX_Y_SCALE 2

static inline v3d_prim_mode_t v3d_prim_mode_remove_tf(bool *tf, v3d_prim_mode_t mode)
{
   switch (mode)
   {
   case V3D_PRIM_MODE_POINTS_TF:       *tf = true; return V3D_PRIM_MODE_POINTS;
   case V3D_PRIM_MODE_LINES_TF:        *tf = true; return V3D_PRIM_MODE_LINES;
   case V3D_PRIM_MODE_LINE_LOOP_TF:    *tf = true; return V3D_PRIM_MODE_LINE_LOOP;
   case V3D_PRIM_MODE_LINE_STRIP_TF:   *tf = true; return V3D_PRIM_MODE_LINE_STRIP;
   case V3D_PRIM_MODE_TRIS_TF:         *tf = true; return V3D_PRIM_MODE_TRIS;
   case V3D_PRIM_MODE_TRI_STRIP_TF:    *tf = true; return V3D_PRIM_MODE_TRI_STRIP;
   case V3D_PRIM_MODE_TRI_FAN_TF:      *tf = true; return V3D_PRIM_MODE_TRI_FAN;
   default:                            *tf = false; return mode;
   }
}

static inline bool v3d_cl_store_instr_eof(const V3D_CL_INSTR_T *i)
{
   switch (i->opcode)
   {
   case V3D_CL_STORE_SUBSAMPLE:     return false;
   case V3D_CL_STORE_SUBSAMPLE_EX:  return i->u.store_subsample_ex.eof;
   case V3D_CL_STORE_GENERAL:       return i->u.store_general.eof;
   default:                         unreachable(); return false;
   }
}

#define V3D_CL_VARY_FLAGS_PER_INSTR 24

struct v3d_cl_source_part
{
   v3d_addr_t addr;
   size_t size;
};

struct v3d_cl_source
{
   /* In an autochained control list, a single instruction/primitive may be
    * split into two discontiguous parts. parts[0].size should not be 0 if
    * parts[1].size is not 0. If parts[1].size is 0, then parts[1].addr should
    * point to the end of the first part. */
   struct v3d_cl_source_part parts[2];
};

static inline size_t v3d_cl_source_size(const struct v3d_cl_source *source)
{
   return source->parts[0].size + source->parts[1].size;
}

static inline v3d_addr_t v3d_cl_source_part_end(const struct v3d_cl_source_part *part)
{
   return v3d_addr_offset(part->addr, part->size);
}

static inline v3d_addr_t v3d_cl_source_end(const struct v3d_cl_source *source)
{
   return v3d_cl_source_part_end(&source->parts[1]);
}

static inline bool v3d_cl_source_part_equal(
   const struct v3d_cl_source_part *a, const struct v3d_cl_source_part *b)
{
   return (a->size == b->size) && ((a->size == 0) || (a->addr == b->addr));
}

static inline void v3d_cl_source_single_part(struct v3d_cl_source *source,
   v3d_addr_t addr, size_t size)
{
   source->parts[0].addr = addr;
   source->parts[0].size = size;
   source->parts[1].addr = v3d_cl_source_part_end(&source->parts[0]);
   source->parts[1].size = 0;
}

extern void v3d_cl_truncate_source(struct v3d_cl_source *source, size_t size);
extern void v3d_cl_extend_source(struct v3d_cl_source *source, v3d_addr_t addr, size_t size);
extern void v3d_cl_cat_sources(struct v3d_cl_source *a, const struct v3d_cl_source *b);

extern void v3d_cl_log_cat_bytes(
   struct log_cat *cat, log_level_t level, const char *line_prefix,
   const char *desc, const uint8_t *bytes, const struct v3d_cl_source *source);
extern void v3d_cl_log_cat_instr(
   struct log_cat *cat, log_level_t level, const char *line_prefix,
   const uint8_t *packed_instr, const struct v3d_cl_source *source);

#define v3d_cl_log_trace_instr(LINE_PREFIX, PACKED_INSTR, SOURCE) \
   v3d_cl_log_cat_instr(&log_default_cat, LOG_TRACE, LINE_PREFIX, PACKED_INSTR, SOURCE)

static inline bool v3d_cl_plist_fmts_equal(
   const V3D_CL_PRIM_LIST_FORMAT_T *a, const V3D_CL_PRIM_LIST_FORMAT_T *b)
{
   return (a->n_verts == b->n_verts) && (a->xy == b->xy) && (a->d3dpvsf == b->d3dpvsf);
}

extern size_t v3d_cl_sprint_plist_fmt(char *buf, size_t buf_size, size_t offset,
   const V3D_CL_PRIM_LIST_FORMAT_T *plist_fmt);
#define V3D_CL_SPRINT_PLIST_FMT(BUF_NAME, PLIST_FMT) \
   VCOS_SAFE_STRFUNC_TO_LOCAL_BUF(BUF_NAME, 256, v3d_cl_sprint_plist_fmt, PLIST_FMT)

#if V3D_HAS_TNG
static inline uint32_t v3d_cl_vpm_pack_to_width(v3d_cl_vpm_pack_t pack)
{
   switch(pack)
   {
      case V3D_CL_VPM_PACK_X16: return 16;
      case V3D_CL_VPM_PACK_X8: return 8;
      case V3D_CL_VPM_PACK_X4: return 4;
      default: unreachable();
   }
}

static inline uint32_t v3d_cl_geom_pack_to_width(v3d_cl_geom_output_pack_t pack)
{
   switch(pack)
   {
      case V3D_CL_GEOM_OUTPUT_PACK_X16: return 16;
      case V3D_CL_GEOM_OUTPUT_PACK_X8: return 8;
      case V3D_CL_GEOM_OUTPUT_PACK_X4: return 4;
      case V3D_CL_GEOM_OUTPUT_PACK_X1: return 1;
      default: unreachable();
   }
}
#endif

VCOS_EXTERN_C_END

#endif
