/*=============================================================================
Copyright (c) 2014 Broadcom Europe Limited.
All rights reserved.
*** Do not edit this file. It is automatically generated by tools/v3d/codegen/codegen.py ***
=============================================================================*/
#ifndef V3D_GEN_H
#define V3D_GEN_H
#include "helpers/gfx/gfx_util.h"
#include "helpers/v3d/v3d_addr.h"
#include "helpers/v3d/v3d_cl_rw.h"
#include "helpers/v3d/v3d_printer.h"
#include "helpers/v3d/v3d_ver.h"

#define EXPORT_FOR_CLIF_CC

VCOS_EXTERN_C_BEGIN
typedef enum
{
   V3D_THREADING_T1      = 0,
   V3D_THREADING_T2      = 1,
   V3D_THREADING_T4      = 2,
   V3D_THREADING_INVALID = 4
} v3d_threading_t;
static inline bool v3d_is_valid_threading(v3d_threading_t threading)
{
   return (uint32_t)threading <= 2;
}
extern const char *v3d_desc_threading(v3d_threading_t threading);
typedef enum
{
   V3D_ATTR_TYPE_DISABLED      = 0,
   V3D_ATTR_TYPE_HALF_FLOAT    = 1,
   V3D_ATTR_TYPE_FLOAT         = 2,
   V3D_ATTR_TYPE_FIXED         = 3,
   V3D_ATTR_TYPE_BYTE          = 4,
   V3D_ATTR_TYPE_SHORT         = 5,
   V3D_ATTR_TYPE_INT           = 6,
   V3D_ATTR_TYPE_INT2_10_10_10 = 7,
   V3D_ATTR_TYPE_INVALID       = 8
} v3d_attr_type_t;
static inline bool v3d_is_valid_attr_type(v3d_attr_type_t attr_type)
{
   return (uint32_t)attr_type <= 7;
}
extern const char *v3d_desc_attr_type(v3d_attr_type_t attr_type);
typedef enum
{
   V3D_TMU_TYPE_YCBCR_LUMA                      = 39,
   V3D_TMU_TYPE_YCBCR_420_CHROMA                = 40,
   V3D_TMU_TYPE_R8I                             = 96,
   V3D_TMU_TYPE_R8UI                            = 97,
   V3D_TMU_TYPE_RG8I                            = 98,
   V3D_TMU_TYPE_RG8UI                           = 99,
   V3D_TMU_TYPE_RGBA8I                          = 100,
   V3D_TMU_TYPE_RGBA8UI                         = 101,
   V3D_TMU_TYPE_R16I                            = 102,
   V3D_TMU_TYPE_R16UI                           = 103,
   V3D_TMU_TYPE_RG16I                           = 104,
   V3D_TMU_TYPE_RG16UI                          = 105,
   V3D_TMU_TYPE_RGBA16I                         = 106,
   V3D_TMU_TYPE_RGBA16UI                        = 107,
   V3D_TMU_TYPE_R32I                            = 108,
   V3D_TMU_TYPE_R32UI                           = 109,
   V3D_TMU_TYPE_RG32I                           = 110,
   V3D_TMU_TYPE_RG32UI                          = 111,
   V3D_TMU_TYPE_RGBA32I                         = 112,
   V3D_TMU_TYPE_RGBA32UI                        = 113,
   V3D_TMU_TYPE_RGB10_A2UI                      = 114,
   V3D_TMU_TYPE_R8                              = 0,
   V3D_TMU_TYPE_R8_SNORM                        = 1,
   V3D_TMU_TYPE_RG8                             = 2,
   V3D_TMU_TYPE_RG8_SNORM                       = 3,
   V3D_TMU_TYPE_RGBA8                           = 4,
   V3D_TMU_TYPE_RGBA8_SNORM                     = 5,
   V3D_TMU_TYPE_RGB565                          = 6,
   V3D_TMU_TYPE_RGBA4                           = 7,
   V3D_TMU_TYPE_RGB5_A1                         = 8,
   V3D_TMU_TYPE_RGB10_A2                        = 9,
   V3D_TMU_TYPE_R16                             = 10,
   V3D_TMU_TYPE_R16_SNORM                       = 11,
   V3D_TMU_TYPE_RG16                            = 12,
   V3D_TMU_TYPE_RG16_SNORM                      = 13,
   V3D_TMU_TYPE_RGBA16                          = 14,
   V3D_TMU_TYPE_RGBA16_SNORM                    = 15,
   V3D_TMU_TYPE_R16F                            = 16,
   V3D_TMU_TYPE_RG16F                           = 17,
   V3D_TMU_TYPE_RGBA16F                         = 18,
   V3D_TMU_TYPE_R11F_G11F_B10F                  = 19,
   V3D_TMU_TYPE_RGB9_E5                         = 20,
   V3D_TMU_TYPE_DEPTH_COMP16                    = 21,
   V3D_TMU_TYPE_DEPTH_COMP24                    = 22,
   V3D_TMU_TYPE_DEPTH_COMP32F                   = 23,
   V3D_TMU_TYPE_DEPTH24_X8                      = 24,
   V3D_TMU_TYPE_R4                              = 25,
   V3D_TMU_TYPE_R1                              = 26,
   V3D_TMU_TYPE_S8                              = 27,
   V3D_TMU_TYPE_S16                             = 28,
   V3D_TMU_TYPE_R32F                            = 29,
   V3D_TMU_TYPE_RG32F                           = 30,
   V3D_TMU_TYPE_RGBA32F                         = 31,
   V3D_TMU_TYPE_C_RGB8_ETC2                     = 32,
   V3D_TMU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 33,
   V3D_TMU_TYPE_C_R11_EAC                       = 34,
   V3D_TMU_TYPE_C_SIGNED_R11_EAC                = 35,
   V3D_TMU_TYPE_C_RG11_EAC                      = 36,
   V3D_TMU_TYPE_C_SIGNED_RG11_EAC               = 37,
   V3D_TMU_TYPE_C_RGBA8_ETC2_EAC                = 38,
   V3D_TMU_TYPE_C_BC1                           = 48,
   V3D_TMU_TYPE_C_BC2                           = 49,
   V3D_TMU_TYPE_C_BC3                           = 50,
   V3D_TMU_TYPE_C_ASTC_4X4                      = 64,
   V3D_TMU_TYPE_C_ASTC_5X4                      = 65,
   V3D_TMU_TYPE_C_ASTC_5X5                      = 66,
   V3D_TMU_TYPE_C_ASTC_6X5                      = 67,
   V3D_TMU_TYPE_C_ASTC_6X6                      = 68,
   V3D_TMU_TYPE_C_ASTC_8X5                      = 69,
   V3D_TMU_TYPE_C_ASTC_8X6                      = 70,
   V3D_TMU_TYPE_C_ASTC_8X8                      = 71,
   V3D_TMU_TYPE_C_ASTC_10X5                     = 72,
   V3D_TMU_TYPE_C_ASTC_10X6                     = 73,
   V3D_TMU_TYPE_C_ASTC_10X8                     = 74,
   V3D_TMU_TYPE_C_ASTC_10X10                    = 75,
   V3D_TMU_TYPE_C_ASTC_12X10                    = 76,
   V3D_TMU_TYPE_C_ASTC_12X12                    = 77,
   V3D_TMU_TYPE_INVALID                         = 128
} v3d_tmu_type_t;
extern bool v3d_is_valid_tmu_type(v3d_tmu_type_t tmu_type);
extern const char *v3d_desc_tmu_type(v3d_tmu_type_t tmu_type);
typedef enum
{
   V3D_TFU_TYPE_YUV_420_2PLANE_REC709           = 39,
   V3D_TFU_TYPE_YUV_420_2PLANE_REC601           = 40,
   V3D_TFU_TYPE_YUV_420_2PLANE_JPEG             = 41,
   V3D_TFU_TYPE_YUV_422_2PLANE_REC709           = 42,
   V3D_TFU_TYPE_YUV_422_2PLANE_REC601           = 43,
   V3D_TFU_TYPE_YUV_422_2PLANE_JPEG             = 44,
   V3D_TFU_TYPE_YUYV_422_1PLANE_REC709          = 45,
   V3D_TFU_TYPE_YUYV_422_1PLANE_REC601          = 46,
   V3D_TFU_TYPE_YUYV_422_1PLANE_JPEG            = 47,
   V3D_TFU_TYPE_YUV_420_3PLANE_REC601           = 90,
   V3D_TFU_TYPE_YUV_420_3PLANE_REC709           = 91,
   V3D_TFU_TYPE_YUV_420_3PLANE_JPEG             = 92,
   V3D_TFU_TYPE_R8                              = 0,
   V3D_TFU_TYPE_R8_SNORM                        = 1,
   V3D_TFU_TYPE_RG8                             = 2,
   V3D_TFU_TYPE_RG8_SNORM                       = 3,
   V3D_TFU_TYPE_RGBA8                           = 4,
   V3D_TFU_TYPE_RGBA8_SNORM                     = 5,
   V3D_TFU_TYPE_RGB565                          = 6,
   V3D_TFU_TYPE_RGBA4                           = 7,
   V3D_TFU_TYPE_RGB5_A1                         = 8,
   V3D_TFU_TYPE_RGB10_A2                        = 9,
   V3D_TFU_TYPE_R16                             = 10,
   V3D_TFU_TYPE_R16_SNORM                       = 11,
   V3D_TFU_TYPE_RG16                            = 12,
   V3D_TFU_TYPE_RG16_SNORM                      = 13,
   V3D_TFU_TYPE_RGBA16                          = 14,
   V3D_TFU_TYPE_RGBA16_SNORM                    = 15,
   V3D_TFU_TYPE_R16F                            = 16,
   V3D_TFU_TYPE_RG16F                           = 17,
   V3D_TFU_TYPE_RGBA16F                         = 18,
   V3D_TFU_TYPE_R11F_G11F_B10F                  = 19,
   V3D_TFU_TYPE_RGB9_E5                         = 20,
   V3D_TFU_TYPE_DEPTH_COMP16                    = 21,
   V3D_TFU_TYPE_DEPTH_COMP24                    = 22,
   V3D_TFU_TYPE_DEPTH_COMP32F                   = 23,
   V3D_TFU_TYPE_DEPTH24_X8                      = 24,
   V3D_TFU_TYPE_R4                              = 25,
   V3D_TFU_TYPE_R1                              = 26,
   V3D_TFU_TYPE_S8                              = 27,
   V3D_TFU_TYPE_S16                             = 28,
   V3D_TFU_TYPE_R32F                            = 29,
   V3D_TFU_TYPE_RG32F                           = 30,
   V3D_TFU_TYPE_RGBA32F                         = 31,
   V3D_TFU_TYPE_C_RGB8_ETC2                     = 32,
   V3D_TFU_TYPE_C_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 33,
   V3D_TFU_TYPE_C_R11_EAC                       = 34,
   V3D_TFU_TYPE_C_SIGNED_R11_EAC                = 35,
   V3D_TFU_TYPE_C_RG11_EAC                      = 36,
   V3D_TFU_TYPE_C_SIGNED_RG11_EAC               = 37,
   V3D_TFU_TYPE_C_RGBA8_ETC2_EAC                = 38,
   V3D_TFU_TYPE_C_BC1                           = 48,
   V3D_TFU_TYPE_C_BC2                           = 49,
   V3D_TFU_TYPE_C_BC3                           = 50,
   V3D_TFU_TYPE_C_ASTC_4X4                      = 64,
   V3D_TFU_TYPE_C_ASTC_5X4                      = 65,
   V3D_TFU_TYPE_C_ASTC_5X5                      = 66,
   V3D_TFU_TYPE_C_ASTC_6X5                      = 67,
   V3D_TFU_TYPE_C_ASTC_6X6                      = 68,
   V3D_TFU_TYPE_C_ASTC_8X5                      = 69,
   V3D_TFU_TYPE_C_ASTC_8X6                      = 70,
   V3D_TFU_TYPE_C_ASTC_8X8                      = 71,
   V3D_TFU_TYPE_C_ASTC_10X5                     = 72,
   V3D_TFU_TYPE_C_ASTC_10X6                     = 73,
   V3D_TFU_TYPE_C_ASTC_10X8                     = 74,
   V3D_TFU_TYPE_C_ASTC_10X10                    = 75,
   V3D_TFU_TYPE_C_ASTC_12X10                    = 76,
   V3D_TFU_TYPE_C_ASTC_12X12                    = 77,
   V3D_TFU_TYPE_INVALID                         = 128
} v3d_tfu_type_t;
extern bool v3d_is_valid_tfu_type(v3d_tfu_type_t tfu_type);
extern const char *v3d_desc_tfu_type(v3d_tfu_type_t tfu_type);
typedef enum
{
   V3D_TMU_WRAP_REPEAT      = 0,
   V3D_TMU_WRAP_CLAMP       = 1,
   V3D_TMU_WRAP_MIRROR      = 2,
   V3D_TMU_WRAP_BORDER      = 3,
   V3D_TMU_WRAP_MIRROR_ONCE = 4,
   V3D_TMU_WRAP_INVALID     = 8
} v3d_tmu_wrap_t;
static inline bool v3d_is_valid_tmu_wrap(v3d_tmu_wrap_t tmu_wrap)
{
   return (uint32_t)tmu_wrap <= 4;
}
extern const char *v3d_desc_tmu_wrap(v3d_tmu_wrap_t tmu_wrap);
#if !V3D_HAS_NEW_TMU_CFG
typedef enum
{
   V3D_TMU_WRAP_CFG0_REPEAT  = 0,
   V3D_TMU_WRAP_CFG0_CLAMP   = 1,
   V3D_TMU_WRAP_CFG0_MIRROR  = 2,
   V3D_TMU_WRAP_CFG0_1D      = 3,
   V3D_TMU_WRAP_CFG0_INVALID = 4
} v3d_tmu_wrap_cfg0_t;
#endif
#if !V3D_HAS_NEW_TMU_CFG
static inline bool v3d_is_valid_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0)
{
   return (uint32_t)tmu_wrap_cfg0 <= 3;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
extern const char *v3d_desc_tmu_wrap_cfg0(v3d_tmu_wrap_cfg0_t tmu_wrap_cfg0);
#endif
typedef enum
{
   V3D_TMU_FILTER_MIN_LIN_MAG_LIN            = 0,
   V3D_TMU_FILTER_MIN_LIN_MAG_NEAR           = 1,
   V3D_TMU_FILTER_MIN_NEAR_MAG_LIN           = 2,
   V3D_TMU_FILTER_MIN_NEAR_MAG_NEAR          = 3,
   V3D_TMU_FILTER_MIN_NEAR_MIP_NEAR_MAG_LIN  = 4,
   V3D_TMU_FILTER_MIN_NEAR_MIP_NEAR_MAG_NEAR = 5,
   V3D_TMU_FILTER_MIN_NEAR_MIP_LIN_MAG_LIN   = 6,
   V3D_TMU_FILTER_MIN_NEAR_MIP_LIN_MAG_NEAR  = 7,
   V3D_TMU_FILTER_MIN_LIN_MIP_NEAR_MAG_LIN   = 8,
   V3D_TMU_FILTER_MIN_LIN_MIP_NEAR_MAG_NEAR  = 9,
   V3D_TMU_FILTER_MIN_LIN_MIP_LIN_MAG_LIN    = 10,
   V3D_TMU_FILTER_MIN_LIN_MIP_LIN_MAG_NEAR   = 11,
   V3D_TMU_FILTER_ANISOTROPIC2               = 12,
   V3D_TMU_FILTER_ANISOTROPIC4               = 13,
   V3D_TMU_FILTER_ANISOTROPIC8               = 14,
   V3D_TMU_FILTER_ANISOTROPIC16              = 15,
   V3D_TMU_FILTER_INVALID                    = 16
} v3d_tmu_filter_t;
static inline bool v3d_is_valid_tmu_filter(v3d_tmu_filter_t tmu_filter)
{
   return (uint32_t)tmu_filter <= 15;
}
extern const char *v3d_desc_tmu_filter(v3d_tmu_filter_t tmu_filter);
typedef enum
{
   V3D_TMU_LTYPE_2D          = 0,
   V3D_TMU_LTYPE_2D_ARRAY    = 1,
   V3D_TMU_LTYPE_3D          = 2,
   V3D_TMU_LTYPE_CUBE_MAP    = 3,
   V3D_TMU_LTYPE_1D          = 4,
   V3D_TMU_LTYPE_1D_ARRAY    = 5,
   V3D_TMU_LTYPE_CHILD_IMAGE = 6,
   V3D_TMU_LTYPE_INVALID     = 8
} v3d_tmu_ltype_t;
static inline bool v3d_is_valid_tmu_ltype(v3d_tmu_ltype_t tmu_ltype)
{
   return (uint32_t)tmu_ltype <= 6;
}
extern const char *v3d_desc_tmu_ltype(v3d_tmu_ltype_t tmu_ltype);
typedef enum
{
   V3D_TMU_SWIZZLE_0       = 0,
   V3D_TMU_SWIZZLE_1       = 1,
   V3D_TMU_SWIZZLE_R       = 2,
   V3D_TMU_SWIZZLE_G       = 3,
   V3D_TMU_SWIZZLE_B       = 4,
   V3D_TMU_SWIZZLE_A       = 5,
   V3D_TMU_SWIZZLE_INVALID = 8
} v3d_tmu_swizzle_t;
static inline bool v3d_is_valid_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle)
{
   return (uint32_t)tmu_swizzle <= 5;
}
extern const char *v3d_desc_tmu_swizzle(v3d_tmu_swizzle_t tmu_swizzle);
#if !V3D_HAS_NEW_TMU_CFG
typedef enum
{
   V3D_TMU_OUTPUT_TYPE_16      = 0,
   V3D_TMU_OUTPUT_TYPE_32      = 1,
   V3D_TMU_OUTPUT_TYPE_AUTO    = 2,
   V3D_TMU_OUTPUT_TYPE_INVALID = 4
} v3d_tmu_output_type_t;
#endif
#if !V3D_HAS_NEW_TMU_CFG
static inline bool v3d_is_valid_tmu_output_type(v3d_tmu_output_type_t tmu_output_type)
{
   return (uint32_t)tmu_output_type <= 2;
}
#endif
#if !V3D_HAS_NEW_TMU_CFG
extern const char *v3d_desc_tmu_output_type(v3d_tmu_output_type_t tmu_output_type);
#endif
typedef enum
{
   V3D_TMU_DIRECT_TYPE_S8      = 0,
   V3D_TMU_DIRECT_TYPE_S16     = 1,
   V3D_TMU_DIRECT_TYPE_VEC2    = 2,
   V3D_TMU_DIRECT_TYPE_VEC3    = 3,
   V3D_TMU_DIRECT_TYPE_VEC4    = 4,
   V3D_TMU_DIRECT_TYPE_8       = 5,
   V3D_TMU_DIRECT_TYPE_16      = 6,
   V3D_TMU_DIRECT_TYPE_32      = 7,
   V3D_TMU_DIRECT_TYPE_INVALID = 8
} v3d_tmu_direct_type_t;
static inline bool v3d_is_valid_tmu_direct_type(v3d_tmu_direct_type_t tmu_direct_type)
{
   return (uint32_t)tmu_direct_type <= 7;
}
extern const char *v3d_desc_tmu_direct_type(v3d_tmu_direct_type_t tmu_direct_type);
typedef enum
{
   V3D_TMU_DIRECT_OP_WR_ADD_RD_PREFETCH       = 0,
   V3D_TMU_DIRECT_OP_WR_SUB_RD_CLEAR          = 1,
   V3D_TMU_DIRECT_OP_WR_XCHG_RD_FLUSH         = 2,
   V3D_TMU_DIRECT_OP_WR_CMPXCHG_RD_CLEAN      = 3,
   V3D_TMU_DIRECT_OP_WR_UMIN_RD_FULL_L1_CLEAR = 4,
   V3D_TMU_DIRECT_OP_WR_UMAX                  = 5,
   V3D_TMU_DIRECT_OP_WR_SMIN                  = 6,
   V3D_TMU_DIRECT_OP_WR_SMAX                  = 7,
   V3D_TMU_DIRECT_OP_WR_AND_RD_INC            = 8,
   V3D_TMU_DIRECT_OP_WR_OR_RD_DEC             = 9,
   V3D_TMU_DIRECT_OP_WR_XOR_RD_NOT            = 10,
   V3D_TMU_DIRECT_OP_REGULAR                  = 15,
   V3D_TMU_DIRECT_OP_INVALID                  = 16
} v3d_tmu_direct_op_t;
extern bool v3d_is_valid_tmu_direct_op(v3d_tmu_direct_op_t tmu_direct_op);
extern const char *v3d_desc_tmu_direct_op(v3d_tmu_direct_op_t tmu_direct_op);
#if V3D_HAS_NEW_TMU_CFG
typedef enum
{
   V3D_TMU_STD_BCOL_0000    = 0,
   V3D_TMU_STD_BCOL_0001    = 1,
   V3D_TMU_STD_BCOL_1111    = 2,
   V3D_TMU_STD_BCOL_NON_STD = 7,
   V3D_TMU_STD_BCOL_INVALID = 8
} v3d_tmu_std_bcol_t;
#endif
#if V3D_HAS_NEW_TMU_CFG
extern bool v3d_is_valid_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern const char *v3d_desc_tmu_std_bcol(v3d_tmu_std_bcol_t tmu_std_bcol);
#endif
typedef enum
{
   V3D_QPU_OP_NOP        = 0,
   V3D_QPU_OP_TIDX       = 1,
   V3D_QPU_OP_EIDX       = 2,
   V3D_QPU_OP_LR         = 3,
   V3D_QPU_OP_VFLA       = 4,
   V3D_QPU_OP_VFLNA      = 5,
   V3D_QPU_OP_VFLB       = 6,
   V3D_QPU_OP_VFLNB      = 7,
   V3D_QPU_OP_FXCD       = 8,
   V3D_QPU_OP_XCD        = 9,
   V3D_QPU_OP_FYCD       = 10,
   V3D_QPU_OP_YCD        = 11,
   V3D_QPU_OP_MSF        = 12,
   V3D_QPU_OP_REVF       = 13,
   V3D_QPU_OP_TMUWT      = 14,
   V3D_QPU_OP_IID        = 15,
   V3D_QPU_OP_NOT        = 256,
   V3D_QPU_OP_NEG        = 257,
   V3D_QPU_OP_FLAPUSH    = 258,
   V3D_QPU_OP_FLBPUSH    = 259,
   V3D_QPU_OP_FLPOP      = 260,
   V3D_QPU_OP_SETMSF     = 261,
   V3D_QPU_OP_SETREVF    = 262,
   V3D_QPU_OP_VPMSETUP   = 263,
   V3D_QPU_OP_FROUND     = 264,
   V3D_QPU_OP_FTOIN      = 265,
   V3D_QPU_OP_FTRUNC     = 266,
   V3D_QPU_OP_FTOIZ      = 267,
   V3D_QPU_OP_FFLOOR     = 268,
   V3D_QPU_OP_FTOUZ      = 269,
   V3D_QPU_OP_FCEIL      = 270,
   V3D_QPU_OP_FTOC       = 271,
   V3D_QPU_OP_FDX        = 272,
   V3D_QPU_OP_FDY        = 273,
   V3D_QPU_OP_ITOF       = 274,
   V3D_QPU_OP_CLZ        = 275,
   V3D_QPU_OP_UTOF       = 276,
   V3D_QPU_OP_FMOV       = 277,
   V3D_QPU_OP_MOV        = 278,
   V3D_QPU_OP_LDVPMV     = 279,
   V3D_QPU_OP_LDVPMD     = 280,
   V3D_QPU_OP_LDVPMP     = 281,
   V3D_QPU_OP_TMUWRCFG   = 282,
   V3D_QPU_OP_TLBWRCFG   = 283,
   V3D_QPU_OP_VPMWRCFG   = 284,
   V3D_QPU_OP_VFMOV      = 285,
   V3D_QPU_OP_VFMOVABS   = 286,
   V3D_QPU_OP_VFMOVNEG   = 287,
   V3D_QPU_OP_VFMOVNAB   = 288,
   V3D_QPU_OP_VFABSMOV   = 289,
   V3D_QPU_OP_VFABS      = 290,
   V3D_QPU_OP_VFABSNEG   = 291,
   V3D_QPU_OP_VFABSNAB   = 292,
   V3D_QPU_OP_VFNEGMOV   = 293,
   V3D_QPU_OP_VFNEGABS   = 294,
   V3D_QPU_OP_VFNEG      = 295,
   V3D_QPU_OP_VFNEGNAB   = 296,
   V3D_QPU_OP_VFNABMOV   = 297,
   V3D_QPU_OP_VFNABABS   = 298,
   V3D_QPU_OP_VFNABNEG   = 299,
   V3D_QPU_OP_VFNABS     = 300,
   V3D_QPU_OP_FADD       = 512,
   V3D_QPU_OP_FADDNF     = 513,
   V3D_QPU_OP_FSUB       = 514,
   V3D_QPU_OP_FMIN       = 515,
   V3D_QPU_OP_FMAX       = 516,
   V3D_QPU_OP_FCMP       = 517,
   V3D_QPU_OP_FMUL       = 518,
   V3D_QPU_OP_VFPACK     = 519,
   V3D_QPU_OP_VFMIN      = 520,
   V3D_QPU_OP_VFMAX      = 521,
   V3D_QPU_OP_VFMUL      = 522,
   V3D_QPU_OP_ADD        = 523,
   V3D_QPU_OP_SUB        = 524,
   V3D_QPU_OP_MIN        = 525,
   V3D_QPU_OP_MAX        = 526,
   V3D_QPU_OP_UMIN       = 527,
   V3D_QPU_OP_UMAX       = 528,
   V3D_QPU_OP_SMUL24     = 529,
   V3D_QPU_OP_UMUL24     = 530,
   V3D_QPU_OP_MULTOP     = 531,
   V3D_QPU_OP_VADD       = 532,
   V3D_QPU_OP_VSUB       = 533,
   V3D_QPU_OP_SHL        = 534,
   V3D_QPU_OP_SHR        = 535,
   V3D_QPU_OP_ASR        = 536,
   V3D_QPU_OP_ROR        = 537,
   V3D_QPU_OP_AND        = 538,
   V3D_QPU_OP_OR         = 539,
   V3D_QPU_OP_XOR        = 540,
   V3D_QPU_OP_STVPMV     = 541,
   V3D_QPU_OP_STVPMD     = 542,
   V3D_QPU_OP_STVPMP     = 543,
   V3D_QPU_OP_LDVPMG_IN  = 544,
   V3D_QPU_OP_LDVPMG_OUT = 545,
   V3D_QPU_OP_INVALID    = 1024
} v3d_qpu_opcode_t;
extern bool v3d_is_valid_qpu_opcode(v3d_qpu_opcode_t qpu_opcode);
extern const char *v3d_desc_qpu_opcode(v3d_qpu_opcode_t qpu_opcode);
typedef enum
{
   V3D_QPU_SETF_NONE    = 0,
   V3D_QPU_SETF_PUSHZ   = 1,
   V3D_QPU_SETF_PUSHN   = 2,
   V3D_QPU_SETF_PUSHC   = 3,
   V3D_QPU_SETF_ANDZ    = 4,
   V3D_QPU_SETF_ANDNZ   = 5,
   V3D_QPU_SETF_NORNZ   = 6,
   V3D_QPU_SETF_NORZ    = 7,
   V3D_QPU_SETF_ANDN    = 8,
   V3D_QPU_SETF_ANDNN   = 9,
   V3D_QPU_SETF_NORNN   = 10,
   V3D_QPU_SETF_NORN    = 11,
   V3D_QPU_SETF_ANDC    = 12,
   V3D_QPU_SETF_ANDNC   = 13,
   V3D_QPU_SETF_NORNC   = 14,
   V3D_QPU_SETF_NORC    = 15,
   V3D_QPU_SETF_INVALID = 16
} v3d_qpu_setf_t;
static inline bool v3d_is_valid_qpu_setf(v3d_qpu_setf_t qpu_setf)
{
   return (uint32_t)qpu_setf <= 15;
}
extern const char *v3d_desc_qpu_setf(v3d_qpu_setf_t qpu_setf);
typedef enum
{
   V3D_QPU_COND_IFA     = 0,
   V3D_QPU_COND_IFB     = 1,
   V3D_QPU_COND_IFNA    = 2,
   V3D_QPU_COND_IFNB    = 3,
   V3D_QPU_COND_ALWAYS  = 4,
   V3D_QPU_COND_INVALID = 8
} v3d_qpu_cond_t;
static inline bool v3d_is_valid_qpu_cond(v3d_qpu_cond_t qpu_cond)
{
   return (uint32_t)qpu_cond <= 4;
}
extern const char *v3d_desc_qpu_cond(v3d_qpu_cond_t qpu_cond);
typedef enum
{
   V3D_QPU_UNPACK_32F_ABS              = 0,
   V3D_QPU_UNPACK_NONE                 = 1,
   V3D_QPU_UNPACK_16F_LOW_TO_32F       = 2,
   V3D_QPU_UNPACK_16F_HIGH_TO_32F      = 3,
   V3D_QPU_UNPACK_32F_TO_16F_REPLICATE = 4,
   V3D_QPU_UNPACK_REPLICATE_LOW_16     = 5,
   V3D_QPU_UNPACK_REPLICATE_HIGH_16    = 6,
   V3D_QPU_UNPACK_SWAP_16              = 7,
   V3D_QPU_UNPACK_INVALID              = 8
} v3d_qpu_unpack_t;
static inline bool v3d_is_valid_qpu_unpack(v3d_qpu_unpack_t qpu_unpack)
{
   return (uint32_t)qpu_unpack <= 7;
}
extern const char *v3d_desc_qpu_unpack(v3d_qpu_unpack_t qpu_unpack);
typedef enum
{
   V3D_QPU_PACK_NONE            = 0,
   V3D_QPU_PACK_32F_TO_16F_LOW  = 1,
   V3D_QPU_PACK_32F_TO_16F_HIGH = 2,
   V3D_QPU_PACK_INVALID         = 4
} v3d_qpu_pack_t;
static inline bool v3d_is_valid_qpu_pack(v3d_qpu_pack_t qpu_pack)
{
   return (uint32_t)qpu_pack <= 2;
}
extern const char *v3d_desc_qpu_pack(v3d_qpu_pack_t qpu_pack);
typedef enum
{
   V3D_QPU_MAGIC_WADDR_R0        = 0,
   V3D_QPU_MAGIC_WADDR_R1        = 1,
   V3D_QPU_MAGIC_WADDR_R2        = 2,
   V3D_QPU_MAGIC_WADDR_R3        = 3,
   V3D_QPU_MAGIC_WADDR_R4        = 4,
   V3D_QPU_MAGIC_WADDR_R5QUAD    = 5,
   V3D_QPU_MAGIC_WADDR_NOP       = 6,
   V3D_QPU_MAGIC_WADDR_TLB       = 7,
   V3D_QPU_MAGIC_WADDR_TLBU      = 8,
#if !V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMU       = 9,
#endif
#if !V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUL      = 10,
#endif
   V3D_QPU_MAGIC_WADDR_TMUD      = 11,
   V3D_QPU_MAGIC_WADDR_TMUA      = 12,
   V3D_QPU_MAGIC_WADDR_TMUAU     = 13,
#if !V3D_HAS_LDVPM
   V3D_QPU_MAGIC_WADDR_VPM       = 14,
#endif
#if !V3D_HAS_LDVPM
   V3D_QPU_MAGIC_WADDR_VPMU      = 15,
#endif
   V3D_QPU_MAGIC_WADDR_SYNC      = 16,
   V3D_QPU_MAGIC_WADDR_SYNCU     = 17,
   V3D_QPU_MAGIC_WADDR_RECIP     = 19,
   V3D_QPU_MAGIC_WADDR_RSQRT     = 20,
   V3D_QPU_MAGIC_WADDR_EXP       = 21,
   V3D_QPU_MAGIC_WADDR_LOG       = 22,
   V3D_QPU_MAGIC_WADDR_SIN       = 23,
#if V3D_VER_AT_LEAST(3, 3)
   V3D_QPU_MAGIC_WADDR_RSQRT2    = 24,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUC      = 32,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUS      = 33,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUT      = 34,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUR      = 35,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUI      = 36,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUB      = 37,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUDREF   = 38,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUOFF    = 39,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUSCM    = 40,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUSFETCH = 41,
#endif
#if V3D_HAS_NEW_TMU_CFG
   V3D_QPU_MAGIC_WADDR_TMUSLOD   = 42,
#endif
   V3D_QPU_MAGIC_WADDR_INVALID   = 64
} v3d_qpu_magic_waddr_t;
extern bool v3d_is_valid_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr);
extern const char *v3d_desc_qpu_magic_waddr(v3d_qpu_magic_waddr_t qpu_magic_waddr);
typedef enum
{
   V3D_QPU_IN_SOURCE_R0      = 0,
   V3D_QPU_IN_SOURCE_R1      = 1,
   V3D_QPU_IN_SOURCE_R2      = 2,
   V3D_QPU_IN_SOURCE_R3      = 3,
   V3D_QPU_IN_SOURCE_R4      = 4,
   V3D_QPU_IN_SOURCE_R5      = 5,
   V3D_QPU_IN_SOURCE_A       = 6,
   V3D_QPU_IN_SOURCE_B       = 7,
   V3D_QPU_IN_SOURCE_INVALID = 8
} v3d_qpu_in_source_t;
static inline bool v3d_is_valid_qpu_in_source(v3d_qpu_in_source_t qpu_in_source)
{
   return (uint32_t)qpu_in_source <= 7;
}
extern const char *v3d_desc_qpu_in_source(v3d_qpu_in_source_t qpu_in_source);
typedef enum
{
   V3D_QPU_BCOND_ALWAYS  = 0,
   V3D_QPU_BCOND_A0      = 2,
   V3D_QPU_BCOND_NA0     = 3,
   V3D_QPU_BCOND_ALLA    = 4,
   V3D_QPU_BCOND_ANYNA   = 5,
   V3D_QPU_BCOND_ANYA    = 6,
   V3D_QPU_BCOND_ALLNA   = 7,
   V3D_QPU_BCOND_INVALID = 8
} v3d_qpu_bcond_t;
extern bool v3d_is_valid_qpu_bcond(v3d_qpu_bcond_t qpu_bcond);
extern const char *v3d_desc_qpu_bcond(v3d_qpu_bcond_t qpu_bcond);
typedef enum
{
   V3D_QPU_MSFIGN_NONE    = 0,
   V3D_QPU_MSFIGN_PIXEL   = 1,
   V3D_QPU_MSFIGN_QUAD    = 2,
   V3D_QPU_MSFIGN_INVALID = 4
} v3d_qpu_msfign_t;
static inline bool v3d_is_valid_qpu_msfign(v3d_qpu_msfign_t qpu_msfign)
{
   return (uint32_t)qpu_msfign <= 2;
}
extern const char *v3d_desc_qpu_msfign(v3d_qpu_msfign_t qpu_msfign);
typedef enum
{
   V3D_QPU_BDEST_ABS      = 0,
   V3D_QPU_BDEST_REL      = 1,
   V3D_QPU_BDEST_LINK_REG = 2,
   V3D_QPU_BDEST_REGFILE  = 3,
   V3D_QPU_BDEST_INVALID  = 4
} v3d_qpu_bdest_t;
static inline bool v3d_is_valid_qpu_bdest(v3d_qpu_bdest_t qpu_bdest)
{
   return (uint32_t)qpu_bdest <= 3;
}
extern const char *v3d_desc_qpu_bdest(v3d_qpu_bdest_t qpu_bdest);
typedef enum
{
   V3D_QPU_LDI_MODE_32          = 0,
   V3D_QPU_LDI_MODE_EL_UNSIGNED = 1,
   V3D_QPU_LDI_MODE_EL_SIGNED   = 2,
   V3D_QPU_LDI_MODE_INVALID     = 4
} v3d_qpu_ldi_mode_t;
static inline bool v3d_is_valid_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode)
{
   return (uint32_t)qpu_ldi_mode <= 2;
}
extern const char *v3d_desc_qpu_ldi_mode(v3d_qpu_ldi_mode_t qpu_ldi_mode);
typedef enum
{
   V3D_TSY_OP_SET_QUORUM          = 0,
   V3D_TSY_OP_INC_WAITERS         = 1,
   V3D_TSY_OP_DEC_WAITERS         = 2,
   V3D_TSY_OP_INC_QUORUM          = 3,
   V3D_TSY_OP_DEC_QUORUM          = 4,
   V3D_TSY_OP_FREE_ALL            = 5,
   V3D_TSY_OP_RELEASE             = 6,
   V3D_TSY_OP_ACQUIRE             = 7,
   V3D_TSY_OP_WAIT                = 8,
   V3D_TSY_OP_WAIT_INC            = 9,
   V3D_TSY_OP_WAIT_CHECK          = 10,
   V3D_TSY_OP_WAIT_INC_CHECK      = 11,
   V3D_TSY_OP_WAIT_CV             = 12,
   V3D_TSY_OP_INC_SEMAPHORE       = 13,
   V3D_TSY_OP_DEC_SEMAPHORE       = 14,
   V3D_TSY_OP_SET_QUORUM_FREE_ALL = 15,
   V3D_TSY_OP_IN_DATA             = 255,
   V3D_TSY_OP_INVALID             = 256
} v3d_tsy_op_t;
extern bool v3d_is_valid_tsy_op(v3d_tsy_op_t tsy_op);
extern const char *v3d_desc_tsy_op(v3d_tsy_op_t tsy_op);
typedef enum
{
   V3D_TLB_RW_TYPE_COLOR_F16  = 0,
   V3D_TLB_RW_TYPE_COLOR_32   = 1,
   V3D_TLB_RW_TYPE_Z          = 2,
   V3D_TLB_RW_TYPE_ALPHA_MASK = 3,
   V3D_TLB_RW_TYPE_INVALID    = 4
} v3d_tlb_rw_type_t;
static inline bool v3d_is_valid_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type)
{
   return (uint32_t)tlb_rw_type <= 3;
}
extern const char *v3d_desc_tlb_rw_type(v3d_tlb_rw_type_t tlb_rw_type);
typedef enum
{
   V3D_TLB_RW_COLOR_TYPE_FLOAT16         = 0,
   V3D_TLB_RW_COLOR_TYPE_FLOAT16_SWAPPED = 1,
   V3D_TLB_RW_COLOR_TYPE_FLOAT32         = 2,
   V3D_TLB_RW_COLOR_TYPE_INT32           = 3,
   V3D_TLB_RW_COLOR_TYPE_INVALID         = 4
} v3d_tlb_rw_color_type_t;
static inline bool v3d_is_valid_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type)
{
   return (uint32_t)tlb_rw_color_type <= 3;
}
extern const char *v3d_desc_tlb_rw_color_type(v3d_tlb_rw_color_type_t tlb_rw_color_type);
typedef enum
{
   V3D_COMPARE_FUNC_NEVER    = 0,
   V3D_COMPARE_FUNC_LESS     = 1,
   V3D_COMPARE_FUNC_EQUAL    = 2,
   V3D_COMPARE_FUNC_LEQUAL   = 3,
   V3D_COMPARE_FUNC_GREATER  = 4,
   V3D_COMPARE_FUNC_NOTEQUAL = 5,
   V3D_COMPARE_FUNC_GEQUAL   = 6,
   V3D_COMPARE_FUNC_ALWAYS   = 7,
   V3D_COMPARE_FUNC_INVALID  = 8
} v3d_compare_func_t;
static inline bool v3d_is_valid_compare_func(v3d_compare_func_t compare_func)
{
   return (uint32_t)compare_func <= 7;
}
extern const char *v3d_desc_compare_func(v3d_compare_func_t compare_func);
typedef enum
{
   V3D_TMU_MIN_FILT_LINEAR        = 0,
   V3D_TMU_MIN_FILT_NEAREST       = 1,
   V3D_TMU_MIN_FILT_NEAR_MIP_NEAR = 2,
   V3D_TMU_MIN_FILT_NEAR_MIP_LIN  = 3,
   V3D_TMU_MIN_FILT_LIN_MIP_NEAR  = 4,
   V3D_TMU_MIN_FILT_LIN_MIP_LIN   = 5,
   V3D_TMU_MIN_FILT_INVALID       = 8
} v3d_tmu_min_filt_t;
static inline bool v3d_is_valid_tmu_min_filt(v3d_tmu_min_filt_t tmu_min_filt)
{
   return (uint32_t)tmu_min_filt <= 5;
}
extern const char *v3d_desc_tmu_min_filt(v3d_tmu_min_filt_t tmu_min_filt);
typedef enum
{
   V3D_TMU_MAG_FILT_LINEAR  = 0,
   V3D_TMU_MAG_FILT_NEAREST = 1,
   V3D_TMU_MAG_FILT_INVALID = 2
} v3d_tmu_mag_filt_t;
static inline bool v3d_is_valid_tmu_mag_filt(v3d_tmu_mag_filt_t tmu_mag_filt)
{
   return (uint32_t)tmu_mag_filt <= 1;
}
extern const char *v3d_desc_tmu_mag_filt(v3d_tmu_mag_filt_t tmu_mag_filt);
typedef enum
{
   V3D_MS_1X      = 0,
   V3D_MS_4X      = 1,
   V3D_MS_16X     = 2,
   V3D_MS_INVALID = 4
} v3d_ms_t;
static inline bool v3d_is_valid_ms(v3d_ms_t ms)
{
   return (uint32_t)ms <= 2;
}
extern const char *v3d_desc_ms(v3d_ms_t ms);
typedef enum
{
   V3D_PRIM_MODE_POINTS         = 0,
   V3D_PRIM_MODE_LINES          = 1,
   V3D_PRIM_MODE_LINE_LOOP      = 2,
   V3D_PRIM_MODE_LINE_STRIP     = 3,
   V3D_PRIM_MODE_TRIS           = 4,
   V3D_PRIM_MODE_TRI_STRIP      = 5,
   V3D_PRIM_MODE_TRI_FAN        = 6,
   V3D_PRIM_MODE_LINES_ADJ      = 8,
   V3D_PRIM_MODE_LINE_STRIP_ADJ = 9,
   V3D_PRIM_MODE_TRIS_ADJ       = 10,
   V3D_PRIM_MODE_TRI_STRIP_ADJ  = 11,
   V3D_PRIM_MODE_POINTS_TF      = 16,
   V3D_PRIM_MODE_LINES_TF       = 17,
   V3D_PRIM_MODE_LINE_LOOP_TF   = 18,
   V3D_PRIM_MODE_LINE_STRIP_TF  = 19,
   V3D_PRIM_MODE_TRIS_TF        = 20,
   V3D_PRIM_MODE_TRI_STRIP_TF   = 21,
   V3D_PRIM_MODE_TRI_FAN_TF     = 22,
   V3D_PRIM_MODE_PATCH1         = 32,
   V3D_PRIM_MODE_PATCH2         = 33,
   V3D_PRIM_MODE_PATCH3         = 34,
   V3D_PRIM_MODE_PATCH4         = 35,
   V3D_PRIM_MODE_PATCH5         = 36,
   V3D_PRIM_MODE_PATCH6         = 37,
   V3D_PRIM_MODE_PATCH7         = 38,
   V3D_PRIM_MODE_PATCH8         = 39,
   V3D_PRIM_MODE_PATCH9         = 40,
   V3D_PRIM_MODE_PATCH10        = 41,
   V3D_PRIM_MODE_PATCH11        = 42,
   V3D_PRIM_MODE_PATCH12        = 43,
   V3D_PRIM_MODE_PATCH13        = 44,
   V3D_PRIM_MODE_PATCH14        = 45,
   V3D_PRIM_MODE_PATCH15        = 46,
   V3D_PRIM_MODE_PATCH16        = 47,
   V3D_PRIM_MODE_PATCH17        = 48,
   V3D_PRIM_MODE_PATCH18        = 49,
   V3D_PRIM_MODE_PATCH19        = 50,
   V3D_PRIM_MODE_PATCH20        = 51,
   V3D_PRIM_MODE_PATCH21        = 52,
   V3D_PRIM_MODE_PATCH22        = 53,
   V3D_PRIM_MODE_PATCH23        = 54,
   V3D_PRIM_MODE_PATCH24        = 55,
   V3D_PRIM_MODE_PATCH25        = 56,
   V3D_PRIM_MODE_PATCH26        = 57,
   V3D_PRIM_MODE_PATCH27        = 58,
   V3D_PRIM_MODE_PATCH28        = 59,
   V3D_PRIM_MODE_PATCH29        = 60,
   V3D_PRIM_MODE_PATCH30        = 61,
   V3D_PRIM_MODE_PATCH31        = 62,
   V3D_PRIM_MODE_PATCH32        = 63,
   V3D_PRIM_MODE_INVALID        = 64
} v3d_prim_mode_t;
extern bool v3d_is_valid_prim_mode(v3d_prim_mode_t prim_mode);
extern const char *v3d_desc_prim_mode(v3d_prim_mode_t prim_mode);
typedef enum
{
   V3D_PRIM_TYPE_POINT    = 0,
   V3D_PRIM_TYPE_LINE     = 1,
   V3D_PRIM_TYPE_TRI      = 2,
   V3D_PRIM_TYPE_LINE_ADJ = 3,
   V3D_PRIM_TYPE_TRI_ADJ  = 4,
   V3D_PRIM_TYPE_PATCH1   = 32,
   V3D_PRIM_TYPE_PATCH2   = 33,
   V3D_PRIM_TYPE_PATCH3   = 34,
   V3D_PRIM_TYPE_PATCH4   = 35,
   V3D_PRIM_TYPE_PATCH5   = 36,
   V3D_PRIM_TYPE_PATCH6   = 37,
   V3D_PRIM_TYPE_PATCH7   = 38,
   V3D_PRIM_TYPE_PATCH8   = 39,
   V3D_PRIM_TYPE_PATCH9   = 40,
   V3D_PRIM_TYPE_PATCH10  = 41,
   V3D_PRIM_TYPE_PATCH11  = 42,
   V3D_PRIM_TYPE_PATCH12  = 43,
   V3D_PRIM_TYPE_PATCH13  = 44,
   V3D_PRIM_TYPE_PATCH14  = 45,
   V3D_PRIM_TYPE_PATCH15  = 46,
   V3D_PRIM_TYPE_PATCH16  = 47,
   V3D_PRIM_TYPE_PATCH17  = 48,
   V3D_PRIM_TYPE_PATCH18  = 49,
   V3D_PRIM_TYPE_PATCH19  = 50,
   V3D_PRIM_TYPE_PATCH20  = 51,
   V3D_PRIM_TYPE_PATCH21  = 52,
   V3D_PRIM_TYPE_PATCH22  = 53,
   V3D_PRIM_TYPE_PATCH23  = 54,
   V3D_PRIM_TYPE_PATCH24  = 55,
   V3D_PRIM_TYPE_PATCH25  = 56,
   V3D_PRIM_TYPE_PATCH26  = 57,
   V3D_PRIM_TYPE_PATCH27  = 58,
   V3D_PRIM_TYPE_PATCH28  = 59,
   V3D_PRIM_TYPE_PATCH29  = 60,
   V3D_PRIM_TYPE_PATCH30  = 61,
   V3D_PRIM_TYPE_PATCH31  = 62,
   V3D_PRIM_TYPE_PATCH32  = 63,
   V3D_PRIM_TYPE_INVALID  = 64
} v3d_prim_type_t;
extern bool v3d_is_valid_prim_type(v3d_prim_type_t prim_type);
extern const char *v3d_desc_prim_type(v3d_prim_type_t prim_type);
typedef enum
{
   V3D_INDEX_TYPE_8BIT     = 0,
   V3D_INDEX_TYPE_16BIT    = 1,
   V3D_INDEX_TYPE_32BIT    = 2,
   V3D_INDEX_TYPE_32BIT_XY = 3,
   V3D_INDEX_TYPE_INVALID  = 4
} v3d_index_type_t;
static inline bool v3d_is_valid_index_type(v3d_index_type_t index_type)
{
   return (uint32_t)index_type <= 3;
}
extern const char *v3d_desc_index_type(v3d_index_type_t index_type);
typedef enum
{
   V3D_COV_UPDATE_NONZERO = 0,
   V3D_COV_UPDATE_ODD     = 1,
   V3D_COV_UPDATE_OR      = 2,
   V3D_COV_UPDATE_ZERO    = 3,
   V3D_COV_UPDATE_INVALID = 4
} v3d_cov_update_t;
static inline bool v3d_is_valid_cov_update(v3d_cov_update_t cov_update)
{
   return (uint32_t)cov_update <= 3;
}
extern const char *v3d_desc_cov_update(v3d_cov_update_t cov_update);
typedef enum
{
   V3D_WIREFRAME_MODE_LINES   = 0,
   V3D_WIREFRAME_MODE_POINTS  = 1,
   V3D_WIREFRAME_MODE_INVALID = 2
} v3d_wireframe_mode_t;
static inline bool v3d_is_valid_wireframe_mode(v3d_wireframe_mode_t wireframe_mode)
{
   return (uint32_t)wireframe_mode <= 1;
}
extern const char *v3d_desc_wireframe_mode(v3d_wireframe_mode_t wireframe_mode);
typedef enum
{
   V3D_BLEND_EQN_ADD     = 0,
   V3D_BLEND_EQN_SUB     = 1,
   V3D_BLEND_EQN_RSUB    = 2,
   V3D_BLEND_EQN_MIN     = 3,
   V3D_BLEND_EQN_MAX     = 4,
   V3D_BLEND_EQN_MUL     = 5,
   V3D_BLEND_EQN_SCREEN  = 6,
   V3D_BLEND_EQN_DARKEN  = 7,
   V3D_BLEND_EQN_LIGHTEN = 8,
   V3D_BLEND_EQN_INVALID = 16
} v3d_blend_eqn_t;
static inline bool v3d_is_valid_blend_eqn(v3d_blend_eqn_t blend_eqn)
{
   return (uint32_t)blend_eqn <= 8;
}
extern const char *v3d_desc_blend_eqn(v3d_blend_eqn_t blend_eqn);
typedef enum
{
   V3D_BLEND_MUL_ZERO           = 0,
   V3D_BLEND_MUL_ONE            = 1,
   V3D_BLEND_MUL_SRC            = 2,
   V3D_BLEND_MUL_OM_SRC         = 3,
   V3D_BLEND_MUL_DST            = 4,
   V3D_BLEND_MUL_OM_DST         = 5,
   V3D_BLEND_MUL_SRC_ALPHA      = 6,
   V3D_BLEND_MUL_OM_SRC_ALPHA   = 7,
   V3D_BLEND_MUL_DST_ALPHA      = 8,
   V3D_BLEND_MUL_OM_DST_ALPHA   = 9,
   V3D_BLEND_MUL_CONST          = 10,
   V3D_BLEND_MUL_OM_CONST       = 11,
   V3D_BLEND_MUL_CONST_ALPHA    = 12,
   V3D_BLEND_MUL_OM_CONST_ALPHA = 13,
   V3D_BLEND_MUL_SRC_ALPHA_SAT  = 14,
   V3D_BLEND_MUL_INVALID        = 16
} v3d_blend_mul_t;
static inline bool v3d_is_valid_blend_mul(v3d_blend_mul_t blend_mul)
{
   return (uint32_t)blend_mul <= 14;
}
extern const char *v3d_desc_blend_mul(v3d_blend_mul_t blend_mul);
typedef enum
{
   V3D_BLEND_VG_MODE_NORMAL      = 0,
   V3D_BLEND_VG_MODE_COVERAGE    = 1,
   V3D_BLEND_VG_MODE_COVERAGE_AM = 2,
   V3D_BLEND_VG_MODE_INVALID     = 4
} v3d_blend_vg_mode_t;
static inline bool v3d_is_valid_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode)
{
   return (uint32_t)blend_vg_mode <= 2;
}
extern const char *v3d_desc_blend_vg_mode(v3d_blend_vg_mode_t blend_vg_mode);
typedef enum
{
   V3D_LDST_BUF_COLOR0               = 0,
   V3D_LDST_BUF_COLOR1               = 1,
   V3D_LDST_BUF_COLOR2               = 2,
   V3D_LDST_BUF_COLOR3               = 3,
   V3D_LDST_BUF_COLOR4               = 4,
   V3D_LDST_BUF_COLOR5               = 5,
   V3D_LDST_BUF_COLOR6               = 6,
   V3D_LDST_BUF_COLOR7               = 7,
   V3D_LDST_BUF_NONE                 = 8,
   V3D_LDST_BUF_DEPTH                = 9,
   V3D_LDST_BUF_STENCIL              = 10,
   V3D_LDST_BUF_PACKED_DEPTH_STENCIL = 11,
   V3D_LDST_BUF_INVALID              = 16
} v3d_ldst_buf_t;
static inline bool v3d_is_valid_ldst_buf(v3d_ldst_buf_t ldst_buf)
{
   return (uint32_t)ldst_buf <= 11;
}
extern const char *v3d_desc_ldst_buf(v3d_ldst_buf_t ldst_buf);
typedef enum
{
   V3D_TILE_ALLOC_BLOCK_SIZE_64      = 0,
   V3D_TILE_ALLOC_BLOCK_SIZE_128     = 1,
   V3D_TILE_ALLOC_BLOCK_SIZE_256     = 2,
   V3D_TILE_ALLOC_BLOCK_SIZE_INVALID = 4
} v3d_tile_alloc_block_size_t;
static inline bool v3d_is_valid_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size)
{
   return (uint32_t)tile_alloc_block_size <= 2;
}
extern const char *v3d_desc_tile_alloc_block_size(v3d_tile_alloc_block_size_t tile_alloc_block_size);
extern v3d_tile_alloc_block_size_t v3d_translate_tile_alloc_block_size(uint32_t x);
extern uint32_t v3d_translate_from_tile_alloc_block_size(v3d_tile_alloc_block_size_t x);
typedef enum
{
   V3D_RT_BPP_32      = 0,
   V3D_RT_BPP_64      = 1,
   V3D_RT_BPP_128     = 2,
   V3D_RT_BPP_INVALID = 4
} v3d_rt_bpp_t;
static inline bool v3d_is_valid_rt_bpp(v3d_rt_bpp_t rt_bpp)
{
   return (uint32_t)rt_bpp <= 2;
}
extern const char *v3d_desc_rt_bpp(v3d_rt_bpp_t rt_bpp);
extern v3d_rt_bpp_t v3d_translate_rt_bpp(uint32_t x);
extern uint32_t v3d_translate_from_rt_bpp(v3d_rt_bpp_t x);
typedef enum
{
   V3D_RT_TYPE_8I      = 0,
   V3D_RT_TYPE_8UI     = 1,
   V3D_RT_TYPE_8       = 2,
   V3D_RT_TYPE_16I     = 4,
   V3D_RT_TYPE_16UI    = 5,
   V3D_RT_TYPE_16F     = 6,
   V3D_RT_TYPE_32I     = 8,
   V3D_RT_TYPE_32UI    = 9,
   V3D_RT_TYPE_32F     = 10,
   V3D_RT_TYPE_INVALID = 16
} v3d_rt_type_t;
extern bool v3d_is_valid_rt_type(v3d_rt_type_t rt_type);
extern const char *v3d_desc_rt_type(v3d_rt_type_t rt_type);
typedef enum
{
   V3D_DEPTH_TYPE_32F     = 0,
   V3D_DEPTH_TYPE_24      = 1,
   V3D_DEPTH_TYPE_16      = 2,
   V3D_DEPTH_TYPE_INVALID = 16
} v3d_depth_type_t;
static inline bool v3d_is_valid_depth_type(v3d_depth_type_t depth_type)
{
   return (uint32_t)depth_type <= 2;
}
extern const char *v3d_desc_depth_type(v3d_depth_type_t depth_type);
typedef enum
{
   V3D_EZ_DIRECTION_LT_LE   = 0,
   V3D_EZ_DIRECTION_GT_GE   = 1,
   V3D_EZ_DIRECTION_INVALID = 2
} v3d_ez_direction_t;
static inline bool v3d_is_valid_ez_direction(v3d_ez_direction_t ez_direction)
{
   return (uint32_t)ez_direction <= 1;
}
extern const char *v3d_desc_ez_direction(v3d_ez_direction_t ez_direction);
typedef enum
{
   V3D_DECIMATE_SAMPLE0     = 0,
   V3D_DECIMATE_4X          = 1,
   V3D_DECIMATE_16X         = 2,
   V3D_DECIMATE_ALL_SAMPLES = 3,
   V3D_DECIMATE_INVALID     = 4
} v3d_decimate_t;
static inline bool v3d_is_valid_decimate(v3d_decimate_t decimate)
{
   return (uint32_t)decimate <= 3;
}
extern const char *v3d_desc_decimate(v3d_decimate_t decimate);
typedef enum
{
   V3D_DITHER_OFF     = 0,
   V3D_DITHER_RGB     = 1,
   V3D_DITHER_A       = 2,
   V3D_DITHER_RGBA    = 3,
   V3D_DITHER_INVALID = 4
} v3d_dither_t;
static inline bool v3d_is_valid_dither(v3d_dither_t dither)
{
   return (uint32_t)dither <= 3;
}
extern const char *v3d_desc_dither(v3d_dither_t dither);
typedef enum
{
   V3D_DEPTH_FORMAT_32F         = 0,
   V3D_DEPTH_FORMAT_24          = 1,
   V3D_DEPTH_FORMAT_16          = 2,
   V3D_DEPTH_FORMAT_24_STENCIL8 = 3,
   V3D_DEPTH_FORMAT_INVALID     = 64
} v3d_depth_format_t;
static inline bool v3d_is_valid_depth_format(v3d_depth_format_t depth_format)
{
   return (uint32_t)depth_format <= 3;
}
extern const char *v3d_desc_depth_format(v3d_depth_format_t depth_format);
typedef enum
{
   V3D_PIXEL_FORMAT_SRGB8_ALPHA8   = 0,
   V3D_PIXEL_FORMAT_SRGB8          = 1,
   V3D_PIXEL_FORMAT_RGB10_A2UI     = 2,
   V3D_PIXEL_FORMAT_RGB10_A2       = 3,
   V3D_PIXEL_FORMAT_A1_BGR5        = 4,
   V3D_PIXEL_FORMAT_A1_BGR5_AM     = 5,
   V3D_PIXEL_FORMAT_ABGR4          = 6,
   V3D_PIXEL_FORMAT_BGR565         = 7,
   V3D_PIXEL_FORMAT_R11F_G11F_B10F = 8,
   V3D_PIXEL_FORMAT_RGBA32F        = 9,
   V3D_PIXEL_FORMAT_RG32F          = 10,
   V3D_PIXEL_FORMAT_R32F           = 11,
   V3D_PIXEL_FORMAT_RGBA32I        = 12,
   V3D_PIXEL_FORMAT_RG32I          = 13,
   V3D_PIXEL_FORMAT_R32I           = 14,
   V3D_PIXEL_FORMAT_RGBA32UI       = 15,
   V3D_PIXEL_FORMAT_RG32UI         = 16,
   V3D_PIXEL_FORMAT_R32UI          = 17,
   V3D_PIXEL_FORMAT_RGBA16F        = 18,
   V3D_PIXEL_FORMAT_RG16F          = 19,
   V3D_PIXEL_FORMAT_R16F           = 20,
   V3D_PIXEL_FORMAT_RGBA16I        = 21,
   V3D_PIXEL_FORMAT_RG16I          = 22,
   V3D_PIXEL_FORMAT_R16I           = 23,
   V3D_PIXEL_FORMAT_RGBA16UI       = 24,
   V3D_PIXEL_FORMAT_RG16UI         = 25,
   V3D_PIXEL_FORMAT_R16UI          = 26,
   V3D_PIXEL_FORMAT_RGBA8          = 27,
   V3D_PIXEL_FORMAT_RGB8           = 28,
   V3D_PIXEL_FORMAT_RG8            = 29,
   V3D_PIXEL_FORMAT_R8             = 30,
   V3D_PIXEL_FORMAT_RGBA8I         = 31,
   V3D_PIXEL_FORMAT_RG8I           = 32,
   V3D_PIXEL_FORMAT_R8I            = 33,
   V3D_PIXEL_FORMAT_RGBA8UI        = 34,
   V3D_PIXEL_FORMAT_RG8UI          = 35,
   V3D_PIXEL_FORMAT_R8UI           = 36,
   V3D_PIXEL_FORMAT_SRGBX8         = 37,
   V3D_PIXEL_FORMAT_RGBX8          = 38,
   V3D_PIXEL_FORMAT_BSTC           = 39,
   V3D_PIXEL_FORMAT_INVALID        = 64
} v3d_pixel_format_t;
static inline bool v3d_is_valid_pixel_format(v3d_pixel_format_t pixel_format)
{
   return (uint32_t)pixel_format <= 39;
}
extern const char *v3d_desc_pixel_format(v3d_pixel_format_t pixel_format);
typedef enum
{
   V3D_MEMORY_FORMAT_RASTER     = 0,
   V3D_MEMORY_FORMAT_LINEARTILE = 1,
   V3D_MEMORY_FORMAT_UBLINEAR_1 = 2,
   V3D_MEMORY_FORMAT_UBLINEAR_2 = 3,
   V3D_MEMORY_FORMAT_UIF_NO_XOR = 4,
   V3D_MEMORY_FORMAT_UIF_XOR    = 5,
   V3D_MEMORY_FORMAT_INVALID    = 8
} v3d_memory_format_t;
static inline bool v3d_is_valid_memory_format(v3d_memory_format_t memory_format)
{
   return (uint32_t)memory_format <= 5;
}
extern const char *v3d_desc_memory_format(v3d_memory_format_t memory_format);
typedef enum
{
   V3D_LDST_MEMORY_FORMAT_UIF_NO_XOR = 0,
   V3D_LDST_MEMORY_FORMAT_UIF_XOR    = 1,
   V3D_LDST_MEMORY_FORMAT_INVALID    = 2
} v3d_ldst_memory_format_t;
static inline bool v3d_is_valid_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format)
{
   return (uint32_t)ldst_memory_format <= 1;
}
extern const char *v3d_desc_ldst_memory_format(v3d_ldst_memory_format_t ldst_memory_format);
typedef enum
{
   V3D_STENCIL_OP_ZERO    = 0,
   V3D_STENCIL_OP_KEEP    = 1,
   V3D_STENCIL_OP_REPLACE = 2,
   V3D_STENCIL_OP_INCR    = 3,
   V3D_STENCIL_OP_DECR    = 4,
   V3D_STENCIL_OP_INVERT  = 5,
   V3D_STENCIL_OP_INCWRAP = 6,
   V3D_STENCIL_OP_DECWRAP = 7,
   V3D_STENCIL_OP_INVALID = 8
} v3d_stencil_op_t;
static inline bool v3d_is_valid_stencil_op(v3d_stencil_op_t stencil_op)
{
   return (uint32_t)stencil_op <= 7;
}
extern const char *v3d_desc_stencil_op(v3d_stencil_op_t stencil_op);
typedef enum
{
   V3D_FLAGS_ACTION_KEEP    = 0,
   V3D_FLAGS_ACTION_ZERO    = 1,
   V3D_FLAGS_ACTION_SET     = 2,
   V3D_FLAGS_ACTION_INVALID = 4
} v3d_flags_action_t;
static inline bool v3d_is_valid_flags_action(v3d_flags_action_t flags_action)
{
   return (uint32_t)flags_action <= 2;
}
extern const char *v3d_desc_flags_action(v3d_flags_action_t flags_action);
typedef enum
{
   V3D_BCFG_TYPE_PART1   = 0,
   V3D_BCFG_TYPE_PART2   = 1,
   V3D_BCFG_TYPE_INVALID = 2
} v3d_bcfg_type_t;
static inline bool v3d_is_valid_bcfg_type(v3d_bcfg_type_t bcfg_type)
{
   return (uint32_t)bcfg_type <= 1;
}
extern const char *v3d_desc_bcfg_type(v3d_bcfg_type_t bcfg_type);
typedef enum
{
   V3D_RCFG_TYPE_COMMON             = 0,
   V3D_RCFG_TYPE_Z_STENCIL          = 1,
   V3D_RCFG_TYPE_SEPARATE_STENCIL   = 2,
   V3D_RCFG_TYPE_COLOR              = 3,
   V3D_RCFG_TYPE_ZS_CLEAR_VALUES    = 4,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART1 = 5,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART2 = 6,
   V3D_RCFG_TYPE_CLEAR_COLORS_PART3 = 7,
   V3D_RCFG_TYPE_INVALID            = 16
} v3d_rcfg_type_t;
static inline bool v3d_is_valid_rcfg_type(v3d_rcfg_type_t rcfg_type)
{
   return (uint32_t)rcfg_type <= 7;
}
extern const char *v3d_desc_rcfg_type(v3d_rcfg_type_t rcfg_type);
typedef enum
{
   V3D_SUPERTILE_ORDER_MORTON  = 0,
   V3D_SUPERTILE_ORDER_RASTER  = 1,
   V3D_SUPERTILE_ORDER_INVALID = 2
} v3d_supertile_order_t;
static inline bool v3d_is_valid_supertile_order(v3d_supertile_order_t supertile_order)
{
   return (uint32_t)supertile_order <= 1;
}
extern const char *v3d_desc_supertile_order(v3d_supertile_order_t supertile_order);
typedef enum
{
   V3D_TFU_RGBORD_RGBA_OR_RG_YUYV_OR_UV = 0,
   V3D_TFU_RGBORD_ABGR_OR_GR_VYUY_OR_VU = 1,
   V3D_TFU_RGBORD_ARGB_OR_YYUV          = 2,
   V3D_TFU_RGBORD_BGRA_OR_VUYY          = 3,
   V3D_TFU_RGBORD_INVALID               = 4
} v3d_tfu_rgbord_t;
static inline bool v3d_is_valid_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord)
{
   return (uint32_t)tfu_rgbord <= 3;
}
extern const char *v3d_desc_tfu_rgbord(v3d_tfu_rgbord_t tfu_rgbord);
typedef enum
{
   V3D_TFU_IFORMAT_RASTER     = 0,
   V3D_TFU_IFORMAT_SAND_128   = 1,
   V3D_TFU_IFORMAT_SAND_256   = 2,
   V3D_TFU_IFORMAT_LINEARTILE = 11,
   V3D_TFU_IFORMAT_UBLINEAR_1 = 12,
   V3D_TFU_IFORMAT_UBLINEAR_2 = 13,
   V3D_TFU_IFORMAT_UIF_NO_XOR = 14,
   V3D_TFU_IFORMAT_UIF_XOR    = 15,
   V3D_TFU_IFORMAT_INVALID    = 16
} v3d_tfu_iformat_t;
extern bool v3d_is_valid_tfu_iformat(v3d_tfu_iformat_t tfu_iformat);
extern const char *v3d_desc_tfu_iformat(v3d_tfu_iformat_t tfu_iformat);
typedef enum
{
   V3D_TFU_OFORMAT_LINEARTILE = 3,
   V3D_TFU_OFORMAT_UBLINEAR_1 = 4,
   V3D_TFU_OFORMAT_UBLINEAR_2 = 5,
   V3D_TFU_OFORMAT_UIF_NO_XOR = 6,
   V3D_TFU_OFORMAT_UIF_XOR    = 7,
   V3D_TFU_OFORMAT_INVALID    = 8
} v3d_tfu_oformat_t;
extern bool v3d_is_valid_tfu_oformat(v3d_tfu_oformat_t tfu_oformat);
extern const char *v3d_desc_tfu_oformat(v3d_tfu_oformat_t tfu_oformat);
typedef enum
{
   V3D_L2T_FLUSH_MODE_FLUSH   = 0,
   V3D_L2T_FLUSH_MODE_CLEAR   = 1,
   V3D_L2T_FLUSH_MODE_CLEAN   = 2,
   V3D_L2T_FLUSH_MODE_INVALID = 4
} v3d_l2t_flush_mode_t;
static inline bool v3d_is_valid_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode)
{
   return (uint32_t)l2t_flush_mode <= 2;
}
extern const char *v3d_desc_l2t_flush_mode(v3d_l2t_flush_mode_t l2t_flush_mode);
typedef enum
{
   V3D_VRI_SIZE_HALF    = 0,
   V3D_VRI_SIZE_FULL    = 1,
   V3D_VRI_SIZE_INVALID = 16
} v3d_vri_size_t;
static inline bool v3d_is_valid_vri_size(v3d_vri_size_t vri_size)
{
   return (uint32_t)vri_size <= 1;
}
extern const char *v3d_desc_vri_size(v3d_vri_size_t vri_size);
typedef enum
{
   V3D_TLB_SIZE_QUARTER = 0,
   V3D_TLB_SIZE_HALF    = 1,
   V3D_TLB_SIZE_FULL    = 2,
   V3D_TLB_SIZE_INVALID = 16
} v3d_tlb_size_t;
static inline bool v3d_is_valid_tlb_size(v3d_tlb_size_t tlb_size)
{
   return (uint32_t)tlb_size <= 2;
}
extern const char *v3d_desc_tlb_size(v3d_tlb_size_t tlb_size);
typedef enum
{
   V3D_IUC_SIZE_1KB     = 6,
   V3D_IUC_SIZE_2KB     = 7,
   V3D_IUC_SIZE_4KB     = 8,
   V3D_IUC_SIZE_INVALID = 16
} v3d_iuc_size_t;
extern bool v3d_is_valid_iuc_size(v3d_iuc_size_t iuc_size);
extern const char *v3d_desc_iuc_size(v3d_iuc_size_t iuc_size);
typedef enum
{
   V3D_IP_RECIPIENT_NONE     = 0,
   V3D_IP_RECIPIENT_TAHITI_B = 7,
   V3D_IP_RECIPIENT_ARUBA    = 9,
   V3D_IP_RECIPIENT_TAHITI_P = 10,
   V3D_IP_RECIPIENT_BCG      = 11,
   V3D_IP_RECIPIENT_INVALID  = 256
} v3d_ip_recipient_t;
extern bool v3d_is_valid_ip_recipient(v3d_ip_recipient_t ip_recipient);
extern const char *v3d_desc_ip_recipient(v3d_ip_recipient_t ip_recipient);
typedef enum
{
   V3D_CTSUBSRUN_STOPPED_AT_END   = 0,
   V3D_CTSUBSRUN_STOPPED_AT_HALT  = 1,
   V3D_CTSUBSRUN_RUNNING_NORMALLY = 2,
   V3D_CTSUBSRUN_STALLED          = 3,
   V3D_CTSUBSRUN_INVALID          = 4
} v3d_ctsubsrun_t;
static inline bool v3d_is_valid_ctsubsrun(v3d_ctsubsrun_t ctsubsrun)
{
   return (uint32_t)ctsubsrun <= 3;
}
extern const char *v3d_desc_ctsubsrun(v3d_ctsubsrun_t ctsubsrun);
typedef enum
{
   V3D_CL_COMPR_TYPE_C0         = 0,
   V3D_CL_COMPR_TYPE_C1         = 1,
   V3D_CL_COMPR_TYPE_C2         = 2,
   V3D_CL_COMPR_TYPE_C3         = 3,
   V3D_CL_COMPR_TYPE_C4         = 4,
   V3D_CL_COMPR_TYPE_C5         = 5,
   V3D_CL_COMPR_TYPE_IID8       = 6,
   V3D_CL_COMPR_TYPE_IID32      = 7,
   V3D_CL_COMPR_TYPE_REL_BRANCH = 8,
   V3D_CL_COMPR_TYPE_BRANCH     = 9,
   V3D_CL_COMPR_TYPE_ESCAPE     = 10,
   V3D_CL_COMPR_TYPE_NOT_COMMON = 11,
   V3D_CL_COMPR_TYPE_INVALID    = 16
} v3d_cl_compr_type_t;
static inline bool v3d_is_valid_cl_compr_type(v3d_cl_compr_type_t cl_compr_type)
{
   return (uint32_t)cl_compr_type <= 11;
}
extern const char *v3d_desc_cl_compr_type(v3d_cl_compr_type_t cl_compr_type);
typedef enum
{
   V3D_CL_TESS_TYPE_TRIANGLE = 0,
   V3D_CL_TESS_TYPE_QUAD     = 1,
   V3D_CL_TESS_TYPE_ISOLINES = 2,
   V3D_CL_TESS_TYPE_INVALID  = 4
} v3d_cl_tess_type_t;
static inline bool v3d_is_valid_cl_tess_type(v3d_cl_tess_type_t cl_tess_type)
{
   return (uint32_t)cl_tess_type <= 2;
}
extern const char *v3d_desc_cl_tess_type(v3d_cl_tess_type_t cl_tess_type);
typedef enum
{
   V3D_CL_TESS_EDGE_SPACING_EVEN            = 0,
   V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_EVEN = 1,
   V3D_CL_TESS_EDGE_SPACING_FRACTIONAL_ODD  = 2,
   V3D_CL_TESS_EDGE_SPACING_INVALID         = 4
} v3d_cl_tess_edge_spacing_t;
static inline bool v3d_is_valid_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing)
{
   return (uint32_t)cl_tess_edge_spacing <= 2;
}
extern const char *v3d_desc_cl_tess_edge_spacing(v3d_cl_tess_edge_spacing_t cl_tess_edge_spacing);
typedef enum
{
   V3D_CL_TCS_BATCH_FLUSH_MODE_FULLY_PACKED            = 0,
   V3D_CL_TCS_BATCH_FLUSH_MODE_SINGLE_PATCH            = 1,
   V3D_CL_TCS_BATCH_FLUSH_MODE_PACKED_COMPLETE_PATCHES = 2,
   V3D_CL_TCS_BATCH_FLUSH_MODE_INVALID                 = 4
} v3d_cl_tcs_batch_flush_mode_t;
static inline bool v3d_is_valid_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode)
{
   return (uint32_t)cl_tcs_batch_flush_mode <= 2;
}
extern const char *v3d_desc_cl_tcs_batch_flush_mode(v3d_cl_tcs_batch_flush_mode_t cl_tcs_batch_flush_mode);
typedef enum
{
   V3D_CL_TCS_OUTPUT_PACK_X16     = 0,
   V3D_CL_TCS_OUTPUT_PACK_X8      = 1,
   V3D_CL_TCS_OUTPUT_PACK_X4      = 2,
   V3D_CL_TCS_OUTPUT_PACK_INVALID = 4
} v3d_cl_tcs_output_pack_t;
static inline bool v3d_is_valid_cl_tcs_output_pack(v3d_cl_tcs_output_pack_t cl_tcs_output_pack)
{
   return (uint32_t)cl_tcs_output_pack <= 2;
}
extern const char *v3d_desc_cl_tcs_output_pack(v3d_cl_tcs_output_pack_t cl_tcs_output_pack);
typedef enum
{
   V3D_CL_GEOM_PRIM_TYPE_POINTS         = 0,
   V3D_CL_GEOM_PRIM_TYPE_LINE_STRIP     = 1,
   V3D_CL_GEOM_PRIM_TYPE_TRIANGLE_STRIP = 2,
   V3D_CL_GEOM_PRIM_TYPE_INVALID        = 4
} v3d_cl_geom_prim_type_t;
static inline bool v3d_is_valid_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type)
{
   return (uint32_t)cl_geom_prim_type <= 2;
}
extern const char *v3d_desc_cl_geom_prim_type(v3d_cl_geom_prim_type_t cl_geom_prim_type);
typedef enum
{
   V3D_CL_GEOM_OUTPUT_PACK_X16     = 0,
   V3D_CL_GEOM_OUTPUT_PACK_X8      = 1,
   V3D_CL_GEOM_OUTPUT_PACK_X4      = 2,
   V3D_CL_GEOM_OUTPUT_PACK_X1      = 3,
   V3D_CL_GEOM_OUTPUT_PACK_INVALID = 4
} v3d_cl_geom_output_pack_t;
static inline bool v3d_is_valid_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack)
{
   return (uint32_t)cl_geom_output_pack <= 3;
}
extern const char *v3d_desc_cl_geom_output_pack(v3d_cl_geom_output_pack_t cl_geom_output_pack);
typedef enum
{
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_21 = 0,
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_02 = 1,
   V3D_TRI_IND_REUSE_NEW_01_EQ_PREV_10 = 2,
   V3D_TRI_IND_REUSE_INVALID           = 4
} v3d_tri_ind_reuse_t;
static inline bool v3d_is_valid_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse)
{
   return (uint32_t)tri_ind_reuse <= 2;
}
extern const char *v3d_desc_tri_ind_reuse(v3d_tri_ind_reuse_t tri_ind_reuse);
typedef enum
{
   V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_1 = 0,
   V3D_LINE_IND_REUSE_NEW_0_EQ_PREV_0 = 1,
   V3D_LINE_IND_REUSE_INVALID         = 4
} v3d_line_ind_reuse_t;
static inline bool v3d_is_valid_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse)
{
   return (uint32_t)line_ind_reuse <= 1;
}
extern const char *v3d_desc_line_ind_reuse(v3d_line_ind_reuse_t line_ind_reuse);
typedef enum
{
   V3D_CL_HALT                               = 0,
   V3D_CL_NOP                                = 1,
   V3D_CL_FLUSH                              = 4,
   V3D_CL_FLUSH_ALL_STATE                    = 5,
   V3D_CL_START_TILE_BINNING                 = 6,
   V3D_CL_INCR_SEMAPHORE                     = 7,
   V3D_CL_WAIT_SEMAPHORE                     = 8,
   V3D_CL_WAIT_PREV_FRAME                    = 9,
   V3D_CL_ENABLE_Z_ONLY                      = 10,
   V3D_CL_DISABLE_Z_ONLY                     = 11,
   V3D_CL_END_Z_ONLY                         = 12,
   V3D_CL_END_RENDER                         = 13,
   V3D_CL_WAIT_TRANSFORM_FEEDBACK            = 14,
   V3D_CL_BRANCH_SUB_AUTOCHAIN               = 15,
   V3D_CL_BRANCH                             = 16,
   V3D_CL_BRANCH_SUB                         = 17,
   V3D_CL_RETURN                             = 18,
   V3D_CL_FLUSH_VCD_CACHE                    = 19,
   V3D_CL_GENERIC_TILE_LIST                  = 20,
   V3D_CL_BRANCH_IMPLICIT_TILE               = 21,
   V3D_CL_BRANCH_EXPLICIT_SUPERTILE          = 22,
   V3D_CL_SUPERTILE_COORDS                   = 23,
   V3D_CL_STORE_SUBSAMPLE                    = 24,
   V3D_CL_STORE_SUBSAMPLE_EX                 = 25,
   V3D_CL_LOAD                               = 26,
   V3D_CL_END_TILE                           = 27,
   V3D_CL_STORE_GENERAL                      = 29,
   V3D_CL_LOAD_GENERAL                       = 30,
   V3D_CL_INDEXED_PRIM_LIST                  = 32,
   V3D_CL_INDIRECT_INDEXED_PRIM_LIST         = 33,
   V3D_CL_INDEXED_INSTANCED_PRIM_LIST        = 34,
   V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST  = 35,
   V3D_CL_VERTEX_ARRAY_PRIMS                 = 36,
   V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS        = 37,
   V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS       = 38,
   V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS = 39,
   V3D_CL_BASE_VERTEX_BASE_INSTANCE          = 43,
   V3D_CL_INDIRECT_PRIMITIVE_LIMITS          = 44,
   V3D_CL_VG_COORD_ARRAY_PRIMS               = 41,
   V3D_CL_VG_INLINE_PRIMS                    = 42,
   V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO      = 48,
   V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID   = 49,
   V3D_CL_CLIPPED_PRIM_IID_ZERO              = 52,
   V3D_CL_CLIPPED_PRIM_CURRENT_IID           = 53,
   V3D_CL_PRIM_LIST_FORMAT                   = 56,
   V3D_CL_GL_SHADER                          = 64,
   V3D_CL_GL_T_SHADER                        = 65,
   V3D_CL_GL_G_SHADER                        = 66,
   V3D_CL_GL_TG_SHADER                       = 67,
   V3D_CL_NV_SHADER                          = 68,
   V3D_CL_VG_SHADER                          = 69,
   V3D_CL_VG_INLINE_SHADER                   = 70,
   V3D_CL_VCM_CACHE_SIZE                     = 73,
   V3D_CL_TRANSFORM_FEEDBACK_ENABLE          = 74,
   V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA      = 75,
   V3D_CL_L1_CACHE_FLUSH_CONTROL             = 76,
   V3D_CL_L2T_CACHE_FLUSH_CONTROL            = 77,
   V3D_CL_L2C_CACHE_FLUSH                    = 78,
   V3D_CL_STENCIL_CFG                        = 80,
   V3D_CL_BLEND_CFG                          = 84,
   V3D_CL_BLEND_CCOLOR                       = 86,
   V3D_CL_COLOR_WMASKS                       = 87,
   V3D_CL_ZERO_ALL_CENTROID_FLAGS            = 88,
   V3D_CL_ZERO_ALL_FLATSHADE_FLAGS           = 97,
   V3D_CL_CENTROID_FLAGS                     = 89,
   V3D_CL_FLATSHADE_FLAGS                    = 98,
   V3D_CL_SAMPLE_COVERAGE                    = 91,
   V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE     = 92,
   V3D_CL_CFG_BITS                           = 96,
   V3D_CL_POINT_SIZE                         = 104,
   V3D_CL_LINE_WIDTH                         = 105,
   V3D_CL_DEPTH_OFFSET                       = 106,
   V3D_CL_CLIP                               = 107,
   V3D_CL_VIEWPORT_OFFSET                    = 108,
   V3D_CL_CLIPZ                              = 109,
   V3D_CL_CLIPPER_XY                         = 110,
   V3D_CL_CLIPPER_Z                          = 111,
   V3D_CL_TILE_BINNING_MODE_CFG              = 120,
   V3D_CL_TILE_RENDERING_MODE_CFG            = 121,
   V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG  = 122,
   V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE = 123,
   V3D_CL_TILE_COORDS                        = 124,
   V3D_CL_IMPLICIT_TILE_COORDS               = 125,
   V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE       = 126,
   V3D_CL_INVALID                            = 256
} v3d_cl_opcode_t;
extern bool v3d_is_valid_cl_opcode(v3d_cl_opcode_t cl_opcode);
extern const char *v3d_desc_cl_opcode(v3d_cl_opcode_t cl_opcode);
typedef struct
{
   v3d_threading_t threading;
   bool propagate_nans;
   v3d_addr_t addr;
   v3d_addr_t unifs_addr;
} V3D_SHADER_ARGS_T;
typedef struct
{
   uint32_t size_sectors;
   v3d_cl_tcs_output_pack_t pack;
} V3D_TESS_SEG_ARGS_T;
typedef struct
{
   uint32_t size_sectors;
   v3d_cl_geom_output_pack_t pack;
} V3D_GEOM_SEG_ARGS_T;
typedef struct
{
   bool point_size_included;
   bool clipping;
   bool cs_vertex_id;
   bool cs_instance_id;
   bool vs_vertex_id;
   bool vs_instance_id;
   bool z_write;
   bool no_ez;
   bool cs_separate_blocks;
   bool vs_separate_blocks;
   bool scb_wait_on_first_thrsw;
   bool disable_scb;
   uint32_t num_varys;
   uint32_t fs_working_size;
   uint32_t cs_output_size;
   uint32_t cs_working_size;
   uint32_t vs_output_size;
   uint32_t vs_working_size;
   v3d_addr_t defaults;
   V3D_SHADER_ARGS_T fs;
   V3D_SHADER_ARGS_T vs;
   V3D_SHADER_ARGS_T cs;
} V3D_SHADREC_GL_MAIN_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_gl_main(uint32_t *packed, const V3D_SHADREC_GL_MAIN_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_main(V3D_SHADREC_GL_MAIN_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_GL_MAIN_PACKED_SIZE 36
typedef struct
{
   V3D_SHADER_ARGS_T gs_bin;
   V3D_SHADER_ARGS_T gs_render;
} V3D_SHADREC_GL_GEOM_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_gl_geom(uint32_t *packed, const V3D_SHADREC_GL_GEOM_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_geom(V3D_SHADREC_GL_GEOM_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_GL_GEOM_PACKED_SIZE 16
typedef struct
{
   V3D_SHADER_ARGS_T tcs_bin;
   V3D_SHADER_ARGS_T tcs_render;
   V3D_SHADER_ARGS_T tes_bin;
   V3D_SHADER_ARGS_T tes_render;
} V3D_SHADREC_GL_TESS_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_gl_tess(uint32_t *packed, const V3D_SHADREC_GL_TESS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_tess(V3D_SHADREC_GL_TESS_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_GL_TESS_PACKED_SIZE 32
typedef struct
{
   bool tess_enabled;
   v3d_cl_tess_type_t tess_type;
   bool tess_point_mode;
   v3d_cl_tess_edge_spacing_t tess_edge_spacing;
   bool tess_clockwise;
   bool tcs_bypass;
   bool tcs_bypass_render;
   v3d_cl_tcs_batch_flush_mode_t tcs_batch_flush;
   bool tcs_barrier;
   uint32_t per_patch_depth_bin;
   uint32_t per_patch_depth_render;
   uint32_t num_tcs_invocations;
   V3D_TESS_SEG_ARGS_T tcs_output_bin;
   V3D_TESS_SEG_ARGS_T tcs_output_render;
   V3D_TESS_SEG_ARGS_T tes_output_bin;
   V3D_TESS_SEG_ARGS_T tes_output_render;
   bool geom_enabled;
   v3d_cl_geom_prim_type_t geom_output;
   bool geom_clockwise;
   uint32_t geom_max_prims;
   V3D_GEOM_SEG_ARGS_T geom_output_bin;
   V3D_GEOM_SEG_ARGS_T geom_output_render;
   uint32_t geom_num_instances;
} V3D_SHADREC_GL_TESS_OR_GEOM_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_gl_tess_or_geom(uint32_t *packed, const V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_tess_or_geom(V3D_SHADREC_GL_TESS_OR_GEOM_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_GL_TESS_OR_GEOM_PACKED_SIZE 16
typedef struct
{
   v3d_addr_t addr;
   uint32_t size;
   v3d_attr_type_t type;
   bool signed_int;
   bool normalised_int;
   bool read_as_int;
   uint32_t cs_num_reads;
   uint32_t vs_num_reads;
   uint32_t divisor;
   uint32_t stride;
} V3D_SHADREC_GL_ATTR_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_gl_attr(uint32_t *packed, const V3D_SHADREC_GL_ATTR_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_gl_attr(V3D_SHADREC_GL_ATTR_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_GL_ATTR_PACKED_SIZE 12
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_SHADREC_VG_T;
EXPORT_FOR_CLIF_CC void v3d_pack_shadrec_vg(uint32_t *packed, const V3D_SHADREC_VG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_shadrec_vg(V3D_SHADREC_VG_T *unpacked, const uint32_t *packed);
#define V3D_SHADREC_VG_PACKED_SIZE 12
typedef struct
{
   uint32_t unif;
} V3D_UNIF_RAW_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_unif_raw(const V3D_UNIF_RAW_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_raw(V3D_UNIF_RAW_T *unpacked, uint32_t packed0);
#define V3D_UNIF_RAW_PACKED_SIZE 4
typedef struct
{
   v3d_addr_t addr;
} V3D_UNIF_ADDR_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_unif_addr(const V3D_UNIF_ADDR_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_addr(V3D_UNIF_ADDR_T *unpacked, uint32_t packed0);
#define V3D_UNIF_ADDR_PACKED_SIZE 4
#if !V3D_HAS_NEW_TMU_CFG
typedef struct
{
   v3d_tmu_type_t type;
   bool srgb;
   bool pix_mask;
   uint32_t width;
   uint32_t height;
} V3D_TMU_PARAM0_CFG0_T;
typedef struct
{
   v3d_tmu_ltype_t ltype;
   bool fetch;
   bool gather;
   bool bias;
   bool bslod;
   bool coefficient;
   bool shadow;
   v3d_tmu_wrap_t wrap_s;
   v3d_tmu_wrap_t wrap_t;
   v3d_tmu_wrap_t wrap_r;
   int32_t tex_off_s;
   int32_t tex_off_t;
   int32_t tex_off_r;
   bool pix_mask;
} V3D_TMU_PARAM0_CFG1_T;
typedef union
{
   V3D_TMU_PARAM0_CFG0_T cfg0;
   V3D_TMU_PARAM0_CFG1_T cfg1;
} V3D_TMU_PARAM0_U_T;
typedef struct
{
   uint32_t cfg;
   V3D_TMU_PARAM0_U_T u;
} V3D_TMU_PARAM0_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param0_cfg0(const V3D_TMU_PARAM0_CFG0_T *unpacked);
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param0_cfg1(const V3D_TMU_PARAM0_CFG1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM0_PACKED_SIZE 4
#endif
#if !V3D_HAS_NEW_TMU_CFG
typedef struct
{
   v3d_tmu_wrap_cfg0_t wrap_s;
   v3d_tmu_wrap_cfg0_t wrap_t;
   v3d_tmu_filter_t filter;
   bool bslod;
   v3d_addr_t base;
} V3D_TMU_PARAM1_CFG0_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param1_cfg0(const V3D_TMU_PARAM1_CFG0_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1_cfg0(V3D_TMU_PARAM1_CFG0_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM1_CFG0_PACKED_SIZE 4
#endif
#if !V3D_HAS_NEW_TMU_CFG
typedef struct
{
   bool word0_en;
   bool word1_en;
   bool word2_en;
   bool word3_en;
   bool unnorm;
   v3d_addr_t ts_base;
} V3D_TMU_PARAM1_CFG1_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param1_cfg1(const V3D_TMU_PARAM1_CFG1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1_cfg1(V3D_TMU_PARAM1_CFG1_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM1_CFG1_PACKED_SIZE 4
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef bool V3D_TMU_PARAM0_WORD_EN_T[4];
typedef struct
{
   V3D_TMU_PARAM0_WORD_EN_T word_en;
   v3d_addr_t tex_state_addr;
} V3D_TMU_PARAM0_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param0(const V3D_TMU_PARAM0_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param0(V3D_TMU_PARAM0_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM0_PACKED_SIZE 4
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef struct
{
   bool output_32;
   bool unnorm;
   bool pix_mask;
   v3d_addr_t sampler_addr;
} V3D_TMU_PARAM1_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param1(const V3D_TMU_PARAM1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param1(V3D_TMU_PARAM1_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM1_PACKED_SIZE 4
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef int32_t V3D_TMU_PARAM2_OFFSETS_T[3];
typedef struct
{
   bool tmuoff_per_sample;
   bool bslod;
   uint32_t coeff_sample;
   bool coefficient;
   uint32_t gather_comp;
   bool gather;
   V3D_TMU_PARAM2_OFFSETS_T offsets;
} V3D_TMU_PARAM2_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tmu_param2(const V3D_TMU_PARAM2_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_param2(V3D_TMU_PARAM2_T *unpacked, uint32_t packed0);
#define V3D_TMU_PARAM2_PACKED_SIZE 4
#endif
typedef struct
{
   v3d_tmu_direct_type_t type;
   v3d_tmu_direct_op_t op;
   bool per_pixel_enable;
} V3D_TMU_DIRECT_CONFIG_T;
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tmu_direct_config(const V3D_TMU_DIRECT_CONFIG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_direct_config(V3D_TMU_DIRECT_CONFIG_T *unpacked, uint8_t packed0);
#define V3D_TMU_DIRECT_CONFIG_PACKED_SIZE 1
typedef struct
{
   v3d_tsy_op_t op;
} V3D_TSY_CONFIG_T;
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tsy_config(const V3D_TSY_CONFIG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tsy_config(V3D_TSY_CONFIG_T *unpacked, uint8_t packed0);
#define V3D_TSY_CONFIG_PACKED_SIZE 1
typedef struct
{
   uint32_t num_words;
   bool no_swap;
   bool all_samples_same_data;
   uint32_t rt;
} V3D_TLB_CONFIG_COLOR_F16_T;
typedef struct
{
   uint32_t num_words;
   bool all_samples_same_data;
   uint32_t rt;
   bool as_int;
} V3D_TLB_CONFIG_COLOR_32_T;
typedef struct
{
   bool use_written_z;
} V3D_TLB_CONFIG_Z_T;
typedef union
{
   V3D_TLB_CONFIG_COLOR_F16_T color_f16;
   V3D_TLB_CONFIG_COLOR_32_T color_32;
   V3D_TLB_CONFIG_Z_T z;
} V3D_TLB_CONFIG_U_T;
typedef struct
{
   v3d_tlb_rw_type_t type;
   V3D_TLB_CONFIG_U_T u;
} V3D_TLB_CONFIG_T;
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tlb_config_color_f16(const V3D_TLB_CONFIG_COLOR_F16_T *unpacked);
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tlb_config_color_32(const V3D_TLB_CONFIG_COLOR_32_T *unpacked);
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tlb_config_z(const V3D_TLB_CONFIG_Z_T *unpacked);
EXPORT_FOR_CLIF_CC uint8_t v3d_pack_tlb_config_alpha_mask(void);
EXPORT_FOR_CLIF_CC void v3d_unpack_tlb_config(V3D_TLB_CONFIG_T *unpacked, uint8_t packed0);
#define V3D_TLB_CONFIG_PACKED_SIZE 1
typedef struct
{
   v3d_qpu_bcond_t bcond;
   v3d_qpu_msfign_t msfign;
   bool ulr;
   int32_t rel_i_addr;
   int32_t rel_u_addr;
} V3D_UNIF_BRANCH_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_unif_branch(const V3D_UNIF_BRANCH_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_unif_branch(V3D_UNIF_BRANCH_T *unpacked, uint32_t packed0);
#define V3D_UNIF_BRANCH_PACKED_SIZE 4
#if !V3D_HAS_NEW_TMU_CFG
typedef v3d_tmu_swizzle_t V3D_TMU_INDIRECT_SWIZZLES_T[4];
typedef struct
{
   int32_t min_lod;
   int32_t max_lod;
   int32_t fixed_bias;
   uint32_t base_level;
   uint32_t samp_num;
   v3d_tmu_output_type_t output_type;
} V3D_TMU_INDIRECT_U_NOT_CHILD_IMAGE_T;
typedef struct
{
   uint32_t cwidth;
   uint32_t cheight;
   uint32_t cxoff;
   uint32_t cyoff;
} V3D_TMU_INDIRECT_U_CHILD_IMAGE_T;
typedef union
{
   V3D_TMU_INDIRECT_U_NOT_CHILD_IMAGE_T not_child_image;
   V3D_TMU_INDIRECT_U_CHILD_IMAGE_T child_image;
} V3D_TMU_INDIRECT_U_T;
typedef struct
{
   v3d_tmu_filter_t filter;
   bool border_rrra;
   v3d_addr_t base;
   uint32_t arr_str;
   uint32_t width;
   uint32_t height;
   uint32_t depth;
   v3d_tmu_type_t ttype;
   bool srgb;
   bool ahdr;
   v3d_compare_func_t compare_func;
   V3D_TMU_INDIRECT_SWIZZLES_T swizzles;
   bool flipx;
   bool flipy;
   bool etcflip;
   bool swapst;
   uint64_t bcolour;
   V3D_TMU_INDIRECT_U_T u;
   uint32_t ub_pad;
   bool ub_xor;
   bool uif_top;
   bool xor_dis;
} V3D_TMU_INDIRECT_T;
EXPORT_FOR_CLIF_CC void v3d_pack_tmu_indirect_not_child_image(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_pack_tmu_indirect_child_image(uint32_t *packed, const V3D_TMU_INDIRECT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_indirect_not_child_image(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_indirect_child_image(V3D_TMU_INDIRECT_T *unpacked, const uint32_t *packed);
#define V3D_TMU_INDIRECT_PACKED_SIZE 32
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef v3d_tmu_swizzle_t V3D_TMU_TEX_STATE_SWIZZLES_T[4];
typedef struct
{
   bool flipx;
   bool flipy;
   bool swapst;
   bool srgb;
   bool ahdr;
   bool reverse_std_bcol;
   v3d_addr_t l0_addr;
   uint32_t arr_str;
   uint32_t width;
   uint32_t height;
   uint32_t depth;
   v3d_tmu_type_t type;
   bool extended;
   V3D_TMU_TEX_STATE_SWIZZLES_T swizzles;
   uint32_t max_level;
   uint32_t base_level;
} V3D_TMU_TEX_STATE_T;
EXPORT_FOR_CLIF_CC void v3d_pack_tmu_tex_state(uint8_t *packed, const V3D_TMU_TEX_STATE_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_tex_state(V3D_TMU_TEX_STATE_T *unpacked, const uint8_t *packed);
#define V3D_TMU_TEX_STATE_PACKED_SIZE 16
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef struct
{
   uint32_t ub_pad;
   bool ub_xor;
   bool uif_top;
   bool xor_dis;
} V3D_TMU_TEX_EXTENSION_T;
EXPORT_FOR_CLIF_CC void v3d_pack_tmu_tex_extension(uint8_t *packed, const V3D_TMU_TEX_EXTENSION_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_tex_extension(V3D_TMU_TEX_EXTENSION_T *unpacked, const uint8_t *packed);
#define V3D_TMU_TEX_EXTENSION_PACKED_SIZE 8
#endif
#if V3D_HAS_NEW_TMU_CFG
typedef struct
{
   v3d_tmu_filter_t filter;
   v3d_compare_func_t compare_func;
   bool srgb_override;
   uint32_t min_lod;
   uint32_t max_lod;
   int32_t fixed_bias;
   v3d_tmu_wrap_t wrap_s;
   v3d_tmu_wrap_t wrap_t;
   v3d_tmu_wrap_t wrap_r;
   v3d_tmu_std_bcol_t std_bcol;
} V3D_TMU_SAMPLER_T;
EXPORT_FOR_CLIF_CC void v3d_pack_tmu_sampler(uint8_t *packed, const V3D_TMU_SAMPLER_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tmu_sampler(V3D_TMU_SAMPLER_T *unpacked, const uint8_t *packed);
#define V3D_TMU_SAMPLER_PACKED_SIZE 8
#endif
typedef struct
{
   uint32_t first;
   uint32_t count;
   uint32_t buffer;
} V3D_TF_SPEC_T;
EXPORT_FOR_CLIF_CC void v3d_pack_tf_spec(uint8_t *packed, const V3D_TF_SPEC_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tf_spec(V3D_TF_SPEC_T *unpacked, const uint8_t *packed);
#define V3D_TF_SPEC_PACKED_SIZE 2
typedef uint32_t V3D_BIN_TILE_STATE_PREV_INDICES_T[3];
typedef struct
{
   v3d_addr_t cl_pos;
   V3D_BIN_TILE_STATE_PREV_INDICES_T prev_indices;
   bool curr_xy_mode;
   bool prev_reverse_flag;
   uint32_t ctr;
   v3d_tile_alloc_block_size_t blksize;
   bool halfwrt;
} V3D_BIN_TILE_STATE_T;
EXPORT_FOR_CLIF_CC void v3d_pack_bin_tile_state(uint32_t *packed, const V3D_BIN_TILE_STATE_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_bin_tile_state(V3D_BIN_TILE_STATE_T *unpacked, const uint32_t *packed);
#define V3D_BIN_TILE_STATE_PACKED_SIZE 64
typedef struct
{
   uint32_t num_indices;
   uint32_t num_instances;
   uint32_t index_of_first_index;
   int32_t base_vertex;
   uint32_t base_instance;
} V3D_INDIRECT_INDEXED_RECORD_T;
EXPORT_FOR_CLIF_CC void v3d_pack_indirect_indexed_record(uint32_t *packed, const V3D_INDIRECT_INDEXED_RECORD_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_indirect_indexed_record(V3D_INDIRECT_INDEXED_RECORD_T *unpacked, const uint32_t *packed);
#define V3D_INDIRECT_INDEXED_RECORD_PACKED_SIZE 20
typedef struct
{
   uint32_t num_vertices;
   uint32_t num_instances;
   uint32_t first_index;
   uint32_t base_instance;
} V3D_INDIRECT_ARRAYS_RECORD_T;
EXPORT_FOR_CLIF_CC void v3d_pack_indirect_arrays_record(uint32_t *packed, const V3D_INDIRECT_ARRAYS_RECORD_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_indirect_arrays_record(V3D_INDIRECT_ARRAYS_RECORD_T *unpacked, const uint32_t *packed);
#define V3D_INDIRECT_ARRAYS_RECORD_PACKED_SIZE 16
typedef float V3D_CLIP_RECORD_VCOEFF_T[3];
typedef struct
{
   int32_t xs;
   int32_t ys;
   float zs;
   float rw;
   V3D_CLIP_RECORD_VCOEFF_T vcoeff;
} V3D_CLIP_RECORD_T;
EXPORT_FOR_CLIF_CC void v3d_pack_clip_record(uint32_t *packed, const V3D_CLIP_RECORD_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_clip_record(V3D_CLIP_RECORD_T *unpacked, const uint32_t *packed);
#define V3D_CLIP_RECORD_PACKED_SIZE 32
typedef struct
{
   v3d_tile_alloc_block_size_t next_block_size;
   bool more;
   v3d_addr_t next_block_addr;
} V3D_AUTOCHAIN_LINK_T;
EXPORT_FOR_CLIF_CC void v3d_pack_autochain_link(uint8_t *packed, const V3D_AUTOCHAIN_LINK_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_autochain_link(V3D_AUTOCHAIN_LINK_T *unpacked, const uint8_t *packed);
#define V3D_AUTOCHAIN_LINK_PACKED_SIZE 4
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID8_T;
typedef struct
{
   uint32_t iid;
} V3D_CL_COMPR_IND_COMMON_IID32_T;
typedef struct
{
   int32_t rel_addr;
} V3D_CL_COMPR_IND_COMMON_REL_BRANCH_T;
typedef struct
{
   v3d_addr_t addr;
} V3D_CL_COMPR_IND_COMMON_BRANCH_T;
typedef union
{
   V3D_CL_COMPR_IND_COMMON_IID8_T iid8;
   V3D_CL_COMPR_IND_COMMON_IID32_T iid32;
   V3D_CL_COMPR_IND_COMMON_REL_BRANCH_T rel_branch;
   V3D_CL_COMPR_IND_COMMON_BRANCH_T branch;
} V3D_CL_COMPR_IND_COMMON_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_COMMON_U_T u;
} V3D_CL_COMPR_IND_COMMON_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_ind_common(uint8_t *packed, const V3D_CL_COMPR_IND_COMMON_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_common(V3D_CL_COMPR_IND_COMMON_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_IND_COMMON_MAX_PACKED_SIZE 5
uint32_t v3d_cl_compr_ind_common_packed_size(v3d_cl_compr_type_t type);
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t diff2;
} V3D_CL_COMPR_IND_TRI_C0_T;
typedef struct
{
   int32_t diff0;
   int32_t diff1;
   int32_t diff2;
} V3D_CL_COMPR_IND_TRI_C1_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
} V3D_CL_COMPR_IND_TRI_C2_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
} V3D_CL_COMPR_IND_TRI_C3_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_TRI_C4_T;
typedef struct
{
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_TRI_C5_T;
typedef union
{
   V3D_CL_COMPR_IND_TRI_C0_T c0;
   V3D_CL_COMPR_IND_TRI_C1_T c1;
   V3D_CL_COMPR_IND_TRI_C2_T c2;
   V3D_CL_COMPR_IND_TRI_C3_T c3;
   V3D_CL_COMPR_IND_TRI_C4_T c4;
   V3D_CL_COMPR_IND_TRI_C5_T c5;
} V3D_CL_COMPR_IND_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_TRI_U_T u;
} V3D_CL_COMPR_IND_TRI_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_ind_tri(uint8_t *packed, const V3D_CL_COMPR_IND_TRI_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_tri(V3D_CL_COMPR_IND_TRI_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_IND_TRI_MAX_PACKED_SIZE 10
uint32_t v3d_cl_compr_ind_tri_packed_size(v3d_cl_compr_type_t type);
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t diff2;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C0_T;
typedef struct
{
   int32_t diff0;
   uint32_t prov_vtx;
   int32_t diff1;
   int32_t diff2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C1_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C2_T;
typedef struct
{
   int32_t diff1;
   int32_t diff2;
   uint32_t idx0;
   uint32_t prov_vtx;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C3_T;
typedef struct
{
   uint32_t prov_vtx;
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C4_T;
typedef struct
{
   uint32_t prov_vtx;
   uint32_t idx0;
   uint32_t idx1;
   uint32_t idx2;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_C5_T;
typedef union
{
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C0_T c0;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C1_T c1;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C2_T c2;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C3_T c3;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C4_T c4;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_C5_T c5;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_D3DPVSF_TRI_U_T u;
} V3D_CL_COMPR_IND_D3DPVSF_TRI_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_ind_d3dpvsf_tri(uint8_t *packed, const V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_d3dpvsf_tri(V3D_CL_COMPR_IND_D3DPVSF_TRI_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_IND_D3DPVSF_TRI_MAX_PACKED_SIZE 10
uint32_t v3d_cl_compr_ind_d3dpvsf_tri_packed_size(v3d_cl_compr_type_t type);
typedef struct
{
   v3d_line_ind_reuse_t reuse;
   int32_t diff1;
} V3D_CL_COMPR_IND_LINE_C0_T;
typedef struct
{
   int32_t diff0;
   int32_t diff1;
   bool reversed;
} V3D_CL_COMPR_IND_LINE_C1_T;
typedef struct
{
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C2_T;
typedef struct
{
   bool reversed;
   int32_t diff1;
   uint32_t idx0;
} V3D_CL_COMPR_IND_LINE_C3_T;
typedef struct
{
   bool reversed;
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C4_T;
typedef struct
{
   bool reversed;
   uint32_t idx0;
   uint32_t idx1;
} V3D_CL_COMPR_IND_LINE_C5_T;
typedef union
{
   V3D_CL_COMPR_IND_LINE_C0_T c0;
   V3D_CL_COMPR_IND_LINE_C1_T c1;
   V3D_CL_COMPR_IND_LINE_C2_T c2;
   V3D_CL_COMPR_IND_LINE_C3_T c3;
   V3D_CL_COMPR_IND_LINE_C4_T c4;
   V3D_CL_COMPR_IND_LINE_C5_T c5;
} V3D_CL_COMPR_IND_LINE_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_LINE_U_T u;
} V3D_CL_COMPR_IND_LINE_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_ind_line(uint8_t *packed, const V3D_CL_COMPR_IND_LINE_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_line(V3D_CL_COMPR_IND_LINE_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_IND_LINE_MAX_PACKED_SIZE 7
uint32_t v3d_cl_compr_ind_line_packed_size(v3d_cl_compr_type_t type);
typedef struct
{
   int32_t diff;
} V3D_CL_COMPR_IND_POINT_C0_T;
typedef struct
{
   int32_t diff;
   bool reversed;
} V3D_CL_COMPR_IND_POINT_C1_T;
typedef struct
{
   int32_t diff;
   uint32_t count;
   bool reversed;
} V3D_CL_COMPR_IND_POINT_C2_T;
typedef struct
{
   bool reversed;
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C4_T;
typedef struct
{
   bool reversed;
   uint32_t idx;
} V3D_CL_COMPR_IND_POINT_C5_T;
typedef union
{
   V3D_CL_COMPR_IND_POINT_C0_T c0;
   V3D_CL_COMPR_IND_POINT_C1_T c1;
   V3D_CL_COMPR_IND_POINT_C2_T c2;
   V3D_CL_COMPR_IND_POINT_C4_T c4;
   V3D_CL_COMPR_IND_POINT_C5_T c5;
} V3D_CL_COMPR_IND_POINT_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_IND_POINT_U_T u;
} V3D_CL_COMPR_IND_POINT_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_ind_point(uint8_t *packed, const V3D_CL_COMPR_IND_POINT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_ind_point(V3D_CL_COMPR_IND_POINT_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_IND_POINT_MAX_PACKED_SIZE 4
uint32_t v3d_cl_compr_ind_point_packed_size(v3d_cl_compr_type_t type);
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C0_T;
typedef struct
{
   v3d_tri_ind_reuse_t reuse;
   int32_t dx2;
   int32_t dy2;
} V3D_CL_COMPR_XY_TRI_C1_T;
typedef struct
{
   int32_t dx1;
   int32_t dy1;
   int32_t dx2;
   int32_t dy2;
   uint32_t x0;
   uint32_t y0;
} V3D_CL_COMPR_XY_TRI_C2_T;
typedef struct
{
   uint32_t x0;
   uint32_t y0;
   uint32_t x1;
   uint32_t y1;
   uint32_t x2;
   uint32_t y2;
} V3D_CL_COMPR_XY_TRI_C3_T;
typedef struct
{
   int32_t rel_addr;
} V3D_CL_COMPR_XY_TRI_REL_BRANCH_T;
typedef union
{
   V3D_CL_COMPR_XY_TRI_C0_T c0;
   V3D_CL_COMPR_XY_TRI_C1_T c1;
   V3D_CL_COMPR_XY_TRI_C2_T c2;
   V3D_CL_COMPR_XY_TRI_C3_T c3;
   V3D_CL_COMPR_XY_TRI_REL_BRANCH_T rel_branch;
} V3D_CL_COMPR_XY_TRI_U_T;
typedef struct
{
   v3d_cl_compr_type_t type;
   V3D_CL_COMPR_XY_TRI_U_T u;
} V3D_CL_COMPR_XY_TRI_T;
EXPORT_FOR_CLIF_CC void v3d_pack_cl_compr_xy_tri(uint8_t *packed, const V3D_CL_COMPR_XY_TRI_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_cl_compr_xy_tri(V3D_CL_COMPR_XY_TRI_T *unpacked, const uint8_t *packed);
#define V3D_CL_COMPR_XY_TRI_MAX_PACKED_SIZE 13
uint32_t v3d_cl_compr_xy_tri_packed_size(v3d_cl_compr_type_t type);
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max_a;
   uint32_t min_a;
   uint32_t max_b;
   uint32_t min_b;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_WEIGHTS_T weights;
   uint32_t max_a;
   uint32_t min_a;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_THREE_PLANE_BA_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_THREE_PLANE_BA_U_T u;
} V3D_BSTC_BLOCK_THREE_PLANE_BA_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_WEIGHTS_T weights;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_U_T u;
} V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_T;
typedef V3D_BSTC_BLOCK_THREE_PLANE_RG_ELEM_T V3D_BSTC_BLOCK_THREE_PLANE_RG_T[2];
typedef struct
{
   V3D_BSTC_BLOCK_THREE_PLANE_BA_T ba;
   V3D_BSTC_BLOCK_THREE_PLANE_RG_T rg;
} V3D_BSTC_BLOCK_THREE_PLANE_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_A_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_A_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_FOUR_PLANE_A_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_WEIGHTS_T weights;
   uint32_t max;
   uint32_t min;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_T;
typedef uint32_t V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_WEIGHTS_T[16];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_WEIGHTS_T weights;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_T;
typedef union
{
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_NORMAL_RANGE_T normal_range;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_MAX_RANGE_T max_range;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_U_T;
typedef struct
{
   bool max_range;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_U_T u;
} V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_T;
typedef V3D_BSTC_BLOCK_FOUR_PLANE_RGB_ELEM_T V3D_BSTC_BLOCK_FOUR_PLANE_RGB_T[3];
typedef struct
{
   V3D_BSTC_BLOCK_FOUR_PLANE_A_T a;
   V3D_BSTC_BLOCK_FOUR_PLANE_RGB_T rgb;
} V3D_BSTC_BLOCK_FOUR_PLANE_T;
typedef union
{
   V3D_BSTC_BLOCK_THREE_PLANE_T three_plane;
   V3D_BSTC_BLOCK_FOUR_PLANE_T four_plane;
} V3D_BSTC_BLOCK_U_T;
typedef struct
{
   bool four_plane;
   V3D_BSTC_BLOCK_U_T u;
} V3D_BSTC_BLOCK_T;
EXPORT_FOR_CLIF_CC void v3d_pack_bstc_block(uint8_t *packed, const V3D_BSTC_BLOCK_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_bstc_block(V3D_BSTC_BLOCK_T *unpacked, const uint8_t *packed);
#define V3D_BSTC_BLOCK_PACKED_SIZE 32
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_hub_ident0(void);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident0(uint32_t packed0);
#define V3D_HUB_IDENT0_PACKED_SIZE 4
typedef struct
{
   uint32_t v3d_tech_version;
   uint32_t v3d_revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_l3c;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
   uint32_t l3c_associativity;
   uint32_t l3c_banks;
} V3D_HUB_IDENT1_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_hub_ident1(const V3D_HUB_IDENT1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident1(V3D_HUB_IDENT1_T *unpacked, uint32_t packed0);
#define V3D_HUB_IDENT1_PACKED_SIZE 4
typedef struct
{
   uint32_t l3c_size_in_multiples_of_64kb;
   bool has_mmu;
} V3D_HUB_IDENT2_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_hub_ident2(const V3D_HUB_IDENT2_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident2(V3D_HUB_IDENT2_T *unpacked, uint32_t packed0);
#define V3D_HUB_IDENT2_PACKED_SIZE 4
typedef struct
{
   v3d_ip_recipient_t ip_recipient;
   uint32_t ip_recipient_revision;
} V3D_HUB_IDENT3_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_hub_ident3(const V3D_HUB_IDENT3_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident3(V3D_HUB_IDENT3_T *unpacked, uint32_t packed0);
#define V3D_HUB_IDENT3_PACKED_SIZE 4
typedef struct
{
   uint32_t v3d_tech_version;
   uint32_t v3d_revision;
   uint32_t num_cores;
   uint32_t num_hosts;
   bool has_l3c;
   bool has_tfu;
   bool has_tsy;
   bool has_mso;
   uint32_t l3c_associativity;
   uint32_t l3c_banks;
   uint32_t l3c_size_in_multiples_of_64kb;
   bool has_mmu;
   v3d_ip_recipient_t ip_recipient;
   uint32_t ip_recipient_revision;
} V3D_HUB_IDENT_T;
EXPORT_FOR_CLIF_CC void v3d_pack_hub_ident(uint32_t *packed, const V3D_HUB_IDENT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_ident(V3D_HUB_IDENT_T *unpacked, uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3);
#define V3D_HUB_IDENT_PACKED_SIZE 16
typedef struct
{
   uint32_t v3d_tech_version;
} V3D_IDENT0_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ident0(const V3D_IDENT0_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ident0(V3D_IDENT0_T *unpacked, uint32_t packed0);
#define V3D_IDENT0_PACKED_SIZE 4
typedef struct
{
   uint32_t v3d_revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
} V3D_IDENT1_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ident1(const V3D_IDENT1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ident1(V3D_IDENT1_T *unpacked, uint32_t packed0);
#define V3D_IDENT1_PACKED_SIZE 4
typedef struct
{
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
} V3D_IDENT2_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ident2(const V3D_IDENT2_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ident2(V3D_IDENT2_T *unpacked, uint32_t packed0);
#define V3D_IDENT2_PACKED_SIZE 4
typedef struct
{
   v3d_ip_recipient_t ip_recipient;
   uint32_t ip_recipient_revision;
} V3D_IDENT3_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ident3(const V3D_IDENT3_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ident3(V3D_IDENT3_T *unpacked, uint32_t packed0);
#define V3D_IDENT3_PACKED_SIZE 4
typedef struct
{
   uint32_t v3d_tech_version;
   uint32_t v3d_revision;
   uint32_t num_slices;
   uint32_t num_qpus_per_slice;
   uint32_t num_tmus;
   uint32_t vpm_size_in_multiples_of_8kb;
   v3d_vri_size_t vri_size;
   v3d_tlb_size_t tlb_size;
   bool tlb_double_buf_support;
   v3d_iuc_size_t icache_size;
   v3d_iuc_size_t ucache_size;
   bool bigend;
   bool endswp_support;
   bool axi_rw_reorder_support;
   bool no_earlyz_support;
   uint32_t core_index;
   bool bcg_interrupt_control;
   bool has_astc;
   v3d_ip_recipient_t ip_recipient;
   uint32_t ip_recipient_revision;
} V3D_IDENT_T;
EXPORT_FOR_CLIF_CC void v3d_pack_ident(uint32_t *packed, const V3D_IDENT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ident(V3D_IDENT_T *unpacked, uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3);
#define V3D_IDENT_PACKED_SIZE 16
typedef struct
{
   bool tfu_fifo_free_over_threshold;
   bool tfu_conv_complete;
   bool mso_obj_reached_state;
   bool mmu_cap;
   bool mmu_pti;
   bool mmu_wrv;
} V3D_HUB_INTR_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_hub_intr(const V3D_HUB_INTR_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_hub_intr(V3D_HUB_INTR_T *unpacked, uint32_t packed0);
#define V3D_HUB_INTR_PACKED_SIZE 4
typedef bool V3D_INTR_QPU_T[16];
typedef struct
{
   bool render_done;
   bool bin_done;
   bool outomem;
   bool spilluse;
   bool trfb;
   bool gmpv;
   V3D_INTR_QPU_T qpu;
} V3D_INTR_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_intr(const V3D_INTR_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_intr(V3D_INTR_T *unpacked, uint32_t packed0);
#define V3D_INTR_PACKED_SIZE 4
typedef struct
{
   bool ctooberr;
   bool cterr;
   v3d_ctsubsrun_t ctsubsrun;
   uint32_t ctqdep;
   uint32_t ctrtsd;
   uint32_t ctsema;
   bool ctrsta;
} V3D_CT0CS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ct0cs(const V3D_CT0CS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct0cs(V3D_CT0CS_T *unpacked, uint32_t packed0);
#define V3D_CT0CS_PACKED_SIZE 4
typedef struct
{
   bool ctetstop;
   bool cterr;
   v3d_ctsubsrun_t ctsubsrun;
   uint32_t ctqdep;
   uint32_t ctrtsd;
   uint32_t ctsema;
   bool ctrsta;
} V3D_CT1CS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ct1cs(const V3D_CT1CS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1cs(V3D_CT1CS_T *unpacked, uint32_t packed0);
#define V3D_CT1CS_PACKED_SIZE 4
typedef struct
{
   bool disable_multicore;
   bool ets_flush;
   uint32_t max_tiles_in_flight;
   uint32_t mcs_mask_set;
   uint32_t mcs_frame_id;
} V3D_CT1CFG_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ct1cfg(const V3D_CT1CFG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1cfg(V3D_CT1CFG_T *unpacked, uint32_t packed0);
#define V3D_CT1CFG_PACKED_SIZE 4
typedef struct
{
   uint32_t tiles_completed_in_curr_st;
   uint32_t supertiles_completed;
   uint32_t tiles_in_flight;
} V3D_CT1TILECT_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ct1tilect(const V3D_CT1TILECT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1tilect(V3D_CT1TILECT_T *unpacked, uint32_t packed0);
#define V3D_CT1TILECT_PACKED_SIZE 4
typedef struct
{
   uint32_t tiles_completed_in_curr_st;
   uint32_t supertiles_completed;
   uint32_t mcs_mask_set;
   uint32_t mcs_frame_id;
   bool etstop;
} V3D_CT1PTCT_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_ct1ptct(const V3D_CT1PTCT_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_ct1ptct(V3D_CT1PTCT_T *unpacked, uint32_t packed0);
#define V3D_CT1PTCT_PACKED_SIZE 4
typedef struct
{
   bool bmactive;
   bool rmactive;
   bool bmoom;
} V3D_PCS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_pcs(const V3D_PCS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_pcs(V3D_PCS_T *unpacked, uint32_t packed0);
#define V3D_PCS_PACKED_SIZE 4
typedef struct
{
   bool busy;
   uint32_t nfree;
   uint32_t cvtct;
   bool tfurst;
} V3D_TFUCS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfucs(const V3D_TFUCS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucs(V3D_TFUCS_T *unpacked, uint32_t packed0);
#define V3D_TFUCS_PACKED_SIZE 4
typedef struct
{
   uint32_t throttle;
   bool crc;
   bool crcchain;
   uint32_t fintthr;
} V3D_TFUSU_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfusu(const V3D_TFUSU_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfusu(V3D_TFUSU_T *unpacked, uint32_t packed0);
#define V3D_TFUSU_PACKED_SIZE 4
typedef struct
{
   bool ioc;
   v3d_tfu_rgbord_t rgbord;
   bool flipy;
   bool srgb;
   uint32_t nummm;
   v3d_tfu_type_t ttype;
   v3d_tfu_iformat_t iformat;
   uint32_t opad;
} V3D_TFUICFG_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfuicfg(const V3D_TFUICFG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuicfg(V3D_TFUICFG_T *unpacked, uint32_t packed0);
#define V3D_TFUICFG_PACKED_SIZE 4
typedef struct
{
   uint32_t stride0;
   uint32_t stride1;
} V3D_TFUIIS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfuiis(const V3D_TFUIIS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuiis(V3D_TFUIIS_T *unpacked, uint32_t packed0);
#define V3D_TFUIIS_PACKED_SIZE 4
typedef struct
{
   bool dimtw;
   v3d_tfu_oformat_t oformat;
   v3d_addr_t oaddr;
} V3D_TFUIOA_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfuioa(const V3D_TFUIOA_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuioa(V3D_TFUIOA_T *unpacked, uint32_t packed0);
#define V3D_TFUIOA_PACKED_SIZE 4
typedef struct
{
   uint32_t xsize;
   uint32_t ysize;
} V3D_TFUIOS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfuios(const V3D_TFUIOS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfuios(V3D_TFUIOS_T *unpacked, uint32_t packed0);
#define V3D_TFUIOS_PACKED_SIZE 4
typedef struct
{
   uint32_t ay;
   uint32_t arc;
   bool usecoef;
} V3D_TFUCOEF0_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfucoef0(const V3D_TFUCOEF0_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef0(V3D_TFUCOEF0_T *unpacked, uint32_t packed0);
#define V3D_TFUCOEF0_PACKED_SIZE 4
typedef struct
{
   uint32_t agc;
   uint32_t abc;
} V3D_TFUCOEF1_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfucoef1(const V3D_TFUCOEF1_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef1(V3D_TFUCOEF1_T *unpacked, uint32_t packed0);
#define V3D_TFUCOEF1_PACKED_SIZE 4
typedef struct
{
   uint32_t agr;
   uint32_t arr;
} V3D_TFUCOEF2_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfucoef2(const V3D_TFUCOEF2_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef2(V3D_TFUCOEF2_T *unpacked, uint32_t packed0);
#define V3D_TFUCOEF2_PACKED_SIZE 4
typedef struct
{
   uint32_t abb;
   uint32_t agb;
} V3D_TFUCOEF3_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_tfucoef3(const V3D_TFUCOEF3_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_tfucoef3(V3D_TFUCOEF3_T *unpacked, uint32_t packed0);
#define V3D_TFUCOEF3_PACKED_SIZE 4
typedef struct
{
   uint32_t num_queued;
   bool queue_error;
   uint32_t num_requests;
   uint32_t num_completed;
} V3D_SRQCS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_srqcs(const V3D_SRQCS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_srqcs(V3D_SRQCS_T *unpacked, uint32_t packed0);
#define V3D_SRQCS_PACKED_SIZE 4
typedef struct
{
   uint32_t page_size;
   uint32_t num_banks;
   uint32_t xor_addr;
} V3D_UIFCFG_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_uifcfg(const V3D_UIFCFG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_uifcfg(V3D_UIFCFG_T *unpacked, uint32_t packed0);
#define V3D_UIFCFG_PACKED_SIZE 4
#if !V3D_HAS_NEW_TMU_CFG
typedef struct
{
   bool ovrtmuout;
} V3D_MISCCFG_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_misccfg(const V3D_MISCCFG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_misccfg(V3D_MISCCFG_T *unpacked, uint32_t packed0);
#define V3D_MISCCFG_PACKED_SIZE 4
#endif
typedef struct
{
   bool enable;
   bool stats_enable;
   bool tlb_clear;
   bool stats_clear;
   bool tlb_clearing;
   bool wrv_exception;
   bool wrv_interrupt;
   bool wrv_abort;
   bool wrv;
   bool pti_enable;
   bool pti_exception;
   bool pti_interrupt;
   bool pti_abort;
   bool pti;
   bool capex_exception;
   bool capex_interrupt;
   bool capex_abort;
   bool capex;
} V3D_MMU_CTRL_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_mmu_ctrl(const V3D_MMU_CTRL_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_ctrl(V3D_MMU_CTRL_T *unpacked, uint32_t packed0);
#define V3D_MMU_CTRL_PACKED_SIZE 4
typedef struct
{
   uint32_t mpage;
   bool enable;
} V3D_MMU_ADDR_CAP_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_mmu_addr_cap(const V3D_MMU_ADDR_CAP_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_addr_cap(V3D_MMU_ADDR_CAP_T *unpacked, uint32_t packed0);
#define V3D_MMU_ADDR_CAP_PACKED_SIZE 4
typedef struct
{
   uint32_t mpage;
   bool enable;
} V3D_MMU_BYPASS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_mmu_bypass(const V3D_MMU_BYPASS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_bypass(V3D_MMU_BYPASS_T *unpacked, uint32_t packed0);
#define V3D_MMU_BYPASS_PACKED_SIZE 4
typedef struct
{
   uint32_t page;
   bool enable;
} V3D_MMU_ILLEGAL_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_mmu_illegal(const V3D_MMU_ILLEGAL_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmu_illegal(V3D_MMU_ILLEGAL_T *unpacked, uint32_t packed0);
#define V3D_MMU_ILLEGAL_PACKED_SIZE 4
typedef struct
{
   bool enable;
   bool flush;
   bool flushing;
   bool clear_stats;
   uint32_t cache_size;
} V3D_MMUC_CONTROL_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_mmuc_control(const V3D_MMUC_CONTROL_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_mmuc_control(V3D_MMUC_CONTROL_T *unpacked, uint32_t packed0);
#define V3D_MMUC_CONTROL_PACKED_SIZE 4
typedef struct
{
   bool enable;
   bool stop_request;
   bool page_cross_detect_enable;
   bool long_burst_detect_enable;
} V3D_GMP_CFG_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_gmp_cfg(const V3D_GMP_CFG_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_cfg(V3D_GMP_CFG_T *unpacked, uint32_t packed0);
#define V3D_GMP_CFG_PACKED_SIZE 4
typedef struct
{
   bool violation;
   bool invalid_table;
   bool counter_overflow;
   bool cfg_update;
   bool read_active;
   bool write_active;
   uint32_t read_count;
   uint32_t write_count;
   bool reset;
} V3D_GMP_STATUS_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_gmp_status(const V3D_GMP_STATUS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_gmp_status(V3D_GMP_STATUS_T *unpacked, uint32_t packed0);
#define V3D_GMP_STATUS_PACKED_SIZE 4
typedef struct
{
   uint32_t reg_data;
   uint32_t reg_addr;
   bool write;
} V3D_UMR_AXI_CONTROL_T;
EXPORT_FOR_CLIF_CC uint32_t v3d_pack_umr_axi_control(const V3D_UMR_AXI_CONTROL_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_control(V3D_UMR_AXI_CONTROL_T *unpacked, uint32_t packed0);
#define V3D_UMR_AXI_CONTROL_PACKED_SIZE 4
typedef struct
{
   uint32_t axi_len;
   uint32_t axi_size;
} V3D_UMR_AXI_BURST_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_burst(const V3D_UMR_AXI_BURST_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_burst(V3D_UMR_AXI_BURST_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_BURST_PACKED_SIZE 2
typedef struct
{
   uint32_t axi_id;
   uint32_t axi_prot;
} V3D_UMR_AXI_ID_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_id(const V3D_UMR_AXI_ID_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_id(V3D_UMR_AXI_ID_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_ID_PACKED_SIZE 2
typedef struct
{
   bool write;
   bool read;
   bool rd_fifo_almost_full;
   bool wr_fifo_almost_empty;
   uint32_t fpga_num;
   bool master_error;
   bool axi_idle;
} V3D_UMR_AXI_STATUS_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_status(const V3D_UMR_AXI_STATUS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_status(V3D_UMR_AXI_STATUS_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_STATUS_PACKED_SIZE 2
typedef struct
{
   uint32_t axi_response;
   bool axi_timeout;
   bool rd_fifo_missed;
   bool rd_fifo_rd;
   bool rd_fifo_wr;
   bool wr_fifo_rd;
   bool wr_fifo_wr;
   bool wr_data_left;
   bool wr_no_data;
   bool rd_data_left;
   bool start_when_busy;
   bool start_error;
   bool fifo_error;
   bool axi_error;
} V3D_UMR_AXI_ERROR_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_error(const V3D_UMR_AXI_ERROR_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_error(V3D_UMR_AXI_ERROR_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_ERROR_PACKED_SIZE 2
typedef struct
{
   bool read_req;
   bool write_req;
   bool clear_error;
   bool fifo_reset;
} V3D_UMR_AXI_FLAGS_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_flags(const V3D_UMR_AXI_FLAGS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_flags(V3D_UMR_AXI_FLAGS_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_FLAGS_PACKED_SIZE 2
typedef struct
{
   bool wr_full;
   bool wr_empty;
   bool wr_almost_empty;
   bool wr_data_left;
   bool rd_full;
   bool rd_empty;
   bool rd_almost_full;
   bool rd_data_left;
   bool resetting;
} V3D_UMR_AXI_FIFO_FLAGS_T;
EXPORT_FOR_CLIF_CC uint16_t v3d_pack_umr_axi_fifo_flags(const V3D_UMR_AXI_FIFO_FLAGS_T *unpacked);
EXPORT_FOR_CLIF_CC void v3d_unpack_umr_axi_fifo_flags(V3D_UMR_AXI_FIFO_FLAGS_T *unpacked, uint16_t packed0);
#define V3D_UMR_AXI_FIFO_FLAGS_PACKED_SIZE 2
extern void v3d_print_shadrec_gl_main(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_shadrec_gl_geom(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_shadrec_gl_tess(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_shadrec_gl_tess_or_geom(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_shadrec_gl_attr(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_shadrec_vg(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_unif_raw(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_unif_addr(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param1_cfg0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if !V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param1_cfg1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param0(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param1(uint32_t packed0, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_param2(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_tmu_direct_config(uint8_t packed0, struct v3d_printer *printer);
extern void v3d_print_tsy_config(uint8_t packed0, struct v3d_printer *printer);
extern void v3d_print_tlb_config(uint8_t packed0, struct v3d_printer *printer);
extern void v3d_print_unif_branch(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_indirect(const uint32_t *packed, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_tex_state(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_tex_extension(const uint8_t *packed, struct v3d_printer *printer);
#endif
#if V3D_HAS_NEW_TMU_CFG
extern void v3d_print_tmu_sampler(const uint8_t *packed, struct v3d_printer *printer);
#endif
extern void v3d_print_tf_spec(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_bin_tile_state(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_indirect_indexed_record(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_indirect_arrays_record(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_clip_record(const uint32_t *packed, struct v3d_printer *printer);
extern void v3d_print_autochain_link(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_common(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_tri(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_d3dpvsf_tri(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_line(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_ind_point(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_cl_compr_xy_tri(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_bstc_block(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_print_hub_ident0(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_hub_ident1(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_hub_ident2(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_hub_ident3(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_hub_ident(uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3, struct v3d_printer *printer);
extern void v3d_print_ident0(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ident1(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ident2(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ident3(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ident(uint32_t packed0, uint32_t packed1, uint32_t packed2, uint32_t packed3, struct v3d_printer *printer);
extern void v3d_print_hub_intr(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_intr(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct0cs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct1cs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct1cfg(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct1tilect(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_ct1ptct(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_pcs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfusu(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuicfg(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuiis(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuioa(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfuios(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef0(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef1(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef2(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_tfucoef3(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_srqcs(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_uifcfg(uint32_t packed0, struct v3d_printer *printer);
#if !V3D_HAS_NEW_TMU_CFG
extern void v3d_print_misccfg(uint32_t packed0, struct v3d_printer *printer);
#endif
extern void v3d_print_mmu_ctrl(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_addr_cap(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_bypass(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmu_illegal(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_mmuc_control(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_gmp_cfg(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_gmp_status(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_control(uint32_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_burst(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_id(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_status(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_error(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_flags(uint16_t packed0, struct v3d_printer *printer);
extern void v3d_print_umr_axi_fifo_flags(uint16_t packed0, struct v3d_printer *printer);
#define V3D_CL_HALT_SIZE 1
#define V3D_CL_NOP_SIZE 1
#define V3D_CL_FLUSH_SIZE 1
#define V3D_CL_FLUSH_ALL_STATE_SIZE 1
#define V3D_CL_START_TILE_BINNING_SIZE 1
#define V3D_CL_INCR_SEMAPHORE_SIZE 1
#define V3D_CL_WAIT_SEMAPHORE_SIZE 1
#define V3D_CL_WAIT_PREV_FRAME_SIZE 1
#define V3D_CL_ENABLE_Z_ONLY_SIZE 1
#define V3D_CL_DISABLE_Z_ONLY_SIZE 1
#define V3D_CL_END_Z_ONLY_SIZE 1
#define V3D_CL_END_RENDER_SIZE 1
#define V3D_CL_WAIT_TRANSFORM_FEEDBACK_SIZE 2
#define V3D_CL_BRANCH_SIZE 5
#define V3D_CL_BRANCH_ADDR_OFFSET 1
#define V3D_CL_BRANCH_ADDR_SHIFT 0
#define V3D_CL_RETURN_SIZE 1
#define V3D_CL_FLUSH_VCD_CACHE_SIZE 1
#define V3D_CL_GENERIC_TILE_LIST_SIZE 9
#define V3D_CL_GENERIC_TILE_LIST_ADDR_OFFSET 1
#define V3D_CL_GENERIC_TILE_LIST_ADDR_SHIFT 0
#define V3D_CL_GENERIC_TILE_LIST_END_OFFSET 5
#define V3D_CL_GENERIC_TILE_LIST_END_SHIFT 0
#define V3D_CL_BRANCH_IMPLICIT_TILE_SIZE 2
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_SIZE 8
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_ADDR_OFFSET 4
#define V3D_CL_BRANCH_EXPLICIT_SUPERTILE_ADDR_SHIFT 0
#define V3D_CL_SUPERTILE_COORDS_SIZE 3
#define V3D_CL_STORE_SUBSAMPLE_SIZE 1
#define V3D_CL_STORE_SUBSAMPLE_EX_SIZE 3
#define V3D_CL_LOAD_SIZE 3
#define V3D_CL_END_TILE_SIZE 1
#define V3D_CL_STORE_GENERAL_SIZE 7
#define V3D_CL_STORE_GENERAL_ADDR_OFFSET 3
#define V3D_CL_STORE_GENERAL_ADDR_SHIFT 8
#define V3D_CL_LOAD_GENERAL_SIZE 7
#define V3D_CL_LOAD_GENERAL_ADDR_OFFSET 3
#define V3D_CL_LOAD_GENERAL_ADDR_SHIFT 8
#define V3D_CL_INDEXED_PRIM_LIST_SIZE 18
#define V3D_CL_INDEXED_PRIM_LIST_INDICES_ADDR_OFFSET 6
#define V3D_CL_INDEXED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_SIZE 15
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_OFFSET 6
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDIRECT_ADDR_SHIFT 0
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDICES_ADDR_OFFSET 10
#define V3D_CL_INDIRECT_INDEXED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_SIZE 18
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_INDICES_ADDR_OFFSET 10
#define V3D_CL_INDEXED_INSTANCED_PRIM_LIST_INDICES_ADDR_SHIFT 0
#define V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_SIZE 18
#define V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_INDICES_ADDR_OFFSET 10
#define V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_INDICES_ADDR_SHIFT 0
#define V3D_CL_VERTEX_ARRAY_PRIMS_SIZE 10
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_SIZE 11
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_INDIRECT_ADDR_OFFSET 6
#define V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_INDIRECT_ADDR_SHIFT 0
#define V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_SIZE 14
#define V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_SIZE 14
#define V3D_CL_BASE_VERTEX_BASE_INSTANCE_SIZE 9
#define V3D_CL_INDIRECT_PRIMITIVE_LIMITS_SIZE 12
#define V3D_CL_VG_COORD_ARRAY_PRIMS_SIZE 10
#define V3D_CL_VG_COORD_ARRAY_PRIMS_COORDS_ADDR_OFFSET 6
#define V3D_CL_VG_COORD_ARRAY_PRIMS_COORDS_ADDR_SHIFT 0
#define V3D_CL_VG_INLINE_PRIMS_SIZE 2
#define V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO_SIZE 1
#define V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID_SIZE 1
#define V3D_CL_CLIPPED_PRIM_SIZE 5
#define V3D_CL_CLIPPED_PRIM_CLIP_NUM 3
#define V3D_CL_CLIPPED_PRIM_ADDR_OFFSET 1
#define V3D_CL_CLIPPED_PRIM_ADDR_SHIFT 5
#define V3D_CL_PRIM_LIST_FORMAT_SIZE 2
#define V3D_CL_GL_SHADER_SIZE 5
#define V3D_CL_GL_SHADER_ADDR_OFFSET 1
#define V3D_CL_GL_SHADER_ADDR_SHIFT 5
#define V3D_CL_VG_SHADER_SIZE 5
#define V3D_CL_VG_SHADER_ADDR_OFFSET 1
#define V3D_CL_VG_SHADER_ADDR_SHIFT 0
#define V3D_CL_VG_INLINE_SHADER_SIZE 9
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_OFFSET 1
#define V3D_CL_VG_INLINE_SHADER_FS_ADDR_SHIFT 3
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_OFFSET 5
#define V3D_CL_VG_INLINE_SHADER_FS_UNIFS_ADDR_SHIFT 0
#define V3D_CL_VCM_CACHE_SIZE_SIZE 2
#define V3D_CL_TRANSFORM_FEEDBACK_ENABLE_SIZE 3
#define V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA_SIZE 1
#define V3D_CL_L1_CACHE_FLUSH_CONTROL_SIZE 3
#define V3D_CL_L2T_CACHE_FLUSH_CONTROL_SIZE 10
#define V3D_CL_L2T_CACHE_FLUSH_CONTROL_L2T_FLUSH_START_ADDRESS_OFFSET 1
#define V3D_CL_L2T_CACHE_FLUSH_CONTROL_L2T_FLUSH_START_ADDRESS_SHIFT 0
#define V3D_CL_L2T_CACHE_FLUSH_CONTROL_L2T_FLUSH_END_ADDRESS_OFFSET 5
#define V3D_CL_L2T_CACHE_FLUSH_CONTROL_L2T_FLUSH_END_ADDRESS_SHIFT 0
#define V3D_CL_L2C_CACHE_FLUSH_SIZE 1
#define V3D_CL_STENCIL_CFG_SIZE 6
#define V3D_CL_BLEND_CFG_SIZE 5
#define V3D_CL_BLEND_CCOLOR_SIZE 9
#define V3D_CL_COLOR_WMASKS_SIZE 5
#define V3D_CL_COLOR_WMASKS_NUM 8
#define V3D_CL_ZERO_ALL_CENTROID_FLAGS_SIZE 1
#define V3D_CL_ZERO_ALL_FLATSHADE_FLAGS_SIZE 1
#define V3D_CL_VARY_FLAGS_SIZE 5
#define V3D_CL_SAMPLE_COVERAGE_SIZE 5
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_SIZE 5
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_ADDR_OFFSET 1
#define V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE_ADDR_SHIFT 0
#define V3D_CL_CFG_BITS_SIZE 4
#define V3D_CL_POINT_SIZE_SIZE 5
#define V3D_CL_LINE_WIDTH_SIZE 5
#define V3D_CL_DEPTH_OFFSET_SIZE 5
#define V3D_CL_CLIP_SIZE 9
#define V3D_CL_VIEWPORT_OFFSET_SIZE 9
#define V3D_CL_CLIPZ_SIZE 9
#define V3D_CL_CLIPPER_XY_SIZE 9
#define V3D_CL_CLIPPER_Z_SIZE 9
#define V3D_CL_TILE_BINNING_MODE_CFG_SIZE 9
#define V3D_CL_TILE_BINNING_MODE_CFG_PART1_TILE_STATE_ADDR_OFFSET 1
#define V3D_CL_TILE_BINNING_MODE_CFG_PART1_TILE_STATE_ADDR_SHIFT 6
#define V3D_CL_TILE_BINNING_MODE_CFG_PART2_TILE_ALLOC_ADDR_OFFSET 5
#define V3D_CL_TILE_BINNING_MODE_CFG_PART2_TILE_ALLOC_ADDR_SHIFT 6
#define V3D_CL_TILE_RENDERING_MODE_CFG_SIZE 9
#define V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_ADDR_SHIFT 6
#define V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_ADDR_SHIFT 6
#define V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_ADDR_OFFSET 5
#define V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_ADDR_SHIFT 0
#define V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_SIZE 9
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_SIZE 5
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_ADDR_OFFSET 1
#define V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_ADDR_SHIFT 6
#define V3D_CL_TILE_COORDS_SIZE 4
#define V3D_CL_IMPLICIT_TILE_COORDS_SIZE 1
#define V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_SIZE 2
#define V3D_CL_MAX_INSTR_SIZE 18
extern uint32_t v3d_cl_instr_size(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_bin(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_render(v3d_cl_opcode_t opcode);
extern bool v3d_cl_instr_ok_in_tile_list(v3d_cl_opcode_t opcode);
static inline void v3d_cl_halt(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_HALT);
}
static inline void v3d_cl_nop(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_NOP);
}
static inline void v3d_cl_flush(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH);
}
static inline void v3d_cl_flush_all_state(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_ALL_STATE);
}
static inline void v3d_cl_start_tile_binning(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_START_TILE_BINNING);
}
static inline void v3d_cl_incr_semaphore(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_INCR_SEMAPHORE);
}
static inline void v3d_cl_wait_semaphore(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_SEMAPHORE);
}
static inline void v3d_cl_wait_prev_frame(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_PREV_FRAME);
}
static inline void v3d_cl_enable_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ENABLE_Z_ONLY);
}
static inline void v3d_cl_disable_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_DISABLE_Z_ONLY);
}
static inline void v3d_cl_end_z_only(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_Z_ONLY);
}
static inline void v3d_cl_end_render(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_RENDER);
}
static inline void v3d_cl_wait_transform_feedback(uint8_t **cl,
   uint32_t num)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_TRANSFORM_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits(num, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_sub_autochain(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB_AUTOCHAIN);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_sub(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_return(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_RETURN);
}
static inline void v3d_cl_flush_vcd_cache(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_VCD_CACHE);
}
static inline void v3d_cl_generic_tile_list(uint8_t **cl,
   v3d_addr_t addr,
   v3d_addr_t end)
{
   v3d_cl_add_8(cl, V3D_CL_GENERIC_TILE_LIST);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   (*cl)[4] = (uint8_t)end;
   (*cl)[5] = (uint8_t)(end >> 8);
   (*cl)[6] = (uint8_t)(end >> 16);
   (*cl)[7] = (uint8_t)(end >> 24);
   *cl += 8;
}
static inline void v3d_cl_branch_implicit_tile(uint8_t **cl,
   uint32_t set)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_IMPLICIT_TILE);
   (*cl)[0] = (uint8_t)gfx_bits(set, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_explicit_supertile(uint8_t **cl,
   uint32_t x,
   uint32_t y,
   uint32_t supertile,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_EXPLICIT_SUPERTILE);
   (*cl)[0] = (uint8_t)gfx_bits(x, 8);
   (*cl)[1] = (uint8_t)gfx_bits(y, 8);
   (*cl)[2] = (uint8_t)gfx_bits(supertile, 8);
   (*cl)[3] = (uint8_t)addr;
   (*cl)[4] = (uint8_t)(addr >> 8);
   (*cl)[5] = (uint8_t)(addr >> 16);
   (*cl)[6] = (uint8_t)(addr >> 24);
   *cl += 7;
}
static inline void v3d_cl_supertile_coords(uint8_t **cl,
   uint32_t x,
   uint32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_SUPERTILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits(x, 8);
   (*cl)[1] = (uint8_t)gfx_bits(y, 8);
   *cl += 2;
}
static inline void v3d_cl_store_subsample(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE);
}
static inline void v3d_cl_store_subsample_ex(uint8_t **cl,
   bool eof,
   bool disable_owo_or_double_buf_swap,
   bool disable_depth_clear,
   bool disable_stencil_clear,
   bool disable_color_clear,
   bool stencil_store,
   bool depth_store,
   uint32_t disable_rt_store_mask)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE_EX);
   (*cl)[0] = (uint8_t)gfx_bits(eof, 1) |
      (uint8_t)(gfx_bits(disable_owo_or_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits(disable_depth_clear, 1) << 2) |
      (uint8_t)(gfx_bits(disable_stencil_clear, 1) << 3) |
      (uint8_t)(gfx_bits(disable_color_clear, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits(stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits(depth_store, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(disable_rt_store_mask, 8);
   *cl += 2;
}
static inline void v3d_cl_load(uint8_t **cl,
   bool stencil_load,
   bool depth_load,
   uint32_t disable_rt_load_mask)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits(stencil_load, 1) << 6) |
      (uint8_t)(gfx_bits(depth_load, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(disable_rt_load_mask, 8);
   *cl += 2;
}
static inline void v3d_cl_end_tile(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_END_TILE);
}
static inline void v3d_cl_store_general(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   bool raw_mode,
   bool disable_depth_clear,
   bool disable_stencil_clear,
   bool disable_color_clear,
   bool eof,
   bool disable_double_buf_swap,
   v3d_ldst_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(raw_mode, 1) << 4) |
      (uint8_t)(gfx_bits(disable_depth_clear, 1) << 5) |
      (uint8_t)(gfx_bits(disable_stencil_clear, 1) << 6) |
      (uint8_t)(gfx_bits(disable_color_clear, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(eof, 1) |
      (uint8_t)(gfx_bits(disable_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits(memory_format, 1) << 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr(addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 16);
   *cl += 6;
}
static inline void v3d_cl_load_general(uint8_t **cl,
   v3d_ldst_buf_t buffer,
   bool raw_mode,
   v3d_ldst_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits(buffer, 4) |
      (uint8_t)(gfx_bits(raw_mode, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(memory_format, 1) << 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr(addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 8) >> 16);
   *cl += 6;
}
static inline void v3d_cl_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   v3d_addr_t indices_addr,
   uint32_t max_index,
   bool prim_restart,
   uint32_t min_index)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)num_indices;
   (*cl)[2] = (uint8_t)(num_indices >> 8);
   (*cl)[3] = (uint8_t)(num_indices >> 16);
   (*cl)[4] = (uint8_t)(num_indices >> 24);
   (*cl)[5] = (uint8_t)indices_addr;
   (*cl)[6] = (uint8_t)(indices_addr >> 8);
   (*cl)[7] = (uint8_t)(indices_addr >> 16);
   (*cl)[8] = (uint8_t)(indices_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(max_index, 31);
   (*cl)[10] = (uint8_t)(gfx_bits(max_index, 31) >> 8);
   (*cl)[11] = (uint8_t)(gfx_bits(max_index, 31) >> 16);
   (*cl)[12] = (uint8_t)(gfx_bits(max_index, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[13] = (uint8_t)min_index;
   (*cl)[14] = (uint8_t)(min_index >> 8);
   (*cl)[15] = (uint8_t)(min_index >> 16);
   (*cl)[16] = (uint8_t)(min_index >> 24);
   *cl += 17;
}
static inline void v3d_cl_indirect_indexed_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indirect,
   bool prim_restart,
   v3d_addr_t indirect_addr,
   v3d_addr_t indices_addr,
   uint32_t indirect_stride)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange(num_indirect, 1, 0x7fffffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)indirect_addr;
   (*cl)[6] = (uint8_t)(indirect_addr >> 8);
   (*cl)[7] = (uint8_t)(indirect_addr >> 16);
   (*cl)[8] = (uint8_t)(indirect_addr >> 24);
   (*cl)[9] = (uint8_t)indices_addr;
   (*cl)[10] = (uint8_t)(indices_addr >> 8);
   (*cl)[11] = (uint8_t)(indices_addr >> 16);
   (*cl)[12] = (uint8_t)(indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(gfx_exact_lsr(indirect_stride, 2), 8);
   *cl += 14;
}
static inline void v3d_cl_indexed_instanced_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   uint32_t num_instances,
   v3d_addr_t indices_addr,
   uint32_t max_index,
   bool prim_restart)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)num_indices;
   (*cl)[2] = (uint8_t)(num_indices >> 8);
   (*cl)[3] = (uint8_t)(num_indices >> 16);
   (*cl)[4] = (uint8_t)(num_indices >> 24);
   (*cl)[5] = (uint8_t)num_instances;
   (*cl)[6] = (uint8_t)(num_instances >> 8);
   (*cl)[7] = (uint8_t)(num_instances >> 16);
   (*cl)[8] = (uint8_t)(num_instances >> 24);
   (*cl)[9] = (uint8_t)indices_addr;
   (*cl)[10] = (uint8_t)(indices_addr >> 8);
   (*cl)[11] = (uint8_t)(indices_addr >> 16);
   (*cl)[12] = (uint8_t)(indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits(max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits(max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits(max_index, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   *cl += 17;
}
static inline void v3d_cl_indexed_single_instance_prim_list(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   v3d_index_type_t index_type,
   uint32_t num_indices,
   uint32_t instance_id,
   v3d_addr_t indices_addr,
   uint32_t max_index,
   bool prim_restart)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) |
      (uint8_t)(gfx_bits(index_type, 2) << 6);
   (*cl)[1] = (uint8_t)num_indices;
   (*cl)[2] = (uint8_t)(num_indices >> 8);
   (*cl)[3] = (uint8_t)(num_indices >> 16);
   (*cl)[4] = (uint8_t)(num_indices >> 24);
   (*cl)[5] = (uint8_t)instance_id;
   (*cl)[6] = (uint8_t)(instance_id >> 8);
   (*cl)[7] = (uint8_t)(instance_id >> 16);
   (*cl)[8] = (uint8_t)(instance_id >> 24);
   (*cl)[9] = (uint8_t)indices_addr;
   (*cl)[10] = (uint8_t)(indices_addr >> 8);
   (*cl)[11] = (uint8_t)(indices_addr >> 16);
   (*cl)[12] = (uint8_t)(indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits(max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits(max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits(max_index, 31) >> 24) |
      (uint8_t)(gfx_bits(prim_restart, 1) << 7);
   *cl += 17;
}
static inline void v3d_cl_vertex_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)first_index;
   (*cl)[6] = (uint8_t)(first_index >> 8);
   (*cl)[7] = (uint8_t)(first_index >> 16);
   (*cl)[8] = (uint8_t)(first_index >> 24);
   *cl += 9;
}
static inline void v3d_cl_indirect_vertex_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_indirect,
   v3d_addr_t indirect_addr,
   uint32_t indirect_stride)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_check_urange(num_indirect, 1, 0xffffffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 8);
   (*cl)[3] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 16);
   (*cl)[4] = (uint8_t)(gfx_check_urange(num_indirect, 1, 0xffffffff) >> 24);
   (*cl)[5] = (uint8_t)indirect_addr;
   (*cl)[6] = (uint8_t)(indirect_addr >> 8);
   (*cl)[7] = (uint8_t)(indirect_addr >> 16);
   (*cl)[8] = (uint8_t)(indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr(indirect_stride, 2), 8);
   *cl += 10;
}
static inline void v3d_cl_vertex_array_instanced_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t num_instances,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)num_instances;
   (*cl)[6] = (uint8_t)(num_instances >> 8);
   (*cl)[7] = (uint8_t)(num_instances >> 16);
   (*cl)[8] = (uint8_t)(num_instances >> 24);
   (*cl)[9] = (uint8_t)first_index;
   (*cl)[10] = (uint8_t)(first_index >> 8);
   (*cl)[11] = (uint8_t)(first_index >> 16);
   (*cl)[12] = (uint8_t)(first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_vertex_array_single_instance_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   uint32_t num_vertices,
   uint32_t instance_id,
   uint32_t first_index)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)instance_id;
   (*cl)[6] = (uint8_t)(instance_id >> 8);
   (*cl)[7] = (uint8_t)(instance_id >> 16);
   (*cl)[8] = (uint8_t)(instance_id >> 24);
   (*cl)[9] = (uint8_t)first_index;
   (*cl)[10] = (uint8_t)(first_index >> 8);
   (*cl)[11] = (uint8_t)(first_index >> 16);
   (*cl)[12] = (uint8_t)(first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_base_vertex_base_instance(uint8_t **cl,
   int32_t base_vertex,
   uint32_t base_instance)
{
   v3d_cl_add_8(cl, V3D_CL_BASE_VERTEX_BASE_INSTANCE);
   (*cl)[0] = (uint8_t)(uint32_t)base_vertex;
   (*cl)[1] = (uint8_t)((uint32_t)base_vertex >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)base_vertex >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)base_vertex >> 24);
   (*cl)[4] = (uint8_t)base_instance;
   (*cl)[5] = (uint8_t)(base_instance >> 8);
   (*cl)[6] = (uint8_t)(base_instance >> 16);
   (*cl)[7] = (uint8_t)(base_instance >> 24);
   *cl += 8;
}
static inline void v3d_cl_indirect_primitive_limits(uint8_t **cl,
   uint32_t max_index,
   uint32_t max_instance,
   uint32_t index_buffer_size)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_PRIMITIVE_LIMITS);
   (*cl)[0] = (uint8_t)gfx_bits(max_index, 24);
   (*cl)[1] = (uint8_t)(gfx_bits(max_index, 24) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits(max_index, 24) >> 16);
   (*cl)[3] = (uint8_t)max_instance;
   (*cl)[4] = (uint8_t)(max_instance >> 8);
   (*cl)[5] = (uint8_t)(max_instance >> 16);
   (*cl)[6] = (uint8_t)(max_instance >> 24);
   (*cl)[7] = (uint8_t)index_buffer_size;
   (*cl)[8] = (uint8_t)(index_buffer_size >> 8);
   (*cl)[9] = (uint8_t)(index_buffer_size >> 16);
   (*cl)[10] = (uint8_t)(index_buffer_size >> 24);
   *cl += 11;
}
static inline void v3d_cl_vg_coord_array_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   bool continuation,
   uint32_t num_vertices,
   v3d_addr_t coords_addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_COORD_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 4) |
      (uint8_t)(gfx_bits(continuation, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)num_vertices;
   (*cl)[2] = (uint8_t)(num_vertices >> 8);
   (*cl)[3] = (uint8_t)(num_vertices >> 16);
   (*cl)[4] = (uint8_t)(num_vertices >> 24);
   (*cl)[5] = (uint8_t)coords_addr;
   (*cl)[6] = (uint8_t)(coords_addr >> 8);
   (*cl)[7] = (uint8_t)(coords_addr >> 16);
   (*cl)[8] = (uint8_t)(coords_addr >> 24);
   *cl += 9;
}
static inline void v3d_cl_vg_inline_prims(uint8_t **cl,
   v3d_prim_mode_t prim_mode,
   bool continuation)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits(prim_mode, 4) |
      (uint8_t)(gfx_bits(continuation, 1) << 4) | (uint8_t)0;
   *cl += 1;
}
static inline void v3d_cl_compressed_prim_list_iid_zero(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_COMPRESSED_PRIM_LIST_IID_ZERO);
}
static inline void v3d_cl_compressed_prim_list_current_iid(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_COMPRESSED_PRIM_LIST_CURRENT_IID);
}
static inline void v3d_cl_clipped_prim_iid_zero(uint8_t **cl,
   bool clip_0,
   bool clip_1,
   bool clip_2,
   bool flat_zw,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_IID_ZERO);
   (*cl)[0] = (uint8_t)gfx_bits(clip_0, 1) | (uint8_t)(gfx_bits(clip_1, 1) << 1) |
      (uint8_t)(gfx_bits(clip_2, 1) << 2) | (uint8_t)(gfx_bits(flat_zw, 1) << 3) |
      (uint8_t)0 | (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_clipped_prim_current_iid(uint8_t **cl,
   bool clip_0,
   bool clip_1,
   bool clip_2,
   bool flat_zw,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_CURRENT_IID);
   (*cl)[0] = (uint8_t)gfx_bits(clip_0, 1) | (uint8_t)(gfx_bits(clip_1, 1) << 1) |
      (uint8_t)(gfx_bits(clip_2, 1) << 2) | (uint8_t)(gfx_bits(flat_zw, 1) << 3) |
      (uint8_t)0 | (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_prim_list_format(uint8_t **cl,
   v3d_prim_type_t prim_type,
   bool xy,
   bool d3dpvsf)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_LIST_FORMAT);
   (*cl)[0] = (uint8_t)gfx_bits(prim_type, 6) | (uint8_t)(gfx_bits(xy, 1) << 6) |
      (uint8_t)(gfx_bits(d3dpvsf, 1) << 7);
   *cl += 1;
}
static inline void v3d_cl_gl_tg_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_TG_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_g_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_G_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_t_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_T_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_shader(uint8_t **cl,
   uint32_t num_attr_arrays,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max(num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr(addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_vg_shader(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_SHADER);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_vg_inline_shader(uint8_t **cl,
   v3d_threading_t fs_threading,
   bool fs_propagate_nans,
   v3d_addr_t fs_addr,
   v3d_addr_t fs_unifs_addr)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits(fs_threading, 2) |
      (uint8_t)(gfx_bits(fs_propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr(fs_addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(fs_addr, 3) >> 21);
   (*cl)[4] = (uint8_t)fs_unifs_addr;
   (*cl)[5] = (uint8_t)(fs_unifs_addr >> 8);
   (*cl)[6] = (uint8_t)(fs_unifs_addr >> 16);
   (*cl)[7] = (uint8_t)(fs_unifs_addr >> 24);
   *cl += 8;
}
static inline void v3d_cl_vcm_cache_size(uint8_t **cl,
   uint32_t num_batches_bin,
   uint32_t num_batches_render)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange(num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange(num_batches_render, 1, 4) << 4);
   *cl += 1;
}
static inline void v3d_cl_transform_feedback_enable(uint8_t **cl,
   uint32_t id,
   uint32_t num_addrs,
   uint32_t num_specs)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_ENABLE);
   (*cl)[0] = (uint8_t)gfx_bits(id, 8);
   (*cl)[1] = (uint8_t)gfx_check_urange(num_addrs, 0, 4) |
      (uint8_t)(gfx_check_urange(num_specs, 1, 16) << 3);
   *cl += 2;
}
static inline void v3d_cl_flush_transform_feedback_data(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_FLUSH_TRANSFORM_FEEDBACK_DATA);
}
static inline void v3d_cl_l1_cache_flush_control(uint8_t **cl,
   bool icache_clear_slice_0,
   bool icache_clear_slice_1,
   bool icache_clear_slice_2,
   bool icache_clear_slice_3,
   bool ucache_clear_slice_0,
   bool ucache_clear_slice_1,
   bool ucache_clear_slice_2,
   bool ucache_clear_slice_3,
   bool tmu_data_cache_clear_0,
   bool tmu_data_cache_clear_1,
   bool tmu_data_cache_clear_2,
   bool tmu_data_cache_clear_3,
   bool tmu_config_cache_clear_0,
   bool tmu_config_cache_clear_1,
   bool tmu_config_cache_clear_2,
   bool tmu_config_cache_clear_3)
{
   v3d_cl_add_8(cl, V3D_CL_L1_CACHE_FLUSH_CONTROL);
   (*cl)[0] = (uint8_t)gfx_bits(icache_clear_slice_0, 1) |
      (uint8_t)(gfx_bits(icache_clear_slice_1, 1) << 1) |
      (uint8_t)(gfx_bits(icache_clear_slice_2, 1) << 2) |
      (uint8_t)(gfx_bits(icache_clear_slice_3, 1) << 3) |
      (uint8_t)(gfx_bits(ucache_clear_slice_0, 1) << 4) |
      (uint8_t)(gfx_bits(ucache_clear_slice_1, 1) << 5) |
      (uint8_t)(gfx_bits(ucache_clear_slice_2, 1) << 6) |
      (uint8_t)(gfx_bits(ucache_clear_slice_3, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(tmu_data_cache_clear_0, 1) |
      (uint8_t)(gfx_bits(tmu_data_cache_clear_1, 1) << 1) |
      (uint8_t)(gfx_bits(tmu_data_cache_clear_2, 1) << 2) |
      (uint8_t)(gfx_bits(tmu_data_cache_clear_3, 1) << 3) |
      (uint8_t)(gfx_bits(tmu_config_cache_clear_0, 1) << 4) |
      (uint8_t)(gfx_bits(tmu_config_cache_clear_1, 1) << 5) |
      (uint8_t)(gfx_bits(tmu_config_cache_clear_2, 1) << 6) |
      (uint8_t)(gfx_bits(tmu_config_cache_clear_3, 1) << 7);
   *cl += 2;
}
static inline void v3d_cl_l2t_cache_flush_control(uint8_t **cl,
   v3d_addr_t l2t_flush_start_address,
   v3d_addr_t l2t_flush_end_address,
   v3d_l2t_flush_mode_t l2t_flush_mode)
{
   v3d_cl_add_8(cl, V3D_CL_L2T_CACHE_FLUSH_CONTROL);
   (*cl)[0] = (uint8_t)l2t_flush_start_address;
   (*cl)[1] = (uint8_t)(l2t_flush_start_address >> 8);
   (*cl)[2] = (uint8_t)(l2t_flush_start_address >> 16);
   (*cl)[3] = (uint8_t)(l2t_flush_start_address >> 24);
   (*cl)[4] = (uint8_t)l2t_flush_end_address;
   (*cl)[5] = (uint8_t)(l2t_flush_end_address >> 8);
   (*cl)[6] = (uint8_t)(l2t_flush_end_address >> 16);
   (*cl)[7] = (uint8_t)(l2t_flush_end_address >> 24);
   (*cl)[8] = (uint8_t)gfx_bits(l2t_flush_mode, 2) | (uint8_t)0;
   *cl += 9;
}
static inline void v3d_cl_l2c_cache_flush(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_L2C_CACHE_FLUSH);
}
static inline void v3d_cl_stencil_cfg(uint8_t **cl,
   uint32_t reference,
   uint32_t mask,
   v3d_compare_func_t func,
   v3d_stencil_op_t fail_op,
   v3d_stencil_op_t depth_fail_op,
   v3d_stencil_op_t pass_op,
   bool front_cfg,
   bool back_cfg,
   uint32_t write_mask)
{
   v3d_cl_add_8(cl, V3D_CL_STENCIL_CFG);
   (*cl)[0] = (uint8_t)gfx_bits(reference, 8);
   (*cl)[1] = (uint8_t)gfx_bits(mask, 8);
   (*cl)[2] = (uint8_t)gfx_bits(func, 3) | (uint8_t)(gfx_bits(fail_op, 3) << 3) |
      (uint8_t)(gfx_bits(depth_fail_op, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(depth_fail_op, 3) >> 2) |
      (uint8_t)(gfx_bits(pass_op, 3) << 1) | (uint8_t)(gfx_bits(front_cfg, 1) << 4) |
      (uint8_t)(gfx_bits(back_cfg, 1) << 5) | (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_bits(write_mask, 8);
   *cl += 5;
}
static inline void v3d_cl_blend_cfg(uint8_t **cl,
   v3d_blend_eqn_t a_eqn,
   v3d_blend_mul_t a_src,
   v3d_blend_mul_t a_dst,
   v3d_blend_eqn_t c_eqn,
   v3d_blend_mul_t c_src,
   v3d_blend_mul_t c_dst,
   v3d_blend_vg_mode_t vg_mode)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits(a_eqn, 4) | (uint8_t)(gfx_bits(a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(a_dst, 4) | (uint8_t)(gfx_bits(c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits(c_src, 4) | (uint8_t)(gfx_bits(c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits(vg_mode, 2) << 4) | (uint8_t)0;
   *cl += 4;
}
static inline void v3d_cl_blend_ccolor(uint8_t **cl,
   float r,
   float g,
   float b,
   float a)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CCOLOR);
   (*cl)[0] = (uint8_t)gfx_float_to_float16(r);
   (*cl)[1] = (uint8_t)(gfx_float_to_float16(r) >> 8);
   (*cl)[2] = (uint8_t)gfx_float_to_float16(g);
   (*cl)[3] = (uint8_t)(gfx_float_to_float16(g) >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_float16(b);
   (*cl)[5] = (uint8_t)(gfx_float_to_float16(b) >> 8);
   (*cl)[6] = (uint8_t)gfx_float_to_float16(a);
   (*cl)[7] = (uint8_t)(gfx_float_to_float16(a) >> 8);
   *cl += 8;
}
static inline void v3d_cl_color_wmasks(uint8_t **cl,
   bool x0_disable_r,
   bool x0_disable_g,
   bool x0_disable_b,
   bool x0_disable_a,
   bool x1_disable_r,
   bool x1_disable_g,
   bool x1_disable_b,
   bool x1_disable_a,
   bool x2_disable_r,
   bool x2_disable_g,
   bool x2_disable_b,
   bool x2_disable_a,
   bool x3_disable_r,
   bool x3_disable_g,
   bool x3_disable_b,
   bool x3_disable_a,
   bool x4_disable_r,
   bool x4_disable_g,
   bool x4_disable_b,
   bool x4_disable_a,
   bool x5_disable_r,
   bool x5_disable_g,
   bool x5_disable_b,
   bool x5_disable_a,
   bool x6_disable_r,
   bool x6_disable_g,
   bool x6_disable_b,
   bool x6_disable_a,
   bool x7_disable_r,
   bool x7_disable_g,
   bool x7_disable_b,
   bool x7_disable_a)
{
   v3d_cl_add_8(cl, V3D_CL_COLOR_WMASKS);
   (*cl)[0] = (uint8_t)gfx_bits(x0_disable_r, 1) |
      (uint8_t)(gfx_bits(x0_disable_g, 1) << 1) |
      (uint8_t)(gfx_bits(x0_disable_b, 1) << 2) |
      (uint8_t)(gfx_bits(x0_disable_a, 1) << 3) |
      (uint8_t)(gfx_bits(x1_disable_r, 1) << 4) |
      (uint8_t)(gfx_bits(x1_disable_g, 1) << 5) |
      (uint8_t)(gfx_bits(x1_disable_b, 1) << 6) |
      (uint8_t)(gfx_bits(x1_disable_a, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits(x2_disable_r, 1) |
      (uint8_t)(gfx_bits(x2_disable_g, 1) << 1) |
      (uint8_t)(gfx_bits(x2_disable_b, 1) << 2) |
      (uint8_t)(gfx_bits(x2_disable_a, 1) << 3) |
      (uint8_t)(gfx_bits(x3_disable_r, 1) << 4) |
      (uint8_t)(gfx_bits(x3_disable_g, 1) << 5) |
      (uint8_t)(gfx_bits(x3_disable_b, 1) << 6) |
      (uint8_t)(gfx_bits(x3_disable_a, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits(x4_disable_r, 1) |
      (uint8_t)(gfx_bits(x4_disable_g, 1) << 1) |
      (uint8_t)(gfx_bits(x4_disable_b, 1) << 2) |
      (uint8_t)(gfx_bits(x4_disable_a, 1) << 3) |
      (uint8_t)(gfx_bits(x5_disable_r, 1) << 4) |
      (uint8_t)(gfx_bits(x5_disable_g, 1) << 5) |
      (uint8_t)(gfx_bits(x5_disable_b, 1) << 6) |
      (uint8_t)(gfx_bits(x5_disable_a, 1) << 7);
   (*cl)[3] = (uint8_t)gfx_bits(x6_disable_r, 1) |
      (uint8_t)(gfx_bits(x6_disable_g, 1) << 1) |
      (uint8_t)(gfx_bits(x6_disable_b, 1) << 2) |
      (uint8_t)(gfx_bits(x6_disable_a, 1) << 3) |
      (uint8_t)(gfx_bits(x7_disable_r, 1) << 4) |
      (uint8_t)(gfx_bits(x7_disable_g, 1) << 5) |
      (uint8_t)(gfx_bits(x7_disable_b, 1) << 6) |
      (uint8_t)(gfx_bits(x7_disable_a, 1) << 7);
   *cl += 4;
}
static inline void v3d_cl_zero_all_centroid_flags(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ZERO_ALL_CENTROID_FLAGS);
}
static inline void v3d_cl_zero_all_flatshade_flags(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_ZERO_ALL_FLATSHADE_FLAGS);
}
static inline void v3d_cl_centroid_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags(uint8_t **cl,
   uint32_t offset,
   v3d_flags_action_t lower_action,
   v3d_flags_action_t higher_action,
   uint32_t flags)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange(offset, 0, 2) |
      (uint8_t)(gfx_bits(lower_action, 2) << 4) |
      (uint8_t)(gfx_bits(higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits(flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits(flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_sample_coverage(uint8_t **cl,
   float sample_coverage)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_COVERAGE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(sample_coverage);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(sample_coverage) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(sample_coverage) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(sample_coverage) >> 24);
   *cl += 4;
}
static inline void v3d_cl_occlusion_query_counter_enable(uint8_t **cl,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE);
   (*cl)[0] = (uint8_t)addr;
   (*cl)[1] = (uint8_t)(addr >> 8);
   (*cl)[2] = (uint8_t)(addr >> 16);
   (*cl)[3] = (uint8_t)(addr >> 24);
   *cl += 4;
}
static inline void v3d_cl_cfg_bits(uint8_t **cl,
   bool front_prims,
   bool back_prims,
   bool cwise_is_front,
   bool depth_offset,
   bool aa_lines,
   v3d_ms_t rast_oversample,
   bool cov_pipe,
   v3d_cov_update_t cov_update,
   bool wireframe_tris,
   v3d_compare_func_t depth_test,
   bool depth_update,
   bool ez,
   bool ez_update,
   bool stencil,
   bool blend,
   v3d_wireframe_mode_t wireframe_mode,
   bool d3d_prov_vtx)
{
   v3d_cl_add_8(cl, V3D_CL_CFG_BITS);
   (*cl)[0] = (uint8_t)gfx_bits(front_prims, 1) |
      (uint8_t)(gfx_bits(back_prims, 1) << 1) |
      (uint8_t)(gfx_bits(cwise_is_front, 1) << 2) |
      (uint8_t)(gfx_bits(depth_offset, 1) << 3) |
      (uint8_t)(gfx_bits(aa_lines, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits(rast_oversample, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits(cov_pipe, 1) |
      (uint8_t)(gfx_bits(cov_update, 2) << 1) |
      (uint8_t)(gfx_bits(wireframe_tris, 1) << 3) |
      (uint8_t)(gfx_bits(depth_test, 3) << 4) |
      (uint8_t)(gfx_bits(depth_update, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits(ez, 1) | (uint8_t)(gfx_bits(ez_update, 1) << 1) |
      (uint8_t)(gfx_bits(stencil, 1) << 2) | (uint8_t)(gfx_bits(blend, 1) << 3) |
      (uint8_t)(gfx_bits(wireframe_mode, 1) << 4) |
      (uint8_t)(gfx_bits(d3d_prov_vtx, 1) << 5) | (uint8_t)0;
   *cl += 3;
}
static inline void v3d_cl_point_size(uint8_t **cl,
   float point_size)
{
   v3d_cl_add_8(cl, V3D_CL_POINT_SIZE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(point_size);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(point_size) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(point_size) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(point_size) >> 24);
   *cl += 4;
}
static inline void v3d_cl_line_width(uint8_t **cl,
   float line_width)
{
   v3d_cl_add_8(cl, V3D_CL_LINE_WIDTH);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(line_width);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(line_width) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(line_width) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(line_width) >> 24);
   *cl += 4;
}
static inline void v3d_cl_depth_offset(uint8_t **cl,
   float factor,
   float units)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits(factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(units) >> 16 >> 8);
   *cl += 4;
}
static inline void v3d_cl_clip(uint8_t **cl,
   uint32_t x,
   uint32_t y,
   uint32_t width,
   uint32_t height)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits(x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits(y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits(y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange(width, 1, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange(width, 1, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange(height, 1, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange(height, 1, 0x1000) >> 8);
   *cl += 8;
}
static inline void v3d_cl_viewport_offset(uint8_t **cl,
   int32_t x,
   int32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)(uint32_t)x;
   (*cl)[1] = (uint8_t)((uint32_t)x >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)x >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)x >> 24);
   (*cl)[4] = (uint8_t)(uint32_t)y;
   (*cl)[5] = (uint8_t)((uint32_t)y >> 8);
   (*cl)[6] = (uint8_t)((uint32_t)y >> 16);
   (*cl)[7] = (uint8_t)((uint32_t)y >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipz(uint8_t **cl,
   float min,
   float max)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPZ);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(min);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(min) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(min) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(min) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(max);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(max) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(max) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(max) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_xy(uint8_t **cl,
   float scale_x,
   float scale_y)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_XY);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(scale_x);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(scale_x) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(scale_x) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(scale_x) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(scale_y);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(scale_y) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(scale_y) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(scale_y) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_z(uint8_t **cl,
   float scale,
   float offset)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_Z);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(scale);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(scale) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(scale) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(scale) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits(offset);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(offset) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits(offset) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits(offset) >> 24);
   *cl += 8;
}
static inline void v3d_cl_tile_binning_mode_cfg_part1(uint8_t **cl,
   bool auto_init_tile_state,
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size,
   v3d_tile_alloc_block_size_t tile_alloc_block_size,
   v3d_addr_t tile_state_addr,
   uint32_t w_in_tiles,
   uint32_t h_in_tiles,
   uint32_t num_rts,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits(auto_init_tile_state, 1) << 1) |
      (uint8_t)(gfx_bits(tile_alloc_initial_block_size, 2) << 2) |
      (uint8_t)(gfx_bits(tile_alloc_block_size, 2) << 4) |
      (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(tile_state_addr, 6) >> 18);
   (*cl)[4] = (uint8_t)gfx_check_urange(w_in_tiles, 1, 0xfff);
   (*cl)[5] = (uint8_t)(gfx_check_urange(w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange(h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] = (uint8_t)(gfx_check_urange(h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_check_urange(num_rts, 0, 8) |
      (uint8_t)(gfx_bits(max_bpp, 2) << 4) | (uint8_t)(gfx_bits(ms_mode, 1) << 6) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 7);
   *cl += 8;
}
static inline void v3d_cl_tile_binning_mode_cfg_part2(uint8_t **cl,
   uint32_t tile_alloc_size,
   v3d_addr_t tile_alloc_addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(tile_alloc_size, 6) >> 18);
   (*cl)[4] = (uint8_t)0 | (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(tile_alloc_addr, 6) >> 18);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_common(uint8_t **cl,
   uint32_t num_rts,
   uint32_t frame_width,
   uint32_t frame_height,
   v3d_rt_bpp_t max_bpp,
   bool ms_mode,
   bool double_buffer,
   bool cov_mode,
   v3d_ez_direction_t ez_direction,
   bool ez_disable,
   bool stencil_store,
   bool depth_store,
   uint32_t disable_rt_store_mask)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)0 |
      (uint8_t)(gfx_pack_uint_minus_1(gfx_check_urange(num_rts, 1, 8), 4) << 4);
   (*cl)[1] = (uint8_t)gfx_check_urange(frame_width, 1, 0xffff);
   (*cl)[2] = (uint8_t)(gfx_check_urange(frame_width, 1, 0xffff) >> 8);
   (*cl)[3] = (uint8_t)gfx_check_urange(frame_height, 1, 0xffff);
   (*cl)[4] = (uint8_t)(gfx_check_urange(frame_height, 1, 0xffff) >> 8);
   (*cl)[5] = (uint8_t)gfx_bits(max_bpp, 2) |
      (uint8_t)(gfx_bits(ms_mode, 1) << 2) |
      (uint8_t)(gfx_bits(double_buffer, 1) << 3) |
      (uint8_t)(gfx_bits(cov_mode, 1) << 4) |
      (uint8_t)(gfx_bits(ez_direction, 1) << 5) |
      (uint8_t)(gfx_bits(ez_disable, 1) << 6) | (uint8_t)0;
   (*cl)[6] = (uint8_t)0 | (uint8_t)(gfx_bits(stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits(depth_store, 1) << 7);
   (*cl)[7] = (uint8_t)gfx_bits(disable_rt_store_mask, 8);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_z_stencil(uint8_t **cl,
   v3d_depth_type_t internal_type,
   v3d_decimate_t decimate_mode,
   v3d_depth_format_t output_format,
   v3d_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(internal_type, 4) << 2) |
      (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)gfx_bits(output_format, 6) |
      (uint8_t)(gfx_bits(memory_format, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(memory_format, 3) >> 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 1);
   (*cl)[4] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 7) |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_separate_stencil(uint8_t **cl,
   v3d_decimate_t decimate_mode,
   v3d_memory_format_t memory_format,
   uint32_t uif_height_in_ub,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)1 | (uint8_t)(1 << 4);
   (*cl)[1] = (uint8_t)0 | (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)0 | (uint8_t)(gfx_bits(memory_format, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits(memory_format, 3) >> 2) |
      (uint8_t)(gfx_bits(uif_height_in_ub, 13) << 1);
   (*cl)[4] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 7) |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[6] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[7] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_color(uint8_t **cl,
   uint32_t rt,
   v3d_rt_bpp_t internal_bpp,
   v3d_rt_type_t internal_type,
   v3d_decimate_t decimate_mode,
   v3d_pixel_format_t output_format,
   v3d_dither_t dither_mode,
   v3d_memory_format_t memory_format,
   bool flipy,
   uint32_t pad,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)2 | (uint8_t)(gfx_check_urange(rt, 0, 7) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(internal_bpp, 2) |
      (uint8_t)(gfx_bits(internal_type, 4) << 2) |
      (uint8_t)(gfx_bits(decimate_mode, 2) << 6);
   (*cl)[2] = (uint8_t)gfx_bits(output_format, 6) |
      (uint8_t)(gfx_bits(dither_mode, 2) << 6);
   (*cl)[3] = (uint8_t)gfx_bits(memory_format, 3) |
      (uint8_t)(gfx_bits(flipy, 1) << 3) | (uint8_t)(gfx_bits(pad, 4) << 4);
   (*cl)[4] = (uint8_t)addr;
   (*cl)[5] = (uint8_t)(addr >> 8);
   (*cl)[6] = (uint8_t)(addr >> 16);
   (*cl)[7] = (uint8_t)(addr >> 24);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_zs_clear_values(uint8_t **cl,
   uint32_t stencil_clear,
   float depth_clear)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)3 | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_bits(stencil_clear, 8);
   (*cl)[2] = (uint8_t)gfx_float_to_bits(depth_clear);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 8);
   (*cl)[4] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 16);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits(depth_clear) >> 24);
   (*cl)[6] = (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part1(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_0,
   uint32_t clear_col_1_andm24)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)4 | (uint8_t)(gfx_check_urange(rt, 0, 7) << 4);
   (*cl)[1] = (uint8_t)clear_col_0;
   (*cl)[2] = (uint8_t)(clear_col_0 >> 8);
   (*cl)[3] = (uint8_t)(clear_col_0 >> 16);
   (*cl)[4] = (uint8_t)(clear_col_0 >> 24);
   (*cl)[5] = (uint8_t)gfx_bits(clear_col_1_andm24, 24);
   (*cl)[6] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 8);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_1_andm24, 24) >> 16);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part2(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_1_shift24,
   uint32_t clear_col_2,
   uint32_t clear_col_3_andm16)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)5 | (uint8_t)(gfx_check_urange(rt, 0, 7) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_1_shift24, 8);
   (*cl)[2] = (uint8_t)clear_col_2;
   (*cl)[3] = (uint8_t)(clear_col_2 >> 8);
   (*cl)[4] = (uint8_t)(clear_col_2 >> 16);
   (*cl)[5] = (uint8_t)(clear_col_2 >> 24);
   (*cl)[6] = (uint8_t)gfx_bits(clear_col_3_andm16, 16);
   (*cl)[7] = (uint8_t)(gfx_bits(clear_col_3_andm16, 16) >> 8);
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_clear_colors_part3(uint8_t **cl,
   uint32_t rt,
   uint32_t clear_col_3_shift16,
   uint32_t raster_padded_width_or_nonraster_height,
   uint32_t uif_height_in_ub)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   (*cl)[0] = (uint8_t)6 | (uint8_t)(gfx_check_urange(rt, 0, 7) << 4);
   (*cl)[1] = (uint8_t)gfx_bits(clear_col_3_shift16, 16);
   (*cl)[2] = (uint8_t)(gfx_bits(clear_col_3_shift16, 16) >> 8);
   (*cl)[3] = (uint8_t)gfx_check_urange(raster_padded_width_or_nonraster_height,
      0, 0x1fff);
   (*cl)[4] = (uint8_t)(gfx_check_urange(raster_padded_width_or_nonraster_height,
      0, 0x1fff) >> 8);
   (*cl)[5] = (uint8_t)gfx_bits(uif_height_in_ub, 13);
   (*cl)[6] = (uint8_t)(gfx_bits(uif_height_in_ub, 13) >> 8) | (uint8_t)0;
   (*cl)[7] = (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_supertile_cfg(uint8_t **cl,
   uint32_t supertile_w_in_tiles,
   uint32_t supertile_h_in_tiles,
   uint32_t frame_w_in_supertiles,
   uint32_t frame_h_in_supertiles,
   uint32_t frame_w_in_tiles,
   uint32_t frame_h_in_tiles,
   bool multicore,
   v3d_supertile_order_t supertile_order)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1(supertile_w_in_tiles, 8);
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1(supertile_h_in_tiles, 8);
   (*cl)[2] = (uint8_t)gfx_check_urange(frame_w_in_supertiles, 1, 255);
   (*cl)[3] = (uint8_t)gfx_check_urange(frame_h_in_supertiles, 1, 255);
   (*cl)[4] = (uint8_t)gfx_check_urange(frame_w_in_tiles, 1, 0xfff);
   (*cl)[5] = (uint8_t)(gfx_check_urange(frame_w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange(frame_h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] = (uint8_t)(gfx_check_urange(frame_h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_bits(multicore, 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits(supertile_order, 1) << 4) | (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_tile_list_base(uint8_t **cl,
   uint32_t set,
   v3d_addr_t addr)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE);
   (*cl)[0] = (uint8_t)gfx_bits(set, 4) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr(addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr(addr, 6) >> 18);
   *cl += 4;
}
static inline void v3d_cl_tile_coords(uint8_t **cl,
   uint32_t x,
   uint32_t y)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits(x, 12);
   (*cl)[1] = (uint8_t)(gfx_bits(x, 12) >> 8) | (uint8_t)(gfx_bits(y, 12) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits(y, 12) >> 4);
   *cl += 3;
}
static inline void v3d_cl_implicit_tile_coords(uint8_t **cl)
{
   v3d_cl_add_8(cl, V3D_CL_IMPLICIT_TILE_COORDS);
}
static inline void v3d_cl_tile_list_initial_block_size(uint8_t **cl,
   v3d_tile_alloc_block_size_t block_size,
   bool chain)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE);
   (*cl)[0] = (uint8_t)gfx_bits(block_size, 2) |
      (uint8_t)(gfx_bits(chain, 1) << 2) | (uint8_t)0;
   *cl += 1;
}
extern void v3d_cl_print_halt(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_nop(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush_all_state(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_start_tile_binning(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_incr_semaphore(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_semaphore(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_prev_frame(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_enable_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_disable_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_end_z_only(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_end_render(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_wait_transform_feedback(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_return(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush_vcd_cache(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_generic_tile_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch_implicit_tile(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_branch_explicit_supertile(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_supertile_coords(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_store_subsample(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_store_subsample_ex(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_load(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_end_tile(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_store_general(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_load_general(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indirect_indexed_prim_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indexed_instanced_prim_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indexed_single_instance_prim_list(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indirect_vertex_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vertex_array_instanced_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vertex_array_single_instance_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_base_vertex_base_instance(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_indirect_primitive_limits(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vg_coord_array_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vg_inline_prims(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_compressed_prim_list_iid_zero(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_compressed_prim_list_current_iid(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipped_prim(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_prim_list_format(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_gl_shader(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vg_shader(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vg_inline_shader(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vcm_cache_size(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_transform_feedback_enable(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_flush_transform_feedback_data(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_l1_cache_flush_control(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_l2t_cache_flush_control(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_l2c_cache_flush(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_stencil_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_blend_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_blend_ccolor(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_color_wmasks(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_zero_all_centroid_flags(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_zero_all_flatshade_flags(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_vary_flags(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_sample_coverage(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_occlusion_query_counter_enable(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_cfg_bits(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_point_size(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_line_width(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_depth_offset(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clip(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_viewport_offset(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipz(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipper_xy(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_clipper_z(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_binning_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_rendering_mode_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_multicore_rendering_supertile_cfg(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_multicore_rendering_tile_list_base(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_coords(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_implicit_tile_coords(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_tile_list_initial_block_size(const uint8_t *packed, struct v3d_printer *printer);
extern void v3d_cl_print_instr(const uint8_t *packed_instr, struct v3d_printer *printer);
typedef struct
{
   v3d_addr_t addr;
   v3d_addr_t end;
} V3D_CL_GENERIC_TILE_LIST_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
   uint32_t supertile;
   v3d_addr_t addr;
} V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
} V3D_CL_SUPERTILE_COORDS_T;
typedef struct
{
   bool eof;
   bool disable_owo_or_double_buf_swap;
   bool disable_depth_clear;
   bool disable_stencil_clear;
   bool disable_color_clear;
   bool stencil_store;
   bool depth_store;
   uint32_t disable_rt_store_mask;
} V3D_CL_STORE_SUBSAMPLE_EX_T;
typedef struct
{
   bool stencil_load;
   bool depth_load;
   uint32_t disable_rt_load_mask;
} V3D_CL_LOAD_T;
typedef struct
{
   v3d_ldst_buf_t buffer;
   bool raw_mode;
   bool disable_depth_clear;
   bool disable_stencil_clear;
   bool disable_color_clear;
   bool eof;
   bool disable_double_buf_swap;
   v3d_ldst_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_STORE_GENERAL_T;
typedef struct
{
   v3d_ldst_buf_t buffer;
   bool raw_mode;
   v3d_ldst_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_LOAD_GENERAL_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   v3d_addr_t indices_addr;
   uint32_t max_index;
   bool prim_restart;
   uint32_t min_index;
} V3D_CL_INDEXED_PRIM_LIST_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indirect;
   bool prim_restart;
   v3d_addr_t indirect_addr;
   v3d_addr_t indices_addr;
   uint32_t indirect_stride;
} V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   uint32_t num_instances;
   v3d_addr_t indices_addr;
   uint32_t max_index;
   bool prim_restart;
} V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   v3d_index_type_t index_type;
   uint32_t num_indices;
   uint32_t instance_id;
   v3d_addr_t indices_addr;
   uint32_t max_index;
   bool prim_restart;
} V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_indirect;
   v3d_addr_t indirect_addr;
   uint32_t indirect_stride;
} V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t num_instances;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   uint32_t num_vertices;
   uint32_t instance_id;
   uint32_t first_index;
} V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T;
typedef struct
{
   int32_t base_vertex;
   uint32_t base_instance;
} V3D_CL_BASE_VERTEX_BASE_INSTANCE_T;
typedef struct
{
   uint32_t max_index;
   uint32_t max_instance;
   uint32_t index_buffer_size;
} V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   bool continuation;
   uint32_t num_vertices;
   v3d_addr_t coords_addr;
} V3D_CL_VG_COORD_ARRAY_PRIMS_T;
typedef struct
{
   v3d_prim_mode_t prim_mode;
   bool continuation;
} V3D_CL_VG_INLINE_PRIMS_T;
typedef bool V3D_CL_CLIPPED_PRIM_CLIP_T[3];
typedef struct
{
   V3D_CL_CLIPPED_PRIM_CLIP_T clip;
   bool flat_zw;
   v3d_addr_t addr;
} V3D_CL_CLIPPED_PRIM_T;
typedef struct
{
   v3d_prim_type_t prim_type;
   bool xy;
   bool d3dpvsf;
} V3D_CL_PRIM_LIST_FORMAT_T;
typedef struct
{
   uint32_t num_attr_arrays;
   v3d_addr_t addr;
} V3D_CL_GL_SHADER_T;
typedef struct
{
   V3D_SHADER_ARGS_T fs;
} V3D_CL_VG_INLINE_SHADER_T;
typedef struct
{
   uint32_t num_batches_bin;
   uint32_t num_batches_render;
} V3D_CL_VCM_CACHE_SIZE_T;
typedef struct
{
   uint32_t id;
   uint32_t num_addrs;
   uint32_t num_specs;
} V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T;
typedef struct
{
   bool icache_clear_slice_0;
   bool icache_clear_slice_1;
   bool icache_clear_slice_2;
   bool icache_clear_slice_3;
   bool ucache_clear_slice_0;
   bool ucache_clear_slice_1;
   bool ucache_clear_slice_2;
   bool ucache_clear_slice_3;
   bool tmu_data_cache_clear_0;
   bool tmu_data_cache_clear_1;
   bool tmu_data_cache_clear_2;
   bool tmu_data_cache_clear_3;
   bool tmu_config_cache_clear_0;
   bool tmu_config_cache_clear_1;
   bool tmu_config_cache_clear_2;
   bool tmu_config_cache_clear_3;
} V3D_CL_L1_CACHE_FLUSH_CONTROL_T;
typedef struct
{
   v3d_addr_t l2t_flush_start_address;
   v3d_addr_t l2t_flush_end_address;
   v3d_l2t_flush_mode_t l2t_flush_mode;
} V3D_CL_L2T_CACHE_FLUSH_CONTROL_T;
typedef struct
{
   uint32_t reference;
   uint32_t mask;
   v3d_compare_func_t func;
   v3d_stencil_op_t fail_op;
   v3d_stencil_op_t depth_fail_op;
   v3d_stencil_op_t pass_op;
   bool front_cfg;
   bool back_cfg;
   uint32_t write_mask;
} V3D_CL_STENCIL_CFG_T;
typedef struct
{
   v3d_blend_eqn_t a_eqn;
   v3d_blend_mul_t a_src;
   v3d_blend_mul_t a_dst;
   v3d_blend_eqn_t c_eqn;
   v3d_blend_mul_t c_src;
   v3d_blend_mul_t c_dst;
   v3d_blend_vg_mode_t vg_mode;
} V3D_CL_BLEND_CFG_T;
typedef struct
{
   float r;
   float g;
   float b;
   float a;
} V3D_CL_BLEND_CCOLOR_T;
typedef struct
{
   bool disable_r;
   bool disable_g;
   bool disable_b;
   bool disable_a;
} V3D_CL_COLOR_WMASKS_ELEM_T;
typedef V3D_CL_COLOR_WMASKS_ELEM_T V3D_CL_COLOR_WMASKS_T[8];
typedef struct
{
   uint32_t offset;
   v3d_flags_action_t lower_action;
   v3d_flags_action_t higher_action;
   uint32_t flags;
} V3D_CL_VARY_FLAGS_T;
typedef struct
{
   bool front_prims;
   bool back_prims;
   bool cwise_is_front;
   bool depth_offset;
   bool aa_lines;
   v3d_ms_t rast_oversample;
   bool cov_pipe;
   v3d_cov_update_t cov_update;
   bool wireframe_tris;
   v3d_compare_func_t depth_test;
   bool depth_update;
   bool ez;
   bool ez_update;
   bool stencil;
   bool blend;
   v3d_wireframe_mode_t wireframe_mode;
   bool d3d_prov_vtx;
} V3D_CL_CFG_BITS_T;
typedef struct
{
   float factor;
   float units;
} V3D_CL_DEPTH_OFFSET_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
   uint32_t width;
   uint32_t height;
} V3D_CL_CLIP_T;
typedef struct
{
   int32_t x;
   int32_t y;
} V3D_CL_VIEWPORT_OFFSET_T;
typedef struct
{
   float min;
   float max;
} V3D_CL_CLIPZ_T;
typedef struct
{
   float scale_x;
   float scale_y;
} V3D_CL_CLIPPER_XY_T;
typedef struct
{
   float scale;
   float offset;
} V3D_CL_CLIPPER_Z_T;
typedef struct
{
   bool auto_init_tile_state;
   v3d_tile_alloc_block_size_t tile_alloc_initial_block_size;
   v3d_tile_alloc_block_size_t tile_alloc_block_size;
   v3d_addr_t tile_state_addr;
   uint32_t w_in_tiles;
   uint32_t h_in_tiles;
   uint32_t num_rts;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
} V3D_CL_TILE_BINNING_MODE_CFG_PART1_T;
typedef struct
{
   uint32_t tile_alloc_size;
   v3d_addr_t tile_alloc_addr;
} V3D_CL_TILE_BINNING_MODE_CFG_PART2_T;
typedef union
{
   V3D_CL_TILE_BINNING_MODE_CFG_PART1_T part1;
   V3D_CL_TILE_BINNING_MODE_CFG_PART2_T part2;
} V3D_CL_TILE_BINNING_MODE_CFG_U_T;
typedef struct
{
   v3d_bcfg_type_t type;
   V3D_CL_TILE_BINNING_MODE_CFG_U_T u;
} V3D_CL_TILE_BINNING_MODE_CFG_T;
typedef struct
{
   uint32_t num_rts;
   uint32_t frame_width;
   uint32_t frame_height;
   v3d_rt_bpp_t max_bpp;
   bool ms_mode;
   bool double_buffer;
   bool cov_mode;
   v3d_ez_direction_t ez_direction;
   bool ez_disable;
   bool stencil_store;
   bool depth_store;
   uint32_t disable_rt_store_mask;
} V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T;
typedef struct
{
   v3d_depth_type_t internal_type;
   v3d_decimate_t decimate_mode;
   v3d_depth_format_t output_format;
   v3d_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_T;
typedef struct
{
   v3d_decimate_t decimate_mode;
   v3d_memory_format_t memory_format;
   uint32_t uif_height_in_ub;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_T;
typedef struct
{
   uint32_t rt;
   v3d_rt_bpp_t internal_bpp;
   v3d_rt_type_t internal_type;
   v3d_decimate_t decimate_mode;
   v3d_pixel_format_t output_format;
   v3d_dither_t dither_mode;
   v3d_memory_format_t memory_format;
   bool flipy;
   uint32_t pad;
   v3d_addr_t addr;
} V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T;
typedef struct
{
   uint32_t stencil_clear;
   float depth_clear;
} V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_0;
   uint32_t clear_col_1_andm24;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_1_shift24;
   uint32_t clear_col_2;
   uint32_t clear_col_3_andm16;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T;
typedef struct
{
   uint32_t rt;
   uint32_t clear_col_3_shift16;
   uint32_t raster_padded_width_or_nonraster_height;
   uint32_t uif_height_in_ub;
} V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T;
typedef union
{
   V3D_CL_TILE_RENDERING_MODE_CFG_COMMON_T common;
   V3D_CL_TILE_RENDERING_MODE_CFG_Z_STENCIL_T z_stencil;
   V3D_CL_TILE_RENDERING_MODE_CFG_SEPARATE_STENCIL_T separate_stencil;
   V3D_CL_TILE_RENDERING_MODE_CFG_COLOR_T color;
   V3D_CL_TILE_RENDERING_MODE_CFG_ZS_CLEAR_VALUES_T zs_clear_values;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART1_T clear_colors_part1;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART2_T clear_colors_part2;
   V3D_CL_TILE_RENDERING_MODE_CFG_CLEAR_COLORS_PART3_T clear_colors_part3;
} V3D_CL_TILE_RENDERING_MODE_CFG_U_T;
typedef struct
{
   v3d_rcfg_type_t type;
   V3D_CL_TILE_RENDERING_MODE_CFG_U_T u;
} V3D_CL_TILE_RENDERING_MODE_CFG_T;
typedef struct
{
   uint32_t supertile_w_in_tiles;
   uint32_t supertile_h_in_tiles;
   uint32_t frame_w_in_supertiles;
   uint32_t frame_h_in_supertiles;
   uint32_t frame_w_in_tiles;
   uint32_t frame_h_in_tiles;
   bool multicore;
   v3d_supertile_order_t supertile_order;
} V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T;
typedef struct
{
   uint32_t set;
   v3d_addr_t addr;
} V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T;
typedef struct
{
   uint32_t x;
   uint32_t y;
} V3D_CL_TILE_COORDS_T;
typedef struct
{
   v3d_tile_alloc_block_size_t block_size;
   bool chain;
} V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T;
static inline void v3d_cl_wait_transform_feedback_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_WAIT_TRANSFORM_FEEDBACK);
   (*cl)[0] = (uint8_t)gfx_bits(*unpacked, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_sub_autochain_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB_AUTOCHAIN);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_sub_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_SUB);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_branch_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_generic_tile_list_indirect(uint8_t **cl, const V3D_CL_GENERIC_TILE_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GENERIC_TILE_LIST);
   (*cl)[0] = (uint8_t)(*unpacked).addr;
   (*cl)[1] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).addr >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).end;
   (*cl)[5] = (uint8_t)((*unpacked).end >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).end >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).end >> 24);
   *cl += 8;
}
static inline void v3d_cl_branch_implicit_tile_indirect(uint8_t **cl, const uint32_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_IMPLICIT_TILE);
   (*cl)[0] = (uint8_t)gfx_bits(*unpacked, 8);
   *cl += 1;
}
static inline void v3d_cl_branch_explicit_supertile_indirect(uint8_t **cl, const V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BRANCH_EXPLICIT_SUPERTILE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).supertile, 8);
   (*cl)[3] = (uint8_t)(*unpacked).addr;
   (*cl)[4] = (uint8_t)((*unpacked).addr >> 8);
   (*cl)[5] = (uint8_t)((*unpacked).addr >> 16);
   (*cl)[6] = (uint8_t)((*unpacked).addr >> 24);
   *cl += 7;
}
static inline void v3d_cl_supertile_coords_indirect(uint8_t **cl, const V3D_CL_SUPERTILE_COORDS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SUPERTILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).y, 8);
   *cl += 2;
}
static inline void v3d_cl_store_subsample_ex_indirect(uint8_t **cl, const V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_SUBSAMPLE_EX);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_owo_or_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).stencil_store, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_store, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_store_mask, 8);
   *cl += 2;
}
static inline void v3d_cl_load_indirect(uint8_t **cl, const V3D_CL_LOAD_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD);
   (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).stencil_load, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).depth_load, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).disable_rt_load_mask, 8);
   *cl += 2;
}
static inline void v3d_cl_store_general_indirect(uint8_t **cl, const V3D_CL_STORE_GENERAL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STORE_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).disable_depth_clear, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).disable_stencil_clear, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).disable_color_clear, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).eof, 1) |
      (uint8_t)(gfx_bits((*unpacked).disable_double_buf_swap, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
   *cl += 6;
}
static inline void v3d_cl_load_general_indirect(uint8_t **cl, const V3D_CL_LOAD_GENERAL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LOAD_GENERAL);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).buffer, 4) |
      (uint8_t)(gfx_bits((*unpacked).raw_mode, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).memory_format, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) << 3);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).uif_height_in_ub, 13) >> 5);
   (*cl)[3] = (uint8_t)gfx_exact_lsr((*unpacked).addr, 8);
   (*cl)[4] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 8);
   (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 8) >> 16);
   *cl += 6;
}
static inline void v3d_cl_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)(*unpacked).num_indices;
   (*cl)[2] = (uint8_t)((*unpacked).num_indices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_indices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_indices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   (*cl)[10] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   (*cl)[11] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   (*cl)[12] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[13] = (uint8_t)(*unpacked).min_index;
   (*cl)[14] = (uint8_t)((*unpacked).min_index >> 8);
   (*cl)[15] = (uint8_t)((*unpacked).min_index >> 16);
   (*cl)[16] = (uint8_t)((*unpacked).min_index >> 24);
   *cl += 17;
}
static inline void v3d_cl_indirect_indexed_prim_list_indirect(uint8_t **cl, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_INDEXED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff);
   (*cl)[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 8);
   (*cl)[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 16);
   (*cl)[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0x7fffffff) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   (*cl)[5] = (uint8_t)(*unpacked).indirect_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
   *cl += 14;
}
static inline void v3d_cl_indexed_instanced_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_INSTANCED_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)(*unpacked).num_indices;
   (*cl)[2] = (uint8_t)((*unpacked).num_indices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_indices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_indices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).num_instances;
   (*cl)[6] = (uint8_t)((*unpacked).num_instances >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).num_instances >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).num_instances >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   *cl += 17;
}
static inline void v3d_cl_indexed_single_instance_prim_list_indirect(uint8_t **cl, const V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) |
      (uint8_t)(gfx_bits((*unpacked).index_type, 2) << 6);
   (*cl)[1] = (uint8_t)(*unpacked).num_indices;
   (*cl)[2] = (uint8_t)((*unpacked).num_indices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_indices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_indices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).instance_id;
   (*cl)[6] = (uint8_t)((*unpacked).instance_id >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).instance_id >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).instance_id >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).indices_addr;
   (*cl)[10] = (uint8_t)((*unpacked).indices_addr >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).indices_addr >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).indices_addr >> 24);
   (*cl)[13] = (uint8_t)gfx_bits((*unpacked).max_index, 31);
   (*cl)[14] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 8);
   (*cl)[15] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 16);
   (*cl)[16] = (uint8_t)(gfx_bits((*unpacked).max_index, 31) >> 24) |
      (uint8_t)(gfx_bits((*unpacked).prim_restart, 1) << 7);
   *cl += 17;
}
static inline void v3d_cl_vertex_array_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).first_index;
   (*cl)[6] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 9;
}
static inline void v3d_cl_indirect_vertex_array_prims_indirect(uint8_t **cl, const V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff);
   (*cl)[2] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 8);
   (*cl)[3] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 16);
   (*cl)[4] =
      (uint8_t)(gfx_check_urange((*unpacked).num_indirect, 1, 0xffffffff) >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).indirect_addr;
   (*cl)[6] = (uint8_t)((*unpacked).indirect_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).indirect_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).indirect_addr >> 24);
   (*cl)[9] = (uint8_t)gfx_bits(gfx_exact_lsr((*unpacked).indirect_stride, 2), 8);
   *cl += 10;
}
static inline void v3d_cl_vertex_array_instanced_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).num_instances;
   (*cl)[6] = (uint8_t)((*unpacked).num_instances >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).num_instances >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).num_instances >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).first_index;
   (*cl)[10] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_vertex_array_single_instance_prims_indirect(uint8_t **cl, const V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 6) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).instance_id;
   (*cl)[6] = (uint8_t)((*unpacked).instance_id >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).instance_id >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).instance_id >> 24);
   (*cl)[9] = (uint8_t)(*unpacked).first_index;
   (*cl)[10] = (uint8_t)((*unpacked).first_index >> 8);
   (*cl)[11] = (uint8_t)((*unpacked).first_index >> 16);
   (*cl)[12] = (uint8_t)((*unpacked).first_index >> 24);
   *cl += 13;
}
static inline void v3d_cl_base_vertex_base_instance_indirect(uint8_t **cl, const V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BASE_VERTEX_BASE_INSTANCE);
   (*cl)[0] = (uint8_t)(uint32_t)(*unpacked).base_vertex;
   (*cl)[1] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)(*unpacked).base_vertex >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).base_instance;
   (*cl)[5] = (uint8_t)((*unpacked).base_instance >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).base_instance >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).base_instance >> 24);
   *cl += 8;
}
static inline void v3d_cl_indirect_primitive_limits_indirect(uint8_t **cl, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_INDIRECT_PRIMITIVE_LIMITS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).max_index, 24);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 8);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).max_index, 24) >> 16);
   (*cl)[3] = (uint8_t)(*unpacked).max_instance;
   (*cl)[4] = (uint8_t)((*unpacked).max_instance >> 8);
   (*cl)[5] = (uint8_t)((*unpacked).max_instance >> 16);
   (*cl)[6] = (uint8_t)((*unpacked).max_instance >> 24);
   (*cl)[7] = (uint8_t)(*unpacked).index_buffer_size;
   (*cl)[8] = (uint8_t)((*unpacked).index_buffer_size >> 8);
   (*cl)[9] = (uint8_t)((*unpacked).index_buffer_size >> 16);
   (*cl)[10] = (uint8_t)((*unpacked).index_buffer_size >> 24);
   *cl += 11;
}
static inline void v3d_cl_vg_coord_array_prims_indirect(uint8_t **cl, const V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_COORD_ARRAY_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
   (*cl)[1] = (uint8_t)(*unpacked).num_vertices;
   (*cl)[2] = (uint8_t)((*unpacked).num_vertices >> 8);
   (*cl)[3] = (uint8_t)((*unpacked).num_vertices >> 16);
   (*cl)[4] = (uint8_t)((*unpacked).num_vertices >> 24);
   (*cl)[5] = (uint8_t)(*unpacked).coords_addr;
   (*cl)[6] = (uint8_t)((*unpacked).coords_addr >> 8);
   (*cl)[7] = (uint8_t)((*unpacked).coords_addr >> 16);
   (*cl)[8] = (uint8_t)((*unpacked).coords_addr >> 24);
   *cl += 9;
}
static inline void v3d_cl_vg_inline_prims_indirect(uint8_t **cl, const V3D_CL_VG_INLINE_PRIMS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_PRIMS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_mode, 4) |
      (uint8_t)(gfx_bits((*unpacked).continuation, 1) << 4) | (uint8_t)0;
   *cl += 1;
}
static inline void v3d_cl_clipped_prim_iid_zero_indirect(uint8_t **cl, const V3D_CL_CLIPPED_PRIM_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_IID_ZERO);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).clip[0], 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[1], 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[2], 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).flat_zw, 1) << 3) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_clipped_prim_current_iid_indirect(uint8_t **cl, const V3D_CL_CLIPPED_PRIM_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPED_PRIM_CURRENT_IID);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).clip[0], 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[1], 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).clip[2], 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).flat_zw, 1) << 3) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_prim_list_format_indirect(uint8_t **cl, const V3D_CL_PRIM_LIST_FORMAT_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_PRIM_LIST_FORMAT);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).prim_type, 6) |
      (uint8_t)(gfx_bits((*unpacked).xy, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).d3dpvsf, 1) << 7);
   *cl += 1;
}
static inline void v3d_cl_gl_tg_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_TG_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_g_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_G_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_t_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_T_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_nv_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_NV_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_gl_shader_indirect(uint8_t **cl, const V3D_CL_GL_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_GL_SHADER);
   (*cl)[0] = (uint8_t)gfx_pack_uint_0_is_max((*unpacked).num_attr_arrays, 5) |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) << 5);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 3);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 11);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 5) >> 19);
   *cl += 4;
}
static inline void v3d_cl_vg_shader_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_SHADER);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_vg_inline_shader_indirect(uint8_t **cl, const V3D_CL_VG_INLINE_SHADER_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VG_INLINE_SHADER);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).fs.threading, 2) |
      (uint8_t)(gfx_bits((*unpacked).fs.propagate_nans, 1) << 2) |
      (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) << 3);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 5);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 13);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).fs.addr, 3) >> 21);
   (*cl)[4] = (uint8_t)(*unpacked).fs.unifs_addr;
   (*cl)[5] = (uint8_t)((*unpacked).fs.unifs_addr >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).fs.unifs_addr >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).fs.unifs_addr >> 24);
   *cl += 8;
}
static inline void v3d_cl_vcm_cache_size_indirect(uint8_t **cl, const V3D_CL_VCM_CACHE_SIZE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VCM_CACHE_SIZE);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).num_batches_bin, 1, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_batches_render, 1, 4) << 4);
   *cl += 1;
}
static inline void v3d_cl_transform_feedback_enable_indirect(uint8_t **cl, const V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TRANSFORM_FEEDBACK_ENABLE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).id, 8);
   (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).num_addrs, 0, 4) |
      (uint8_t)(gfx_check_urange((*unpacked).num_specs, 1, 16) << 3);
   *cl += 2;
}
static inline void v3d_cl_l1_cache_flush_control_indirect(uint8_t **cl, const V3D_CL_L1_CACHE_FLUSH_CONTROL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_L1_CACHE_FLUSH_CONTROL);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).icache_clear_slice_0, 1) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_1, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_2, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).icache_clear_slice_3, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_0, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_1, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_2, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).ucache_clear_slice_3, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).tmu_data_cache_clear_0, 1) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_1, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_2, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).tmu_data_cache_clear_3, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_0, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_1, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_2, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked).tmu_config_cache_clear_3, 1) << 7);
   *cl += 2;
}
static inline void v3d_cl_l2t_cache_flush_control_indirect(uint8_t **cl, const V3D_CL_L2T_CACHE_FLUSH_CONTROL_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_L2T_CACHE_FLUSH_CONTROL);
   (*cl)[0] = (uint8_t)(*unpacked).l2t_flush_start_address;
   (*cl)[1] = (uint8_t)((*unpacked).l2t_flush_start_address >> 8);
   (*cl)[2] = (uint8_t)((*unpacked).l2t_flush_start_address >> 16);
   (*cl)[3] = (uint8_t)((*unpacked).l2t_flush_start_address >> 24);
   (*cl)[4] = (uint8_t)(*unpacked).l2t_flush_end_address;
   (*cl)[5] = (uint8_t)((*unpacked).l2t_flush_end_address >> 8);
   (*cl)[6] = (uint8_t)((*unpacked).l2t_flush_end_address >> 16);
   (*cl)[7] = (uint8_t)((*unpacked).l2t_flush_end_address >> 24);
   (*cl)[8] = (uint8_t)gfx_bits((*unpacked).l2t_flush_mode, 2) | (uint8_t)0;
   *cl += 9;
}
static inline void v3d_cl_stencil_cfg_indirect(uint8_t **cl, const V3D_CL_STENCIL_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_STENCIL_CFG);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).reference, 8);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).mask, 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).func, 3) |
      (uint8_t)(gfx_bits((*unpacked).fail_op, 3) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) << 6);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).depth_fail_op, 3) >> 2) |
      (uint8_t)(gfx_bits((*unpacked).pass_op, 3) << 1) |
      (uint8_t)(gfx_bits((*unpacked).front_cfg, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).back_cfg, 1) << 5) | (uint8_t)0;
   (*cl)[4] = (uint8_t)gfx_bits((*unpacked).write_mask, 8);
   *cl += 5;
}
static inline void v3d_cl_blend_cfg_indirect(uint8_t **cl, const V3D_CL_BLEND_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CFG);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).a_eqn, 4) |
      (uint8_t)(gfx_bits((*unpacked).a_src, 4) << 4);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).a_dst, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_eqn, 4) << 4);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).c_src, 4) |
      (uint8_t)(gfx_bits((*unpacked).c_dst, 4) << 4);
   (*cl)[3] = (uint8_t)0 | (uint8_t)(gfx_bits((*unpacked).vg_mode, 2) << 4) |
      (uint8_t)0;
   *cl += 4;
}
static inline void v3d_cl_blend_ccolor_indirect(uint8_t **cl, const V3D_CL_BLEND_CCOLOR_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_BLEND_CCOLOR);
   (*cl)[0] = (uint8_t)gfx_float_to_float16((*unpacked).r);
   (*cl)[1] = (uint8_t)(gfx_float_to_float16((*unpacked).r) >> 8);
   (*cl)[2] = (uint8_t)gfx_float_to_float16((*unpacked).g);
   (*cl)[3] = (uint8_t)(gfx_float_to_float16((*unpacked).g) >> 8);
   (*cl)[4] = (uint8_t)gfx_float_to_float16((*unpacked).b);
   (*cl)[5] = (uint8_t)(gfx_float_to_float16((*unpacked).b) >> 8);
   (*cl)[6] = (uint8_t)gfx_float_to_float16((*unpacked).a);
   (*cl)[7] = (uint8_t)(gfx_float_to_float16((*unpacked).a) >> 8);
   *cl += 8;
}
static inline void v3d_cl_color_wmasks_indirect(uint8_t **cl, const V3D_CL_COLOR_WMASKS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_COLOR_WMASKS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked)[0].disable_r, 1) |
      (uint8_t)(gfx_bits((*unpacked)[0].disable_g, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked)[0].disable_b, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked)[0].disable_a, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked)[1].disable_r, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked)[1].disable_g, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked)[1].disable_b, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked)[1].disable_a, 1) << 7);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked)[2].disable_r, 1) |
      (uint8_t)(gfx_bits((*unpacked)[2].disable_g, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked)[2].disable_b, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked)[2].disable_a, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked)[3].disable_r, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked)[3].disable_g, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked)[3].disable_b, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked)[3].disable_a, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked)[4].disable_r, 1) |
      (uint8_t)(gfx_bits((*unpacked)[4].disable_g, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked)[4].disable_b, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked)[4].disable_a, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked)[5].disable_r, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked)[5].disable_g, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked)[5].disable_b, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked)[5].disable_a, 1) << 7);
   (*cl)[3] = (uint8_t)gfx_bits((*unpacked)[6].disable_r, 1) |
      (uint8_t)(gfx_bits((*unpacked)[6].disable_g, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked)[6].disable_b, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked)[6].disable_a, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked)[7].disable_r, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked)[7].disable_g, 1) << 5) |
      (uint8_t)(gfx_bits((*unpacked)[7].disable_b, 1) << 6) |
      (uint8_t)(gfx_bits((*unpacked)[7].disable_a, 1) << 7);
   *cl += 4;
}
static inline void v3d_cl_centroid_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CENTROID_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_flatshade_flags_indirect(uint8_t **cl, const V3D_CL_VARY_FLAGS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_FLATSHADE_FLAGS);
   (*cl)[0] = (uint8_t)gfx_check_urange((*unpacked).offset, 0, 2) |
      (uint8_t)(gfx_bits((*unpacked).lower_action, 2) << 4) |
      (uint8_t)(gfx_bits((*unpacked).higher_action, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).flags, 24);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 8);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).flags, 24) >> 16);
   *cl += 4;
}
static inline void v3d_cl_sample_coverage_indirect(uint8_t **cl, const float *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_SAMPLE_COVERAGE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
   *cl += 4;
}
static inline void v3d_cl_occlusion_query_counter_enable_indirect(uint8_t **cl, const v3d_addr_t *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_OCCLUSION_QUERY_COUNTER_ENABLE);
   (*cl)[0] = (uint8_t)*unpacked;
   (*cl)[1] = (uint8_t)(*unpacked >> 8);
   (*cl)[2] = (uint8_t)(*unpacked >> 16);
   (*cl)[3] = (uint8_t)(*unpacked >> 24);
   *cl += 4;
}
static inline void v3d_cl_cfg_bits_indirect(uint8_t **cl, const V3D_CL_CFG_BITS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CFG_BITS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).front_prims, 1) |
      (uint8_t)(gfx_bits((*unpacked).back_prims, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).cwise_is_front, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).depth_offset, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).aa_lines, 1) << 4) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).rast_oversample, 2) << 6);
   (*cl)[1] = (uint8_t)gfx_bits((*unpacked).cov_pipe, 1) |
      (uint8_t)(gfx_bits((*unpacked).cov_update, 2) << 1) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_tris, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).depth_test, 3) << 4) |
      (uint8_t)(gfx_bits((*unpacked).depth_update, 1) << 7);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).ez, 1) |
      (uint8_t)(gfx_bits((*unpacked).ez_update, 1) << 1) |
      (uint8_t)(gfx_bits((*unpacked).stencil, 1) << 2) |
      (uint8_t)(gfx_bits((*unpacked).blend, 1) << 3) |
      (uint8_t)(gfx_bits((*unpacked).wireframe_mode, 1) << 4) |
      (uint8_t)(gfx_bits((*unpacked).d3d_prov_vtx, 1) << 5) | (uint8_t)0;
   *cl += 3;
}
static inline void v3d_cl_point_size_indirect(uint8_t **cl, const float *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_POINT_SIZE);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
   *cl += 4;
}
static inline void v3d_cl_line_width_indirect(uint8_t **cl, const float *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_LINE_WIDTH);
   (*cl)[0] = (uint8_t)gfx_float_to_bits(*unpacked);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits(*unpacked) >> 24);
   *cl += 4;
}
static inline void v3d_cl_depth_offset_indirect(uint8_t **cl, const V3D_CL_DEPTH_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_DEPTH_OFFSET);
   (*cl)[0] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).factor) >> 16 >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).units) >> 16 >> 8);
   *cl += 4;
}
static inline void v3d_cl_clip_indirect(uint8_t **cl, const V3D_CL_CLIP_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIP);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 16);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 16) >> 8);
   (*cl)[2] = (uint8_t)gfx_bits((*unpacked).y, 16);
   (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).y, 16) >> 8);
   (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).width, 1, 0x1000);
   (*cl)[5] = (uint8_t)(gfx_check_urange((*unpacked).width, 1, 0x1000) >> 8);
   (*cl)[6] = (uint8_t)gfx_check_urange((*unpacked).height, 1, 0x1000);
   (*cl)[7] = (uint8_t)(gfx_check_urange((*unpacked).height, 1, 0x1000) >> 8);
   *cl += 8;
}
static inline void v3d_cl_viewport_offset_indirect(uint8_t **cl, const V3D_CL_VIEWPORT_OFFSET_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_VIEWPORT_OFFSET);
   (*cl)[0] = (uint8_t)(uint32_t)(*unpacked).x;
   (*cl)[1] = (uint8_t)((uint32_t)(*unpacked).x >> 8);
   (*cl)[2] = (uint8_t)((uint32_t)(*unpacked).x >> 16);
   (*cl)[3] = (uint8_t)((uint32_t)(*unpacked).x >> 24);
   (*cl)[4] = (uint8_t)(uint32_t)(*unpacked).y;
   (*cl)[5] = (uint8_t)((uint32_t)(*unpacked).y >> 8);
   (*cl)[6] = (uint8_t)((uint32_t)(*unpacked).y >> 16);
   (*cl)[7] = (uint8_t)((uint32_t)(*unpacked).y >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipz_indirect(uint8_t **cl, const V3D_CL_CLIPZ_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPZ);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).min);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).min) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).max);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).max) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_xy_indirect(uint8_t **cl, const V3D_CL_CLIPPER_XY_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_XY);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale_x);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_x) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).scale_y);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).scale_y) >> 24);
   *cl += 8;
}
static inline void v3d_cl_clipper_z_indirect(uint8_t **cl, const V3D_CL_CLIPPER_Z_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_CLIPPER_Z);
   (*cl)[0] = (uint8_t)gfx_float_to_bits((*unpacked).scale);
   (*cl)[1] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 8);
   (*cl)[2] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 16);
   (*cl)[3] = (uint8_t)(gfx_float_to_bits((*unpacked).scale) >> 24);
   (*cl)[4] = (uint8_t)gfx_float_to_bits((*unpacked).offset);
   (*cl)[5] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 8);
   (*cl)[6] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 16);
   (*cl)[7] = (uint8_t)(gfx_float_to_bits((*unpacked).offset) >> 24);
   *cl += 8;
}
static inline void v3d_cl_tile_binning_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_BINNING_MODE_CFG);
   if ((*unpacked).type == V3D_BCFG_TYPE_PART1)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART1);
      (*cl)[0] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.part1.auto_init_tile_state, 1) << 1) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_initial_block_size, 2) <<
         2) | (uint8_t)(gfx_bits((*unpacked).u.part1.tile_alloc_block_size, 2) << 4) |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) << 6);
      (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >> 2);
      (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         10);
      (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part1.tile_state_addr, 6) >>
         18);
      (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff);
      (*cl)[5] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.w_in_tiles, 1, 0xfff) >> 8) |
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) << 4);
      (*cl)[6] =
         (uint8_t)(gfx_check_urange((*unpacked).u.part1.h_in_tiles, 1, 0xfff) >> 4);
      (*cl)[7] = (uint8_t)gfx_check_urange((*unpacked).u.part1.num_rts, 0, 8) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.max_bpp, 2) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.ms_mode, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.part1.double_buffer, 1) << 7);
   }
   else if ((*unpacked).type == V3D_BCFG_TYPE_PART2)
   {
      assert((*unpacked).type == V3D_BCFG_TYPE_PART2);
      (*cl)[0] = (uint8_t)1 | (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) << 6);
      (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >> 2);
      (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         10);
      (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_size, 6) >>
         18);
      (*cl)[4] = (uint8_t)0 |
         (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) << 6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.part2.tile_alloc_addr, 6) >>
         18);
   }
   else
   {
      unreachable();
   }
   *cl += 8;
}
static inline void v3d_cl_tile_rendering_mode_cfg_indirect(uint8_t **cl, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_RENDERING_MODE_CFG);
   if ((*unpacked).type == V3D_RCFG_TYPE_COMMON)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COMMON);
      (*cl)[0] = (uint8_t)0 | (uint8_t)(gfx_pack_uint_minus_1(
         gfx_check_urange((*unpacked).u.common.num_rts, 1, 8), 4) << 4);
      (*cl)[1] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff);
      (*cl)[2] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_width, 1,
         0xffff) >> 8);
      (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff);
      (*cl)[4] = (uint8_t)(gfx_check_urange((*unpacked).u.common.frame_height, 1,
         0xffff) >> 8);
      (*cl)[5] = (uint8_t)gfx_bits((*unpacked).u.common.max_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ms_mode, 1) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.common.double_buffer, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.common.cov_mode, 1) << 4) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_direction, 1) << 5) |
         (uint8_t)(gfx_bits((*unpacked).u.common.ez_disable, 1) << 6) | (uint8_t)0;
      (*cl)[6] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.common.stencil_store, 1) << 6) |
         (uint8_t)(gfx_bits((*unpacked).u.common.depth_store, 1) << 7);
      (*cl)[7] = (uint8_t)gfx_bits((*unpacked).u.common.disable_rt_store_mask, 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_Z_STENCIL);
      (*cl)[0] = (uint8_t)1 | (uint8_t)0;
      (*cl)[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)gfx_bits((*unpacked).u.z_stencil.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) << 6);
      (*cl)[3] = (uint8_t)(gfx_bits((*unpacked).u.z_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) << 1);
      (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).u.z_stencil.uif_height_in_ub, 13) >>
         7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) << 6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.z_stencil.addr, 6) >> 18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_SEPARATE_STENCIL);
      (*cl)[0] = (uint8_t)1 | (uint8_t)(1 << 4);
      (*cl)[1] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)0 |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) << 6);
      (*cl)[3] =
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.memory_format, 3) >> 2) |
         (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub, 13) << 1);
      (*cl)[4] = (uint8_t)(gfx_bits((*unpacked).u.separate_stencil.uif_height_in_ub,
         13) >> 7) | (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) <<
         6);
      (*cl)[5] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >> 2);
      (*cl)[6] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         10);
      (*cl)[7] = (uint8_t)(gfx_exact_lsr((*unpacked).u.separate_stencil.addr, 6) >>
         18);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_COLOR)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_COLOR);
      (*cl)[0] = (uint8_t)2 |
         (uint8_t)(gfx_check_urange((*unpacked).u.color.rt, 0, 7) << 4);
      (*cl)[1] = (uint8_t)gfx_bits((*unpacked).u.color.internal_bpp, 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.internal_type, 4) << 2) |
         (uint8_t)(gfx_bits((*unpacked).u.color.decimate_mode, 2) << 6);
      (*cl)[2] = (uint8_t)gfx_bits((*unpacked).u.color.output_format, 6) |
         (uint8_t)(gfx_bits((*unpacked).u.color.dither_mode, 2) << 6);
      (*cl)[3] = (uint8_t)gfx_bits((*unpacked).u.color.memory_format, 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.flipy, 1) << 3) |
         (uint8_t)(gfx_bits((*unpacked).u.color.pad, 4) << 4);
      (*cl)[4] = (uint8_t)(*unpacked).u.color.addr;
      (*cl)[5] = (uint8_t)((*unpacked).u.color.addr >> 8);
      (*cl)[6] = (uint8_t)((*unpacked).u.color.addr >> 16);
      (*cl)[7] = (uint8_t)((*unpacked).u.color.addr >> 24);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_ZS_CLEAR_VALUES);
      (*cl)[0] = (uint8_t)3 | (uint8_t)0;
      (*cl)[1] = (uint8_t)gfx_bits((*unpacked).u.zs_clear_values.stencil_clear, 8);
      (*cl)[2] = (uint8_t)gfx_float_to_bits((*unpacked).u.zs_clear_values.depth_clear);
      (*cl)[3] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 8);
      (*cl)[4] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 16);
      (*cl)[5] = (uint8_t)(gfx_float_to_bits(
         (*unpacked).u.zs_clear_values.depth_clear) >> 24);
      (*cl)[6] = (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART1);
      (*cl)[0] = (uint8_t)4 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part1.rt, 0, 7) << 4);
      (*cl)[1] = (uint8_t)(*unpacked).u.clear_colors_part1.clear_col_0;
      (*cl)[2] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 8);
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 16);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part1.clear_col_0 >> 24);
      (*cl)[5] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24);
      (*cl)[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 8);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part1.clear_col_1_andm24, 24) >> 16);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART2);
      (*cl)[0] = (uint8_t)5 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part2.rt, 0, 7) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_1_shift24, 8);
      (*cl)[2] = (uint8_t)(*unpacked).u.clear_colors_part2.clear_col_2;
      (*cl)[3] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 8);
      (*cl)[4] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 16);
      (*cl)[5] = (uint8_t)((*unpacked).u.clear_colors_part2.clear_col_2 >> 24);
      (*cl)[6] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16);
      (*cl)[7] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part2.clear_col_3_andm16, 16) >> 8);
   }
   else if ((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3)
   {
      assert((*unpacked).type == V3D_RCFG_TYPE_CLEAR_COLORS_PART3);
      (*cl)[0] = (uint8_t)6 |
         (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.rt, 0, 7) << 4);
      (*cl)[1] = (uint8_t)gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16);
      (*cl)[2] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.clear_col_3_shift16, 16) >> 8);
      (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff);
      (*cl)[4] = (uint8_t)(gfx_check_urange((*unpacked).u.clear_colors_part3.
         raster_padded_width_or_nonraster_height, 0, 0x1fff) >> 8);
      (*cl)[5] = (uint8_t)gfx_bits((*unpacked).u.clear_colors_part3.uif_height_in_ub,
         13);
      (*cl)[6] = (uint8_t)(gfx_bits(
         (*unpacked).u.clear_colors_part3.uif_height_in_ub, 13) >> 8) | (uint8_t)0;
      (*cl)[7] = (uint8_t)0;
   }
   else
   {
      unreachable();
   }
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_supertile_cfg_indirect(uint8_t **cl, const V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG);
   (*cl)[0] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_w_in_tiles, 8);
   (*cl)[1] = (uint8_t)gfx_pack_uint_minus_1((*unpacked).supertile_h_in_tiles, 8);
   (*cl)[2] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_supertiles, 1, 255);
   (*cl)[3] = (uint8_t)gfx_check_urange((*unpacked).frame_h_in_supertiles, 1, 255);
   (*cl)[4] = (uint8_t)gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff);
   (*cl)[5] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_w_in_tiles, 1, 0xfff) >> 8) |
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) << 4);
   (*cl)[6] =
      (uint8_t)(gfx_check_urange((*unpacked).frame_h_in_tiles, 1, 0xfff) >> 4);
   (*cl)[7] = (uint8_t)gfx_bits((*unpacked).multicore, 1) | (uint8_t)0 |
      (uint8_t)(gfx_bits((*unpacked).supertile_order, 1) << 4) | (uint8_t)0;
   *cl += 8;
}
static inline void v3d_cl_multicore_rendering_tile_list_base_indirect(uint8_t **cl, const V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).set, 4) | (uint8_t)0 |
      (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) << 6);
   (*cl)[1] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 2);
   (*cl)[2] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 10);
   (*cl)[3] = (uint8_t)(gfx_exact_lsr((*unpacked).addr, 6) >> 18);
   *cl += 4;
}
static inline void v3d_cl_tile_coords_indirect(uint8_t **cl, const V3D_CL_TILE_COORDS_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_COORDS);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).x, 12);
   (*cl)[1] = (uint8_t)(gfx_bits((*unpacked).x, 12) >> 8) |
      (uint8_t)(gfx_bits((*unpacked).y, 12) << 4);
   (*cl)[2] = (uint8_t)(gfx_bits((*unpacked).y, 12) >> 4);
   *cl += 3;
}
static inline void v3d_cl_tile_list_initial_block_size_indirect(uint8_t **cl, const V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked)
{
   v3d_cl_add_8(cl, V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE);
   (*cl)[0] = (uint8_t)gfx_bits((*unpacked).block_size, 2) |
      (uint8_t)(gfx_bits((*unpacked).chain, 1) << 2) | (uint8_t)0;
   *cl += 1;
}
extern void v3d_cl_pack_wait_transform_feedback(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_wait_transform_feedback(uint32_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_branch(v3d_addr_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_generic_tile_list(uint8_t *packed, const V3D_CL_GENERIC_TILE_LIST_T *unpacked);
extern void v3d_cl_unpack_generic_tile_list(V3D_CL_GENERIC_TILE_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch_implicit_tile(uint8_t *packed, const uint32_t *unpacked);
extern void v3d_cl_unpack_branch_implicit_tile(uint32_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_branch_explicit_supertile(uint8_t *packed, const V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked);
extern void v3d_cl_unpack_branch_explicit_supertile(V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_supertile_coords(uint8_t *packed, const V3D_CL_SUPERTILE_COORDS_T *unpacked);
extern void v3d_cl_unpack_supertile_coords(V3D_CL_SUPERTILE_COORDS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_store_subsample_ex(uint8_t *packed, const V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked);
extern void v3d_cl_unpack_store_subsample_ex(V3D_CL_STORE_SUBSAMPLE_EX_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_load(uint8_t *packed, const V3D_CL_LOAD_T *unpacked);
extern void v3d_cl_unpack_load(V3D_CL_LOAD_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_store_general(uint8_t *packed, const V3D_CL_STORE_GENERAL_T *unpacked);
extern void v3d_cl_unpack_store_general(V3D_CL_STORE_GENERAL_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_load_general(uint8_t *packed, const V3D_CL_LOAD_GENERAL_T *unpacked);
extern void v3d_cl_unpack_load_general(V3D_CL_LOAD_GENERAL_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indexed_prim_list(uint8_t *packed, const V3D_CL_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_prim_list(V3D_CL_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indirect_indexed_prim_list(uint8_t *packed, const V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indirect_indexed_prim_list(V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indexed_instanced_prim_list(uint8_t *packed, const V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_instanced_prim_list(V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indexed_single_instance_prim_list(uint8_t *packed, const V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_T *unpacked);
extern void v3d_cl_unpack_indexed_single_instance_prim_list(V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vertex_array_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_prims(V3D_CL_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indirect_vertex_array_prims(uint8_t *packed, const V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_indirect_vertex_array_prims(V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vertex_array_instanced_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_instanced_prims(V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vertex_array_single_instance_prims(uint8_t *packed, const V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vertex_array_single_instance_prims(V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_base_vertex_base_instance(uint8_t *packed, const V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked);
extern void v3d_cl_unpack_base_vertex_base_instance(V3D_CL_BASE_VERTEX_BASE_INSTANCE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_indirect_primitive_limits(uint8_t *packed, const V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked);
extern void v3d_cl_unpack_indirect_primitive_limits(V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vg_coord_array_prims(uint8_t *packed, const V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vg_coord_array_prims(V3D_CL_VG_COORD_ARRAY_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vg_inline_prims(uint8_t *packed, const V3D_CL_VG_INLINE_PRIMS_T *unpacked);
extern void v3d_cl_unpack_vg_inline_prims(V3D_CL_VG_INLINE_PRIMS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipped_prim(uint8_t *packed, const V3D_CL_CLIPPED_PRIM_T *unpacked);
extern void v3d_cl_unpack_clipped_prim(V3D_CL_CLIPPED_PRIM_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_prim_list_format(uint8_t *packed, const V3D_CL_PRIM_LIST_FORMAT_T *unpacked);
extern void v3d_cl_unpack_prim_list_format(V3D_CL_PRIM_LIST_FORMAT_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_gl_shader(uint8_t *packed, const V3D_CL_GL_SHADER_T *unpacked);
extern void v3d_cl_unpack_gl_shader(V3D_CL_GL_SHADER_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vg_shader(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_vg_shader(v3d_addr_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vg_inline_shader(uint8_t *packed, const V3D_CL_VG_INLINE_SHADER_T *unpacked);
extern void v3d_cl_unpack_vg_inline_shader(V3D_CL_VG_INLINE_SHADER_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vcm_cache_size(uint8_t *packed, const V3D_CL_VCM_CACHE_SIZE_T *unpacked);
extern void v3d_cl_unpack_vcm_cache_size(V3D_CL_VCM_CACHE_SIZE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_transform_feedback_enable(uint8_t *packed, const V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked);
extern void v3d_cl_unpack_transform_feedback_enable(V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_l1_cache_flush_control(uint8_t *packed, const V3D_CL_L1_CACHE_FLUSH_CONTROL_T *unpacked);
extern void v3d_cl_unpack_l1_cache_flush_control(V3D_CL_L1_CACHE_FLUSH_CONTROL_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_l2t_cache_flush_control(uint8_t *packed, const V3D_CL_L2T_CACHE_FLUSH_CONTROL_T *unpacked);
extern void v3d_cl_unpack_l2t_cache_flush_control(V3D_CL_L2T_CACHE_FLUSH_CONTROL_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_stencil_cfg(uint8_t *packed, const V3D_CL_STENCIL_CFG_T *unpacked);
extern void v3d_cl_unpack_stencil_cfg(V3D_CL_STENCIL_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_blend_cfg(uint8_t *packed, const V3D_CL_BLEND_CFG_T *unpacked);
extern void v3d_cl_unpack_blend_cfg(V3D_CL_BLEND_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_blend_ccolor(uint8_t *packed, const V3D_CL_BLEND_CCOLOR_T *unpacked);
extern void v3d_cl_unpack_blend_ccolor(V3D_CL_BLEND_CCOLOR_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_color_wmasks(uint8_t *packed, const V3D_CL_COLOR_WMASKS_T *unpacked);
extern void v3d_cl_unpack_color_wmasks(V3D_CL_COLOR_WMASKS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_vary_flags(uint8_t *packed, const V3D_CL_VARY_FLAGS_T *unpacked);
extern void v3d_cl_unpack_vary_flags(V3D_CL_VARY_FLAGS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_sample_coverage(uint8_t *packed, const float *unpacked);
extern void v3d_cl_unpack_sample_coverage(float *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_occlusion_query_counter_enable(uint8_t *packed, const v3d_addr_t *unpacked);
extern void v3d_cl_unpack_occlusion_query_counter_enable(v3d_addr_t *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_cfg_bits(uint8_t *packed, const V3D_CL_CFG_BITS_T *unpacked);
extern void v3d_cl_unpack_cfg_bits(V3D_CL_CFG_BITS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_point_size(uint8_t *packed, const float *unpacked);
extern void v3d_cl_unpack_point_size(float *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_line_width(uint8_t *packed, const float *unpacked);
extern void v3d_cl_unpack_line_width(float *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_depth_offset(uint8_t *packed, const V3D_CL_DEPTH_OFFSET_T *unpacked);
extern void v3d_cl_unpack_depth_offset(V3D_CL_DEPTH_OFFSET_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clip(uint8_t *packed, const V3D_CL_CLIP_T *unpacked);
extern void v3d_cl_unpack_clip(V3D_CL_CLIP_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_viewport_offset(uint8_t *packed, const V3D_CL_VIEWPORT_OFFSET_T *unpacked);
extern void v3d_cl_unpack_viewport_offset(V3D_CL_VIEWPORT_OFFSET_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipz(uint8_t *packed, const V3D_CL_CLIPZ_T *unpacked);
extern void v3d_cl_unpack_clipz(V3D_CL_CLIPZ_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipper_xy(uint8_t *packed, const V3D_CL_CLIPPER_XY_T *unpacked);
extern void v3d_cl_unpack_clipper_xy(V3D_CL_CLIPPER_XY_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_clipper_z(uint8_t *packed, const V3D_CL_CLIPPER_Z_T *unpacked);
extern void v3d_cl_unpack_clipper_z(V3D_CL_CLIPPER_Z_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_binning_mode_cfg(uint8_t *packed, const V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_binning_mode_cfg(V3D_CL_TILE_BINNING_MODE_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_rendering_mode_cfg(uint8_t *packed, const V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked);
extern void v3d_cl_unpack_tile_rendering_mode_cfg(V3D_CL_TILE_RENDERING_MODE_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_multicore_rendering_supertile_cfg(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked);
extern void v3d_cl_unpack_multicore_rendering_supertile_cfg(V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_multicore_rendering_tile_list_base(uint8_t *packed, const V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked);
extern void v3d_cl_unpack_multicore_rendering_tile_list_base(V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_coords(uint8_t *packed, const V3D_CL_TILE_COORDS_T *unpacked);
extern void v3d_cl_unpack_tile_coords(V3D_CL_TILE_COORDS_T *unpacked, const uint8_t *packed);
extern void v3d_cl_pack_tile_list_initial_block_size(uint8_t *packed, const V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked);
extern void v3d_cl_unpack_tile_list_initial_block_size(V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T *unpacked, const uint8_t *packed);
typedef struct {
   v3d_cl_opcode_t opcode;
   union {
      uint32_t wait_transform_feedback;
      v3d_addr_t branch;
      V3D_CL_GENERIC_TILE_LIST_T generic_tile_list;
      uint32_t branch_implicit_tile;
      V3D_CL_BRANCH_EXPLICIT_SUPERTILE_T branch_explicit_supertile;
      V3D_CL_SUPERTILE_COORDS_T supertile_coords;
      V3D_CL_STORE_SUBSAMPLE_EX_T store_subsample_ex;
      V3D_CL_LOAD_T load;
      V3D_CL_STORE_GENERAL_T store_general;
      V3D_CL_LOAD_GENERAL_T load_general;
      V3D_CL_INDEXED_PRIM_LIST_T indexed_prim_list;
      V3D_CL_INDIRECT_INDEXED_PRIM_LIST_T indirect_indexed_prim_list;
      V3D_CL_INDEXED_INSTANCED_PRIM_LIST_T indexed_instanced_prim_list;
      V3D_CL_INDEXED_SINGLE_INSTANCE_PRIM_LIST_T indexed_single_instance_prim_list;
      V3D_CL_VERTEX_ARRAY_PRIMS_T vertex_array_prims;
      V3D_CL_INDIRECT_VERTEX_ARRAY_PRIMS_T indirect_vertex_array_prims;
      V3D_CL_VERTEX_ARRAY_INSTANCED_PRIMS_T vertex_array_instanced_prims;
      V3D_CL_VERTEX_ARRAY_SINGLE_INSTANCE_PRIMS_T vertex_array_single_instance_prims;
      V3D_CL_BASE_VERTEX_BASE_INSTANCE_T base_vertex_base_instance;
      V3D_CL_INDIRECT_PRIMITIVE_LIMITS_T indirect_primitive_limits;
      V3D_CL_VG_COORD_ARRAY_PRIMS_T vg_coord_array_prims;
      V3D_CL_VG_INLINE_PRIMS_T vg_inline_prims;
      V3D_CL_CLIPPED_PRIM_T clipped_prim;
      V3D_CL_PRIM_LIST_FORMAT_T prim_list_format;
      V3D_CL_GL_SHADER_T gl_shader;
      v3d_addr_t vg_shader;
      V3D_CL_VG_INLINE_SHADER_T vg_inline_shader;
      V3D_CL_VCM_CACHE_SIZE_T vcm_cache_size;
      V3D_CL_TRANSFORM_FEEDBACK_ENABLE_T transform_feedback_enable;
      V3D_CL_L1_CACHE_FLUSH_CONTROL_T l1_cache_flush_control;
      V3D_CL_L2T_CACHE_FLUSH_CONTROL_T l2t_cache_flush_control;
      V3D_CL_STENCIL_CFG_T stencil_cfg;
      V3D_CL_BLEND_CFG_T blend_cfg;
      V3D_CL_BLEND_CCOLOR_T blend_ccolor;
      V3D_CL_COLOR_WMASKS_T color_wmasks;
      V3D_CL_VARY_FLAGS_T vary_flags;
      float sample_coverage;
      v3d_addr_t occlusion_query_counter_enable;
      V3D_CL_CFG_BITS_T cfg_bits;
      float point_size;
      float line_width;
      V3D_CL_DEPTH_OFFSET_T depth_offset;
      V3D_CL_CLIP_T clip;
      V3D_CL_VIEWPORT_OFFSET_T viewport_offset;
      V3D_CL_CLIPZ_T clipz;
      V3D_CL_CLIPPER_XY_T clipper_xy;
      V3D_CL_CLIPPER_Z_T clipper_z;
      V3D_CL_TILE_BINNING_MODE_CFG_T tile_binning_mode_cfg;
      V3D_CL_TILE_RENDERING_MODE_CFG_T tile_rendering_mode_cfg;
      V3D_CL_MULTICORE_RENDERING_SUPERTILE_CFG_T multicore_rendering_supertile_cfg;
      V3D_CL_MULTICORE_RENDERING_TILE_LIST_BASE_T multicore_rendering_tile_list_base;
      V3D_CL_TILE_COORDS_T tile_coords;
      V3D_CL_TILE_LIST_INITIAL_BLOCK_SIZE_T tile_list_initial_block_size;
   } u;
} V3D_CL_INSTR_T;
extern void v3d_cl_pack_instr(uint8_t *packed_instr, const V3D_CL_INSTR_T *instr);
extern void v3d_cl_unpack_instr(V3D_CL_INSTR_T *instr, const uint8_t *packed_instr);
VCOS_EXTERN_C_END
#endif
