/*=============================================================================
Copyright (c) 2012 Broadcom Europe Limited.
All rights reserved.

Project  :  khronos
Module   :  glxx_server_transform_feedback.c

FILE DESCRIPTION
OpenGL ES 3.0 transform feedback object
=============================================================================*/

#define VCOS_LOG_CATEGORY (&glxx_tf_log)

#include "interface/khronos/glxx/gl_public_api.h"
#include "interface/khronos/common/khrn_int_common.h"
#include "middleware/khronos/glxx/glxx_shared.h"

#include "middleware/khronos/glxx/glxx_server.h"
#include "middleware/khronos/glxx/glxx_server_internal.h"
#include "interface/khronos/tools/dglenum/dglenum.h"

#include "middleware/khronos/glxx/glxx_buffer.h"
#include "interface/khronos/common/khrn_int_util.h"

#include "middleware/khronos/glxx/glxx_hw.h"
#include "middleware/khronos/glxx/glxx_log.h"
#include "middleware/khronos/glxx/glxx_translate.h"

#include "middleware/khronos/gl20/gl20_program.h"
#include "middleware/khronos/gl20/gl20_shader.h"

#include "middleware/khronos/common/khrn_render_state.h"

#include <string.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include "vcos.h"

#include "gmem.h"

#define GLXX_TRANSFORM_FEEDBACK_FLAG_CREATED           (1 << 0)   // set on first call to BeginQuery
#define GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE            (1 << 1)   // set on calls to BeginTransformFeedback, cleared on EndTransformFeedback
#define GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED            (1 << 2)   // set on calls to PauseTransformFeedback, cleared on ResumeTransformFeedback
#define GLXX_TRANSFORM_FEEDBACK_FLAG_ENDED             (1 << 3)   // set on EndTransformFeedback
#define GLXX_TRANSFORM_FEEDBACK_FLAG_WAITED            (1 << 4)   // set when we read from transform feedback buffer
#define GLXX_TRANSFORM_FEEDBACK_FLAG_RESULT_AVAILABLE  (1 << 4)   // set when result available

// Max number of components to write to a single buffer in interleaved mode                  : 64 MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
// Max number of separate attributes or outputs that can be captured in transform feedback   :  4 MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
// Max number of components per attribute or output in separate mode                         :  4 MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS

static_assrt(V3D_MAX_TF_BUFFERS >= GLXX_CONFIG_MAX_TF_SEPARATE_ATTRIBS);

static bool buffer_has_space(GLXX_TRANSFORM_FEEDBACK_T *tf, int index, uint32_t additional_bytes);

GLXX_BUFFER_BINDING_T *glxx_tf_get_buffer_binding(GLXX_SERVER_STATE_T *state)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;
   return &tf->generic_buffer_binding;
}

GLint glxx_tf_get_bound(GLXX_SERVER_STATE_T *state)
{
   return (GLint) (state->transform_feedback.binding->name);
}

GLuint glxx_tf_get_bound_buffer(GLXX_SERVER_STATE_T *state)
{
   return (GLuint) (state->transform_feedback.binding->generic_buffer_binding.buffer);
}

bool glxx_tf_bind_buffer_valid(GLXX_SERVER_STATE_T *state) {
   return !state->transform_feedback.in_use;
}

GLXX_INDEXED_BINDING_POINT_T *glxx_tf_get_indexed_bindings(GLXX_SERVER_STATE_T *state) {
   return state->transform_feedback.binding->binding_points;
}

bool glxx_tf_validate_draw_arrays(GLXX_SERVER_STATE_T *state,
   GLenum primitive_mode, GLsizei count, GLsizei instance_count)
{
   // When transform feedback is active and not paused, all geometric
   // primitives generated must match the value of primitiveMode passed to
   // BeginTransform- Feedback.

   // The error INVALID_OPERATION is generated by DrawArrays and
   // DrawArraysInstanced if recording the vertices of a primitive to the
   // buffer objects being used for transform feedback purposes would result in
   // either exceeding the limits of any buffer object's size, or in exceeding
   // the end position offset + size - 1, as set by BindBufferRange

   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;

   bool active = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE;
   bool paused = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED) == GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED;
   bool in_use = active && !paused;

   if (!in_use) return true;

   if (tf->primitive_mode != primitive_mode) return false;

   {
      // Count how many bytes would be written to each buffer by this draw call
      uint32_t                            tf_vertices;
      uint32_t                            bytes_to_write[V3D_MAX_TF_BUFFERS];
      GL20_PROGRAM_T                      *p    = (GL20_PROGRAM_T *)state->program;
      assert(p);

      GLXX_PROGRAM_TRANSFORM_FEEDBACK_T   *ptf  = &p->transform_feedback;
      uint32_t i;

      if (primitive_mode == GL_POINTS)
         tf_vertices = count;
      else if (primitive_mode == GL_LINES)
         tf_vertices = count - (count & 1);
      else if (primitive_mode == GL_TRIANGLES)
         tf_vertices = count - (count % 3);
      else {
         return false;
      }

      tf_vertices *= instance_count;

      for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
         bytes_to_write[i] = 0;

      for (i = 0; i < ptf->post_link.spec_count; ++i)
      {
         V3D_TF_SPEC_T *spec = &ptf->post_link.spec[i];

         bytes_to_write[spec->buffer] += tf_vertices * spec->count * sizeof(uint32_t);
      }

      // Validate we don't exceed buffer
      for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
      {
         if (bytes_to_write[i])
         {
            bool fits = buffer_has_space(tf, i, bytes_to_write[i]);
            if (!fits)
            {
               return false;
            }
         }
      }
   }

   return true;
}

void glxx_tf_write_primitives(GLXX_SERVER_STATE_T *state,
   v3d_prim_mode_t primitive_mode, GLsizei count, GLsizei instance_count)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;
   bool active = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE;
   bool paused = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED) == GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED;
   bool in_use = active && !paused;

   if (in_use)
   {
      // Count how many bytes to write to each buffer by this draw call
      uint32_t primitive_count;
      uint32_t tf_vertices;
      uint32_t bytes_to_write[V3D_MAX_TF_BUFFERS];
      uint32_t i;
      GLXX_QUERY_T *query = state->queries.queries[GLXX_Q_TRANSF_FEEDBACK].active;

      if (primitive_mode == V3D_PRIM_MODE_POINTS_TF)
      {
         tf_vertices = count;
         primitive_count = tf_vertices;
      }
      else if (primitive_mode == V3D_PRIM_MODE_LINES_TF)
      {
         tf_vertices = count - (count & 1);
         primitive_count = tf_vertices / 2;
      }
      else if (primitive_mode == V3D_PRIM_MODE_TRIS_TF)
      {
         tf_vertices = count - (count % 3);
         primitive_count = tf_vertices / 3;
      }
      else
      {
         assert(0);
         return;
      }

      if (primitive_count == 0)
         return;

      tf_vertices *= instance_count;

      for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
         bytes_to_write[i] = 0;

      {
         GLXX_PROGRAM_TRANSFORM_FEEDBACK_T *ptf = &state->program->transform_feedback;

         for (i = 0; i < ptf->post_link.spec_count; ++i)
         {
            V3D_TF_SPEC_T *spec = &ptf->post_link.spec[i];
            bytes_to_write[spec->buffer] += tf_vertices * spec->count * sizeof(uint32_t);
         }
      }

      for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
         tf->stream_position[i] += bytes_to_write[i];

      if (query)
         query->result += primitive_count;
   }
}

// Return false if operation is invalid and rs requires flush,
// or we ran out of memory.
bool glxx_tf_add_interlock_writes(
   const GLXX_SERVER_STATE_T *state,
   GLXX_HW_RENDER_STATE_T *rs,
   bool* requires_flush)
{
   GLXX_PROGRAM_TRANSFORM_FEEDBACK_T *ptf = NULL;
   bool uses_tf = false;

   if (state->transform_feedback.in_use)
   {
      ptf     = &state->program->transform_feedback;
      uses_tf = ptf->post_link.varying_count > 0;
   }

   if (!uses_tf)
   {
      *requires_flush = false;
      return true;// No interlock writes needed
   }

   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;
   unsigned num_addr = ptf->post_link.addr_count;

   for (unsigned i = 0; i < num_addr; ++i)
   {
      GLXX_BUFFER_T *buffer = tf->binding_points[i].buffer.obj;
      KHRN_RES_INTERLOCK_T *res_i = buffer->resource;

      if (!khrn_fmem_record_res_interlock_tf_write(&rs->fmem, res_i, requires_flush))
         return false;
   }

   return true;
}

bool glxx_tf_emit_spec(GLXX_SERVER_STATE_T *state, GLXX_HW_RENDER_STATE_T *rs,
   uint8_t **instr, bool point_size_used)
{
   GLXX_PROGRAM_TRANSFORM_FEEDBACK_T *ptf;
   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GL20_PROGRAM_T *program;
   uint32_t       id = 0;
   uint32_t       i;
   bool           res = true;
   uint32_t       num_specs;
   uint32_t       num_addr;

   tf          = state->transform_feedback.binding;
   program     = (GL20_PROGRAM_T *)state->program;
   ptf         = &program->transform_feedback;
   num_specs   = ptf->post_link.spec_count;
   num_addr    = ptf->post_link.addr_count;

   rs->tf_used = true;
   rs->tf_started_count = rs->tf_started_count + 1;

   v3d_cl_transform_feedback_enable(instr, id, num_addr, num_specs);

   // Emit transform feedback enable specs
   for (i = 0; i < num_specs; ++i)
   {
      V3D_TF_SPEC_T  *spec_src = &ptf->post_link.spec[i];
      V3D_TF_SPEC_T  spec = *spec_src;
      uint8_t        packed_spec[2];

      // At link time, all tf specs use 7 as first user varying.
      // Here at draw call time, we decrement 1 from all user varyings if point size is not used.
      // Additionally, 6 (before decrementing) is not allowed.
      if (!point_size_used && spec.first >= 6)
      {
         assert(spec.first != 6);
         spec.first -= 1;
      }

      v3d_pack_tf_spec(packed_spec, &spec);

      v3d_cl_add_8(instr, packed_spec[0]);
      v3d_cl_add_8(instr, packed_spec[1]);

      vcos_log_trace(
         "PACK: tf spec %d buffer = %d, first = %d, count = %d words. bytes: %02x %02x",
         i,
         spec.buffer,
         spec.first,
         spec.count,
         packed_spec[0],
         packed_spec[1]);
   }

   // Emit transform feedback buffer addresses
   for (i = 0; i < num_addr; ++i)
   {
      GLintptr             offset;
      GLXX_BUFFER_T        *buffer;
      KHRN_RES_INTERLOCK_T *res_i;
      v3d_addr_t     addr;

      assert(tf->binding_points[i].buffer.obj != NULL);

      buffer  = tf->binding_points[i].buffer.obj;
      offset  = tf->binding_points[i].offset;
      offset += tf->stream_position[i];

      assert(buffer != NULL);

      // We dont need the TF aware version here.
      res_i = glxx_buffer_get_res_interlock(buffer);

      addr = khrn_fmem_lock_and_sync(&rs->fmem, res_i->handle, GMEM_SYNC_CORE_WRITE, 0);
      v3d_cl_add_addr(instr, addr + offset);

      // Record the new last TF wait counter that writes to this buffer.
      buffer->last_tf_write_count = rs->tf_started_count;
   }

   return res;
}

void glxx_tf_get_integer64i(const GLXX_SERVER_STATE_T *state, GLenum target, GLuint index, GLint64 *data)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;

   switch (target)
   {
   case GL_TRANSFORM_FEEDBACK_BUFFER_START:
      *data = tf->binding_points[index].offset;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:
      // Internally -1 means full size. In GL API 0 means full size
      *data = (tf->binding_points[index].size == -1) ? 0 : tf->binding_points[index].size;
      break;
   }
}

void glxx_tf_get_integeri(const GLXX_SERVER_STATE_T *state, GLenum target, GLuint index, GLint* data)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;

   switch (target)
   {
   case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
      *data = tf->binding_points[index].buffer.buffer;
      break;
   }
}

int glxx_tf_get_boolean(const GLXX_SERVER_STATE_T *state, GLenum pname, GLboolean *data)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = state->transform_feedback.binding;
   int res = 0;

   switch (pname)
   {
   case GL_TRANSFORM_FEEDBACK_ACTIVE:
      data[0] = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE
         ? GL_TRUE
         : GL_FALSE;
      res = 1;
      break;
   case GL_TRANSFORM_FEEDBACK_PAUSED:
      data[0] = (tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED) == GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED
         ? GL_TRUE
         : GL_FALSE;
      res = 1;
      break;
   }

   return res;
}

void glxx_tf_delete_buffer(GLXX_TRANSFORM_FEEDBACK_T *tf, GLXX_BUFFER_T *buffer_obj, GLuint buffer)
{
   if (tf->generic_buffer_binding.buffer == buffer) {
      KHRN_MEM_ASSIGN(tf->generic_buffer_binding.obj, NULL);
      tf->generic_buffer_binding.buffer = 0;
   }

   for (int i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
   {
      if (tf->binding_points[i].buffer.buffer == buffer) {
         KHRN_MEM_ASSIGN(tf->binding_points[i].buffer.obj, NULL);
         tf->binding_points[i].buffer.buffer = 0;
      }
   }
}

//  The error INVALID_OPERATION is generated by LinkProgram
//  or ProgramBinary if program is the name of a program
//  being used by one or more transform feedback objects,
//  even if the objects are not currently bound or are paused
typedef struct {
   GL20_PROGRAM_T *program;
   bool           used;
} TF_PROGRAM_USED_INFO_T;
static void glxx_tf_program_used_callback(KHRN_MAP_T *map, uint32_t key, void *value, void *info_)
{
   TF_PROGRAM_USED_INFO_T *info = (TF_PROGRAM_USED_INFO_T *)info_;
   GLXX_TRANSFORM_FEEDBACK_T *tf;

   assert(info);
   assert(value != NULL);

   if (info->used)
      return;

   tf = (GLXX_TRANSFORM_FEEDBACK_T *)value;
   if (tf->program == info->program)
      info->used = true;
}
// add to header & add to link program
bool glxx_tf_program_used(GLXX_SERVER_STATE_T *state, GL20_PROGRAM_T *program)
{
   TF_PROGRAM_USED_INFO_T info;
   info.program   = program;
   info.used      = false;
   khrn_map_iterate(&state->transform_feedback.objects, glxx_tf_program_used_callback, &info);
   return info.used;
}


static void glxx_transform_feedback_term(void *v, size_t size)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = (GLXX_TRANSFORM_FEEDBACK_T *)v;
   uint32_t i;

   UNUSED(size);

   KHRN_MEM_ASSIGN(tf->generic_buffer_binding.obj, NULL);
   for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
   {
      KHRN_MEM_ASSIGN(tf->binding_points[i].buffer.obj, NULL);
   }

   KHRN_MEM_ASSIGN(tf->program, NULL);

   free(tf->debug_label);
   tf->debug_label = NULL;
}

static void glxx_transform_feedback_init(GLXX_TRANSFORM_FEEDBACK_T *tf, int32_t name)
{
   tf->name = name;
   tf->flags = 0;    // created flag is set on first BindTransformFeedback
   tf->primitive_mode = GL_POINTS;
   tf->program = NULL;
   tf->debug_label = NULL;
}

GLXX_TRANSFORM_FEEDBACK_T *glxx_tf_create_default(GLXX_SERVER_STATE_T *state)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = KHRN_MEM_ALLOC_STRUCT(GLXX_TRANSFORM_FEEDBACK_T);

   if (tf != NULL)
   {
      khrn_mem_set_term(tf, glxx_transform_feedback_term);
      glxx_transform_feedback_init(tf, 0);
   }
   return tf;
}

GLXX_TRANSFORM_FEEDBACK_T *glxx_get_transform_feedback(GLXX_SERVER_STATE_T *state, uint32_t id)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = khrn_map_lookup(&state->transform_feedback.objects, id);

   return tf;
}

static GLXX_TRANSFORM_FEEDBACK_T *new_tf(GLXX_SERVER_STATE_T *state, uint32_t id)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf;

   // return NULL if id was already used
   if (glxx_get_transform_feedback(state, id) != NULL) return NULL;

   tf = KHRN_MEM_ALLOC_STRUCT(GLXX_TRANSFORM_FEEDBACK_T);
   if (tf == NULL) return NULL;

   khrn_mem_set_term(tf, glxx_transform_feedback_term);

   glxx_transform_feedback_init(tf, id);

   if (khrn_map_insert(&state->transform_feedback.objects, id, tf))
      khrn_mem_release(tf);
   else
   {
      khrn_mem_release(tf);
      tf = NULL;
   }

   return tf;
}

static void glxx_delete_transform_feedback(GLXX_SERVER_STATE_T *state, uint32_t id)
{
   assert(id != 0);

   // This makes name unused - map get will now return NULL
   khrn_map_delete(&state->transform_feedback.objects, id);
}

GL_API void GL_APIENTRY glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   if (n < 0)
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
   else if (ids)
   {
      int32_t i = 0;
      while (i < n)
      {
         if (new_tf(state, state->transform_feedback.next) != NULL)
            ids[i++] = state->transform_feedback.next;

         ++state->transform_feedback.next;
      }
   }

   GL30_UNLOCK_SERVER_STATE();
}

GL_API GLboolean GL_APIENTRY glIsTransformFeedback(GLuint id)
{
   GLboolean result = GL_FALSE;
   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE_UNCHANGED();
   if (!state) return result;

   if (id == 0) goto end; /* TODO: Looks wrong but was here before */

   tf = glxx_get_transform_feedback(state, id);
   if (tf != NULL)
   {
      if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_CREATED) == GLXX_TRANSFORM_FEEDBACK_FLAG_CREATED)
         result = GL_TRUE;
   }

end:
   GL30_UNLOCK_SERVER_STATE();
   return result;
}

GL_API void GL_APIENTRY glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   if (n < 0)
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
   else if (ids)
   {
      int i;

      //  The error INVALID_OPERATION is generated by DeleteTransformFeedbacks
      //  if the transform feedback operation for any object named by ids is
      //  currently active.
      for (i = 0; i < n; i++)
      {
         if (ids[i])
         {
            GLXX_TRANSFORM_FEEDBACK_T *tf = glxx_get_transform_feedback(state, ids[i]);

            if (tf != NULL)
            {
               if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) != 0)
               {
                  glxx_server_state_set_error(state, GL_INVALID_OPERATION);
                  goto unlock_out;
               }
            }
         }
      }

      for (i = 0; i < n; i++)
      {
         if (ids[i] == (GLuint)state->transform_feedback.binding->name) {
            KHRN_MEM_ASSIGN(state->transform_feedback.binding, state->transform_feedback.default_obj);
         }

         if (ids[i])
         {
            glxx_delete_transform_feedback(state, ids[i]);
         }
      }
   }

unlock_out:
   GL30_UNLOCK_SERVER_STATE();
}

GL_API void GL_APIENTRY glBindTransformFeedback(GLenum target, GLuint id)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = NULL;
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   if (target != GL_TRANSFORM_FEEDBACK)
   {
      glxx_server_state_set_error(state, GL_INVALID_ENUM);
      goto unlock_out;
   }

   if (state->transform_feedback.in_use)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   if (id == 0)
      tf = state->transform_feedback.default_obj;
   else
      // Set create = false, because name 'id' must have
      // been already created by GenTransformFeedbacks
      tf = glxx_get_transform_feedback(state, id);

   if (tf == NULL)
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
   else
   {
      KHRN_MEM_ASSIGN(state->transform_feedback.binding, tf);

      tf->flags |= GLXX_TRANSFORM_FEEDBACK_FLAG_CREATED;
   }

unlock_out:
   GL30_UNLOCK_SERVER_STATE();
}

GL_API void GL_APIENTRY glBeginTransformFeedback(GLenum primitiveMode)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf = NULL;
   uint32_t i;
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   if ((primitiveMode != GL_TRIANGLES) && (primitiveMode != GL_LINES) && (primitiveMode != GL_POINTS))
   {
      glxx_server_state_set_error(state, GL_INVALID_ENUM);
      goto unlock_out;
   }

   //  The error INVALID_OPERATION is also generated by BeginTransformFeedback
   //  if no binding points would be used, either because no program object is
   //  active or because the active program object has specified no output
   //  variables to record.
   if (state->program == NULL)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }
   if (!gl20_validate_program(state, state->program))
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }
   if (state->program->transform_feedback.post_link.varying_count == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   tf = state->transform_feedback.binding;

   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) != 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto unlock_out;
   }

   // The error INVALID_OPERATION is generated by BeginTransformFeedback
   // if any binding point used in transform feedback mode does not
   // have a buffer object bound
   for (i = 0; i < V3D_MAX_TF_SPECS; ++i)
   {
      uint32_t buffer = state->program->transform_feedback.post_link.spec[i].buffer;
      GLXX_BUFFER_T* bufferObj = tf->binding_points[buffer].buffer.obj;

      if (bufferObj == NULL)
      {
         glxx_server_state_set_error(state, GL_INVALID_OPERATION);
         goto unlock_out;
      }
   }

   // Reset transform feedback writing position for all buffers
   for (i = 0; i < V3D_MAX_TF_BUFFERS; ++i)
      tf->stream_position[i] = 0;

   tf->flags |= GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE;
   tf->primitive_mode = primitiveMode;
   KHRN_MEM_ASSIGN(tf->program, state->program);
   state->transform_feedback.in_use = true;

unlock_out:
   GL30_UNLOCK_SERVER_STATE();
}

GL_API void GL_APIENTRY glPauseTransformFeedback(void)
{
   GLXX_SERVER_STATE_T *state;
   GLXX_TRANSFORM_FEEDBACK_T *tf;

   state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   tf = state->transform_feedback.binding;

   //  The error INVALID_OPERATION is generated by PauseTransformFeedback
   //  if the currently bound transform feedback is not active or is paused.
   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }
   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED) != 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }

   tf->flags |= GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED;
   state->transform_feedback.in_use = false;

out:
   GL30_UNLOCK_SERVER_STATE();
}

GL_API void GL_APIENTRY glResumeTransformFeedback(void)
{

   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   tf = state->transform_feedback.binding;

   //  The error INVALID_OPERATION is generated by ResumeTransformFeedback
   //  if the currently bound transform feedback is not active or is not paused
   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }
   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED) == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }

   tf->flags &= ~GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED;
   state->transform_feedback.in_use = true;

out:
   GL30_UNLOCK_SERVER_STATE();
}

GL_API void GL_APIENTRY glEndTransformFeedback(void)
{
   GLXX_TRANSFORM_FEEDBACK_T *tf;
   GLXX_SERVER_STATE_T *state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   tf = state->transform_feedback.binding;

   if ((tf->flags & GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE) == 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_OPERATION);
      goto out;
   }

   tf->flags &= ~GLXX_TRANSFORM_FEEDBACK_FLAG_ACTIVE;
   tf->flags &= ~GLXX_TRANSFORM_FEEDBACK_FLAG_PAUSED;

   tf->flags |= GLXX_TRANSFORM_FEEDBACK_FLAG_ENDED;

   KHRN_MEM_ASSIGN(tf->program, NULL);

   state->transform_feedback.in_use = false;

out:
   GL30_UNLOCK_SERVER_STATE();
}

//  glGetTransformFeedbackVarying() is in gl20_program.c

GL_API void GL_APIENTRY glTransformFeedbackVaryings(
   GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode)
{
   GLXX_SERVER_STATE_T *state;
   GL20_PROGRAM_T *p;
   int i;

   state = GL30_LOCK_SERVER_STATE();
   if (!state) return;

   if (bufferMode != GL_INTERLEAVED_ATTRIBS && bufferMode != GL_SEPARATE_ATTRIBS)
   {
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
      goto unlock_out;
   }
   if (count < 0)
   {
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
      goto unlock_out;
   }
   if (bufferMode == GL_SEPARATE_ATTRIBS &&
       count > GLXX_CONFIG_MAX_TF_SEPARATE_ATTRIBS)
   {
      glxx_server_state_set_error(state, GL_INVALID_VALUE);
      goto unlock_out;
   }

   p = gl20_get_program(state, program);

   if (p == NULL)
      /* error is set by gl20_get_program */
      goto unlock_out;

   p->transform_feedback.pre_link.buffer_mode = bufferMode;
   p->transform_feedback.pre_link.varying_count = count;

   for (i = 0; i < GLXX_CONFIG_MAX_TF_INTERLEAVED_COMPONENTS; ++i) {
      // In case we are re-assigning this program's TF varyings.
      free(p->transform_feedback.pre_link.name[i]);
   }

   for (i = 0; i < count; ++i) {
      p->transform_feedback.pre_link.name[i] = strdup(varyings[i]);
      if (p->transform_feedback.pre_link.name[i] == NULL) {
         glxx_server_state_set_error(state, GL_OUT_OF_MEMORY);
      }
   }

   for (; i < GLXX_CONFIG_MAX_TF_INTERLEAVED_COMPONENTS; ++i)
      p->transform_feedback.pre_link.name[i] = NULL;

unlock_out:
   GL30_UNLOCK_SERVER_STATE();
}

static bool buffer_has_space(GLXX_TRANSFORM_FEEDBACK_T *tf, int index, uint32_t additional_bytes)
{
   GLXX_INDEXED_BINDING_POINT_T *binding = &tf->binding_points[index];

   if (binding->buffer.obj == NULL)
      return false;

   {
      uint32_t write_begin = binding->offset + tf->stream_position[index];
      uint32_t write_end   = write_begin + additional_bytes;
      size_t binding_end = (binding->size == -1)
         ? glxx_buffer_get_size(binding->buffer.obj)   // if binding size == -1, use full buffer size
         : (size_t)(binding->offset + binding->size);

      return (write_end <= binding_end);
   }
}

// Table 6.24. Transform Feedback State
//
// Get value Type                         Description
// -----------------------------------------------------------------------------------------------------------------
// TRANSFORM_FEEDBACK_BUFFER_BINDING      Buffer object bound to generic bind point for transform feedback
// TRANSFORM_FEEDBACK_BUFFER_BINDING []   Buffer object bound to each transform feedback attribute stream
// TRANSFORM_FEEDBACK_BUFFER_START   []   Start offset of binding range for each transform feedback attrib. stream
// TRANSFORM_FEEDBACK_BUFFER_SIZE    []   Size of binding range for each transform feedback attrib. stream
// TRANSFORM_FEEDBACK_PAUSED              Is transform feedback paused on this object?
// TRANSFORM_FEEDBACK_ACTIVE              Is transform feedback active on this object?

// Table 6.34 Implementation Dependent Transform Feedback Limits
//
// Get value Type                                  Minimum  Description
// --------------------------------------------------------------------------------------------------------
// MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS   64       Max number of components to write to a single
//                                                          buffer in interleaved mode
// MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS         4        Max number of separate attributes or outputs
//                                                          that can be captured in transform feedback
// MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS      4        Max number of components per attribute or
//                                                          output in separate mode

// 64 = 4 * 16
// MAX_VARYING_COMPONENTS  >= 60
// MAX_VARYING_VECTORS     >= 15

// MAX_FRAGMENT_INPUT_COMPONENTS >= 60

// MAX_VERTEX_OUTPUT_COMPONENTS >= 64

// MAX_VERTEX_ATTRIBS >= 16
