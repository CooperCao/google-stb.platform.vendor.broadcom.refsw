#!/usr/bin/env perl
#     (c)2013 Broadcom Corporation
#
#  This program is the proprietary software of Broadcom Corporation and/or its licensors,
#  and may only be used, duplicated, modified or distributed pursuant to the terms and
#  conditions of a separate, written license agreement executed between you and Broadcom
#  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
#  no license (express or implied), right to use, or waiver of any kind with respect to the
#  Software, and Broadcom expressly reserves all rights in and to the Software and all
#  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
#  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
#  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
#
#  Except as expressly set forth in the Authorized License,
#
#  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
#  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
#  and to use this information only in connection with your use of Broadcom integrated circuit products.
#
#  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
#  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
#  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
#  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
#  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
#  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
#  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
#  USE OR PERFORMANCE OF THE SOFTWARE.
#
#  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
#  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
#  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
#  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
#  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
#  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
#  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
#  ANY LIMITED REMEDY.
#
# $brcm_Workfile: $
# $brcm_Revision: $
# $brcm_Date: $
#
# File Description:
#
# Revision History:
#
# $brcm_Log: $
# 
#############################################################################

use strict;
use warnings;
use Data::Dumper;


sub usage {
    print "Usage\n";
    print "$0 <src> <dest>\n";
    print "\nWhere:\n";
    print "\t<src> - name of text file with extracted content from XLS file\n";
    print "\t<dest> - name of already _existing_ file to be populated with list of clients, only the file header would get preserved\n";
    exit(1);
}

usage () if(scalar @ARGV<2);
my $txt_file = $ARGV[0];
my $h_file = $ARGV[1];
print "Processing '$txt_file' into  '$h_file' \n";
my $fin;

if( not open($fin, '<', $h_file)) {
    print "Can't open $h_file for read\n"; usage ();
}

my @header;
my $autogenerated;
while(<$fin>) {
    push @header,$_;
    if(/THIS FILE IS AUTOGENERATED/) {
        $autogenerated=1;
        last;
    }
}
die "$h_file is not autogenerated" unless defined $autogenerated;
close $fin;

sub max {
    my ($a,$b) = @_;
    return $a > $b ? $a : $b;
}

my @data;
my $nmemc=0;

if($txt_file ne 'VH') {

    if( not open($fin, '<', $txt_file)) {
        print "Can't open $txt_file\n"; usage ();
    }

    while(<$fin>) {
        my @line;
        s/\r|\n//g;
        if(/^#/) {
            @line = (undef,$_);
        } elsif(/^\s+$/) {
            @line = (undef);
        } elsif(/([a-zA-Z][^\t]+)\t( |\d*)\t( |\d*)\t(\d+)(\t|$)(.*)/) {
            #print "3: $_\n";
            @line = ([$1,$2,$3,$4],$6);
        } elsif(/([a-zA-Z][^\t]+)\t( |\d*)\t(\d+)(\t|$)(.*)/) {
            #print "2: $_\n";
            @line = ([$1,$2,$3],$5);
        } elsif(/([a-zA-Z][^\t]+)\t(\d+)(\t|$)(.*)/) {
            #print "1: $_\n";
            @line = ([$1,$2],$4);
        } else {
            @line = (undef,$_);
        }
        #print "$_\n " . Dumper(\@line);
        push @data,\@line;
    }

    close($fin);

    #use Data::Dumper;
    #print Dumper(\@data);
    for(@data) {
        my $memc = $_->[0];
        next unless defined $memc;
        $nmemc = max($nmemc, scalar @$memc);
    }
    $nmemc--;
} else {
    my %scb;
    my %comments;
    # VHDL file parsing from standard input
    print "Reading VHDL data ....\nPlease copy&paste or restart and redirect standard input\n\n";
    while(<STDIN>) {
        if(/[`#]define (\w+)_SCB(\d+)_DECL\w*\s+(\d+)([^0-9]*)/) {
            my $client = $1;
            my $memc = $2;
            next if $client eq 'UNUSED';
            #print "$1 $2 $3\n";
            $scb{$client}[$memc] = $3;
            $nmemc = max $nmemc, $memc;
            if($4 =~  m|//(.+)|) {
                $comments{$client}[$memc] = $1;
            } else {
                $comments{$client}[$memc] = '';
            }
        }
    }
    for my $c (keys %scb) {
        for my $m (0..$nmemc-1) {
            $scb{$c}[$m] = '-1' unless defined $scb{$c}[$m];
        }
    }
    $nmemc++;
#    print Dumper($nmemc,\%scb);
#    print Dumper([sort {$scb{$a}[0] <=> $scb{$b}[0]} keys %scb])
    @data = map { [[$_, @{$scb{$_}}],join('',@{$comments{$_}})] } (sort {$scb{$a}[0] <=> $scb{$b}[0]} keys %scb);
#    print Dumper(\@data);
#    exit 0;
}

my $fout;


sub format_line {
    my ($nmemc,$data,$cmnt) = @_;
    return "" unless defined $cmnt;
    $cmnt =~ s/\t/    /g;
    $cmnt =~ s/\*/ \*/g;
    if(defined $data) {
        my @memc = @$data;
        for my $i (0 .. $nmemc) {
            #print "-" . Dumper($memc[$i]);
            #print "-- $memc[$i] \n";
            if( (not defined $memc[$i]) || (length($memc[$i])==0) || $memc[$i] eq ' ' || $memc[$i] eq '-1') {
                $memc[$i] = 'INVALID';
            }
            #print "+" . Dumper($memc[$i]);
        }
        $memc[0] =~ s/[^A-Za-z0-9]/_/g; #replace non-valid characters 
        $memc[0] =~ s/_+/_/g; #squash underscores
        $memc[0] =~ s/_+$//g; #remove trailing underscores
        $data = "BCHP_P_MEMC_DEFINE_CLIENT(" . join(',', @memc) . ")";
        my $data_len = length($data);
        if($data_len < 60) {
            $data_len = 60;
        }
        $data = $data . "                                         ";
        $data = substr($data,0,$data_len);
    } else {
        $data = "";
    }
    "$data/* $cmnt */"
}

if( not open($fout, '>', $h_file)) {
    print "Can't open $h_file for write\n"; usage ();
}

print $fout @header;
print $fout "/*****\n";
print $fout "GENERATED by:\n";
print $fout "perl $0 " . join(' ',@ARGV) . "\n";
print $fout "*******/\n";
for(@data) {
    my ($_memc,$cmnt) = @$_;
    print $fout format_line($nmemc,$_memc,$cmnt);
    print $fout "\n";
}
close($fout);
print "Done\n";


