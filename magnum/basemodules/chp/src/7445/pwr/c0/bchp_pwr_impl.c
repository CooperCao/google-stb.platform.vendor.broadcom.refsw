/***************************************************************************
*     (c)2004-2014 Broadcom Corporation
*
*  This program is the proprietary software of Broadcom Corporation and/or its licensors,
*  and may only be used, duplicated, modified or distributed pursuant to the terms and
*  conditions of a separate, written license agreement executed between you and Broadcom
*  (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
*  no license (express or implied), right to use, or waiver of any kind with respect to the
*  Software, and Broadcom expressly reserves all rights in and to the Software and all
*  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
*  HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
*  NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
*
*  Except as expressly set forth in the Authorized License,
*
*  1.     This program, including its structure, sequence and organization, constitutes the valuable trade
*  secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
*  and to use this information only in connection with your use of Broadcom integrated circuit products.
*
*  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
*  AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
*  WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
*  THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
*  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
*  LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
*  OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
*  USE OR PERFORMANCE OF THE SOFTWARE.
*
*  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
*  LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
*  EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
*  USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
*  THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
*  ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
*  LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
*  ANY LIMITED REMEDY.
*
* $brcm_Workfile: $
* $brcm_Revision: $
* $brcm_Date: $
*
* API Description:
*   API name: Platform
*    Specific APIs to initialize the a board.
*
* Revision History:
*
* $brcm_Log: $
*
***************************************************************************/

/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clkgen.h"
#include "bchp_avs_top_ctrl.h"
#include "bchp_hdmi_tx_phy.h"
#include "bchp_hdmi_rx_fe_0.h"
#include "bchp_aud_fmm_iop_pll_0.h"
#include "bchp_aud_fmm_iop_pll_1.h"
#include "bchp_aud_fmm_iop_pll_2.h"
#include "bchp_aud_fmm_iop_out_dac_ctrl_0.h"
#include "bchp_rfm_sysclk.h"
#include "bchp_pm.h"

BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_HVD0_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD0_CORE_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_CORE_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD0_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD0_CPU_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_CPU_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD0_SCB_GISB_54_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD0_SCB_GISB_54_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_54_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_108_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE_HVD0_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD0_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD0_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SHVD0_SRAM_PDA_IN_SHVD0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SHVD0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HVD1_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD1_CORE_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_CORE_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD1_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD0_CPU_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_CPU_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD1_54_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD1_54_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_54_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD1_SCB_GISB_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD1_SCB_GISB: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_SCB_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_HVD1_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD1_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD1_SRAM_PDA_IN_HVD1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HVD2_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD2_CORE_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_CORE_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD2_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD2_CPU_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_CPU_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD2_SCB_GISB_54_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD2_SCB_GISB_54_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_54_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_108_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE_HVD2_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD2_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HVD2_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HVD2_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD2_SRAM_PDA_IN_HVD2_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD2, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VICE0_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VICE0_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_SCB_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_GISB_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_GISB_ALTERNATE_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_CORE_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VICE0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VICE0_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_0_SRAM_PDA_IN_VICE2_0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VICE1_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VICE1_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_SCB_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_GISB_ALTERNATE_CLOCK_ENABLE_MASK |
	     BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_CORE_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE_VICE2_1_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VICE2_1_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VICE1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VICE1_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_1_SRAM_PDA_IN_VICE2_1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE_SCB_CLOCK_ENABLE_AIO_MASK |
             BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE_108_CLOCK_ENABLE_AIO_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO_SRAM_PDA_IN_AIO_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_AUD_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask1, mask2, reg;

    BDBG_MSG(("HW_AUD_DAC: %s", activate?"on":"off"));

    mask1 = (BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_aux_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_instage_MASK|
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_main_MASK|
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_main_delay_MASK |
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_LDO1p5_pu_MASK |
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_LDO1p5_pu_MASK |
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_Local1p8cp_pu_MASK |
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_NegLDO_pu_MASK |
	     BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_V2I_pu_MASK );

    mask2 = (BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_Ref_filt_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_CP_pu_Lshifter_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_CP_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_DACbuf_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_pu_MASK );

    if (activate) {
	reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2);
	reg |= mask2;
	BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2, reg);

	reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1);
        reg |= mask1;
	BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1, reg);

    } else {
	reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1);
	reg &= ~mask1;
	BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1, reg);

	reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2);
	reg &= ~mask2;
	BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2, reg);
    }
}

static void BCHP_PWR_P_HW_RAAGA0_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_DSP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_DSP: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_DSP_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0_SRAM_PDA_IN_RAAGA0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_RAAGA1_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA1_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE_RAAGA1_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE_RAAGA1_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE_RAAGA1_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE_RAAGA1_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA1_DSP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA1_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE_RAAGA1_DSP_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_1_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA1_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA1_SRAM_PDA_IN_RAAGA1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_BVN_BVB_GISB_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_BVB_GISB: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_BVB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
     uint32_t mask;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_BVB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_SCB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND_SRAM_PDA_IN_BVND_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND, mask, activate?0:mask);

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN_SRAM_PDA_IN_BVN_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_ANA_QDAC_TS28HPM_6MX_2MR_FC_H_E_INST_CLOCK_DISABLE_DISABLE_QDAC_DACADC_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_ANA_QDAC_TS28HPM_6MX_2MR_FC_H_E_INST_CLOCK_DISABLE, mask, activate?0:mask);

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, mask, activate?0:mask);

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_GISB_CLOCK_ENABLE_VEC_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VEC_108_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_108: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_108_CLOCK_ENABLE_VEC_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_BVB_CLOCK_ENABLE_VEC_MASK |
	     BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_SCB_CLOCK_ENABLE_VEC_MASK |
             BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_GISB_CLOCK_ENABLE_VEC_MASK |
             BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_GISB_CLOCK_ENABLE_VEC_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF_VEC_GISB_CLOCK_ENABLE_VEC_QDAC_INTF_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_AIO_54_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC_SRAM_PDA_IN_VEC_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VDC_656_OUT_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_656_OUT: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_ITU656_0_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, mask, activate?0:mask);

}

static void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_CORE_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
             BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_XPT_SRAM_Control(BCHP_Handle handle, bool activate)
{
    BSTD_UNUSED(handle);

    BDBG_MSG(("HW_XPT_SRAM: %s", activate?"on":"off"));

#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_XPT_SRAM_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

static void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL_CLOCK_Async_CG_XPT_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL, mask, activate?0:mask);

    mask = ( BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_XPT_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE_DVPHT_54_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHT_SRAM_PDA_IN_DVPHT_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHT, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_CLOCK_ENABLE, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_DVP_HT_INST_ENABLE_DVPHT_CLK_VEC_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_INST_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_PHY_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HDMI_TX_PHY: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL);
    mask = (BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, RNDGEN_PWRDN) |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PLL_PWRDN)  |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, BG_PWRDN) |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, LDO_PWRDN) |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, BIAS_PWRDN) |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PLL_LDO_PWRDN) |
	    BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PHY_PWRDN));
    if (activate) {
        reg &= ~mask;
    }
    else {
        reg |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL, reg) ;
}

static void BCHP_PWR_P_HW_HDMI_RX0_FE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;

    BDBG_MSG(("HW_HDMI_RX0_FE: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_DVP_HR_INST_CLOCK_DISABLE_DISABLE_DVPHR_ALWAYSON_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_DISABLE, mask, activate?0:mask);

    mask = ( BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_54_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE2_DVPHR_108_CLOCK_ENABLE2_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE2, mask, activate?mask:0);

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_RX_FE_0_RESET_CONTROL);
    mask = (BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_BIAS_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_0_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_1_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_2_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_CLOCK_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_PLL_POWER_DOWN_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_0_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_1_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_CHANNEL_2_RESET_MASK |
	    BCHP_HDMI_RX_FE_0_RESET_CONTROL_ANALOG_PLL_RESET_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_RX_FE_0_RESET_CONTROL, val);
}

static void BCHP_PWR_P_HW_HDMI_RX0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_RX0_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHR_SRAM_PDA_IN_DVPHR_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHR, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HDMI_RX0_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_RX0_108M: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_HD_DVI_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_BVB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE0_DVPHR_108_CLOCK_ENABLE0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE0, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_M2MC0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC0: %s", activate?"on":"off"));

     mask = ( BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC0_GFX_M2MC0_CLOCK_ENABLE_M2MC0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC0, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE0_GFX_M2MC0_SCB_CLOCK_ENABLE0_MASK |
             BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE0_GFX_M2MC0_GISB_CLOCK_ENABLE0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE0, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_M2MC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC1: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1_GFX_M2MC1_CLOCK_ENABLE_M2MC1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE1_GFX_M2MC1_SCB_CLOCK_ENABLE1_MASK |
             BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE1_GFX_M2MC1_GISB_CLOCK_ENABLE1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE1, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_M2MC0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC0_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC0_SRAM_PDA_IN_M2MC0_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_M2MC1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC1_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1_SRAM_PDA_IN_M2MC1_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1, mask, activate?0:mask);

}

static void BCHP_PWR_P_HW_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_V3D: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_GISB_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_V3D_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_V3D_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D_SRAM_PDA_IN_V3D_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD0: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD1: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_TEMP_MONITOR_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val, mask;

    BDBG_MSG(("HW_TEMP_MONITOR: %s", activate?"on":"off"));

    val = BREG_Read32(handle->regHandle, BCHP_PM_CLK_CTRL);
    mask = BCHP_PM_CLK_CTRL_tmon_MASK;
    if (activate) {
	val |= mask;
    }
    else {
	val &= ~mask;
    }
    BREG_Write32(handle->regHandle, BCHP_PM_CLK_CTRL, val);
}

static void BCHP_PWR_P_HW_SID_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SID: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_SID_SID_CORE_CLOCK_ENABLE_SID_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_HVD_SID1_TOP_INST_CLOCK_ENABLE_SID, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_SID_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SID_SRAM: %s", activate?"on":"off"));

    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID_SRAM_PDA_IN_SID_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_RFM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;

    BDBG_MSG(("HW_RFM: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_54_CLOCK_ENABLE_MASK |
		 BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK |
		 BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_GISB_CLOCK_ENABLE_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE, mask, mask);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1);
	val &= ~( BCHP_RFM_SYSCLK_DPLL_MISC1_ARESET_MASK |
		  BCHP_RFM_SYSCLK_DPLL_MISC1_DRESET_MASK |
		  BCHP_RFM_SYSCLK_DPLL_MISC1_PWRDN_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1, val);

	BKNI_Delay(50); /* wait 50us for RFM PLL to lock */

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val &= ~BCHP_RFM_SYSCLK_CLKCTL_LDO_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
	val &= ~BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);
    } else {
	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
	val |= BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= BCHP_RFM_SYSCLK_CLKCTL_LDO_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
	val |= BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK;
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

	val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1);
	val |= ( BCHP_RFM_SYSCLK_DPLL_MISC1_ARESET_MASK |
		 BCHP_RFM_SYSCLK_DPLL_MISC1_DRESET_MASK |
		 BCHP_RFM_SYSCLK_DPLL_MISC1_PWRDN_MASK );
	BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DPLL_MISC1, val);

	mask = ( BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_54_CLOCK_ENABLE_MASK |
		 BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK |
		 BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_GISB_CLOCK_ENABLE_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_HVD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_HVD_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_HVD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_HVD_CH1: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_HVD_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_HVD_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_HVD_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_HVD_CH3: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_3, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_HVD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_HVD: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_HVD_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("HVD PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON, mask, mask);
    } else {
	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON, mask, 0);

	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_HVD_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, AUD_FMM_IOP_PLL_0_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("Audio0 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_AUDIO0_PM_PLL_LDO_POWERUP_PLL_AUDIO0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_AUDIO0_PM_PLL_LDO_POWERUP_PLL_AUDIO0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON, mask, 0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_PWRON, mask,0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, AUD_FMM_IOP_PLL_0_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("Audio0 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_AUDIO1_PM_PLL_LDO_POWERUP_PLL_AUDIO1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_AUDIO1_PM_PLL_LDO_POWERUP_PLL_AUDIO1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON, mask, 0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_PWRON, mask,0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL2: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_BG_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_LDO_PWRON, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, AUD_FMM_IOP_PLL_0_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("Audio0 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_AUDIO2_PM_PLL_LDO_POWERUP_PLL_AUDIO2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO2, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_AUDIO2_PM_PLL_LDO_POWERUP_PLL_AUDIO2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO2, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
		 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_RESET, mask, mask);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_LDO_PWRON, mask, 0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_PWRON, mask,0);

	mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_2_BG_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON, mask, mask);

	mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("VCXO 0 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON, mask, mask);
    } else {
	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON, mask, 0);

	mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON, mask, 0);

	mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON, mask, mask);

	mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("VCXO 1 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON, mask, mask);
    } else {
	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON, mask, 0);

	mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON, mask, 0);

	mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL2_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL2_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL2_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL2_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_PLL2: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_BG_PWRON, mask, mask);

	mask = (BCHP_CLKGEN_PLL_VCXO2_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO2_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO2_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("VCXO 2 PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_LDO_PWRON, mask, mask);
    } else {
	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_LDO_PWRON, mask, 0);

	mask = (BCHP_CLKGEN_PLL_VCXO2_PLL_RESET_RESETD_MASK |
		BCHP_CLKGEN_PLL_VCXO2_PLL_RESET_RESETA_MASK);
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_BG_PWRON, mask, 0);

	mask = ( BCHP_CLKGEN_PLL_VCXO2_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO2_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_MOCA_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_MOCA_CH3: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_MOCA_CH4_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_MOCA_CH4: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_CLOCK_DIS_CH4_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_POST_DIVIDER_HOLD_CH4_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_POST_DIVIDER_HOLD_CH4_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_CLOCK_DIS_CH4_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD0_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD0: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = ( BCHP_CLKGEN_PLL_SC0_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC0_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("SmartCard 0 PLL Lock Timeout"));
    } else {
	mask = ( BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_SC0_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD1_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD1: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;
	mask = ( BCHP_CLKGEN_PLL_SC1_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC1_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("SmartCard 1 PLL Lock Timeout"));
    } else {
	mask = ( BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_SC1_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON, mask, 0);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH0: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH1: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH2: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH3: %s", activate?"on":"off"));

    if(activate) {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, mask, 0);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, mask, 0);
    } else {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, mask, mask);
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_RAAGA: %s", activate?"on":"off"));

    if(activate) {
	uint32_t reg, cnt=50;

	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, mask, 0);

	/* Check for PLL lock */
	while(cnt--) {
	    BKNI_Delay(10);
	    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS);
	    if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS, LOCK))
		break;
	}
	if(!cnt)
	    BDBG_ERR(("RAAGA PLL Lock Timeout"));

	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON, mask, mask);
    }else {
	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON, mask, 0);

	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
		 BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, mask, mask);

	mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON_PWRON_PLL_MASK );
	BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON, mask, 0);
    }
}

