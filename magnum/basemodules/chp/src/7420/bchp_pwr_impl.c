/***************************************************************************
 *     Copyright (c) 2003-2014, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: $
 * $brcm_Revision: $
 * $brcm_Date: $
 *
 * Module Description:
 *
 * Revision History:
 *
 * $brcm_Log: $
 *
 ***************************************************************************/
/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"
#include "breg_mem.h"

#include "bchp_clk.h"
#include "bchp_avd_rgr_0.h"
#include "bchp_avd_rgr_1.h"
#include "bchp_aio_misc.h"
#include "bchp_xpt_xmemif.h"
#include "bchp_hdmi_tx_phy.h"
#include "bchp_vcxo_ctl_misc.h"
#include "bchp_rfm_sysclk.h"
#include "bchp_avlink_phy.h"
#include "bchp_uhfr_glbl.h"
#include "bchp_sun_top_ctrl.h"

BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_AVD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_AVD0: %s", activate?"on":"off"));

    if (activate) {
        /* PWRDN_CLOCK_108_CG_AVD GISB clock*/
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BREG_Read32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0);
        mask &= ~BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
        BREG_Write32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0, mask);

        /* PWRDN_CLOCK_216_CG_AVD SCB Memory clock */
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        /* AVD Coreclock */
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_250M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);
    }
    else {
        /* AVD Coreclock */
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_250M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        /* PWRDN_CLOCK_216_CG_AVD SCB Memory clock */
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BREG_Read32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0);
        mask |= BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
        BREG_Write32(handle->regHandle, BCHP_AVD_RGR_0_SW_RESET_0, mask);

        /* PWRDN_CLOCK_108_CG_AVD GISB clock*/
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);
    }
}

static void BCHP_PWR_P_HW_AVD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    uint32_t ulReg, chip_id;

    ulReg = BREG_Read32(handle->regHandle, BCHP_SUN_TOP_CTRL_PROD_REVISION);
    chip_id = BCHP_GET_FIELD_DATA(ulReg, SUN_TOP_CTRL_PROD_REVISION, product_revision);
    chip_id >>= 16;


    if (chip_id == 0x7420 || chip_id == 0x7409)
    {

        BDBG_MSG(("HW_AVD1: %s", activate?"on":"off"));

        if (activate) {
            mask = BREG_Read32(handle->regHandle, BCHP_AVD_RGR_1_SW_RESET_0);
            mask &= ~BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
            BREG_Write32(handle->regHandle, BCHP_AVD_RGR_1_SW_RESET_0, mask);

            /* PWRDN_CLOCK_216_CG_AVD SCB Memory clock */
            mask = BCHP_CLK_AVD1_CLK_PM_CTRL_DIS_216M_CLK_MASK;
            BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD1_CLK_PM_CTRL, mask, 0);

            /* AVD Coreclock */
            mask = BCHP_CLK_AVD1_CLK_PM_CTRL_DIS_250M_CLK_MASK;
            BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD1_CLK_PM_CTRL, mask, 0);
        }
        else {
            /* AVD Coreclock */
            mask = BCHP_CLK_AVD1_CLK_PM_CTRL_DIS_250M_CLK_MASK;
            BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD1_CLK_PM_CTRL, mask, mask);

            /* PWRDN_CLOCK_216_CG_AVD SCB Memory clock */
            mask = BCHP_CLK_AVD1_CLK_PM_CTRL_DIS_216M_CLK_MASK;
            BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD1_CLK_PM_CTRL, mask, mask);

            mask = BREG_Read32(handle->regHandle, BCHP_AVD_RGR_1_SW_RESET_0);
            mask |= BCHP_AVD_RGR_0_SW_RESET_0_disable_avd_clk_rcvr_MASK;
            BREG_Write32(handle->regHandle, BCHP_AVD_RGR_1_SW_RESET_0, mask);
        }
    }
}

static void BCHP_PWR_P_HW_AVD_108_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_AVD_108: %s", activate?"on":"off"));

    mask = BCHP_CLK_AVD1_CLK_PM_CTRL_DIS_108M_CLK_MASK;

   /* PWRDN_CLOCK_108_CG_AVD GISB clock*/
   BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD1_CLK_PM_CTRL, mask, activate?0:mask);

}

static void BCHP_PWR_P_HW_RAP_OPEN_Control(BCHP_Handle handle, bool activate)
{
    /* BRAP_Open() needs more than just the 108M clock.
       the 216M, 250M clocks, plus RAP_AVD_PLL_CHL1 are needed for AUD_DSP0_* register R/W */

    uint32_t val;
    BDBG_MSG(("HW_RAP_OPEN: %s", activate?"on":"off"));

    if (activate) {
        /* AIO clocks */
        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);

        /* D2CDiff */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_CTRL);
        val &= ~BCHP_AIO_MISC_CTRL_PWRDWN_D2CDIFF_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_CTRL, val);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_RPT_250M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, 0);
    }
    else {
        /* AIO clocks */
        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_RPT_250M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);

        /* D2CDiff */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_CTRL);
        val |= BCHP_AIO_MISC_CTRL_PWRDWN_D2CDIFF_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_CTRL, val);

        val = BCHP_CLK_RPT_AIO_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RPT_AIO_CLK_PM_CTRL, val, val);
    }
}

static void BCHP_PWR_P_HW_RAP_START_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_RAP_START: %s", activate?"on":"off"));

    if (activate) {
        /* AC2 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC2_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC2_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL, val);

        /* AC1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        /* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        /* HifiDriver1 */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val &= ~BCHP_AIO_MISC_PWRDOWN_DAC1_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);

        /* HifiDriver0 */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val &= ~BCHP_AIO_MISC_PWRDOWN_DAC0_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);
    }
    else {
        /* HifiDriver0 */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val |= BCHP_AIO_MISC_PWRDOWN_DAC0_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);

        /* HifiDriver1 */
        val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
        val |= BCHP_AIO_MISC_PWRDOWN_DAC1_MASK;
        BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);

        /* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        /* AC1 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        /* AC2 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC2_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC2_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL, val);
    }
}

static void BCHP_PWR_P_HW_BVN_EDGE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN_EDGE: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_EDGE_PM_CTRL_DIS_108M_CLK_MASK |
           BCHP_CLK_BVN_EDGE_PM_CTRL_DIS_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_EDGE_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_BVN_MIDDLE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN_MIDDLE: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_MIDDLE_PM_CTRL_DIS_108M_CLK_MASK |
           BCHP_CLK_BVN_MIDDLE_PM_CTRL_DIS_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_MIDDLE_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_BVN_MCVP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN_MCVP: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_MCVP_PM_CTRL_DIS_108M_CLK_MASK |
           BCHP_CLK_BVN_MCVP_PM_CTRL_DIS_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_MCVP_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_TDAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_TDAC: %s", activate?"on":"off"));

    mask = BCHP_CLK_TDAC_CLK_PM_CTRL_DIS_TDAC_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_TDAC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_QDAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_QDAC: %s", activate?"on":"off"));

    mask = BCHP_CLK_QDAC_CLK_PM_CTRL_DIS_QDAC_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_QDAC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_VEC: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_CLK_PM_CTRL_DIS_108M_CLK_MASK |
           BCHP_CLK_VEC_CLK_PM_CTRL_DIS_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_656_OUT_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_656_OUT: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_656_CLK_PM_CTRL_DIS_VEC_VCXO_656_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_656_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_VEC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_VEC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_CLK_PM_CTRL_DIS_VEC_DAC_216M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));

    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    if (!activate) {
        /* a short delay (~500us) is needed before a power down of the XMEMIF clock */
        BKNI_Sleep(1);
    }

    /* the 216M clock controls XMEMIF */
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));

    /* 5 clocks are tied to RMX */
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_40P5M_CLK_MASK |
        BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_20P25M_CLK_MASK |
        BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_81M_CLK_MASK |
        BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_54M_CLK_MASK |
        BCHP_CLK_XPT_CLK_PM_CTRL_DIS_XPT_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
     uint32_t mask, val;
    BDBG_MSG(("HW_HDMI_TX_TMDS: %s", activate?"on":"off"));

    /* 3 clocks needed for TMDS */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_MAX_250M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_VEC_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* power on/off analog core except CEC */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PLL_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_REF_COMP_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_BG_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);

    /* random bit block */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0_RND_PWRDN_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0, val);

    /* rate managers */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1_I_PWR_DN_CH1_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1, val);

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2_I_PWRDN_CH2_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2, val);

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_A_RESET_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_D_RESET_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);
}

static void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    /* 108M clock needed for register R/W */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_HDMI_TX_CEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_HDMI_TX_CEC_HOTPLUG: %s", activate?"on":"off"));

    /* 2 clocks needed for CEC and hotplug interrupts */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_PM_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* CEC bit in analog core and refamp */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_CEC_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_REFAMP_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);
}

static void BCHP_PWR_P_HW_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

    mask = BCHP_CLK_GFX_2D_PM_CTRL_DIS_216M_CLK_MASK |
           BCHP_CLK_GFX_2D_PM_CTRL_DIS_108M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_GFX_2D_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_PX3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask = BCHP_CLK_GFX_3D_PM_CTRL_DIS_216M_CLK_MASK | BCHP_CLK_GFX_3D_PM_CTRL_DIS_108M_CLK_MASK;
    BDBG_MSG(("HW_PX3D: %s", activate?"on":"off"));

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_GFX_3D_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_DMA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask = BCHP_CLK_SECTOP_DMA_PM_CTRL_DIS_216M_CLK_MASK;
    BDBG_MSG(("HW_DMA: %s", activate?"on":"off"));

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SECTOP_DMA_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_DIGITAL_FRONTEND_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_DIGITAL_FRONTEND: %s", activate?"on":"off"));
    BSTD_UNUSED(handle);
    BSTD_UNUSED(activate);
}

static void BCHP_PWR_P_HW_RFM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_RFM: %s", activate?"on":"off"));

    if (activate) {
        /* step 1 */
        val = BCHP_CLK_RFM_CLK_PM_CTRL_DIS_RFM_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RFM_CLK_PM_CTRL, val, 0);

        /* step 2 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
        val &= ~(BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK |
                 BCHP_RFM_SYSCLK_CLKCTL_VREG_OFF_MASK |
                 BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

        /* step 3 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL);
        val &= ~(BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL_PHASEITP_PWRDN_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL, val);

        /* step 4 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_PLL_MISC1);
        val &= ~(BCHP_RFM_SYSCLK_PLL_MISC1_NDIV_PWRDN_MASK |
                 BCHP_RFM_SYSCLK_PLL_MISC1_REFCOMP_PWRDN_MASK |
                 BCHP_RFM_SYSCLK_PLL_MISC1_PWRDN_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_PLL_MISC1, val);

        /* step 5 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val &= ~(BCHP_RFM_SYSCLK_DACCTL_BIAS50U_OFF_MASK |
                 BCHP_RFM_SYSCLK_DACCTL_BIASLOG_OFF_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* step 6 */
        BKNI_Sleep(1); /* wait 50us for RFM PLL to lock */

        /* step 7 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
        val &= ~(BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

        /* step 8 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val &= ~(BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* 2nd DAC */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val &= ~(BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_2_MASK);
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* this sequence should be followed by a sysclk reset and CRC BIST; this is done inside the PI */
    }
    else {
        /* step 1 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val |= BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* 2nd DAC */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val |= BCHP_RFM_SYSCLK_DACCTL_DAC_PWRDN_2_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* step 2 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
        val |= BCHP_RFM_SYSCLK_CLKCTL_CLK_OFF_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

        /* step 3 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL);
        val |= BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL_PHASEITP_PWRDN_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_RFM_PHASEITP_CTL, val);

        /* step 4 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_PLL_MISC1);
        val |= BCHP_RFM_SYSCLK_PLL_MISC1_NDIV_PWRDN_MASK |
               BCHP_RFM_SYSCLK_PLL_MISC1_REFCOMP_PWRDN_MASK |
               BCHP_RFM_SYSCLK_PLL_MISC1_PWRDN_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_PLL_MISC1, val);

        /* step 5 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL);
        val |= BCHP_RFM_SYSCLK_DACCTL_BIAS50U_OFF_MASK |
                 BCHP_RFM_SYSCLK_DACCTL_BIASLOG_OFF_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_DACCTL, val);

        /* step 6 */
        val = BREG_Read32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL);
        val |= BCHP_RFM_SYSCLK_CLKCTL_RFMCLK_OFF_MASK |
                 BCHP_RFM_SYSCLK_CLKCTL_VREG_OFF_MASK |
                 BCHP_RFM_SYSCLK_CLKCTL_BGCORE_OFF_MASK;
        BREG_Write32(handle->regHandle, BCHP_RFM_SYSCLK_CLKCTL, val);

        /* step 7 */
        val = BCHP_CLK_RFM_CLK_PM_CTRL_DIS_RFM_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_RFM_CLK_PM_CTRL, val, val);
    }
}

static void BCHP_PWR_P_HW_1394_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_1394: %s", activate?"on":"off"));

#if 0
    if (activate) {
        val = (BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_1394_PM_27M_CLK_MASK |
               BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_108M_CLK_MASK |
               BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_216M_CLK_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_TOP1394_CLK_PM_CTRL, val, 0);

        val = BREG_Read32(handle->regHandle, BCHP_AVLINK_PHY_PHY_PM_CTRL);
        val &= ~(BCHP_AVLINK_PHY_PHY_PM_CTRL_BIAS_POWER_DOWN_MASK |
                 BCHP_AVLINK_PHY_PHY_PM_CTRL_DS_POWER_DOWN_MASK |
                 BCHP_AVLINK_PHY_PHY_PM_CTRL_PLL_POWER_DOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_AVLINK_PHY_PHY_PM_CTRL, val);
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_AVLINK_PHY_PHY_PM_CTRL);
        val |= BCHP_AVLINK_PHY_PHY_PM_CTRL_BIAS_POWER_DOWN_MASK |
               BCHP_AVLINK_PHY_PHY_PM_CTRL_DS_POWER_DOWN_MASK |
               BCHP_AVLINK_PHY_PHY_PM_CTRL_PLL_POWER_DOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_AVLINK_PHY_PHY_PM_CTRL, val);

        val = (BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_1394_PM_27M_CLK_MASK |
               BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_108M_CLK_MASK |
               BCHP_CLK_TOP1394_CLK_PM_CTRL_DIS_216M_CLK_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_TOP1394_CLK_PM_CTRL, val, val);
    }
#else
    BSTD_UNUSED(handle);
    BSTD_UNUSED(activate);
    BSTD_UNUSED(val);
#endif
}

static void BCHP_PWR_P_HW_MDM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_MDM: %s", activate?"on":"off"));

#if 0
    if (activate) {
        val = BCHP_CLK_SUN_SM_CLK_PM_CTRL_DIS_SUN_SM_27M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SUN_SM_CLK_PM_CTRL, val, 0);

        val = BCHP_CLK_SUN_DAA_CLK_PM_CTRL_DIS_SUN_DAA_32P4M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SUN_DAA_CLK_PM_CTRL, val, 0);
    }
    else {
        val = BCHP_CLK_SUN_DAA_CLK_PM_CTRL_DIS_SUN_DAA_32P4M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SUN_DAA_CLK_PM_CTRL, val, val);

        val = BCHP_CLK_SUN_SM_CLK_PM_CTRL_DIS_SUN_SM_27M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SUN_SM_CLK_PM_CTRL, val, val);
    }
#else
    BSTD_UNUSED(handle);
    BSTD_UNUSED(activate);
    BSTD_UNUSED(val);
#endif
}

static void BCHP_PWR_P_HW_UHF_INPUT_ANALOG_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val, mask;
    BDBG_MSG(("HW_UHF_INPUT_ANALOG: %s", activate?"on":"off"));

    val = BREG_Read32(handle->regHandle, BCHP_UHFR_GLBL_AUTOPD1);
    mask = BCHP_UHFR_GLBL_AUTOPD1_MANUAL_PD_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_UHFR_GLBL_AUTOPD1, val);
}

static void BCHP_PWR_P_HW_UHF_INPUT_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_UHF_INPUT_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLK_UHFR_CLK_PM_CTRL_DIS_ANA_UHFR_CLK_MASK |
           BCHP_CLK_UHFR_CLK_PM_CTRL_DIS_DIGI_UHFR_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_UHFR_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_SCD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_SCD: %s", activate?"on":"off"));

    if (activate) {
        /* power up VCXO smartcard PLL */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_CTRL);
        mask &= ~(BCHP_VCXO_CTL_MISC_SC_CTRL_POWERDOWN_MASK |
                  BCHP_VCXO_CTL_MISC_SC_CTRL_RESET_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_CTRL, mask);

        /* power up PLL channel 1 post divider */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1);
        mask &= ~BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1, mask);

        /* enable PLL clock outputs */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1);
        mask |= BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1_CLOCK_ENA_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1, mask);
    }
    else {
        /* disable PLL clock outputs */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1);
        mask &= ~BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1_CLOCK_ENA_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_CLOCK_ENA_1, mask);

        /* power down PLL channel 1 post divider  */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1);
        mask |= BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_PM_DIS_CHL_1, mask);

        /* power down VCXO smartcard PLL */
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_CTRL);
        mask |= BCHP_VCXO_CTL_MISC_SC_CTRL_POWERDOWN_MASK |
                BCHP_VCXO_CTL_MISC_SC_CTRL_RESET_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_SC_CTRL, mask);
    }
}

static void BCHP_PWR_P_HW_TMN_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_TMN: %s", activate?"on":"off"));
    BSTD_UNUSED(handle);
    BSTD_UNUSED(activate);

    /* no clocks to toggle */
}

static void BCHP_PWR_P_HW_AVD_PLL_CH_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_AVD_PLL_CH: %s", activate?"on":"off"));

    if (activate) {
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6);
        mask |= BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_EN_CMLBUF_MASK |
                BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_CLOCK_ENA_MASK;
        mask &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6, mask);

        BKNI_Sleep(1); /* wait for PLL to lock */
    }
    else {
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6);
        mask &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_EN_CMLBUF_MASK;
        mask &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_CLOCK_ENA_MASK;
        mask |= BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_6, mask);
    }

}

static void BCHP_PWR_P_HW_RAP_PLL_CH_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_RAP_PLL_CH: %s", activate?"on":"off"));

    if (activate) {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1);
        val |= (BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_CLOCK_ENA_MASK |
                BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_EN_CMLBUF_MASK);
        val &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1, val);

        BKNI_Sleep(1); /* wait for PLL to lock */
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1);
        val &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_CLOCK_ENA_MASK;
        val &= ~BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_EN_CMLBUF_MASK;
        val |= BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CHL_1, val);
    }
}

static void BCHP_PWR_P_HW_AVD_RAP_PLL_CTRL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_AVD_RAP_PLL_CTRL: %s", activate?"on":"off"));

    if (activate) {
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL);
        mask &= ~(BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL_POWERDOWN_MASK |
                BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL_RESET_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL, mask);

        BKNI_Sleep(1); /* wait for PLL to lock */
    }
    else {
        mask = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL);
        mask |= BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL_POWERDOWN_MASK |
                BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL_RESET_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_RAP_AVD_PLL_CTRL, mask);
    }
}

static void BCHP_PWR_P_HW_ACX_PLL_CTRL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_ACX_PLL_CTRL: %s", activate?"on":"off"));

    if (activate) {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC2_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC2_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
                 BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        BKNI_Sleep(1); /* wait for PLL to lock */
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC1_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC1_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC1_CTRL, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL);
        val |= BCHP_VCXO_CTL_MISC_AC2_CTRL_RESET_MASK |
               BCHP_VCXO_CTL_MISC_AC2_CTRL_POWERDOWN_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC2_CTRL, val);
    }
}

static void BCHP_PWR_P_HW_VCX_PLL_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_VCX_PLL_CH1: %s", activate?"on":"off"));

    if (activate) {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1);
        val &= ~BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1, val);
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_1, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1);
        val |= BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_1, val);
    }
}

static void BCHP_PWR_P_HW_VCX_PLL_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_VCX_PLL_CH2: %s", activate?"on":"off"));

    if (activate) {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2);
        val &= ~BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2, val);
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_2, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2);
        val |= BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_2, val);
    }
}

static void BCHP_PWR_P_HW_VCX_PLL_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_VCX_PLL_CH3: %s", activate?"on":"off"));

    if (activate) {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3);
        val &= ~BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3, val);
    }
    else {
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3);
        val |= BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_PM_DIS_CHL_3, val);
    }
}

static void BCHP_PWR_P_HW_VCX_PLL_CTRL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VCX_PLL_CTRL: %s", activate?"on":"off"));

    if (activate) {
        mask = (BCHP_VCXO_CTL_MISC_VC0_CTRL_DRESET_MASK |
                BCHP_VCXO_CTL_MISC_VC0_CTRL_ARESET_MASK |
                BCHP_VCXO_CTL_MISC_VC0_CTRL_POWERDOWN_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL, mask, 0);
        mask = (BCHP_VCXO_CTL_MISC_VC1_CTRL_DRESET_MASK |
                BCHP_VCXO_CTL_MISC_VC1_CTRL_ARESET_MASK |
                BCHP_VCXO_CTL_MISC_VC1_CTRL_POWERDOWN_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_CTRL, mask, 0);
    }
    else {
        mask = (BCHP_VCXO_CTL_MISC_VC0_CTRL_DRESET_MASK |
                BCHP_VCXO_CTL_MISC_VC0_CTRL_ARESET_MASK |
                BCHP_VCXO_CTL_MISC_VC0_CTRL_POWERDOWN_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_CTRL, mask, mask);
        mask = (BCHP_VCXO_CTL_MISC_VC1_CTRL_DRESET_MASK |
                BCHP_VCXO_CTL_MISC_VC1_CTRL_ARESET_MASK |
                BCHP_VCXO_CTL_MISC_VC1_CTRL_POWERDOWN_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC1_CTRL, mask, mask);
    }
}



static void BCHP_PWR_P_HW_SYS_PLL_0_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask = BCHP_CLK_SYS_PLL_0_PLL_3_DIS_CH_MASK;
    BDBG_MSG(("HW_SYS_PLL_0_CH3: %s", activate?"on":"off"));

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_0_PLL_3, mask, activate ? 0 : mask);
}
