/***************************************************************************
*     Copyright (c) 2006-2014, Broadcom Corporation*
*     All Rights Reserved*
*     Confidential Property of Broadcom Corporation*
*
*  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
*  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
*  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
*
* $brcm_Workfile: $
* $brcm_Revision: $
* $brcm_Date: $
*
* Module Description:
*
* Revision History:
*
* $brcm_Log: $
*
***************************************************************************/
/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clkgen.h"
#include "bchp_avs_top_ctrl.h"
#include "bchp_hdmi_tx_phy.h"
#include "bchp_aud_fmm_iop_pll_0.h"
#include "bchp_aud_fmm_iop_pll_1.h"
#include "bchp_aud_fmm_iop_out_dac_ctrl_0.h"
#include "bchp_pm.h"

BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_HVD0_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_CORE_CLK: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_AVD_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_HVD0_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_CPU_CLK: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask =  BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_CPU_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_HVD0_SCB_54_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SCB_54_CLK: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_54_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_HVD0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD_SRAM_PDA_IN_HVD_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD, reg);
}

static void BCHP_PWR_P_HW_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AIO: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_ALTERNATE_108_3_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_ALTERNATE_108_2_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_ALTERNATE_SCB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO_SRAM_PDA_IN_AIO_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO, reg);
}

static void BCHP_PWR_P_HW_AUD_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AUD_DAC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1);
    mask = ( BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_main_delay_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_V2I_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_LDO1p5_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_main_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_NegLDO_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_aux_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_Local1p8cp_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1_STB_DRV_pu_instage_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_1, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2);
    mask = ( BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_CP_pu_Lshifter_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_DACbuf_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_CP_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_pu_MASK |
             BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2_STB_Ref_filt_pu_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_OUT_DAC_CTRL_0_ANALOG_CTRL_REG_2, reg);
}

static void BCHP_PWR_P_HW_RAAGA0_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_CLK: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_108_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_54_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_RAAGA0_DSP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_DSP: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA0_DSP_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0_SRAM_PDA_IN_RAAGA0_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0, reg);
}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVNM_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVNM_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVNM_BVB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVNT_108_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_MVP_TOP_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE_BVNT_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE_BVNT_SCB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_BVN_BVB_GISB_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN_BVB_GISB: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE_BVNT_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE_BVNT_BVB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_BVN_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN_SRAM_PDA_IN_BVN_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND_SRAM_PDA_IN_BVND_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND, reg);
}

static void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_QDAC_216_CLOCK_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_BVB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF_VEC_ALTERNATE_BVB_CLOCK_ENABLE_VEC_QDAC_INTF_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF, reg);
}

static void BCHP_PWR_P_HW_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VEC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_648_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_AIO_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_BVB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_108_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_GISB2_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_SCB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_GISB0_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC_SRAM_PDA_IN_VEC_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC, reg);
}

static void BCHP_PWR_P_HW_VDC_656_OUT_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VDC_656_OUT: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE);
    mask = ( BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_ITU656_0_CLOCK_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_VEC_AIO_TOP_INST_CLOCK_DISABLE, reg);
}

static void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));
    BSTD_UNUSED(mask);
    BSTD_UNUSED(reg);
    BSTD_UNUSED(handle);

    /*
      reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE);
      mask = ( BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
      BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
      BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK |
      BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK |
      BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK );
      reg &= ~mask;
      reg |= activate?0:mask;
      BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_DISABLE, reg);
    */
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE_XPT_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE_XPT_CORE_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE_XPT_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_CORE_XPT_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL);
    mask = BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL_CLOCK_Async_CG_XPT_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL);
    mask = ( BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_XPT_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, reg);
}

static void BCHP_PWR_P_HW_HDMI_TX_PHY_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HDMI_TX_PHY: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL);
    mask = ( BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, RNDGEN_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PLL_PWRDN)  |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PLL_LDO_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, BIAS_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, LDO_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, BG_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PHY_PWRDN));
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL, reg);
}

static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE_DVPHT_54_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE);
    mask = BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE_DVPHT_CLK_SYS_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE, reg);
}

static void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE);
    mask =  BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE);
    mask = BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE_DVPHT_CLK_VEC_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_DVP_HT_INST_ENABLE, reg);
}

static void BCHP_PWR_P_HW_M2MC0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE0);
    mask = ( BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE0_GFX_M2MC0_GISB_CLOCK_ENABLE0_MASK |
             BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE0_GFX_M2MC0_SCB_CLOCK_ENABLE0_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE0, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0);
    mask = BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0_GFX_M2MC_CLOCK_ENABLE_M2MC0_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0, reg);
}

static void BCHP_PWR_P_HW_M2MC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE1);
    mask = ( BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE1_GFX_M2MC1_GISB_CLOCK_ENABLE1_MASK |
             BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE1_GFX_M2MC1_SCB_CLOCK_ENABLE1_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE1, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0);
    mask = BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0_GFX_M2MC1_CLOCK_ENABLE_M2MC0_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_GRAPHICS_INST_CLOCK_ENABLE_M2MC0, reg);
}

static void BCHP_PWR_P_HW_M2MC0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX_SRAM_PDA_IN_GFX_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX, reg);
}

static void BCHP_PWR_P_HW_M2MC1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC1_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1_SRAM_PDA_IN_M2MC1_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1, reg);
}

static void BCHP_PWR_P_HW_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_V3D: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE_V3D_54_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE_V3D_BVB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE_V3D_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE_V3D_GISB_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE_V3D_SCB_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_V3D_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_V3D_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_V3D_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D_SRAM_PDA_IN_V3D_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D, reg);
}

static void BCHP_PWR_P_HW_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SCD0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE, reg);
}

static void BCHP_PWR_P_HW_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SCD1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_SYS_CTRL_INST_CLOCK_DISABLE, reg);
}

static void BCHP_PWR_P_HW_TEMP_MONITOR_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_TEMP_MONITOR: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_PM_CLK_CTRL);
    mask = BCHP_PM_CLK_CTRL_tmon_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_PM_CLK_CTRL, reg);
}

static void BCHP_PWR_P_HW_HVD0_SID_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SID: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = ( BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_SID_CLOCK_ENABLE_MASK );
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ONOFF_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);
}

static void BCHP_PWR_P_HW_SID_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SID_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID);
    mask = ( BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID_SRAM_PDA_IN_SID_MASK );
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID, reg);
}

static void BCHP_PWR_P_HW_PLL_HVD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_HVD_CH1: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);
    }

}

static void BCHP_PWR_P_HW_PLL_HVD_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_HVD_CH2: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2);
        mask = ( BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_2, reg);
    }

}

static void BCHP_PWR_P_HW_AUD_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AUD_PLL0: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
                 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, AUD_FMM_IOP_PLL_0_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("Audio0 PLL Lock Timeout"));

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0);
        mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_AUDO0_ISO_OUT_SEL_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0);
        mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_AUDO0_ISO_OUT_SEL_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
                 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_RESET, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AUD_PLL1: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
                 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, AUD_FMM_IOP_PLL_0_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("Audio0 PLL Lock Timeout"));

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1);
        mask =  BCHP_CLKGEN_PLL_AUDIO1_PLL_AUDO0_ISO_OUT_SEL_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1);
        mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_AUDO0_ISO_OUT_SEL_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETD_MASK |
                 BCHP_AUD_FMM_IOP_PLL_0_RESET_RESETA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_RESET, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON);
        mask = ( BCHP_AUD_FMM_IOP_PLL_0_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_AUD_FMM_IOP_PLL_1_BG_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH0: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL0_CH2: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_2, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL0: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON, reg);

        mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, 0);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO0_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO0_PLL_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("VCXO 0 PLL Lock Timeout"));
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO0_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

        mask = (BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, mask);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_BG_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH0: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL1_CH2: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2);
        mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_2, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_VCXO_PLL1: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON, reg);

        mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, 0);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO1_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO1_PLL_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("VCXO 1 PLL Lock Timeout"));
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO1_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

        mask = (BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, mask);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON);
        mask = ( BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON_BG_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_BG_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_XPT_CH5_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_XPT_CH5: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5);
        mask =  BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5_CLOCK_DIS_CH5_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5);
        mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5_POST_DIVIDER_HOLD_CH5_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5);
        mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5_POST_DIVIDER_HOLD_CH5_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5);
        mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5_CLOCK_DIS_CH5_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_5, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_NETWORK_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_NETWORK_CH3: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3);
        mask = BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3);
        mask = BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3);
        mask = BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3);
        mask = BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_NETWORK_PLL_CHANNEL_CTRL_CH_3, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD0_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_SCD0_CH0: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_SCD0: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_SC0_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC0_PLL_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("SmartCard 0 PLL Lock Timeout"));
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_SC0_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_RESET, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_SC0_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD1_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_SCD1_CH0: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
        mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_SCD1: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_SC1_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC1_PLL_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("SmartCard 1 PLL Lock Timeout"));
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_SC1_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_RESET, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_SC1_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_PWRON, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_PLL_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_RAAGA_PLL_CH0: %s", activate?"on":"off"));

    if(activate) {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);
    } else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);
    }
}

static void BCHP_PWR_P_HW_PLL_RAAGA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PLL_RAAGA: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, reg);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_RAAGA_PLL_LOCK_STATUS, LOCK))
            break;
        }
        if(!cnt)
            BDBG_ERR(("RAAGA PLL Lock Timeout"));

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_RAAGA_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);
    }else {
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
        mask = ( BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_RAAGA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK |
                 BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK );
        reg &= ~mask;
        reg |= mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON, reg);

        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON);
        mask = ( BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON_PWRON_PLL_MASK );
        reg &= ~mask;
        BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON, reg);
    }
}
