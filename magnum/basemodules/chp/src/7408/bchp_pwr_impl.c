/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clk.h"
#include "bchp_hdmi_tx_phy.h"
#include "bchp_aio_misc.h"
#include "bchp_vcxo_ctl_misc.h"
#include "bchp_uhfr_glbl.h"

BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_AVD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_AVD0: %s", activate?"on":"off"));
    
    if (activate) {        
        mask = BCHP_CLK_SYS_PLL_1_1_DIS_CH_MASK | BCHP_CLK_SYS_PLL_1_1_EN_CMLBUF_MASK;
        val = 0 | BCHP_CLK_SYS_PLL_1_1_EN_CMLBUF_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_1_1, mask, val);

        /* Wait for PLLs to lock */
        BKNI_Sleep(1);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_AVD0_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, 0);
    }
    else {
        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_AVD0_PROG_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_216M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_AVD0_CLK_PM_CTRL_DIS_108M_CLK_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_AVD0_CLK_PM_CTRL, mask, mask);

        mask = BCHP_CLK_SYS_PLL_1_1_DIS_CH_MASK | BCHP_CLK_SYS_PLL_1_1_EN_CMLBUF_MASK;
        val = BCHP_CLK_SYS_PLL_1_1_DIS_CH_MASK | 0;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_SYS_PLL_1_1, mask, val);
    }
}

static void BCHP_PWR_P_HW_APE_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val;
    BDBG_MSG(("HW_APE_AIO: %s", activate?"on":"off"));
 
    if (activate) {
	/* AIO clocks */
        val = BCHP_CLK_AIO_CLK_PM_CTRL_DIS_AIO_216M_CLK_MASK;
        BREG_AtomicUpdate32( handle->regHandle, BCHP_CLK_AIO_CLK_PM_CTRL, val, 0);
	
	val = BCHP_CLK_AIO_CLK_PM_CTRL_DIS_AIO_108M_CLK_MASK;
        BREG_AtomicUpdate32( handle->regHandle, BCHP_CLK_AIO_CLK_PM_CTRL, val, 0);

	/* VC0 */
	val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val &= ~BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

	/* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val &= ~(BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
		 BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);

	val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
	val |= BCHP_AIO_MISC_PWRDOWN_PWR_AUTO_MASK;
	val &= ~(BCHP_AIO_MISC_PWRDOWN_REF_PD_MASK |
		 BCHP_AIO_MISC_PWRDOWN_D2C_PD_MASK |
		 BCHP_AIO_MISC_PWRDOWN_VAC2_PD_MASK | 
		 BCHP_AIO_MISC_PWRDOWN_VAC1_PD_MASK);
	BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);
    }
    else {
	val = BREG_Read32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN);
	val &= ~BCHP_AIO_MISC_PWRDOWN_PWR_AUTO_MASK;
	val |= (BCHP_AIO_MISC_PWRDOWN_REF_PD_MASK |
		BCHP_AIO_MISC_PWRDOWN_D2C_PD_MASK |
		BCHP_AIO_MISC_PWRDOWN_VAC2_PD_MASK | 
		BCHP_AIO_MISC_PWRDOWN_VAC1_PD_MASK);
	BREG_Write32(handle->regHandle, BCHP_AIO_MISC_PWRDOWN, val);
	
	/* AC0 */
        val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL);
        val |= (BCHP_VCXO_CTL_MISC_AC0_CTRL_RESET_MASK |
		BCHP_VCXO_CTL_MISC_AC0_CTRL_POWERDOWN_MASK);
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_AC0_CTRL, val);
	
	/* VC0 */
	val = BREG_Read32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3);
        val |= BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3_DIS_CH_MASK;
        BREG_Write32(handle->regHandle, BCHP_VCXO_CTL_MISC_VC0_PM_DIS_CHL_3, val);

	/* AIO clocks */
        val = BCHP_CLK_AIO_CLK_PM_CTRL_DIS_AIO_216M_CLK_MASK;
        BREG_AtomicUpdate32( handle->regHandle, BCHP_CLK_AIO_CLK_PM_CTRL, val, val);
	
	val = BCHP_CLK_AIO_CLK_PM_CTRL_DIS_AIO_108M_CLK_MASK;
        BREG_AtomicUpdate32( handle->regHandle, BCHP_CLK_AIO_CLK_PM_CTRL, val, val);
    }
}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_2ND_108M_CLK_MASK |
	   BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_2ND_216M_CLK_MASK |           
           BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_TOP_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_BVN_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;	
    BDBG_MSG(("HW_BVN_108M: %s", activate?"on":"off"));

    mask = BCHP_CLK_BVN_TOP_CLK_PM_CTRL_DIS_108M_CLK_MASK;	
	
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_BVN_TOP_CLK_PM_CTRL, mask, activate ? 0 : mask);	
}

static void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_CLK_PM_CTRL_DIS_VEC_DAC_108M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_VDC_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VDC_VEC: %s", activate?"on":"off"));

    mask = BCHP_CLK_VEC_CLK_PM_CTRL_DIS_VEC_108M_CLK_MASK |
           BCHP_CLK_VEC_CLK_PM_CTRL_DIS_VEC_216M_CLK_MASK;
    
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_VEC_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));  

    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));   

    if (!activate) {
        /* a short delay (~500us) is needed before a power down of the XMEMIF clock */
        BKNI_Sleep(1);
    }

    /* the 216M clock controls XMEMIF */
    mask = BCHP_CLK_XPT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_XPT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}


static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    /* 3 clocks needed for TMDS */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_MAX_PROG_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);   

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_VEC_216M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* power on/off analog core except CEC */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PLL_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_REF_COMP_PWRDN_MASK |
            BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_BG_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);

    /* random bit block */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0_RND_PWRDN_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_0, val);

    /* rate managers */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1_I_PWR_DN_CH1_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_1, val);

    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2);
    mask = BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2_I_PWRDN_CH2_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_CTL_2, val);
}

static void BCHP_PWR_P_HW_HDMI_TX_CEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, val;
    BDBG_MSG(("HW_HDMI_TX_CEC: %s", activate?"on":"off"));

    /* 2 clocks needed for CEC and hotplug interrupts */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_PM_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_HDMI_27M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    /* CEC bit in analog core and refamp */
    val = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL);
    mask = (BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_CEC_MASK |
        BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL_PWRDN_REFAMP_MASK);
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_HDMI_TX_PHY_RESET_CTL, val);
}

static void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    /* 108M clock needed for register R/W */
    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_2ND_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);

    mask = BCHP_CLK_DVP_HT_CLK_PM_CTRL_DIS_108M_CLK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_DVP_HT_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

    mask = BCHP_CLK_GFX_2D_CLK_PM_CTRL_DIS_216M_CLK_MASK | 
           BCHP_CLK_GFX_2D_CLK_PM_CTRL_DIS_108M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_GFX_2D_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_PX3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask; 
    BDBG_MSG(("HW_PX3D: %s", activate?"on":"off"));
    
    mask = BCHP_CLK_GFX_3D_CLK_PM_CTRL_DIS_216M_CLK_MASK | 
           BCHP_CLK_GFX_3D_CLK_PM_CTRL_DIS_108M_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_GFX_3D_CLK_PM_CTRL, mask, activate ? 0 : mask);
}

static void BCHP_PWR_P_HW_UHF_INPUT_ANALOG_Control(BCHP_Handle handle, bool activate)
{
    uint32_t val, mask;
    BDBG_MSG(("HW_UHF_INPUT_ANALOG: %s", activate?"on":"off"));

    val = BREG_Read32(handle->regHandle, BCHP_UHFR_GLBL_AUTOPD1);
    mask = BCHP_UHFR_GLBL_AUTOPD1_MANUAL_PD_MASK;
    if (activate) {
        val &= ~mask;
    }
    else {
        val |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_UHFR_GLBL_AUTOPD1, val);
}

static void BCHP_PWR_P_HW_UHF_INPUT_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_UHF_INPUT_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLK_UHFR_CLK_PM_CTRL_DIS_ANA_UHFR_CLK_MASK | 
           BCHP_CLK_UHFR_CLK_PM_CTRL_DIS_DIGI_UHFR_CLK_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLK_UHFR_CLK_PM_CTRL, mask, activate ? 0 : mask);
}








