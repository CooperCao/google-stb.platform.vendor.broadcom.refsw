/***************************************************************************
*     Copyright (c) 2006-2014, Broadcom Corporation*
*     All Rights Reserved*
*     Confidential Property of Broadcom Corporation*
*
*  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
*  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
*  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
*
* $brcm_Workfile: $
* $brcm_Revision: $
* $brcm_Date: $
*
* Module Description:
*
* Revision History:
*
* $brcm_Log: $
*
***************************************************************************/
/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"
#include "bchp_clkgen.h"
#include "bchp_avs_top_ctrl.h"


BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AIO: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO);
    mask = (BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE_108_CLOCK_ENABLE_AIO_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO_AIO_ALTERNATE_SCB_CLOCK_ENABLE_AIO_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_AIO, reg);

}

static void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO_SRAM_PDA_IN_AIO_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_AIO, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_AIO);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_AIO_SRAM_PDA_OUT_AIO_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_AIO_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_BVB_324_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE_BVND_54_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_BVN_MVP_TOP_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_54_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_BVN_DVPHR0_DVPHT0_DVPHT1_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN_DVPHR0_DVPHT0_DVPHT1_VEC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_GISB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE_BVN_BVB_324_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN_SRAM_PDA_IN_BVN_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVN, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND_SRAM_PDA_IN_BVND_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_BVND, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_BVN);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_BVN_SRAM_PDA_OUT_BVN_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_BVN_SRAM Timeout"));
    }

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_BVND);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_BVND_SRAM_PDA_OUT_BVND_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_BVN_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_DVPHR0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHR0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_DVP_HR_INST_CLOCK_DISABLE_DISABLE_DVPHR_ALWAYSON_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_DISABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_BVB_324_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE_DVPHR_HD_DVI_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE0);
    mask = BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE0_DVPHR_108_CLOCK_ENABLE0_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HR_INST_CLOCK_ENABLE0, reg);

}

static void BCHP_PWR_P_HW_DVPHR0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHR0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHR);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHR_SRAM_PDA_IN_DVPHR_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHR, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_DVPHR);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_DVPHR_SRAM_PDA_OUT_DVPHR_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_DVPHR0_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_DVPHT0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHT0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE_DVPHT_54_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE);
    mask = (BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE_DVPHT_CLK_MAX_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE_DVPHT_CLK_VEC_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE, reg);

}

static void BCHP_PWR_P_HW_DVPHT0_DVPHT1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHT0_DVPHT1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_DISABLE_DISABLE_DVPHT_IIC_MASTER_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_DISABLE, reg);

}

static void BCHP_PWR_P_HW_DVPHT1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHT1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE_DVPHT_1_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE_DVPHT_1_108_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_CLOCK_ENABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE);
    mask = (BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE_DVPHT_1_CLK_MAX_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE_DVPHT_1_CLK_VEC_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_DVP_HT_DUAL_WRAPPER_INST_ENABLE, reg);

}

static void BCHP_PWR_P_HW_DVPHT_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_DVPHT_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHT);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHT_SRAM_PDA_IN_DVPHT_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_DVPHT, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_DVPHT);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_DVPHT_SRAM_PDA_OUT_DVPHT_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_DVPHT_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_GRAPHICS_M2MC1_GFX_M2MC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_GRAPHICS_M2MC1_GFX_M2MC1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1);
    mask = BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1_GFX_CLOCK_ENABLE_M2MC1_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1, reg);

}

static void BCHP_PWR_P_HW_GRAPHICS_M2MC_GFX_54_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_GRAPHICS_M2MC_GFX_54_M2MC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC);
    mask = BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC_GFX_54_CLOCK_ENABLE_M2MC_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC, reg);

}

static void BCHP_PWR_P_HW_HVD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_108_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_HVD0_SID_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SID: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_SCB_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_HVD0_SID_SECBUS_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SID_SECBUS: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_GISB_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_HVD0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD_SRAM_PDA_IN_HVD_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_HVD, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_HVD);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_HVD_SRAM_PDA_OUT_HVD_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_HVD0_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_HVD_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_HVD_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_HVD_CH_CTRL_CH_1_DIS_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_CH_CTRL_CH_1_DIS_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_HVD_CH_CTRL_CH_1_POST_DIV_HOLD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_CH_CTRL_CH_1_POST_DIV_HOLD_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_HVD_LDO_PWRON_LDO_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_LDO_PWRON_LDO_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_LDO_PWRON, reg);

    BKNI_Delay(2);
}

static void BCHP_PWR_P_HW_HVD_PWRON_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_PWRON_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_PWRON);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_PWRON_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_PWRON, reg);

}

static void BCHP_PWR_P_HW_HVD_RESET_RESETA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_RESET_RESETA: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETA_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET, reg);

    BKNI_Delay(30);
}

static void BCHP_PWR_P_HW_HVD_RESET_RESETD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_RESET_RESETD: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET);
    mask = BCHP_CLKGEN_PLL_HVD_PLL_RESET_RESETD_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_HVD_PLL_RESET, reg);

}

static void BCHP_PWR_P_HW_HVD_SID0_HVD_CORE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_SID0_HVD_CORE: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_CORE_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_HVD_SID0_HVD_CPU_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HVD_SID0_HVD_CPU: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_HVD_CPU_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_ITU656_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_ITU656: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_ITU656_0_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, reg);

}

static void BCHP_PWR_P_HW_M2MC0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_ALT_CLOCK_ENABLE_M2MC);
    mask = BCHP_CLKGEN_GRAPHICS_INST_ALT_CLOCK_ENABLE_M2MC_GFX_GISB_ALT_CLOCK_ENABLE_M2MC_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_ALT_CLOCK_ENABLE_M2MC, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC);
    mask = (BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC_GFX_GISB_CLOCK_ENABLE_M2MC_MASK |
            BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC_GFX_SCB_CLOCK_ENABLE_M2MC_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC, reg);

}

static void BCHP_PWR_P_HW_M2MC0_M2MC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC0_M2MC1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC);
    mask = BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC_GFX_CLOCK_ENABLE_M2MC_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC, reg);

}

static void BCHP_PWR_P_HW_M2MC0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX_SRAM_PDA_IN_GFX_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_GFX, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_GFX);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_GFX_SRAM_PDA_OUT_GFX_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_M2MC0_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_M2MC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1);
    mask = (BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1_GFX_SCB_CLOCK_ENABLE_M2MC1_MASK |
            BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1_GFX_GISB_CLOCK_ENABLE_M2MC1_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_INST_CLOCK_ENABLE_M2MC1, reg);

}

static void BCHP_PWR_P_HW_M2MC1_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_M2MC1_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1_SRAM_PDA_IN_M2MC1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_M2MC1, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_M2MC1);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_M2MC1_SRAM_PDA_OUT_M2MC1_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_M2MC1_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_MOCA_CH_CTRL_CH_3_DIS_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_MOCA_CH_CTRL_CH_3_DIS_CH3: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3);
    mask = BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, reg);

}

static void BCHP_PWR_P_HW_MOCA_CH_CTRL_CH_3_POST_DIV_HOLD_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_MOCA_CH_CTRL_CH_3_POST_DIV_HOLD_CH3: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3);
    mask = BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_3, reg);

}

static void BCHP_PWR_P_HW_MOCA_CH_CTRL_CH_4_DIS_CH4_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_MOCA_CH_CTRL_CH_4_DIS_CH4: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4);
    mask = BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_CLOCK_DIS_CH4_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, reg);

}

static void BCHP_PWR_P_HW_MOCA_CH_CTRL_CH_4_POST_DIV_HOLD_CH4_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_MOCA_CH_CTRL_CH_4_POST_DIV_HOLD_CH4: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4);
    mask = BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4_POST_DIVIDER_HOLD_CH4_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_MOCA_PLL_CHANNEL_CTRL_CH_4, reg);

}

static void BCHP_PWR_P_HW_PM_LDO_POWERUP_ISO_HVD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PM_LDO_POWERUP_ISO_HVD: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_HVD_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

}

static void BCHP_PWR_P_HW_PM_LDO_POWERUP_ISO_RAAGA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PM_LDO_POWERUP_ISO_RAAGA: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_RAAGA_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

}

static void BCHP_PWR_P_HW_PM_LDO_POWERUP_ISO_VCXO0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PM_LDO_POWERUP_ISO_VCXO0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

}

static void BCHP_PWR_P_HW_PM_LDO_POWERUP_ISO_VCXO1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_PM_LDO_POWERUP_ISO_VCXO1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP);
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_VCXO1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, reg);

}

static void BCHP_PWR_P_HW_RAAGA0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA_SCB_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_RAAGA0_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_AIO: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA_108_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_RAAGA0_AIO_SECBUS_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_AIO_SECBUS: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA_GISB_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0_SRAM_PDA_IN_RAAGA0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_RAAGA0, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_RAAGA0);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_RAAGA0_SRAM_PDA_OUT_RAAGA0_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_RAAGA0_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_RAAGA_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_RAAGA_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_RAAGA_CH_CTRL_CH_3_DIS_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_CH_CTRL_CH_3_DIS_CH3: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, reg);

}

static void BCHP_PWR_P_HW_RAAGA_CH_CTRL_CH_3_POST_DIV_HOLD_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_CH_CTRL_CH_3_POST_DIV_HOLD_CH3: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_3, reg);

}

static void BCHP_PWR_P_HW_RAAGA_DSP_0_RAAGA_DSP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_DSP_0_RAAGA_DSP: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE_RAAGA_DSP_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_RAAGA_LDO_PWRON_LDO_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_LDO_PWRON_LDO_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_LDO_PWRON, reg);

    BKNI_Delay(2);
}

static void BCHP_PWR_P_HW_RAAGA_PWRON_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_PWRON_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_PWRON, reg);

}

static void BCHP_PWR_P_HW_RAAGA_RESET_RESETA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_RESET_RESETA: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETA_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, reg);

    BKNI_Delay(30);
}

static void BCHP_PWR_P_HW_RAAGA_RESET_RESETD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RAAGA_RESET_RESETD: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET);
    mask = BCHP_CLKGEN_PLL_RAAGA_PLL_RESET_RESETD_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_RESET, reg);

}

static void BCHP_PWR_P_HW_RFM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_RFM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE_RFM_GISB_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_SC0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, reg);

}

static void BCHP_PWR_P_HW_SC0_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC0_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_SC0_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC0_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC0_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_SC1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_INST_CLOCK_DISABLE, reg);

}

static void BCHP_PWR_P_HW_SC1_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC1_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_SC1_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SC1_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_SC1_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_SID_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SID: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_SID);
    mask = BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_SID_HVD_CLOCK_ENABLE_SID_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_HVD_SID0_TOP_INST_CLOCK_ENABLE_SID, reg);

}

static void BCHP_PWR_P_HW_SID_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_SID_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID_SRAM_PDA_IN_SID_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_SID, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_SID);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_SID_SRAM_PDA_OUT_SID_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_SID_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_V3D: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_GISB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_SCB_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_V3D_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_V3D_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D_SRAM_PDA_IN_V3D_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_V3D, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_V3D);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_V3D_SRAM_PDA_OUT_V3D_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_V3D_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_V3D_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_V3D_V3D: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE_V3D_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_V3D_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_VCXO0_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_VCXO0_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_VCXO0_CH_CTRL_CH_1_DIS_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_CH_CTRL_CH_1_DIS_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_VCXO0_CH_CTRL_CH_1_POST_DIV_HOLD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_CH_CTRL_CH_1_POST_DIV_HOLD_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_VCXO0_LDO_PWRON_LDO_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_LDO_PWRON_LDO_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_LDO_PWRON, reg);

    BKNI_Delay(25);
}

static void BCHP_PWR_P_HW_VCXO0_PWRON_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_PWRON_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON);
    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_PWRON, reg);

}

static void BCHP_PWR_P_HW_VCXO0_RESET_RESETA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_RESET_RESETA: %s", activate?"on":"off"));

    BSTD_UNUSED(reg);

    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETA_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, activate?0:mask);

    BKNI_Delay(30);
}

static void BCHP_PWR_P_HW_VCXO0_RESET_RESETD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO0_RESET_RESETD: %s", activate?"on":"off"));

    BSTD_UNUSED(reg);

    mask = BCHP_CLKGEN_PLL_VCXO0_PLL_RESET_RESETD_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO0_PLL_RESET, mask, activate?0:mask);

}

static void BCHP_PWR_P_HW_VCXO1_CH_CTRL_CH_0_DIS_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_CH_CTRL_CH_0_DIS_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_VCXO1_CH_CTRL_CH_0_POST_DIV_HOLD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_CH_CTRL_CH_0_POST_DIV_HOLD_CH0: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_0, reg);

}

static void BCHP_PWR_P_HW_VCXO1_CH_CTRL_CH_1_DIS_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_CH_CTRL_CH_1_DIS_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_VCXO1_CH_CTRL_CH_1_POST_DIV_HOLD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_CH_CTRL_CH_1_POST_DIV_HOLD_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_VCXO1_LDO_PWRON_LDO_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_LDO_PWRON_LDO_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON_LDO_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_LDO_PWRON, reg);

    BKNI_Delay(25);
}

static void BCHP_PWR_P_HW_VCXO1_PWRON_PWRON_PLL_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_PWRON_PWRON_PLL: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON);
    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON_PWRON_PLL_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_PWRON, reg);

}

static void BCHP_PWR_P_HW_VCXO1_RESET_RESETA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_RESET_RESETA: %s", activate?"on":"off"));

    BSTD_UNUSED(reg);

    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETA_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, activate?0:mask);

    BKNI_Delay(30);
}

static void BCHP_PWR_P_HW_VCXO1_RESET_RESETD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VCXO1_RESET_RESETD: %s", activate?"on":"off"));

    BSTD_UNUSED(reg);

    mask = BCHP_CLKGEN_PLL_VCXO1_PLL_RESET_RESETD_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO1_PLL_RESET, mask, activate?0:mask);

}

static void BCHP_PWR_P_HW_VDAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VDAC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_ANA_QDAC_TS28HPM_6MX_2MR_FC_H_E_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_ANA_QDAC_TS28HPM_6MX_2MR_FC_H_E_INST_CLOCK_DISABLE_DISABLE_QDAC_DACADC_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_ANA_QDAC_TS28HPM_6MX_2MR_FC_H_E_INST_CLOCK_DISABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_DISABLE, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_GISB_CLOCK_ENABLE_VEC_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF_VEC_GISB_CLOCK_ENABLE_VEC_QDAC_INTF_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_QDAC_INTF, reg);

}

static void BCHP_PWR_P_HW_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VEC: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC);
    mask = (BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_BVB_324_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_SCB_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_GISB_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_VEC_108_CLOCK_ENABLE_VEC_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_ENABLE);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_ENABLE_VEC_CLK_648_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_ENABLE, reg);

}

static void BCHP_PWR_P_HW_VEC_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VEC_AIO: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE_VEC_AIO_54_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC_SRAM_PDA_IN_VEC_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VEC, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_VEC);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_VEC_SRAM_PDA_OUT_VEC_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_VEC_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_VICE20_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VICE20: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_SCB_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_VICE20_SECBUS_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VICE20_SECBUS: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_GISB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_GISB_ALTERNATE_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_VICE20_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VICE20_SRAM: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_0);
    mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_0_SRAM_PDA_IN_VICE2_0_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_IN_VICE2_0, reg);

    {
        uint32_t val=0, cnt=50;
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_VICE2_0);
            mask = BCHP_AVS_TOP_CTRL_SRAM_POWER_GATE_OUT_VICE2_0_SRAM_PDA_OUT_VICE2_0_MASK;
            reg &= mask;
            val |= activate?0:mask;
            if (val == reg)
                break;
        }
        if(!cnt)
            BDBG_ERR(("HW_VICE20_SRAM Timeout"));
    }

}

static void BCHP_PWR_P_HW_VICE2_0_VICE2_0_CORE_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_VICE2_0_VICE2_0_CORE: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE_VICE2_0_CORE_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_VICE2_0_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_XPT_CH_CTRL_CH_1_DIS_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_CH_CTRL_CH_1_DIS_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_XPT_CH_CTRL_CH_1_POST_DIV_HOLD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_CH_CTRL_CH_1_POST_DIV_HOLD_CH1: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1);
    mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_1, reg);

}

static void BCHP_PWR_P_HW_XPT_CH_CTRL_CH_2_DIS_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_CH_CTRL_CH_2_DIS_CH2: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2);
    mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2, reg);

}

static void BCHP_PWR_P_HW_XPT_CH_CTRL_CH_2_POST_DIV_HOLD_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_CH_CTRL_CH_2_POST_DIV_HOLD_CH2: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2);
    mask = BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PLL_XPT_PLL_CHANNEL_CTRL_CH_2, reg);

}

static void BCHP_PWR_P_HW_XPT_REMUX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_REMUX: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE);
    mask = (BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK);
    reg &= ~mask;
    reg |= activate?0:mask;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_DISABLE, reg);

}

static void BCHP_PWR_P_HW_XPT_SECBUS_XPT_REMUX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_SECBUS_XPT_REMUX: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_GISB_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL);
    mask = BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL_CLOCK_Async_CG_XPT_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_Async_ALIVE_SEL, reg);

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL);
    mask = BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_XPT_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, reg);

}

static void BCHP_PWR_P_HW_XPT_XPT_REMUX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_XPT_REMUX: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE);
    mask = (BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_54_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK);
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, reg);

}

static void BCHP_PWR_P_HW_XPT_XPT_WAKEUP_SECBUS_XPT_REMUX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_XPT_XPT_WAKEUP_SECBUS_XPT_REMUX: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE);
    mask = BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE_XPT_CORE_CLOCK_ENABLE_MASK;
    reg &= ~mask;
    reg |= activate?mask:0;
    BREG_Write32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_INST_CLOCK_ENABLE, reg);

}
