/***************************************************************************
*     Copyright (c) 2006-2014, Broadcom Corporation
*     All Rights Reserved
*     Confidential Property of Broadcom Corporation
*
*  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
*  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
*  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
*
* $brcm_Workfile: $
* $brcm_Revision: $
* $brcm_Date: $
*
* Module Description:
*
* Revision History:
*
* $brcm_Log: $
*
***************************************************************************/
/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clkgen.h"
#include "bchp_hdmi_tx_phy.h"
#include "bchp_aio_misc.h"

BDBG_MODULE(BCHP_PWR_IMPL);

#define BCHP_PWR_P_DIV_CONTROL(mult_reg, mult_field, prediv_reg, prediv_field, postdiv_reg, postdiv_field) \
    BDBG_ASSERT(BCHP_##mult_reg == BCHP_##prediv_reg); \
    if(set) { \
        BREG_AtomicUpdate32(handle->regHandle, BCHP_##postdiv_reg, BCHP_MASK(postdiv_reg, postdiv_field), BCHP_FIELD_DATA(postdiv_reg, postdiv_field, *postdiv)); \
    } else { \
        reg = BREG_Read32(handle->regHandle, BCHP_##mult_reg); \
        *mult = BCHP_GET_FIELD_DATA(reg, mult_reg, mult_field); \
        *prediv = BCHP_GET_FIELD_DATA(reg, prediv_reg, prediv_field); \
        reg = BREG_Read32(handle->regHandle, BCHP_##postdiv_reg); \
        *postdiv = BCHP_GET_FIELD_DATA(reg, postdiv_reg, postdiv_field); \
    }

static void BCHP_PWR_P_HW_AVD0_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_CORE_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_AVD0_CORE_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_CPU_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_AVD0_CPU_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_SCB_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_SCB_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_AVD0_SCB_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_108_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_108_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_AVD0_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_PWR_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_AVD0_PWR: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY_AVD0_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO: %s", activate?"on":"off"));

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_AIO_AIO_SCB_CLOCK_ENABLE_AIO_MASK |
             BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_AIO_AIO_108_CLOCK_ENABLE_AIO_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_AIO, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_108_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_108_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_DSP_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_DSP_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_DSP_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_AIO_AIO_POWER_SWITCH_MEMORY_AIO_MASK;
    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_AIO, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_AIO, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_AIO, mask, mask);
    }
}

static void BCHP_PWR_P_HW_RAAGA0_SCB_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_SCB_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_SCB_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY_RAAGA_POWER_SWITCH_MEMORY_MASK;
    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_BVN_TOP_CLOCK_ENABLE_BVN_SCB_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_108M: %s", activate?"on":"off"));

     mask = (BCHP_CLKGEN_BVN_TOP_CLOCK_ENABLE_BVN_216_CLOCK_ENABLE_MASK |
             BCHP_CLKGEN_BVN_TOP_CLOCK_ENABLE_BVN_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY_BVN_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE, mask, activate?0:mask);

    mask = BCHP_CLKGEN_ANA_QDAC40G_M7FC_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_ANA_QDAC40G_M7FC_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VEC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_VEC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_AIO_ALTERNATE2_216_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE, mask, activate?mask:0);

    mask = ( BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_VEC_SCB_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_QDAC_216_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_VEC_216_CLOCK_ENABLE_VEC_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_VEC_108_CLOCK_ENABLE_VEC_MASK
            );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_VEC_VEC_POWER_SWITCH_MEMORY_VEC_MASK;
    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_VEC, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_VEC, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_VEC, mask, mask);
    }
}

static void BCHP_PWR_P_HW_VDC_656_OUT_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_656_OUT: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE_DISABLE_VEC_ITU656_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_HDMI_TX_PHY_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask, reg;

    BDBG_MSG(("HW_HDMI_TX_PHY: %s", activate?"on":"off"));

    reg = BREG_Read32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL);
    mask = ( BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, RNDGEN_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PLL_PWRDN)  |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, BIAS_PWRDN) |
             BCHP_MASK(HDMI_TX_PHY_POWERDOWN_CTL, PHY_PWRDN));
    if (activate) {
        reg &= ~mask;
    }
    else {
        reg |= mask;
    }
    BREG_Write32(handle->regHandle, BCHP_HDMI_TX_PHY_POWERDOWN_CTL, reg) ;
}

static void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_216_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
   uint32_t mask;
    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_XPT_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY_XPT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL_CLOCK_216_CG_XPT_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL, mask, activate?mask:0);

    mask = BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_SYS0_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_VEC_IF_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_MAX_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY_DVPHT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_M2MC0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_M2MC0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_M2MC_M2MC_CORE_CLOCK_ENABLE_M2MC_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_M2MC, mask, activate ? mask: 0);

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_M2MC_M2MC_SCB_CLOCK_ENABLE_M2MC_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_M2MC, mask, activate ? mask : 0);
}

static void BCHP_PWR_P_HW_GFX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_GFX_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_GFX_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE, mask, activate ? mask : 0);

}

static void BCHP_PWR_P_HW_M2MC0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC0_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_M2MC_GFX_POWER_SWITCH_MEMORY_M2MC_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_M2MC, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_M2MC, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_M2MC, mask, mask);
    }
}

static void BCHP_PWR_P_HW_V3D_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_V3D: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_V3D_V3D_CORE_CLOCK_ENABLE_V3D_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_V3D, mask, activate ? mask : 0);

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_V3D_V3D_SCB_CLOCK_ENABLE_V3D_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_V3D, mask, activate ? mask : 0);
}

static void BCHP_PWR_P_HW_V3D_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_V3D_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_V3D_GFX_POWER_SWITCH_MEMORY_V3D_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_V3D, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_V3D, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_V3D, mask, mask);
    }
}

static void BCHP_PWR_P_HW_DMA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_DMA: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SECTOP_CLOCK_ENABLE_M2MDMA_M2M_DMA_SCB_CLOCK_ENABLE_M2MDMA_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SECTOP_CLOCK_ENABLE_M2MDMA, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_SID_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SID: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SID_SID_324_CLOCK_ENABLE_SID_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SID, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RFM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RFM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RFM_TOP_CLOCK_ENABLE_RFM_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RFM_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RFM_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RFM_TOP_POWER_SWITCH_MEMORY_RFM_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_POWER_SWITCH_MEMORY, mask, 2);
    BKNI_Delay(10);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_POWER_SWITCH_MEMORY, mask, 0);
    BKNI_Delay(10);
    } else {
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RFM_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_AVD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH0: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }

}

static void BCHP_PWR_P_HW_PLL_AVD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH1: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_AVD_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH2: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2, mask, 0);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2, mask, mask);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_AVD_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH3: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3, mask, 0);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3_POST_DIVIDER_HOLD_CH3_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3, mask, mask);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_AVD_CH4_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH4: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4_CLOCK_DIS_CH4_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4, mask, 0);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4_POST_DIVIDER_HOLD_CH4_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4_POST_DIVIDER_HOLD_CH4_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4, mask, mask);
        mask = BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4_CLOCK_DIS_CH4_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4, mask, mask);
    }
}

static void BCHP_PWR_P_DV_PLL_AVD_CH0_Control(BCHP_Handle handle, unsigned *mult, unsigned *prediv, unsigned *postdiv, bool set)
{
    uint32_t reg;

    BDBG_MSG(("DV_PLL_AVD_CH0: %s", set?"write":"read"));

    BCHP_PWR_P_DIV_CONTROL(CLKGEN_PLL_AVD_PLL_DIV, NDIV_INT, CLKGEN_PLL_AVD_PLL_DIV, PDIV, CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_0, MDIV_CH0)
}

static void BCHP_PWR_P_DV_PLL_AVD_CH1_Control(BCHP_Handle handle, unsigned *mult, unsigned *prediv, unsigned *postdiv, bool set)
{
    uint32_t reg;

    BDBG_MSG(("DV_PLL_AVD_CH1: %s", set?"write":"read"));

    BCHP_PWR_P_DIV_CONTROL(CLKGEN_PLL_AVD_PLL_DIV, NDIV_INT, CLKGEN_PLL_AVD_PLL_DIV, PDIV, CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_1, MDIV_CH1)
}

static void BCHP_PWR_P_DV_PLL_AVD_CH2_Control(BCHP_Handle handle, unsigned *mult, unsigned *prediv, unsigned *postdiv, bool set)
{
    uint32_t reg;

    BDBG_MSG(("DV_PLL_AVD_CH2: %s", set?"write":"read"));

    BCHP_PWR_P_DIV_CONTROL(CLKGEN_PLL_AVD_PLL_DIV, NDIV_INT, CLKGEN_PLL_AVD_PLL_DIV, PDIV, CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_2, MDIV_CH2)
}

static void BCHP_PWR_P_DV_PLL_AVD_CH3_Control(BCHP_Handle handle, unsigned *mult, unsigned *prediv, unsigned *postdiv, bool set)
{
    uint32_t reg;

    BDBG_MSG(("DV_PLL_AVD_CH3: %s", set?"write":"read"));

    BCHP_PWR_P_DIV_CONTROL(CLKGEN_PLL_AVD_PLL_DIV, NDIV_INT, CLKGEN_PLL_AVD_PLL_DIV, PDIV, CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_3, MDIV_CH3)
}

static void BCHP_PWR_P_DV_PLL_AVD_CH4_Control(BCHP_Handle handle, unsigned *mult, unsigned *prediv, unsigned *postdiv, bool set)
{
    uint32_t reg;

    BDBG_MSG(("DV_PLL_AVD_CH4: %s", set?"write":"read"));

    BCHP_PWR_P_DIV_CONTROL(CLKGEN_PLL_AVD_PLL_DIV, NDIV_INT, CLKGEN_PLL_AVD_PLL_DIV, PDIV, CLKGEN_PLL_AVD_PLL_CHANNEL_CTRL_CH_4, MDIV_CH4)
}

static void BCHP_PWR_P_HW_PLL_AVD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD: %s", activate?"on":"off"));

    if (activate) {
    uint32_t reg, cnt=50;
    /* power up PLL_AVD */
    mask = BCHP_CLKGEN_PLL_AVD_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_PWRDN , mask, 0);

    mask = (BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_RESET, mask, 0);

    /* Check for PLL lock */
    while(cnt--) {
        BKNI_Delay(10);
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_LOCK_STATUS);
        if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AVD_PLL_LOCK_STATUS, LOCK))
        break;
    }

    /* Release clock isolation */
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_AVD_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, mask);
    } else {
    mask = BCHP_CLKGEN_PM_PLL_LDO_POWERUP_ISO_CLOCK_PLL_AVD_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_LDO_POWERUP, mask, 0);

    /* power down PLL_AVD */
    mask = (BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AVD_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_RESET, mask, mask);

    mask = BCHP_CLKGEN_PLL_AVD_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_PLL_PWRDN , mask, mask);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL0: %s", activate?"on":"off"));

    if(activate) {
    uint32_t reg, cnt=50;
    mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, 0);

    mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, 0);

    /* Check for PLL lock */
    while(cnt--) {
        BKNI_Delay(10);
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS);
        if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS, LOCK))
            break;
    }
    if(!cnt)
        BDBG_ERR(("Audio0 PLL Lock Timeout"));
    } else {
    mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, mask);

    mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL1: %s", activate?"on":"off"));

    if(activate) {
    uint32_t reg, cnt=50;
    mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, 0);

    mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, 0);

    /* Check for PLL lock */
    while(cnt--) {
        BKNI_Delay(10);
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS);
        if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS, LOCK))
            break;
    }
    if(!cnt)
        BDBG_ERR(("Audio1 PLL Lock Timeout"));
    } else {
    mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, mask);

    mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD_CH0: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0, mask, 0 );
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0, mask, mask);
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD_CH1: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1, mask, 0);
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1, mask, mask);
        mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD: %s", activate?"on":"off"));

    if(activate) {
    uint32_t reg, cnt=50;
    mask = BCHP_CLKGEN_PLL_SC_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_PWRDN, mask, 0);

    mask = (BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_RESET, mask, 0);

    /* Check for PLL lock */
    while(cnt--) {
        BKNI_Delay(10);
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_LOCK_STATUS);
        if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC_PLL_LOCK_STATUS, LOCK))
            break;
    }

    if(!cnt)
        BDBG_ERR(("SmartCard PLL Lock Timeout"));
    } else {
    mask = (BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_RESET, mask, mask);

    mask = BCHP_CLKGEN_PLL_SC_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_CH0: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0, mask, 0);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0_POST_DIVIDER_HOLD_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0, mask, mask);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_CH1: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1, mask, 0);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1_POST_DIVIDER_HOLD_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1, mask, mask);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_CH2: %s", activate?"on":"off"));

    if(activate) {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2, mask, 0);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2, mask, 0);
    } else {
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2_POST_DIVIDER_HOLD_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2, mask, mask);
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_2, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_VCXO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO: %s", activate?"on":"off"));

    if(activate) {
    uint32_t reg, cnt=50;
    mask = BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN, mask, 0);

    mask = (BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_RESET, mask, 0);

    /* Check for PLL lock */
    while(cnt--) {
        BKNI_Delay(10);
        reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_LOCK_STATUS);
        if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO_PLL_LOCK_STATUS, LOCK))
            break;
    }
    if(!cnt)
        BDBG_ERR(("VCXO PLL Lock Timeout"));
    } else {
    mask = (BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETD_MASK |
        BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETA_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_RESET, mask, mask);

    mask = BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN_PWRDN_PLL_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN, mask, mask);
    }
}
