/***************************************************************************
 *     Copyright (c) 2006-2014, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: $
 * $brcm_Revision: $
 * $brcm_Date: $
 *
 * Module Description:
 *
 * Revision History:
 *
 * $brcm_Log: $
 *
 ***************************************************************************/

/***************************************************************
*
* This file maps the power resource control to register writes.
* The templates are auto-generated by generate_chp_pwr.pl,
* but must be filled-in manually.
*
***************************************************************/

#include "bchp.h"
#include "bchp_priv.h"
#include "bdbg.h"
#include "bkni.h"

#include "bchp_clkgen.h"

BDBG_MODULE(BCHP_PWR_IMPL);

static void BCHP_PWR_P_HW_AVD0_CORE_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_CORE_CLK: %s", activate?"on":"off"));

    /* AVD0 Core clock */
    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_AVD_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_CPU_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_CPU_CLK: %s", activate?"on":"off"));

    /* AVD0 CPU clock */
    mask = BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_CPU_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AVD0_SCB_108_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_SCB_108_CLK: %s", activate?"on":"off"));

    if (activate) {
        /* AVD Core, CPU, SCB, 108M clock */
        mask = (BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_SCB_CLOCK_ENABLE_MASK |
                BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_ALTERNATE_SCB_CLOCK_ENABLE_MASK |
                BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_108_CLOCK_ENABLE_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, mask);
    }
    else {
        /* AVD Core, CPU, SCB, 108M clock */
        mask = (BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_SCB_CLOCK_ENABLE_MASK |
                BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_ALTERNATE_SCB_CLOCK_ENABLE_MASK |
                BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE_SVD_108_CLOCK_ENABLE_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_CLOCK_ENABLE, mask, 0);
    }
}

static void BCHP_PWR_P_HW_AVD0_PWR_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AVD0_PWR: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY_SVD_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_AVD0_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_VEC_AIO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_AIO: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_ALTERNATE_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_ALTERNATE_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_ALTERNATE_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_ALTERNATE2_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE_VEC_108_CLOCK_ENABLE_MASK);

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_AIO_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AIO_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_B_AIO_POWER_SWITCH_MEMORY_B_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_B, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_B, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_B, mask, mask);
    }
}

static void BCHP_PWR_P_HW_RAAGA0_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_CLK: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_108_CLOCK_ENABLE_MASK);

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_DSP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_DSP: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE_RAAGA_DSP_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_RAAGA0_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_RAAGA0_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY_RAAGA_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_RAAGA_DSP_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_BVN_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_BVN_TOP_ENABLE_BVN_SCB_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_BVN_TOP_ENABLE_BVN_216_CLK_ENABLE_MASK |
            BCHP_CLKGEN_BVN_TOP_ENABLE_BVN_108_CLK_ENABLE_MASK);

    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_BVN_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_BVN_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY_BVN_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_BVN_TOP_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_VDC_DAC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VDC_DAC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE_DISABLE_VEC_DACADC_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_VEC_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_VEC_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_A_VEC_POWER_SWITCH_MEMORY_A_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_A, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_A, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_VEC_AIO_TOP_POWER_SWITCH_MEMORY_A, mask, mask);
    }
}

static void BCHP_PWR_P_HW_XPT_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_108M: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_XMEMIF_Control(BCHP_Handle handle, bool activate)
{
   uint32_t mask;
    BDBG_MSG(("HW_XPT_XMEMIF: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE_XPT_SCB_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_XPT_RMX_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;
    BDBG_MSG(("HW_XPT_RMX: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_20P25_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_27_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_40P5_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_54_CLOCK_MASK |
            BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE_DISABLE_XPT_81_CLOCK_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_XPT_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY_XPT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_CORE_XPT_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_XPT_WAKEUP_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_XPT_WAKEUP: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL_CLOCK_216_CG_XPT_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_CLOCK_216_ALIVE_SEL, mask, activate?mask:0);

    mask = BCHP_CLKGEN_PM_PLL_ALIVE_SEL_PLL_SYS0_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PM_PLL_ALIVE_SEL, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_CLK_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_CLK: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_DVP_HT_ENABLE_DVPHT_CLK_MAX_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_ENABLE, mask, activate?mask:0);

    mask = BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_ALTERNATE_108_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY_DVPHT_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_HDMI_TX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_HDMI_TX_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_ALTERNATE_216_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE_DVPHT_108_CLOCK_ENABLE_MASK );
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_DVP_HT_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_HDMI_TX_CEC_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_HDMI_TX_CEC: %s", activate?"on":"off"));

    BSTD_UNUSED(handle);

#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_HDMI_TX_CEC_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

static void BCHP_PWR_P_HW_M2MC_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

     BDBG_MSG(("HW_M2MC: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_GFX_M2MC_CLOCK_ENABLE_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE, mask, activate ? mask : 0);

    mask = BCHP_CLKGEN_GRAPHICS_CLOCK_DISABLE_DISABLE_GFX_M2MC_CORE_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_DISABLE, mask, activate ? 0: mask);
}

static void BCHP_PWR_P_HW_GFX_SRAM_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_GFX_SRAM: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY_GFX_POWER_SWITCH_MEMORY_MASK;

    if(activate) {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY, mask, 2);
        BKNI_Delay(10);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY, mask, 0);
        BKNI_Delay(10);
    } else {
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_POWER_SWITCH_MEMORY, mask, mask);
    }
}

static void BCHP_PWR_P_HW_GFX_108M_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_GFX_108M: %s", activate?"on":"off"));

    BDBG_MSG(("HW_GFX_108M: %s", activate?"on":"off"));

    mask = (BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_GFX_108_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_GFX_SCB_CLOCK_ENABLE_MASK |
            BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE_GFX_ALTERNATE_108_CLOCK_ENABLE_MASK);
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_GRAPHICS_CLOCK_ENABLE, mask, activate ? mask : 0);
}

static void BCHP_PWR_P_HW_DMA_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_DMA: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SECTOP_INST_CLOCK_ENABLE_SEC_ALTERNATE_SCB_CLOCK_ENABLE_MASK;

    BREG_AtomicUpdate32(handle->regHandle,  BCHP_CLKGEN_SECTOP_INST_CLOCK_ENABLE, mask, activate?mask:0);
}

static void BCHP_PWR_P_HW_SCD0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE_DISABLE_SC0_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_SCD1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE_DISABLE_SC1_CLOCK_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_SYS_CTRL_CLOCK_DISABLE, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_MDM_Control(BCHP_Handle handle, bool activate)
{
    BDBG_MSG(("HW_MDM: %s", activate?"on":"off"));
        BSTD_UNUSED(handle);
#if 0 /* Edit the register read/modify/write below */
    BREG_AtomicUpdate32(handle->regHandle, BCHP_REGISTERNAME,
        BCHP_REGISTERNAME_MDM_MASK,
        activate ? 0 : 0xFFFFFFFFFF);
#endif
}

static void BCHP_PWR_P_HW_PLL_AVD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_AVD_CH2_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH2: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_2_CLOCK_DIS_CH2_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_2, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_AVD_CH3_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD_CH3: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_3_CLOCK_DIS_CH3_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_CHANNEL_CTRL_CH_3, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_AVD_Control(BCHP_Handle handle, bool activate)
{
    /* Due to other dependencies S/w does not control AVD PLL */
#if 0
    uint32_t mask;

    BDBG_MSG(("HW_PLL_AVD: %s", activate?"on":"off"));

    if (activate) {
        uint32_t reg, cnt=50;
        mask = BCHP_CLKGEN_PLL_AVD_MIPS_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_PWRDN , mask, 0);

        mask = (BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET, mask, 0);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AVD_MIPS_PLL_LOCK_STATUS, LOCK))
                break;
        }
    } else {
        mask = (BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_RESET, mask, mask);

        mask = BCHP_CLKGEN_PLL_AVD_MIPS_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AVD_MIPS_PLL_PWRDN , mask, mask);
    }
#else
    BSTD_UNUSED(handle);
    BSTD_UNUSED(activate);
#endif
}

static void BCHP_PWR_P_HW_AUD_PLL0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL0: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, 0);

        mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, 0);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO0_PLL_LOCK_STATUS, LOCK))
                break;
        }
        if(!cnt)
            BDBG_ERR(("Audio0 PLL Lock Timeout"));
    } else {
        mask = (BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_RESET, mask, mask);

        mask = BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO0_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_AUD_PLL1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_AUD_PLL1: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, 0);

        mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, 0);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_AUDIO1_PLL_LOCK_STATUS, LOCK))
                break;
        }
        if(!cnt)
            BDBG_ERR(("Audio1 PLL Lock Timeout"));
    } else {
        mask = (BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_RESET, mask, mask);

        mask = BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_AUDIO1_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_SCD_PLL: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        mask = BCHP_CLKGEN_PLL_SC_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_PWRDN, mask, 0);

        mask = (BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_RESET, mask, 0);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_SC_PLL_LOCK_STATUS, LOCK))
                break;
        }

        if(!cnt)
            BDBG_ERR(("SmartCard PLL Lock Timeout"));
    } else {
        mask = (BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_SC_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_RESET, mask, mask);

        mask = BCHP_CLKGEN_PLL_SC_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_PWRDN, mask, mask);
    }
}

static void BCHP_PWR_P_HW_PLL_SCD_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD_CH0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_SCD_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_SCD_CH1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_SC_PLL_CHANNEL_CTRL_CH_1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_VCXO_CH0_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_CH0: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0_CLOCK_DIS_CH0_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_0, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_VCXO_CH1_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO_CH1: %s", activate?"on":"off"));

    mask = BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1_CLOCK_DIS_CH1_MASK;
    BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_CHANNEL_CTRL_CH_1, mask, activate?0:mask);
}

static void BCHP_PWR_P_HW_PLL_VCXO_Control(BCHP_Handle handle, bool activate)
{
    uint32_t mask;

    BDBG_MSG(("HW_PLL_VCXO: %s", activate?"on":"off"));

    if(activate) {
        uint32_t reg, cnt=50;
        mask = BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN, mask, 0);

        mask = (BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_RESET, mask, 0);

        /* Check for PLL lock */
        while(cnt--) {
            BKNI_Delay(10);
            reg = BREG_Read32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_LOCK_STATUS);
            if (BCHP_GET_FIELD_DATA(reg, CLKGEN_PLL_VCXO_PLL_LOCK_STATUS, LOCK))
                break;
        }
        if(!cnt)
            BDBG_ERR(("VCXO  PLL Lock Timeout"));
    } else {
        mask = (BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETD_MASK |
                BCHP_CLKGEN_PLL_VCXO_PLL_RESET_RESETA_MASK);
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_RESET, mask, mask);

        mask = BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN_PWRDN_PLL_MASK;
        BREG_AtomicUpdate32(handle->regHandle, BCHP_CLKGEN_PLL_VCXO_PLL_PWRDN, mask, mask);
    }
}
