/******************************************************************************
 * Copyright (C) 2017 Broadcom.  The term "Broadcom" refers to Broadcom Limited and/or its subsidiaries.
 *
 * This program is the proprietary software of Broadcom and/or its licensors,
 * and may only be used, duplicated, modified or distributed pursuant to the terms and
 * conditions of a separate, written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 * no license (express or implied), right to use, or waiver of any kind with respect to the
 * Software, and Broadcom expressly reserves all rights in and to the Software and all
 * intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 * secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of Broadcom integrated circuit products.
 *
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 * AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 * THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES
 * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,
 * LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION
 * OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF
 * USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 * LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR
 * EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
 * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
 * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
 * LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF
 * ANY LIMITED REMEDY.
 *****************************************************************************/
#include "bdsp_common_cit_priv.h"

BDBG_MODULE(bdsp_common_cit);

const char BuffTypeEnum2Char[BDSP_AF_P_BufferType_eLAST][MAX_CHAR_LENGTH] =
{
    {"DRAM Circular Buffer"},
    {"RDB"},
    {"FMM Buffer"},
    {"RAVE Buffer"},
    {"Inter-Stage Buffer"},
    {"FMM Slave buffer"},
    {"Pooled buffer"}
};

const char PortDatatType[BDSP_AF_P_DistinctOpType_eMax][MAX_CHAR_LENGTH] =
{
    {"Mix PCM 7.1 Channel"},
    {"Mix PCM 5.1 Channel"},
    {"Mix Stereo PCM"},
    {"PCM 7.1 Channel"},
    {"PCM 5.1 Channel"},
    {"Stereo PCM"},
    {"Mono PCM"},
    {"Compressed Data"},
    {"Auxilary Data Out"},
    {"Generic Interstage Data"},
    {"Compressed Data Buffer"},
    {"ITB Generated by DSP"},
    {"Dolby Re-encode Data"},
    {"Compressed 4x Data"},
    {"Compressed HBR Data"},
    {"Ancillary Data"},
    {"Descriptor Queue"}
};

const char PortValidType[BDSP_AF_P_ValidInvalid_eMax][MAX_CHAR_LENGTH] =
{
    {"INVALID"},
    {"VALID"}
};

const char DisableEnable[2][MAX_CHAR_LENGTH] =
{
    {" Disabled "},
    {" Enabled "}
};

const char GlobalTimeBase [2][MAX_CHAR_LENGTH] =
{
    {" 45 Khz "},
    {" 27 Mhz "}
};

const char ContextType[BDSP_ContextType_eMax+1][MAX_CHAR_LENGTH]=
{
    {"Audio"},
    {"Video Decode"},
    {"Video Encode"},
    {"Graphics"},
    {"SCM"},
    {"Invalid"}
};

const char SchedulingMode[BDSP_TaskSchedulingMode_eMax+1][MAX_CHAR_LENGTH]=
{
    {"Standalone"},
    {"Master"},
    {"Slave"},
    {"Invalid"}
};

const char SchedulingType[BDSP_TaskRealtimeMode_eMax+1][MAX_CHAR_LENGTH]=
{
    {"Real Time"},
    {"Non-Real Time"},
    {"Soft Real Time"},
    {"On Demand"},
    {"Invalid"}
};

const char DelayMode[BDSP_AudioTaskDelayMode_eMax+1][MAX_CHAR_LENGTH]=
{
    {"Default"},
    {"WD_Low"},
    {"WD_Lowest"},
    {"Invalid"}
};

void BDSP_P_PopulateStcTrigConfig(
                BDSP_AF_P_sStcTrigConfig    *psStcTrigConfig,
                BDSP_TaskStartSettings *pStartSettings
            )
{

    psStcTrigConfig->eStcTrigRequired = pStartSettings->stcIncrementConfig.enableStcTrigger;
    psStcTrigConfig->ui32StcIncHiAddr = pStartSettings->stcIncrementConfig.stcIncHiAddr;
    psStcTrigConfig->ui32StcIncLowAddr = pStartSettings->stcIncrementConfig.stcIncLowAddr;
    psStcTrigConfig->ui32StcIncTrigAddr = pStartSettings->stcIncrementConfig.stcIncTrigAddr;
    psStcTrigConfig->ui32TriggerBit = pStartSettings->stcIncrementConfig.triggerBit;

}

/******************************************************************************
Summary:
    RESET Port Configuration of a task

Description:

    RESET Port Configuration
            1) NCO
            2) PLL      (Only PLL0 and PLL1     Limitations are as per 7405RDB
            3) I2S      (Only I2S0 and I2S1)
            4) HiFiDAC  (Only DAC0)
            5) SPDIF    (Only SPDIF0).

             SPDIF1 is used only for MAI

Input:

    sFmmDestCfgArray:   FMM configuration for all th PLLs

Output:
    sFmmDestCfgArray:   FMM configuration for all th PLLs

Returns:
        None

******************************************************************************/
void BDSP_P_InitializeFmmDstCfg(
                        BDSP_AF_P_sFMM_DEST_CFG     *psFmmDestCfgArray
                )
{
    uint32_t                                    ui32Count;
    uint32_t                                    ui32PllCount;
    BDSP_AF_P_sFMM_DEST_CFG                     *psFmmDestCfg;
    BDSP_AF_P_sFMM_DEST_NCO_CFG                 *psFmmNcoCfg;
    BDSP_AF_P_sFMM_DEST_PLL_CFG                 *psFmmDestPllCfg;
    BDSP_AF_P_sFMM_DEST_I2S_CLK_CFG             *psFmmDestI2SClkCfg;
    BDSP_AF_P_sFMM_DEST_DAC_CFG                 *psFmmDestDacCfg;
    BDSP_AF_P_sFMM_ESR_REGISTER                 *psFmmEsrReg;
    BDSP_AF_P_sFMM_DEST_SPDIF_CLK_CBIT_CFG      *psFmmDestSpdifClkCbitCfg;
    BDSP_AF_P_sFMM_DEST_CAP_PORT_CLK_CFG        *psCapPortClkCfg;
#if defined BDSP_DUMMY_PORT_SUPPORT
    BDSP_AF_P_sFMM_DEST_DUMMY_PORT_CLK_CFG      *psFmmDummyPortClkCfg;
#endif


    BDBG_ENTER(BDSP_P_InitializeFmmDstCfg);


    for(ui32PllCount =0;ui32PllCount<BDSP_AF_P_MAX_NUM_PLLS;ui32PllCount++)
    {

        psFmmDestCfg = &psFmmDestCfgArray[ui32PllCount];

        psFmmNcoCfg         = &psFmmDestCfg->sFmmDestNcoCfg;
        psFmmDestPllCfg     = &psFmmDestCfg->sFmmDestPllCfg;


        /*-----------------*/
        /*NCO Configuration*/
        /*-----------------*/
        psFmmDestCfg->eFmmPllNcoSelect          = BDSP_AF_P_NoneSelect; /*Global select to None*/

        psFmmNcoCfg->ui32NcoPhaseIncRegAddr     = (uint32_t)((unsigned long)NULL);
        psFmmNcoCfg->ui32NcoRateRatioRegAddr    =  (uint32_t)((unsigned long)NULL);
        psFmmNcoCfg->ui32NcoSampleIncRegAddr    =  (uint32_t)((unsigned long)NULL);

        /*-----------------*/
        /*PLL Configuration*/
        /*-----------------*/

        psFmmDestPllCfg->ui32PllEnabled             = (uint32_t)BDSP_AF_P_PortDisable;
        psFmmDestPllCfg->ui32PllIndex               = (uint32_t)BDSP_CIT_P_INVALID;
        psFmmDestPllCfg->ui32AudioPllMacroRegAddr   = (uint32_t)((unsigned long)NULL);


        /*------------------*/
        /* HBR Configuration*/
        /*------------------*/
        /*psFmmDestCfg->ui32HbrEnable = (uint32_t)BDSP_AF_P_PortDisable;*/
        psFmmDestCfg->eHdmiFsRate   = BDSP_AF_P_FmmDstFsRate_eBaseRate;

        /*---------------------*/
        /* HwCbit Configuration*/
        /*---------------------*/

        psFmmDestCfg->ui32HwCbitsEnable = (uint32_t)BDSP_AF_P_PortDisable;

        /*------------------*/
        /*I2S Configuration */
        /*------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_I2S_PORTS;ui32Count++)
        {
            psFmmDestI2SClkCfg = &psFmmDestCfg->sFmmDestI2SClkCfg[ui32Count];

            psFmmDestI2SClkCfg->ui32I2SEnabled              = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestI2SClkCfg->eFmmDstFsRate               = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psFmmDestI2SClkCfg->ui32AudioI2SClkMacroRegAddr = (uint32_t)((unsigned long)NULL);

        }


        /*-------------------*/
        /* SPDIF Configuration */
        /*-------------------*/
        psFmmEsrReg = &psFmmDestCfg->sFmmDestSpdifCfg.sFmmEsrRegister;

        psFmmEsrReg->ui32AudFmmMsEsrStatusRegAddr           = (uint32_t)((unsigned long)NULL);
        psFmmEsrReg->ui32AudFmmMsEsrStatusClearRegAddr      = (uint32_t)((unsigned long)NULL);


        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_SPDIF_PORTS;ui32Count++)
        {
            psFmmDestSpdifClkCbitCfg
                        = &psFmmDestCfg->sFmmDestSpdifCfg.sFmmDestSpdifClkCbitCfg[ui32Count];


            psFmmDestSpdifClkCbitCfg->ui32SpdifEnabled       = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestSpdifClkCbitCfg->eFmmDstFsRate          = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psFmmDestSpdifClkCbitCfg->ui32AudioSpdifClkMacroRegAddr
                                                             = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32SpdifCbitCtrlReg   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32CbitBasePingAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32CbitBasePongAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32PingPongMask       = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32SpdifDramConfigPtr = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32PcmOnSpdif         = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32AudFmmMsCtrlHwSpdifCfg
                                                             = (uint32_t)((unsigned long)NULL);

        }

        /*-------------------*/
        /* DAC Configuration */
        /*-------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_DAC_PORTS;ui32Count++)
        {
            psFmmDestDacCfg = &psFmmDestCfg->sFmmDestDacCfg[ui32Count];

            psFmmDestDacCfg->ui32DacEnabled                 = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestDacCfg->eFmmDstFsRate                  = BDSP_AF_P_FmmDstFsRate_eInvalid;
            psFmmDestDacCfg->ui32HifidacRmPhaseIncRegAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRmRateRatioRegAddr  = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRmSampleIncRegAddr  = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRateManagerCfgAddr  = (uint32_t)((unsigned long)NULL);
        }

        /*------------------------*/
        /* CAPTURE Configuration  */
        /*------------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_CAP_PORTS;ui32Count++)
        {
            psCapPortClkCfg = &psFmmDestCfg->sFmmCapPortClkCfg[ui32Count];

            psCapPortClkCfg->ui32CapPortEnabled             = (uint32_t)BDSP_AF_P_PortDisable;
            psCapPortClkCfg->eFmmDstFsRate                  = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psCapPortClkCfg->ui32AudioCapPortClkMacroRegAddr= (uint32_t)((unsigned long)NULL);
        }

        /*--------------------*/
        /* Dummy Port Config  */
        /*--------------------*/

#if defined BDSP_DUMMY_PORT_SUPPORT
        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_DUMMY_PORTS;ui32Count++)
        {
            psFmmDummyPortClkCfg = &psFmmDestCfg->sFmmDummyPortClkCfg[ui32Count];

            psFmmDummyPortClkCfg->ui32DummyPortEnabled              = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDummyPortClkCfg->eFmmDstFsRate                     = BDSP_AF_P_FmmDstFsRate_eInvalid;
            psFmmDummyPortClkCfg->ui32DummyPortClkMacroRegAddr      = (uint32_t)((unsigned long)NULL);
        }
#endif
    }

    BDBG_LEAVE(BDSP_P_InitializeFmmDstCfg);
}

/******************************************************************************
Summary:
    This function fills the Smaplig frequency conversion table.
    The LUT tells the output sampling frequency of the CHIP for a particular
    input Fs..
            Table is divided into
                    a) QSF (8,11,12)
                    b) Half (16,22,24)
                    c) Full (32,44,48) and
                    d) High (64,88,96)
                    e) Very High (128,176,192)

    This table is modified if the DTS and Ac3 encoder is present.

  Aim of this LUT is to tell the IDS/Framesync/system about the final sampling frequency.
  For MPEG decoders, we need to support the prime band as the final Fs. FW looks into this
  LUT and gets the output sampling frequency LSF and QSF - > prime Frequency

  DTS Encoder exception:
        DTS encoder can do encode only on 44.1 and 48K not 32Khz.
        So the final sampling frequency for 8, 16 and 32Khz and 64Khz should be 48Khz.

  Ac3 Encoder exception:
        Ac3 encoder can do encode only on 48K.
        So the final sampling frequency for 8, 16,32Khz and 64Khzshould be 48Khz.


Description:

Input:
    psAlgoModePresent

Output:


Returns:
        Error

******************************************************************************/
BERR_Code BDSP_P_FillSamplingFrequencyMapLut(
                BDSP_AF_P_DolbyMsUsageMode  eDolbyMsUsageMode,
                BDSP_CIT_P_sAlgoModePresent *psAlgoModePresent,
                BDSP_MMA_Memory				*pFwOpSamplingFreqMapLUTAddr
            )
{
	BERR_Code	ui32Error = BERR_SUCCESS;
    BDSP_AF_P_sOpSamplingFreq   sOpSamplingFrequencyMapLut =    { {   /*QSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*HSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*FSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*HSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*VHSF */
                                                                      32000,
                                                                      44100,
                                                                      48000
                                                                    }
                                                                };

    BDBG_ENTER(BDSP_P_FillSamplingFrequencyMapLut);

    /*Ms11 usage case */
#if 0 /* To be enabled when SRC is integrated into DDP to output data at 48 kHx always */
    if(
        (psAlgoModePresent->ui32DolbyPulsePresent == BDSP_CIT_P_PRESENT) ||
        (BDSP_AF_P_DolbyMsUsageMode_eMS11DecodeMode      == eDolbyMsUsageMode ) ||
        (BDSP_AF_P_DolbyMsUsageMode_eMS11SoundEffectMixing == eDolbyMsUsageMode )
      )
#else
    if ((psAlgoModePresent->ui32DolbyPulsePresent == BDSP_CIT_P_PRESENT) ||
        (   (psAlgoModePresent->ui32DdrePresent == BDSP_CIT_P_PRESENT) &&
            (   (BDSP_AF_P_DolbyMsUsageMode_eMS11DecodeMode == eDolbyMsUsageMode) ||
                (BDSP_AF_P_DolbyMsUsageMode_eMS11SoundEffectMixing == eDolbyMsUsageMode))))
#endif
    {
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[0] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[1] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[2] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[3] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[4] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[5] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[6] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[7] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[8] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[9] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[10] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[11] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[12] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[13] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[14] = 48000;
    }
    else
    {
        /*Special Case for DTS encoder and Ac3 encoder*/
        if( (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32DTS_EncoderPresent) ||
            (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32AC3_EncoderPresent)
          )
        {
            /*Upsampling to 48K output sampling frequency */
            /*  8K-> 48K */
            /* 16K-> 48K */
            /* 32K-> 48K */
            /* 64K-> 48K */
            /* 128K->48K */
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e8Khz] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e16Khz] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e32Khz] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e64Khz] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e128Khz]= 48000;

            /* Special Case for Ac3 encoder ONLY */
            if (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32AC3_EncoderPresent)
            {
                /* 11.025KHz -> 48KHz */
                /* 22.05KHz -> 48KHz */
                /* 44.1KHz -> 48KHz */
                /* 88.2KHz -> 48KHz */
                /* 176.4KHz -> 48KHz */
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e11_025Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e22_05Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e88_2Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e176_4Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e44_1Khz] = 48000;
            }
        }
    }

	ui32Error = BDSP_MMA_P_CopyDataToDram(pFwOpSamplingFreqMapLUTAddr, (void *)&sOpSamplingFrequencyMapLut, SIZEOF(BDSP_AF_P_sOpSamplingFreq));
	if(ui32Error != BERR_SUCCESS)
	{
		BDBG_ERR(("Error in Copying the Sample Rate Map LUT from BDSP to Firmware Address"));
	}

    BDBG_LEAVE(BDSP_P_FillSamplingFrequencyMapLut);
	return ui32Error;
}
