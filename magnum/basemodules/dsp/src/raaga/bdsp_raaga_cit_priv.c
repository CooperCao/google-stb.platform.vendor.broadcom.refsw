/******************************************************************************
 * (c) 2004-2016 Broadcom Corporation
 *
 * This program is the proprietary software of Broadcom Corporation and/or its
 * licensors, and may only be used, duplicated, modified or distributed pursuant
 * to the terms and conditions of a separate, written license agreement executed
 * between you and Broadcom (an "Authorized License").  Except as set forth in
 * an Authorized License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and Broadcom
 * expressly reserves all rights in and to the Software and all intellectual
 * property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 *    constitutes the valuable trade secrets of Broadcom, and you shall use all
 *    reasonable efforts to protect the confidentiality thereof, and to use
 *    this information only in connection with your use of Broadcom integrated
 *    circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 *    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 *    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
 *    TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
 *    WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
 *    PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
 *    ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME
 *    THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 *    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
 *    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
 *    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
 *    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER
 *    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
 *    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 *****************************************************************************/


#include "bdsp_raaga_priv.h"
#include "bdsp_raaga_fw_cit.h"
#include "bdsp_raaga_fw.h"
#include "bdsp_raaga_fw_status.h"
#include "bdsp_task.h"
#include "bdsp_common_cit_priv.h"
#include "bdsp_common_priv.h"

#include "bchp_aud_fmm_bf_ctrl.h"

 /* CIT-Gen  header File Inclusion */

BDBG_MODULE(bdsp_cit);

/*#undef ANALYZE_IO_CFG */
/*--------------------------------------------------*/
/*    Static Memory Allocations for CIT-Gen Module  */
/*--------------------------------------------------*/

/* Arrays for :- Display Messages */
static const char BuffTypeEnum2Char[BDSP_AF_P_BufferType_eLAST][MAX_CHAR_LENGTH] =
{
    {"DRAM Circular Buffer"},
    {"RDB"},
    {"FMM Buffer"},
    {"RAVE Buffer"},
    {"Inter-Stage Buffer"},
    {"FMM Slave buffer"},
    {"Pooled buffer"}
};

static const char PortDatatType[BDSP_AF_P_DistinctOpType_eMax][MAX_CHAR_LENGTH] =
{
    {"Mix PCM 7.1 Channel"},
    {"Mix PCM 5.1 Channel"},
    {"Mix Stereo PCM"},
    {"PCM 7.1 Channel"},
    {"PCM 5.1 Channel"},
    {"Stereo PCM"},
    {"Mono PCM"},
    {"Compressed Data"},
    {"Auxilary Data Out"},
    {"Generic Interstage Data"},
    {"Compressed Data Buffer"},
    {"ITB Generated by DSP"},
    {"Dolby Re-encode Data"},
    {"Compressed 4x Data"},
    {"Compressed HBR Data"},
    {"Ancillary Data"},
    {"Descriptor Queue"}
};

static const char PortValidType[BDSP_AF_P_ValidInvalid_eMax][MAX_CHAR_LENGTH] =
{
    {"INVALID"},
    {"VALID"}
};

static const char AlgoIdEnum2Char[BDSP_AF_P_AlgoId_eMax+1][MAX_CHAR_LENGTH] =
{
    {"MpegDecode"},
    {"Ac3Decode"},
    {"AacDecode"},
    {"AacHeLpSbrDecode"},
    {"DdpDecode"},
    {"DdLosslessDecode"},
    {"LpcmCustomDecode"},
    {"BdLpcmDecode"},
    {"DvdLpcmDecode"},
    {"HdDvdLpcmDecode"},
    {"MpegMcDecode"},
    {"WmaStdDecode"},
    {"WmaProStdDecode"},
    {"MlpDecode"},
    {"Ddp71Decode"},
    {"DtsDecode"},
    {"DtsLbrDecode"},
    {"DtsHdDecode"},
    {"PcmWavDecode"},
    {"Amr Decode"},
    {"Dra Decode"},
    {"Real Audio LBR Decode"},
    {"Dolby Pulse Decode"},
    {"Ms10 DdpDecode"},
    {"Adpcm Decode"},
    {"G.711/G.726 Decode"},
    {"G.729 Decode"},
    {"VORBIS Decode"},
    {"G.723.1 Decode"},
    {"FLAC Decode"},
    {"MAC Decode"},
    {"Amrwb Decode"},
    {"iLBC Decode"},
    {"ISAC Decode"},
    {"UDC Decode"},
    {"Dolby AACHE Decode"},
    {"Opus Decode"},
    {"ALS Decode"},
    {"EndOfAudioDecodeAlgos"},
    {"Real Video Decode"},
    {"VP6 Video Decode"},
    {"EndOfDecodeAlgos"},
    {"MpegFrameSync"},
    {"MpegMcFrameSync"},
    {"AdtsFrameSync"},
    {"LoasFrameSync"},
    {"WmaStdFrameSync"},
    {"WmaProFrameSync"},
    {"Ac3FrameSync"},
    {"DdpFrameSync"},
    {"Ddp71FrameSync"},
    {"DtsFrameSync"},
    {"DtsLbrFrameSync"},
    {"DtsHdFrameSync"},
    {"DtsHdFrameSync_1"},
    {"DtsHdHdDvdFrameSync"},
    {"DdLosslessFrameSync"},
    {"MlpFrameSync"},
    {"MlpHdDvdFrameSync"},
    {"PesFrameSync"},
    {"BdLpcmFrameSync"},
    {"HdDvdLpcmFrameSync"},
    {"DvdLpcmFrameSync"},
    {"DvdLpcmFrameSync_1"},
    {"PcmWavFrameSync"},
    {"Amr FrameSync"},
    {"Dra FrameSync"},
    {"Real Audio LBR FrameSync"},
    {"Ms10 Ddp FrameSync"},
    {"Adpcm FrameSync"},
    {"G.711/G.726 FrameSync"},
    {"G.729 FrameSync"},
    {"VORBIS FrameSync"},
    {"G.723.1 FrameSync"},
    {"FLAC FrameSync"},
    {"MAC FrameSync"},
    {"Amrwb FrameSync"},
    {"iLBC FrameSync"},
    {"ISAC FrameSync"},
    {"UDC FrameSync"},
    {"EndOfAudioDecFsAlgos"},
    {"Real Video FrameSync"},
    {"VP6 Video FrameSync"},
    {"EndOfDecFsAlgos"},
    {"Ac3Encode"},
    {"MpegL2Encode"},
    {"MpegL3Encode"},
    {"AacLcEncode"},
    {"AacHeEncode"},
    {"DtsEncode"},
    {"DtsBroadcastEncode"},
    {"SBC Encode"},
    {"DD Transcode"},
    {"G.711/G.726 Encode"},
    {"G.729 Encode"},
    {"G.723.1 Encode"},
    {"G.722 Encode"},
    {"Amr Encode"},
    {"Amrwb Encode"},
    {"ILBC Encode"},
    {"ISAC Encode"},
    {"Lpcm Encode"},
    {"Opus Encode"},
    {"DDP Encode"},
    {"EndOfAudioEncodeAlgos"},
    {"H.264 Video Encoder"},
    {"X.264 Video Encoder"},
    {"EndOfVideoEncodeAlgos"},
    {"Ac3EncFrameSync"},
    {"MpegL3EncFrameSync"},
    {"MpegL2EncFrameSync"},
    {"AacLcEncFrameSync"},
    {"AacHeEncFrameSync"},
    {"DtsEncFrameSync"},
    {"EndOfEncFsAlgos"},
    {"PassThru"},
    {"MlpPassThru"},
    {"EndOfAuxAlgos"},
    {"SrsTruSurroundPostProc"},
    {"SrcPostProc"},
    {"DdbmPostProc"},
    {"DownmixPostProc"},
    {"CustomSurroundPostProc"},
    {"CustomBassPostProc"},
    {"KaraokeCapablePostProc"},
    {"CustomVoicePostProc"},
    {"PeqPostProc"},
    {"AvlPostProc"},
    {"Pl2PostProc"},
    {"XenPostProc"},
    {"BbePostProc"},
    {"DsolaPostProc"},
    {"DtsNeoPostProc"},
    {"DDConvert"},
    {"AudioDescriptorFadePostProc"},
    {"AudioDescriptorPanPostProc"},
    {"PCMRouterPostProc"},
    {"WMAPassThrough"},
    {"SrsTruSurroundHDPostProc"},
    {"SrsTruVolumePostProc"},
    {"DolbyVolumePostProc"},
    {"Brcm3D SurroundPostProc"},
    {"FwMixer PostProc"},
    {"MonoDownMix PostProc"},
    {"Ms10 DDConvert"},
    {"DdrePostProc"},
    {"Dv258PostProc"},
    {"DpcmrPostProc"},
    {"CdbItbGenPostProc"},
    {"Btsc Encoder"},
    {"Speex Acoustic echo canceller"},
    {"Karaoke"},
    {"MixerDapv2 PostProc"},
    {"Output Formatter"},
    {"Vocal PostProc"},
    {"Fade Control"},
    {"EndOfPpAlgos"},
    {"MixerFrameSync"},
    {"MixerDapv2FrameSync"},
    {"EndOfPpFsAlgos"},
    {"SysLib"},
    {"AlgoLib"},
    {"IDSCommonLib"},
    {"VideoIDSCommonLib"},
    {"EndOfLibAlgos"},
    {"Scm1 Processing"},
    {"Scm2 Processing"},
    {"Scm3Processing"},
    {"EndOfScmAlgos"},
    {"SCMTask"},
    {"EndOfTasks"},
    {"EndOfAlgos"}
};

static const char DisableEnable[2][MAX_CHAR_LENGTH] =
{
    {" Disabled "},
    {" Enabled "}
};

static const char GlobalTimeBase [2][MAX_CHAR_LENGTH] =
{
    {" 45 Khz "},
    {" 27 Mhz "}
};

static uint32_t BDSP_CITGEN_P_FillSamplingFrequencyMapLut(
            BMEM_Handle                         hHeap,
            BDSP_AF_P_DolbyMsUsageMode          eDolbyMsUsageMode,
            uint32_t                            ui32FwOpSamplingFreqMapLutAddr,
            BDSP_CIT_P_sAlgoModePresent         *psAlgoModePresent
        );

static void BDSP_CITGEN_P_ComputeTaskStackBuffSize(
            BDSP_CIT_P_sTaskBuffInfo                *psTaskBuffInfo
        );

static uint32_t BDSP_CITGEN_P_FillNodeCfgIntoNewCit(
            BDSP_RaagaStage *pPrimaryStageHandle,
            uint32_t dspIndex,
            BDSP_AF_P_sNODE_CONFIG          *psCit,
            unsigned *ui32TotalNodes);

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit (
                        BDSP_RaagaTask *pRaagaTask,
                        BDSP_AF_P_sTASK_CONFIG  *psCit,
                        unsigned ui32TotalNodes);
static uint32_t BDSP_CITGEN_P_FillInputforVideoEncode (BDSP_RaagaTask *pRaagaTask);

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoDecodeCit (
                        BDSP_RaagaTask               *pRaagaTask,
                        BDSP_VF_P_sDEC_TASK_CONFIG   *psVideoDecodeCit,
                        BDSP_sVDecoderIPBuffCfg      *psVDecodeBuffCfgIp,
                        unsigned                      ui32TotalNodes);

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoEncodeCit (
                        BDSP_RaagaTask              *pRaagaTask,
                        BDSP_VF_P_sENC_TASK_CONFIG  *psVideoEncodeCit,
                        BDSP_sVEncoderIPConfig *psVEncoderCfgIp,
                        unsigned                     ui32TotalNodes);


static void BDSP_PopulateStcTrigConfig(
                BDSP_AF_P_sStcTrigConfig    *psStcTrigConfig,
                BDSP_TaskStartSettings *pStartSettings
            );

BERR_Code BDSP_P_PopulateFwHwBuffer(
                                void *pPrimaryStageHandle,
                                BDSP_AF_P_sFW_HW_CFG        *sFwHwCfg
                            );
static uint32_t BDSP_PopulateAlgoMode(
                BDSP_RaagaStage *pRaagaPrimaryStage,
                BDSP_CIT_P_sAlgoModePresent *sAlgoModePresent
                );

static uint32_t  BDSP_CITGEN_P_GetNumZeroFillSamples(
    uint32_t    *pui32ZeroFillSamples,
    BDSP_RaagaStage *pRaagaPrimaryStage
    );

/*Modification*/


static void BDSP_CITGEN_P_InitializeFmmDstCfg(
            BDSP_AF_P_sFMM_DEST_CFG                 *psFmmDestCfg
        );

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewScmCit (
                        BDSP_RaagaTask *pRaagaTask,
                        BDSP_SCM_P_sTASK_CONFIG *psCit,
                        unsigned ui32TotalNodes);
static uint32_t BDSP_CITGEN_P_FillNodeCfgIntoNewScmCit(
                    BDSP_RaagaStage *pPrimaryStageHandle,
                    BDSP_SCM_P_sTASK_CONFIG         *psCit,
                    unsigned *ui32TotalNodes);
/*- Optional Debug Function Prototype Declarations in CIT-Genn Module ---*/

#ifdef ANALYSIS_IO_GEN_ENABLE

static void BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(
            BDSP_AF_P_sIO_BUFFER                    *psIoBuffStruct
        );

static void BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(
            BDSP_AF_P_sIO_GENERIC_BUFFER            *psToGenericBuffStruct
        );
#endif

uint32_t BDSP_P_GenNewCit(void* pTaskHandle)
{
    unsigned ui32Err = BERR_SUCCESS ;

    BDSP_RaagaTask *pRaagaTask = (BDSP_RaagaTask *)pTaskHandle;
    BDSP_CIT_P_Output   *psCitOp = &(pRaagaTask->citOutput);

    BDSP_CIT_P_sTaskBuffInfo sTaskBuffInfo;
    unsigned ui32TotalNodes = 0;

    /*the whole of citOutput should be filled here*/

    BDBG_ENTER(BDSP_P_GenNewCit);

    BDSP_CITGEN_P_ComputeTaskStackBuffSize(&sTaskBuffInfo);

    BDBG_ASSERT(NULL != pRaagaTask);
    BDBG_ASSERT(NULL != pRaagaTask->startSettings.primaryStage);

    ui32Err = BDSP_CITGEN_P_FillNodeCfgIntoNewCit(
                    (void *) pRaagaTask->startSettings.primaryStage->pStageHandle,
                    pRaagaTask->settings.dspIndex,
                    &psCitOp->sCit.sNodeConfig[0]/*BDSP_AF_P_sTASK_CONFIG*/ ,
                    &ui32TotalNodes);

    if( ui32Err != BERR_SUCCESS || ui32TotalNodes == 0)
    {
        goto BDSP_CITGENMODULE_P_EXIT_POINT;
    }

    if(ui32TotalNodes > BDSP_AF_P_MAX_NODES)
    {
        BDBG_ERR(("Error : The number of nodes in the system is %d. Maximum Allowed is %d", ui32TotalNodes,BDSP_AF_P_MAX_NODES));
        return(BERR_NOT_SUPPORTED);
    }
    BDBG_MSG(("ui32TotalNodes in Network = %d", ui32TotalNodes));

    /*  Fill the global task configuration into CIT */
    ui32Err = BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit(
                            (void *) pRaagaTask,
                            &psCitOp->sCit,
                            ui32TotalNodes); /*BDSP_AF_P_sTASK_CONFIG*/

    if( ui32Err != BERR_SUCCESS)
    {
        goto BDSP_CITGENMODULE_P_EXIT_POINT;
    }


    /* EXIT Point */
    BDSP_CITGENMODULE_P_EXIT_POINT:

    /* Check for Error and assert */
    if(ui32Err !=BERR_SUCCESS)
    {
        BDBG_ASSERT(0);
    }

    BDBG_LEAVE(BDSP_P_GenNewCit);

    return ui32Err;
}
/*************************************************/
/*   CIT Generation Module's Private defines     */
/**************************************************/
/*
    #define BDSP_CIT_P_PRINT_STAGE_PORT_CONNECTION
    #define BDSP_CIT_P_PRINT_PPM_CFG
*/
/**************************************************/

/*---------------------------------------------------------------------
                Top level CIT Generation Function
---------------------------------------------------------------------*/

uint32_t BDSP_P_GenNewScmCit(   void* pTaskHandle )
{


    unsigned ui32Err = BERR_SUCCESS ;

    BDSP_RaagaTask *pRaagaTask = (BDSP_RaagaTask *)pTaskHandle;
    BDSP_CIT_P_ScmCITOutput     *psScmCitOp = &(pRaagaTask->scmCitOutput);

    BDSP_CIT_P_sTaskBuffInfo sTaskBuffInfo;
    unsigned ui32TotalNodes = 0;

    /*the whole of citOutput should be filled here*/

    BDBG_ENTER(BDSP_P_GenNewScmCit);

    BDSP_CITGEN_P_ComputeTaskStackBuffSize(&sTaskBuffInfo);

    BDBG_ASSERT(NULL != pRaagaTask);
    BDBG_ASSERT(NULL != pRaagaTask->startSettings.primaryStage);

    ui32Err = BDSP_CITGEN_P_FillNodeCfgIntoNewScmCit(
                    (void *) pRaagaTask->startSettings.primaryStage->pStageHandle,
                    &psScmCitOp->sScmCit,
                    &ui32TotalNodes);

    if( ui32Err != BERR_SUCCESS || ui32TotalNodes == 0)
    {
        goto BDSP_CITGENMODULE_P_EXIT_POINT;
    }
    if(ui32TotalNodes > BDSP_AF_P_MAX_NODES)
    {
        BDBG_ERR(("Error : The number of nodes in the system is %d. Maximum Allowed is %d", ui32TotalNodes,BDSP_AF_P_MAX_NODES));
        return(BERR_NOT_SUPPORTED);
    }
    BDBG_MSG(("ui32TotalNodes in Network = %d", ui32TotalNodes));

    /*  Fill the global task configuration into CIT */
    ui32Err = BDSP_CITGEN_P_FillGblTaskCfgIntoNewScmCit(
                            (void *) pRaagaTask,
                            &psScmCitOp->sScmCit,
                            ui32TotalNodes);

    if( ui32Err != BERR_SUCCESS)
    {
        goto BDSP_CITGENMODULE_P_EXIT_POINT;
    }


    /* EXIT Point */
    BDSP_CITGENMODULE_P_EXIT_POINT:

    /* Check for Error and assert */
    if(ui32Err !=BERR_SUCCESS)
    {
        BDBG_ASSERT(0);
    }

    BDBG_LEAVE(BDSP_P_GenNewScmCit);

    return ui32Err;

}

/****************************************************************************/
/****************************************************************************/
/************************* VIDEO TASK  **************************************/
/****************************************************************************/
/****************************************************************************/

/*---------------------------------------------------------------------
                Top level Video CIT Generation Function
---------------------------------------------------------------------*/

static uint32_t BDSP_CITGEN_P_FillInputforVideoEncode (BDSP_RaagaTask *pRaagaTask)
{

    uint32_t    ui32Error, ui32RegOffset;
    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_Raaga *pRaagaDevice;

    BDBG_ENTER(BDSP_CITGEN_P_FillInputforVideoEncode);

    ui32Error = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(pRaagaTask, BDSP_RaagaTask);
    pRaagaPrimaryStage = (BDSP_RaagaStage *)pRaagaTask->startSettings.primaryStage->pStageHandle;
    pRaagaDevice       = (BDSP_Raaga *)pRaagaPrimaryStage->pContext->pDevice;

    pRaagaPrimaryStage->sStageInput[0].eNodeValid              = BDSP_AF_P_eValid;
    pRaagaPrimaryStage->sStageInput[0].eConnectionType         = BDSP_ConnectionType_eRDBBuffer;
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.eBufferType    = BDSP_AF_P_BufferType_eRDB;
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.ui32NumBuffers = 3;

    /* PDQ - FIFO 15  values passed */
    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_1_BASE_ADDR - \
        BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR;

    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR + \
    (ui32RegOffset * pRaagaTask->hRDQueue->i32FifoId);

    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[0].ui32BaseAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32RegOffset + BDSP_RAAGA_P_FIFO_BASE_OFFSET ) ;
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[0].ui32EndAddr  = BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[0].ui32WriteAddr= BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32RegOffset + BDSP_RAAGA_P_FIFO_WRITE_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[0].ui32ReadAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32RegOffset + BDSP_RAAGA_P_FIFO_READ_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[0].ui32WrapAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );

    /* PRQ - FIFO 16 values passed */
    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_1_BASE_ADDR - \
    BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR;

    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR + \
    (ui32RegOffset * pRaagaTask->hRRQueue->i32FifoId);

    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[1].ui32BaseAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_BASE_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[1].ui32EndAddr  = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[1].ui32WriteAddr= BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_WRITE_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[1].ui32ReadAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_READ_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[1].ui32WrapAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );


    /* CCDQ - FIFO 14  values passed */
    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_1_BASE_ADDR - \
        BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR;

    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR + \
    (ui32RegOffset * pRaagaTask->hCCDQueue->i32FifoId);

    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[2].ui32BaseAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_BASE_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[2].ui32EndAddr  = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[2].ui32WriteAddr= BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_WRITE_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[2].ui32ReadAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_READ_OFFSET );
    pRaagaPrimaryStage->sStageInput[0].IoBuffer.sCircBuffer[2].ui32WrapAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );

    pRaagaPrimaryStage->totalInputs++;

    BDSP_MEM_P_ConvertAddressToOffset(pRaagaDevice->memHandle,
        pRaagaPrimaryStage->sStageInput[0].pIoBuffDesc,
        &pRaagaPrimaryStage->sStageInput[0].ui32StageIOBuffCfgAddr);

    BDSP_MEM_P_ConvertAddressToOffset(pRaagaDevice->memHandle,
        pRaagaPrimaryStage->sStageInput[0].pIoGenBuffDesc,
        &pRaagaPrimaryStage->sStageInput[0].ui32StageIOGenericDataBuffCfgAddr);

    BDBG_LEAVE(BDSP_CITGEN_P_FillInputforVideoEncode);

    return ui32Error;

}

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoDecodeCit (
                        BDSP_RaagaTask               *pRaagaTask,
                        BDSP_VF_P_sDEC_TASK_CONFIG   *psVideoDecodeCit,
                        BDSP_sVDecoderIPBuffCfg      *psVDecodeBuffCfgIp,
                        unsigned                      ui32TotalNodes)
{
    uint32_t    ui32Error;
    uint32_t    ui32Count, ui32RegOffset;

    BDSP_VF_P_sGLOBAL_TASK_CONFIG *psGblTaskCfg;
    BDSP_VF_P_sVDecodeBuffCfg     *psGlobalTaskConfigFromPI;

    BDBG_ENTER(BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoDecodeCit);

    ui32Error = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(pRaagaTask, BDSP_RaagaTask);

    psGblTaskCfg             = &psVideoDecodeCit->sGlobalTaskConfig;
    psGlobalTaskConfigFromPI = &psGblTaskCfg->sGlobalTaskConfigFromPI;

    /*Update the number if Nodes in the Task*/
    psGblTaskCfg->ui32NumberOfNodesInTask = ui32TotalNodes;

    /* Calculate the PDQ and PRQ Structure Addresses and
            Update it into The Global Config parameters*/
    /* PDQ - FIFO 15  values passed */
    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_1_BASE_ADDR - \
        BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR;

    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR + \
    (ui32RegOffset * pRaagaTask->hPDQueue->i32FifoId);


    psGlobalTaskConfigFromPI->sPDQ.ui32BaseAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_BASE_OFFSET );
    psGlobalTaskConfigFromPI->sPDQ.ui32EndAddr  = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );
    psGlobalTaskConfigFromPI->sPDQ.ui32WriteAddr= BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_WRITE_OFFSET );
    psGlobalTaskConfigFromPI->sPDQ.ui32ReadAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_READ_OFFSET );
    psGlobalTaskConfigFromPI->sPDQ.ui32WrapAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );

    /* PRQ - FIFO 16 values passed */
    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_1_BASE_ADDR - \
    BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR;

    ui32RegOffset = BCHP_RAAGA_DSP_FW_CFG_FIFO_0_BASE_ADDR + \
    (ui32RegOffset * pRaagaTask->hPRQueue->i32FifoId);

    psGlobalTaskConfigFromPI->sPRQ.ui32BaseAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_BASE_OFFSET );
    psGlobalTaskConfigFromPI->sPRQ.ui32EndAddr  = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );
    psGlobalTaskConfigFromPI->sPRQ.ui32WriteAddr= BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_WRITE_OFFSET );
    psGlobalTaskConfigFromPI->sPRQ.ui32ReadAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_READ_OFFSET );
    psGlobalTaskConfigFromPI->sPRQ.ui32WrapAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP(  ui32RegOffset + BDSP_RAAGA_P_FIFO_END_OFFSET );


    /* Set the Reference Values to 720 */
    /* Currently hard coded but remove if PI provides proper configuration */
#if 0
    psGlobalTaskConfigFromPI->ui32MaxFrameWidth  = psVDecodeBuffCfgIp->MaxFrameWidth;
    psGlobalTaskConfigFromPI->ui32MaxFrameHeight = psVDecodeBuffCfgIp->MaxFrameHeight;
    psGlobalTaskConfigFromPI->ui32StripeWidth    = psVDecodeBuffCfgIp->StripeWidth;
#else
    psGlobalTaskConfigFromPI->ui32MaxFrameWidth  = 720;
    psGlobalTaskConfigFromPI->ui32MaxFrameHeight = 576;
    psGlobalTaskConfigFromPI->ui32StripeWidth    = 128;
#endif  /* 0 */

    /* DISPLAY FRAME BUFFER CONFIGURATION */
    psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.ui32NumBuffAvl =
                                            psVDecodeBuffCfgIp->sDisplayFrameBuffParams.ui32NumBuffAvl;

    /* Currently hard coded but remove if PI provides proper configuration */
#if 0
    psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.ui32ChromaStripeHeight
                            = psVDecodeBuffCfgIp->sDisplayFrameBuffParams.ui32ChromaStripeHeight;
    psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.ui32LumaStripeHeight
                            = psVDecodeBuffCfgIp->sDisplayFrameBuffParams.ui32LumaStripeHeight;
#else

    /*(CEILING((MaxVertSize/2)/16) x 16)*/
    /*(CEILING((576/2)/16) x 16) */
    psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.ui32ChromaStripeHeight= 288;

    /*(CEILING(MaxVertSize/16) x 16) */
    /*(CEILING(576/16) x 16) */
    psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.ui32LumaStripeHeight = 576;
#endif  /* 0 */

    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
    {
        /* Luma */
        psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress =
                        psVDecodeBuffCfgIp->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress;

        psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes =
                        psVDecodeBuffCfgIp->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes;

        /* Chroma */
        psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress =
                psVDecodeBuffCfgIp->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress;

        psGlobalTaskConfigFromPI->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes =
                        psVDecodeBuffCfgIp->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes;

    }

    /* REFERENCE FRAME BUFFER CONFIGURATION */
        /* Currently hard coded but remove if PI provides proper configuration */
#if 0
    psGlobalTaskConfigFromPI->sReferenceBuffParams.ui32ChromaStripeHeight
                            = psVDecodeBuffCfgIp->sReferenceBuffParams.ui32ChromaStripeHeight;
    psGlobalTaskConfigFromPI->sReferenceBuffParams.ui32LumaStripeHeight
                            = psVDecodeBuffCfgIp->sReferenceBuffParams.ui32LumaStripeHeight;
#else
    /*TotalHorzPadd = 96, TotalVertPadd_Luma = 96, and TotalVertPadd_Chroma = 48*/
    /*(CEILING(((MaxVertSize/2) + TotalVertPadd_Chroma)/16) x 16)*/
    psGlobalTaskConfigFromPI->sReferenceBuffParams.ui32ChromaStripeHeight = 336;

    /*(CEILING((MaxVertSize + TotalVertPadd_Luma)/16) x 16)*/
    psGlobalTaskConfigFromPI->sReferenceBuffParams.ui32LumaStripeHeight = 672;
#endif /*0 */

    psGlobalTaskConfigFromPI->sReferenceBuffParams.ui32NumBuffAvl =
                                            psVDecodeBuffCfgIp->sReferenceBuffParams.ui32NumBuffAvl;

    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_REF_BUFF_AVAIL;ui32Count++)
    {
        /* Luma */
        psGlobalTaskConfigFromPI->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress =
                        psVDecodeBuffCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress;

        psGlobalTaskConfigFromPI->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes =
                        psVDecodeBuffCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes;


        /* Chroma */
        psGlobalTaskConfigFromPI->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress =
                        psVDecodeBuffCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress;

        psGlobalTaskConfigFromPI->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes =
                        psVDecodeBuffCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes;
    }

    /* UPB BUFFER CONFIGURATION  */
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
    {
        psGlobalTaskConfigFromPI->sUPBs[ui32Count].ui32DramBufferAddress =
                        psVDecodeBuffCfgIp->sUPBs[ui32Count].ui32DramBufferAddress;

        psGlobalTaskConfigFromPI->sUPBs[ui32Count].ui32BufferSizeInBytes =
                        psVDecodeBuffCfgIp->sUPBs[ui32Count].ui32BufferSizeInBytes;
    }

    BDBG_LEAVE(BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoDecodeCit);
    return ui32Error;
}

static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoEncodeCit (
                        BDSP_RaagaTask              *pRaagaTask,
                        BDSP_VF_P_sENC_TASK_CONFIG  *psVideoEncodeCit,
                        BDSP_sVEncoderIPConfig      *psVEncoderCfgIp,
                        unsigned                     ui32TotalNodes)
{
    uint32_t    ui32Error;
    uint32_t    ui32Count;

    BDSP_VF_P_sENC_GLOBAL_TASK_CONFIG *psVideoEncodeGlobalTaskConfig;
    BDSP_VF_P_sVEncodeConfig          *psGlobalEncodeTaskConfig;

    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_RaagaContext *pRaagaContext;
    BDSP_Raaga *pRaagaDevice;

    void                            *pvRrqAddr=NULL;
    unsigned int                    i=0;
    unsigned int                    StripeWidthIndex;

    unsigned int                    uiDspIndex;
    unsigned int                    uiOffset;
#if (defined BCHP_RAAGA_DSP_DMA_SCB0_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB1_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB2_DRAM_MAP5_ADDR_CFG)
    uint32_t                        ui32DramMap5AddrCfg;
#endif
    uint32_t                        uiMs4Bits;
    uint32_t                        ui32RegVal;

    BDBG_ENTER(BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoEncodeCit);

    ui32Error = BERR_SUCCESS;
    uiDspIndex = 0;
    uiOffset = 0;
#if (defined BCHP_RAAGA_DSP_DMA_SCB0_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB1_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB2_DRAM_MAP5_ADDR_CFG)
    ui32DramMap5AddrCfg = 0;
#endif
    uiMs4Bits = 0;
    ui32RegVal = 0;
    StripeWidthIndex = 0;
    BDBG_OBJECT_ASSERT(pRaagaTask, BDSP_RaagaTask);
    pRaagaPrimaryStage = (BDSP_RaagaStage *)pRaagaTask->startSettings.primaryStage->pStageHandle;
    pRaagaContext      = (BDSP_RaagaContext *)pRaagaPrimaryStage->pContext;
    pRaagaDevice       = (BDSP_Raaga *)pRaagaContext->pDevice;

    psVideoEncodeGlobalTaskConfig  = &psVideoEncodeCit->sEncGlobalTaskConfig;
    psGlobalEncodeTaskConfig       = &psVideoEncodeGlobalTaskConfig->sGlobalVideoEncoderConfig;

    psVideoEncodeGlobalTaskConfig->ui32NumberOfNodesInTask = ui32TotalNodes;

    /* Hook RDQ/RRQ to CIT's branch input */

    /* From base Address of pRaagaTask->hRRQueue fill all the buffers. Fill RRQ in the beginning */
    /* This conversion is done to pass a virtual address as the second argument
        of BDSP_Raaga_P_MemWrite32 */
    BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                        pRaagaTask->hRRQueue->ui32BaseAddr,
                                            (void **)&pvRrqAddr);

    for(i = 0; i < BDSP_FWMAX_VIDEO_BUFF_AVAIL; i++)
    {
        BDSP_P_MemWrite32(pRaagaDevice->memHandle,
            (void *)((uint8_t *)pvRrqAddr+(i*4)),
            psVEncoderCfgIp->sPPBs[i].ui32DramBufferAddress);
    }

    /* Common Parameters */
    psGlobalEncodeTaskConfig->ui32MaxFrameHeight = psVEncoderCfgIp->MaxFrameHeight;
    psGlobalEncodeTaskConfig->ui32MaxFrameWidth  = psVEncoderCfgIp->MaxFrameWidth;
    psGlobalEncodeTaskConfig->ui32StripeWidth    = psVEncoderCfgIp->StripeWidth;
#if (defined BCHP_RAAGA_DSP_DMA_SCB0_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB1_DRAM_MAP5_ADDR_CFG || defined BCHP_RAAGA_DSP_DMA_SCB2_DRAM_MAP5_ADDR_CFG)
    if ( psVEncoderCfgIp->StripeWidth == 128 )
    {
        ui32DramMap5AddrCfg =0x00080005;
    }
    else if ( psVEncoderCfgIp->StripeWidth == 256 )
    {
        ui32DramMap5AddrCfg =0x00090005;
    }
#endif
    if ( psVEncoderCfgIp->StripeWidth == 64 )
    {
        StripeWidthIndex = 0;
    }
    else if ( psVEncoderCfgIp->StripeWidth == 128 )
    {
        StripeWidthIndex = 1;
    }
    else if ( psVEncoderCfgIp->StripeWidth == 256 )
    {
        StripeWidthIndex = 2;
    }

    for (uiDspIndex =0 ; uiDspIndex < pRaagaDevice->numDsp; uiDspIndex++)
    {
            uiOffset = pRaagaDevice->dspOffset[uiDspIndex];
#ifdef BCHP_RAAGA_DSP_DMA_SCB0_DRAM_MAP5_ADDR_CFG
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB0_DRAM_MAP5_ADDR_CFG + uiOffset,
                            ui32DramMap5AddrCfg);
#endif

#ifdef BCHP_RAAGA_DSP_DMA_SCB1_DRAM_MAP5_ADDR_CFG
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB1_DRAM_MAP5_ADDR_CFG + uiOffset,
                                ui32DramMap5AddrCfg);
#endif

#ifdef BCHP_RAAGA_DSP_DMA_SCB2_DRAM_MAP5_ADDR_CFG
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB2_DRAM_MAP5_ADDR_CFG + uiOffset,
                                ui32DramMap5AddrCfg);
#endif


#ifdef BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL0_MASK
            ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset);

            ui32RegVal = ui32RegVal & ( ~(BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL0_MASK) );
            ui32RegVal = ui32RegVal | (StripeWidthIndex << BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL0_SHIFT);

            ui32RegVal = ui32RegVal & ( ~(BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_SCB0_MS4BITS_MASK) );
            uiMs4Bits =  ( (psVEncoderCfgIp->sScbAddrRange[0].ui32StartPhysicalOffset + psVEncoderCfgIp->sScbAddrRange[0].ui32Size) & BDSP_CIT_MS4BITS_MASK );
            uiMs4Bits >>= BDSP_CIT_MS4BITS_TO_LS4BITS_SHIFT;
            ui32RegVal = ui32RegVal | (uiMs4Bits << BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_SCB0_MS4BITS_SHIFT);
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset, ui32RegVal);
#endif

#ifdef BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL1_MASK
            if ( psVEncoderCfgIp->ui32NumOfScbs > 1 )
            {
                ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset);
                ui32RegVal = ui32RegVal & ( ~(BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL1_MASK) );
                ui32RegVal = ui32RegVal | (StripeWidthIndex << BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL1_SHIFT);

                ui32RegVal = ui32RegVal & ( ~(BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_SCB1_MS4BITS_MASK) );
                uiMs4Bits =  ( (psVEncoderCfgIp->sScbAddrRange[0].ui32StartPhysicalOffset + psVEncoderCfgIp->sScbAddrRange[0].ui32Size) & BDSP_CIT_MS4BITS_MASK );
                uiMs4Bits >>= BDSP_CIT_MS4BITS_TO_LS4BITS_SHIFT;
                ui32RegVal = ui32RegVal | (uiMs4Bits << BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_SCB1_MS4BITS_SHIFT);
                BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset, ui32RegVal);
            }
#endif

#ifdef BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL2_MASK
            if ( psVEncoderCfgIp->ui32NumOfScbs > 2 )
            {
                ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset);
                ui32RegVal = ui32RegVal & ( ~(BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL2_MASK) );
                ui32RegVal = ui32RegVal | (StripeWidthIndex << BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG_STRIPE_WIDTH_SEL2_SHIFT);
                BDSP_Write32(pRaagaDevice->regHandle, BCHP_RAAGA_DSP_DMA_SCB_IF_CONFIG + uiOffset, ui32RegVal);
            }
#endif
#if 0

#ifdef BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_MDIV_CH0_MASK
            ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0 + uiOffset);\
            ui32RegVal = ui32RegVal & ( ~(BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_MDIV_CH0_MASK) );
            ui32RegVal |= (5 << BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0_MDIV_CH0_SHIFT);
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_CLKGEN_PLL_RAAGA_PLL_CHANNEL_CTRL_CH_0 + uiOffset, ui32RegVal);


#endif


#ifdef BCHP_MEMC_ARB_0_CLIENT_INFO_55_RR_EN_MASK
            ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_MEMC_ARB_0_CLIENT_INFO_55 + uiOffset);
            ui32RegVal |= (BCHP_MEMC_ARB_0_CLIENT_INFO_55_RR_EN_ENABLED << BCHP_MEMC_ARB_0_CLIENT_INFO_55_RR_EN_SHIFT);
            BDSP_Write32(pRaagaDevice->regHandle, BCHP_MEMC_ARB_0_CLIENT_INFO_55 + uiOffset, ui32RegVal);


#endif
#ifdef BCHP_MEMC_ARB_0_CLIENT_INFO_127_RR_EN_MASK
                ui32RegVal = BDSP_Read32(pRaagaDevice->regHandle, BCHP_MEMC_ARB_0_CLIENT_INFO_127 + uiOffset);
                ui32RegVal |= (BCHP_MEMC_ARB_0_CLIENT_INFO_127_RR_EN_ENABLED << BCHP_MEMC_ARB_0_CLIENT_INFO_127_RR_EN_SHIFT);
                BDSP_Write32(pRaagaDevice->regHandle, BCHP_MEMC_ARB_0_CLIENT_INFO_127 + uiOffset, ui32RegVal);
#endif

#endif



    }



    /* REFERENCE FRAME BUFFER SETTINGS */
    psGlobalEncodeTaskConfig->sReferenceBuffParams.ui32NumBuffAvl = psVEncoderCfgIp->sReferenceBuffParams.ui32NumBuffAvl;

    /*TotalHorzPadd = 96, TotalVertPadd_Luma = 96, and TotalVertPadd_Chroma = 48*/
    /*(CEILING(((MaxVertSize/2) + TotalVertPadd_Chroma)/16) x 16)*/
    psGlobalEncodeTaskConfig->sReferenceBuffParams.ui32LumaStripeHeight = psVEncoderCfgIp->sReferenceBuffParams.ui32LumaStripeHeight;

    /*(CEILING((MaxVertSize + TotalVertPadd_Luma)/16) x 16)*/
    psGlobalEncodeTaskConfig->sReferenceBuffParams.ui32ChromaStripeHeight = psVEncoderCfgIp->sReferenceBuffParams.ui32ChromaStripeHeight;

    /* Reference Frame Buffers */
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_REF_BUFF_AVAIL;ui32Count++)
    {
        /* Luma */
        psGlobalEncodeTaskConfig->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress =
            psVEncoderCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress;

        psGlobalEncodeTaskConfig->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes =
                        psVEncoderCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes;

        /* Chroma */
                psGlobalEncodeTaskConfig->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress =
                    psVEncoderCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress;

        psGlobalEncodeTaskConfig->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes =
                        psVEncoderCfgIp->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes;
    }

    /* sPPBs */
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
    {
        psGlobalEncodeTaskConfig->sPPBs[ui32Count].ui32DramBufferAddress =
                        psVEncoderCfgIp->sPPBs[ui32Count].ui32DramBufferAddress;

        psGlobalEncodeTaskConfig->sPPBs[ui32Count].ui32BufferSizeInBytes =
                        psVEncoderCfgIp->sPPBs[ui32Count].ui32BufferSizeInBytes;
    }

    psGlobalEncodeTaskConfig->sEncoderParams.ui32Frames2Accum = psVEncoderCfgIp->sEncoderParams.ui32Frames2Accum;
    psGlobalEncodeTaskConfig->sEncoderParams.IsGoBitInterruptEnabled =
                                                psVEncoderCfgIp->sEncoderParams.IsGoBitInterruptEnabled;
    psGlobalEncodeTaskConfig->sEncoderParams.eEncodeFrameRate = psVEncoderCfgIp->sEncoderParams.eEncodeFrameRate;

    psGlobalEncodeTaskConfig->sEncoderParams.ui32InterruptBit[0] = psVEncoderCfgIp->sEncoderParams.ui32InterruptBit[0];
    psGlobalEncodeTaskConfig->sEncoderParams.ui32InterruptBit[1] = psVEncoderCfgIp->sEncoderParams.ui32InterruptBit[1];

    psGlobalEncodeTaskConfig->sEncoderParams.ui32StcAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP((psVEncoderCfgIp->sEncoderParams.ui32StcAddr));
    psGlobalEncodeTaskConfig->sEncoderParams.ui32StcAddr_hi = BDSP_RAAGA_REGSET_ADDR_FOR_DSP((psVEncoderCfgIp->sEncoderParams.ui32StcAddr_hi));

    /* We need to send the RDQ and RRQ's DRAM address too in global task configuration */
    psGlobalEncodeTaskConfig->sRawDataQueues.ui32DramBufferAddress
                = psVideoEncodeCit->sNodeConfig[0].ui32NodeIpBuffCfgAddr[0];
    psGlobalEncodeTaskConfig->sRawDataQueues.ui32BufferSizeInBytes
                = SIZEOF(BDSP_AF_P_sIO_BUFFER);

    BDBG_LEAVE(BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoEncodeCit);
    return ui32Error;
}

uint32_t BDSP_P_GenNewVideoCit( void                       *pTaskHandle,
                                            BDSP_AlgorithmType          eAlgorithm)
{
    unsigned ui32Err = BERR_SUCCESS ;

    BDSP_RaagaTask            *pRaagaTask      = (BDSP_RaagaTask *)pTaskHandle;
    BDSP_CIT_P_VideoCITOutput *psVideoCitOp    = &(pRaagaTask->videoCitOutput);
    BDSP_RaagaStage *pPrimaryStageHandle;

    BDSP_CIT_P_sTaskBuffInfo sTaskBuffInfo;
    unsigned ui32TotalNodes = 0;

    /*the whole of citOutput should be filled here*/

    BDBG_ENTER(BDSP_P_GenNewVideoCit);

    BDSP_CITGEN_P_ComputeTaskStackBuffSize(&sTaskBuffInfo);

    BDBG_ASSERT(NULL != pRaagaTask);
    BDBG_ASSERT(NULL != pRaagaTask->startSettings.primaryStage);

    pPrimaryStageHandle = (BDSP_RaagaStage *) pRaagaTask->startSettings.primaryStage->pStageHandle;

    if(BDSP_AlgorithmType_eVideoDecode == eAlgorithm)
    {
        ui32Err = BDSP_CITGEN_P_FillNodeCfgIntoNewCit(
                        pPrimaryStageHandle,
                        pRaagaTask->settings.dspIndex,
                        &psVideoCitOp->uVideoCit.sVideoDecTaskConfig.sNodeConfig[0],
                        &ui32TotalNodes);
    }
    else
    {
        /* Fill IO Buffer Explicitly for Video Encode case with the HRD , HRR and CCD Queue */
        ui32Err |= BDSP_CITGEN_P_FillInputforVideoEncode(pRaagaTask);

        ui32Err |= BDSP_CITGEN_P_FillNodeCfgIntoNewCit(
                        pPrimaryStageHandle,
                        pRaagaTask->settings.dspIndex,
                        &psVideoCitOp->uVideoCit.sVideoEncTaskConfig.sNodeConfig[0],
                        &ui32TotalNodes);
    }
    if( ui32Err != BERR_SUCCESS)
    {
        goto BDSP_VIDEOCITGENMODULE_P_EXIT_POINT;
    }

    if(ui32TotalNodes > BDSP_AF_P_MAX_NODES)
    {
        BDBG_ERR(("Error : The number of nodes in the system is %d. Maximum Allowed is %d", ui32TotalNodes,BDSP_AF_P_MAX_NODES));
        return(BERR_NOT_SUPPORTED);
    }
    BDBG_MSG(("ui32TotalNodes in Network = %d", ui32TotalNodes));

    /*  Fill the global task configuration into CIT */
    if(BDSP_AlgorithmType_eVideoDecode == eAlgorithm)
    {
        ui32Err = BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoDecodeCit(
                                (void *)pRaagaTask,
                                &psVideoCitOp->uVideoCit.sVideoDecTaskConfig,/*BDSP_VF_P_sDEC_TASK_CONFIG*/
                                (BDSP_sVDecoderIPBuffCfg *)pRaagaTask->startSettings.psVDecoderIPBuffCfg,
                                ui32TotalNodes);
    }
    else
    {
        ui32Err = BDSP_CITGEN_P_FillGblTaskCfgIntoNewVideoEncodeCit(
                                (void *)pRaagaTask,
                                &psVideoCitOp->uVideoCit.sVideoEncTaskConfig,/*BDSP_VF_P_sENC_TASK_CONFIGs*/
                                (BDSP_sVEncoderIPConfig *)pRaagaTask->startSettings.psVEncoderIPConfig,
                                ui32TotalNodes);
    }
    if( ui32Err != BERR_SUCCESS)
    {
        goto BDSP_VIDEOCITGENMODULE_P_EXIT_POINT;
    }

    /* EXIT Point */
    BDSP_VIDEOCITGENMODULE_P_EXIT_POINT:

    /* Check for Error and assert */
    if(ui32Err != BERR_SUCCESS)
    {
        BDBG_ASSERT(0);
    }

    BDBG_LEAVE(BDSP_P_GenNewVideoCit);

    return ui32Err;
}

static uint32_t BDSP_CITGEN_P_FillNodeCfgIntoNewCit(
                    BDSP_RaagaStage *pPrimaryStageHandle,
                    uint32_t dspIndex,
                    BDSP_AF_P_sNODE_CONFIG  *psNodeCfg,
                    unsigned *ui32TotalNodes)
{

    uint32_t    errCode;
    uint32_t    ui32Node;
    uint32_t    ui32NumNodesInAlgo;
    uint32_t    ui32NodeIndex, ui32Ip, ui32Op;
    unsigned    ui32IOPhysAddr, ui32IOGenPhysAddr, i;
    bool        collectResidue;
    BDSP_AF_P_sIO_GENERIC_BUFFER *pTempIoGenBuffer_Cached = NULL;
    BDSP_AF_P_sIO_BUFFER         *pTempIoBuffer_Cached = NULL;
    void        *pTemp;

    uint32_t    j, k;
    uint32_t    ui32FmmPortDstCount[BDSP_AF_P_DistinctOpType_eMax] = {0};

    const BDSP_Raaga_P_AlgorithmInfo *sAlgoInfo;

    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_RaagaContext *pRaagaContext;

    BDSP_Raaga *pRaagaDevice;

    BDSP_AF_P_ValidInvalid          eNodeValid = BDSP_AF_P_eInvalid;

    BDBG_ENTER(BDSP_CITGEN_P_FillNodeCfgIntoNewCit);

    /* TBD: Put lots of error prints in this function. Big and Error Prone */

    errCode = BERR_SUCCESS;

    pRaagaPrimaryStage = (BDSP_RaagaStage *)pPrimaryStageHandle;
    BDBG_ASSERT(NULL != pRaagaPrimaryStage->pContext);
    pRaagaContext = (BDSP_RaagaContext *)pRaagaPrimaryStage->pContext;
    BDBG_ASSERT(NULL != pRaagaContext->pDevice);
    pRaagaDevice = (BDSP_Raaga *)pRaagaContext->pDevice;

    ui32NodeIndex=0;

    collectResidue = true;

    /*Now, traverse through all the stages. Hold back the stage forking for later traversing.
    The assumption is that the stage o/p connection handle will be NULL if it has no o/p interstage connection */
    BDSP_STAGE_TRAVERSE_LOOP_BEGIN(pRaagaPrimaryStage, pRaagaConnectStage)
    BSTD_UNUSED(macroBrId);
    BSTD_UNUSED(macroStId);
    {
        sAlgoInfo = BDSP_Raaga_P_LookupAlgorithmInfo(pRaagaConnectStage->algorithm);

        ui32NumNodesInAlgo = sAlgoInfo->algoExecInfo.NumNodes;

        for( ui32Node=0; ui32Node<ui32NumNodesInAlgo; ui32Node++ )
        {
            /*Intialization for Master Slave Configuration Counter */
            for(j = 0; j< BDSP_AF_P_DistinctOpType_eMax; j++)
            {
                ui32FmmPortDstCount[j] = 0;
            }

            if(sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node] != BDSP_AF_P_AlgoId_eInvalid )
            {
                psNodeCfg->uiNodeId = ui32NodeIndex;/*increment to next node*/
                /*Populating the Collect Residual Flag */
                /*Branch Id is populated during the stage traverse to Download FW execs. Use it now.*/
                psNodeCfg->eCollectResidual = (collectResidue) ? BDSP_AF_P_eEnable : BDSP_AF_P_eDisable;
                BDBG_MSG(("Collect Residue [%s] = %d", (BDSP_Raaga_P_LookupAlgorithmInfo(pRaagaConnectStage->algorithm))->pName, collectResidue));

                psNodeCfg->eAlgoId = sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node];

                /* Audio Algorithm Type */
                psNodeCfg->ui32AudioAlgorithmType = sAlgoInfo->algorithm;

                /* TBD: Need to update the DDP decoder to stop using the decoderencpptype and then remove this hack */
                switch(sAlgoInfo->algorithm)
                {
                    case BDSP_Algorithm_eAc3Decode:
                    case BDSP_Algorithm_eAc3Passthrough:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eAc3;
                        break;
                    case BDSP_Algorithm_eMpegAudioDecode:
                    case BDSP_Algorithm_eMpegAudioPassthrough:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eMpeg;
                        break;
                    case BDSP_Algorithm_eAacAdtsDecode:
                    case BDSP_Algorithm_eAacAdtsPassthrough:
                    case BDSP_Algorithm_eAacLoasDecode:
                    case BDSP_Algorithm_eAacLoasPassthrough:
                    case BDSP_Algorithm_eDolbyPulseAdtsDecode:
                    case BDSP_Algorithm_eDolbyPulseLoasDecode:
                    case BDSP_Algorithm_eDolbyAacheAdtsDecode:
                    case BDSP_Algorithm_eDolbyAacheLoasDecode:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eAac;
                        break;
                    case BDSP_Algorithm_eAc3PlusDecode:
                    case BDSP_Algorithm_eAc3PlusPassthrough:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eAc3Plus;
                        break;
                    case BDSP_Algorithm_eUdcDecode:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eUdc;
                        break;
                    case BDSP_Algorithm_eUdcPassthrough:
                        /* This is specifically added if UDC Passthru is supported in Firmware and to take care of DDP or DD stream, the decision has to be made here */
                        for(k = 0; k< BDSP_AF_P_MAX_OP_FORKS; k++)
                        {
                            if(BDSP_AF_P_DistinctOpType_eCompressed4x == pRaagaConnectStage->eStageOpBuffDataType[k])
                            {
                                psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eAc3Plus;
                            }
                            else if( BDSP_AF_P_DistinctOpType_eCompressed == pRaagaConnectStage->eStageOpBuffDataType[k])
                            {
                                psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eAc3;
                            }
                            else
                            {
                                /* DO NOTHING */
                            }
                        }
                        break;
                    case BDSP_Algorithm_eWmaStdDecode:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eWmaStd;
                        break;
                    case BDSP_Algorithm_eDts14BitDecode:
                    case BDSP_Algorithm_eDts14BitPassthrough:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eDtsBroadcast;
                        break;
                    case BDSP_Algorithm_eDtsHdDecode:
                    case BDSP_Algorithm_eDtsHdPassthrough:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eDtshd;
                        break;
                    case BDSP_Algorithm_eDraDecode:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_DecodeAlgoType_eDra;
                        break;
                    default:
                        break;
                }

                BDBG_MSG(("ui32NodeIndex=%d", ui32NodeIndex));
                BDBG_MSG(("sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node]=%d, ui32Node=%d", sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node], ui32Node));


                /*  Code Buffer */
                psNodeCfg->ui32VomAlgoAddr =
                                                BDSP_sAlgoStartAddr.sVomAlgoStartAddr[psNodeCfg->eAlgoId];
                psNodeCfg->sDramAlgoCodeBuffer.ui32DramBufferAddress =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_CODE(psNodeCfg->eAlgoId)].offset;
                psNodeCfg->sDramAlgoCodeBuffer.ui32BufferSizeInBytes =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_CODE(psNodeCfg->eAlgoId)].size;

                if(ui32Node==0)
                {
                /*  Inter-Frame buffer */
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramInterFrameBuffer.ui32DramBufferAddress +
                                                pRaagaConnectStage->sFrameSyncOffset.ui32IfOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  Inter-Frame buffer */
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramInterFrameBuffer.ui32DramBufferAddress;

                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }

                }

                psNodeCfg->sDramInterFrameBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32InterFrmBuffSize;

                /*  ROM Table buffer */
                psNodeCfg->sDramLookupTablesBuffer.ui32DramBufferAddress =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_TABLE(psNodeCfg->eAlgoId)].offset;
                psNodeCfg->sDramLookupTablesBuffer.ui32BufferSizeInBytes =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_TABLE(psNodeCfg->eAlgoId)].size;



                if(ui32Node==0)
                {
                /*  User Config buffer*/
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramUserConfigBuffer.ui32DramBufferAddress
                                                + pRaagaConnectStage->sFrameSyncOffset.ui32UserCfgOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  User Config buffer */
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramUserConfigBuffer.ui32DramBufferAddress;
                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }

                }

                psNodeCfg->sDramUserConfigBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32UserCfgBuffSize;

                if(ui32Node==0)
                {
                /*  User Config buffer*/
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramStatusBuffer.ui32DramBufferAddress
                                                + pRaagaConnectStage->sFrameSyncOffset.ui32StatusOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  User Config buffer */
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramStatusBuffer.ui32DramBufferAddress;
                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }
                }
                psNodeCfg->sDramStatusBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32StatusBuffSize;

                /*  Num Src and destination for the node */
                psNodeCfg->ui32NumSrc = pRaagaConnectStage->totalInputs;/*inputs of all type*/
                psNodeCfg->ui32NumDst = pRaagaConnectStage->totalOutputs; /*Use the modified Dst o/ps*/

                /*The logic is in filling the node configuration for a stage which has more than one node, say decoder is:
                Both use the same IO Buffer and IO Gen Buffer as input and output respectively */

                pTempIoBuffer_Cached = NULL;
                pTempIoGenBuffer_Cached = NULL;
                /*  Input Configuration */
                for( ui32Ip=0; ui32Ip<BDSP_AF_P_MAX_IP_FORKS; ui32Ip++ )
                {
                    /*BDBG_ERR(("%s:%d - psNodeCfg->eNodeIpValidFlag[ui32Ip] %d", pRaagaConnectStage->sStageInput[ui32Ip].eNodeValid));*/
                    eNodeValid = pRaagaConnectStage->sStageInput[ui32Ip].eNodeValid;
                    psNodeCfg->eNodeIpValidFlag[ui32Ip] = eNodeValid;

                    if(eNodeValid)
                    {
                        BDBG_ASSERT(pRaagaConnectStage->sStageInput[ui32Ip].ui32StageIOBuffCfgAddr);
                        BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                                    pRaagaConnectStage->sStageInput[ui32Ip].ui32StageIOBuffCfgAddr,
                                                    &pTemp);
                        pTempIoBuffer_Cached = pTemp;

                        BDBG_ASSERT(pRaagaConnectStage->sStageInput[ui32Ip].ui32StageIOGenericDataBuffCfgAddr);
                        BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                                    pRaagaConnectStage->sStageInput[ui32Ip].ui32StageIOGenericDataBuffCfgAddr,
                                                    &pTemp);
                        pTempIoGenBuffer_Cached = pTemp;

                        switch (pRaagaConnectStage->sStageInput[ui32Ip].eConnectionType)
                        {
                            case BDSP_ConnectionType_eFmmBuffer:
                            case BDSP_ConnectionType_eRaveBuffer:
                            case BDSP_ConnectionType_eRDBBuffer:


                                pTempIoBuffer_Cached->eBufferType = pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.eBufferType;
                                pTempIoBuffer_Cached->ui32NumBuffers= pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.ui32NumBuffers;

                                for(i=0;i<pTempIoBuffer_Cached->ui32NumBuffers;i++)/*audio channels*/
                                {   /*ensure that the descriptors for FMM and RAVE that are passed are physical address*/
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32BaseAddr=pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.sCircBuffer[i].ui32BaseAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32EndAddr=pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.sCircBuffer[i].ui32EndAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32ReadAddr=pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.sCircBuffer[i].ui32ReadAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32WrapAddr=pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.sCircBuffer[i].ui32WrapAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32WriteAddr=pRaagaConnectStage->sStageInput[ui32Ip].IoBuffer.sCircBuffer[i].ui32WriteAddr;
                                }
                                BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoGenBuffer_Cached, sizeof(*pTempIoGenBuffer_Cached));
                                BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoBuffer_Cached, sizeof(*pTempIoBuffer_Cached));

                                pTemp = NULL;
                                BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                                pRaagaConnectStage->sIdsStageOutput.ui32StageIOGenericDataBuffCfgAddr,
                                                &pTemp);
                                pTempIoGenBuffer_Cached = pTemp;


                                BDBG_MSG(("FMM,RAVE,RDB i/p connection,ui32Ip=%d",ui32Ip));

                                break;
                            case BDSP_ConnectionType_eStage:

                                for (i = 0; i < pTempIoBuffer_Cached->ui32NumBuffers; i++)
                                {
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32BaseAddr
                                        = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer[i].ui32BaseAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32EndAddr
                                        = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer[i].ui32EndAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32ReadAddr
                                        = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer[i].ui32ReadAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32WriteAddr
                                        = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer[i].ui32WriteAddr;
                                    pTempIoBuffer_Cached->sCircBuffer[i].ui32WrapAddr
                                        = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer[i].ui32WrapAddr;
                                }

                                pTempIoGenBuffer_Cached->sCircBuffer.ui32BaseAddr
                                    = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer.ui32BaseAddr;
                                pTempIoGenBuffer_Cached->sCircBuffer.ui32EndAddr
                                    = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer.ui32EndAddr;
                                pTempIoGenBuffer_Cached->sCircBuffer.ui32ReadAddr
                                    = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer.ui32ReadAddr;
                                pTempIoGenBuffer_Cached->sCircBuffer.ui32WriteAddr
                                    = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer.ui32WriteAddr;
                                pTempIoGenBuffer_Cached->sCircBuffer.ui32WrapAddr
                                    = pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[pRaagaConnectStage->ui32BranchId].sCircBuffer.ui32WrapAddr;
                                BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoGenBuffer_Cached, sizeof(*pTempIoGenBuffer_Cached));
                                BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoBuffer_Cached, sizeof(*pTempIoBuffer_Cached));

                                BDBG_MSG(("Stage ip connection and Branch id of interstage=%d", pRaagaConnectStage->ui32BranchId));
                                break;

                            case BDSP_ConnectionType_eInterTaskBuffer:
                                /* Do nothing for inter task connection as the descriptors are populated
                                at create inter task buffer and inter task buffer flush */
                                break;
                            default:

                                BDBG_ERR(("ERROR: Invalid Connection type %d in BDSP_CITGEN_P_FillNodeCfgIntoNewCit",pRaagaConnectStage->sStageInput[ui32Ip].eConnectionType));
                                break;
                        }

                        /*convert to physical and */
                        BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                        (void *)pTempIoBuffer_Cached,
                                                        &ui32IOPhysAddr
                                                     );
                        /*convert to physical and */
                        BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                        (void *)pTempIoGenBuffer_Cached,
                                                        &ui32IOGenPhysAddr
                                                     );

                        BDBG_MSG(("ui32Ip= %d of a stage,pRaagaConnectStage->algorithm=%d,ui32IOPhysAddr =%x,ui32IOGenPhysAddr=%x ",ui32Ip, pRaagaConnectStage->algorithm, ui32IOPhysAddr, ui32IOGenPhysAddr));

                        psNodeCfg->ui32NodeIpBuffCfgAddr[ui32Ip] = ui32IOPhysAddr;
                        psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32Ip] = ui32IOGenPhysAddr;
                        /*psNodeCfg->ui32NodeIpBuffCfgAddr[ui32Ip] = (unsigned) pTempIoBuffer;*//*pRaagaConnectStage->sStageInput[ui32Ip].ui32StageIOBuffCfgAddr;*/

                    }
                }

                pTempIoBuffer_Cached = NULL;
                pTempIoGenBuffer_Cached = NULL;
                /* Output Configuration */
                /*Only for a decoder, this ui32Node is valid. For other stages, lets say SRC, node 0 is invalid and wont even enter this 'if'.*/
                if ((ui32Node == 0) && (ui32NumNodesInAlgo > 1))
                {
                    /* The output buffer descriptors for IDS (node 0 of a decode / mixer stage)
                    will always be the inter-stage buffer of branch 0 */
                    BDBG_MSG(("IDS of pRaagaConnectStage->algorithm=%d",pRaagaConnectStage->algorithm));

                    pTemp = NULL;
                    BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                        pRaagaConnectStage->sIdsStageOutput.ui32StageIOBuffCfgAddr,
                                        &pTemp);
                    pTempIoBuffer_Cached = pTemp;

                    pTemp = NULL;
                    BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                        pRaagaConnectStage->sIdsStageOutput.ui32StageIOGenericDataBuffCfgAddr,
                                        &pTemp);
                    pTempIoGenBuffer_Cached = pTemp;


                    /* Output IO buffer descriptor population */
                    pTempIoBuffer_Cached->eBufferType = BDSP_AF_P_BufferType_eDRAM_IS;
                    pTempIoBuffer_Cached->ui32NumBuffers = 0;
                    pRaagaConnectStage->sIdsStageOutput.eNodeValid = BDSP_AF_P_eValid;
                    pRaagaConnectStage->sIdsStageOutput.eConnectionType = BDSP_ConnectionType_eStage;

                    /* Output IO Generic buffer descriptor population */
                    pTempIoGenBuffer_Cached->eBufferType = BDSP_AF_P_BufferType_eDRAM_IS;
                    pTempIoGenBuffer_Cached->ui32NumBuffers = 1;

                    pTempIoGenBuffer_Cached->sCircBuffer.ui32BaseAddr=pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[0].sCircBuffer.ui32BaseAddr;
                    pTempIoGenBuffer_Cached->sCircBuffer.ui32EndAddr=pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[0].sCircBuffer.ui32EndAddr;
                    pTempIoGenBuffer_Cached->sCircBuffer.ui32ReadAddr=pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[0].sCircBuffer.ui32ReadAddr;
                    pTempIoGenBuffer_Cached->sCircBuffer.ui32WrapAddr=pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[0].sCircBuffer.ui32WrapAddr;
                    pTempIoGenBuffer_Cached->sCircBuffer.ui32WriteAddr=pRaagaDevice->memInfo.sScratchandISBuff[dspIndex].InterStageIOGenericBuff[0].sCircBuffer.ui32WriteAddr;

                    BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoGenBuffer_Cached, sizeof(*pTempIoGenBuffer_Cached));
                    BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoBuffer_Cached, sizeof(*pTempIoBuffer_Cached));


                    /*convert to physical and */
                    BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                    (void *)pTempIoBuffer_Cached,
                                                    &ui32IOPhysAddr
                                                 );
                    /*convert to physical and */
                    BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                    (void *)pTempIoGenBuffer_Cached,
                                                    &ui32IOGenPhysAddr
                                                 );
                    psNodeCfg->ui32NodeOpBuffCfgAddr[0] = ui32IOPhysAddr;
                    psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[0] = ui32IOGenPhysAddr;
                    psNodeCfg->eNodeOpBuffDataType[0] = BDSP_AF_P_DistinctOpType_eGenericIsData;

                    psNodeCfg->ui32NumDst = 1; /* Number of outputs from IDS node is always one */
                }
                else
                {

                    for( ui32Op=0; ui32Op<BDSP_AF_P_MAX_OP_FORKS; ui32Op++ )
                    {
                        eNodeValid = pRaagaConnectStage->sStageOutput[ui32Op].eNodeValid;
                        if(eNodeValid)
                        {
                            pTemp = NULL;
                            BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                                pRaagaConnectStage->sStageOutput[ui32Op].ui32StageIOBuffCfgAddr,
                                                &pTemp);
                            pTempIoBuffer_Cached = pTemp;

                            pTemp = NULL;
                            BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                                pRaagaConnectStage->sStageOutput[ui32Op].ui32StageIOGenericDataBuffCfgAddr,
                                                &pTemp);
                            pTempIoGenBuffer_Cached = pTemp;

                            switch (pRaagaConnectStage->sStageOutput[ui32Op].eConnectionType)
                            {
                                case BDSP_ConnectionType_eFmmBuffer:
                                case BDSP_ConnectionType_eRaveBuffer:
                                case BDSP_ConnectionType_eRDBBuffer:
                                    /*no IO Generic o/p to Rave(same for MDAL also - check ?)*/

                                    BKNI_Memset(pTempIoGenBuffer_Cached, 0, sizeof(BDSP_AF_P_sIO_GENERIC_BUFFER));

                                    if( BDSP_ConnectionType_eFmmBuffer == pRaagaConnectStage->sStageOutput[ui32Op].eConnectionType)
                                    {
                                        /*Detecting the Master /Slave port */
                                        /*
                                        The Algorithm is :
                                            The PI will not provide any information telling a buffer is Master or slave..

                                                Following are the Assumptions..
                                                    All slaves of a master port comes in a Distinct output as different output ports..
                                                    The first FMM output port of a distinct port is considered as Master and all other FMM ports are
                                                    considered as slave to the Master..

                                            CIT-gen counts the FMM ports in a Distinct output. If the number of FMM ports in a distinct output is >1,
                                            then the other FMM slave ports are present.

                                            If an FMM port is identified as Slave, them the Buffer type should be ....
                                        */
                                        if(0 != ui32FmmPortDstCount[pRaagaConnectStage->eStageOpBuffDataType[ui32Op]])
                                        {
                                            pTempIoBuffer_Cached->eBufferType = BDSP_AF_P_BufferType_eFMMSlave;
                                        }
                                        else
                                        {
                                            pTempIoBuffer_Cached->eBufferType = BDSP_AF_P_BufferType_eFMM;
                                        }
                                        ui32FmmPortDstCount[pRaagaConnectStage->eStageOpBuffDataType[ui32Op]]++;
                                    }
                                    else
                                    {
                                        pTempIoBuffer_Cached->eBufferType = pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.eBufferType;
                                    }

                                    pTempIoBuffer_Cached->ui32NumBuffers= pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.ui32NumBuffers;

                                    for(i=0;i<pTempIoBuffer_Cached->ui32NumBuffers;i++)/*audio channels*/
                                    {   /*ensure that the descriptors for FMM and RAVE that are passed are physical address*/
                                        pTempIoBuffer_Cached->sCircBuffer[i].ui32BaseAddr=pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.sCircBuffer[i].ui32BaseAddr;
                                        pTempIoBuffer_Cached->sCircBuffer[i].ui32EndAddr=pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.sCircBuffer[i].ui32EndAddr;
                                        pTempIoBuffer_Cached->sCircBuffer[i].ui32ReadAddr=pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.sCircBuffer[i].ui32ReadAddr;
                                        pTempIoBuffer_Cached->sCircBuffer[i].ui32WrapAddr=pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.sCircBuffer[i].ui32WrapAddr;
                                        pTempIoBuffer_Cached->sCircBuffer[i].ui32WriteAddr=pRaagaConnectStage->sStageOutput[ui32Op].IoBuffer.sCircBuffer[i].ui32WriteAddr;
                                    }
                                    BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoGenBuffer_Cached, sizeof(*pTempIoGenBuffer_Cached));
                                    BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)pTempIoBuffer_Cached, sizeof(*pTempIoBuffer_Cached));

                                    BDBG_MSG(("FMM RAVE RDB output connection"));
                                    break;

                                case BDSP_ConnectionType_eInterTaskBuffer: /* Do nothing as descriptor is populated at inter task buffer create */
                                case BDSP_ConnectionType_eStage: /*Populated during the Stage I/p itself. Since same descriptor for a stage-stage connection, no need to populate here*/
                                    break;
                                default:

                                    BDBG_ERR(("ERROR: Invalid Connection type %d in BDSP_CITGEN_P_FillNodeCfgIntoNewCit",pRaagaConnectStage->sStageOutput[ui32Op].eConnectionType));
                                    break;
                            }

                            /*convert to physical and */
                            BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                            (void *)pTempIoBuffer_Cached,
                                                            &ui32IOPhysAddr);

                            /*convert to physical and */
                            BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                                            (void *)pTempIoGenBuffer_Cached,
                                                            &ui32IOGenPhysAddr);

                            BDBG_MSG(("ui32Op= %d of a stage,pRaagaConnectStage->algorithm=%d, ui32IOPhysAddr=%x, ui32IOGenPhysAddr=%x",ui32Op, pRaagaConnectStage->algorithm, ui32IOPhysAddr, ui32IOGenPhysAddr));

                            psNodeCfg->ui32NodeOpBuffCfgAddr[ui32Op] = ui32IOPhysAddr;
                            psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32Op] = ui32IOGenPhysAddr;
                            psNodeCfg->eNodeOpBuffDataType[ui32Op] = pRaagaConnectStage->eStageOpBuffDataType[ui32Op];
                        }
                    }
                }

                psNodeCfg++;/*next node*/
                ui32NodeIndex++;
             }/*if node of a stage is valid*/
         }/*for( ui32Node=0; ui32Node<ui32NumNodesInAlgo; ui32Node++ )*/

        /*Node config fill for a stage ends here. Traverse to the next stage*/
        for (i = 0; i < BDSP_AF_P_MAX_OP_FORKS; i++)
        {
            if ((pRaagaConnectStage->sStageOutput[i].eConnectionType == BDSP_ConnectionType_eFmmBuffer)
                 && (pRaagaConnectStage->sStageOutput[i].eNodeValid == BDSP_AF_P_eValid))
            {
                collectResidue = false;
            }
        }
    }
    BDSP_STAGE_TRAVERSE_LOOP_END(pRaagaConnectStage)

     *ui32TotalNodes = ui32NodeIndex;

    BDBG_LEAVE(BDSP_CITGEN_P_FillNodeCfgIntoNewCit);

    return errCode;
}

/*  This function fills the global task configuration */
static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit (
                        BDSP_RaagaTask *pRaagaTask,
                        BDSP_AF_P_sTASK_CONFIG  *psCit,
                        unsigned ui32TotalNodes)

{
    uint32_t    ui32Error;
    int32_t  taskindex;
    BDSP_CIT_P_sAlgoModePresent sAlgoModePresent;
    BDSP_AF_P_DolbyMsUsageMode  eDolbyMsUsageMode;
    BDSP_AF_P_sStcTrigConfig    psStcTrigConfig;
    unsigned ui32ZeroFillSamples;
    raaga_dramaddr ui32PhysAddr;
    unsigned ui32TaskPortConfigAddr, ui32TaskGateOpenConfigAddr, ui32TaskFwHwCfgAddr;
    unsigned ui32FwOpSamplingFreqMapLutAddr, ui32StcTriggerCfgAddr;
    void *pTemp;
    BDSP_AF_P_sFMM_DEST_CFG* psFmmDestCfg;

    BDSP_AF_P_TASK_sFMM_GATE_OPEN_CONFIG    sTaskFmmGateOpenConfig;
    BDSP_TaskGateOpenSettings   sDependentTaskGateOpenSettings;
    BDSP_AF_P_sFW_HW_CFG        sFwHwCfg;
    BDSP_TaskStartSettings *pStartSettings;

    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_RaagaContext *pRaagaContext;

    BDSP_Raaga *pRaagaDevice;

    BDSP_AF_P_sGLOBAL_TASK_CONFIG *psGblTaskCfg;

    BDBG_ENTER(BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit);

    ui32Error = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(pRaagaTask, BDSP_RaagaTask);

    pRaagaPrimaryStage = (BDSP_RaagaStage *)pRaagaTask->startSettings.primaryStage->pStageHandle;
    pRaagaContext = (BDSP_RaagaContext *)pRaagaPrimaryStage->pContext;
    pRaagaDevice = (BDSP_Raaga *)pRaagaContext->pDevice;
    psGblTaskCfg = &psCit->sGlobalTaskConfig;

    pStartSettings = &pRaagaTask->startSettings;


    /*seems like the following psOpPortInfo->ui32NumopPorts is always zero. check
    If reqd, can be got from sTaskFmmGateOpenConfig->ui32NumPorts down and also populated there*/

    /*  Fill in the scratch buffer details */
    psGblTaskCfg->sDramScratchBuffer.ui32DramBufferAddress = pRaagaDevice->memInfo.sScratchandISBuff[pRaagaTask->settings.dspIndex].ui32DspScratchMemGrant.ui32DramBufferAddress;
    psGblTaskCfg->sDramScratchBuffer.ui32BufferSizeInBytes = pRaagaDevice->memInfo.sScratchandISBuff[pRaagaTask->settings.dspIndex].ui32DspScratchMemGrant.ui32BufferSizeInBytes;

    /*  Start node index */
    psGblTaskCfg->ui32StartNodeIndexOfCoreAudioAlgorithm = BDSP_CIT_P_NUM_SPECIAL_NODES;

    /*  WARNING!!! Num zero fill frames not filled. This may be required
        for bring up */

    /*  WARNING!!! All other global task parameters are unfilled */

    BDSP_MEM_P_ConvertAddressToOffset(  pRaagaDevice->memHandle,
                                    pRaagaTask->taskMemGrants.sTaskCfgBufInfo.pBaseAddr,
                                    &ui32PhysAddr
                                 );
    /*split the memory here */

    /* Adding port Config and SPDIF Config */
    ui32TaskPortConfigAddr      =   ui32PhysAddr;

    /* TaskGateOpenConfig */
    ui32TaskGateOpenConfigAddr  =   ui32TaskPortConfigAddr + BDSP_CIT_P_TASK_PORT_CONFIG_MEM_SIZE;

    /*PPM Configuration*/
    ui32TaskFwHwCfgAddr         =   ui32TaskGateOpenConfigAddr + BDSP_CIT_P_TASK_FMM_GATE_OPEN_CONFIG;

    ui32FwOpSamplingFreqMapLutAddr = ui32TaskFwHwCfgAddr    + BDSP_CIT_P_TASK_HW_FW_CONFIG;
    /* STC trigger config  */
    ui32StcTriggerCfgAddr   =   ui32FwOpSamplingFreqMapLutAddr + BDSP_CIT_P_TASK_FS_MAPPING_LUT_SIZE;

    pTemp = NULL;
    BDSP_MEM_P_ConvertOffsetToCacheAddr(pRaagaDevice->memHandle,
                                         ui32TaskPortConfigAddr,
                                         &pTemp);
    psFmmDestCfg = pTemp;

    /*BDSP_CIT_P_TASK_STC_TRIG_CONFIG_SIZE;*/
    BDSP_CITGEN_P_InitializeFmmDstCfg(psFmmDestCfg);
    BDSP_MEM_P_FlushCache(pRaagaDevice->memHandle, (void *)psFmmDestCfg, BDSP_CIT_P_TASK_PORT_CONFIG_MEM_SIZE);


    /* Add port Config and SPDIF Config */
    psGblTaskCfg->ui32FmmDestCfgAddr = ui32TaskPortConfigAddr;

    BKNI_Memset(&sTaskFmmGateOpenConfig,0,sizeof(BDSP_AF_P_TASK_sFMM_GATE_OPEN_CONFIG));
    if(true == pStartSettings->gateOpenReqd)
    {
        BDSP_Raaga_P_PopulateGateOpenFMMStages(
                                        (void *)pRaagaPrimaryStage,
                                        &sTaskFmmGateOpenConfig,
                                        pStartSettings->maxIndependentDelay
                                    );
        if(pStartSettings->DependentTaskInfo.numTasks >= BDSP_MAX_DEPENDENT_TASK)
        {
            BDBG_ERR(("BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit: Total number of Dependent task to open their respective gates is %d exceeding limit %d !!!!!!!!!!",pStartSettings->DependentTaskInfo.numTasks, BDSP_MAX_DEPENDENT_TASK));
            return BERR_INVALID_PARAMETER;
        }

        for(taskindex=0; taskindex<(int32_t)pStartSettings->DependentTaskInfo.numTasks; taskindex++)
        {
            BKNI_Memset(&sDependentTaskGateOpenSettings,0,sizeof(BDSP_TaskGateOpenSettings));
            sDependentTaskGateOpenSettings.psFmmGateOpenConfig = BKNI_Malloc(BDSP_AF_P_MAX_FMM_OP_PORTS_IN_TASK* sizeof(BDSP_AF_P_sFMM_GATE_OPEN_CONFIG));
            BDSP_Task_RetrieveGateOpenSettings( pStartSettings->DependentTaskInfo.DependentTask[taskindex],
                                                &sDependentTaskGateOpenSettings);
			if(sDependentTaskGateOpenSettings.ui32MaxIndepDelay != sTaskFmmGateOpenConfig.ui32MaxIndepDelay)
			{
				BDBG_ERR(("BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit: Max Independent Delay for Dependent task and Gate Open Incharge Task different"));
			}
            if((sTaskFmmGateOpenConfig.ui32NumPorts + sDependentTaskGateOpenSettings.ui32NumPorts)> BDSP_AF_P_MAX_FMM_OP_PORTS_IN_TASK)
            {
                BDBG_ERR(("BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit: Total number of FMM ports in the ecosystem exceeding the limit %d !!!!!!!!!!",BDSP_AF_P_MAX_FMM_OP_PORTS_IN_TASK));
                return BERR_INVALID_PARAMETER;
            }
            else
            {
                BKNI_Memcpy((void *)&(sTaskFmmGateOpenConfig.sFmmGateOpenConfig[sTaskFmmGateOpenConfig.ui32NumPorts]),
                            sDependentTaskGateOpenSettings.psFmmGateOpenConfig,
                            (sDependentTaskGateOpenSettings.ui32NumPorts * sizeof(BDSP_AF_P_sFMM_GATE_OPEN_CONFIG)));
                sTaskFmmGateOpenConfig.ui32NumPorts += sDependentTaskGateOpenSettings.ui32NumPorts;
            }
            BKNI_Free(sDependentTaskGateOpenSettings.psFmmGateOpenConfig);
        }
    }
	else
	{
		BDBG_MSG(("BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit: Gate Open is turned OFF for this task"));
	}

    /*Adding Gate open */
    BDSP_P_WriteToOffset(pRaagaDevice->memHandle,
        (void *)&sTaskFmmGateOpenConfig,
        ui32TaskGateOpenConfigAddr,
        (uint32_t)SIZEOF(sTaskFmmGateOpenConfig));

    psGblTaskCfg->ui32FmmGateOpenConfigAddr         = ui32TaskGateOpenConfigAddr;

    /*Populating FwHw starts here*/
    BDSP_P_PopulateFwHwBuffer(
                                    (void *)pRaagaPrimaryStage,
                                    &sFwHwCfg
                                );
    BDSP_P_WriteToOffset(pRaagaDevice->memHandle,
        (void *)&sFwHwCfg,
        ui32TaskFwHwCfgAddr,
        SIZEOF(sFwHwCfg));

    /* Add Fw Hw cfg address*/
    psGblTaskCfg->ui32TaskFwHwCfgAddr               = ui32TaskFwHwCfgAddr;

/*Populating LUTTable starts here*/

    /*First populate sAlgoModePresent, along with that get the number of nodes in Network also*/
    BDSP_PopulateAlgoMode(pRaagaPrimaryStage, &sAlgoModePresent);

    if (pStartSettings->pSampleRateMap)
    {
        /*Filling the Fw Op sampling map LUT */
        BDSP_P_WriteToOffset(pRaagaDevice->memHandle,
            (void *)pStartSettings->pSampleRateMap,
            (uint32_t)ui32FwOpSamplingFreqMapLutAddr,
            (uint32_t)(BDSP_CIT_P_TASK_FS_MAPPING_LUT_SIZE));
    }
    else
    {
        /*No idea at all where this eDolbyMsUsageMode has to be initialized*/
        eDolbyMsUsageMode = BDSP_AF_P_DolbyMsUsageMode_eSingleDecodeMode;
        ui32Error = BDSP_CITGEN_P_FillSamplingFrequencyMapLut(
                                        pRaagaDevice->memHandle,
                                        eDolbyMsUsageMode,
                                        ui32FwOpSamplingFreqMapLutAddr,
                                        &sAlgoModePresent
                                    );
    }

    /*First populate sStcTrigConfig*/
    BDSP_PopulateStcTrigConfig(&psStcTrigConfig, pStartSettings);


    /* Populating the Stc trigger configuration registers-structures */
    BDSP_P_WriteToOffset(pRaagaDevice->memHandle,
                            (void *)&psStcTrigConfig,
                            ui32StcTriggerCfgAddr,
                            (uint32_t)SIZEOF(BDSP_AF_P_sStcTrigConfig));


    /* Finding the Zero Fill Samples  */  /*Need to check whether FW is using */
    ui32Error = BDSP_CITGEN_P_GetNumZeroFillSamples(
        &ui32ZeroFillSamples,
        pRaagaPrimaryStage);

    psGblTaskCfg->ui32NumberOfNodesInTask = ui32TotalNodes;


    /* Add FW Op Sampling Frequency Cfg*/
    psGblTaskCfg->ui32FwOpSamplingFreqMapLutAddr    = ui32FwOpSamplingFreqMapLutAddr;

    /* Zero Fill samples ::: Currently not used by FW */
    psGblTaskCfg->ui32NumberOfZeroFillSamples       = ui32ZeroFillSamples;

    /*Filling the time base type */
    psGblTaskCfg->eTimeBaseType                     = pRaagaTask->startSettings.timeBaseType;

    /* STC trigger config address */
    psGblTaskCfg->ui32StcTrigConfigAddr             = ui32StcTriggerCfgAddr;

    BDBG_LEAVE(BDSP_CITGEN_P_FillGblTaskCfgIntoNewCit);

    return ui32Error;
}

static uint32_t BDSP_CITGEN_P_FillNodeCfgIntoNewScmCit(
                    BDSP_RaagaStage *pPrimaryStageHandle,
                    BDSP_SCM_P_sTASK_CONFIG         *psCit,
                    unsigned *ui32TotalNodes)
{

    uint32_t    errCode;
    uint32_t    ui32Node;
    uint32_t    ui32NumNodesInAlgo;
    uint32_t    ui32NodeIndex;
    unsigned    i;
    BDSP_AF_P_sNODE_CONFIG  *psNodeCfg;
    bool collectResidue;

    const BDSP_Raaga_P_AlgorithmInfo *sAlgoInfo;

    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_RaagaContext *pRaagaContext;

    BDSP_Raaga *pRaagaDevice;

    BDBG_ENTER(BDSP_CITGEN_P_FillNodeCfgIntoNewScmCit);

    /* TBD: Put lots of error prints in this function. Big and Error Prone */

    errCode = BERR_SUCCESS;

    pRaagaPrimaryStage = (BDSP_RaagaStage *)pPrimaryStageHandle;
    BDBG_ASSERT(NULL != pRaagaPrimaryStage->pContext);
    pRaagaContext = (BDSP_RaagaContext *)pRaagaPrimaryStage->pContext;
    BDBG_ASSERT(NULL != pRaagaContext->pDevice);
    pRaagaDevice = (BDSP_Raaga *)pRaagaContext->pDevice;

    ui32NodeIndex=0;

    /*  Update the CIT nodes based on execution order */
    psNodeCfg = psCit->sNodeConfig;

    collectResidue = true;

    /*Now, traverse through all the stages. Hold back the stage forking for later traversing.
    The assumption is that the stage o/p connection handle will be NULL if it has no o/p interstage connection */
    BDSP_STAGE_TRAVERSE_LOOP_BEGIN(pRaagaPrimaryStage, pRaagaConnectStage)
    BSTD_UNUSED(macroBrId);
    BSTD_UNUSED(macroStId);
    {

        sAlgoInfo = BDSP_Raaga_P_LookupAlgorithmInfo(pRaagaConnectStage->algorithm);

        ui32NumNodesInAlgo = sAlgoInfo->algoExecInfo.NumNodes;
            BDBG_MSG((" algo id = %d should be - %d numnodes - %d",pRaagaConnectStage->algorithm, BDSP_Algorithm_eSecurityC ,ui32NumNodesInAlgo ));

        for( ui32Node=0; ui32Node<ui32NumNodesInAlgo; ui32Node++ )
        {
            if(sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node] != BDSP_AF_P_AlgoId_eInvalid )
            {
                psNodeCfg->uiNodeId = ui32NodeIndex;/*increment to next node*/
                /*Populating the Collect Residual Flag */
                /*Branch Id is populated during the stage traverse to Download FW execs. Use it now.*/
                psNodeCfg->eCollectResidual = (collectResidue) ? BDSP_AF_P_eEnable : BDSP_AF_P_eDisable;
                BDBG_MSG(("Collect Residue [%s] = %d", (BDSP_Raaga_P_LookupAlgorithmInfo(pRaagaConnectStage->algorithm))->pName, collectResidue));

                psNodeCfg->eAlgoId = sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node];

                /* Audio Algorithm Type */
                psNodeCfg->ui32AudioAlgorithmType = sAlgoInfo->algorithm;

                /* TBD: Need to update the DDP decoder to stop using the decoderencpptype and then remove this hack */
                switch(sAlgoInfo->algorithm)
                {
                case BDSP_Algorithm_eSecurityA:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_ScmAlgoType_eScm1;
                        break;
                case BDSP_Algorithm_eSecurityB:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_ScmAlgoType_eScm2;
                        break;
                case BDSP_Algorithm_eSecurityC:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_ScmAlgoType_eScm3;
                        break;
                    default:
                        psNodeCfg->ui32AudioAlgorithmType = BDSP_AF_P_ScmAlgoType_eScm3;
                        break;
                }

                BDBG_MSG(("ui32NodeIndex=%d", ui32NodeIndex));
                BDBG_MSG(("sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node]=%d, ui32Node=%d", sAlgoInfo->algoExecInfo.eAlgoIds[ui32Node], ui32Node));


                /*  Code Buffer */
                psNodeCfg->ui32VomAlgoAddr =
                                                BDSP_sAlgoStartAddr.sVomAlgoStartAddr[psNodeCfg->eAlgoId];
                psNodeCfg->sDramAlgoCodeBuffer.ui32DramBufferAddress =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_CODE(psNodeCfg->eAlgoId)].offset;
                psNodeCfg->sDramAlgoCodeBuffer.ui32BufferSizeInBytes =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_CODE(psNodeCfg->eAlgoId)].size;

                if(ui32Node==0)
                {
                /*  Inter-Frame buffer */
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramInterFrameBuffer.ui32DramBufferAddress +
                                                pRaagaConnectStage->sFrameSyncOffset.ui32IfOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  Inter-Frame buffer */
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramInterFrameBuffer.ui32DramBufferAddress;

                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }

                }

                psNodeCfg->sDramInterFrameBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32InterFrmBuffSize;

                /*  ROM Table buffer */
                psNodeCfg->sDramLookupTablesBuffer.ui32DramBufferAddress =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_TABLE(psNodeCfg->eAlgoId)].offset;
                psNodeCfg->sDramLookupTablesBuffer.ui32BufferSizeInBytes =
                                                pRaagaDevice->imgCache[BDSP_IMG_ID_TABLE(psNodeCfg->eAlgoId)].size;



                if(ui32Node==0)
                {
                /*  User Config buffer*/
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramUserConfigBuffer.ui32DramBufferAddress
                                                + pRaagaConnectStage->sFrameSyncOffset.ui32UserCfgOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  User Config buffer */
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramUserConfigBuffer.ui32DramBufferAddress;
                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }

                }

                psNodeCfg->sDramUserConfigBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32UserCfgBuffSize;

                if(ui32Node==0)
                {
                /*  User Config buffer*/
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramStatusBuffer.ui32DramBufferAddress
                                                + pRaagaConnectStage->sFrameSyncOffset.ui32StatusOffset;
                }else /*if(ui32Node==1)*/
                {
                /*  User Config buffer */
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress =
                                                pRaagaConnectStage->sDramStatusBuffer.ui32DramBufferAddress;
                    if(ui32Node>1)
                    {
                        BDBG_ERR(("Number of nodes more than 2 in the branch %d and stage %d ", pRaagaConnectStage->ui32BranchId, pRaagaConnectStage->ui32StageId));
                    }
                }

                psNodeCfg->sDramStatusBuffer.ui32BufferSizeInBytes =
                                                BDSP_sNodeInfo[psNodeCfg->eAlgoId].ui32StatusBuffSize;

                /*  Num Src and destination for the node */
                psNodeCfg->ui32NumSrc = pRaagaConnectStage->totalInputs;/*inputs of all type*/
                psNodeCfg->ui32NumDst = pRaagaConnectStage->totalOutputs; /*Use the modified Dst o/ps*/

                psNodeCfg++;/*next node*/
                ui32NodeIndex++;
             }/*if node of a stage is valid*/
         }/*for( ui32Node=0; ui32Node<ui32NumNodesInAlgo; ui32Node++ )*/

        /*Node config fill for a stage ends here. Traverse to the next stage*/
        for (i = 0; i < BDSP_AF_P_MAX_OP_FORKS; i++)
        {
            if ((pRaagaConnectStage->sStageOutput[i].eConnectionType == BDSP_ConnectionType_eFmmBuffer)
                 && (pRaagaConnectStage->sStageOutput[i].eNodeValid == BDSP_AF_P_eValid))
            {
                collectResidue = false;
            }
        }
    }
    BDSP_STAGE_TRAVERSE_LOOP_END(pRaagaConnectStage)

     *ui32TotalNodes = ui32NodeIndex;

    BDBG_LEAVE(BDSP_CITGEN_P_FillNodeCfgIntoNewScmCit);

    return errCode;
}

/* Specific function for SCM */
/*  This function fills the global task configuration */
static uint32_t BDSP_CITGEN_P_FillGblTaskCfgIntoNewScmCit (
                        BDSP_RaagaTask *pRaagaTask,
                        BDSP_SCM_P_sTASK_CONFIG *psCit,
                        unsigned ui32TotalNodes)

{
    uint32_t    ui32Error;
    BDSP_CIT_P_sAlgoModePresent sAlgoModePresent;

    BDSP_RaagaStage *pRaagaPrimaryStage;
    BDSP_RaagaContext *pRaagaContext;

    BDSP_Raaga *pRaagaDevice;

    BDSP_SCM_P_sGLOBAL_TASK_CONFIG *psGblTaskCfg;

    BDBG_ENTER(BDSP_CITGEN_P_FillGblTaskCfgIntoNewScmCit);

    ui32Error = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(pRaagaTask, BDSP_RaagaTask);

    pRaagaPrimaryStage = (BDSP_RaagaStage *)pRaagaTask->startSettings.primaryStage->pStageHandle;
    pRaagaContext = (BDSP_RaagaContext *)pRaagaPrimaryStage->pContext;
    pRaagaDevice = (BDSP_Raaga *)pRaagaContext->pDevice;
    psGblTaskCfg = &psCit->sGlobalTaskConfig;

    /*  Fill in the scratch buffer details */
    psGblTaskCfg->sDramScratchBuffer.ui32DramBufferAddress = pRaagaDevice->memInfo.sScratchandISBuff[pRaagaTask->settings.dspIndex].ui32DspScratchMemGrant.ui32DramBufferAddress;
    psGblTaskCfg->sDramScratchBuffer.ui32BufferSizeInBytes = pRaagaDevice->memInfo.sScratchandISBuff[pRaagaTask->settings.dspIndex].ui32DspScratchMemGrant.ui32BufferSizeInBytes;

    /*  Start node index */
    psGblTaskCfg->ui32StartNodeIndexOfCoreScmAlgo = BDSP_CIT_P_NODE0;


    /*Populating LUTTable starts here*/

    /*First populate sAlgoModePresent, along with that get the number of nodes in Network also*/
    BDSP_PopulateAlgoMode(pRaagaPrimaryStage, &sAlgoModePresent);

    psGblTaskCfg->ui32NumberOfNodesInTask = ui32TotalNodes;


    BDBG_LEAVE(BDSP_CITGEN_P_FillGblTaskCfgIntoNewScmCit);

    return ui32Error;
}
/*******************************************************************************/


/*  This function analysis the CIT. The intention of this function is to
    analyse and print out all the parameters within the CIT structure
    Going forward it is expected to verify all the addresses and sizes also
    generated in the CIT strucuture*/
void BDSP_P_AnalyseCit( BMEM_Handle             hHeap,
                       BDSP_AF_P_sTASK_CONFIG   *psCit
                      )
{
    uint32_t    ui32NumNodes;
    uint32_t    ui32Node;
    uint32_t    ui32NumSrc, ui32NumDest;
    BDSP_AF_P_sGLOBAL_TASK_CONFIG   *psGblTaskCfg;
    BDSP_AF_P_sNODE_CONFIG          *psNodeCfg;

#ifdef ANALYZE_IO_CFG
    BDSP_AF_P_sIO_BUFFER            sIoBuffer;
    BDSP_AF_P_sIO_GENERIC_BUFFER    sIoGenericBuffer;
#endif

    BDBG_ENTER(BDSP_P_AnalyseCit);

    /*  First Step: Print all the informations within the CIT structure */
    BDBG_MSG(("Global Task Configuration parameters"));
    BDBG_MSG(("===================================="));

    psGblTaskCfg = &psCit->sGlobalTaskConfig;
    ui32NumNodes = psGblTaskCfg->ui32NumberOfNodesInTask;


    BDBG_MSG(("Time base for the Task:%s",GlobalTimeBase[psGblTaskCfg->eTimeBaseType]));
    BDBG_MSG(("--"));

    BDBG_MSG(("Number of Nodes in Task: %d ",ui32NumNodes));
    BDBG_MSG(("Number of Zero Fill Frames: 0x%x ",
        psGblTaskCfg->ui32NumberOfZeroFillSamples));
    BDBG_MSG(("Start Node index of Core Algo: %d ",
        psGblTaskCfg->ui32StartNodeIndexOfCoreAudioAlgorithm));

    /*
        Removing:
    ui32NumPorts = psGblTaskCfg->ui32NumOpPorts;
    BDBG_MSG(("Number of Output Ports in Task: %d ",
        psGblTaskCfg->ui32NumOpPorts));

    for(ui32Port=0; ui32Port<ui32NumPorts; ui32Port++)
    {
        BDBG_MSG(("Output Port Configuration for Port: %d ",ui32Port));
        BDBG_MSG(("TBD "));
    }
    */

    /*  Dram Scratch buffer Address and Size */
    BDBG_MSG(("--"));
    BDBG_MSG(("DRAM Scratch Buffer Address: 0x%x ",
        psGblTaskCfg->sDramScratchBuffer.ui32DramBufferAddress));
    BDBG_MSG(("DRAM Scratch Buffer Size Allocated: %d Bytes ",
        psGblTaskCfg->sDramScratchBuffer.ui32BufferSizeInBytes));
    BDBG_MSG(("--"));

    /* DRAM port Configuration */
    BDBG_MSG(("Port Configuration address 0x%x  ",psGblTaskCfg->ui32FmmDestCfgAddr));

    /* DRAM Gate Open Configuration */
    BDBG_MSG(("Gate Open Configuration address 0x%x  ",psGblTaskCfg->ui32FmmGateOpenConfigAddr));
    BDBG_MSG(("--"));



    BDBG_MSG(("Node Configuration parameters "));
    BDBG_MSG(("============================= "));
    for(ui32Node=0; ui32Node<ui32NumNodes; ui32Node++)
    {
        psNodeCfg = &psCit->sNodeConfig[ui32Node];
        BDBG_MSG(("Node index: %d ",psNodeCfg->uiNodeId));
        BDBG_MSG(("Algo Id: %s ",AlgoIdEnum2Char[psNodeCfg->eAlgoId]));

        BDBG_MSG(("\neCollectResidual : %s ",DisableEnable[psNodeCfg->eCollectResidual]));
        /*BDBG_ERR(("Algo Id: %x ",psNodeCfg->eAlgoId));*/

        /*  Code Address and Size */
        BDBG_MSG(("DRAM Code Buffer Address: 0x%x ",
            psNodeCfg->sDramAlgoCodeBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Code Buffer Size: %d Bytes",
            psNodeCfg->sDramAlgoCodeBuffer.ui32BufferSizeInBytes));

        /*  Lookup Table Address and Size */
        BDBG_MSG(("DRAM Lookup Table Buffer Address: 0x%x ",
            psNodeCfg->sDramLookupTablesBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Lookup Table Buffer Size: %d Bytes",
            psNodeCfg->sDramLookupTablesBuffer.ui32BufferSizeInBytes));

        /*  Inter-frame buffer Address check */
        if( psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Not present for this Node"));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Address: 0x%x ",
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: %d Bytes",
                psNodeCfg->sDramInterFrameBuffer.ui32BufferSizeInBytes));
        }

        /*  Node Status buffer Address check */
        if( psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Node Status buffer Not present for this Node"));
            BDBG_MSG(("DRAM Node Status buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Node Status buffer Address: 0x%x ",
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Node Status buffer Size: %d Bytes",
                psNodeCfg->sDramStatusBuffer.ui32BufferSizeInBytes));
        }

        /*  User config buffer Address check */
        if( psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM User Config Buffer not present for this Node"));
            BDBG_MSG(("DRAM User Config Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM User Config Buffer Address: 0x%x ",
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM User Config Buffer Size: %d Bytes",
                psNodeCfg->sDramUserConfigBuffer.ui32BufferSizeInBytes));
        }

        /*  Input buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Input Configuration Details:", ui32Node));
        BDBG_MSG(("Num Source feeding data to this node: %d", psNodeCfg->ui32NumSrc));
        for( ui32NumSrc=0; ui32NumSrc<psNodeCfg->ui32NumSrc; ui32NumSrc++)
        {
            BDBG_MSG(("--"));

            BDBG_MSG(("Source %d Input Buffer is [%s]",ui32NumSrc, PortValidType[psNodeCfg->eNodeIpValidFlag[ui32NumSrc]]));

            BDBG_MSG(("Source %d Input Buffer Cfg Structure Address: 0x%x",
                ui32NumSrc, psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG
            /*BDBG_MSG(("Input buffer Configuration:"));*/
            if(psNodeCfg->eNodeIpValidFlag[ui32NumSrc] == BDSP_AF_P_eValid)
            {
                /* Getting the Virtual Address */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc],
                    (void *)&sIoBuffer,
                    (uint32_t)SIZEOF(BDSP_AF_P_sIO_BUFFER));

                /*Printing Buffer Type*/
                if((sIoBuffer.ui32NumBuffers >0) && (BDSP_AF_P_eValid == psNodeCfg->eNodeIpValidFlag[ui32NumSrc]) )
                {
                    BDBG_MSG(("Source %d Input Buffer Type: %s",
                    ui32NumSrc, BuffTypeEnum2Char[sIoBuffer.eBufferType]));
                }

                /*  Analyze Io Buff Struct */
                /* BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(&sIoBuffer); */
#endif
                BDBG_MSG(("Source %d Input Generic Buffer Cfg Structure Address: 0x%x",
                    ui32NumSrc, psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG

                /* BDBG_MSG(("Input Generic buffer Configuration:")); */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc],
                    (void *)&sIoGenericBuffer,
                    (uint32_t)SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

                /*Printing Buffer Type*/
                if(sIoGenericBuffer.ui32NumBuffers >0)
                {
                    BDBG_MSG(("Source %d Input Generic Buffer Type: %s",
                    ui32NumSrc,BuffTypeEnum2Char[sIoGenericBuffer.eBufferType]));
                }

                /*  Analyze Io Genric Buff Struct */
                 /* BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(&sIoGenericBuffer); */
            }
#endif
        }

        /*  Output buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Output Configuration Details:", ui32Node));
        BDBG_MSG(("Num Destination getting data from this node: %d",
            psNodeCfg->ui32NumDst));
        for( ui32NumDest=0; ui32NumDest<psNodeCfg->ui32NumDst; ui32NumDest++)
        {

            /* IO BUFFER CONFIGURATION */
            /*-------------------------*/

            /*Printing Output Buffer Cfg Structure Address */
            BDBG_MSG(("Destination %d Output Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest]));

#ifdef ANALYZE_IO_CFG
            /* BDBG_MSG(("Output buffer Configuration:"));*/

            if(0 != psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest])
            {

                /* Getting contents of the Destination IO buffer */
                /* Getting the Virtual Address */

            BDSP_P_ReadFromOffset(hHeap,
                        psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest],
                        (void *)&sIoBuffer,
                        (uint32_t)SIZEOF(BDSP_AF_P_sIO_BUFFER));

                /*Printing Buffer Type*/
                if(sIoBuffer.ui32NumBuffers >0)
                {
                    BDBG_MSG(("Destination %d Output Buffer Type: %s",
                    ui32NumDest, BuffTypeEnum2Char[sIoBuffer.eBufferType]));
                }


                /*  Print Io Buff Struct */
                /* BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(&sIoBuffer); */
            }
#endif


            /* IOGENERIC BUFFER CONFIGURATION */
            /*--------------------------------*/

            BDBG_MSG(("Destination %d Output Generic Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest]));


#ifdef ANALYZE_IO_CFG

            /*  Getting contents of the IO Generic buffer */
            if(0 != psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest])
            {

                /*Getting the Virtual Address */

            BDSP_P_ReadFromOffset(hHeap,
                psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest],
                (void *)&sIoGenericBuffer,
                (uint32_t)SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

                /*Printing Buffer Type*/
                if(sIoGenericBuffer.ui32NumBuffers >0)
                {
                    BDBG_MSG(("Destination %d Output Generic Buffer Type: %s",
                    ui32NumDest, BuffTypeEnum2Char[sIoGenericBuffer.eBufferType]));
                }

                /*  Analyze Io Genric Buff Struct */
                /* BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(&sIoGenericBuffer); */
            }
#endif

#ifdef BDSP_CIT_P_ENABLE_FORK_MATRIXING

            BDBG_MSG(("Destination %d Datatype : %s",
                ui32NumDest, PortDatatType[psNodeCfg->eNodeOpBuffDataType[ui32NumDest]]));

            BDBG_MSG(("--"));
#endif
        }

        BDBG_MSG(("============================= "));
    }

    BDBG_LEAVE(BDSP_P_AnalyseCit);
}


/*******************************************************************************/


/*  This function analysis the CIT. The intention of this function is to
    analyse and print out all the parameters within the CIT structure
    Going forward it is expected to verify all the addresses and sizes also
    generated in the CIT strucuture*/
void BDSP_P_AnalyseScmCit(  BMEM_Handle             hHeap,
                       BDSP_SCM_P_sTASK_CONFIG  *psScmCit
                      )
{
    uint32_t    ui32NumNodes;
    uint32_t    ui32Node;
    uint32_t    ui32NumSrc, ui32NumDest;
    BDSP_SCM_P_sGLOBAL_TASK_CONFIG  *psGblTaskCfg;
    BDSP_AF_P_sNODE_CONFIG          *psNodeCfg;

#ifdef ANALYZE_IO_CFG
    BDSP_AF_P_sIO_BUFFER            sIoBuffer;
    BDSP_AF_P_sIO_GENERIC_BUFFER    sIoGenericBuffer;
#endif

    /*  First Step: Print all the informations within the CIT structure */
    BDBG_MSG(("===================================="));
    BDBG_MSG(("=========== SCM CIT LOG============="));

    BDBG_MSG(("Global Task Configuration parameters"));
    BDBG_MSG(("===================================="));

    psGblTaskCfg = &psScmCit->sGlobalTaskConfig;
    ui32NumNodes = psGblTaskCfg->ui32NumberOfNodesInTask;


    BDBG_MSG(("Number of Nodes in Task: %d ",ui32NumNodes));
    BDBG_MSG(("Start Node index of Core Algo: %d ",
        psGblTaskCfg->ui32StartNodeIndexOfCoreScmAlgo));

    /*  Dram Scratch buffer Address and Size */
    BDBG_MSG(("--"));
    BDBG_MSG(("DRAM Scratch Buffer Address: 0x%x ",
        psGblTaskCfg->sDramScratchBuffer.ui32DramBufferAddress));
    BDBG_MSG(("DRAM Scratch Buffer Size Allocated: %d Bytes ",
        psGblTaskCfg->sDramScratchBuffer.ui32BufferSizeInBytes));
    BDBG_MSG(("--"));


    BDBG_MSG(("Node Configuration parameters "));
    BDBG_MSG(("============================= "));
    for(ui32Node=0; ui32Node<ui32NumNodes; ui32Node++)
    {
        psNodeCfg = &psScmCit->sNodeConfig[ui32Node];
        BDBG_MSG(("Node index: %d ",psNodeCfg->uiNodeId));
        BDBG_MSG(("Algo Id: %s ",AlgoIdEnum2Char[psNodeCfg->eAlgoId]));

        BDBG_MSG(("\neCollectResidual : %s ",DisableEnable[psNodeCfg->eCollectResidual]));
        /*BDBG_ERR(("Algo Id: %x ",psNodeCfg->eAlgoId));*/

        /*  Code Address and Size */
        BDBG_MSG(("DRAM Code Buffer Address: 0x%x ",
            psNodeCfg->sDramAlgoCodeBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Code Buffer Size: %d Bytes",
            psNodeCfg->sDramAlgoCodeBuffer.ui32BufferSizeInBytes));

        /*  Lookup Table Address and Size */
        BDBG_MSG(("DRAM Lookup Table Buffer Address: 0x%x ",
            psNodeCfg->sDramLookupTablesBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Lookup Table Buffer Size: %d Bytes",
            psNodeCfg->sDramLookupTablesBuffer.ui32BufferSizeInBytes));

        /*  Inter-frame buffer Address check */
        if( psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Not present for this Node"));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Address: 0x%x ",
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: %d Bytes",
                psNodeCfg->sDramInterFrameBuffer.ui32BufferSizeInBytes));
        }

        /*  Node Status buffer Address check */
        if( psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Node Status buffer Not present for this Node"));
            BDBG_MSG(("DRAM Node Status buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Node Status buffer Address: 0x%x ",
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Node Status buffer Size: %d Bytes",
                psNodeCfg->sDramStatusBuffer.ui32BufferSizeInBytes));
        }

        /*  User config buffer Address check */
        if( psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM User Config Buffer not present for this Node"));
            BDBG_MSG(("DRAM User Config Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM User Config Buffer Address: 0x%x ",
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM User Config Buffer Size: %d Bytes",
                psNodeCfg->sDramUserConfigBuffer.ui32BufferSizeInBytes));
        }

        /*  Input buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Input Configuration Details:", ui32Node));
        BDBG_MSG(("Num Source feeding data to this node: %d", psNodeCfg->ui32NumSrc));
        for( ui32NumSrc=0; ui32NumSrc<psNodeCfg->ui32NumSrc; ui32NumSrc++)
        {
            BDBG_MSG(("--"));

            BDBG_MSG(("Source %d Input Buffer Cfg Structure Address: 0x%x",
                ui32NumSrc, psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG
            /*BDBG_MSG(("Input buffer Configuration:"));*/

            /* Getting the Virtual Address */

            BDSP_P_ReadFromOffset(hHeap,
                psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc],
                (void *)&sIoBuffer,
                (uint32_t)SIZEOF(BDSP_AF_P_sIO_BUFFER));

            /*Printing Buffer Type*/
            if((sIoBuffer.ui32NumBuffers >0) && (BDSP_AF_P_eValid == psNodeCfg->eNodeIpValidFlag[ui32NumSrc]) )
            {
                BDBG_MSG(("Source %d Input Buffer Type: %s",
                ui32NumSrc, BuffTypeEnum2Char[sIoBuffer.eBufferType]));
            }

            /*  Analyze Io Buff Struct */
            /* BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(&sIoBuffer); */
#endif
            BDBG_MSG(("Source %d Input Generic Buffer Cfg Structure Address: 0x%x",
                ui32NumSrc, psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG

            /* BDBG_MSG(("Input Generic buffer Configuration:")); */

            /* Getting the Virtual Address */

            BDSP_P_ReadFromOffset(hHeap,
                psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc],
                (void * )&sIoGenericBuffer,
                (uint32_t)SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

            /*Printing Buffer Type*/
            if(sIoGenericBuffer.ui32NumBuffers >0)
            {
                BDBG_MSG(("Source %d Input Generic Buffer Type: %s",
                ui32NumSrc,BuffTypeEnum2Char[sIoGenericBuffer.eBufferType]));
            }

            /*  Analyze Io Genric Buff Struct */
             /* BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(&sIoGenericBuffer); */
#endif

        }

        /*  Output buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Output Configuration Details:", ui32Node));
        BDBG_MSG(("Num Destination getting data from this node: %d",
            psNodeCfg->ui32NumDst));
        for( ui32NumDest=0; ui32NumDest<psNodeCfg->ui32NumDst; ui32NumDest++)
        {

            /* IO BUFFER CONFIGURATION */
            /*-------------------------*/

            /*Printing Output Buffer Cfg Structure Address */
            BDBG_MSG(("Destination %d Output Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest]));

#ifdef ANALYZE_IO_CFG
            /* BDBG_MSG(("Output buffer Configuration:"));*/


            /* Getting contents of the Destination IO buffer */
            /* Getting the Virtual Address */

            BDSP_P_ReadFromOffset(hHeap,
                psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest],
                (void *)&sIoBuffer,
                (uint32_t)SIZEOF(BDSP_AF_P_sIO_BUFFER));

            /*Printing Buffer Type*/
            if(sIoBuffer.ui32NumBuffers >0)
            {
                BDBG_MSG(("Destination %d Output Buffer Type: %s",
                ui32NumDest, BuffTypeEnum2Char[sIoBuffer.eBufferType]));
            }


            /*  Print Io Buff Struct */
            /* BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(&sIoBuffer); */
#endif


            /* IOGENERIC BUFFER CONFIGURATION */
            /*--------------------------------*/

            BDBG_MSG(("Destination %d Output Generic Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest]));


#ifdef ANALYZE_IO_CFG

            /* Getting contents of the IO Generic buffer */
            /* Getting the Virtual Address */
            BDSP_P_ReadFromOffset(hHeap,
                psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest],
                (void *)&sIoGenericBuffer,
                (uint32_t)SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

            /*Printing Buffer Type*/
            if(sIoGenericBuffer.ui32NumBuffers >0)
            {
                BDBG_MSG(("Destination %d Output Generic Buffer Type: %s",
                ui32NumDest, BuffTypeEnum2Char[sIoGenericBuffer.eBufferType]));
            }

            /*  Analyze Io Genric Buff Struct */
            /* BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(&sIoGenericBuffer); */
#endif

#ifdef BDSP_CIT_P_ENABLE_FORK_MATRIXING

            BDBG_MSG(("Destination %d Datatype : %s",
                ui32NumDest, PortDatatType[psNodeCfg->eNodeOpBuffDataType[ui32NumDest]]));

            BDBG_MSG(("--"));
#endif
        }

        BDBG_MSG(("============================= "));
    }
}



#ifdef ANALYZE_IO_CFG
#ifdef ANALYSIS_IO_GEN_ENABLE
/*  This function Analyzes the I/O buff structure */
static void BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(BDSP_AF_P_sIO_BUFFER *psIoBuffStruct)
{
    uint32_t    ui32Buff;
    BDSP_AF_P_sDRAM_CIRCULAR_BUFFER *psCircBuff;

    /*  Need to put characters instead of directly printing value */
    BDBG_ERR(("Number of buffers: %d", psIoBuffStruct->ui32NumBuffers));
    BDBG_ERR(("Buffer Type: %s", BuffTypeEnum2Char[psIoBuffStruct->eBufferType]));

    for( ui32Buff=0; ui32Buff<psIoBuffStruct->ui32NumBuffers; ui32Buff++)
    {
        psCircBuff = &psIoBuffStruct->sCircBuffer[ui32Buff];

        if( ( psIoBuffStruct->eBufferType == BDSP_AF_P_BufferType_eRDB ) ||
            ( psIoBuffStruct->eBufferType == BDSP_AF_P_BufferType_eFMM ) ||
            ( psIoBuffStruct->eBufferType == BDSP_AF_P_BufferType_eRAVE ) )
        {
            /*  The circular buffer will contain address of RDB registers
                and not the actual DRAM addresses */
            BDBG_ERR(("Buffer %d Address of the Fifo Base Register in RDB: 0x%x ",
                ui32Buff,psCircBuff->ui32BaseAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo End Register in RDB: 0x%x ",
                ui32Buff,psCircBuff->ui32EndAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Write Pointer Register in RDB: 0x%x ",
                ui32Buff,psCircBuff->ui32WriteAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Read Pointer Register in RDB: 0x%x ",
                ui32Buff,psCircBuff->ui32ReadAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Wrap Pointer Register in RDB: 0x%x ",
                ui32Buff,psCircBuff->ui32WrapAddr));
        }
        else if ( psIoBuffStruct->eBufferType == BDSP_AF_P_BufferType_eDRAM_IS )
        {
            /*  The circular buffer the actual DRAM addresses as the buffer is Inter-stage */
            BDBG_ERR(("Buffer %d Fifo DRAM Base Address: 0x%x ",
                ui32Buff, psCircBuff->ui32BaseAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM End Address: 0x%x ",
                ui32Buff,psCircBuff->ui32EndAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Write Pointer Address: 0x%x ",
                ui32Buff,psCircBuff->ui32WriteAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Read Pointer Address: 0x%x ",
                ui32Buff,psCircBuff->ui32ReadAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Wrap Pointer Address: 0x%x ",
                ui32Buff,psCircBuff->ui32WrapAddr));
        }
        else
        {
            /*  This is a DRAM buffer */
            /*  WARNING!!! TBD */
        }
    }
}

/*  This function Analyzes the I/O Generic buffer structure */
static void BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(BDSP_AF_P_sIO_GENERIC_BUFFER *psIoGenericBuffStruct)
{
    BDSP_AF_P_sDRAM_CIRCULAR_BUFFER *psCircBuff;

    BDBG_ERR(("Number of buffers: %d", psIoGenericBuffStruct->ui32NumBuffers));
    /*  Need to put characters instead of directly printing value */
    if( psIoGenericBuffStruct->ui32NumBuffers != 0 )
    {
        BDBG_ERR(("Buffer Type: %s", BuffTypeEnum2Char[psIoGenericBuffStruct->eBufferType]));

        psCircBuff = &psIoGenericBuffStruct->sCircBuffer;

        if( ( psIoGenericBuffStruct->eBufferType == BDSP_AF_P_BufferType_eRDB ) ||
            ( psIoGenericBuffStruct->eBufferType == BDSP_AF_P_BufferType_eFMM ) ||
            ( psIoGenericBuffStruct->eBufferType == BDSP_AF_P_BufferType_eRAVE ) )
        {
            /*  The circular buffer will contain address of RDB registers
                and not the actual DRAM addresses */
            BDBG_ERR(("Buffer %d Address of the Fifo Base Register in RDB: 0x%x ",
                0,psCircBuff->ui32BaseAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo End Register in RDB: 0x%x ",
                0,psCircBuff->ui32EndAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Write Pointer Register in RDB: 0x%x ",
                0,psCircBuff->ui32WriteAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Read Pointer Register in RDB: 0x%x ",
                0,psCircBuff->ui32ReadAddr));
            BDBG_ERR(("Buffer %d Address of the Fifo Wrap Pointer Register in RDB: 0x%x ",
                0,psCircBuff->ui32WrapAddr));
        }
        else if ( psIoGenericBuffStruct->eBufferType == BDSP_AF_P_BufferType_eDRAM_IS )
        {
            /*  The circular buffer the actual DRAM addresses as the buffer is Inter-stage */
            BDBG_ERR(("Buffer %d Fifo DRAM Base Address: 0x%x ",
                0, psCircBuff->ui32BaseAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM End Address: 0x%x ",
                0,psCircBuff->ui32EndAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Write Pointer Address: 0x%x ",
                0,psCircBuff->ui32WriteAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Read Pointer Address: 0x%x ",
                0,psCircBuff->ui32ReadAddr));
            BDBG_ERR(("Buffer %d Fifo DRAM Wrap Pointer Address: 0x%x ",
                0,psCircBuff->ui32WrapAddr));
        }
        else
        {
            /*  This is a DRAM buffer */
            /*  WARNING!!! TBD */
        }
    }
}
#endif /* #endif#ifdef ANALYSIS_IO_GEN_ENABLE */

#endif

/******************************************************************************
Summary:

    Compute the Buffer Size of a Task's stack

Description:

    Every Task will be assiciated with a DRAM stack. This is to enable stack swap
    in DSP.

    Allocated stack size per task is BDSP_CIT_P_TASK_SWAP_BUFFER_SIZE_INBYTES
    bytes.

Input:
        None
Output:
        psTaskBuffInfo : Buffer information for a task
Returns:
        None

******************************************************************************/

static void BDSP_CITGEN_P_ComputeTaskStackBuffSize(
                    BDSP_CIT_P_sTaskBuffInfo    *psTaskBuffInfo )

{
    BDBG_ENTER(BDSP_CITGEN_P_ComputeTaskStackBuffSize);

    psTaskBuffInfo->ui32TaskStackMemSize
                        = BDSP_CIT_P_TASK_SWAP_BUFFER_SIZE_INBYTES;

    BDBG_LEAVE(BDSP_CITGEN_P_ComputeTaskStackBuffSize);

}

BERR_Code BDSP_P_PopulateFwHwBuffer(
                                void *pPrimaryStageHandle,
                                BDSP_AF_P_sFW_HW_CFG        *psFwHwCfg
                            )
{
    BERR_Code errCode;
    unsigned output;

    unsigned ui32Count = 0, ui32PPMCount = 0, ui32BufferId = 0;

    BDSP_RaagaStage *pRaagaPrimaryStage = (BDSP_RaagaStage *)pPrimaryStageHandle;

    BDBG_ASSERT(NULL != pRaagaPrimaryStage);

    /*Initialization*/
    for(ui32Count =0; ui32Count<BDSP_AF_P_MAX_ADAPTIVE_RATE_BLOCKS;ui32Count++)
    {
        psFwHwCfg->sPpmCfg[ui32Count].ePPMChannel       = BDSP_AF_P_eDisable;
        psFwHwCfg->sPpmCfg[ui32Count].ui32PPMCfgAddr    = (uint32_t)((unsigned long)NULL);
    }

    BDSP_STAGE_TRAVERSE_LOOP_BEGIN(pRaagaPrimaryStage, pRaagaConnectStage)
    BSTD_UNUSED(macroBrId);
    BSTD_UNUSED(macroStId);
    {
        for(output=0;output<BDSP_AF_P_MAX_OP_FORKS;output++)
        {
            if(pRaagaConnectStage->sStageOutput[output].eConnectionType == BDSP_ConnectionType_eFmmBuffer &&
                pRaagaConnectStage->sStageOutput[output].eNodeValid==BDSP_AF_P_eValid)
            {
                for(ui32Count =0; ui32Count<BDSP_AF_P_MAX_CHANNEL_PAIR;ui32Count++)
                {
                    ui32BufferId = pRaagaConnectStage->sStageOutput[output].Metadata.rateController[ui32Count].wrcnt;
                    /*ui32BufferId would be -1 by default by init if FMM dest not added*/
                    if(ui32BufferId != BDSP_CIT_P_PI_INVALID)
                    {
                        if(ui32PPMCount >= BDSP_AF_P_MAX_ADAPTIVE_RATE_BLOCKS)
                        {
                            errCode = BERR_LEAKED_RESOURCE;
                            goto error;
                        }

                        psFwHwCfg->sPpmCfg[ui32PPMCount].ePPMChannel = BDSP_AF_P_eEnable;

                        psFwHwCfg->sPpmCfg[ui32PPMCount].ui32PPMCfgAddr = BDSP_RAAGA_REGSET_ADDR_FOR_DSP( ui32BufferId );

                        ui32PPMCount = ui32PPMCount + 1;
                    }
                }

            }
        }
    }
    BDSP_STAGE_TRAVERSE_LOOP_END(pRaagaConnectStage)

    return BERR_SUCCESS;
error:
    return errCode;

}

static uint32_t  BDSP_CITGEN_P_GetNumZeroFillSamples(
    uint32_t    *pui32ZeroFillSamples,
    BDSP_RaagaStage *pRaagaPrimaryStage
    )
{
    BERR_Code errCode = BERR_SUCCESS;
    bool foundValidStage = false;
    BDSP_RaagaStage *pRaagaStage = NULL;

    BDBG_ENTER(BDSP_CITGEN_P_GetNumZeroFillSamples);
    BDBG_ASSERT(NULL != pRaagaPrimaryStage);

    BDSP_STAGE_TRAVERSE_LOOP_V1_BEGIN(pRaagaPrimaryStage, pRaagaConnectStage, branchId, stageId)
    BSTD_UNUSED(stageId);
    {
        pRaagaStage = pRaagaConnectStage;
        if(branchId == 0)/*check only the first branch*/
        {
            /* Iterate till you hit the first Decode/Encode stage */
            switch ( BDSP_RAAGA_P_ALGORITHM_TYPE(pRaagaConnectStage->algorithm) )
            {
                case BDSP_AlgorithmType_eAudioDecode:
                case BDSP_AlgorithmType_eAudioMixer:
                case BDSP_AlgorithmType_eAudioPassthrough:
                case BDSP_AlgorithmType_eAudioEncode:
                case BDSP_AlgorithmType_eVideoDecode:
                case BDSP_AlgorithmType_eVideoEncode:
                case BDSP_AlgorithmType_eSecurity:
                    foundValidStage = true;
                    break;
                default:
                    break;
            }
        }
        else
        {
            /*break after the end of first branch*/
            break;
        }
    }
    BDSP_STAGE_TRAVERSE_LOOP_END(pRaagaConnectStage)

    BDBG_ASSERT(NULL != pRaagaStage);

    if( !(foundValidStage) )
    {
        *pui32ZeroFillSamples = 0;
        BDBG_ERR(("Unable to find the Decoder/Encoder stage in the 1st branch "));
        BDBG_LEAVE(BDSP_CITGEN_P_GetNumZeroFillSamples);
        return BERR_UNKNOWN;
    }

    switch(pRaagaStage->algorithm)
    {
        case BDSP_Algorithm_eMpegAudioDecode:
        case BDSP_Algorithm_eMpegAudioPassthrough:
            *pui32ZeroFillSamples = 13824;
            break;
        case BDSP_Algorithm_eAc3Decode:
        case BDSP_Algorithm_eAc3Passthrough:
            *pui32ZeroFillSamples = 18432;
            break;

        default:
            *pui32ZeroFillSamples = 0;
            break;
    }

    BDBG_LEAVE(BDSP_CITGEN_P_GetNumZeroFillSamples);
    return errCode;
}

/******************************************************************************
Summary:
    RESET Port Configuration of a task

Description:

    RESET Port Configuration
            1) NCO
            2) PLL      (Only PLL0 and PLL1     Limitations are as per 7405RDB
            3) I2S      (Only I2S0 and I2S1)
            4) HiFiDAC  (Only DAC0)
            5) SPDIF    (Only SPDIF0).

             SPDIF1 is used only for MAI

Input:

    sFmmDestCfgArray:   FMM configuration for all th PLLs

Output:
    sFmmDestCfgArray:   FMM configuration for all th PLLs

Returns:
        None

******************************************************************************/
static void BDSP_CITGEN_P_InitializeFmmDstCfg(
                        BDSP_AF_P_sFMM_DEST_CFG     *psFmmDestCfgArray
                )
{
    uint32_t                                    ui32Count;
    uint32_t                                    ui32PllCount;
    BDSP_AF_P_sFMM_DEST_CFG                     *psFmmDestCfg;
    BDSP_AF_P_sFMM_DEST_NCO_CFG                 *psFmmNcoCfg;
    BDSP_AF_P_sFMM_DEST_PLL_CFG                 *psFmmDestPllCfg;
    BDSP_AF_P_sFMM_DEST_I2S_CLK_CFG             *psFmmDestI2SClkCfg;
    BDSP_AF_P_sFMM_DEST_DAC_CFG                 *psFmmDestDacCfg;
    BDSP_AF_P_sFMM_ESR_REGISTER                 *psFmmEsrReg;
    BDSP_AF_P_sFMM_DEST_SPDIF_CLK_CBIT_CFG      *psFmmDestSpdifClkCbitCfg;
    BDSP_AF_P_sFMM_DEST_CAP_PORT_CLK_CFG        *psCapPortClkCfg;
#if defined DUMMY_PORT_SUPPORT
    BDSP_AF_P_sFMM_DEST_DUMMY_PORT_CLK_CFG      *psFmmDummyPortClkCfg;
#endif


    BDBG_ENTER(BDSP_CITGEN_P_InitializeFmmDstCfg);


    for(ui32PllCount =0;ui32PllCount<BDSP_AF_P_MAX_NUM_PLLS;ui32PllCount++)
    {

        psFmmDestCfg = &psFmmDestCfgArray[ui32PllCount];

        psFmmNcoCfg         = &psFmmDestCfg->sFmmDestNcoCfg;
        psFmmDestPllCfg     = &psFmmDestCfg->sFmmDestPllCfg;


        /*-----------------*/
        /*NCO Configuration*/
        /*-----------------*/
        psFmmDestCfg->eFmmPllNcoSelect          = BDSP_AF_P_NoneSelect; /*Global select to None*/

        psFmmNcoCfg->ui32NcoPhaseIncRegAddr     = (uint32_t)((unsigned long)NULL);
        psFmmNcoCfg->ui32NcoRateRatioRegAddr    =  (uint32_t)((unsigned long)NULL);
        psFmmNcoCfg->ui32NcoSampleIncRegAddr    =  (uint32_t)((unsigned long)NULL);

        /*-----------------*/
        /*PLL Configuration*/
        /*-----------------*/

        psFmmDestPllCfg->ui32PllEnabled             = (uint32_t)BDSP_AF_P_PortDisable;
        psFmmDestPllCfg->ui32PllIndex               = (uint32_t)BDSP_CIT_P_INVALID;
        psFmmDestPllCfg->ui32AudioPllMacroRegAddr   = (uint32_t)((unsigned long)NULL);


        /*------------------*/
        /* HBR Configuration*/
        /*------------------*/
        /*psFmmDestCfg->ui32HbrEnable = (uint32_t)BDSP_AF_P_PortDisable;*/
        psFmmDestCfg->eHdmiFsRate   = BDSP_AF_P_FmmDstFsRate_eBaseRate;

        /*---------------------*/
        /* HwCbit Configuration*/
        /*---------------------*/

        psFmmDestCfg->ui32HwCbitsEnable = (uint32_t)BDSP_AF_P_PortDisable;

        /*------------------*/
        /*I2S Configuration */
        /*------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_I2S_PORTS;ui32Count++)
        {
            psFmmDestI2SClkCfg = &psFmmDestCfg->sFmmDestI2SClkCfg[ui32Count];

            psFmmDestI2SClkCfg->ui32I2SEnabled              = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestI2SClkCfg->eFmmDstFsRate               = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psFmmDestI2SClkCfg->ui32AudioI2SClkMacroRegAddr = (uint32_t)((unsigned long)NULL);

        }


        /*-------------------*/
        /* SPDIF Configuration */
        /*-------------------*/
        psFmmEsrReg = &psFmmDestCfg->sFmmDestSpdifCfg.sFmmEsrRegister;

        psFmmEsrReg->ui32AudFmmMsEsrStatusRegAddr           = (uint32_t)((unsigned long)NULL);
        psFmmEsrReg->ui32AudFmmMsEsrStatusClearRegAddr      = (uint32_t)((unsigned long)NULL);


        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_SPDIF_PORTS;ui32Count++)
        {
            psFmmDestSpdifClkCbitCfg
                        = &psFmmDestCfg->sFmmDestSpdifCfg.sFmmDestSpdifClkCbitCfg[ui32Count];


            psFmmDestSpdifClkCbitCfg->ui32SpdifEnabled       = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestSpdifClkCbitCfg->eFmmDstFsRate          = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psFmmDestSpdifClkCbitCfg->ui32AudioSpdifClkMacroRegAddr
                                                             = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32SpdifCbitCtrlReg   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32CbitBasePingAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32CbitBasePongAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32PingPongMask       = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32SpdifDramConfigPtr = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32PcmOnSpdif         = (uint32_t)((unsigned long)NULL);
            psFmmDestSpdifClkCbitCfg->ui32AudFmmMsCtrlHwSpdifCfg
                                                             = (uint32_t)((unsigned long)NULL);

        }

        /*-------------------*/
        /* DAC Configuration */
        /*-------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_DAC_PORTS;ui32Count++)
        {
            psFmmDestDacCfg = &psFmmDestCfg->sFmmDestDacCfg[ui32Count];

            psFmmDestDacCfg->ui32DacEnabled                 = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDestDacCfg->eFmmDstFsRate                  = BDSP_AF_P_FmmDstFsRate_eInvalid;
            psFmmDestDacCfg->ui32HifidacRmPhaseIncRegAddr   = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRmRateRatioRegAddr  = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRmSampleIncRegAddr  = (uint32_t)((unsigned long)NULL);
            psFmmDestDacCfg->ui32HifidacRateManagerCfgAddr  = (uint32_t)((unsigned long)NULL);
        }

        /*------------------------*/
        /* CAPTURE Configuration  */
        /*------------------------*/

        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_CAP_PORTS;ui32Count++)
        {
            psCapPortClkCfg = &psFmmDestCfg->sFmmCapPortClkCfg[ui32Count];

            psCapPortClkCfg->ui32CapPortEnabled             = (uint32_t)BDSP_AF_P_PortDisable;
            psCapPortClkCfg->eFmmDstFsRate                  = BDSP_AF_P_FmmDstFsRate_eInvalid;

            psCapPortClkCfg->ui32AudioCapPortClkMacroRegAddr= (uint32_t)((unsigned long)NULL);
        }

        /*--------------------*/
        /* Dummy Port Config  */
        /*--------------------*/

#if defined DUMMY_PORT_SUPPORT
        for(ui32Count=0;ui32Count<BDSP_AF_P_MAX_NUM_DUMMY_PORTS;ui32Count++)
        {
            psFmmDummyPortClkCfg = &psFmmDestCfg->sFmmDummyPortClkCfg[ui32Count];

            psFmmDummyPortClkCfg->ui32DummyPortEnabled              = (uint32_t)BDSP_AF_P_PortDisable;
            psFmmDummyPortClkCfg->eFmmDstFsRate                     = BDSP_AF_P_FmmDstFsRate_eInvalid;
            psFmmDummyPortClkCfg->ui32DummyPortClkMacroRegAddr      = (uint32_t)((unsigned long)NULL);
        }
#endif
    }

    BDBG_LEAVE(BDSP_CITGEN_P_InitializeFmmDstCfg);
}

/******************************************************************************
Summary:
    This function fills the Smaplig frequency conversion table.
    The LUT tells the output sampling frequency of the CHIP for a particular
    input Fs..
            Table is divided into
                    a) QSF (8,11,12)
                    b) Half (16,22,24)
                    c) Full (32,44,48) and
                    d) High (64,88,96)
                    e) Very High (128,176,192)

    This table is modified if the DTS and Ac3 encoder is present.

  Aim of this LUT is to tell the IDS/Framesync/system about the final sampling frequency.
  For MPEG decoders, we need to support the prime band as the final Fs. FW looks into this
  LUT and gets the output sampling frequency LSF and QSF - > prime Frequency

  DTS Encoder exception:
        DTS encoder can do encode only on 44.1 and 48K not 32Khz.
        So the final sampling frequency for 8, 16 and 32Khz and 64Khz should be 48Khz.

  Ac3 Encoder exception:
        Ac3 encoder can do encode only on 48K.
        So the final sampling frequency for 8, 16,32Khz and 64Khzshould be 48Khz.


Description:

Input:
    psAlgoModePresent

Output:


Returns:
        Error

******************************************************************************/
static uint32_t BDSP_CITGEN_P_FillSamplingFrequencyMapLut(
                BMEM_Handle                 hHeap,
                BDSP_AF_P_DolbyMsUsageMode  eDolbyMsUsageMode,
                uint32_t                    ui32FwOpSamplingFreqMapLutAddr,
                BDSP_CIT_P_sAlgoModePresent *psAlgoModePresent
            )
{

    uint32_t ui32Error;
    BDSP_AF_P_sOpSamplingFreq   sOpSamplingFrequencyMapLut =    { {   /*QSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*HSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*FSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*HSF */
                                                                      32000,
                                                                      44100,
                                                                      48000,
                                                                      /*VHSF */
                                                                      32000,
                                                                      44100,
                                                                      48000
                                                                    }
                                                                };

    BDBG_ENTER(BDSP_CITGEN_P_FillSamplingFrequencyMapLut);

    ui32Error  = BERR_SUCCESS;

    /*Ms11 usage case */
#if 0 /* To be enabled when SRC is integrated into DDP to output data at 48 kHx always */
    if(
        (psAlgoModePresent->ui32DolbyPulsePresent == BDSP_CIT_P_PRESENT) ||
        (BDSP_AF_P_DolbyMsUsageMode_eMS11DecodeMode      == eDolbyMsUsageMode ) ||
        (BDSP_AF_P_DolbyMsUsageMode_eMS11SoundEffectMixing == eDolbyMsUsageMode )
      )
#else
    if ((psAlgoModePresent->ui32DolbyPulsePresent == BDSP_CIT_P_PRESENT) ||
        (   (psAlgoModePresent->ui32DdrePresent == BDSP_CIT_P_PRESENT) &&
            (   (BDSP_AF_P_DolbyMsUsageMode_eMS11DecodeMode == eDolbyMsUsageMode) ||
                (BDSP_AF_P_DolbyMsUsageMode_eMS11SoundEffectMixing == eDolbyMsUsageMode))))
#endif
    {
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[0] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[1] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[2] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[3] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[4] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[5] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[6] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[7] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[8] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[9] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[10] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[11] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[12] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[13] = 48000;
        sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[14] = 48000;
    }
    else
    {
        /*Special Case for DTS encoder and Ac3 encoder*/
        if( (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32DTS_EncoderPresent) ||
            (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32AC3_EncoderPresent)
          )
        {
            /*Upsampling to 48K output sampling frequency */

            /*  8K-> 48K */
            /* 16K-> 48K */
            /* 32K-> 48K */
            /* 64K-> 48K */
            /* 128K->48K */

            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[0] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[3] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[6] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[9] = 48000;
            sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[12]= 48000;

            /* Special Case for Ac3 encoder ONLY */
            if (BDSP_CIT_P_PRESENT == psAlgoModePresent->ui32AC3_EncoderPresent)
            {
                /* 11.025KHz -> 48KHz */
                /* 22.05KHz -> 48KHz */
                /* 44.1KHz -> 48KHz */
                /* 88.2KHz -> 48KHz */
                /* 176.4KHz -> 48KHz */
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e11_025Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e22_05Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e88_2Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e176_4Khz] = 48000;
                sOpSamplingFrequencyMapLut.ui32OpSamplingFrequency[BDSP_AF_P_SampFreq_e44_1Khz] = 48000;
            }
        }
    }

    BDSP_P_WriteToOffset(
                    hHeap,
                    (void *)&sOpSamplingFrequencyMapLut,
                    (uint32_t)ui32FwOpSamplingFreqMapLutAddr,
                    (uint32_t)(BDSP_CIT_P_TASK_FS_MAPPING_LUT_SIZE)
             );

    BDBG_LEAVE(BDSP_CITGEN_P_FillSamplingFrequencyMapLut);

    return(ui32Error);
}


static uint32_t BDSP_PopulateAlgoMode(
                BDSP_RaagaStage *pRaagaPrimaryStage,
                BDSP_CIT_P_sAlgoModePresent *sAlgoModePresent)
{
    BERR_Code errCode = BERR_SUCCESS;
    BDBG_ASSERT(NULL != pRaagaPrimaryStage);

    /*Initialize first*/
    sAlgoModePresent->ui32DolbyPulsePresent = BDSP_CIT_P_ABSENT;
    sAlgoModePresent->ui32DDP_PassThruPresent = BDSP_CIT_P_ABSENT;
    sAlgoModePresent->ui32DTS_EncoderPresent = BDSP_CIT_P_ABSENT;
    sAlgoModePresent->ui32AC3_EncoderPresent = BDSP_CIT_P_ABSENT;
    sAlgoModePresent->ui32DdrePresent = BDSP_CIT_P_ABSENT;

    BDSP_STAGE_TRAVERSE_LOOP_BEGIN(pRaagaPrimaryStage, pRaagaConnectStage)
    BSTD_UNUSED(macroBrId);
    BSTD_UNUSED(macroStId);
    {
        /* Handle special case algorithms */
        switch ( pRaagaConnectStage->algorithm )
        {
            case BDSP_Algorithm_eDolbyPulseAdtsDecode:
            case BDSP_Algorithm_eDolbyPulseLoasDecode:
                sAlgoModePresent->ui32DolbyPulsePresent
                                = BDSP_CIT_P_PRESENT;
                break;
            case BDSP_Algorithm_eAc3PlusPassthrough:
                sAlgoModePresent->ui32DDP_PassThruPresent
                                = BDSP_CIT_P_PRESENT;
                break;
            case BDSP_Algorithm_eDtsCoreEncode:
                sAlgoModePresent->ui32DTS_EncoderPresent
                                = BDSP_CIT_P_PRESENT;
                break;
            case BDSP_Algorithm_eAc3Encode:
                sAlgoModePresent->ui32AC3_EncoderPresent
                                = BDSP_CIT_P_PRESENT;
                break;
            case BDSP_Algorithm_eDdre:
                sAlgoModePresent->ui32DdrePresent
                                = BDSP_CIT_P_PRESENT;
                break;
            default:
                break;
        }
    }
    BDSP_STAGE_TRAVERSE_LOOP_END(pRaagaConnectStage)

    return errCode;
}



static void BDSP_PopulateStcTrigConfig(
                BDSP_AF_P_sStcTrigConfig    *psStcTrigConfig,
                BDSP_TaskStartSettings *pStartSettings
            )
{

    psStcTrigConfig->eStcTrigRequired = pStartSettings->stcIncrementConfig.enableStcTrigger;
    psStcTrigConfig->ui32StcIncHiAddr = pStartSettings->stcIncrementConfig.stcIncHiAddr;
    psStcTrigConfig->ui32StcIncLowAddr = pStartSettings->stcIncrementConfig.stcIncLowAddr;
    psStcTrigConfig->ui32StcIncTrigAddr = pStartSettings->stcIncrementConfig.stcIncTrigAddr;
    psStcTrigConfig->ui32TriggerBit = pStartSettings->stcIncrementConfig.triggerBit;

}


/****************************************************************************/
/****************************************************************************/
/************************* VIDEO TASK  **************************************/
/****************************************************************************/
/****************************************************************************/

/*---------------------------------------------------------------------
                Top level Video CIT Generation Function
---------------------------------------------------------------------*/

/******************************************************************************
Summary:
    This function analysis the Video CIT. The intention of this function is to
    analyse and print out all the parameters within the Video CIT structure

Description:

    Debug prints

Input:
    hHeap
    psCit

Output:
Returns:
        None

******************************************************************************/
void BDSP_P_AnalyseVideoCit(
                            BMEM_Handle                  hHeap,
                            BDSP_VF_P_uTASK_CONFIG      *puCit,
                            BDSP_AlgorithmType           eAlgorithm
                      )
{
    uint32_t    ui32NumNodes;
    uint32_t    ui32Node,ui32Count;
    uint32_t    ui32NumSrc, ui32NumDest;
    BDSP_AlgorithmType  algoType;

    BDSP_VF_P_sVDecodeBuffCfg       *psVDecodeBuffCfg;
    BDSP_VF_P_sGLOBAL_TASK_CONFIG   *psGblTaskCfg;
    BDSP_AF_P_sNODE_CONFIG          *psNodeCfg;
    BDSP_VF_P_sVEncodeConfig                *psVEncoderCfg;
    BDSP_VF_P_sENC_GLOBAL_TASK_CONFIG       *psEncGblTaskCfg;

#ifdef ANALYZE_IO_CFG
    BDSP_AF_P_sIO_BUFFER            sIoBuffer;
    BDSP_AF_P_sIO_GENERIC_BUFFER    sIoGenericBuffer;
#endif

    /*  First Step: Print all the informations within the CIT structure */
    BDBG_MSG(("Global Task Configuration parameters"));
    BDBG_MSG(("===================================="));

    algoType = eAlgorithm;

    if(algoType == BDSP_AlgorithmType_eVideoDecode)
    {
        psGblTaskCfg = &puCit->sVideoDecTaskConfig.sGlobalTaskConfig;

    ui32NumNodes = psGblTaskCfg->ui32NumberOfNodesInTask;

    BDBG_MSG(("--"));
    BDBG_MSG(("Displaying the Global Task Cfg from PI"));
    BDBG_MSG(("--------------------------------------"));
    BDBG_MSG(("--"));

    psVDecodeBuffCfg = &psGblTaskCfg->sGlobalTaskConfigFromPI;

    BDBG_MSG((" PRQ Circ Buffer Addresses:\n\tBase Addr  = 0x%x\n\tRead Addr  = 0x%x\n\tWrite Addr = 0x%x\n\tEnd   Addr = 0x%x\n\tWrap  Addr = 0x%x",
                        psVDecodeBuffCfg->sPRQ.ui32BaseAddr,
                        psVDecodeBuffCfg->sPRQ.ui32ReadAddr,
                        psVDecodeBuffCfg->sPRQ.ui32WriteAddr,
                        psVDecodeBuffCfg->sPRQ.ui32EndAddr,
                        psVDecodeBuffCfg->sPRQ.ui32WrapAddr));
    BDBG_MSG((" PDQ Circ Buffer Addresses:\n\tBase Addr  = 0x%x\n\tRead Addr  = 0x%x\n\tWrite Addr = 0x%x\n\tEnd   Addr = 0x%x\n\tWrap  Addr = 0x%x",
                        psVDecodeBuffCfg->sPDQ.ui32BaseAddr,
                        psVDecodeBuffCfg->sPDQ.ui32ReadAddr,
                        psVDecodeBuffCfg->sPDQ.ui32WriteAddr,
                        psVDecodeBuffCfg->sPDQ.ui32EndAddr,
                        psVDecodeBuffCfg->sPDQ.ui32WrapAddr));

    BDBG_MSG(("--"));

    BDBG_MSG(("\tMax Frame Height = 0x%x\n\tMax Frame Width = 0x%x\n\tStripe Width = 0x%x\n", \
                        psVDecodeBuffCfg->ui32MaxFrameHeight, \
                        psVDecodeBuffCfg->ui32MaxFrameWidth, \
                        psVDecodeBuffCfg->ui32StripeWidth));

    BDBG_MSG((" Display Frame Buffer Details "));
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
    {
        BDBG_MSG(("\t  Frame Buffer [%d] Params:\n\tLuma Buffer - Addr = 0x%x : Size = 0x%x \n\tChroma Buffer - Addr = 0x%x : Size = 0x%x\n\tNum Buffers = 0x%x\n\tLuma Stripe Height = 0x%x\tChroma Stripe Height = 0x%x" ,ui32Count, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.ui32NumBuffAvl, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.ui32LumaStripeHeight, \
                            psVDecodeBuffCfg->sDisplayFrameBuffParams.ui32ChromaStripeHeight));
        BDBG_MSG(("--"));
    }

    BDBG_MSG(("--"));
    BDBG_MSG((" Reference Buffer Details "));
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_REF_BUFF_AVAIL;ui32Count++)
    {
        BDBG_MSG(("\t  Reference Buffer [%d] Params:\n\tLuma Buffer - Addr = 0x%x : Size = 0x%x \n\tChroma Buffer - Addr = 0x%x : Size = 0x%x\n\tNum Buffers = 0x%x\n\tLuma Stripe Height = 0x%x\tChroma Stripe Height = 0x%x" ,ui32Count, \
                            psVDecodeBuffCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress, \
                            psVDecodeBuffCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes, \
                            psVDecodeBuffCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress, \
                            psVDecodeBuffCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes, \
                            psVDecodeBuffCfg->sReferenceBuffParams.ui32NumBuffAvl, \
                            psVDecodeBuffCfg->sReferenceBuffParams.ui32LumaStripeHeight, \
                            psVDecodeBuffCfg->sReferenceBuffParams.ui32ChromaStripeHeight));
        BDBG_MSG(("--"));
    }

    BDBG_MSG(("--"));
    BDBG_MSG((" UPB Buffer Details "));
    for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
    {

        BDBG_MSG(("\t UPB  [%d] Buffer Addr 0x%x Buffer Size  0x%x" ,ui32Count, \
                            psVDecodeBuffCfg->sUPBs[ui32Count].ui32DramBufferAddress,\
                            psVDecodeBuffCfg->sUPBs[ui32Count].ui32BufferSizeInBytes));
    }

    }
    else if (algoType == BDSP_AlgorithmType_eVideoEncode)
    {
        psEncGblTaskCfg = &puCit->sVideoEncTaskConfig.sEncGlobalTaskConfig;

        ui32NumNodes = psEncGblTaskCfg->ui32NumberOfNodesInTask;

        BDBG_MSG(("--"));
        BDBG_MSG(("Displaying the Global Task Cfg from PI"));
        BDBG_MSG(("--------------------------------------"));
        BDBG_MSG(("--"));

        psVEncoderCfg = &psEncGblTaskCfg->sGlobalVideoEncoderConfig;

        BDBG_MSG(("--"));

        BDBG_MSG(("\tMax Frame Height = 0x%x\n\tMax Frame Width = 0x%x\n\tStripe Width = 0x%x\n", \
                            psVEncoderCfg->ui32MaxFrameHeight, \
                            psVEncoderCfg->ui32MaxFrameWidth, \
                            psVEncoderCfg->ui32StripeWidth));

        BDBG_MSG(("\tInterrupt bit given are %d and %d", \
                        psVEncoderCfg->sEncoderParams.ui32InterruptBit[0], \
                        psVEncoderCfg->sEncoderParams.ui32InterruptBit[1]));
        BDBG_MSG(("\t STC address is 0x%08x", psVEncoderCfg->sEncoderParams.ui32StcAddr));

        BDBG_MSG(("--"));
        BDBG_MSG((" Reference Buffer Details "));
        for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_REF_BUFF_AVAIL;ui32Count++)
        {
            BDBG_MSG(("\t  Reference Buffer [%d] Params:\n\tLuma Buffer - Addr = 0x%x : Size = 0x%x \n\tChroma Buffer - Addr = 0x%x : Size = 0x%x\n\tNum Buffers = 0x%x\n\tLuma Stripe Height = 0x%x\tChroma Stripe Height = 0x%x" ,ui32Count, \
                                psVEncoderCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32DramBufferAddress, \
                                psVEncoderCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffLuma.ui32BufferSizeInBytes, \
                                psVEncoderCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32DramBufferAddress, \
                                psVEncoderCfg->sReferenceBuffParams.sBuffParams[ui32Count].sFrameBuffChroma.ui32BufferSizeInBytes, \
                                psVEncoderCfg->sReferenceBuffParams.ui32NumBuffAvl, \
                                psVEncoderCfg->sReferenceBuffParams.ui32LumaStripeHeight, \
                                psVEncoderCfg->sReferenceBuffParams.ui32ChromaStripeHeight));
            BDBG_MSG(("--"));
        }

        BDBG_MSG(("--"));
        BDBG_MSG((" UPB Buffer Details "));
        for(ui32Count =0;ui32Count<BDSP_FWMAX_VIDEO_BUFF_AVAIL;ui32Count++)
        {

            BDBG_MSG(("\t UPB  [%d] Buffer Addr 0x%x Buffer Size  0x%x" ,ui32Count, \
                                psVEncoderCfg->sPPBs[ui32Count].ui32DramBufferAddress,\
                                psVEncoderCfg->sPPBs[ui32Count].ui32BufferSizeInBytes));
        }

    }
    else
    {
        /* Error! should not come here */
        ui32NumNodes = 0;
    }

    BDBG_MSG(("Number of Nodes in Task: %d ",ui32NumNodes));

    BDBG_MSG(("Node Configuration parameters "));
    BDBG_MSG(("============================= "));
    for(ui32Node=0; ui32Node<ui32NumNodes; ui32Node++)
    {
        if(algoType == BDSP_AlgorithmType_eVideoDecode)
        {
            psNodeCfg = &puCit->sVideoDecTaskConfig.sNodeConfig[ui32Node];
        }
        else if(algoType == BDSP_AlgorithmType_eVideoEncode)
        {
            psNodeCfg = &puCit->sVideoEncTaskConfig.sNodeConfig[ui32Node];
        }
        else
        {
            psNodeCfg = NULL;
            BDBG_ERR(("Only video decoder and encoder is supported. Please debug."));
        }

        BDBG_MSG(("Node index: %d ",psNodeCfg->uiNodeId));
        BDBG_MSG(("Algo Id: %s ",AlgoIdEnum2Char[psNodeCfg->eAlgoId]));

        BDBG_MSG(("\neCollectResidual : %s ",DisableEnable[psNodeCfg->eCollectResidual]));
        /*BDBG_ERR(("Algo Id: %x ",psNodeCfg->eAlgoId));*/

        /*  Code Address and Size */
        BDBG_MSG(("DRAM Code Buffer Address: 0x%x ",
            psNodeCfg->sDramAlgoCodeBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Code Buffer Size: %d Bytes",
            psNodeCfg->sDramAlgoCodeBuffer.ui32BufferSizeInBytes));

        /*  Lookup Table Address and Size */
        BDBG_MSG(("DRAM Lookup Table Buffer Address: 0x%x ",
            psNodeCfg->sDramLookupTablesBuffer.ui32DramBufferAddress));
        BDBG_MSG(("DRAM Lookup Table Buffer Size: %d Bytes",
            psNodeCfg->sDramLookupTablesBuffer.ui32BufferSizeInBytes));

        /*  Inter-frame buffer Address check */
        if( psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Not present for this Node"));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Inter-Frame Buffer Address: 0x%x ",
                psNodeCfg->sDramInterFrameBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Inter-Frame Buffer Size: %d Bytes",
                psNodeCfg->sDramInterFrameBuffer.ui32BufferSizeInBytes));
        }

        /*  Node Status buffer Address check */
        if( psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM Node Status buffer Not present for this Node"));
            BDBG_MSG(("DRAM Node Status buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM Node Status buffer Address: 0x%x ",
                psNodeCfg->sDramStatusBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM Node Status buffer Size: %d Bytes",
                psNodeCfg->sDramStatusBuffer.ui32BufferSizeInBytes));
        }

        /*  User config buffer Address check */
        if( psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress ==
                BDSP_AF_P_DRAM_ADDR_INVALID )
        {
            BDBG_MSG(("DRAM User Config Buffer not present for this Node"));
            BDBG_MSG(("DRAM User Config Buffer Size: 0 Bytes"));
        }
        else
        {
            BDBG_MSG(("DRAM User Config Buffer Address: 0x%x ",
                psNodeCfg->sDramUserConfigBuffer.ui32DramBufferAddress));
            BDBG_MSG(("DRAM User Config Buffer Size: %d Bytes",
                psNodeCfg->sDramUserConfigBuffer.ui32BufferSizeInBytes));
        }

        /*  Input buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Input Configuration Details:", ui32Node));
        BDBG_MSG(("Num Source feeding data to this node: %d", psNodeCfg->ui32NumSrc));
        for( ui32NumSrc=0; ui32NumSrc<psNodeCfg->ui32NumSrc; ui32NumSrc++)
        {
            BDBG_MSG(("Source %d Input Buffer Cfg Structure Address: 0x%x",
                ui32NumSrc, psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG
            /*BDBG_MSG(("Input buffer Configuration:"));*/
            if(psNodeCfg->eNodeIpValidFlag[ui32NumSrc] == BDSP_AF_P_eValid)
            {
                /* Getting the Virtual Address */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeIpBuffCfgAddr[ui32NumSrc],
                    (void *)&sIoBuffer,
                    (uint32_t) SIZEOF(BDSP_AF_P_sIO_BUFFER));

#endif
                BDBG_MSG(("Source %d Input Generic Buffer Cfg Structure Address: 0x%x",
                    ui32NumSrc, psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc]));

#ifdef ANALYZE_IO_CFG

                /* BDBG_MSG(("Input Generic buffer Configuration:")); */
                /* Getting the Virtual Address */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeIpGenericDataBuffCfgAddr[ui32NumSrc],
                    (void *)&sIoGenericBuffer,
                    (uint32_t) SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

            }
#endif
        }

        /*  Output buffer configuration details */
        BDBG_MSG(("--"));
        BDBG_MSG(("Node %d Output Configuration Details:", ui32Node));
        BDBG_MSG(("Num Destination getting data from this node: %d",
            psNodeCfg->ui32NumDst));
        for( ui32NumDest=0; ui32NumDest<psNodeCfg->ui32NumDst; ui32NumDest++)
        {

            /* IO BUFFER CONFIGURATION */
            /*-------------------------*/

            /*Printing Output Buffer Cfg Structure Address */
            BDBG_MSG(("Destination %d Output Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest]));

#ifdef ANALYZE_IO_CFG
            /* BDBG_MSG(("Output buffer Configuration:"));*/

            if(0 != psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest])
            {
                /* Getting contents of the Destination IO buffer */
                /* Getting the Virtual Address */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeOpBuffCfgAddr[ui32NumDest],
                    (void *)&sIoBuffer,
                    (uint32_t) SIZEOF(BDSP_AF_P_sIO_BUFFER));

                /*Printing Buffer Type*/
                if(sIoBuffer.ui32NumBuffers >0)
                {
                    BDBG_MSG(("Destination %d Output Buffer Type: %s",
                    ui32NumDest, BuffTypeEnum2Char[sIoBuffer.eBufferType]));
                }


                /*  Print Io Buff Struct */
                /* BDSP_CITGEN_P_AnalyzeIoBuffCfgStruct(&sIoBuffer); */
            }
#endif


            /* IOGENERIC BUFFER CONFIGURATION */
            /*--------------------------------*/

            BDBG_MSG(("Destination %d Output Generic Buffer Cfg Structure Address: 0x%x",
                ui32NumDest, psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest]));


#ifdef ANALYZE_IO_CFG

            /*  Getting contents of the IO Generic buffer */
            if(0 != psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest])
            {
                /*Getting the Virtual Address */
                BDSP_P_ReadFromOffset(hHeap,
                    psNodeCfg->ui32NodeOpGenericDataBuffCfgAddr[ui32NumDest],
                    (void *)&sIoGenericBuffer,
                    (uint32_t) SIZEOF(BDSP_AF_P_sIO_GENERIC_BUFFER));

                /*Printing Buffer Type*/
                if(sIoGenericBuffer.ui32NumBuffers >0)
                {
                    BDBG_MSG(("Destination %d Output Generic Buffer Type: %s",
                    ui32NumDest, BuffTypeEnum2Char[sIoGenericBuffer.eBufferType]));
                }

                /*  Analyze Io Genric Buff Struct */
                /* BDSP_CITGEN_P_AnalyzeIoGenericBuffCfgStruct(&sIoGenericBuffer); */
            }
#endif

#ifdef BDSP_CIT_P_ENABLE_FORK_MATRIXING

            BDBG_MSG(("Destination %d Datatype : %s",
                ui32NumDest, PortDatatType[psNodeCfg->eNodeOpBuffDataType[ui32NumDest]]));

            BDBG_MSG(("--"));
#endif
        }
        BDBG_MSG(("============================= "));
    }
}
