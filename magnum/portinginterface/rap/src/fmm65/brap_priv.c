/***************************************************************************
*     Copyright (c) 2004-2012, Broadcom Corporation
*     All Rights Reserved
*     Confidential Property of Broadcom Corporation
*
*  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
*  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
*  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
*
* $brcm_Workfile: $
* $brcm_Revision: $
* $brcm_Date: $
*
* Module Description:
*	This file contains the common APIs used internally by different 
*	modules of the Raptor Audio PI. 
*
* Revision History:
*
* $brcm_Log: $
* 
***************************************************************************/
#include "brap.h"
#include "brap_priv.h"

BDBG_MODULE(rap_priv);

/* For debugging Link Info */
#define BRAP_P_DBG_LINK_INFO 0
#define BRAP_P_STOP_TIMEOUT_COUNTER 30

/* This flag decides if we want FW to program the output PLL or not */
 

#define TRIWINDOW_WIDTH_SEL_VALUE 8
#define ADAPTIVE_RATE_THRESHOLD_VALUE 0xFFFF



/***************************************************************************
Summary:
    Private function that updates the already allocated output and spdiffm 
    ids in the resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_UpdateOpResrcGrant(
    BRAP_ChannelHandle      hRapCh,         /* [in] Raptor channel handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    );

/***************************************************************************
Summary:
    Private function that resets/removes output port and spdiffm ids from the
    resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_ResetOpResrcGrant(
    BRAP_Handle             hRap,           /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    );


/***************************************************************************
Summary:
    A Destination Group is the number of destinations associated with one 
    output mode. For example if for one RAP Channel there are three stereo 
    outputs, then each of these output ports constitute one destination group. 
****************************************************************************/    
typedef struct BRAP_P_DstGrpDetails
{
    bool                bInputMixingLvlOnly;
    BRAP_OutputMode     eAudioMode;     /* Audio Mode for this output group */
    bool                bLfeOn;         /* Whether LFE exists for this output 
                                           group */
    BAVC_AudioSamplingRate   eSamplingRate;  /* Sampling rate */
    BRAP_DstDetails     *pDstDetails;   /* Pointer to dst details. This 
                                           is valid only if a particular
                                           Mixing Level feeds to a destination 
                                           directly. It is NULL if a mixing 
                                           level doesn't feed to some 
                                           destination directly */
    BRAP_P_InternalDst  *pIntDstDetails;/* Pointer to internal destination as
                                           Internal capture port */
}BRAP_P_DstGrpDetails;

static const 
BRAP_P_DstGrpDetails sDstGrpInvalid = {
    false,                              /* bInputMixingLvlOnly */
    BRAP_OutputMode_eLast,              /* eAudioMode */
    false,                              /* bLfeOn */
    BAVC_AudioSamplingRate_eUnknown,    /* eSamplingRate */
    NULL,                               /* pDstDetails */
    NULL                                /* pIntDstDetails */
};

#define BRAP_P_MAX_OUTPUT_CONFIGS   8
#if (BRAP_3548_FAMILY == 1)
/* This is a workaround to support ADC with 6 destinations 
The extra internal capture port for sampling rate conversion reasons
adds up to the usual destinations in MixerSrcRescLayout giving 7.
This needs to be fixed later and when that is done we need to make
#define BRAP_P_MAX_CLONES           as 6
*/
#define BRAP_P_MAX_CLONES           7
#else
#define BRAP_P_MAX_CLONES           4
#endif

static const 
BRAP_P_MixingLevelProp  sMixingLevelPropInvalid = {
    BAVC_AudioSamplingRate_eUnknown,    /* InputSR */
    BAVC_AudioSamplingRate_eUnknown,    /* OutputSR */
    BRAP_OutputMode_eLast,              /* Input Aud Mode */
    false,                              /* bInputLfeOn */
    BRAP_OutputMode_eLast,              /* Output Aud Mode */
    false,                              /* bOutputLfeOn */
    {NULL,                              /* pDstDetails[0] */
    NULL},                              /* pDstDetails[1] */
    {NULL,                              /* pIntDstDetails[0] */
    NULL}                               /* pIntDstDetails[1] */
 };


static const BRAP_P_OpAudModProp sOutputAudModeProp[BRAP_OutputMode_eLast] = 
{/*|ChNo|ChBits| L    | R   | Ls   | Rs   | C    | Lfe  | Lb   | Rb  | */   
    {1,  0x80, {true, false, false, false, false, false, false, false}},/*1_0*/
    {0,  0x00, {false, false, false, false, false, false, false, false}},/*XXX*/
    {0,  0x28, {false, false, true, false, true, false, false, false}},/*1_1 TODO */
    {2,  0xC0, {true, true, false, false, false, false, false, false}},/*2_0*/
    {3,  0xC8, {true, true, false, false, true, false, false, false}},/*3_0*/
    {3,  0xE0, {true, true, true, false, false, false, false, false}},/* 2_1 */
    {4,  0xE8, {true, true, true, false, true, false, false, false}},/* 3_1 */
    {4,  0xF0, {true, true, true, true, false, false, false, false}},/* 2_2 */
    {5,  0xF8, {true, true, true, true, true, false, false, false}},/* 3_2 */   
    {6,  0xFA, {true, true, true, true, true, false, true, false}},/* 3_3 */
    {7,  0xFB, {true, true, true, true, true, false, true, true}}/* 3_4 */
    /* TODO: Add more modes */
};


static const BRAP_P_InternalDst sInternalDst = {
    {
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax,
        BRAP_CapInputPort_eMax
    },
    BAVC_AudioSamplingRate_eUnknown,
    BRAP_OutputMode_eLast,
    false
};


/* BRAP_P_AlignAddress : Aligns the address to the specified bit position
 */
uint32_t BRAP_P_AlignAddress(
		uint32_t	ui32Address,	/* [in] size in bytes of block to allocate */
		uint32_t	uiAlignBits		/* [in] alignment for the block */
		)
{
	return (ui32Address+((1<<uiAlignBits)-1)) & ~((1<<uiAlignBits)-1) ;
}


/***************************************************************************
Summary: Gets the watchdog recovery flag 

Description:
	This function returns current status of watchdog recovery flag. This
	is required to know whether a function is getting called in watchdog
	context or from application.

Returns:
	Watchdog flag

See Also:
**************************************************************************/
bool BRAP_P_GetWatchdogRecoveryFlag(BRAP_Handle hRap)
{
	return hRap->bWatchdogRecoveryOn;
}

/* BRAP_P_AllocAligned : A wrapper around the BMEM module to 
 * include static memory allocation 
 */
#ifndef BRAP_MEM_DBG
void *BRAP_P_AllocAligned(
		BRAP_Handle  hRap,        /* [in] The RAP device handle */
		size_t       ulSize,      /* [in] size in bytes of block to allocate */
		unsigned int uiAlignBits, /* [in] alignment for the block */
		unsigned int uiBoundary   /* [in] boundary restricting allocated value */
		)
{
	uint32_t ui32_AllocMem ;
	uint32_t ui32_adjSize ;
	void *ptr;

#if (EMULATION==0)
	BSTD_UNUSED(ui32_AllocMem);
	BSTD_UNUSED(ui32_adjSize);

	ptr = BMEM_AllocAligned(
			hRap->hHeap, 
			ulSize, 
			uiAlignBits, 
			uiBoundary) ;
	BDBG_MSG(("Allocated Memory : %08lx, size %08lx", ptr, ulSize));
    

	hRap->uiTotalMemUsed+=ulSize;

	return (ptr == 0)? (void *)BRAP_P_INVALID_DRAM_ADDRESS : ptr ;

#else
	BSTD_UNUSED(uiBoundary);
	BSTD_UNUSED(ptr);

	ui32_adjSize = ulSize + (1<<uiAlignBits)-1 ;

	/* The simple static memory allocator works as follows :
	 * The running pointer always points to the starting address
	 * of the remaining and free portion of the static memory block.
	 */
	ui32_AllocMem = hRap->sMemAllocInfo.currentStaticMemoryPointer ;

	BDBG_MSG(("Current Mem Pointer = 0x%08x, Base = 0x%08x, Size = 0x%08x",
	hRap->sMemAllocInfo.currentStaticMemoryPointer,
	hRap->sMemAllocInfo.currentStaticMemoryBase,
	hRap->sMemAllocInfo.staticMemorySize));

	/* Point the running pointer to the end+1 of the current buffer *
	 * but first check if the static memory block is not exhausted */
	if( (hRap->sMemAllocInfo.currentStaticMemoryPointer+ulSize) > 
		(hRap->sMemAllocInfo.currentStaticMemoryBase +
		hRap->sMemAllocInfo.staticMemorySize) )
	{
		BDBG_ERR(("BRAP_P_AllocAligned : No more Static Memory available"));
		return (void *) BRAP_P_INVALID_DRAM_ADDRESS ;
	}

	/* Align the address to the specified Bit position */
	ui32_AllocMem = BRAP_P_AlignAddress(ui32_AllocMem, uiAlignBits) ;

	hRap->sMemAllocInfo.currentStaticMemoryPointer += ui32_adjSize;

	/* Set the memory that is allocate to zero, this is asure allocated memory is a known value */
	{
		uint32_t offset;
		
		for(offset = 0; offset <= ui32_adjSize; offset += 4)
		{
			/* may over the allocated buffer by upto 3 bytes, but this should be okay 
			   since the override will occur to unallocated memory, due to the simple
			   memory allocator that currently exist */
			BRAP_P_DRAMWRITE( (ui32_AllocMem + offset), 0x00);
		}
	}


	/* TODO : Add Boundary checks */

	hRap->uiTotalMemUsed+=ulSize;
	BDBG_MSG(("Allocated Memory : %08lx, size %08lx, prealigned = %08lx", ui32_AllocMem, ulSize,hRap->sMemAllocInfo.currentStaticMemoryPointer ));


	return (void *)ui32_AllocMem ;	
#endif
}
#endif

/* BRAP_P_Free : A wrapper around the BMEM module to free device memory.
 */
BERR_Code BRAP_P_Free(
		BRAP_Handle  hRap,        	/* [in] The RAP device handle */
		void *pMemPtr)			/* [in] Pointer to device memory to be freed */
{
	BERR_Code err = BERR_SUCCESS;
	BDBG_ASSERT(hRap);

    if((pMemPtr !=NULL) && (pMemPtr!=(void *)BRAP_P_INVALID_DRAM_ADDRESS))
    {
        BDBG_MSG(("BRAP_P_Free: Freeing pMemPtr = 0x%x",pMemPtr));
    	err = BMEM_Free(hRap->hHeap, pMemPtr);        
    }
	return err;
}

/* BRAP_P_ConvertAddressToOffset: Wrapper on BMEM function BMEM_ConvertAddressToOffset.
 * Since for 7411 chips, RAP PI doesn't get virtual pointer to device memory and access
 * device memory using physical address only, this function returns device offset equal
 * to virtual pointer to device memory for these chips. For all other chips it calls 
 * BMEM function BMEM_ConvertAddressToOffset for this conversion.
 */
BERR_Code BRAP_P_ConvertAddressToOffset(
	BMEM_Handle  Heap,    /* Heap that contains the memory block. */
	void        *pvAddress, /* Address of the memory block */
	uint32_t    *pulOffset)   /* [out] Returned device offset. */
{
	BERR_Code err = BERR_SUCCESS;
	
#if (EMULATION==0)
	err = BMEM_ConvertAddressToOffset(Heap, pvAddress, pulOffset);
#else
	BSTD_UNUSED(Heap);
	*pulOffset = (uint32_t) pvAddress;
#endif
	return err;
}

/* BRAP_P_ConvertOffsetToAddress: Wrapper on BMEM function BMEM_ConvertOffsetToAddress.
 */
BERR_Code BRAP_ConvertOffsetToAddress
(
	BMEM_Handle   hHeap,    /* Heap that contains the memory block */
	uint32_t      ulOffset,  /* Device offset within the heap. */
	void        **ppvAddress)  /* [out] Returned address. */
{
	BERR_Code err = BERR_SUCCESS;
	
	err = BMEM_ConvertOffsetToAddress(hHeap, ulOffset, ppvAddress);

	return err;
}

BERR_Code BRAP_P_CopyDataToDram(BMEM_Handle hHeap,
                                    uint32_t *data,
									uint32_t memAdr,
									uint32_t size)
{
    void *dest=NULL;
    BERR_Code    ret=BERR_SUCCESS;
    if (data==NULL) {
            ret = BMEM_Heap_ConvertAddressToCached(hHeap,(void *) memAdr,(void **) &dest);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_ConvertAddressToCached returned Error %d",ret));
                return BERR_TRACE(ret);
            }            
            BKNI_Memset(dest, 0, size);
            ret = BMEM_Heap_FlushCache(hHeap,(void *)dest,size);      
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_FlushCache returned Error %d",ret));
                return BERR_TRACE(ret);
            }            
            
    }
    else {
            ret = BMEM_Heap_ConvertAddressToCached(hHeap,(void *) memAdr,(void **) &dest);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_ConvertAddressToCached returned Error %d",ret));
                return BERR_TRACE(ret);
            }                        
            BKNI_Memcpy(dest, data , size);
            ret = BMEM_Heap_FlushCache(hHeap,(void *)dest,size);
            if (ret!=BERR_SUCCESS)
             {
                BDBG_ERR(("BMEM_Heap_FlushCache returned Error %d",ret));
                return BERR_TRACE(ret);
            }                
    }
    return ret;
}

#ifndef EMULATION
void BRAP_MemWrite32(
					uint32_t	offset, /* Memory offset to write */
					uint32_t	data   /* Data to write */
					)
{
	*((volatile uint32_t *)offset) = data;
}

void BRAP_MemWrite32_isr(
					uint32_t	offset, /* Memory offset to write */
					uint32_t	data   /* Data to write */
					)
{
	*((volatile uint32_t *)offset) = data;
}

void BRAP_MemWrite8(
					uint32_t	offset, /* Memory offset to write */
					uint8_t	data   /* Data to write */
					)
{
	*((volatile uint8_t *)offset) = data;
}

uint32_t BRAP_MemRead32(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint32_t ui32ValRead;

	ui32ValRead = *((volatile uint32_t *)offset);
	return ui32ValRead;
}

uint32_t BRAP_MemRead32_isr(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint32_t ui32ValRead;

	ui32ValRead = *((volatile uint32_t *)offset);
	return ui32ValRead;
}

uint8_t BRAP_MemRead8(
						uint32_t	offset /* Memory offset to write */
					   )
{
	uint8_t ui8ValRead;

	ui8ValRead = *((volatile uint8_t *)offset);

	return ui8ValRead;

}

void BRAP_DSP_Write32(BREG_Handle hReg,
					uint32_t		offset,
					uint32_t		data,
					bool			bIsrCxt)
{
	if (bIsrCxt)
        {
		BRAP_Write32_isr(hReg, offset, data);
        }
	else
    {
		BRAP_Write32(hReg, offset, data);
}
}

uint32_t BRAP_DSP_Read32(BREG_Handle hReg,
					uint32_t		offset,
					bool			bIsrCxt)
{
	uint32_t regVal;

	if(bIsrCxt)
		regVal = BRAP_Read32_isr(hReg, offset);
	else
		regVal = BRAP_Read32(hReg, offset);

	return regVal;
}

#endif /* EMULATION */

/**************************************************************************
Summary:
    Private function that outputs true if (eAudioMode2, bLfeOn2) is greater
    than (eAudioMode1, bLfeOn1) else it outputs false in pMatched.
**************************************************************************/
BERR_Code
BRAP_P_IsAudModeGreater(
	BRAP_OutputMode 	eAudioMode1, 
	bool 			    bLfeOn1,
	BRAP_OutputMode 	eAudioMode2, 
	bool 			    bLfeOn2,
	bool                *pMatched)
{
    BRAP_P_OpAudModProp sOpModeProp1, sOpModeProp2;
    BERR_Code           ret = BERR_SUCCESS;

    BDBG_ASSERT(pMatched);

    *pMatched = false;

    BDBG_MSG(("BRAP_P_IsAudModeGreater: (opMode, lfe)1 = (%d,%d)",
        eAudioMode1, bLfeOn1));
    BDBG_MSG(("BRAP_P_IsAudModeGreater: (opMode, lfe)2 = (%d,%d)",
        eAudioMode2, bLfeOn2));

    /* Initialization to bypass compiler warnings */
    sOpModeProp1.ui8ChanBits = 0;
    sOpModeProp2.ui8ChanBits = 0;
    
    ret = BRAP_P_GetAudOpModeProp(eAudioMode1, bLfeOn1, &sOpModeProp1);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("BRAP_P_IsAudModeGreater: GetAudOpModeProp returned %d",ret));
        return BERR_TRACE(ret);
    }

    ret = BRAP_P_GetAudOpModeProp(eAudioMode2, bLfeOn2, &sOpModeProp2);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("BRAP_P_IsAudModeGreater: GetAudOpModeProp returned %d",ret));
        return BERR_TRACE(ret);
    }
    if(sOpModeProp2.ui8ChanBits == sOpModeProp1.ui8ChanBits)
    {
        *pMatched = false;
    }
    else
    {
        /* Logic: if (bitMap1 OR bitMap2) XOR bitMap1 is 0 then bitMap1 is a 
           superset of bitMap2 */
        if((sOpModeProp2.ui8ChanBits | sOpModeProp1.ui8ChanBits) 
            ^ sOpModeProp2.ui8ChanBits)
        {
            *pMatched = false;
        }
        else
        {
            *pMatched = true;
        }
    }

    return ret;
}

/* This function returns number of SRCs required in cascade.
    Valid values: 1 & 2.
    Invalid or error : 0 */    
unsigned int 
BRAP_P_NumSrcReqdInCascade(
    BAVC_AudioSamplingRate eInputSR, 
    BAVC_AudioSamplingRate eOutputSR
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiInSr = 0, uiOutSr = 0, uiNumSRCs = 0;

    BDBG_MSG(("BRAP_P_NumSrcReqdInCascade: eInputSR = %d, eOutputSR = %d",
            eInputSR, eOutputSR));

    ret = BRAP_P_ConvertSR(eInputSR, &uiInSr);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        return 0;
    }
    
    ret = BRAP_P_ConvertSR(eOutputSR, &uiOutSr);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        return 0;    
    }    

    if(uiInSr >= uiOutSr)
    {
        if(2>(uiInSr / uiOutSr))
        {
            uiNumSRCs = 1;
        }
        else if((2== (uiInSr / uiOutSr))&& (0==(uiInSr % uiOutSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((2== (uiInSr / uiOutSr))&& (0!=(uiInSr % uiOutSr)))||
                ((2<(uiInSr / uiOutSr)) && (4 > (uiInSr / uiOutSr))))
        {
            uiNumSRCs = 2;
        }
        else if((4 == (uiInSr / uiOutSr))&& (0==(uiInSr % uiOutSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((4 == (uiInSr / uiOutSr))&& (0!=(uiInSr % uiOutSr)))||
                (4 < (uiInSr / uiOutSr)))
        {
            uiNumSRCs = 2;
        }

    }
    else
    {
        if(2>(uiOutSr / uiInSr))
        {
            uiNumSRCs = 1;
        }
        else if((2== (uiOutSr / uiInSr)) && (0==(uiOutSr % uiInSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((2== (uiOutSr / uiInSr)) && (0!=(uiOutSr % uiInSr)))||
                ((2<(uiOutSr / uiInSr)) && (4 > (uiOutSr / uiInSr))))
        {
            uiNumSRCs = 2;
        }
        else if((4 == (uiOutSr / uiInSr))&& (0==(uiOutSr % uiInSr)))
        {
            uiNumSRCs = 1;
        }
        else if(((4 == (uiOutSr / uiInSr))&& (0!=(uiOutSr % uiInSr)))||
                (4 < (uiOutSr / uiInSr)))
        {
            uiNumSRCs = 2;
        }
   }

    /* Assert if number of SRCs required in cascade is more than 2 */
    if(uiNumSRCs > 2)
    {
        BDBG_ERR(("uiInSR = %d uiOutSR = %d, uiNumSRCs = %d",
            uiInSr, uiOutSr, uiNumSRCs));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        return 0;
    }
    
    return uiNumSRCs;
}
                                       
/* Return TRUE, if douwnmixing is required, return FALSE if downmixing is 
   required, ASSERT, if Upmixing is required since it is not supported */
BERR_Code BRAP_P_DecideDwnMixing(BRAP_OutputMode eInputAudMode,
                            bool bInLfeOn,
                            BRAP_OutputMode eOutputAudMode,
                            bool bOutLfeOn,
                            bool *pbDownMix)
{
    BERR_Code   ret = BERR_SUCCESS;
    bool        bModeMatched = false;

    BDBG_MSG(("OutputAudMode %d  InputAudMode %d InputLFE %d outputLFE %d",
                eOutputAudMode,eInputAudMode,bInLfeOn,bOutLfeOn));

    
    *pbDownMix = false;

    ret = BRAP_P_IsAudModeGreater(eInputAudMode,bInLfeOn, eOutputAudMode, bOutLfeOn,
                                       &bModeMatched);
    if(BERR_SUCCESS != ret)    
    {
        return BERR_TRACE(ret);
    }
    
    if(true == bModeMatched)
    {
        if((eInputAudMode == eOutputAudMode)&&(bInLfeOn == bOutLfeOn))
        {
            *pbDownMix = false;
        }
        else
        {
            BDBG_ERR(("OutputAudMode %d is greate than InputAudMode %d",
                                                eOutputAudMode,eInputAudMode));
            BDBG_ASSERT(0);
        }
    }
    else
    {
        if((eInputAudMode == eOutputAudMode)&&(bInLfeOn == bOutLfeOn))
        {
            *pbDownMix = false;
        }
        else
        {
            *pbDownMix = true;
        }
    }        
    BDBG_MSG(("pbDownMix %d",*pbDownMix));
    return ret;
}

BERR_Code BRAP_P_GetSharedAssociation(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbShareAssoc
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;
    bool            flag=false;
    BDBG_ENTER(BRAP_P_GetSharedAssociation);

    for(j = 0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
        {
            continue;
        }
        
        flag=false;
        uiAssocId = hRapCh->uiAssociationId[j];
        for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
            if((hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL)&&
               (hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != hRapCh)) 
            {
                pbShareAssoc[uiAssocId] = true;
                flag=true;
                break;
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL)&&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != hRapCh)) 
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL)&&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i] != hRapCh))
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        if(flag == false)
        {
            for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
            {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL)&&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i] != hRapCh))
                {
                    pbShareAssoc[uiAssocId] = true;
                    flag=true;
                    break;
                }
            }
        }
        
    }
    
    BDBG_LEAVE(BRAP_P_GetSharedAssociation);
    return ret;
}

BERR_Code BRAP_P_GetStartedChannel(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbPrimaryPresent,
    BRAP_ChannelHandle      *phStrtdAssocCh
)
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;

    BDBG_ENTER(BRAP_P_GetStartedChannel);
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
    /* Check if any of the channels in the channel group which contains the 
       current channel, has been started */
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
        {
            continue;
        }
        uiAssocId = hRapCh->uiAssociationId[j];
    for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
            if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL) 
        {
                if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i]->eState == BRAP_P_State_eStarted)
            {
                pbPrimaryPresent[uiAssocId] = true;            
                /* Primary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPriDecCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is primary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL) &&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Secondary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hSecDecCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is Secodary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Sound effect channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPBCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is PB=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i]->eState == BRAP_P_State_eStarted))
            {
                /* Capture channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hCapCh[i];
                    BDBG_MSG(("BRAP_P_GetStartedChannel: Channel started for Association=%d is Capture=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
        {
            BDBG_MSG(("BRAP_P_GetStartedChannel: No Channel is started for Association=%d ",uiAssocId));
        }
    }

    BDBG_LEAVE(BRAP_P_GetStartedChannel);
    return ret;
}

BERR_Code BRAP_P_GetOtherStartedChannel(
    BRAP_ChannelHandle      hRapCh,
    bool                    *pbPrimaryPresent,
    BRAP_ChannelHandle      *phStrtdAssocCh
)
{
    BERR_Code       ret = BERR_SUCCESS;
    BRAP_Handle     hRap = hRapCh->hRap;
    unsigned int    i=0,uiAssocId=0,j=0;

    BDBG_ENTER(BRAP_P_GetOtherStartedChannel);
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
    {
        uiAssocId = j;
    for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
            if((hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL) 
                &&(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != hRapCh))
        {
                pbPrimaryPresent[uiAssocId] = true;
                if(hRap->sAssociatedCh[uiAssocId].hPriDecCh[i]->eState == BRAP_P_State_eStarted)
            {
                /* Primary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPriDecCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is primary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if((hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]!= NULL) &&
                   (hRap->sAssociatedCh[uiAssocId].hSecDecCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != hRapCh))
            {
                /* Secondary has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hSecDecCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is Secodary=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hPBCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hPBCh[i] != hRapCh))
                    
            {
                /* Sound effect channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hPBCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is PB=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if( NULL == phStrtdAssocCh[uiAssocId])
    {
        for (i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
        {
                if ((hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL) &&
                    (hRap->sAssociatedCh[uiAssocId].hCapCh[i]->eState == BRAP_P_State_eStarted)
                    &&(hRap->sAssociatedCh[uiAssocId].hCapCh[i] != hRapCh))                    
            {
                /* Capture channel has been started */
                    phStrtdAssocCh[uiAssocId] = hRap->sAssociatedCh[uiAssocId].hCapCh[i];
                    BDBG_MSG(("BRAP_P_GetOtherStartedChannel: Channel started for Association=%d is Capture=%x",
                        uiAssocId,phStrtdAssocCh[uiAssocId]));
                break;
            }
        }
    }
        if(NULL == phStrtdAssocCh[uiAssocId])
        {
            BDBG_MSG(("BRAP_P_GetOtherStartedChannel: No Channel is started for Association=%d ",uiAssocId));
        }
    }

    BDBG_LEAVE(BRAP_P_GetOtherStartedChannel);
    return ret;
}

static BERR_Code 
BRAP_P_FormAndSortDestGrp(
    BRAP_ChannelHandle      hRapCh,
    unsigned int            uiPth,
    BRAP_P_DstGrpDetails    *pDstGrp,
    bool                    bSetTopDecCh,
    BRAP_P_InternalDst      *pIntDst,
    unsigned int            *puiMaxDstGrp,
    bool                    bPrimaryPresent,
    unsigned int            uiAssocId
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            dst = 0, m = 0, n = 0, chp = 0;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
	unsigned int            uiNumDstGrp = 0;
    unsigned int            uiNumIntDstGrp = 0;
    unsigned int            uiNumTotalDst = 0;
    unsigned int            uiMaxDstGrp = 0;
    bool                    bInputMixingOnlyLvlReqd = true;
    BRAP_P_DstGrpDetails    sTempDstGrp;
    bool                    bModeMatched = false;
    unsigned int            uiSRn =0, uiSRm = 0;
    unsigned int                     i=0;
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT    
    BRAP_OutputPort         eOutputOrder[5] = {BRAP_OutputPort_eI2s4, BRAP_OutputPort_eDac0, BRAP_OutputPort_eDac1, BRAP_OutputPort_eDac2, BRAP_OutputPort_eSpdif};
    BRAP_DstDetails         *pTempDstDetails = NULL;
#endif    
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS]={false,false,false,false};
    BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS] ={NULL,NULL,NULL,NULL};  
    BDBG_ENTER(BRAP_P_FormAndSortDestGrp);



#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
    /* We sort the destinatinos such that the output port with more mixers is first and with the least at the last.
    This is to ensure smooth flow in Mixer allocation for CustomRequirment */  
    for (i=0; i<5; i++)
    {
        for (dst=0; dst<BRAP_P_MAX_DST_PER_RAPCH; dst++)
        {
            if((NULL == hRapCh->pPath[uiPth]) || (NULL == hRapCh->pPath[uiPth]->pDstDetails[dst]))
            {
                continue;
            }

            if (eOutputOrder[i] == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
            {
                pTempDstDetails = hRapCh->pPath[uiPth]->pDstDetails[dst];
                hRapCh->pPath[uiPth]->pDstDetails[dst] = hRapCh->pPath[uiPth]->pDstDetails[i];
                hRapCh->pPath[uiPth]->pDstDetails[i] = pTempDstDetails;
            }
        }
    
    }

#endif

    /* Form the Destination Group Array */
    for(dst=0, uiNumDstGrp=0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
    {
        if((NULL == hRapCh->pPath[uiPth]) || 
                               (NULL == hRapCh->pPath[uiPth]->pDstDetails[dst]))
        {
            continue;
        }

        BDBG_MSG(("BRAP_P_FormAndSortDestGrp: dst = %d,"
                  " hRapCh->pPath[%d]->pDstDetails[dst]->eAudioDst = %d", dst,
                  uiPth, hRapCh->pPath[uiPth]->pDstDetails[dst]->eAudioDst));

        switch(hRapCh->pPath[uiPth]->pDstDetails[dst]->eAudioDst)
        {
            case BRAP_AudioDst_eOutputPort:

#if BRAP_P_MAI_NEEDS_MUX_SELECTOR
            /* Mai can't be fed directly in 7440 A0 / 3563 A0 */
            if(BRAP_OutputPort_eMai == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
            {
                continue;
            }
#else            
            if((((BRAP_OutputPort_eMai == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
                 &&(((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)
                   ||(BRAP_P_UsgPath_ePPBranch== hRapCh->pPath[uiPth]->eUsgPath)
                   ||(BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath)))
                   &&(BRAP_OutputPort_eMai != hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiMultiSettings.eMaiMuxSelector))
               ||((BRAP_OutputPort_eSpdif== hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR])
                 &&(((BRAP_P_UsgPath_eDecodeCompress== hRapCh->pPath[uiPth]->eUsgPath)
                     ||(BRAP_P_UsgPath_ePPBranch== hRapCh->pPath[uiPth]->eUsgPath)
                     ||(BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath))
                     &&(true== hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bCompressed))))
                 &&(BRAP_OutputMode_e3_2 == hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eAudioMode))
            {
                continue;
            }
#endif 
            pDstGrp[uiNumDstGrp].eAudioMode = 
                hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eAudioMode;
            pDstGrp[uiNumDstGrp].bLfeOn = 
                hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.bLfeOn;
            pDstGrp[uiNumDstGrp].pDstDetails = hRapCh->pPath[uiPth]->pDstDetails[dst];
            
            ret = BRAP_P_GetAudOpModeProp(pDstGrp[uiNumDstGrp].eAudioMode, 
                                          pDstGrp[uiNumDstGrp].bLfeOn,
                                          &sCurOpAudModeProp);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                return BERR_TRACE(ret);
            }

            for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
	        {
                if((sCurOpAudModeProp.bChnExists[chp*2] == true) ||
                   (sCurOpAudModeProp.bChnExists[(chp*2)+1] == true))
                {
                    /* Make sure that there is a valid port for this channel 
                       pair */
                    eOp = hRapCh->pPath[uiPth]->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[chp]; 
                    if(eOp >= BRAP_OutputPort_eMax)
                    {
                        BDBG_ERR(("pDstDetails[%d].sOpDetails.eOutput[%d] = %d",
                            dst,chp,eOp));
                        return BERR_TRACE(BERR_NOT_INITIALIZED);
                    }                   

                    /* Get its sampling rate */
                    if(false == bSetTopDecCh)
                    {
                        if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                        {
                        pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
                        }
                        else
                        {
                            ret = BRAP_P_GetStartedChannel(hRapCh,bPrimary,hStrtdAssocCh);
                            if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_GetStartedChannel returnrd error"));
                                return BERR_TRACE(ret);
                            }                            
                            if((hStrtdAssocCh[uiAssocId] != NULL)
                                &&(true == bPrimary[uiAssocId])
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bGateOpened == true))
                            {
                                pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eSamplingRate;
                            }
                            else
                            {
                                pDstGrp[uiNumDstGrp].eSamplingRate = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
                            }
                        }
                    }
                    else
                    {
                        pDstGrp[uiNumDstGrp].eSamplingRate = BAVC_AudioSamplingRate_eUnknown;
                    }
                }
            }    
			uiNumDstGrp++;
            break;
            case BRAP_AudioDst_eRingBuffer:
    /*		pDstGrp[dst].eAudioMode = BRAP_OutputMode_e2_0;
    		pDstGrp[dst].bLfeOn = false;
    		pDstGrp[dst].eSamplingRate = BAVC_AudioSamplingRate_e48k;
    		pDstGrp[dst].pDstDetails = &(hRapCh->pPath[uiPth]->pDstDetails[dst]);
    		uiNumDstGrp++;*/
    		continue;
    		break;
            default:
            /* TODO: Return not supported */
            break;
        }/* switch */
    }/* for dst */
    /* Internal destination (i.e. capture path) is present. 
       So add this information to the Destination Group Array also */
    for(i =0 ; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if(hRapCh->pPath[uiPth]->pDstDetails[i] != NULL)
        {
            if(hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                break;
        }
    }
    if((i < BRAP_P_MAX_DST_PER_RAPCH) ||
         /* Capture path for Post-Mixing */
       (((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath) ||
         (BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth]->eUsgPath))&&
        (BRAP_P_IsAssociationNWValid(&(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[0])))))
    {
        for(dst = 0; dst < BRAP_RM_P_MAX_INTERNAL_DST; dst++)
        {
            /* Here, we cannot take a decision based on the eCapPort as eCapPort has
               not been allocated and pIntDst[dst]eCapPort[] still points to invalid
               value. This is because we are still in the resource request preparation
               stage. But, we can definitely check for eInputAudMode to check if an
               internal destination is required or not. */
            if(pIntDst[dst].eInputAudMode != BRAP_OutputMode_eLast)
            {
                BDBG_MSG(("Found the Internal Destination uiNumDstGrp + dst = %d",
                    uiNumDstGrp + dst));
                pDstGrp[uiNumDstGrp + dst].eAudioMode = pIntDst[dst].eInputAudMode;
                pDstGrp[uiNumDstGrp + dst].pIntDstDetails = &(pIntDst[dst]);
                pDstGrp[uiNumDstGrp + dst].bLfeOn = pIntDst[dst].bLfeOn;
                
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
                /*ToDo: This code is causing O/P port+capture to fail when Independent delay is disabled. Check it. */
                if(false == bSetTopDecCh)
                {
                    pDstGrp[uiNumDstGrp + dst].eSamplingRate = pIntDst[dst].eInputSR;            
                }
                else
                {
                    pDstGrp[uiNumDstGrp + dst].eSamplingRate =  BAVC_AudioSamplingRate_eUnknown;
                }
#else
                pDstGrp[uiNumDstGrp + dst].eSamplingRate = pIntDst[dst].eInputSR;
#endif            
                uiNumIntDstGrp++;
            }
        }
    }

    uiNumTotalDst = uiNumDstGrp + uiNumIntDstGrp;
	BDBG_MSG(("uiNumTotalDst = %d, uiNumDstGrp =%d, uiNumIntDstGrp = %d",
               uiNumTotalDst,uiNumDstGrp,uiNumIntDstGrp));

	/* We do not need the input mixing level in any path other than Decode PCM*/
    if((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)	
        &&(hRapCh->eChannelType == BRAP_ChannelType_eDecode))/* Assuming that PCM Capture and PCM playback will always be stereo*/
    {

        /* Check if the audio mode is same as the input audio mode. If so,
           extra stage for input mixing only is not required. */
        for(dst = 0; dst < uiNumTotalDst; dst++)
        {        
            /* If Primary is present in the association, consider its input mode */
            if ((true == bPrimaryPresent)&&
                (BRAP_P_State_eStarted == hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eState))
            {
                if((pDstGrp[dst].eAudioMode == 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eInputAudMode) && 
                   (pDstGrp[dst].bLfeOn == 
                   hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bInputLfeOn)

                    )
                {
                    bInputMixingOnlyLvlReqd = false;
                    break;
                }
                else
                {
                    bInputMixingOnlyLvlReqd = true;
                }
            }
            /* Else take current channels input mode */
            else
            {
                if((pDstGrp[dst].eAudioMode == hRapCh->eInputAudMode)/* && 
                   (pDstGrp[dst].bLfeOn == hRapCh->bInputLfeOn)*/
                   )
                {
                    bInputMixingOnlyLvlReqd = false;
                    break;
                }
                else
                {
                    if((BRAP_P_IsAssociationNWValid(&(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[0])))
                       || ((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                        &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                        ||((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                        &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                        &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)))
                    {
                        bInputMixingOnlyLvlReqd = false;
                        break;
                    }
                    else
                    {
                        bInputMixingOnlyLvlReqd = true;
    			    }
    			}
            }
        }
    }
    else
    {
        bInputMixingOnlyLvlReqd = false;
    }
	BDBG_MSG(("bInputMixingOnlyLvlReqd = %d", bInputMixingOnlyLvlReqd));

    /* If none of the destinations have audio mode same as the input audio mode, 
       then we need to add the first entry in pDstGrp corresponding to the input 
       audio mode. It is done because in this case, there is requirement of a 
       level where mixing of primary decode, secondary decode and sound effect 
       channels has to happen then it should be downmixed to result the output 
       audio modes required. Add this stage at the end of the array first. In 
       the next step bring this stage to the first entry */
    if(true == bInputMixingOnlyLvlReqd)
    {
        /* As we are going to introduce a dummy dst group, check if 
           this can be accomodated */
        if(uiNumTotalDst >= (BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST))
        {
            BDBG_ERR(("No space available for adding a dummy destination grp"));
            return BERR_TRACE(BERR_NOT_SUPPORTED);
        }
            
        /* Prepare pDstGrp to hold dummy mixing level with no immediate dest */ 
        uiMaxDstGrp = uiNumTotalDst + 1;
        pDstGrp[uiNumTotalDst].bInputMixingLvlOnly = true;
        pDstGrp[uiNumTotalDst].pDstDetails = NULL;
        pDstGrp[uiNumTotalDst].pIntDstDetails = NULL;
            
        /* Sampling rate of the primary channel in the channel group should be 
           the sampling rate of this stage */
        /* TODO: It should be unified SR */

        if(hRapCh->eChannelSubType == BRAP_ChannelSubType_ePrimary)
        {
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));            
        }
        else if(true == bSetTopDecCh) 
        {
            /* Decode channel for Set Top Platform. 
               Mark the Sampling rate as invalid */
            pDstGrp[uiNumTotalDst].eSamplingRate = BAVC_AudioSamplingRate_eUnknown;
        }
        else if(NULL == 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0])
        {
            /* Primary channel doesn't exist for this group. This must be a 
               playback channel for Set Top Application. Mark the input sampling 
               rate as the sampling rate of this stage */
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));                        
        }
        else if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eState 
                == BRAP_P_State_eStarted)
        {
            /* Take the sampling rate of the primary channel in the group, 
               if started */
            pDstGrp[uiNumTotalDst].eSamplingRate 
                = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eSamplingRate;
        }
        else
        {
            BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&(pDstGrp[uiNumTotalDst].eSamplingRate));                                
        }

        if (true == bPrimaryPresent)
        {
             pDstGrp[uiNumTotalDst].eAudioMode = 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->eInputAudMode;
             pDstGrp[uiNumTotalDst].bLfeOn = 
                hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0]->bInputLfeOn;
        }
        else
        {
            pDstGrp[uiNumTotalDst].eAudioMode = hRapCh->eInputAudMode;

            /*pDstGrp[uiNumTotalDst].bLfeOn = hRapCh->bInputLfeOn;*/
            if(hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
            {
                if(hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                    pDstGrp[uiNumTotalDst].bLfeOn = hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.bLfeOn;
                else
                    pDstGrp[uiNumTotalDst].bLfeOn = false;
            }
            else
            {
                    pDstGrp[uiNumTotalDst].bLfeOn = false;
            }  
        }

        /* Exchange the 1st and this level so that this stage will appear as 
           the first entry in the pDstGrp array */
        sTempDstGrp = pDstGrp[uiNumTotalDst];
        pDstGrp[uiNumTotalDst] = pDstGrp[0];
        pDstGrp[0] = sTempDstGrp;
    }
    else
    {
        uiMaxDstGrp = uiNumTotalDst;
    }

    /*TODO:while sorting itself we should store the number of direct consumers
           of this dstgrp. This will be used while allocating mixer output. */

    /* Sort destination groups in a particular order 
        a) decreasing order of data mode (7.1, 5.1, 2.0)
        b) increasing order of sampling rate with in the same data mode */
    for(m = 0; m < uiMaxDstGrp - 1; m++)
    {
        for(n = m +1 ; n < uiMaxDstGrp; n++)
        {
            BDBG_MSG(("m=%d n=%d, uiMaxDstGrp=%d (%d, %d) (%d, %d)", 
               m , n , uiMaxDstGrp,
               pDstGrp[m].eAudioMode, 
               pDstGrp[m].bLfeOn, 
               pDstGrp[n].eAudioMode, 
               pDstGrp[n].bLfeOn));
            if (true == pDstGrp[m].bInputMixingLvlOnly)
                continue;
            
            ret = BRAP_P_IsAudModeGreater(pDstGrp[m].eAudioMode, 
                                       pDstGrp[m].bLfeOn, 
                                       pDstGrp[n].eAudioMode, 
                                       pDstGrp[n].bLfeOn,
                                       &bModeMatched);
            if(BERR_SUCCESS != ret)    
            {
                return BERR_TRACE(ret);
            }
            
            if(true == bModeMatched)
            {
                sTempDstGrp = pDstGrp[m];
                pDstGrp[m] = pDstGrp[n];
                pDstGrp[n] = sTempDstGrp;
            }
            else if((pDstGrp[m].eAudioMode == pDstGrp[n].eAudioMode) && 
                    (pDstGrp[m].bLfeOn == pDstGrp[n].bLfeOn))
            {
                if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
                {
                    /* do nothing */
            	}
                else
                {
                BRAP_P_ConvertSR(pDstGrp[m].eSamplingRate,&uiSRm);
                BRAP_P_ConvertSR(pDstGrp[n].eSamplingRate,&uiSRn);
                if(uiSRm < uiSRn)
                {
                    sTempDstGrp = pDstGrp[m];
                    pDstGrp[m] = pDstGrp[n];
                    pDstGrp[n] = sTempDstGrp;
                }
                else
                {
                    /* do nothing */
                }
            }
            }
            else
            {
                /* do nothing, dst are already sorted */
            }
        }/* for n */
    }/* for m */

    *puiMaxDstGrp = uiMaxDstGrp;

    BDBG_LEAVE(BRAP_P_FormAndSortDestGrp);
    return ret;
}

BERR_Code BRAP_P_PrepareSrcRequest(
    BRAP_ChannelHandle      hRapCh,
    BRAP_P_OpAudModProp     sOpAudModeProp,
    BRAP_P_MixingLevelProp  sMixingLevels,
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq,
    unsigned int            uiPp,
    unsigned int            uiLvl,
    BRAP_ChannelHandle      hStrtdAssocCh,
    unsigned int            uiAsctdUsgPath,
    unsigned int            uiPth
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            chp = 0;
    unsigned int            uiNumSRCs = 0;
    unsigned int            i = 0;
    BRAP_RM_P_SrcGrant      sPrivSrcGrant;
    BRAP_P_ObjectHandles    *pTempPath=NULL;


    BDBG_ENTER(BRAP_P_PrepareSrcRequest);

    /* If we need fresh SRC - if its Level 0 or there is no channel 
       started in the Association */
    if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
        ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
    {
        pTempPath = hRapCh->pPath[hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx];
        if(pTempPath == NULL)
        {   
            BDBG_ERR(("In path of Mix path got corrupted"));
            BDBG_ASSERT(0);
        }
        else
        {
            for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
            {
                if((sOpAudModeProp.bChnExists[chp*2] == true) ||
                   (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
                {
                    /* SRCs will have only one parallel path */
                    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
                    {
                        sPrivSrcGrant = pTempPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                            sSrcGrant[i][chp][uiPp];

                        if((BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcId)&&
                           (BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcBlkId))
                        {
                            /* New allocation is required, since for each channel 
                               one SRC will be required */
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                                    = sPrivSrcGrant.uiSrcBlkId;
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                                    = sPrivSrcGrant.uiSrcId;
                            pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;
                            BDBG_MSG(("SrcBlkId=%d SrcId=%d",pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId,
                                pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId));
                        }
                    }
                }
                else
                {
                    pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
                }    
            }
        }
    }
    else
    {
    if((NULL == hStrtdAssocCh)||(0 == uiLvl))
    {
        for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {  
            if((sOpAudModeProp.bChnExists[chp*2] == true) ||
               (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
            {
                /* For the input audio mode, this audio channel pair 
            	   exists, so SRC and Mixer needs to be allocated */

                /* SRC Request */
                /* Check if 2 SRCs in cascade are required. 
                    2 SRCs in cascade are required when the SRC ratio 
                    is greater than 4 */

                if(((BRAP_ChannelType_eDecode == hRapCh->eChannelType)&&
                   (BRAP_ChannelSubType_eNone == hRapCh->eChannelSubType))
                   ||(BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)/*Assuming that for PCM playback/Capture we will do only Lint Mode SRC*/
                   ||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType))
            	{
            		uiNumSRCs = 1;
            	}
            	else
            	{
                    uiNumSRCs = BRAP_P_NumSrcReqdInCascade(
                                        sMixingLevels.eInputSR, 
                                        sMixingLevels.eOutputSR);
                }
                BDBG_MSG(("uiNumSRCs > %d", uiNumSRCs));
                
                if((uiNumSRCs > BRAP_RM_P_MAX_SRC_IN_CASCADE) || (uiNumSRCs == 0)) 
                {
                    BDBG_ERR(("BRAP_P_NumSrcReqdInCascade returned invalid"
                              " value uiNumSRCs > %d", uiNumSRCs));
                    return BERR_TRACE(BERR_NOT_SUPPORTED);
                }

                    /* SRCs will have only one parallel path */
                for(i = 0; i < uiNumSRCs; i++)
                {
            	    pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;
                     
                    /* New allocation is required, since for each channel 
                       one SRC will be required */
                    pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                            = BRAP_RM_P_INVALID_INDEX;
                    pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                            = BRAP_RM_P_INVALID_INDEX;
                }
            }
            else
            {
                pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
            }
            } /* for chp */
    }
    /* There is a started channel, Reallocate previously allocated SRCs */
    else
    {
        for (chp = 0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {
            if((sOpAudModeProp.bChnExists[chp*2] == true) ||
               (sOpAudModeProp.bChnExists[(chp*2)+1] == true))
            {
                /* SRCs will have only one parallel path */
                for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
                {
                    sPrivSrcGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->sRsrcGrnt.
                                sSrcMixerGrnt[uiLvl].sSrcGrant[i][chp][uiPp];

                    if((BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcId)&&
                       (BRAP_RM_P_INVALID_INDEX != sPrivSrcGrant.uiSrcBlkId))
                    {
                        /* New allocation is required, since for each channel 
                           one SRC will be required */
                        pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcBlkId 
                                = sPrivSrcGrant.uiSrcBlkId;
                        pSrcMixerReq->sSrcReq[i][chp][uiPp].sReallocateSrc.uiSrcId 
                                = sPrivSrcGrant.uiSrcId;

                        pSrcMixerReq->sSrcReq[i][chp][uiPp].bAllocate = true;

                    }
                }
            }
            else
            {
                pSrcMixerReq->sSrcReq[0][chp][uiPp].bAllocate = false;
            }    
        }
    }
    }

    
    BDBG_LEAVE(BRAP_P_PrepareSrcRequest);
    return ret;
}


BERR_Code BRAP_P_PrepareMixerRequest(
    BRAP_ChannelHandle      hRapCh,
    BRAP_ChannelHandle      hStrtdAssocCh,
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq,
    bool                    bPrimaryPresent,
    unsigned int            uiAsctdUsgPath,
    bool                    bInputMixingLvlOnly,
    unsigned int            uiNumMixerOutputs,
    unsigned int            uilvl,
    bool                    bDwmixEn,
    BRAP_P_MixingLevelProp  sMixingLvl,
    unsigned int            uiPth,
    unsigned int            uiAssocId
)
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_OpAudModProp     sMixLvlOpAudModeProp;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    BRAP_ChannelHandle      hMasterCh = NULL;
    unsigned int            chp =0, uiPp = 0;
    unsigned int            i=0, j=0;
    BRAP_RM_P_MixerGrant    sPrivMixerGrant;
    BRAP_OutputChannelPair  eInChp = BRAP_OutputChannelPair_eMax;
    
    BDBG_ENTER(BRAP_P_PrepareMixerRequest);
    
/* 
   Algo for mixer allocation

   - Find the master channel & it's 1st level data mode 
        - If Primary decode is present, it is the master.
        - If Primary is not present in association, then the channel opened first is master.
        
   - If you are the master, allocate one mixer per chan pair (check if any other associated
     channel has already been allocated. If yes, then reallocate those mixers with new
     inputs.)
   - If you are not the master
        a) If master's 1st level of mixing has been allocated
           - for each of your chan pair allocate all the mixers 
             already allocated for the master with differen inputs
        b) If master's 1st level is not allocated
           - for each of your chan pair allocate all the mixers
             required assuming master is already allocated. Later on
             when resources for master will be allocated, these 
             mixers will be reallocated there.   

    Note: If you are the master, only one mixer input is allocated per channel pair.
          If you are not the master then n mixer input is allocated per channel pair
            where n is = number of channel pairs present in your audmode.
          (In other words, each channel pair feeds to each of the mixers allocated for the master)  
    
*/


    BDBG_MSG((" BRAP_P_PrepareMixerRequest Params :: "
        "\n\thRapCh = 0x%x" 
        "\n\thStrtdAssocCh = 0x%x"  
        "\n\tpSrcMixerReq = 0x%x"
        "\n\tbPrimaryPresent = 0x%x" 
        "\n\tuiAsctdUsgPath = 0x%x" 
        "\n\tbInputMixingLvlOnly = 0x%x" 
        "\n\tuiNumMixerOutputs = 0x%x"
        "\n\tuilvl = 0x%x"
        "\n\tbDwmixEn = 0x%x"
        "\n\tuiPth=0x%x",
        hRapCh, hStrtdAssocCh, pSrcMixerReq,
        bPrimaryPresent, uiAsctdUsgPath, bInputMixingLvlOnly,
        uiNumMixerOutputs, uilvl, bDwmixEn, uiPth));

    BSTD_UNUSED(uiPth);

    /* Initialization to bypass compiler warning */
    sCurOpAudModeProp.uiNoChannels = 0;

    if (NULL == hStrtdAssocCh)
    {
        /* This is the first channel to be started. Allocate 
           mixer according to the Master channel */
        /* Find the master channel */
        if (true == bPrimaryPresent)
        {
            hMasterCh = hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[0];
        }
        else
        {
            hMasterCh = hRapCh;
        }

        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eOutputAudMode, 
                                sMixingLvl.bOutputLfeOn,&sMixLvlOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }

        for(chp =0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
        {
            if((true == sMixLvlOpAudModeProp.bChnExists[chp*2])||
               (true == sMixLvlOpAudModeProp.bChnExists[(chp*2) + 1]))
            {
                if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                {
                for(i=uiPp; i < BRAP_RM_P_MAX_PARALLEL_PATHS; i++)
                {
                    if(pSrcMixerReq->sMixerReq[chp][i].bAllocate == true)
                    uiPp++;
                    else
                        break;
                }
                }
                pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate = true;
                
                pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiDpId 
                                                = BRAP_RM_P_INVALID_INDEX;
                
                pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerId 
                                                = BRAP_RM_P_INVALID_INDEX;
                
                if(false == bDwmixEn)
                {
                    if(0 == uilvl)
                    {
                    /* If Current channel is master */
                    if ((hMasterCh == hRapCh))
                    {
                       pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 1;
                       /* Mixer input chpair is the same as the Master's chpair */
                       pSrcMixerReq->sMixerReq[chp][uiPp].bInputChPair[chp] = true;
                    }
                    else /* Current channel is not the master */
                    {
                        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                       sMixingLvl.bInputLfeOn,
                                                       &sCurOpAudModeProp);
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                            return BERR_TRACE(ret);
                        }

                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 
                                            (sCurOpAudModeProp.uiNoChannels + 1)/2;
                        for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                        {
                            if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||
                            (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                            {
                                pSrcMixerReq->sMixerReq[chp][uiPp].
                                                        bInputChPair[eInChp]= true;
                            }
                        }/* for eInChp */
                    }
                }
                    else
                    {
                        BDBG_MSG(("Came for Level %d",uilvl));
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 1;
                        /* Mixer input chpair is the same as the Master's chpair */
                        pSrcMixerReq->sMixerReq[chp][uiPp].bInputChPair[chp] = true;
                    }
                        
                }
                else /* Down Mix at this level */
                {
                    ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                   sMixingLvl.bInputLfeOn,
                                                   &sCurOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                        return BERR_TRACE(ret);
                    }

                    pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = 
                                        (sCurOpAudModeProp.uiNoChannels + 1)/2;
                    for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                    {
                        if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||
                        (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                        {
                            pSrcMixerReq->sMixerReq[chp][uiPp].
                                                    bInputChPair[eInChp]= true;
                        }
                    }/* for eInChp */
                }
            }/* if bDwnMix */
        
            /* For Mixer Output */
            if(bInputMixingLvlOnly == true)
            {
                pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput = 1;
                /* Mixer output 1 can only be used for Loopback to other Mixer */
                pSrcMixerReq->sMixerReq[chp][uiPp].uiMixerOutputId[0] = 1;
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerOutputId[i] 
                        = BRAP_RM_P_INVALID_INDEX;
                }
            }
            else
            {
                /* TODO: Allocate number of outputs depending on direct consumers 
                         at that Level */
                pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput = uiNumMixerOutputs; 
                
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    pSrcMixerReq->sMixerReq[chp][uiPp].sReallocateMixer.uiMixerOutputId[i] 
                        = BRAP_RM_P_INVALID_INDEX;
                }
            }/* if bInputMixingLvlOnly */
            
            BDBG_MSG(("Mixer Request : chp = %d, uiPp = %d, \n "
                      "pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate = %d \n"
                      "pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput = %d \n"
                      "pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput =%d \n",
                        chp,uiPp,pSrcMixerReq->sMixerReq[chp][uiPp].bAllocate,
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewInput,
                        pSrcMixerReq->sMixerReq[chp][uiPp].uiNumNewOutput));
        }
    }
    else if (NULL != hStrtdAssocCh) 
    {
        
        /* If a channel in association is already started, Reallocate already 
           allocated mixers */
        ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eOutputAudMode, 
                                sMixingLvl.bOutputLfeOn,&sMixLvlOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }
        
        if(0 == uilvl)
        {
            for(chp =0; chp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; chp++)
            {
                if((true == sMixLvlOpAudModeProp.bChnExists[chp*2])||
                   (true == sMixLvlOpAudModeProp.bChnExists[(chp*2) + 1]))
                {
                    if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                    {
                    for(i=uiPp; i < BRAP_RM_P_MAX_PARALLEL_PATHS; i++)
                    {
                        if(pSrcMixerReq->sMixerReq[chp][i].bAllocate == true)
                        uiPp++;
                        else
                            break;
                    }
                    }          
                    for(i=0;i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
                    {
                        BDBG_ASSERT(hStrtdAssocCh->pPath[uiAsctdUsgPath] != NULL);
                        
                        sPrivMixerGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->
                                    sRsrcGrnt.sSrcMixerGrnt[0].sMixerGrant[i][uiPp];
                        if((BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiDpId)&&
                           (BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiMixerId))
                        {
                            pSrcMixerReq->sMixerReq[i][uiPp].bAllocate = true;
                    
                            pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiDpId = sPrivMixerGrant.uiDpId;
                            pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerId = sPrivMixerGrant.uiMixerId;

                            for(j=0;j<BRAP_RM_P_MAX_MIXER_OUTPUTS;j++)
                            {
                                pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerOutputId[j]
                                                = sPrivMixerGrant.uiMixerOutputId[j];
                            }
                            
                            if(BRAP_ChannelSubType_ePrimary == hRapCh->eChannelSubType)
                            {
                                pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = 1;
                                pSrcMixerReq->sMixerReq[i][uiPp].bInputChPair[i]= true;
                            }
                            else
                            {
                                ret = BRAP_P_GetAudOpModeProp(sMixingLvl.eInputAudMode,
                                                   sMixingLvl.bInputLfeOn,
                                                   &sCurOpAudModeProp);
                                if(BERR_SUCCESS != ret)
                                {
                                    BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
                                    return BERR_TRACE(ret);
                                }
                                pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = 
                                                    (sCurOpAudModeProp.uiNoChannels + 1)/2;
                                for(eInChp=0; eInChp<BRAP_OutputChannelPair_eMax; eInChp++)
                                {
                                    if((true == sCurOpAudModeProp.bChnExists[eInChp*2])||                                
                                    (true == sCurOpAudModeProp.bChnExists[(eInChp*2) + 1]))
                                    {                                    
                                        pSrcMixerReq->sMixerReq[i][uiPp].bInputChPair[eInChp]= true;
                                    }                            
                                }/* for eInChp */
                            }
                            /* For Mixer Output */
                            pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewOutput = BRAP_RM_P_INVALID_INDEX;
                        }
                    }
                }
            }
        }
        else
        {
            /* Copy the already allocated mixers and reallocate them */
            for(i=0;i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
            {
                BDBG_ASSERT(NULL != hStrtdAssocCh->pPath[uiAsctdUsgPath]);
                sPrivMixerGrant = hStrtdAssocCh->pPath[uiAsctdUsgPath]->sRsrcGrnt.
                                    sSrcMixerGrnt[uilvl].sMixerGrant[i][uiPp];
                if((BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiDpId)&&
                   (BRAP_RM_P_INVALID_INDEX != sPrivMixerGrant.uiMixerId))
                {
                    pSrcMixerReq->sMixerReq[i][uiPp].bAllocate = true;
            
                    pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiDpId = sPrivMixerGrant.uiDpId;
                    pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerId = sPrivMixerGrant.uiMixerId;

                    for(j=0;j<BRAP_RM_P_MAX_MIXER_OUTPUTS;j++)
                    {
                        pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerOutputId[j]
                                        = sPrivMixerGrant.uiMixerOutputId[j];
                    }
                    
                    for (j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
                    {
                        BDBG_MSG(("Mixer Reallocate Input Id[%d] = %d",j,sPrivMixerGrant.uiMixerInputId[j]));
                        pSrcMixerReq->sMixerReq[i][uiPp].sReallocateMixer.uiMixerInputId[j]
                                        = sPrivMixerGrant.uiMixerInputId[j];
                    }
                    /* For Mixer Output */
                    pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewOutput = BRAP_RM_P_INVALID_INDEX;
                    pSrcMixerReq->sMixerReq[i][uiPp].uiNumNewInput = BRAP_RM_P_INVALID_INDEX;
                }
            }
        }
    }
    else
    {
        /* This condition should never come */
        BDBG_ASSERT(0);
    }
   
    BDBG_LEAVE(BRAP_P_PrepareMixerRequest);
    return ret;
}

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
BERR_Code BRAP_P_ResrcReqRbufSrcch(
    BRAP_ChannelHandle      hRapCh,         /* [in] The RAP Channel handle */
    BRAP_RM_P_ResrcReq      *pResrcReq,     /* [out] Resource Request filled 
                                               with Mixer and SRC layout */
    unsigned int            uiPth,          /* [in] Path index */
    BRAP_P_OpAudModProp *pOpModeProp,   /* [in] OpMode property structure
                                       passed by reference */    
    bool  bCompress                                       
)
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            dst = 0;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;

    BDBG_ENTER(BRAP_P_ResrcReqRbufSrcch);
    BSTD_UNUSED(uiPth);

    /* Assign RBUF & SRCCH requests based on sorted DSTs */
    for(dst = 0, eChP = 0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
    {
        if(NULL == hRapCh->pDstDetails[dst])
            continue;
        if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[dst]->eAudioDst)
        {
            if(eChP >= BRAP_RM_P_MAX_OP_CHANNEL_PAIRS)
            {
                BDBG_ERR(("Exceeding Max no of channel pair."));
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            /* Rbuf */
            pResrcReq->sRbufReq[eChP].bAllocate = true;
            pResrcReq->sRbufReq[eChP].eBufDataMode =  BRAP_BufDataMode_eStereoNoninterleaved;
            /* SrcCh */
            pResrcReq->sSrcChReq[eChP].bAllocate = true;
            /* AdaptRateCtrl */
                if((bCompress == false)
                    &&(pOpModeProp->bChnExists[0] == true) 
                    && (pOpModeProp->bChnExists[1] == true)) /* i.e LR Channel Pair*/
                {
                    if((pOpModeProp->bChnExists[2] == true) /*Ls*/
                        ||(pOpModeProp->bChnExists[3] == true)/*Rs*/
                        ||(pOpModeProp->bChnExists[4] == true)/*Center*/
                        ||(pOpModeProp->bChnExists[6] == true) /*Lr*/
                        ||(pOpModeProp->bChnExists[7] == true))/*Rr*/
                        {
                            BDBG_MSG(("AdaptRateCtrl is not allocated for Multichannel"));
                        }
                        else
                        {
                		    /* AdaptRateCtrl */
                            BDBG_MSG(("Populating resource request for AdaptRateCtrl"));                            
                            pResrcReq->sAdaptRateCtrlReq[eChP].bAllocate = true;                            
                        }          
                }
            eChP++;
        }
    }
    
    BDBG_LEAVE(BRAP_P_ResrcReqRbufSrcch);
    return ret;
}
#endif

BERR_Code BRAP_P_MixerSrcRsrcLayout(
    BRAP_ChannelHandle      hRapCh,         /* [in] The RAP Channel handle */
    BRAP_RM_P_ResrcReq      *pResrcReq,     /* [out] Resource Request filled 
                                               with Mixer and SRC layout */
    unsigned int            uiPth,          /* [in] Path index */
    BRAP_P_MixingLevelProp  *pMixingLevels, /* [out] Pointer to an array of
                                               structure to hold mixing level
                                               properties */
    BRAP_P_InternalDst      *pIntDst,       /* [in] Internal destination struct
                                               pointer */
    BRAP_OutputMode         eAudMode,       /* [in] Audio Mode for Input to Mixer*/
    bool                    bLfe,           /* [in] LFE status for Input to mixer*/
    BAVC_AudioSamplingRate  eSR,             /* [in] Sampling rate for level 0 
                                               SRC allocation */
    bool   bCompress                                               
)
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_DstGrpDetails    sDstGrp[BRAP_P_MAX_DST_PER_RAPCH + 
                                                    BRAP_RM_P_MAX_INTERNAL_DST + 1];
    /* Extra one to keep invalid entry for stack usage reduction */
    unsigned int            dst = 0, /*chp = 0,*/ uiLevel = 0, uiPp = 0;
    unsigned int            i=0, j=0, k=0, uiIntDst = 0 /*, path=0*/;
    BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
    bool                    bPrimaryPresent[BRAP_MAX_ASSOCIATED_GROUPS];
    unsigned int            uiAsctdUsgPath[BRAP_MAX_ASSOCIATED_GROUPS];
    bool                    bSetTopDecCh = false;
    bool                    bLfeOn = false;
    BRAP_P_OpAudModProp     sCurOpAudModeProp;
    unsigned int            uiMaxDstGrp = 0;
    BRAP_RM_P_SrcMixerReq   *pSrcMixerReq = NULL;
    unsigned int            uiNumConsumers = 0;
#if BRAP_P_EQUALIZER
    bool                    bSrcBlkAssigned = false;
    unsigned int            uisrc_blk = 0,uisrc_id = 0, l = 0;
    unsigned int            uiNumSrcEqAllocated[BRAP_RM_P_MAX_SRC_BLCK];    
    unsigned int            uiSrcRequestindex = 0;
    unsigned int            uiNumSrcEqsRequired = 0;
    unsigned int            uiCurrentAssocIdOfChan=0;
#endif
    bool                    bDwmixEn = false;
    unsigned int            sClonedDst[BRAP_P_MAX_OUTPUT_CONFIGS][BRAP_P_MAX_CLONES];
    unsigned int            uiNumMixerOutputs =0, uiAssocId=0;
    unsigned int            uiNumMixerRqd =0;
    bool                    bInputMixLvl = false;
    unsigned int            uiPpMix = 0;
    bool                    bBreakLoop = false, bLookStartedChan = true;

    
    BDBG_ENTER(BRAP_P_MixerSrcRsrcLayout);

    if(hRapCh->pPath[uiPth] == NULL)
    {
        BDBG_ERR(("Path handle should not be null "));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BKNI_Memset((void *)&sCurOpAudModeProp,0,sizeof(BRAP_P_OpAudModProp));
    /* Init sDstGrp[] to hold invalid values */
    for(dst = 0; dst < BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST + 1; dst++)
    {
        sDstGrp[dst] = sDstGrpInvalid;
    }

#if BRAP_P_EQUALIZER
    for(uisrc_blk=0; uisrc_blk<BRAP_RM_P_MAX_SRC_BLCK; uisrc_blk++)
    {
        uiNumSrcEqAllocated[uisrc_blk] = 0;
    }
#endif    

    for (i=0; i < BRAP_P_MAX_OUTPUT_CONFIGS; i++)
    {
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            sClonedDst[i][j]=BRAP_INVALID_VALUE;
        }
    }
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStrtdAssocCh[uiAssocId]=NULL;
        bPrimaryPresent[uiAssocId]=false;
        uiAsctdUsgPath[uiAssocId] = BRAP_INVALID_VALUE;
    }

#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
    if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
       ((hRapCh->pPath[uiPth]->eUsgPath != BRAP_P_UsgPath_eDecodePcmPostMixing) &&
        (hRapCh->pPath[uiPth]->eUsgPath != BRAP_P_UsgPath_ePPBranchPostMixing)))
    {
        /* In MS11 case Decode channels output to DRAM and a PB channel to RBUF. 
           So DecodePCM and PPBranch paths don't share any resources and have to 
           be formed for each channel. Only PostMixing path is shared. */
        bLookStartedChan = false;
    }
#endif    
    if(bLookStartedChan == true)
    {
        ret = BRAP_P_GetStartedChannel(hRapCh,bPrimaryPresent,hStrtdAssocCh);
        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_P_GetStartedChannel returned error"));
            return BERR_TRACE(ret);
        }
    }
   
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hRapCh->uiAssociationId[uiAssocId] != BRAP_INVALID_VALUE)
        {
            BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: hRapCh = 0x%x hStartedAssoCh[uiAssocId=%d] = 0x%x",
                hRapCh,hRapCh->uiAssociationId[uiAssocId],hStrtdAssocCh[hRapCh->uiAssociationId[uiAssocId]]));
        }
    }
    
    /* Need to search for a started channel in the association that the given path(uiPth) belongs to. */
    uiAssocId = hRapCh->pPath[uiPth]->uiAssocId;
    if(BRAP_P_IsPointerValid((void *)hStrtdAssocCh[uiAssocId]))
    {   
        /* Check if the same path has been started in the associated started 
           channel */
        bBreakLoop  =false;
        for(i=0; i<BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
        {
            if(!(BRAP_P_IsPointerValid((void *)hStrtdAssocCh[uiAssocId]->pPath[i])))
            {
                continue;
            }

            for(j =0 ; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
            {
                if(hStrtdAssocCh[uiAssocId]->pPath[i]->pDstDetails[j] == NULL)
                    continue;
                for(k =0 ; k < BRAP_P_MAX_DST_PER_RAPCH; k++)                    
                {
                    if(hRapCh->pPath[uiPth]->pDstDetails[k] == NULL)
                    {
                        if((BRAP_INVALID_VALUE != hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx) &&
                           (BRAP_P_UsgPath_eCapture == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath))
                        {
                            /* hRapCh has DecodePcmPostMixing path. Don't get out of the loop. 
                               pDstDetails will be null for DecodePcm/PPBranch path in all the channels of this Assoc */
                        }
                        else
                            continue;                        
                    }
                    if(hStrtdAssocCh[uiAssocId]->pPath[i]->pDstDetails[j] == hRapCh->pPath[uiPth]->pDstDetails[k])
                    {
                        uiAsctdUsgPath[uiAssocId] = i;
                        bBreakLoop  = true;
                        break;
                    }                        
                }
                if(true == bBreakLoop)
                    break;
            }
            if(true == bBreakLoop)
                break;

        }

        if(i >= BRAP_P_MAX_PATHS_IN_A_CHAN)
        {
            BDBG_ERR(("BRAP_P_MixerSrcRsrcLayout : Could not find Similar"
                              " path in started associated channel "));
            return BERR_TRACE(BERR_NOT_INITIALIZED);
        }
    }

    /* Check if this channel is a Decode Channel for Set Top Box Platform */
    if((hRapCh->eChannelSubType == BRAP_ChannelSubType_eNone) && 
       (hRapCh->eChannelType == BRAP_ChannelType_eDecode))
    {
        bSetTopDecCh = true;
    }

    /* Check LFE Status */
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        bLfeOn = hRapCh->bInputLfeOn;
    }
    else
    {
        hRapCh->bInputLfeOn = bLfeOn = false;
    }

    /* TODO: Add support for compressed path e.g. passthru, transcode */
    /* Prepare the destination group */
    ret = BRAP_P_FormAndSortDestGrp(hRapCh,uiPth,sDstGrp,bSetTopDecCh,pIntDst,
                              &uiMaxDstGrp,bPrimaryPresent[uiAssocId],uiAssocId);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_FormAndSortDestGrp returnrd error"));
        return BERR_TRACE(ret);
    }

    /* Update the Sorted Dsts in Clone Array */
    for(dst = 0,i=0,j=0; dst < uiMaxDstGrp; dst++)
    {
        if(0 == dst)
        {
            BDBG_MSG(("\t sDstGrp[dst=%d].eAudioMode=%d"
                      "\n\t sDstGrp[dst].eSamplingRate=%d",
                        dst,sDstGrp[dst].eAudioMode,
                        sDstGrp[dst].eSamplingRate));
            
            sClonedDst[i][j] = dst;
        }
        else
        {
            BDBG_MSG(("\t sDstGrp[dst=%d].eAudioMode=%d"
                      "\n\t sDstGrp[dst].eSamplingRate=%d"
                      "\n\t sDstGrp[dst-1].eAudioMode=%d"
                      "\n\t sDstGrp[dst-1].eSamplingRate=%d",
                        dst,sDstGrp[dst].eAudioMode,
                        sDstGrp[dst].eSamplingRate,
                        sDstGrp[dst-1].eAudioMode,
                        sDstGrp[dst-1].eSamplingRate));
            
            if((sDstGrp[dst-1].eAudioMode == sDstGrp[dst].eAudioMode) && 
               (sDstGrp[dst-1].eSamplingRate == sDstGrp[dst].eSamplingRate))
            {
                /* This is the clone of the previous Dst */
                if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                {
                  i++;j = 0;
                }
                else
                {
                  j++;
                }

                if( j >= BRAP_P_MAX_CLONES)
                {
                    BDBG_ERR(("Maximum %d clonned ports possible.",BRAP_P_MAX_CLONES));
                    return BERR_TRACE(BERR_NOT_SUPPORTED);
                }
                sClonedDst[i][j]=dst;
                
            }
            else
            {
                /* This is not a clone of previous Dst */
                i++;
                j=0;
                if( i >= BRAP_P_MAX_OUTPUT_CONFIGS)
                {
                    BDBG_ERR(("Maximum Eight Different output ports' config possible."));
                    return (BERR_NOT_SUPPORTED);
                }
                sClonedDst[i][j]=dst;
                
            }
        }
    }

    for (i=0; i < BRAP_P_MAX_OUTPUT_CONFIGS; i++)
    {
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if(BRAP_INVALID_VALUE == sClonedDst[i][j])
                sClonedDst[i][j] = BRAP_P_MAX_DST_PER_RAPCH + BRAP_RM_P_MAX_INTERNAL_DST;
        }
    }

    for(i=0,uiLevel = 0,uiPp = 0 ;(i< BRAP_P_MAX_OUTPUT_CONFIGS);i++)
    {
        bInputMixLvl = false;
        
        if((NULL == sDstGrp[sClonedDst[i][0]].pDstDetails)&&
           (NULL == sDstGrp[sClonedDst[i][0]].pIntDstDetails)&&
           (false == sDstGrp[sClonedDst[i][0]].bInputMixingLvlOnly))
        {
            continue;
        }
        uiNumConsumers = 0;
        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if ((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)||
                (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)||
                (true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly))
            {
                uiNumConsumers++;
        		BDBG_MSG(("1 j=%d uiNumConsumers=%d",j,uiNumConsumers ));
            }
            if(true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly)
            {
                bInputMixLvl =true;
            }
        }
        if(0 == uiLevel)
        {
            if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedPath)
                ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedMixPath)
                ||((hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                       && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                ||((hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                       && (hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                       && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))                       
                ||(bCompress == true))
            {
                pMixingLevels[uiLevel].eInputAudMode = BRAP_OutputMode_e2_0;
                pMixingLevels[uiLevel].bInputLfeOn = false;
                pMixingLevels[uiLevel].eInputSR = eSR;
            }
            else
            {
                pMixingLevels[uiLevel].eInputAudMode = eAudMode;
                pMixingLevels[uiLevel].bInputLfeOn = bLfe;
                pMixingLevels[uiLevel].eInputSR = eSR;
            }
        }
        else
        {
            pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
            pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
            pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
        }
        pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
        pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
        pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

        pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);

        /* For SRC allocation, for level 0, we need the channel's audio mode */
            ret = BRAP_P_GetAudOpModeProp(pMixingLevels[uiLevel].eInputAudMode,
                                      pMixingLevels[uiLevel].bInputLfeOn,
                                      &sCurOpAudModeProp);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_GetAudOpModeProp returned %d", ret));
            return BERR_TRACE(ret);
        }

        /* This is required to allow mixing of primary, secondary and sound 
           effects. Also, after first level of mixing there is no 
           distinction between primary and secondary sub channels */
        if((0 == uiLevel)||
           (pMixingLevels[uiLevel].eOutputSR != pMixingLevels[uiLevel-1].eOutputSR))
        {
            ret = BRAP_P_PrepareSrcRequest(hRapCh,sCurOpAudModeProp,
                                    pMixingLevels[uiLevel],pSrcMixerReq,uiPp,
                                    uiLevel,hStrtdAssocCh[uiAssocId],uiAsctdUsgPath[uiAssocId],uiPth);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_PrepareSrcRequest returned %d", ret));
                return BERR_TRACE(ret);
            }
        }
        BDBG_MSG(("BRAP_P_DecideDwnMixing: InMode %d, OutMode %d, uiLevel %d",
                                pMixingLevels[uiLevel].eInputAudMode,
                                pMixingLevels[uiLevel].eOutputAudMode,
                                uiLevel));

        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)||
	     (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
        {
            if(((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)&&
                (0!=uiLevel)&&
                (false == bInputMixLvl)&&
                (pMixingLevels[uiLevel].eInputAudMode != 
                                            pMixingLevels[uiLevel].eOutputAudMode))
               )
            {
                ret = BRAP_P_DecideDwnMixing(pMixingLevels[uiLevel].eInputAudMode,
                                             pMixingLevels[uiLevel].bInputLfeOn,
                                             pMixingLevels[uiLevel].eOutputAudMode,
                                             pMixingLevels[uiLevel].bOutputLfeOn,
                                             &bDwmixEn);
                BDBG_MSG(("BRAP_P_DecideDwnMixing: bDwnMixEn %d ",bDwmixEn));

                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_DecideDwnMixing returned %d", ret));
                    return BERR_TRACE(ret);
                }
            }
        }
        
        if(1 < uiNumConsumers)
        {
            uiNumMixerRqd = (uiNumConsumers -1);
        }
        else
        {
            uiNumMixerRqd = 1;
        }
        
        for(j=0,k=0,uiIntDst=0; j<uiNumConsumers; j++)
        {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
            uiLevel=0;
            pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
#endif
            pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;

            if(1 < uiMaxDstGrp)
            {
                uiNumMixerOutputs = 2;
            }
            else
            {
                uiNumMixerOutputs = 1;
            }

            BDBG_MSG(("uiPath=%d",uiPth));

#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                BDBG_MSG(("Custom Mixer Requirement is enalbed"));
                uiNumMixerOutputs = 2;
#endif            
            ret = BRAP_P_PrepareMixerRequest(hRapCh,hStrtdAssocCh[uiAssocId],pSrcMixerReq,
                                             bPrimaryPresent[uiAssocId],uiAsctdUsgPath[uiAssocId],
                                             sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly,
                                             uiNumMixerOutputs,uiLevel,bDwmixEn,
                                             pMixingLevels[uiLevel],uiPth,uiAssocId);
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_PrepareMixerRequest returned %d for uiAssocId=%d", ret,uiAssocId));
                return BERR_TRACE(ret);
            }

#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
            {   
                int x =0, nNumExtraMixers=0;
                
                if (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                {
                    /* If there is atleast one valid destination pDstDetails will not be NULL here */
                    if (sDstGrp[sClonedDst[i][j]].pDstDetails->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eI2s4)
                        nNumExtraMixers = 2;
                    else if (sDstGrp[sClonedDst[i][j]].pDstDetails->uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eDac0)
                        nNumExtraMixers = 1;
                    else
                        nNumExtraMixers = 0;
                    
                    for(x=0;x<nNumExtraMixers;x++)
                    {
                        uiLevel++;
                        
                        pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                        pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                        pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                        pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                        pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                        pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                        pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
                        ret = BRAP_P_PrepareMixerRequest(hRapCh,hStrtdAssocCh[uiAssocId],pSrcMixerReq,
                                                     bPrimaryPresent[uiAssocId],uiAsctdUsgPath[uiAssocId],
                                                     sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly,
                                                     uiNumMixerOutputs,uiLevel,bDwmixEn,
                                                     pMixingLevels[uiLevel],uiPth,uiAssocId);
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_PrepareMixerRequest returned %d", ret));
                            return BERR_TRACE(ret);
                        }
                    }
                }
            }
#endif            
            
            if (true == sDstGrp[sClonedDst[i][j]].bInputMixingLvlOnly)
            {
                if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                {
                    if (true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                    {
                        pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                    }
                    else
                    {
                        pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                    }
                }

                if(NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
                {
                    pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;
                }

                if ((true == hRapCh->hRap->sSettings.bIndOpVolCtrl) &&
                    (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails))
                {
                    uiPpMix++;
                }
                else if((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails) ||
                        (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails))
                {
                    uiLevel++;
                    
                    pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                    pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                    pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                }
   
                pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
            }
            else
            {
                if(((NULL != sDstGrp[sClonedDst[i][j+1]].pDstDetails) || (NULL != sDstGrp[sClonedDst[i][j+1]].pIntDstDetails))&& 
                   (2 >= (uiNumConsumers - j))&&
                   (NULL == sDstGrp[sClonedDst[i+1][0]].pDstDetails)&&(NULL == sDstGrp[sClonedDst[i+1][0]].pIntDstDetails))
                {
                    if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                    { 
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                        pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
#else
                        pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
#endif
                        k++;
                    }
                    else if(NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
                    {
                        pMixingLevels[uiLevel].pIntDstDetails[uiIntDst] = sDstGrp[sClonedDst[i][j]].pIntDstDetails;
                        uiIntDst++;
                    }                    
                }
                else
                {
                    if(NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
                    {
                        if (true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                        {
                            pMixingLevels[uiLevel].pDstDetails[uiPpMix] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                        }
                        else
                        {
                            pMixingLevels[uiLevel].pDstDetails[k] = sDstGrp[sClonedDst[i][j]].pDstDetails;
                        }
                    }
                    
                    if ((true == hRapCh->hRap->sSettings.bIndOpVolCtrl) &&
                        (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails))
                    {
                        uiPpMix++;
                    }
                    else if((NULL != sDstGrp[sClonedDst[i][j]].pDstDetails) ||
                            (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails))
                    {
                        uiLevel++;
                        
                        pMixingLevels[uiLevel].eInputAudMode = pMixingLevels[uiLevel-1].eOutputAudMode;
                        pMixingLevels[uiLevel].eInputSR = pMixingLevels[uiLevel-1].eOutputSR;
                        pMixingLevels[uiLevel].bInputLfeOn = pMixingLevels[uiLevel-1].bOutputLfeOn;
                    }
   
                    pMixingLevels[uiLevel].eOutputAudMode = sDstGrp[sClonedDst[i][0]].eAudioMode; 
                    pMixingLevels[uiLevel].bOutputLfeOn = sDstGrp[sClonedDst[i][0]].bLfeOn;
                    pMixingLevels[uiLevel].eOutputSR = sDstGrp[sClonedDst[i][0]].eSamplingRate;

                    pSrcMixerReq = &(pResrcReq->sSrcMixerReq[uiLevel]);
                }
            }
        }
    }
#if BRAP_P_EQUALIZER
    /* Request and allocate the SRC for Equalizer here
        We need uiNumConsumers SRC Equalizers one for each destination */

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStrtdAssocCh[uiAssocId]=NULL;
        bPrimaryPresent[uiAssocId]=false;
    }
    
    ret = BRAP_P_GetStartedChannel(hRapCh,bPrimaryPresent,hStrtdAssocCh);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_GetStartedChannel returnrd error"));
        return BERR_TRACE(ret);
    }

    uiCurrentAssocIdOfChan = hRapCh->pPath[uiPth]->uiAssocId;

    for(i=0;i< BRAP_P_MAX_OUTPUT_CONFIGS;i++)
    {
        if((NULL == sDstGrp[sClonedDst[i][0]].pDstDetails)&&
           (NULL == sDstGrp[sClonedDst[i][0]].pIntDstDetails)&&
           (false == sDstGrp[sClonedDst[i][0]].bInputMixingLvlOnly))
        {
            continue;
        }

        for(j=0;j<BRAP_P_MAX_CLONES;j++)
        {
            if (NULL != sDstGrp[sClonedDst[i][j]].pDstDetails)
            {
                /* For valid output port paths see if equalizer has been added */
                BRAP_P_DstDetails *pvtDstDetails;
                unsigned int uiAssocitationID = 0;
                
                pvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                if( NULL==pvtDstDetails)
                {
                    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                    goto end;
                }
                BKNI_Memset(pvtDstDetails,0,sizeof( BRAP_P_DstDetails ));                        
                
                ret  = BRAP_P_GetPvtDstDetails (
                                hRapCh,
                                sDstGrp[sClonedDst[i][j]].pDstDetails,
                                pvtDstDetails,
                                &uiAssocitationID
                            );
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_GetPvtDstDetails returnrd error"));
                    return BERR_TRACE(ret);
                }

                if(pvtDstDetails->hEqualizer != NULL)
                {
                    if(hStrtdAssocCh[uiCurrentAssocIdOfChan] == NULL)
                    {                    
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = true;
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = BRAP_RM_P_INVALID_INDEX;
                        uiNumSrcEqsRequired++;

                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].bAllocate = true;
                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = BRAP_RM_P_INVALID_INDEX;
                        uiNumSrcEqsRequired++;                            

                        /* Same Equalizer can be added to multiple output ports that belong 
                           to same raptor channel. If an SRC for this EQ is already allocated,
                               allocate the subsequent SRCs for this EQ from the same block */
                        for(l=0; l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; l++)
                        {
                            for(uiPp=0; uiPp<BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                            {
                                for(k=0; k<BRAP_P_MAX_PATHS_IN_A_CHAN; k++)
                                {                            
                                    if((NULL != pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]) &&
                                       (NULL != pvtDstDetails->hEqualizer->hSrcEq[1][l][uiPp][k]))
                                    {
                                        BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: Requesting SRC from the same Block %d"
                                            "as that of earlier allocated Equalizer SRC.", 
                                            pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]->uiBlkId));
                                        
                                        pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 
                                                        pvtDstDetails->hEqualizer->hSrcEq[0][l][uiPp][k]->uiBlkId;
                                        pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 
                                                        pvtDstDetails->hEqualizer->hSrcEq[1][l][uiPp][k]->uiBlkId;
                                        bSrcBlkAssigned = true;
                                        break;                                    
                                    }
                                }
                                if(true == bSrcBlkAssigned)
                                    break;
                            }
                            if(true == bSrcBlkAssigned)
                                break;                            
                        }

                        if(false == bSrcBlkAssigned)
                        {
                            /* Count the total number of Equalizer SRCs allocated so far */
                            for(uisrc_blk=0;uisrc_blk<BRAP_RM_P_MAX_SRC_BLCK;uisrc_blk++)
                            {
                                for(uisrc_id=0;uisrc_id<BRAP_RM_P_MAX_SRC_PER_SRC_BLCK;uisrc_id++)
                                {
                                    if((0 < hRapCh->hRap->hRm->sSrcUsage[uisrc_blk][uisrc_id].uiUsageCount) &&
                                       (true == hRapCh->hRap->hRm->sSrcUsage[uisrc_blk][uisrc_id].bSrcEq))
                                    {
                                        uiNumSrcEqAllocated[uisrc_blk]++;                            
                                    }                        
                                }
                            }

                            /* There are 160 Coeff adresses available in SRC0 for IIR filter
                               so 2 SrcEqs((40+40)*2) can be allocated. In SRC1 we have entire
                               360 Coeff adresses for IIR filters so 4 SrcEqs can be allocated,
                               leaving 40 more addresses free */                     
                            if(2 > uiNumSrcEqAllocated[0])
                            {
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 0;                        
                                pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 0;
                            }
                            else if(4 > uiNumSrcEqAllocated[1])
                            {
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId = 1;                        
                                pResrcReq->sSrcEqReq[1][0][uiSrcRequestindex].uiBlkId = 1;
                            }
                            else
                            {
                                BDBG_ERR(("BRAP_RM_P_AllocateSrcEq: Could not Allocate SRC." 
                                    " No Free SRC/Coefficient Address available"));
                                return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);                    
                            } 
                            BDBG_MSG(("BRAP_P_MixerSrcRsrcLayout: Requesting SRC from Block %d",
                                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].uiBlkId));
                        }
                        uiSrcRequestindex++;
                    }
                    else
                    {
                        for(k=0; k < BRAP_P_MAX_PATHS_IN_A_CHAN; k++)
                        {
                            if(hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k] == NULL)
                                continue;
                            for(l=0; l < BRAP_P_MAX_DST_PER_RAPCH; l++)
                            {
                                if((hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->pDstDetails[l]->eAudioDst == 
                                    pvtDstDetails->sExtDstDetails.eAudioDst) &&
                                   (hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->pDstDetails[l]->uDstDetails.sOpDetails.eOutput[0] == 
                                    pvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]))
                                {
                                    for(uiPp=0;uiPp<BRAP_RM_P_MAX_PARALLEL_PATHS;uiPp++)
                                    {           
                                        if((hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.
                                            sSrcEqGrant[0][0][uiPp].uiSrcBlkId != BRAP_RM_P_INVALID_INDEX) &&
                                           (hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.
                                            sSrcEqGrant[0][0][uiPp].uiSrcId != BRAP_RM_P_INVALID_INDEX))
                                        {
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = true;                
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcBlkId = 
                                                hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.sSrcEqGrant[0][0][uiPp].uiSrcBlkId;
                                            pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].sReallocateSrcEq.uiSrcId = 
                                                hStrtdAssocCh[uiCurrentAssocIdOfChan]->pPath[k]->sRsrcGrnt.sSrcEqGrant[0][0][uiPp].uiSrcId;
                                            uiSrcRequestindex++;
                                            uiNumSrcEqsRequired++;                                            
                                            bBreakLoop = true;
                                            break;
                                        }
                                    }
                                }
                                if(bBreakLoop == true)
                               break;                                
                            }
                            if(bBreakLoop == true)
                           break;
                        }
                    }    
                }
                else
                {
                    pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = false;
                    uiSrcRequestindex++;                        
                }
            }
            
            if (NULL != sDstGrp[sClonedDst[i][j]].pIntDstDetails)
            {
                /* No equalizer for internal capture ports in this method */
                pResrcReq->sSrcEqReq[0][0][uiSrcRequestindex].bAllocate = false;
                uiSrcRequestindex++;
            }
        }
    }

    BDBG_MSG (("Equalizer Related Resource: uiNumSrcEqsRequired = %d",uiNumSrcEqsRequired));

#endif
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_MixerSrcRsrcLayout);
    return ret;
}


BERR_Code BRAP_P_ValidateDecPathParams(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams   /* [in] Audio params passed 
	                                               during channel start time */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    bool bWdgRecovery = false;
    BRAP_Handle hRap = NULL;
    
    /* Check if this is a watchdog recovery. */
      BDBG_ASSERT(hRapCh);
    bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    hRap = hRapCh->hRap;
  

    /* Check for valid supported conditions if not watchdog recovery */
    if(false == bWdgRecovery) 
    {
        if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
        {
            /* Check DecodeMode */
            switch(pAudioParams->sDspChParams.eDecodeMode)
            {
                /* Modes supported:  */
                case BRAP_DSPCHN_DecodeMode_eDecode:
                case BRAP_DSPCHN_DecodeMode_ePassThru:
                    break;
                /* Not supported */
                default:
                    BDBG_ERR(("BRAP_P_OpenAndStartDecPath: Decode mode %d not" 
                        " supported", pAudioParams->sDspChParams.eDecodeMode));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
            }

            if(BRAP_AudioSource_eExtCapPort != pAudioParams->eAudioSource)
            {
                /* Check audio algorithm type */
/*                ret = BRAP_P_IsAlgoTypeSupported(hRap, pAudioParams->sDspChParams.eType);
                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);                        
                }*/
#if 0                
                if(!((BRAP_DSPCHN_AudioType_eAc3 == pAudioParams->sDspChParams.eType)&&
                    (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)))
                {
                    if(false == BRAP_FWDWNLD_P_IsAudCodecSupported(pAudioParams->sDspChParams.eType))
                    {
                        BDBG_ERR(("Algo Type (%d) Not Supported", pAudioParams->sDspChParams.eType));
                        return BERR_TRACE(ret);                        
                    }
                }
#endif

/*				else if(BRAP_DSPCHN_AudioType_eDdp7_1== pAudioParams->sDspChParams.eType)
				{
					if ((pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_ePassThru)
                    || (pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eSimulMode))
                    {
                        BDBG_ERR(("Compressed data format not supported for algorithm DDP 7.1. Use Ac3Plus instead."));
                        return BERR_TRACE(BRAP_ERR_COMP_SPDIF_NOT_ALLOWED);
                    }  
				}
  */              

                /* 1. bDtsCdCompressed and bHbrCompressed should not be enabled for 
                      together. 
                   2. bDtsCdCompressed can be enabled only for DTS-HD or DTS algo simul mode */
                if((true == pAudioParams->sDspChParams.bDtsCdCompressed) && 
                   (true == pAudioParams->sDspChParams.bHbrCompressed)) 
                {
                    BDBG_ERR(("Both bDtsCdCompressed and bHbrCompressed can't be true together"));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }

                if((true == pAudioParams->sDspChParams.bDtsCdCompressed) && 
                   ((BRAP_DSPCHN_AudioType_eDts != pAudioParams->sDspChParams.eType) && 
                     (BRAP_DSPCHN_AudioType_eDtshd != pAudioParams->sDspChParams.eType))) 
                {
                    BDBG_ERR(("bDtsCdCompressed = true not supported for AlgoType = %d and DecodeMode = %d",
                        pAudioParams->sDspChParams.eType, pAudioParams->sDspChParams.eDecodeMode));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                    
            	/* Check if the algo type was selected at BRAP_Open time. Otherwise  
            	   we may not have sufficient memory for this algorithm */

                /* Check stream type */
                ret = BRAP_P_IsStreamTypeSupported(
                        pAudioParams->sDspChParams.eStreamType);
                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);                        
                }
            }

            /* TODO: Check if bPtsSpecificDecode supported for 7440 */
            /* bPtsSpecificDecode should not be set to true */
            if(true == pAudioParams->sDspChParams.bPtsSpecificDecode) 
            {
                BDBG_ERR(("PTS specific decode is supported only for 7411 D0"));
                return BERR_TRACE(BERR_NOT_SUPPORTED);
            }
            
            /* TODO: Add more checks for decode channel here */
        }
    
        /* TODO: check conditions for other channel types here */

    }/* bWdgRecovery == false */

    /* Sanity tests outside the watchdog recovery */

    return ret;
}

/***********************************************
Summary: This function tells if the output of the path is compress or linear.
Please note that before this calling this function, the destinations in the path needs to be populated
***********************************************/
BERR_Code
BRAP_P_IsPathOutputCompress(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	unsigned int                                uiPth,
	bool                                         *pbCompress
	)
{
    BRAP_P_DstDetails   *pPvtDstDetails = NULL;
    unsigned int i =0;
    BERR_Code ret = BERR_SUCCESS;

    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pbCompress);        
    BDBG_ENTER(BRAP_P_IsPathOutputCompress);

    if(hRapCh->pPath[uiPth] == NULL)
    {
        BDBG_ERR(("Path should not be NULL"));
        ret = BERR_TRACE(BERR_INVALID_PARAMETER);
        goto exit;              
    }
	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
	{
        BDBG_ERR(("Sysmtem memory not availbale"));
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto exit;            
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));        

    if ((BRAP_P_UsgPath_eDecodeCompress==hRapCh->pPath[uiPth]->eUsgPath) ||
        (BRAP_P_UsgPath_eDecodeCompressPostMixing==hRapCh->pPath[uiPth]->eUsgPath))
    {
       *pbCompress = true;
       goto exit;
    }
    else
    {
        for(i = 0 ; i< BRAP_P_MAX_DST_PER_RAPCH ; i++)
        {
            if(NULL != hRapCh->pPath[uiPth]->pDstDetails[i])
            {
                if((BRAP_AudioDst_eOutputPort == hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst)
                    &&(true == hRapCh->hRap->sOutputSettings[hRapCh->pPath[uiPth]->pDstDetails[i]->\
                                uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]].bCompressed))
                {
                    *pbCompress = true;
                    break;
                }                
            
                else if((BRAP_AudioDst_eRingBuffer == hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst)
                        &&(true == hRapCh->pPath[uiPth]->pDstDetails[i]->uDstDetails.sRBufDetails.bCompress))
                {
                    *pbCompress = true;
                    break;
                }                
            }
        }
        if(i == BRAP_P_MAX_DST_PER_RAPCH)
        {
            /* Did not find compressed audio in the path. Assume PCM */
            /* Ofcourse incase of Loopback To DSP, pre-loopback paths have pDstDetails[i] NULL for all 'i',
               but currently only PCM loopback to DSP is supported */
            *pbCompress = false;        
        }
    }
    
exit:
    BDBG_LEAVE(BRAP_P_IsPathOutputCompress);
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts a decode path.
**************************************************************************/
BERR_Code 
  BRAP_P_StartDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    BRAP_DSPCHN_P_AudioParams   *pDspChParams = NULL;
    unsigned int                i = 0;
    bool                        bCompress = false;
    bool                        bWdgRecovery = false;
#if ( (BRAP_3548_FAMILY == 1) )
    bool                        bLinked = false;
    bool                        bSlave = false;
#endif
    bool                        bRequireDSP = false;
    bool                        bFMMPathAllocated = true;

    BDBG_ENTER(BRAP_P_StartDecPath);

    if(NULL == hRapCh->pPath[uiPth])
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
        goto exit;
    }

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("StartDecPath: Returning success for PCMPB compress path\n"));
        goto exit;        
    }
    
    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) 
       through DRAM buffers and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));      
    
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    /* Check if the path has already been started. If yes, just increment the 
       count and return success. */
    if((bWdgRecovery == false) 
        && (0 != hRapCh->pPath[uiPth]->uiPthStartCnt))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartDecPath: Dec Path %d was already started. " 
                "New start count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

        /* DSPCHN start need not be called again but add the new input to FW Mixer task */
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) && 
           ((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing) ||
            (hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing)))
        {
            uint32_t                ui32Offset, j = 0;
            BRAP_P_IOBufferDetails  *psIOBufInfo; /* Contains Buffer details of Decode or PB Output/Input to FW Mixer */

            psIOBufInfo = (BRAP_P_IOBufferDetails *)BKNI_Malloc(sizeof(BRAP_P_IOBufferDetails));
            if(psIOBufInfo == NULL)
            {
                ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                goto free_IO_resrc;
            }
            
            if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
            {
                if(hRapCh->hMultiStreamDecoder != NULL)
                {
                    psIOBufInfo->eBufferType = BRAP_P_IOBufferType_eDRAM;
                    for(i=0; i<BRAP_P_MAX_FW_STG_INPUTS; i++)
                    {
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == false)
                            break;
                    }
                    if(i == BRAP_P_MAX_FW_STG_INPUTS)
                    {
                        BDBG_ERR(("No free DRAM buffer found for InterTask buffer usage"));
                        ret = BRAP_ERR_BAD_DEVICE_STATE;
                        goto free_IO_resrc;
                    }
                    
                    psIOBufInfo->uBufferDetails.sIOBuffer.uiNumBuffers = hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[i];

                    for(j=0 ; j<psIOBufInfo->uBufferDetails.sIOBuffer.uiNumBuffers; j++)
                    {	
                        BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap,
    						(void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[i][j]), &ui32Offset);
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32BaseAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32ReadAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32WriteAddr = ui32Offset;

                        BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap,
    						(void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[i][j] \
    						+ BRAP_AF_P_INTERTASK_IOBUFFER_SIZE), &ui32Offset);
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32EndAddr = ui32Offset;
                        psIOBufInfo->uBufferDetails.sIOBuffer.sIOCircularBuf[j].ui32WrapAddr = ui32Offset;
                    }
                    BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap,
                        (void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[i]), &ui32Offset);
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32BaseAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32ReadAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32WriteAddr = ui32Offset;
                    
                    BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap,
                        (void *)(hRapCh->hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[i] \
                        +BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE), &ui32Offset); 
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32EndAddr = ui32Offset;
                    psIOBufInfo->uBufferDetails.sIOBuffer.sIOGenericCircularBuf.ui32WrapAddr = ui32Offset;                                            
                }
                else
                {
                    BDBG_ERR(("Multi Stream Decoder handle invalid"));
                    ret = BERR_NOT_SUPPORTED;
                    goto free_IO_resrc;
                }
            }
            else if(hRapCh->eChannelType == BRAP_ChannelType_ePcmPlayback)    
            {
                /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                if(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth-1]->eUsgPath)
                {
                    psIOBufInfo->eBufferType = BRAP_P_IOBufferType_eFMM;                
                    psIOBufInfo->uBufferDetails.sIOBufId.uiNumBuffers = 2;
                    psIOBufInfo->uBufferDetails.sIOBufId.ui32RbufId[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    psIOBufInfo->uBufferDetails.sIOBufId.ui32RbufId[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];
                }
                else
                {
                    BDBG_ERR(("Previous path is not Capture path."));
                    ret = BERR_NOT_SUPPORTED;
                    goto free_IO_resrc;
                }                
            }
            else
            {
                BDBG_ERR(("Capture channel not supported currently"));
                ret = BERR_NOT_SUPPORTED;
                goto free_IO_resrc;          
            }

            ret  = BRAP_DSPCHN_P_AddRemoveInputToTask(hRapCh, hRapCh->pPath[uiPth]->hDspCh, true, psIOBufInfo);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_DSPCHN_P_AddRemoveInputToTask returned error"));
                goto free_IO_resrc;
            }
			free_IO_resrc:
            if(psIOBufInfo)
                BKNI_Free(psIOBufInfo);
        }
#endif        

        /* Return success */
        BDBG_LEAVE (BRAP_P_StartDecPath);
        ret = BERR_SUCCESS;
        goto exit;        
    }   

	/* Malloc large local structures */
	pDspChParams = hRapCh->hRap->sOpenTimeMallocs.pDspChParams;
	if( NULL==pDspChParams )
	{
        ret = BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
        goto exit;        
	}
    BKNI_Memset(pDspChParams, 0, sizeof(BRAP_DSPCHN_P_AudioParams));

#if ( (BRAP_3548_FAMILY == 1) )
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_eDecode==pAudioParams->sDspChParams.eDecodeMode ))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapMasterCh))
            {
                bLinked = true;
                break;
            }
        }
    }
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode ))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapSlaveCh))
            {
                bSlave = true;
                break;
            }
        }
    }
#endif
    

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) 
        ||( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode ))
        bCompress = true;
    else 
        bCompress = false;

    if(true == bFMMPathAllocated)
    {
        ret = BRAP_P_IsPathOutputCompress(hRapCh,uiPth,&bCompress);
        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_IsPathOutputCompress() returned err(%d)",ret));	
            ret = BERR_TRACE(ret); 
            goto exit;                
        }

        /* Start all internal module handles */
        ret = BRAP_P_StartFmmModuleHandles(hRapCh, pAudioParams, uiPth, bCompress);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_StartFmmModuleHandles failed %d",
                ret));
            ret = BERR_TRACE(ret); 
            goto exit;        
        }
        if (false == bCompress)
        {
            /* Program the mixing Coefficients for the channel */
            ret = BRAP_P_ProgramCoefficients(hRapCh, &(pAudioParams->sMixingCoeff));
            if(BERR_SUCCESS != ret)
            {
            	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramCoefficients failed %d",
                    ret));
                ret = BERR_TRACE(ret); 
                goto exit;            
            }
            /* Program the Down-mixing Coefficients for the channel */
            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)||
    			(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
            {
                ret = BRAP_P_ProgramDownMixCoefficients(hRapCh,uiPth);
                if(BERR_SUCCESS != ret)
                {
                	BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramDownMixCoefficients failed %d",
                        ret));
                	ret = BERR_TRACE(ret); 
                    goto exit;
                }
            }
            if(false == bWdgRecovery)
            hRapCh->sMixingCoeff = pAudioParams->sMixingCoeff;
        }
    }

    /* Decide whether to have DSP or not */
#if (BRAP_3548_FAMILY == 1)  
    if ( (BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) ||
         (BRAP_ChannelType_eDecode == hRapCh->eChannelType)
       )
    {
        bRequireDSP = true;
    }
    if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
         (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
         (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
         ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
           (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
         )
       )
    {
        bRequireDSP = false;

        /* Also in this mode we should put the SPDIF RX to PCM mode */
        BRAP_SPDIFRX_P_SwitchToCompressed (hRapCh->hRap);
    }
#else
    if (BRAP_ChannelType_eDecode == hRapCh->eChannelType)
    {
        bRequireDSP = true;
    }
#endif     
    if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
        /* Assocition network */
        if((BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth]->hDspCh)) &&
           (hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh == false))
        {
            bRequireDSP = true;
        }
    }
    
    if (true == bRequireDSP)
    {
        /* Populate sDspChnParams structure */    
    	pDspChParams->sExtAudioParams = pAudioParams->sDspChParams;

        if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode) ||
           (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode))
        {
            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.bIsSingleI2SHbrMode = false;

          	/* Initialize the ring buffer index array in sDspChnParams */
        	for(i=0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        	{
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.rBufIndex[i] 
	                    = (int8_t)BRAP_RM_P_INVALID_INDEX;
                
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[i] 
	                    = (int8_t)BRAP_RM_P_INVALID_INDEX;
        	}

            for(i=0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
            {
        		pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.rBufIndex[i] = 
                   hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[i];
            }

            /* TODO: sMixerParams: mixer ids and input info for metadata preparation */    
        }
        else
            BDBG_ASSERT(0);

        /* Other misc DSP channel params */                        
      	pDspChParams->eTimebase = pAudioParams->eTimebase;
      	pDspChParams->uiTransChId = hRapCh->uiXptChannelNo;
		pDspChParams->sXptContextMap = pAudioParams->sXptContextMap;
    	pDspChParams->bPlayback =  pAudioParams->bPlayback;
        pDspChParams->bMultiChanOnI2S = false;
        pDspChParams->sExtAudioParams.eLowDelayEnableMode = pAudioParams->eLowDelayEnableMode;


        /* Add the SPDIF channel status buffer params to the sDspChParams */
        if(true == hRapCh->hRap->bOpSettingsValid[BRAP_OutputPort_eSpdif])
        {
            /* TODO: Check with firmware team if they need to know the 
               output port or ring buffer that will be carrying SPDIF data */
            pDspChParams->sSpdifChStatusParams[0] = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
    		pDspChParams->bUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
        }

        /* Add the MAI channel status buffer params to the sDspChParams */
        if(true == hRapCh->hRap->bOpSettingsValid[BRAP_OutputPort_eMai])
        {
            /* TODO: Check with firmware team if they need to know the 
               output port or ring buffer that will be carrying SPDIF data */
            pDspChParams->sSpdifChStatusParams[1] = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams;
    		pDspChParams->bUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].bUseSpdifPackedChanStatusBits );
        }
        
        if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode) ||
           (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode))
        {  
            if ((BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth]->eUsgPath)||
                (BRAP_P_UsgPath_eMixPath== hRapCh->pPath[uiPth]->eUsgPath)||
                (BRAP_P_UsgPath_eSharedPP== hRapCh->pPath[uiPth]->eUsgPath)||                    
                (BRAP_P_UsgPath_eDownmixedMixPath== hRapCh->pPath[uiPth]->eUsgPath)||                    
                (BRAP_P_UsgPath_eDownmixedPath== hRapCh->pPath[uiPth]->eUsgPath) ||
                (BRAP_P_UsgPath_ePPBranchPostMixing== hRapCh->pPath[uiPth]->eUsgPath))
            {
                ret = BRAP_DSPCHN_P_DummyStart(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
            }
            else
            {
                BDBG_MSG(("BRAP_P_StartDecPath: Calling DSPCHN_P_Start"));
                /* Note: A DSP channel is required to be started only if it is a 
                   decode mode or passthru mode or passthru context of simul mode */
                   
                if (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource)
                {
#if (BRAP_7550_FAMILY != 1)
                    pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];


                    if ( (BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort)||
                         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort)||
                         (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort)
                       )
                    {
                        pDspChParams->sExtAudioParams.eDecodeMode = BRAP_DSPCHN_DecodeMode_eDecode;
                        pDspChParams->sExtAudioParams.eType = BRAP_DSPCHN_AudioType_ePcm;
                        pDspChParams->sExtAudioParams.eOutputSampleRate = BAVC_AudioSamplingRate_e48k;
                        pDspChParams->sExtAudioParams.eStreamType = BAVC_StreamType_ePes;

                        if(BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort)
                        {
                            pDspChParams->sExtAudioParams.eInputSampleRate = 
                                hRapCh->hRap->sInputSettings[hRapCh->eCapInputPort].eSampleRate;
                        }
                    }
#endif                        
                }
                else if(BRAP_AudioSource_eRingBuffer== hRapCh->eAudioSource)
                {
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                    pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                        hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];                    
                }

                if(false == hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh)
                {
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                    if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
                    {
                        /* First configuration/start of FW Mixer, 0th input port will be used */
                        /* FW doesn't assume that 0th one is the mixer input port.
                        FW checks all the input port and finds out which one is valid*/
                        hRapCh->uiFWMixerIpIndex = 0;
                    }
#endif                    
                    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth-1]);
                    /* Get Ring Buffer indices from CapturePath(uiPth-1) */
                    if(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth-1]->eUsgPath)
                    {
                        pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eFMMBuf;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[0] = 
                            hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[0];
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecPathFmmParams.inputRBufIndex[1] = 
                            hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiRbufId[1];
                    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                    else if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
                            ((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth-1]->eUsgPath) ||
                             (BRAP_P_UsgPath_ePPBranch == hRapCh->pPath[uiPth-1]->eUsgPath)) &&
                            (BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth-1]->hDspCh)))
                    {
                        uint32_t    ui32Offset = 0, j = 0;

                        i = hRapCh->uiFWMixerIpIndex;       
                        pDspChParams->sDecOrPtParams.eDecSourceType = BRAP_DSPCHN_P_SourceType_eDRAMBuf;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoBuffer.eBufferType = BRAP_AF_P_BufferType_eDRAM;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoBuffer.ui32NumBuffers = hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[i];
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == true)
                        {
                            BDBG_ERR(("This is first start of Decode Post-Mixing path, 0th DRAM Buffer can't be in use"));
                        	ret = BRAP_ERR_BAD_DEVICE_STATE; 
                            goto exit;
                        }
                        for(j=0 ; j<pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.sDecIoBuffer.ui32NumBuffers ; j++)
                        {	
                            BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                                ui32InterTaskIoBufferAddress[i][j]), &ui32Offset);
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32BaseAddr = ui32Offset;
                            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                                sDecIoBuffer.sCircBuffer[j].ui32ReadAddr = ui32Offset;
                            pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                                sDecIoBuffer.sCircBuffer[j].ui32WriteAddr = ui32Offset;

                            BRAP_P_ConvertAddressToOffset(	hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                                ui32InterTaskIoBufferAddress[i][j] + BRAP_AF_P_INTERTASK_IOBUFFER_SIZE), &ui32Offset);
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32EndAddr = ui32Offset;
    						pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                              sDecIoBuffer.sCircBuffer[j].ui32WrapAddr = ui32Offset;
                            
                        }
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.eBufferType = BRAP_AF_P_BufferType_eDRAM;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.ui32NumBuffers = 1;

                        BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                            ui32InterTaskIoGenericBufferAddress[i]), &ui32Offset);
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32BaseAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32ReadAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32WriteAddr = ui32Offset;

                        BRAP_P_ConvertAddressToOffset(  hRapCh->hHeap, (void *)(hRapCh->hMultiStreamDecoder->\
                            ui32InterTaskIoGenericBufferAddress[i] +BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE), &ui32Offset);
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32EndAddr = ui32Offset;
                        pDspChParams->sDecOrPtParams.uDecBufFmmParams.sDecSourceBufDetails.\
                            sDecIoGenericBuffer.sCircBuffer.ui32WrapAddr = ui32Offset;
                    }
#endif
                    pDspChParams->bPlayback = false;
                    pDspChParams->sExtAudioParams.eDecodeMode = BRAP_DSPCHN_DecodeMode_eDecode;
                    pDspChParams->sExtAudioParams.eType = BRAP_DSPCHN_AudioType_ePcm;
                    pDspChParams->sExtAudioParams.eStreamType = BAVC_StreamType_ePes;
                    pDspChParams->sExtAudioParams.bPPMCorrection = false;
                }

                ret = BRAP_DSPCHN_P_CreateDstConfig(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_StartDecPath: BRAP_DSPCHN_P_CreateDstConfig failed %d", ret));
                    ret = BERR_TRACE(ret); 
                    goto exit;                    
                }

#if (BRAP_3548_FAMILY == 1)
                if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)  &&
                        ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort) ||
                         (BRAP_CapInputPort_eHdmi  == pAudioParams->eCapInputPort)
                        ) 
                   )
                {
                    /* The input data flow from SPDIF Rx has to be set properly */
                    BKNI_EnterCriticalSection();
                    if (BRAP_DSPCHN_AudioType_ePcm == pDspChParams->sExtAudioParams.eType)
                    {
                        BRAP_SPDIFRX_P_SwitchToPCM (hRapCh->hRap);
                    }
                    else
                    {
                        BRAP_SPDIFRX_P_SwitchToPES (hRapCh->hRap, 0);
                    }
                    BKNI_LeaveCriticalSection();
                }
#endif
                ret = BRAP_DSPCHN_P_Start(hRapCh->pPath[uiPth]->hDspCh, pDspChParams);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_StartDecPath: BRAP_DSPCHN_P_Start failed %d", ret));
                    ret = BERR_TRACE(ret); 
                    goto exit;
                }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT                        
                if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) &&
                   (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType) &&
                   (hRapCh->pPath[uiPth]->hDspCh->bChSpecificDspCh == false))
                {
                    hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[hRapCh->uiFWMixerIpIndex] = true;
                }
#endif
            }
        }
        else
            BDBG_MSG(("Did **NOT** Call DSPCHN_P_Start"));
    }   

    if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
        if(bWdgRecovery == false)
        {
            ret = BTMR_StartTimer(hRapCh->hTimer, 1000);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartDecPath: BTMR_StartTimer() returned err(%d)",ret));
                return BERR_TRACE(ret);
                goto exit;
            }
            BDBG_MSG(("BRAP_P_StartDecPath: Start timer done!"));
        }
#endif            
    }

    if((BERR_SUCCESS == ret) && (bWdgRecovery == false))
    {
        /* Increment the start count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartDecPath: hRapCh->pPath[uiPth=%d]->uiPthStartCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));
        
        /* Exit successfully */
        goto exit;    
    }

exit: 
    BDBG_MSG(("StartDecPath Done!"));
    BDBG_LEAVE(BRAP_P_StartDecPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that stops a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_StopDecPath(
	BRAP_ChannelHandle 			hRapCh,     /* [in] RAP Channel handle */
    const unsigned int          uiPth       /* [in] Path idx corresponding 
                                               to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;

#if  (BRAP_7405_FAMILY ==1)
    unsigned int    uiPp= 0,uiChPair  = 0;
    bool bPrimary[BRAP_MAX_ASSOCIATED_GROUPS] = {false,false,false,false};
    BRAP_ChannelHandle hStartedChannel[BRAP_MAX_ASSOCIATED_GROUPS] = {NULL,NULL,NULL,NULL};
    unsigned int i = 0;
    bool bOtherChannelStarted = false;
    unsigned int ui32RegVal=0;
#if  (BRAP_7550_FAMILY !=1)    
    unsigned int uiBlkId=0,uiBlkOffset=0;    
#endif
#endif
    bool                        bFMMPathAllocated = true;
    
    BDBG_ENTER(BRAP_P_StopDecPath);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("StopDecPath: Returning success for PCMPB compress path\n"));
        BDBG_LEAVE(BRAP_P_StopDecPath);
        return BERR_SUCCESS;        
    }
    
    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));    
    
    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthStartCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_StopDecPath: Dec Path start count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;

    BDBG_MSG(("BRAP_P_StopDecPath: For uiPth=%d New uiPthStartCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

    /* If the new start count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthStartCnt)
    {
        BDBG_MSG(("BRAP_P_StopDecPath: uiPthStartCnt = %d so not closing resources!"));

        /* DSPCHN Stop need not be called but remove the corresponding input from FW Mixer task */
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        if((BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)) && 
           ((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing) ||
            (hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing)))
        {            
            ret  = BRAP_DSPCHN_P_AddRemoveInputToTask(hRapCh, hRapCh->pPath[uiPth]->hDspCh, false, NULL);
            if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_DSPCHN_P_AddRemoveInputToTask returned error"));
                goto exit;
            }

            hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[hRapCh->uiFWMixerIpIndex] = false;
        }
#endif        
        BDBG_LEAVE(BRAP_P_StopDecPath);
        return BERR_SUCCESS;
    }
    else
    {
        hRapCh->pPath[uiPth]->uiPthStartCnt++;
    }
    
#if BRAP_P_WATERMARK_WORKAROUND==1
	if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
	{
		ret = BTMR_StopTimer(hRapCh->hTimer);
		if ( ret != BERR_SUCCESS )
		{
			BDBG_ERR(("BRAP_P_StopDecPath: BTMR_StopTimer() returned err(%d)",ret));	
			ret = BERR_TRACE(ret);
			return ( ret );
		}
	}
#endif  	
#if (BRAP_7405_FAMILY == 1)
    /* Program the Ramp Amount */
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        ret = BRAP_P_GetOtherStartedChannel(hRapCh,bPrimary,hStartedChannel);
        if(BERR_SUCCESS != ret)
        {
            return BERR_TRACE(ret);
        }                
        for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
        {
            if(NULL != hStartedChannel[i])
            {
                bOtherChannelStarted = true;
                break;
            }            
        }
        if(false == bOtherChannelStarted)
        {
            for(uiChPair = 0; uiChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChPair++)
            {
                for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                {
                    if(NULL == hRapCh->pPath[uiPth]->sOp[uiChPair][uiPp].hSpdifFm)
                        continue;
    
                    BRAP_Write32 (hRapCh->hRegister,
                                  BCHP_AUD_FMM_MS_CTRL_FW_RAMP_AMOUNT_0 + hRapCh->pPath[uiPth]->sOp[uiChPair][uiPp].hSpdifFm->ui32Offset, 
                                  0x800); 
                }
            }
        }
    }
#endif

    /* Stop the DSP channel, if any in this path */
    if(NULL != hRapCh->pPath[uiPth]->hDspCh)
    {  
        BDBG_MSG(("Calling DSPCHN_P_Stop"));
        ret = BRAP_DSPCHN_P_Stop(hRapCh->pPath[uiPth]->hDspCh);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StopDecPath: BRAP_DSPCHN_P_Stop failed %d",ret));
        	return BERR_TRACE(ret); 
        }
    }
    else
        BDBG_MSG(("Did **NOT** Call DSPCHN_P_Stop"));

    if(true == bFMMPathAllocated)
    {
        /* Stop all internal module handles */
        ret = BRAP_P_StopFmmModuleHandles(hRapCh, uiPth);
        if(BERR_SUCCESS != ret)
        {
        	BDBG_ERR(("BRAP_P_StopDecPath: StopFmmModuleHandles failed %d",ret));
        	return BERR_TRACE(ret); 
        }

#if (BRAP_7405_FAMILY == 1)
    /* Program the Ramp Amount */
        bOtherChannelStarted =false;

        ret = BRAP_P_GetOtherStartedChannel(hRapCh,bPrimary,hStartedChannel);
        if(BERR_SUCCESS != ret)
        {
            return BERR_TRACE(ret);
        }                
        for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
        {
            if(NULL != hStartedChannel[i])
            {
                    bOtherChannelStarted = true;
                    break;
            }            
        }
        
        if(false == bOtherChannelStarted)
        {
            ui32RegVal = BRAP_Read32 (hRapCh->hRegister,BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP);

            ui32RegVal &= ~(BCHP_MASK (    
                            AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, 
                            VOLUME_RAMP_STEP));
            
            ui32RegVal |= (BCHP_FIELD_DATA (    
                                AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, 
                                VOLUME_RAMP_STEP, 
                                0x00));

            BRAP_Write32 (hRapCh->hRegister, BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, ui32RegVal);

#if (BRAP_7550_FAMILY != 1)
            for (uiBlkId = 0; uiBlkId < BRAP_RM_P_MAX_SRC_BLCK; uiBlkId++)
            {
                uiBlkOffset = 0;
#if ( BRAP_RM_P_MAX_SRC_BLCK > 1 )    
                uiBlkOffset = (BCHP_AUD_FMM_SRC_CTRL1_STRM_ENA - BCHP_AUD_FMM_SRC_CTRL0_STRM_ENA) * uiBlkId;
#endif
                ui32RegVal = BRAP_Read32 (hRapCh->hRegister,BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset);

                ui32RegVal &= ~(BCHP_MASK (    
                                AUD_FMM_SRC_CTRL0_RAMP_STEP, 
                                STEP_SIZE));
                
                ui32RegVal |= (BCHP_FIELD_DATA (    
                                    AUD_FMM_SRC_CTRL0_RAMP_STEP, 
                                    STEP_SIZE, 
                                    0x00));
                BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset, ui32RegVal);  
            }            
#endif    
        }
#endif
    }


    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;
exit:    
    BDBG_LEAVE(BRAP_P_StopDecPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts a Capture path.
**************************************************************************/
BERR_Code 
BRAP_P_StartCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    bool bCompress = false;
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
    unsigned int i = 0;
#endif
    bool                        bWdgRecovery = false;
   
    BDBG_ENTER(BRAP_P_StartCapPath);

	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    /* Check if the path has already been started. If yes, just increment the 
       count and return success. */
    if((bWdgRecovery == false) 
        && (0 != hRapCh->pPath[uiPth]->uiPthStartCnt))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartCapPath: Cap Path %d was already started. " 
                "New start count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

        /* Return success */
        BDBG_LEAVE (BRAP_P_StartCapPath);
        return BERR_SUCCESS;
    }

    /* Start all internal module handles */
    ret = BRAP_P_StartFmmModuleHandles(hRapCh, pAudioParams, uiPth, bCompress);
    if(BERR_SUCCESS != ret)
    {
    	BDBG_ERR(("BRAP_P_StartCapPath: BRAP_P_StartFmmModuleHandles failed %d",
            ret));
    	return BERR_TRACE(ret); 
    }
    /* TODO: Do we need to do SetSamplingRate As in previous Chips ?*/

    /* TODO: Check if it is correct */
#if (BRAP_P_WATERMARK_WORKAROUND == 1)
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
    if( 
        ( (pAudioParams->eCapMode == BRAP_CaptureMode_eCaptureOnly) ||
          ( 
            (hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
          )
        ) &&
        (bWdgRecovery == false) &&
        (0 != uiPth)
      )
    {
#ifdef AUTOTRAP
        ret = BTMR_StartTimer(hRapCh->hTimer1, 1000);
#else
        ret = BTMR_StartTimer(hRapCh->hTimer, 1000);
#endif /* AUTOTRAP */
    	if(ret != BERR_SUCCESS)
    	{
    		BDBG_ERR(("BRAP_CAP_Start: BTMR_StartTimer() returned err(%d)",ret));
    		ret = BERR_TRACE(ret);
    	}
    	BDBG_MSG(("BRAP_CAP_Start: Start timer done!"));
            break;
        }
    }
#endif

    if((BERR_SUCCESS == ret) && (bWdgRecovery == false))
    {
        /* Increment the start count */
        hRapCh->pPath[uiPth]->uiPthStartCnt++;

        BDBG_MSG(("BRAP_P_StartCapPath: hRapCh->pPath[uiPth=%d]->uiPthStartCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));
        
        /* Exit successfully */
        goto exit;    
    }

exit:
    BDBG_LEAVE(BRAP_P_StartCapPath);
    return ret;
}
/**************************************************************************
Summary:
    Private function that stops a capture path.
**************************************************************************/
BERR_Code 
BRAP_P_StopCapPath(
	BRAP_ChannelHandle 			hRapCh,     /* [in] RAP Channel handle */
    const unsigned int          uiPth       /* [in] Path idx corresponding 
                                               to pPath[] array element */
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
#if (BRAP_P_WATERMARK_WORKAROUND==1)
    unsigned int i = 0;
#endif
    BDBG_ENTER(BRAP_P_StopCapPath);

    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthStartCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_StopCapPath: Cap Path start count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;

    BDBG_MSG(("BRAP_P_StopCapPath: For uiPth=%d New uiPthStartCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthStartCnt));

    /* If the new start count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthStartCnt)
    {
        BDBG_MSG(("BRAP_P_StopCapPath: uiPthStartCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_StopCapPath);
        return BERR_SUCCESS;
    }
    else
    {
        hRapCh->pPath[uiPth]->uiPthStartCnt++;
    }

    
#if (BRAP_P_WATERMARK_WORKAROUND==1)
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
             == BRAP_AudioDst_eRingBuffer))
        {
#ifdef AUTOTRAP
            ret = BTMR_StopTimer(hRapCh->hTimer1);
#else
	        ret = BTMR_StopTimer(hRapCh->hTimer);
#endif /* AUTOTRAP */
	        if ( ret != BERR_SUCCESS )
	        {
		        BDBG_ERR(("BRAP_P_StopCapPath: BTMR_StopTimer() returned err(%d)",
                          ret));	
		        ret = BERR_TRACE(ret);
		        return ( ret );
	        }
        }
    }
#endif  	

    /* Stop all internal module handles */
    ret = BRAP_P_StopFmmModuleHandles(hRapCh, uiPth);
    if(BERR_SUCCESS != ret)
    {
    	BDBG_ERR(("BRAP_P_StopCapPath: StopFmmModuleHandles failed %d",ret));
    	return BERR_TRACE(ret); 
    }

    /* Decrement the start count */
    hRapCh->pPath[uiPth]->uiPthStartCnt--;	
    BDBG_LEAVE(BRAP_P_StopCapPath);
    return ret;
}
/**************************************************************************
Summary:
    Private function that opens a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_OpenDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth,      	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    unsigned int                uiNumCapPath    /* [in] If path is feeding to 
                                                   a capture path */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    bool                    bCompress = false,bAdaptiveRateEnable=false;
    BRAP_ChannelType        eChType = BRAP_ChannelType_eMax;
    BRAP_Handle             hRap = NULL;
    BRAP_RM_P_ResrcReq      *psRsrcReq = NULL;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt = NULL;
    bool                    bLfeOn = false;
    BRAP_OutputMode         eInAudMode = BRAP_OutputMode_eLast;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            dst = 0;
    unsigned int            i=0, j=0,uiAssocId=0, k= 0;
#if (BRAP_7550_FAMILY != 1)
    unsigned int            uiPthId = 0, uiChp = 0, uiPrllPth = 0;
    BRAP_CapInputPort       eCapPort;
    BRAP_BufDataMode        eBufDataMode;
#endif    
    BRAP_ChannelHandle      hMasterCh = NULL;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    BRAP_P_ObjectHandles    *pTempPth=NULL;
    bool                    bFound = false, bIntCapPortFound = false;
    unsigned int            uiNumRateMngrsAlloctd = 0;    
    unsigned int            uiNumPathsNeedRateCtrl = 0;
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];    
    BRAP_ChannelHandle      hStartedAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
    BAVC_AudioSamplingRate  eInputSamplingRate;     
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    bool                    bFMMPathAllocated = true;
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
    uint32_t                uiNumBuffers=0,uiFreeIndex=BRAP_INVALID_VALUE;
    BRAP_RBUF_P_Settings    sRBufSettings;
#endif    
    BDBG_ENTER(BRAP_P_OpenDecPath); 
    BDBG_MSG(("BRAP_P_OpenDecPath CALLED!!!"));
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    hRap = hRapCh->hRap;
    BDBG_ASSERT(hRap);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("OpenDecPath: Returning success for PCMPB compress path\n"));
        goto exit;        
    }    

	/* Malloc large structures */
	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
	if ( NULL==pPvtDstDetails )
	{
	    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto free_rsrc;                                
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));
                            
    /* Check if this is a watchdog recovery. */
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    if(false == bWdgRecovery)
    {
        /* Check if the path has already been opened. If yes, just increment the 
           count and return success. */
        if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
        {
            /* Increment the open count */
            hRapCh->pPath[uiPth]->uiPthOpenCnt++;

            BDBG_MSG(("BRAP_P_OpenDecPath: Dec Path %d was already open. " 
                    "New open count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

            /* Return success */
            BDBG_LEAVE (BRAP_P_OpenDecPath);
            return BERR_SUCCESS;
        }

    	/* Malloc large structures */
    	psRsrcReq = hRap->sOpenTimeMallocs.psResrcReq;
    	if ( NULL==psRsrcReq )
    	{
    			ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
				goto free_rsrc;
    	}
        BKNI_Memset(psRsrcReq, 0, sizeof(BRAP_RM_P_ResrcReq));          
    	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
    	if ( NULL==psRsrcGrnt )
    	{
    			ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
				goto free_rsrc;
    	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));        	
        /* Invalid init the resource request */
        BRAP_RM_P_InitResourceReq(psRsrcReq);
    }

    /* Validate parameters */    
    ret = BRAP_P_ValidateDecPathParams(hRapCh, pAudioParams);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);                        
    	goto exit;
    }
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        hStartedAssocCh[uiAssocId]=NULL;
        bPrimary[uiAssocId]=false;
    }
                
    if(BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath)
    {
        bCompress = true;
    }
    else
    {
        bCompress = false;
    } 

    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }
    BDBG_MSG(("bFMMPathAllocated=%d",bFMMPathAllocated));
    
    ret = BRAP_P_IsPathOutputCompress(hRapCh,uiPth,&bCompress);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_IsPathOutputCompress() returned err(%d)",ret));	
        ret = BERR_TRACE(ret); 
        goto exit;                
    }
    
    BRAP_P_EnableAdaptiveRate(hRapCh,&bAdaptiveRateEnable,pAudioParams->sDspChParams.bPPMCorrection);
    
    eChType = hRapCh->eChannelType;

    if(false == bWdgRecovery) 
    {
        if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
            ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
        {
            pTempPth = hRapCh->pPath[hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx];
        }
        if(BRAP_ChannelType_eDecode == eChType)
        {        
            /* XPT Channel number for the current channel. This is used by the 
               DSP Firmware to determine the CDB and ITB used for the current 
               DSP Context */
            hRapCh->uiXptChannelNo = pAudioParams->sXptContextMap.ContextIdx;
            hRapCh->sXptContextMap = pAudioParams->sXptContextMap;

            if((hRapCh->eChannelSubType == BRAP_ChannelSubType_ePrimary) ||
               (hRapCh->eChannelSubType == BRAP_ChannelSubType_eNone) ||
               (hRapCh->eChannelSubType == BRAP_ChannelSubType_eSecondary))
            {
                hRapCh->bInputLfeOn = pAudioParams->bInputLfePresent;
                hRapCh->eInputAudMode = pAudioParams->eInputAudMode;
            }
        }

        if(true == bFMMPathAllocated)
        {
            /* Form the Resource Request */
            psRsrcReq->eChType = hRapCh->eChannelType;
            psRsrcReq->eChSubType = hRapCh->eChannelSubType;
            psRsrcReq->ePath = hRapCh->pPath[uiPth]->eUsgPath;

            /* To prepare the resource request, we need to know what all channels 
               are required for this path. Get this info. */
            /* TODO: This code can be generalized later. */
            if(BRAP_ChannelType_eDecode == eChType)
            {
                eInAudMode = hRapCh->eInputAudMode;
                /*bLfeOn = hRapCh->bInputLfeOn;*/
                if(hRapCh->pPath[uiPth]->pDstDetails[0] != NULL)
                {
                    if(hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        bLfeOn = hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sOpDetails.bLfeOn;
                    else
                        bLfeOn = false;
                }
                else
                {
                    bLfeOn = false;
                }
            }
            else if(BRAP_ChannelType_ePcmPlayback == eChType)
            {
                /* TODO: This code has to be revisited. Using eCurOpMode to 
                   get rid of the seg fault due to pInputAudMode in MixerSrcRsrcLayout */
                /* Another assumption here is - a PB channel is always stereo */   
                hRapCh->eInputAudMode = BRAP_OutputMode_e2_0;
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[uiPth]->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == hRapCh->pPath[uiPth]->eUsgPath))
                {
                    eInAudMode = BRAP_OutputMode_e2_0;            
                }
                else
                {
                    if(BRAP_BufDataMode_eStereoNoninterleaved == pAudioParams->eBufDataMode)
                        eInAudMode = BRAP_OutputMode_e2_0;
                    else
                        eInAudMode = BRAP_OutputMode_e1_0;
                }

                hRapCh->bInputLfeOn = false;
            }
#if (BRAP_7550_FAMILY != 1)        
            else if(BRAP_ChannelType_ePcmCapture == eChType)
            {
                bLfeOn = false;
                hRapCh->bInputLfeOn = false;
                /* As of now, decode path is required only for external capture */
                /* Find out what buffer data mode is configured for capture channel.
                 * TODO: This code needs to be revisited to remove hardcoding
                 * pPath[0], sCapPort[0][0] etc */
                BDBG_ASSERT(NULL != hRapCh->pPath[0]); 
                eCapPort = hRapCh->pPath[0]->sCapPort[0][0].hCapPort->eCapPort;
                eBufDataMode = hRap->sInputSettings[eCapPort].eBufDataMode;
                if(BRAP_BufDataMode_eStereoNoninterleaved == eBufDataMode)
                    eInAudMode = BRAP_OutputMode_e2_0;
                else
                    eInAudMode = BRAP_OutputMode_e2_0;/*Set the INputmode 2_0, and ebufdataMode will later will be used to configure BUFFER_PAIR_ENABLE*/
                    hRapCh->eInputAudMode = eInAudMode;
            }
#endif
            /* Update the info in pPath->sInPathProp */
            /* TODO: Remove hardcoding to 0 if in future number of in link for path
               become more than one */

    /*        if(false == bCompress)*/
            if(1) /* 7043 Passthru + RBUF Cap Test */
            {
                if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
                    ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
                {
                    ret = BRAP_P_GetAudOpModeProp(eInAudMode, bLfeOn, &sOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp"
                            " returned %d",ret));
                        ret = BERR_TRACE(ret);
                        goto free_rsrc;
                    }
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                	{
            			/* For the input audio mode, this audio channel exists, 
            			   so RBuf is required to be allocated */
                        /* Note: For a DEC channel, If there is just 1 channel valid in a channel pair,
                           even then DSP requires ring buffer for both the channels. 
                           DSP will write 0's in other channel. So. take care of that
                           allocation here. */                   
                		if((sOpAudModeProp.bChnExists[eChP*2] == true)||
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                		{
                			psRsrcReq->sRbufReq[eChP].bAllocate = false;
                            psRsrcReq->sRbufReq[eChP].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                            psRsrcReq->sSrcChReq[eChP].bAllocate = false;
                		}
                    }
                }
                else if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedPath)
                           ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDownmixedMixPath)
                               ||((BRAP_P_IsPointerValid((void *)hRapCh->pPath[uiPth]->pDstDetails[0])) &&
                                  (((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.
                            sOpDetails.eAudioMode == BRAP_OutputMode_e2_0)
                                &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                            ||((hRapCh->pPath[uiPth]->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                &&(hRapCh->pPath[uiPth]->pDstDetails[0]->uDstDetails.sRBufDetails.eAudioMode == BRAP_OutputMode_e2_0)
                                    &&(hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))))
                           ||(true == bCompress))
                {
                    BDBG_MSG(("Populating Resource request for BRAP_P_UsgPath_eDownmixedPath"));
                    /*If its a downmixed Path allocate only one pair of Rbuf */
                    psRsrcReq->sRbufReq[0].bAllocate = true;
                    psRsrcReq->sRbufReq[0].eBufDataMode =   BRAP_BufDataMode_eStereoNoninterleaved;                
                    psRsrcReq->sSrcChReq[0].bAllocate = true;
                }         
                else
                {
                    /* Prepare resource request for rbuf and srcch */
                    ret = BRAP_P_GetAudOpModeProp(eInAudMode, bLfeOn, &sOpAudModeProp);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp"
                            " returned %d",ret));
                        ret = BERR_TRACE(ret);
                        goto free_rsrc;
                    }

                    /* Resource request for Rbufs and SrcChs */
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                    {
            			/* For the input audio mode, this audio channel exists, 
            			   so RBuf is required to be allocated */
                        /* Note: For a DEC channel, If there is just 1 channel valid in a channel pair,
                           even then DSP requires ring buffer for both the channels. 
                           DSP will write 0's in other channel. So. take care of that
                           allocation here. */                   
                		if((sOpAudModeProp.bChnExists[eChP*2] == true) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                		{
#if (BRAP_7405_FAMILY == 1)            		
                            if(!((BRAP_ChannelType_ePcmPlayback== eChType)
                                &&(hRapCh->bOpenTimeWrToRbuf == true)
                                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif                            
                            {            		
                		    /* Rbuf */
                			psRsrcReq->sRbufReq[eChP].bAllocate = true;
                            /* SrcCh */
                            psRsrcReq->sSrcChReq[eChP].bAllocate = true;
              		        }
                            psRsrcReq->sRbufReq[eChP].eBufDataMode =   BRAP_BufDataMode_eStereoNoninterleaved;
          		        }
                        else if(
                           ((sOpAudModeProp.bChnExists[eChP*2] == true) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == false)) ||
                           ((sOpAudModeProp.bChnExists[eChP*2] == false) &&
                           (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                           ) 
                        {
#if (BRAP_7405_FAMILY == 1)            		
                            if(!((BRAP_ChannelType_ePcmPlayback== eChType)
                                &&(hRapCh->bOpenTimeWrToRbuf == true)
                                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif   
                            {
                    		    /* Rbuf */
                                psRsrcReq->sRbufReq[eChP].bAllocate = true;
                    		    /* SrcCh */
                                psRsrcReq->sSrcChReq[eChP].bAllocate = true;                             
                            }
                            if(BRAP_ChannelType_eDecode == eChType)
                            {
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                    BRAP_BufDataMode_eStereoNoninterleaved;
                            }
                            else if((BRAP_ChannelType_ePcmPlayback == eChType)||
                                (BRAP_ChannelType_ePcmCapture == eChType))
                            {
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                    pAudioParams->eBufDataMode;
                            }
                            else 
                            {
                                BDBG_ASSERT(0); /* TODO : remove this once PB etc is implemented */
                                /* TODO: Enable this later for PB 
                                psRsrcReq->sRbufReq[eChP].eBufDataMode = hRapCh->eBufDataMode;
                                
                                */
                            }                    
                        }
                    } /* for eChP */

                    if(true == bAdaptiveRateEnable)
                    {
                        /* Prepare resource request for AdaptRateCtrl */
                        /* AdaptRateCtrl is only allocated for stereo channel */
                        if((sOpAudModeProp.bChnExists[0] == true) 
                            && (sOpAudModeProp.bChnExists[1] == true)) /* i.e LR Channel Pair*/
                        {
                            bool    bPPMCorrectionSuprtd = true;
                            
                            for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                            {
                                /* To consider RBuf Dstn as well when compressed capture is supported */
                                if((hRapCh->pDstDetails[i] != NULL) &&
                                   (hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eOutputPort))
                                {
                                    eOp = hRapCh->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[0];

                                    if((eOp == BRAP_OutputPort_eMai)   ||
                                       (eOp == BRAP_OutputPort_eSpdif) ||
                                       (eOp == BRAP_OutputPort_eSpdif1))
                                    {
                                        if((hRap->bOpSettingsValid[eOp] == true) &&
                                           (hRap->sOutputSettings[eOp].bCompressed == true))
                                        {
                                            bPPMCorrectionSuprtd = false;
                                            BDBG_MSG(("Adaptive Rate Control cannot be enabled if any of "
                                                "Raptor channel destinations carry compressed data"));
                                            break;
                                        }
                                    }
                                }
                            }

                            if(bPPMCorrectionSuprtd == true)
                            {
                            if((sOpAudModeProp.bChnExists[2] == true) /*Ls*/
                                ||(sOpAudModeProp.bChnExists[3] == true)/*Rs*/
                                ||(sOpAudModeProp.bChnExists[4] == true)/*Center*/
                                ||(sOpAudModeProp.bChnExists[6] == true) /*Lr*/
                                ||(sOpAudModeProp.bChnExists[7] == true))/*Rr*/
                            {
                                    bPPMCorrectionSuprtd = false;
                                BDBG_MSG(("AdaptRateCtrl is not allocated for Multichannel"));
                            }
                            else
                            {
                                /* Count the total number of Rate Managers allocated till now.*/    
                                for(i=0; i<BRAP_RM_P_MAX_DEC_CHANNELS; i++)
                                {
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if( (hRap->hRapDecCh[i] != NULL) &&
                                            (hRap->hRapDecCh[i]->pPath[j] != NULL) &&
                                                (BRAP_RM_P_INVALID_INDEX != 
                                                    hRap->hRapDecCh[i]->pPath[j]->sRsrcGrnt.uiAdaptRateCtrlId[0])
                                               )
                                        {
                                            uiNumRateMngrsAlloctd += 1;
                                        }
                                    }
                                }

                                /* Count the number of paths in the channel that are yet to be allocated Rate Managers.*/    
                                for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                {
                                    if((hRapCh->pPath[j] != NULL) &&
                                        ((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                                         ||(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_ePPBranch)) &&
                                        (BRAP_RM_P_INVALID_INDEX == hRapCh->pPath[j]->sRsrcGrnt.uiAdaptRateCtrlId[0]) 
                                      )
                                    {
                                        uiNumPathsNeedRateCtrl += 1;
                                    }
                                }
                                
                                    if( !(uiNumPathsNeedRateCtrl <= (BRAP_RM_P_MAX_ADAPTRATE_CTRL - uiNumRateMngrsAlloctd)))
                                    {
                                        bPPMCorrectionSuprtd = false;
                                        BDBG_MSG(("Not enough Rate Managers available, Adapative Rate control is disabled for this channel %x", hRapCh));
                                    }
                                }
                            } /* end of if(bPPMCorrectionSuprtd == true) */
                            if(bPPMCorrectionSuprtd == true)
                                {
                        		    /* AdaptRateCtrl Request*/
                                    psRsrcReq->sAdaptRateCtrlReq[0].bAllocate = true;
                                BDBG_MSG(("Populating resource request for AdaptRateCtrl"));
                            }
                        } 
                    } /*end of if(true == pAudioParams->sDspChParams.bPPMCorrection)*/
                } /*end of else at if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)...*/

    		    BDBG_MSG(("uiNumCapPath > %d", uiNumCapPath));

                if(0 != uiNumCapPath)
                {
                    for(i=0;i<uiNumCapPath;i++)
                    {
                        for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH;j++)
                        {
                            if(NULL == hRapCh->pDstDetails[j])
                            {
                                continue;
                            }
                            
                            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[j]->eAudioDst)
                            {
#if (BRAP_7550_FAMILY != 1)                        
                                for(k =0 ; k < BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hRapCh->pPath[uiPth]->pDstDetails[k] != NULL)
                                    {
                                        if((hRapCh->pPath[uiPth]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                            &&(hRapCh->pPath[uiPth]->pDstDetails[k] == hRapCh->pDstDetails[j]))
                                            break;
                                    }
                                }

                                if(k < BRAP_P_MAX_DST_PER_RAPCH)
                                {
        		                    BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sRBufDetails.eAudioMode > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode));
                                    
                            		BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sRBufDetails.bLfeOn > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.bLfeOn));
                                
                                    hRapCh->sIntDst[i].eInputAudMode = hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode;
                                    hRapCh->sIntDst[i].bLfeOn = false;
                                    /* 7440 A0 transcoder require input SR of data to DSP at 48kHz. */
        /*                            hRapCh->sIntDst[i].eInputSR = BAVC_AudioSamplingRate_e48k;*/
                                    /* This was wrong, we should set it to input sampling rate */
                                    /* RBUF has a sampling rate associated now */
                                    /*hRapCh->sIntDst[i].eInputSR = hRapCh->eInputSamplingRate;*/
                                    hRapCh->sIntDst[i].eInputSR = hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eSampleRate;

                                    /* Get the other started channel(if any) from the association. bPrimary is not being used*/
                                    ret = BRAP_P_GetOtherStartedChannel(hRapCh, bPrimary, hStartedAssocCh);
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;        
                                    }
                                    
                                    ret = BRAP_P_GetAssocId(hRapCh, hRapCh->pPath[uiPth]->pDstDetails[k], &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;
                                    }             

                                    if((hStartedAssocCh[uiAssocId] == NULL)
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
        /* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
           and no resources are shared among them as decode channels output to DRAM and PB to RBUF */
                                       ||(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
#endif           
                                      )
                                    {
                                        /* Allocate Internal Cap ports and store them as internal Destinations */
                                        /* Prepare resource request for cap port */
                                        ret = BRAP_P_GetAudOpModeProp(
                                                        hRapCh->sIntDst[i].eInputAudMode, 
                                                        hRapCh->sIntDst[i].bLfeOn,
                                                        &sOpAudModeProp);
                                        if(BERR_SUCCESS != ret)
                                        {
                                            BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp returned %d",ret));
                                            ret = BERR_TRACE(ret);
                                            goto free_rsrc;
                                        }

                                        /* Resource request for Capport */
                                        for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                        {
                                            if((sOpAudModeProp.bChnExists[eChP*2] == true) ||
                                               (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                                            {
                                    		    /* Resource request for internal capport */
                                    			psRsrcReq->sCapReq[eChP][i].bAllocate = true;
                                                psRsrcReq->sCapReq[eChP][i].eCapPort = BRAP_CapInputPort_eMax;
                                                psRsrcReq->sFsTmgSrcReq.bAllocate = true;
                                                psRsrcReq->sFsTmgSrcReq.uiFsTmgSrcId = BRAP_RM_P_INVALID_INDEX;
                                  		    }
                          	            }
                              	    }
                                    else
                                    {
                                        for(uiPthId=0; uiPthId < BRAP_P_MAX_PATHS_IN_A_CHAN; uiPthId++)
                                        {
                                            if(NULL == hStartedAssocCh[uiAssocId]->pPath[uiPthId])
                                            {
                                                continue;
                                            }
                                            for(uiChp=0; uiChp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChp++)
                                            {
                                                for(uiPrllPth=0; uiPrllPth < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiPrllPth++)
                                                {   
                                                    if((NULL != hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort) &&
                                                       (BRAP_CapInputPort_eIntCapPort3 >= 
                                                         hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort))
                                                    {
                                            		    /* Mixing case: Internal Capture port is already allocated for this association */
                                            			psRsrcReq->sCapReq[uiChp][uiPrllPth].bAllocate = true;
                                                        psRsrcReq->sCapReq[uiChp][uiPrllPth].eCapPort = 
                                                            hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort;
                                                        /* uiFsTmgSrcId is not used anywhere */
                                                        bFound = true;
                                                        break;
                                                    }
                                                }
                                                if(bFound == true)
                                                    break;
                                            }
                                            if(bFound == true)
                                                break;
                                        }
                                    }
                              	}
#else
                                BDBG_ERR(("Error: Ringbuffer destination found in hRapCh->pDstDetails[#d] = %x is not supported",
                                                    j,hRapCh->pDstDetails[j]));
                                ret = BERR_TRACE(BERR_NOT_SUPPORTED);
                                goto exit;
#endif
                          	}
        		            else if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[j]->eAudioDst)
            			 	{
                                BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;
                                bool                    bPrimaryPresent[BRAP_MAX_ASSOCIATED_GROUPS];
                                BRAP_ChannelHandle      hStrtdAssocCh[BRAP_MAX_ASSOCIATED_GROUPS];
                                for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; ++uiAssocId)
                                {
                                    bPrimaryPresent[uiAssocId] = false;
                                    hStrtdAssocCh[uiAssocId] = NULL;
                                }
                                
                                	/* Initialize before use */
                                BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                                
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                            hRapCh->pDstDetails[j],
                                            pPvtDstDetails,
                                            &uiAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto free_rsrc;
                                }
                                eAudioProcessing = pPvtDstDetails->eAudioProcessing;
            		            BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.eAudioProcessing > %d", eAudioProcessing));

#if (BRAP_7550_FAMILY != 1)                            
                                /* Capture path for Association Network */
                                if((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath) &&
                                   (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                                {
        		                    BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.eAudioMode > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eAudioMode));
                                    
                            		BDBG_MSG(("hRapCh->pDstDetails[j].uDstDetails.sOpDetails.bLfeOn > %d", 
                                      hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.bLfeOn));
                                
                                    hRapCh->sIntDst[i].eInputAudMode = hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eAudioMode;
                                    hRapCh->sIntDst[i].bLfeOn = false;
                                    hRapCh->sIntDst[i].eInputSR = BAVC_AudioSamplingRate_e48k; /* By default set to 48khz */
                                    
                                    /* Get the other started channel(if any) from the association. bPrimary is not being used*/
                                    ret = BRAP_P_GetOtherStartedChannel(hRapCh, bPrimary, hStartedAssocCh);
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;        
                                    }
                                    
                                    ret = BRAP_P_GetAssocId(hRapCh, hRapCh->pDstDetails[j], &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto exit;
                                    }             
                                
                                    if((hStartedAssocCh[uiAssocId] == NULL)
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
/* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
   and no resources are shared among them as decode channels output to DRAM and PB to RBUF */
                                        ||(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
#endif           
                                      )
                                    {
                                        /* Allocate Internal Cap ports and store them as internal Destinations */
                                        /* Prepare resource request for cap port */
                                        ret = BRAP_P_GetAudOpModeProp(
                                                        hRapCh->sIntDst[i].eInputAudMode, 
                                                        hRapCh->sIntDst[i].bLfeOn,
                                                        &sOpAudModeProp);
                                        if(BERR_SUCCESS != ret)
                                        {
                                            BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_GetAudOpModeProp returned %d",ret));
                                            ret = BERR_TRACE(ret);
                                            goto free_rsrc;
                                        }

                                        /* Resource request for Capport */
                                        for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                        {
                                            if((sOpAudModeProp.bChnExists[eChP*2] == true) ||
                                               (sOpAudModeProp.bChnExists[(eChP*2)+1] == true))
                                            {
                                    		    /* Resource request for internal capport */
                                    			psRsrcReq->sCapReq[eChP][i].bAllocate = true;
                                                psRsrcReq->sCapReq[eChP][i].eCapPort = BRAP_CapInputPort_eMax;
                                                psRsrcReq->sFsTmgSrcReq.bAllocate = true;
                                                psRsrcReq->sFsTmgSrcReq.uiFsTmgSrcId = BRAP_RM_P_INVALID_INDEX;
                                  		    }
                          	            }
                              	    }
                                    else
                                    {
                                        for(uiPthId=0; uiPthId < BRAP_P_MAX_PATHS_IN_A_CHAN; uiPthId++)
                                        {
                                            if(NULL == hStartedAssocCh[uiAssocId]->pPath[uiPthId])
                                            {
                                                continue;
                                            }
                                            for(uiChp=0; uiChp < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uiChp++)
                                            {
                                                for(uiPrllPth=0; uiPrllPth < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiPrllPth++)
                                                {   
                                                    if((NULL != hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort) &&
                                                       (BRAP_CapInputPort_eIntCapPort3 >= 
                                                         hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort))
                                                    {
                                            		    /* Mixing case: Internal Capture port is already allocated for this association */
                                            			psRsrcReq->sCapReq[uiChp][uiPrllPth].bAllocate = true;
                                                        psRsrcReq->sCapReq[uiChp][uiPrllPth].eCapPort = 
                                                            hStartedAssocCh[uiAssocId]->pPath[uiPthId]->sCapPort[uiChp][uiPrllPth].hCapPort->eCapPort;
                                                        /* uiFsTmgSrcId is not used anywhere */
                                                        bFound = true;
                                                        break;
                                                    }
                                                }
                                                if(bFound == true)
                                                    break;
                                            }
                                            if(bFound == true)
                                                break;
                                        }
                                    }
    		                    }
#endif                                
                            }
                        }
                    }
                }
                /* For Mixer-SRC Layout find the audio mode and sampling rate of 
                   master channel */
                /* Resource request for SRCs and Mixers */
                
                /* If Primary Decode Channel present in the association then it is 
                   the master, otherwise current channel is the master */
                   
                for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; ++j)
                {
                    if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
                        continue;
                for (i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
                {
                        if(hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].hPriDecCh[i] != NULL) 
                    {
                            hMasterCh = hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].hPriDecCh[i];
                        }
                    }
                }

                if (NULL == hMasterCh)
                {
                    hMasterCh = hRapCh;
                }
                
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[uiPth]->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == hRapCh->pPath[uiPth]->eUsgPath))
                    
                {
                    /* Currently there is no SR Conversion required in post-mixing path. 
                       At this stage we don't know the stream SR, the outputs will be defaulted 
                       to 48khz, so programming the same, this will force SRC type to 'Bypass' */
                    eInputSamplingRate = BAVC_AudioSamplingRate_e48k;
                }
                else
                {
                    BRAP_P_ConvertSrToEnum(hRapCh->uiInputSamplingRate,&eInputSamplingRate);                                                    
                }
                
                /* Resource request for SRCs and Mixers */
                ret = BRAP_P_MixerSrcRsrcLayout(hRapCh, psRsrcReq, uiPth,
                                    &(hRapCh->pPath[uiPth]->sMixingLevels[0]),
                                    &(hRapCh->sIntDst[0]),hRapCh->eInputAudMode,
                                    bLfeOn,eInputSamplingRate,bCompress);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_MixerSrcRsrcLayout"
                        " returned %d",ret));
                    ret = BERR_TRACE(ret);
                    goto exit;
                }
        	}
            else
            {
    	        int count=0;
    			
                /* Passthru context requires 2 rbufs */
                /* Why should passthru require 2 RBUFs? */
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].eBufDataMode = 
                    BRAP_BufDataMode_eStereoInterleaved;
                /* 1 SrcCh */
                psRsrcReq->sSrcChReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
#if ( (BRAP_7405_FAMILY == 1))			
    			
                /* 1 Src */
                psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].bAllocate = true;
#endif
                /* 1 Mixer */
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].bAllocate = true;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewInput = 1;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].bInputChPair[0] = true;
                psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewOutput = 0;

                /* Update the mixing level info */
                /* TODO: check if sMixingLevels[0] is required to be programmed 
                   with valid values */
                hRapCh->pPath[uiPth]->sMixingLevels[0] = sMixingLevelPropInvalid;
    			count = 0;
                for(dst = 0; dst < BRAP_P_MAX_DST_PER_RAPCH; dst++)
                {
                    BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;

                    if(NULL == hRapCh->pDstDetails[dst])
                    {
                        continue;
                    }

                    	/* Initialize before use */
                BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                 
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                hRapCh->pDstDetails[dst],
                                pPvtDstDetails,
                                &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret =  BERR_TRACE(ret);
                        goto free_rsrc;                    
                    }
                    eAudioProcessing = pPvtDstDetails->eAudioProcessing;

                    if(BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[dst]->eAudioDst)
                    {
                        eOp = hRapCh->pDstDetails[dst]->uDstDetails.sOpDetails.eOutput[0];
                        
#if (BRAP_7405_FAMILY == 1)
                       if(((BRAP_OutputPort_eMai == eOp)||
                           ((BRAP_OutputPort_eI2s5 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s7 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable)))&&
                          (true == hRap->sOutputSettings[eOp].bCompressed))
#else
                       if((
                           ((BRAP_OutputPort_eMai == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s5 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s6 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
                           ((BRAP_OutputPort_eI2s7 == eOp) &&
                            (true == hRap->sOutputSettings[eOp].bHbrEnable))||
    		               (BRAP_OutputPort_eI2s5 == eOp))&&
                          (true == hRap->sOutputSettings[eOp].bCompressed))
#endif                      
                    {
                        /* Got the SPDIF output port carrying compressed data */
    					/*1 Mixing Level supports only 2 compresed output port, Hence Assert*/
    					BDBG_ASSERT(count < 2);
                        hRapCh->pPath[uiPth]->sMixingLevels[0].pDstDetails[count++] = 
                            hRapCh->pDstDetails[dst];
    					psRsrcReq->sSrcMixerReq[0].sMixerReq[0][0].uiNumNewOutput++;     
                    }
                        }
                }
            }

            /* Call resource manager to allocate required resources. */
    		ret = BRAP_RM_P_AllocateResources(hRap->hRm, psRsrcReq, psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: Resource alloc failed with err = %d",
                    ret));
    			ret = BERR_TRACE(ret);
                goto exit;
    		}



            
            if((hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eMixPath)
                ||(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eSharedPP))
            {
                for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                {
                    hRapCh->pPath[uiPth]->hRBuf[eChP] = pTempPth->hRBuf[eChP];
                    hRapCh->pPath[uiPth]->sSrcCh[eChP] = pTempPth->sSrcCh[eChP];
                }
            }
            /* Save Capport allocated in sIntDstDetails */
            if(0 != uiNumCapPath)
            {
                for(i=0;i<uiNumCapPath;i++)
                {
                    bFound = false;
                    for(j=0 ; j< BRAP_RM_P_MAX_INTERNAL_DST; j++)
                    {
                        for(k = 0; k < BRAP_RM_P_MAX_MIXING_LEVELS; k++)
                        {
                            if(hRapCh->pPath[uiPth]->sMixingLevels[k].pIntDstDetails[i] == &(hRapCh->sIntDst[j]))          
                            {
                                for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                                {
                                        hRapCh->sIntDst[j].eCapPort[eChP] = psRsrcGrnt->sCapPortGrnt[eChP][i].eCapPort;

                                        for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH;j++)
                                        {
                                            if(NULL == hRapCh->pDstDetails[j])
                                            {
                                                continue;
                                            }
                                            
                                            if( (bIntCapPortFound == false) &&
                                                (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[j]->eAudioDst))
                                            {
                                                bIntCapPortFound = true;
                                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eCapPort[eChP] = psRsrcGrnt->sCapPortGrnt[eChP][i].eCapPort;
                                                BDBG_MSG(("i=%d, eChp=%d, hRapCh->pDstDetails[%d]->uDstDetails.sRBufDetails.eCapPort[%d]=%d",
                                                    i,eChP,j,eChP,hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eCapPort[eChP]));
                                                break;
                                            }
                                        }
                                }
                                bFound =true;
                                break;
                            }                            
                        }
                        if(bFound == true)
                            break;
                    }
                }
            }

            /* Open all internal module handles */
            ret = BRAP_P_OpenFmmModuleHandles(hRapCh, pAudioParams, uiPth, psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_OpenFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}

            /* Update the resource grant structure in hRapCh */
            ret = BRAP_RM_P_UpdateResrcGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt), 
                                             psRsrcGrnt);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: UpdateResrcGrant failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}

            /* Update the resource grant structure in hRapCh to hold the output
               ports and spdifFm (if any) */
            ret = BRAP_P_UpdateOpResrcGrant(hRapCh, hRapCh->pPath[uiPth], 
                &(hRapCh->pPath[uiPth]->sRsrcGrnt));
            if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_UpdateOpResrcGrant failed %d",
                   ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}        

            /* Prepare linkage info among the resources in the same path */
            ret = BRAP_P_LinkFmmModuleHandles(hRapCh, uiPth);
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_LinkFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}
        }
        else
        {
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
            if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
            {   
                if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                {
                    for(i=0; i<BRAP_P_MAX_FW_STG_INPUTS; i++)
                    {
                        if(hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[i] == false)
                            break;
                    }
                    if(i == BRAP_P_MAX_FW_STG_INPUTS)
                    {
                        BDBG_ERR(("No free DRAM buffer found for InterTask buffer usage"));
                        ret = BRAP_ERR_BAD_DEVICE_STATE;
                        goto free_rsrc;
                    }
                    uiFreeIndex = i;
                    
                    if(BRAP_P_IsMs10UsageMode(hRapCh))
                    {
                        uiNumBuffers = 2;
                    }
                    else
                    {
                        uiNumBuffers = 6; /* Currently 5.1 for MS11 */
                    }
                    i =0;
                    while(i < uiNumBuffers)
                    {
                        ret = BRAP_P_GetRbufFromPool(hRapCh,NULL,hRapCh->pPath[uiPth],false,0,0,&sRBufSettings, 0);          
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret); 
                            goto free_rsrc;
                        }   
                        if(sRBufSettings.sExtSettings.uiSize < BRAP_AF_P_INTERTASK_IOBUFFER_SIZE)
                        {
                            BDBG_ERR(("Buffer size required (%d) for interTask DRAM  is less than required(%d)"
                                ,sRBufSettings.sExtSettings.uiSize,BRAP_AF_P_INTERTASK_IOBUFFER_SIZE));
                            ret = BERR_TRACE(BERR_INVALID_PARAMETER); 
                            goto free_rsrc;                                
                        }
                        hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[uiFreeIndex][i] = (uint32_t)sRBufSettings.sExtSettings.pBufferStart;
                        i++;
                    }
                    hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[uiFreeIndex] = uiNumBuffers;
                }
            }
#endif      
        }
    }
    else /* if watchdog */
    {
        if(true == bFMMPathAllocated)
        {    
            /* Open all internal module handles */
            ret = BRAP_P_OpenFmmModuleHandles(hRapCh, pAudioParams, uiPth, 
                    &(hRapCh->pPath[uiPth]->sRsrcGrnt));
    		if(BERR_SUCCESS != ret)
    		{
    			BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_OpenFmmModuleHandles"
                   " failed %d", ret));
    			ret = BERR_TRACE(ret); 
                goto free_rsrc;
    		}
#if (BRAP_P_WATERMARK_WORKAROUND == 0)
#if (BRAP_P_EDGE_TRIG_INTRPT == 1)
            if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                /* Unmask the Free Mark interrupt */
                ret = BRAP_P_UnmaskInterrupt(hRapCh, BRAP_Interrupt_eFmmRbufFreeByte);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_OpenDecPath: BRAP_P_UnmaskInterrupt() returned err(%d)",ret));
                    ret = BERR_TRACE(ret);
                    goto free_rsrc;
                }
            }
#endif
#endif            
        }
    }
        
    if((BERR_SUCCESS == ret) && (false == bWdgRecovery))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenDecPath: hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
    }

    if(BERR_SUCCESS == ret)
    {
        /* Exit successfully */
        goto exit;
    }
    
free_rsrc:
    /* Free resources */    
    BRAP_RM_P_FreeResources(hRap->hRm, psRsrcGrnt,true);
    if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("Free Resource failed with err = %d",ret));
		ret = BERR_TRACE(ret);
	}
	
exit: 

    BDBG_LEAVE(BRAP_P_OpenDecPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes a decode path.
**************************************************************************/
BERR_Code 
BRAP_P_CloseDecPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    unsigned int            i = 0;
    bool                    bFMMPathAllocated = true;
   
    BDBG_ENTER(BRAP_P_CloseDecPath); 
    BDBG_MSG(("BRAP_P_CloseDecPath CALLED!!!"));
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);

    if((BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath) &&
       (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType))
    {
        BDBG_MSG(("CloseDecPath: Returning success for PCMPB compress path\n"));
        BDBG_LEAVE(BRAP_P_CloseDecPath);
        return BERR_SUCCESS;        
    }
    
    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthOpenCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_CloseDecPath: SM Path open count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the open count */
    hRapCh->pPath[uiPth]->uiPthOpenCnt--;

    BDBG_MSG(("BRAP_P_CloseDecPath: For uiPth=%d New uiPthOpenCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

    /* If the new open count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        BDBG_MSG(("BRAP_P_CloseDecPath: uiPthOpenCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_CloseDecPath);
        return BERR_SUCCESS;
    }

    /* For MS10, MS11 the decode channels output to sepearate task(FW Mixer) through DRAM and not FMM */
    ret = BRAP_P_IsFMMPathAllocated(hRapCh, uiPth, &bFMMPathAllocated);
    if(BERR_SUCCESS!=ret)
    {
        BDBG_ERR(("BRAP_P_IsFMMPathAllocated returned Error!"));
        ret = BERR_TRACE(ret);
        goto exit;
    }    
    
    if(bFMMPathAllocated == true)
    {
#if (BRAP_P_WATERMARK_WORKAROUND == 0)
#if (BRAP_P_EDGE_TRIG_INTRPT == 0)
    	if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    	{
    	    /* Mask the Free Mark interrupt */
    	    ret = BRAP_P_MaskInterrupt(hRapCh, BRAP_Interrupt_eFmmRbufFreeByte);
    		if(ret != BERR_SUCCESS)
    		{
    			BDBG_ERR(("BRAP_PB_Stop: BRAP_P_MaskInterrupt() returned err(%d)",ret));	
                        return BERR_TRACE (ret);            
    		}
    	}
#endif
#endif
        
        /* Check if this is a watchdog recovery. */
    	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

        /* Unlink FMM modules */
        ret = BRAP_P_UnlinkFmmModuleHandles(hRapCh, uiPth);
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: UnlinkFmmModuleHandles failed %d", ret));
    		ret = BERR_TRACE(ret); 
    	}


        /* Remove output ports and spdifFm (if any) from the resource grant 
           structure in hRapCh. This action is just opposite to what is done in
           BRAP_P_UpdateOpResrcGrant() */
        ret = BRAP_P_ResetOpResrcGrant(hRapCh->hRap, 
                                       hRapCh->pPath[uiPth],
                                       &(hRapCh->pPath[uiPth]->sRsrcGrnt));
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: ResetOpResrcGrant failed err=%d", ret));
    		ret = BERR_TRACE(ret); 
    	}

        /* Close all internal module handles */
        ret = BRAP_P_CloseFmmModuleHandles(hRapCh, uiPth);
    	if(BERR_SUCCESS != ret)
    	{
    		BDBG_ERR(("BRAP_P_CloseDecPath: CloseFmmModuleHandles failed %d", ret));
    		ret = BERR_TRACE(ret); 
    	}
#if (BRAP_7405_FAMILY == 1)            	                
        if(((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
            &&(hRapCh->bOpenTimeWrToRbuf == true)
            &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
        {
            /* Free all resources allocated during OpenDecPath() */
                ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),false);
        	if(BERR_SUCCESS != ret)
        	{
        		BDBG_ERR(("BRAP_P_CloseDecPath: Resource free failed err = %d",ret));
        		ret = BERR_TRACE(ret);
        	}

                 /* Reset the resource grant structure for this path */
                BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),false);
        }
        else
#endif
        {            
            /* Free all resources allocated during OpenDecPath() */
                ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
        	if(BERR_SUCCESS != ret)
        	{
        		BDBG_ERR(("BRAP_P_CloseDecPath: Resource free failed err = %d",ret));
        		ret = BERR_TRACE(ret);
        	}

                 /* Reset the resource grant structure for this path */
                BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
        }
    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
    else
    {
        BRAP_P_ReturnRBufToPool(hRapCh,hRapCh->pPath[uiPth],false,0,0);    
        i=0;
        while(i < hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex])
        {            
            hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[hRapCh->uiFWMixerIpIndex][i] = (uint32_t)NULL;
            i++;
        }        
        hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex] = 0;        
        hRapCh->hMultiStreamDecoder->bDRAMBuffersUsed[hRapCh->uiFWMixerIpIndex] = false;        
    }
#endif
exit:    
    /* Reset misc channel handle elements.
       Note: This is exactly reverse of what is done in OpenDecPath() */
    if(false == bWdgRecovery) 
    {
        if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
        {        
            hRapCh->uiXptChannelNo = BRAP_INVALID_VALUE;
        }

        for(i=0; i<BRAP_RM_P_MAX_MIXING_LEVELS; i++)
        {
            hRapCh->pPath[uiPth]->sMixingLevels[i] = sMixingLevelPropInvalid;
        }

        for(i=0; i<BRAP_RM_P_MAX_INTERNAL_DST; i++)
        {
            hRapCh->sIntDst[i] = sInternalDst;
        }
    }
    
    BDBG_LEAVE(BRAP_P_CloseDecPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that opens a Capture path.
**************************************************************************/
BERR_Code 
BRAP_P_OpenCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    bool                    bWdgRecovery = false;
    BRAP_Handle             hRap = NULL;
    BRAP_ChannelType        eChType = BRAP_ChannelType_eMax;
    BRAP_RM_P_ResrcReq      *psRsrcReq = NULL;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt = NULL;
    unsigned int            i =0, j = 0;
    bool                    bRbuAllocated = false;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            uiInPth = 0;

#if BRAP_P_WATERMARK_WORKAROUND==1
	BTMR_Settings sTimerSettings;
#endif    

    BDBG_ENTER(BRAP_P_OpenCapPath);

    /* Check if this is a watchdog recovery. */
    hRap = hRapCh->hRap;
    BDBG_ASSERT(hRap);
    bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    if(false == bWdgRecovery)
    {
    /* Check if the path has already been opened. If yes, just increment the 
       count and return success. */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenCapPath: Cap Path %d was already open. " 
                "New open count = %d", uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

        /* Return success */
        BDBG_LEAVE (BRAP_P_OpenCapPath);
        return BERR_SUCCESS;
    }
    
	/* Malloc large structures */
	psRsrcReq = hRap->sOpenTimeMallocs.psResrcReq;
	if ( NULL==psRsrcReq )
	{
			return BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
	}
        BKNI_Memset(psRsrcReq, 0, sizeof(BRAP_RM_P_ResrcReq));     
	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
	if ( NULL==psRsrcGrnt )
	{
			return BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));         
	
    /* Invalid init the resource request */
    BRAP_RM_P_InitResourceReq(psRsrcReq);

    psRsrcReq->ePath = hRapCh->pPath[uiPth]->eUsgPath;

    /* Copy internal capPort resource request from the earlier path */
    uiInPth = hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx;

    if((BRAP_INVALID_VALUE != uiInPth) && (NULL != hRapCh->pPath[uiInPth]))
    {
        /* Copy the internal CapPort request */
        for(eChP=0; eChP<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
        {
            for(i=0;i<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;i++)
            {
                if((hRapCh->pPath[uiInPth]->sOutPathProp[i].uiPathIdx == uiPth)&&
                   (BRAP_CapInputPort_eMax != 
                    hRapCh->pPath[uiInPth]->sRsrcGrnt.sCapPortGrnt[eChP][i].eCapPort))
                {
                    psRsrcReq->sCapReq[eChP][0].bAllocate = true;
                    psRsrcReq->sCapReq[eChP][0].eCapPort = 
                        hRapCh->pPath[uiInPth]->sRsrcGrnt.sCapPortGrnt[eChP][i].eCapPort;
                }
            }
        }
    }
    }

    eChType = hRapCh->eChannelType;        
    if(false == bWdgRecovery) 
    {
        if((BRAP_ChannelType_eDecode == eChType)||
           (BRAP_ChannelType_ePcmPlayback == eChType))
        {
            /* In case of external SPDIF/HDMI In we require 1 Destination channel and 2 Ring buffers 
            The SPDIF/HDMI might require 1 or 2 buffers depending on the input which can change on the
            fly and so we allocate 2 ring buffers as we will not be able to allocate later */

            if ( ((BRAP_CapInputPort_eSpdif == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eHdmi == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort) ||
                 (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) ||                 
                 (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort))&&
                 (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource)&&
                 (0 == uiPth)
               )
            {
    		    /* Rbuf */
    			psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                /* DstCh */
                psRsrcReq->sDstChReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                /* Allocate the External Capture port */
                if((BRAP_CapInputPort_eRfAudio == hRapCh->eCapInputPort) ||
                   (BRAP_CapInputPort_eSpdif == hRapCh->eCapInputPort) ||  
                   (BRAP_CapInputPort_eHdmi == hRapCh->eCapInputPort) ||                     
                   (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) ||
                   (BRAP_CapInputPort_eExtI2s0 == hRapCh->eCapInputPort))
                {
                        psRsrcReq->sCapReq[BRAP_OutputChannelPair_eCaptureLR][0].bAllocate = true;
                        psRsrcReq->sCapReq[BRAP_OutputChannelPair_eCaptureLR][0].eCapPort = 
                                                            pAudioParams->eCapInputPort;
                }
            }
            /* For the case of Ringbuffer as audio source only ringbuffers need to be allocated. 
               Application will directly write the data into these buffers */
            else if((BRAP_AudioSource_eRingBuffer == hRapCh->eAudioSource) &&
                    (0 == uiPth))
            {
    		    /* Rbuf */
    			psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].bAllocate = true;
                psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eCaptureLR].eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
            }
            /* This is a temporary fix for SPDIF/HDMI In bringup for 3563. 
            Needs to be fixed properly later for a case like transcode of captured
            SPDIF data */
            else 
            {
                /* Check if Rbuf and DstCh already allocated at Add_destination time */
                for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
    		    BDBG_MSG(("bRbuAllocated > %d", bRbuAllocated));
                if(bRbuAllocated == false)
                {                     
                    /* Prepare resource request for rbuf and dstch */
                    for(i = 0; i < BRAP_RM_P_MAX_INTERNAL_DST; i++)
                    {
                        if(hRapCh->sIntDst[i].eInputAudMode < BRAP_OutputMode_eLast)
                        {
                            ret = BRAP_P_GetAudOpModeProp(hRapCh->sIntDst[i].eInputAudMode, 
                                                           hRapCh->sIntDst[i].bLfeOn, 
                                                           &sOpAudModeProp);
                    		if(BERR_SUCCESS != ret)
                    		{
                    			BDBG_ERR(("BRAP_P_GetAudOpModeProp failed with err = %d", ret));
                    			ret = BERR_TRACE(ret);
                                goto exit;
                    		}

                            /* Resource request for Rbufs and SrcChs */
                            for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                        	{
                    			/* For the input audio mode, this audio channel exists, 
                    			   so RBuf is required to be allocated */
                        		if(sOpAudModeProp.bChnExists[eChP*2] == true)
                        		{
                        		    /* Rbuf */
                        			psRsrcReq->sRbufReq[eChP].bAllocate = true;
                                    psRsrcReq->sRbufReq[eChP].eBufDataMode = 
                                        BRAP_BufDataMode_eStereoNoninterleaved;
                                    /* DstCh */
                                    psRsrcReq->sDstChReq[eChP].bAllocate = true;
                      		    }
                            }
                        }
                    }
                }
            }
        }
#if (BRAP_7550_FAMILY != 1)        
        else if(BRAP_ChannelType_ePcmCapture == eChType)
        {
            if(false == hRap->bInPortSettingValid[pAudioParams->eCapInputPort])
            {
                BDBG_ERR((" BRAP_P_OpenCapPath:Capture Input not configured ."
                          " Before starting configure it"));
                ret = BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
		        goto exit;
            }
            
            /* Check the Cpture Mode */
            if(BRAP_CaptureMode_eCaptureOnly == pAudioParams->eCapMode)
            {
                /*Rbuf and DstCh should have been allocated at Add destination */
                /* Check for them */
                for(i=0 ; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
                if(bRbuAllocated == false)
                {
                    BDBG_ERR(("BRAP_P_OpenCapPath: Please Add RBUF as destination"
                              " before starting Capture channel in Cap_only mode"));
                    ret = BERR_TRACE(BERR_NOT_INITIALIZED);
		            goto exit;
                }
                /* Allocate the External Capture port */
                psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].bAllocate = true;
                psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].eCapPort = 
                                                    pAudioParams->eCapInputPort;
            }
            else if (BRAP_CaptureMode_eFullDuplex == pAudioParams->eCapMode)
            {
                /* Check if Rbuf has been allocated,If not prepare the request */
                for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL == hRapCh->pDstDetails[i])
                    {
                        continue;
                    }

                    if((BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst) &&
                       (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[0] != BRAP_INVALID_VALUE))
                    {
                        bRbuAllocated = true;                    
                        break;
                    }
                    else
                    {
                        bRbuAllocated = false;
                    }
                }
                if ((false == bRbuAllocated) || (0 == uiPth) )
                {
                    /* Rbuf Request */
                    psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].bAllocate = true;
                    psRsrcReq->sRbufReq[BRAP_OutputChannelPair_eLR].eBufDataMode=
                        hRap->sInputSettings[pAudioParams->eCapInputPort].eBufDataMode;

                    /* DSTCH request */
                    psRsrcReq->sDstChReq[BRAP_OutputChannelPair_eLR].bAllocate = true;

                    /* Only for 0th path we have external capture possible */
                    /* Add request for External Port */
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].bAllocate = true;
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][0].eCapPort = 
                                                        pAudioParams->eCapInputPort;
                    
                    bRbuAllocated = false;

                }
#if (BRAP_3548_FAMILY == 1)
                if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource) &&
                     (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort) &&
                     (0 == uiPth)
                   )
                {
                    /* 
                        Add request for internal capture Port and an SRC in this capture path 
                        This is a requirment in ADC that the input first go through the SRC for
                        downsampling and then be routed to Dstch Buffers (otherwise DRAM/DSP cannot
                        handle it)
                    */
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][1].bAllocate = true;
                    psRsrcReq->sCapReq[BRAP_OutputChannelPair_eLR][1].eCapPort = BRAP_CapInputPort_eMax;

                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].bAllocate = true;
                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].sReallocateSrc.uiSrcBlkId = BRAP_RM_P_INVALID_INDEX;
                    psRsrcReq->sSrcMixerReq[0].sSrcReq[0][0][0].sReallocateSrc.uiSrcId = BRAP_RM_P_INVALID_INDEX;                
                }
#endif                            
            }
        }
#endif

        /* Allocate the Resources */
        ret = BRAP_RM_P_AllocateResources(hRap->hRm, psRsrcReq, psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: Resource alloc failed with err = %d",
                ret));
			ret = BERR_TRACE(ret);
            goto exit;
		}

        /* Open all internal module handles */
        ret = BRAP_P_OpenFmmModuleHandles(hRapCh,pAudioParams, uiPth, psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_OpenFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}

        /* Consider already allocated FMM modules */
    	if(true == bRbuAllocated)
    	{
    		for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
    		{
    			if( hRapCh->pDstDetails[j] != NULL &&
                    hRapCh->pDstDetails[j]->eAudioDst == BRAP_AudioDst_eRingBuffer )
    			{
                     ret = BRAP_P_GetAudOpModeProp(hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.eAudioMode, 
                                                   hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.bLfeOn, 
                                                   &sOpAudModeProp);
                     
                    for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
                	{
                		if(sOpAudModeProp.bChnExists[eChP*2] == true)
                		{
                		    /* Find valid Rbuf Id and store the Rbuf handle */
                            if( BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2])
                            {
            			 	    psRsrcGrnt->uiRbufId[eChP*2] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2];
                				hRapCh->pPath[uiPth]->hRBuf[eChP*2] = 
                                    hRap->hFmm[0]->hRBuf[psRsrcGrnt->uiRbufId[eChP*2]];                                
                            }
                            if( BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1])
                            {
            			 	    psRsrcGrnt->uiRbufId[eChP*2+1] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1];
                                hRapCh->pPath[uiPth]->hRBuf[eChP*2+1] = 
                                    hRap->hFmm[0]->hRBuf[psRsrcGrnt->uiRbufId[eChP*2+1]];
                            }

                		    /* Find valid DstCh Id and store the DstCh handle */
                            if(BRAP_INVALID_VALUE != 
                                hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiDstChId[eChP])
                            {
                			 	psRsrcGrnt->uiDstChId[eChP] = 
                                 hRapCh->pDstDetails[j]->uDstDetails.sRBufDetails.uiDstChId[eChP];
                				hRapCh->pPath[uiPth]->sDstCh[eChP].hDstCh = 
                                    hRap->hFmm[0]->hDstCh[psRsrcGrnt->uiDstChId[eChP]];
                            }
                        }
                    }
    			}
    		}
    	}

        /* Update the resource grant structure in hRapCh */
        ret = BRAP_RM_P_UpdateResrcGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt), 
                                         psRsrcGrnt);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: UpdateResrcGrant failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}
        /* Update the resource grant structure in hRapCh for Rbuf and DstCh 
           added at Add_destination time */
            /* TODO*/

        /* Prepare linkage info among the resources in the same path */
        ret = BRAP_P_LinkFmmModuleHandles(hRapCh, uiPth);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_LinkFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}        
    }
    else /* Watchdog */
    {
        /* Open all internal module handles */
        ret = BRAP_P_OpenFmmModuleHandles(hRapCh,pAudioParams, uiPth, 
                &(hRapCh->pPath[uiPth]->sRsrcGrnt));
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_OpenCapPath: BRAP_P_OpenFmmModuleHandles"
               " failed %d", ret));
			ret = BERR_TRACE(ret); 
            goto free_rsrc;
		}
    }

#if BRAP_P_WATERMARK_WORKAROUND==1
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
    if((pAudioParams->eCapMode == BRAP_CaptureMode_eCaptureOnly) ||
           ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
            (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer))
            ) 
    {

        BTMR_GetDefaultTimerSettings(&sTimerSettings);
        sTimerSettings.type = BTMR_Type_eCountDown;
        sTimerSettings.cb_isr = (BTMR_CallbackFunc) BRAP_P_FmmDstRbufFullWaterMark_isr;
        sTimerSettings.pParm1 = hRapCh;
        sTimerSettings.parm2 = 0;
        sTimerSettings.exclusive = false;

#ifdef AUTOTRAP
        ret = BTMR_CreateTimer (hRap->hTmr, &hRapCh->hTimer1, &sTimerSettings);
#else
        ret = BTMR_CreateTimer (hRap->hTmr, &hRapCh->hTimer, &sTimerSettings);
#endif /* AUTOTRAP */
        if ( ret != BERR_SUCCESS )
        {
    		BDBG_ERR(("BRAP_P_OpenCapPath: Create Timer Failed"));
    		ret = BERR_TRACE(ret);
    		goto free_rsrc;
        }
            break;
        }        
    }        
#endif

    if((BERR_SUCCESS == ret) && (false == bWdgRecovery))
    {
        /* Increment the open count */
        hRapCh->pPath[uiPth]->uiPthOpenCnt++;

        BDBG_MSG(("BRAP_P_OpenCapPath: hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
            uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
        
        /* Exit successfully */
        goto exit;
    }
    
    if(BERR_SUCCESS == ret)
    {
        /* Exit successfully */
        goto exit;
    }
    
free_rsrc:
    /* Free resources */    
    BRAP_RM_P_FreeResources(hRap->hRm, psRsrcGrnt,true);
    if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("Free Resource failed with err = %d",ret));
		ret = BERR_TRACE(ret);
	}

exit:
	
    BDBG_LEAVE(BRAP_P_OpenCapPath);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes a capture path.
**************************************************************************/
BERR_Code 
BRAP_P_CloseCapPath(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
    const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                   to pPath[] array element */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_OpAudModProp     sOpAudModeProp;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            i = 0;
   
    BDBG_ENTER(BRAP_P_CloseCapPath); 
    BDBG_MSG(("BRAP_P_CloseCapPath CALLED!!!"));
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    /* Error state check */
    if (0 == hRapCh->pPath[uiPth]->uiPthOpenCnt)
    { 
        /* This should never happen. If it does, it means the system
           has gone into an invalid state!!!!*/
        BDBG_ERR (("BRAP_P_CloseCapPath: SM Path open count is already 0"));
        return BERR_TRACE (BERR_NOT_SUPPORTED);
    }

    /* Decrement the open count */
    hRapCh->pPath[uiPth]->uiPthOpenCnt--;

    BDBG_MSG(("BRAP_P_CloseCapPath: For uiPth=%d New uiPthOpenCnt = %d", 
        uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));

    /* If the new open count is not 0, do not close the resources instead 
       return success */
    if(0 != hRapCh->pPath[uiPth]->uiPthOpenCnt)
    {
        BDBG_MSG(("BRAP_P_CloseCapPath: uiPthOpenCnt = %d so not closing resources!"));
        BDBG_LEAVE(BRAP_P_CloseCapPath);
        return BERR_SUCCESS;
    }


#if (BRAP_P_WATERMARK_WORKAROUND==1)
    /* Destroy the timer */
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
#ifdef AUTOTRAP
        if ((NULL != hRapCh->hTimer1) &&
            ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
             (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
              == BRAP_AudioDst_eRingBuffer)))
        {
            ret = BTMR_DestroyTimer(hRapCh->hTimer1);
            if (ret != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_CloseCapPath: BTMR_DestroyTimer Failed"));
                ret = BERR_TRACE(ret);
            }
            hRapCh->hTimer1 = NULL;
        }
#else
        if ((NULL != hRapCh->hTimer) &&
            ((hRapCh->pPath[uiPth]->pDstDetails[i] != NULL) && 
             (hRapCh->pPath[uiPth]->pDstDetails[i]->eAudioDst 
              == BRAP_AudioDst_eRingBuffer)))
        {
            ret = BTMR_DestroyTimer(hRapCh->hTimer);
            if (ret != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_CloseCapPath: BTMR_DestroyTimer Failed"));
                ret = BERR_TRACE(ret);
            }
            hRapCh->hTimer = NULL;
        }
#endif /* AUTOTRAP */
    }
#endif

    /* Unlink FMM modules */
    ret = BRAP_P_UnlinkFmmModuleHandles(hRapCh, uiPth);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: UnlinkFmmModuleHandles failed %d", ret));
		ret = BERR_TRACE(ret); 
	}

    /* Close all internal module handles */
    ret = BRAP_P_CloseFmmModuleHandles(hRapCh, uiPth);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: CloseFmmModuleHandles failed %d", ret));
		ret = BERR_TRACE(ret); 
	}

	for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
	{
        if(NULL == hRapCh->pDstDetails[i])
        {
            continue;
        }
	
		if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
		{
             ret = BRAP_P_GetAudOpModeProp(hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.eAudioMode, 
                                           hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.bLfeOn, 
                                           &sOpAudModeProp);
            for (eChP = 0; eChP < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChP++)
        	{
        		if(sOpAudModeProp.bChnExists[eChP*2] == true)
        		{
        		    /* 
        		        This is required so that the Ring Buffers and Destination Channels that are allocated at runtime
        		        is not freed by Resource Manager.
                    */
                    
        		    /* Rbuf */
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[eChP*2] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2] = BRAP_RM_P_INVALID_INDEX;
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiRBufId[eChP*2+1] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2+1])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiRbufId[eChP*2+1] = BRAP_RM_P_INVALID_INDEX;
                    /* DstCh */
                    if (hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.uiDstChId[eChP] == hRapCh->pPath[uiPth]->sRsrcGrnt.uiDstChId[eChP])
    			 	    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDstChId[eChP] = BRAP_RM_P_INVALID_INDEX;
                }
            }
		}
	}
    

    /* Free all resources allocated during OpenDecPath() */
    ret = BRAP_RM_P_FreeResources(hRapCh->hRap->hRm, &(hRapCh->pPath[uiPth]->sRsrcGrnt),true);
	if(BERR_SUCCESS != ret)
	{
		BDBG_ERR(("BRAP_P_CloseCapPath: Resource free failed err = %d",ret));
		ret = BERR_TRACE(ret);
	}

    /* Reset the resource grant structure for this path */
    BRAP_RM_P_InitResourceGrant(&(hRapCh->pPath[uiPth]->sRsrcGrnt),true);

    BDBG_LEAVE(BRAP_P_CloseCapPath);    
    return ret;
}


/***************************************************************************
Summary:
    Private function that checks if a stream type is supported or not.
****************************************************************************/
BERR_Code 
BRAP_P_IsStreamTypeSupported(
    BAVC_StreamType     eStreamType
    )
{
    BERR_Code ret = BERR_SUCCESS;
    
	/* Check Transport Stream type: 
       NOTE: This  list should be constantly updated to refelct current status
       for each platform */
    switch(eStreamType)
    {
        /* Break with success for supported stream types */
        case BAVC_StreamType_eMpeg1System:
        case BAVC_StreamType_eTsMpeg:
        case BAVC_StreamType_eDssEs:
        case BAVC_StreamType_eDssPes:
        case BAVC_StreamType_ePS:
        case BAVC_StreamType_ePes:
        case BAVC_StreamType_eEs:
         break;
        case BAVC_StreamType_eBes:
        case BAVC_StreamType_eCms:
        default:
            BDBG_ERR(("BRAP_DEC_Start: Stream type %d not supported",
                eStreamType));
            return BERR_TRACE(BERR_NOT_SUPPORTED);
    }
    return ret;
}

/***************************************************************************
Summary:
    Private function that identifies and prepares the various usage paths 
    required for this channel.

    This function should also populate the inlink, outlink, self link
    for all the paths required in this channel.

    TODO: Keep updating this algorithm. Refer 7440_fmm_usage.doc for preparing
    this decision matrix.
    
    ALGORITHM: 
    1. Identify which all paths are required
    * DEC PATH: 
        (DecDSP0)->Rbuf to OP/CAP
        DEC or PB channels
        These output ports do not carry 
        a) transcoded/encoded data
        b) watermark detection
        c) speaker mngt (valid only for OP carrying multichannel PCM) 
         
    * TRANS PATH:
        Compressed 
        Shared Rbuf to Capture port
        DEC and PB channels    
            
    * CAP PATH:
        Capture port to Rbuf or OutputPort
        DEC or PB or CAP channels
        delay balance, VWM detection, transcoding
            
    * ENC PATH:
        ENC, DEC, PB
        Encoding/Transcoding enabled
        
    * SM PATH:
        DEC, PB
        SM enabled

    2. Update the pPath[] in hRapCh.        
**************************************************************************/
BERR_Code BRAP_P_GetPathIndex(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed */	
        unsigned int                    uiBranchId,     /* [in] path number */
        unsigned int                    uiCloneOp,      /* [in] Number of clone OP without any path */
        unsigned int                    *uipPthIndex     /* [out] Give the path index*/
)
{
    unsigned int j=0;
    BERR_Code   ret=BERR_SUCCESS;
    /*Find Path which is having cloned port */
    if(0 == uiBranchId )
    {
        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
        {
            if((hRapCh->pPath[j] != NULL) &&
               ((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)||
                (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodeCompress)))
            {
                *uipPthIndex= j;
            }
        }
        if(j == BRAP_P_MAX_PATHS_IN_A_CHAN)
            ret = BERR_INVALID_PARAMETER;
    }
    else
    {
        if (((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)&&
            ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
             (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
             (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort)||                 
              (BRAP_CapInputPort_eExtI2s0 == pAudioParams->eCapInputPort))) ||
            (BRAP_AudioSource_eRingBuffer == pAudioParams->eAudioSource))
        {
            /*One capture path and one decpcm or decComp path */
            *uipPthIndex = uiBranchId+1-uiCloneOp;
        }
        else
        {
            /*Either one decpcm or deccmp path*/
            *uipPthIndex= uiBranchId-uiCloneOp;
        }
    }
    return ret;
}

BERR_Code
BRAP_P_GetInputPathIndexForAssociation(
            BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
            unsigned int                uiAssociationId,
            unsigned int                *uipPthIndex     /* [out] Give the path index*/	
	)
{
    BERR_Code   ret=BERR_SUCCESS;
    unsigned int i = 0;

    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(uipPthIndex);    
    
    for(i = 0 ; i< BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        if(hRapCh->pPath[i] == NULL)
            continue;
        if(hRapCh->pPath[i]->uiAssocId == uiAssociationId)
        {
           *uipPthIndex = i;
            break;
        }
    }

    if(i >=BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("ERROR!!! No path feeding to Association %d ",uiAssociationId));
        ret = BERR_INVALID_PARAMETER;
    }

    return ret;
}

BRAP_ChannelHandle
BRAP_P_GetRapChHandle(
        BRAP_AssociatedChannelHandle    hAssociatedCh   /* [in] Association handle */
        )
{
    unsigned int        i=0;
    BRAP_ChannelHandle  hRapCh;  
    
    BDBG_ENTER(BRAP_P_GetRapChHandle);
    BDBG_ASSERT(hAssociatedCh);

    for(i=0;i<BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hPriDecCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hSecDecCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hPBCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }
    for(i=0;i<BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP;i++)
    {
        hRapCh = hAssociatedCh->hCapCh[i];
        if(BRAP_P_IsPointerValid((void *)hRapCh))
        {
            return hRapCh;
        }
    }  
        
    BDBG_LEAVE(BRAP_P_GetRapChHandle);
    return NULL;    
}

BERR_Code
    BRAP_P_FormPostMixingPathsForSubsequentDestinations(
        unsigned int                uiDstnIndex,    /* [in] Destination index in RapCh */
        unsigned int                uiPth,          /* [in] Index to form the Path from */
        unsigned int                uiAssocId,      /* [in]*/
    	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */        
        BRAP_ChannelHandle              hRapCh      /* [in] RAP Channel handle */
        )
{
    BERR_Code       ret = BERR_SUCCESS;
    bool    bCompress=false,bIndepPathRequire=false,bDownmixPathRequire=false;
    bool    bBranchCloned=false, flag=false, bMixPathRequire=false;
    bool    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];
    unsigned int uiClonedBranch=BRAP_INVALID_VALUE, m=0, uiLastStage=0, j=0, k=0, l=0, n=0; 
    unsigned int ui32MasterBranchId=0, ui32MasterStageId=0, uiCloneAssocId=0, uiDestCount=0;
    unsigned int uiCloneBranchId[BRAP_P_MAX_DST_PER_RAPCH], uiCloneOp=0;
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    BRAP_ProcessingType     eAudioProcessing = BRAP_ProcessingType_eNone;    
    BRAP_ChannelHandle      hStartedRapCh[BRAP_MAX_ASSOCIATED_GROUPS];    
    #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    BRAP_P_UsgPath         ePathType = BRAP_P_UsgPath_eMax;  
    #endif    

    BDBG_ASSERT(hRapCh);
    BDBG_ENTER(BRAP_P_FormPostMixingPathsForSubsequentDestinations);

    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        hStartedRapCh[j]=NULL;
    }
    
    /* Malloc large structures */
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));     

    /* Get the started channel (if any) from the association 
    We are not using bPrimary */
    ret = BRAP_P_GetStartedChannel(hRapCh, bPrimary, hStartedRapCh);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }
    
    for(uiDstnIndex=uiDstnIndex+1; uiDstnIndex<BRAP_P_MAX_DST_PER_RAPCH; ++uiDstnIndex)
    {
        if(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, uiDstnIndex))
        {   
            bCompress = false;                        
            BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
            ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                            hRapCh->pDstDetails[uiDstnIndex],
                                            pPvtDstDetails,
                                            &m);
            if(BERR_SUCCESS!=ret)
            {
                ret = BERR_TRACE(ret);
                goto end;
            }
            if(!(BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                continue;
            
            if(m != uiAssocId)
            {
                BDBG_ERR(("Muliple Association Networks not supported per channel"));
                ret = BERR_NOT_SUPPORTED;
                goto end;                            
            }

            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
            {
                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                    break;

                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));
                    if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                                                                      
                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                {
                    bCompress = true;
                }
            }
            if(m>0)
            {
                uiLastStage = m -1;
            }
            else
            {
                uiLastStage = BRAP_INVALID_VALUE;
                BDBG_ERR(("Network must have one valid stage"));
                ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                goto end;                            
            }

            if(NULL == hStartedRapCh[uiAssocId])
            {
                bIndepPathRequire = false;      
                bDownmixPathRequire = false;                
                bBranchCloned = flag = bMixPathRequire = false;
                uiClonedBranch = BRAP_INVALID_VALUE;                            
                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                {
                    uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                }
                for(j = 0; j < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,uiDstnIndex,j)))  
                        break;
                }
                if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][j-1].bCloneStage)) 
                {
                    flag = true;
                }

                /*If its Mai and Muxselector is not Mai, then dont create path for it */
                if( (!((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                        &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                    ||(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                {                
                    if(flag == false)
                    {
                        bBranchCloned = false;
                    }
                    else
                    {
                        ui32MasterBranchId = k= hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].ui32MasterBranchId;
                        ui32MasterStageId = l= hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].ui32MasterStageId;
                        m=0;
                        /* Check if the current branch is a clone of complete master branch */
                        if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k,l+1)))           
                        {
                            bBranchCloned = true;
                            uiCloneBranchId[m]=k;
                            m++;
                            k++;
                        }

                        /* Now check if the branches between Current and Master branch are similar to current branch.
                        This is done by checking if the last stage is cloned, and its Master stage/branch id 
                        is same as that of last stage id of current branch. Just to make clear, here 
                        Current Branch/Stage Id is : uiDstnIndex/uiLastStage
                        Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                        And we looping on K, which is between ui32MasterBranchId and uiDstnIndex */
                        for(; k<uiDstnIndex; ++k)
                        {
                            if(!(BRAP_P_STAGE_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k,l+1)))
                            {   
                                if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId))
                                {
                                    bBranchCloned = true;
                                    uiCloneBranchId[m]=k;
                                    m++;
                                } 
                            }
                        }

                        /* Now if there  are branches which are cloned to current then, Are they in same
                        association? If no then Create a Mix Path corresponding to them , if not created 
                        already.*/
                        if(bBranchCloned == true)
                        {                        
                            if(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            {                    
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    
                                    if((hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                        ||(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                        hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                    {
                                        bDownmixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                    {
                                        bDownmixPathRequire = true;
                                    }
                                }
                            }

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                            if((false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/

                                    if((hRapCh->bIndepDelayEnabled == true)
                                        &&((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) ||
                                           (hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) ||
                                           (hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0) ||
                                           (hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                               hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                      )
                                    {
                                        bIndepPathRequire = true;
                                        uiClonedBranch = k;                                                                                
                                        break;
                                    }
                                    else
                                    {
                                        bIndepPathRequire = false;
                                        uiClonedBranch = k;                                            
                                    }
                                }
                            }
#endif                        
                            if((false == bIndepPathRequire)&&(false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                    pPvtDstDetails,
                                                                    &uiCloneAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    /* For this branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    if(uiAssocId == uiCloneAssocId)
                                    {
                                        bMixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else
                                    {
                                        bMixPathRequire = true;
                                    }
                                }
                            }
                        }
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                }                        
                else
                {
                    bBranchCloned = true;
                    for(k =0; k<uiDstnIndex; ++k)
                    {
                        if((BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,k)))
                        {   
                            if((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                != BRAP_OutputPort_eMai)
                                &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                == hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector))
                            {
                                uiClonedBranch = k;
                                BDBG_MSG(("################Coming here k =%d",k));
                            }
                        }
                    }
                } /*if(bBranchCloned == true)*/
                
                BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                bBranchCloned,uiAssocId,uiCloneAssocId));
                
                if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage,uiDstnIndex)))
                    ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                {

                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    if( (((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                          &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                         ||((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) 
                            &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sRBufDetails.eAudioMode== BRAP_OutputMode_e2_0)))
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0) )    /* Capture to rbuf is required in stereo mode as of now */
                    {
                    
                        BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eDownmixedPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                    }
                    else
                    {
                        BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                    }
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                    uiPth++;
                } /*if((false == bBranchCloned)&&*/
                else if ((true == bBranchCloned) && (true == bMixPathRequire))
                {   
                    /*Find the Path which is having cloned port */
                    ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);


                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }   
                    if((hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                    {
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eDownmixedMixPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));
                    }
                    else
                    {
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                            BRAP_P_UsgPath_eMixPath,
                                            BRAP_INVALID_VALUE, 
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);        
                        BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));
                    }
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /*Mark the path which is cloned for this stage as mix*/
                    BDBG_MSG(("Input to mix path uiPth=%d",m));
                    hRapCh->pPath[m]->bMixPath = true;
                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));                      
                    ++uiPth;
                } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                else
                {
                    /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                    no path is created for this destination. So add this destination to a corresponding existing path.*/
                    uiCloneOp++;
                    flag = false;
                    for(m =0 ; m < uiPth ; m++)
                    {
                        uiDestCount = hRapCh->pPath[m]->uiDestcount;
                        
                        for(n =0 ; n < uiDestCount ; n++)
                        {
                            if(hRapCh->pPath[m]->pDstDetails[n] == 
                                &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                            {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                if(bIndepPathRequire == true)
                                {/* Create a Path */
                                
                                    switch(hRapCh->pPath[m]->eUsgPath)
                                    {
                                        case BRAP_P_UsgPath_eDecodePcmPostMixing:
                                        case BRAP_P_UsgPath_eDecodeCompressPostMixing:    
                                        case BRAP_P_UsgPath_ePPBranchPostMixing:
                                        case BRAP_P_UsgPath_eMixPath:
                                            ePathType = BRAP_P_UsgPath_ePPBranchPostMixing;
                                            break;
                                        case BRAP_P_UsgPath_eDownmixedPath:
                                        case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                            ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                            break;
                                        default:
                                            ePathType = BRAP_P_UsgPath_ePPBranchPostMixing;
                                            break;
                                    }
                                    
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                        
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                            
                                        }
                                    }
                                    BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                        ePathType,
                                                        BRAP_INVALID_VALUE, 
                                                        uiPth,
                                                        BRAP_INVALID_VALUE,0);

                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                    hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][0].hValidDestHandle->sExtDstDetails);
                                    
                                    if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    else if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    uiPth++;                                    
                                }
                                else
#endif                                    
                                {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[uiDstnIndex][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                    if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    else if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sRBufDetails.eCapPort[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    hRapCh->pPath[m]->uiDestcount++;
                                }
                                flag =true;
                                break;
                            }
                        }
                        if(true == flag)
                            break;
                    }
                }
            }
            else
            {
                for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                {
                    if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                        (NULL == hRapCh->pPath[uiPth])&& 
                        (NULL != hStartedRapCh[uiAssocId]->pPath[j]))
                    {
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                        {
                            if(hStartedRapCh[uiAssocId]->pPath[j]->pDstDetails[k] == hRapCh->pDstDetails[uiDstnIndex])
                                break;
                        }
                        if(k == BRAP_P_MAX_DST_PER_RAPCH)
                            continue;

                        l = uiPth;
                        /* For Independent delay disabled case no need to form separate 
                           paths unless the data carried to the ports is different */
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
                        if((hRapCh->bIndepDelayEnabled == false) &&
                           (hStartedRapCh[uiAssocId]->pPath[j] == hRapCh->pPath[uiPth-1]))
                            l = uiPth-1;
#else
                        if(hStartedRapCh[uiAssocId]->pPath[j] == hRapCh->pPath[uiPth-1])
                            l = uiPth-1;
#endif
                        
                        hRapCh->pPath[l] = hStartedRapCh[uiAssocId]->pPath[j];
                        for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                        {
                            if(BRAP_INVALID_VALUE == hRapCh->pPath[l]->sInPathProp[k].uiPathIdx)
                                break;
                        }
                        hRapCh->pPath[l]->sInPathProp[k].uiPathIdx = l-1;
                        hRapCh->pPath[l-1]->sOutPathProp[0].uiPathIdx = l;                                            

                        BDBG_MSG(("Copying path: hRapCh->pPath[l =%d]->eUsgPath =%d, StrtdPathIndex=%d",
                        l, hRapCh->pPath[l]->eUsgPath,j));
                        uiPth=l+1;
                        break;                            
                    }
                } 
#if 0                    
                if(bCompress == true)
                {
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                           (hRapCh->pPath[uiPth] == NULL)&&
                           (NULL != hStartedRapCh[uiAssocId]->pPath[j])&& 
                           (hStartedRapCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                        {
                            bool    bStartedPathFound=false;
                            if(BRAP_P_UsgPath_eDecodeCompressPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            {
                                bStartedPathFound = true;
                            }
                            else if(BRAP_P_UsgPath_ePPBranchPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            {
                                bool    bStartedPathOutputCompress=false;
                                BRAP_P_IsPathOutputCompress(hStartedRapCh[uiAssocId],j,&bStartedPathOutputCompress);
                                if(bStartedPathOutputCompress == true)
                                    bStartedPathFound = true;
                            }

                            if(bStartedPathFound == true)
                            {
                                hRapCh->pPath[uiPth] = hStartedRapCh[uiAssocId]->pPath[j];
                                
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                uiPth++;                    
                                break;
                            }
                        }
                    }                            
                }
                else
                {
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL == hRapCh->pPath[uiPth])&& 
                            (NULL != hStartedRapCh[uiAssocId]->pPath[j])&& 
                            ((BRAP_P_UsgPath_ePPBranchPostMixing == hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath)
                            ||(BRAP_P_UsgPath_eDecodePcmPostMixing== hStartedRapCh[uiAssocId]->pPath[j]->eUsgPath))&&
                            (hStartedRapCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                        {
                            hRapCh->pPath[uiPth] = hStartedRapCh[uiAssocId]->pPath[j];
                            for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                            {
                                if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                    break;
                            }
                            hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                            

                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                            uiPth++;
                            break;                            
                        }
                    }                            
                }
#endif                
            }
        } /* if(BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, uiDstnIndex)) */
    } /* for(uiDstnIndex=uiDstnIndex+1; i<BRAP_P_MAX_DST_PER_RAPCH; ++i) */                
end:
    
    return ret;
    BDBG_ENTER(BRAP_P_FormPostMixingPathsForSubsequentDestinations);
}

BERR_Code 
BRAP_P_GetChannelPaths(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                *uiNumCapPath   /* [out] True if capture path
                                                   present in channel */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiPth = 0;
    unsigned int i = 0,uiAssocId=0,k=0,l=0,m=0,uiCloneAssocId=0;
    unsigned int j = 0,n=0,uiCloneOp=0,uiCloneBranchId[BRAP_P_MAX_DST_PER_RAPCH];
    BRAP_ChannelHandle hStartedAssoCh[BRAP_MAX_ASSOCIATED_GROUPS];
    bool bPrimary[BRAP_MAX_ASSOCIATED_GROUPS];
    BRAP_DSPCHN_P_Settings	*pDspChSettings = NULL;
    bool bBranchCloned=false, flag=false, bMixPathRequire=false,bDownmixPathRequire = false;
    BRAP_ProcessingType    eAudioProcessing = BRAP_ProcessingType_eNone;
    BRAP_P_DstDetails       *pPvtDstDetails = NULL;
    bool bCompress = false, bAssociationNWDstnFound = false;
    unsigned int                    ui32MasterBranchId = BRAP_INVALID_VALUE;
    unsigned int                    ui32MasterStageId = BRAP_INVALID_VALUE; 
    unsigned int    uiLastStage = BRAP_INVALID_VALUE;
    unsigned int    uiDestCount = 0;
    BRAP_ProcessingStageHandle  hAudProcessing = NULL;
    BRAP_ProcessingType             eAudProc = BRAP_ProcessingType_eMax;
    unsigned int uiClonedBranch = BRAP_INVALID_VALUE;
#if 0    
    bool bSpdifMaiPresent= false;
    unsigned int uiSpdifMaiPathindex =BRAP_INVALID_VALUE;        
#endif    
    #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    BRAP_P_UsgPath         ePathType = BRAP_P_UsgPath_eMax;  
    #endif
    bool                bIndepPathRequire = false;
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
    bool                bBranchFoundForDummy = false;
#endif

        
    BDBG_ENTER(BRAP_P_GetChannelPaths);

    if(true == BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap))
    {
        /* Copying  uiNumCapPath from hRapCh */
        *uiNumCapPath = hRapCh->uiNumCapPath;
        BDBG_MSG(("Under Watchdog Recovery - not doing anything"));    
        BDBG_LEAVE(BRAP_P_GetChannelPaths);
        ret = BERR_SUCCESS;
        goto end;
    }
    
    pDspChSettings = ( BRAP_DSPCHN_P_Settings *) BKNI_Malloc( sizeof( BRAP_DSPCHN_P_Settings ));
    if ( NULL==pDspChSettings )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;        
    }            
    BKNI_Memset(pDspChSettings, 0, sizeof(BRAP_DSPCHN_P_Settings));         
    /* Form the DSP Channel Settings */
    ret = BRAP_DSPCHN_P_GetDefaultSettings(pDspChSettings);
    if(BERR_SUCCESS != ret)
    {
        BDBG_ERR(("DSPCHN_P_GetDefaultSettings: returned %d", ret));
        ret = BERR_TRACE(ret); 
        goto end;        
    }         
#ifdef RAP_VIDEOONDSP_SUPPORT
    if(hRapCh->eChannelType == BRAP_ChannelType_eVideoDecode)
    {
        if(NULL == hRapCh->pPath[uiPth])
          {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif              
              if(BERR_SUCCESS != ret)
              {
                  ret = BERR_TRACE(ret);
                  goto end;
              }            
          }
          BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                  BRAP_P_UsgPath_eVideoDecode,
                                                  BRAP_INVALID_VALUE,
                                                  uiPth,
                                                  uiPth+1,0);
          hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;                
          /* Instantiate the DSP Channel corresponding to the DSP context resource 
          manager has allocated */
          ret = BRAP_DSPCHN_P_Open( &(hRapCh->pPath[uiPth]->hDspCh),
                                    hRapCh,
                                    true,
                                    pDspChSettings);
          if(BERR_SUCCESS != ret)
          {
              BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
              ret = BERR_TRACE(ret);
              goto end;
          }
          return ret;
    }
#endif
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
        {
        hStartedAssoCh[uiAssocId]=NULL;
        bPrimary[uiAssocId]=false;
    }
    
    *uiNumCapPath = 0;
    BDBG_MSG(("*uiNumCapPath > %d", *uiNumCapPath));

    /* Get the started channel (if any) from the association 
    We are not using bPrimary */
    ret = BRAP_P_GetStartedChannel(hRapCh, bPrimary, hStartedAssoCh);
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hRapCh->uiAssociationId[uiAssocId] != BRAP_INVALID_VALUE)
        {
            BDBG_MSG(("BRAP_P_GetChannelPaths: hRapCh = 0x%x hStartedAssoCh[uiAssocId=%d] = 0x%x",
                hRapCh,hRapCh->uiAssociationId[uiAssocId],hStartedAssoCh[hRapCh->uiAssociationId[uiAssocId]]));
        }
    }
    
    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        if(hStartedAssoCh[uiAssocId])
        {
            for(j=0; j < BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
            {
                if(hStartedAssoCh[uiAssocId]->pPath[j] != NULL)
                {
                    BDBG_MSG(("hStartedAssoCh[uiAssocId=%d]->pPath[j=%d]->eUsgPath = %d",
                    uiAssocId,j, hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath));
                }
            }
        }
    }
    if(BERR_SUCCESS != ret)
    {
        ret = BERR_TRACE(ret);
        goto end;        
    }
    
    /* Malloc large structures */
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto end;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));     
        
    /*
    Look if the input source to decode is external capture port then add capture 
    path.
    Now decide if the channel is associated with two different association.
        1)If it going in two association than decide for which assocaiton we have 
        to create DECPCM path and for other association we have to create DECMix
        path. To decide the path type we have to use information of O/P associated 
        with the association.

        2)If it is not the part of two assocaition then it will be the usual case.

        To decide for different path

        We will take all different output port on the channel. Search the association 
        in which this output port is added. If it is associated with an association 
        where we are not mixing any other channel than look the other already existed 
        path in the channel. If their is any DecPCm path is already in system than 
        create PP path otherwise create DECPCM path. 
        If the association in which the output port is added having any other 
        channel to mix and that channel is already started than search the for 
        the path which is having same OP added in already started channel and 
        copy the links. 
        If the association in which the output port is added having any other channel 
        to mix and that channel not started and if this branch is having any output 
        port cloing than we create one Mix path & one PP path otherwise we create PP path.

        Post-Mixing path: The subsequent path after mixing(HW/FW) viz., eDecodePcmPostMixing/..
            Normal case: eDecodePcm/ePPBranch/..-->eCapture-->eDecodePcmPostMixing/..
            Decoder Output to DRAM: eDecodePcm/ePPBranch/..-->eDecodePcmPostMixing/..
            In the above cases the paths before Post-Mixing eDecodePcm,ePPBranch,..
            will not have destination details as they are feeding to any destination directly.
        Channel Network: Audio network in eDecodePcm,ePPBranch,..
        Association Network: Audio network in eDecodePcmPostMixing/..
        Currently one Association Network supported per Raptor Channel.
    */

    if(BRAP_ChannelType_eDecode == hRapCh->eChannelType)
    {
        if(BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage))
        {
            for(j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
            {
                if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,0,j)))
                    break;
            }
            j--;

            if(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle != NULL)
            {
                ret = BRAP_P_GetAssocId(hRapCh,
                                        &(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle->sExtDstDetails),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }            
            }
            else /* Path feeding to Post-Mixing path */
            {         
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                hRapCh->pDstDetails[0],
                                                pPvtDstDetails,
                                                &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                {
                    bAssociationNWDstnFound = true;
                }
                else
                {
                    BDBG_ERR(("Error! Destination not found either on"
                        " Channel Network or Association Network "));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;                    
                }
            }

            bCompress = false;
            
            for(k =1; k < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; k++)
            {
                hAudProcessing = hRapCh->sChAudProcessingStage[0][k].hAudioProcessing;                
                if(NULL == hAudProcessing)
                    break;
                eAudProc = hAudProcessing->sProcessingStageSettings.eAudioProcessing;
                
                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudProc));
                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudProc)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudProc)                        
                    ||(BRAP_ProcessingType_eEncodeDts== eAudProc)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudProc)                    
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudProc)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudProc)
                    ||(BRAP_ProcessingType_ePassthru==eAudProc))
                {
                       bCompress = true;
                       break;
                }

            }
            /*Check if the source to decode is SPDIF/HDMI/I2S or Ringbuffer*/
            if (((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)&&
                ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
                (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                (BRAP_CapInputPort_eAdc == pAudioParams->eCapInputPort)||                 
                  (BRAP_CapInputPort_eExtI2s0 == pAudioParams->eCapInputPort))) ||
                (BRAP_AudioSource_eRingBuffer == pAudioParams->eAudioSource))
            {
                /* This means that we have SPDIF/HDMI/I2S or Ringbuffer as the source 
                for the decode. So we have to create a capture path and then a 
                Decode path to handle this case */
                if(NULL == hRapCh->pPath[uiPth])
                {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                    ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                    ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }            
                }
                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                        BRAP_P_UsgPath_eCapture,
                                                        BRAP_INVALID_VALUE,
                                                        uiPth,
                                                        uiPth+1,0);
                hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;                
                /* Instantiate the DSP Channel corresponding to the DSP context resource 
                manager has allocated */
                ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                            &hRapCh,
                                            true,
                                            pDspChSettings);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                    ret = BERR_TRACE(ret);
                    goto end;
                }

                hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                uiPth++;
                if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode)
                    &&(bCompress == false))
                {
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("Malloc Path falled"));
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }            
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodePcm,
                                                            uiPth-1,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /* Before we update the resource grant, let us take out the DSP resources & put it in here */
                    /* DSP was allocated in path 0, but now moved to path 1 */ 
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func.
                      Don't populate if there is an Association network, as eDecodePCMPostMixing path feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;            
                }
                else if((BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)
                            ||(bCompress == true))
                {
                    /* In case of a SPDIF/HDMI we need to add DecodeCompress path also 
                    to handle the digital passthru case. Compressed In -> Compressed Out */            

                    if ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)||
                    (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort))
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eDecodeCompress,
                                                                uiPth-1,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        /* Before we update the resource grant, let us take out the DSP resources & put it in here */
                        /* DSP was allocated in path 0, but now moved to path 2 */ 
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;                

                      /* Don't populate if there is an Association network, as eDecodeCompressPostMixing path feeds directly to Destination */
                        if(bAssociationNWDstnFound == false)
                        {
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                            BDBG_MSG(("Adding Output port %d to Decode Compress Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));
                        }
                        uiPth++;  
                    }
                }
            } /* if ((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)*/
            else
            {
                if((BRAP_DSPCHN_DecodeMode_eDecode == pAudioParams->sDspChParams.eDecodeMode)
                    &&(bCompress == false))
                {
                    uiPth = 0;
                    BDBG_MSG(("BRAP_P_GetChannelPaths: Decode Mode "));
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;
                        }
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodePcm,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    /* Instantiate the DSP Channel corresponding to the DSP context resource 
                    manager has allocated */
                    BDBG_MSG(("BRAP_P_UsgPath_eDecodePcm uiPth=%d",uiPth));
                    
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    
                    ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                &hRapCh,
                                                true,
                                                pDspChSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                        goto end;
                    }
                    hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                    
                      /* Don't populate Destination details if there is an Association network followed.
                         It is eDecodePCMPostMixing path that feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;
                }
                else if((BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode)
                        ||(bCompress == true))
                {
                    uiPth = 0;
                    BDBG_MSG(("BRAP_P_GetChannelPaths: Pass thru Mode "));
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDecodeCompress,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    BDBG_MSG(("BRAP_P_UsgPath_eDecodeCompress uiPth=%d",uiPth));                    

                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /* Instantiate the DSP Channel corresponding to the DSP context resource 
                    manager has allocated */
                    ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                &hRapCh,
                                                true,
                                                pDspChSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                        goto end;
                    }
                    hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                    /* Don't populate if there is an Association network, as eDecodeCompressPostMixing path feeds directly to Destination */
                    if(bAssociationNWDstnFound == false)
                    {
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Decode Compress Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  
                    }
                    uiPth++;
                }
            } /*else((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)*/            

            for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
            {   
                if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))                
                {
                    break;
                }

                bIndepPathRequire = false;      

                bDownmixPathRequire = false;                
                bBranchCloned = flag = bMixPathRequire = false;
                uiClonedBranch = BRAP_INVALID_VALUE;                            
                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                {
                    uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                }
                for (j = 0; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,i,j)))  
                        break;
                }
                if((true == hRapCh->sChAudProcessingStage[i][j-1].bCloneStage)) 
                {
                    flag = true;
                }


                /* Last valid stage id */
                uiLastStage  = j -1;   
                if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle != NULL)
                {
                    ret = BRAP_P_GetAssocId(hRapCh,
                                            &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails)
                                            ,&uiAssocId );
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }                    
                }
                else
                {
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[i],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;                
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If DecodePCM/PPBranch path corresponding to Post-Mixing path 
                           is already formed then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue; 
                    }
                    else
                    {
                        BDBG_ERR(("Error! Destination not found either on"
                            " Channel Network or Association Network "));
                        ret = BERR_NOT_SUPPORTED;
                        goto end;                    
                    }
                }                

            /*If its Mai and Muxselector is not Mai, then dont create path for it */
                if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                    &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                    &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                    ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                {                
                if(flag == false)
                {
                    bBranchCloned = false;
                }
                else
                {
                    ui32MasterBranchId = k= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterBranchId;
                    ui32MasterStageId = l= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterStageId;
                    m=0;
                    /* Check if the current branch is the clone of master branch of last stage of the current branch */
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))           
                    {
                        bBranchCloned = true;
                        uiCloneBranchId[m]=k;
                        m++;
                        k++;
                    }

                    /* Now check if the branches between Master branch and current branch is similar to current  branch.
                    This is done by checking if the last stage is cloned, and its Master stage/branch id 
                    is same as that of last stage id of current branch. Just to make clear, here 
                    Current Branch/Stage Id is : i/uiLastStage
                    Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                    And we looping on K, which is between ui32MasterBranchId and i*/                                    
                    for(; k<i; ++k)
                    {
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))
                        {   
                                if((true == hRapCh->sChAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId)
                                    &&(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1))))
                            {
                                bBranchCloned = true;
                                uiCloneBranchId[m]=k;
                                m++;
                            } 
                        }
                    }

                    /* Now if there  are branches which are cloned to current then, Are they in same
                    association? If no then Create a Mix Path corresponding to them , If not created 
                    already.*/
                    if(bBranchCloned == true)
                    {                        
                        if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        {                    
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                
                                            if((hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                                ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                    hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                {
                                    bDownmixPathRequire = false;
                                    uiClonedBranch = k;
                                    break;
                                }
                                else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                {
                                    bDownmixPathRequire = true;
                                }
                            }
                        }

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                        if((false == bDownmixPathRequire))
                        {                        
                        /*If its Mai and Muxselector is not Mai, then dont create path for it */
                            if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                                &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                                ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                            {
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/

#if (BRAP_DYNAMIC_PORT_SWITCHING != 1)
                                if((hRapCh->bIndepDelayEnabled == true)
                                    &&((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                       ||((hRapCh->sChAudProcessingStage[k][l].hValidDestHandle != NULL) &&
                                          (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                                           ||(hRapCh->eChannelOutputMode == BRAP_OutputMode_e2_0)
                                       ||((hRapCh->sChAudProcessingStage[k][l].hValidDestHandle != NULL) &&
                                          (hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                           hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort)))
                                  )
                                {
                                    bIndepPathRequire = true;
                                    uiClonedBranch = k;                                                                                
                                    break;
                                }
                                else
                                {
                                    bIndepPathRequire = false;
                                    uiClonedBranch = k;                                            
                                }
#else
                                if( (hRapCh->bIndepDelayEnabled == true) &&
                                    ((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                     (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                     (hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay != 
                                     hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay))
                                    )
                                {
                                    bIndepPathRequire = true;
                                    uiClonedBranch = k;                                                                                
                                    break;                                    
                                }
                                else if( (hRapCh->bIndepDelayEnabled == true) &&
                                         ((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                         (hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                         (hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay == 
                                          hRapCh->hRap->sOutputSettings[hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]].iDelay))
                                        )
                                {
                                    switch(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0])
                                    {
                                        case BRAP_OutputPort_eMax:
                                            BDBG_ERR(("BRAP_DEC_Start: Output port type %d not supported", BRAP_OutputPort_eMax));
                                            return BERR_TRACE(BERR_NOT_SUPPORTED);                               
                                            break;
                                        case BRAP_OutputPort_eDac2:
                                            for(j=(i-1); j>=k; j--)
                                            {
                                                if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                                   (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eDac1))
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = j;
                                                    bBranchFoundForDummy = true;
                                                    break;                                                        
                                                }
                                            }
                                            if(j<k)
                                            {
                                                BDBG_ERR(("No Master port added corresponding to DAC2 output port"));
                                                return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                            }
                                            break;
                                        case BRAP_OutputPort_eI2s1: 
                                            for(j=(i-1); j>=k; j--)
                                            {
                                                if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                                   (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eI2s4))
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = j;
                                                    bBranchFoundForDummy = true;                                                        
                                                    break;                                                        
                                                }
                                            }
                                            if(j<k)
                                            {
                                                BDBG_ERR(("No Master port added corresponding to I2S1 output port"));
                                                return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                            }
                                            break;
                                        default:
                                            bIndepPathRequire = true;
                                            uiClonedBranch = k;
                                            break;
                                    }
                                    BDBG_MSG(("Output Port = %d, bIndepPathRequire=%d, uiClonedBranch=%d",
                                        hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0],
                                        bIndepPathRequire,uiClonedBranch));
                                    /*if(bIndepPathRequire == true)*/
                                        break;
                                }                              
                                /* Assumption: There will be no two ringbuffer destinations */
                                else if( (hRapCh->bIndepDelayEnabled == true) &&
                                         (hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) 
                                        )
                                {
                                    /* If it is a dummy capture for SPDIF */
                                    if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sRBufDetails.bDontPauseWhenFull == true)
                                    {
                                        for(j=(i-1); j>=k; j--)
                                        {
                                            if((hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                                               (hRapCh->sChAudProcessingStage[j][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif))
                                            {
                                                bIndepPathRequire = false;
                                                uiClonedBranch = j;
                                                bBranchFoundForDummy = true;
                                                break;                                                        
                                            }
                                        }
                                        if(j<k)
                                        {
                                            BDBG_ERR(("No Master port added corresponding to DAC2 output port"));
                                            return BERR_TRACE(BERR_NOT_SUPPORTED);                                                                                                                               
                                        }                                    
                                    }
                                }                                
                                else
                                {
                                    bIndepPathRequire = false;
                                    uiClonedBranch = k;                                            
                                }                                     
#endif
                            }
                        }                        
                    }
#endif                        
                        if((false == bIndepPathRequire)
                            &&(false == bDownmixPathRequire)
#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
                            &&(false == bBranchFoundForDummy)
#endif
                            )
                        {
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                &(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                                pPvtDstDetails,
                                                                                &uiCloneAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                
                                }
                                /* For this branch */
                                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                    &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                                    pPvtDstDetails,
                                                                                    &uiAssocId);
                                if(BERR_SUCCESS!=ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                
                                }
                                if(uiAssocId == uiCloneAssocId)
                                {
                                    bMixPathRequire = false;
                                    uiClonedBranch = k;
                                    break;
                                }
                                else
                                {
                                    bMixPathRequire = true;
                                }
                            }
                        }
                        }
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                }                        
                else
                {
                    bBranchCloned = true;
                    for(k =0; k<i; ++k)
                    {
                        if((BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                        {   
                            if((hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                &&(hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                != BRAP_OutputPort_eMai)
                                &&(hRapCh->sChAudProcessingStage[k][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]
                                == hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector))
                            {
                                uiClonedBranch = k;
                                BDBG_MSG(("################Coming here k =%d",k));
                            }
                        }
                    }
                } /*if(bBranchCloned == true)*/
                
                BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                bBranchCloned,uiAssocId,uiCloneAssocId));
                if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))
                    ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                {

                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }
                    if( (((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                          &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                         ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0) )    /* Capture to rbuf is required in stereo mode as of now */
                    {
                    
/*                        if(uiLastStage == 0)*/
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDownmixedPath,
                                                                    BRAP_INVALID_VALUE, 
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                        }
                    }
                    else
                    {
                    BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_ePPBranch,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    }
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                    uiPth++;
                } /*if((false == bBranchCloned)&&*/
                else if ((true == bBranchCloned) && (true == bMixPathRequire))
                {   
                    /*Find the Path which is having cloned port */
                    ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);


                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }   
                    if((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                        && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                    {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eDownmixedMixPath,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                    BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));                    
                    }
                    else
                    {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                            BRAP_P_UsgPath_eMixPath,
                                                            BRAP_INVALID_VALUE, 
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);        
                    BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));                    
                    }
                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                    /*Mark the path which is cloned for this stage as mix*/
                    BDBG_MSG(("Input to mix path uiPth=%d",m));
                    hRapCh->pPath[m]->bMixPath = true;
                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                    BDBG_MSG(("Adding Output port %d to  Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));                      
                    ++uiPth;
                } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                else
                {
                    /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                    no path is created for this destination. So add this destination to the path it belong.*/
                    uiCloneOp++;
                    flag = false;
                    for(m =0 ; m < uiPth ; m++)
                    {
                        uiDestCount = hRapCh->pPath[m]->uiDestcount;
                        
                        for(n =0 ; n < uiDestCount ; n++)
                        {
                            
                            if(hRapCh->pPath[m]->pDstDetails[n] == 
                                &(hRapCh->sChAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                            {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                if(bIndepPathRequire == true)
                                {/* Create a Path */
                                
                                    switch(hRapCh->pPath[m]->eUsgPath)
                                    {
                                        case BRAP_P_UsgPath_eDecodePcm:
                                        case BRAP_P_UsgPath_eDecodeCompress:                                            
                                        case BRAP_P_UsgPath_ePPBranch:                                            
                                        case BRAP_P_UsgPath_eMixPath:                                            
                                        case BRAP_P_UsgPath_eSharedPP:                                                            
                                            ePathType = BRAP_P_UsgPath_ePPBranch;
                                            break;
                                        case BRAP_P_UsgPath_eDownmixedPath:
                                        case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                            ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                            break;
                                        default:
                                            ePathType = BRAP_P_UsgPath_ePPBranch;
                                            break;
                                    }
                                    
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                                   
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                            
                                        }
                                    }
                                    BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                            ePathType,
                                                                            BRAP_INVALID_VALUE, 
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);

                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                    hRapCh->pPath[uiPth]->uiMasterpathId = m;

                                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);

                                    /* Get the Assoc Id corresponding to the Destination this path is feeding and update it in pPath */
                                    ret = BRAP_P_GetAssocId(hRapCh,
                                                &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails),
                                                &uiAssocId );    
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;
                                    }
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    
                                    if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    else if(hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                      
                                    }
                                    uiPth++;                                    
                                    
                                }
                                else
#endif                                    
                                {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                    if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eOutputPort)
                                    {
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    else if(hRapCh->pPath[m]->pDstDetails[uiDestCount]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                                    {
                                        BDBG_MSG(("Adding Capture port %d to  Path type = %d", 
                                            hRapCh->pPath[m]->pDstDetails[uiDestCount]->uDstDetails.sRBufDetails.eCapPort[0],hRapCh->pPath[m]->eUsgPath));
                                    }
                                    hRapCh->pPath[m]->uiDestcount++;
                                }
                                flag =true;
                                break;
                            }
                        }
                        if(true == flag)
                            break;
                    }
                }
            } /*for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)*/
            BDBG_MSG(("Checking for Internal capture path"));
            /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));
                
                BDBG_MSG(("hRapCh->pDstDetails[i]=%x",hRapCh->pDstDetails[i]));
                /*Find the audio procsssing for the destination of the row on association network*/
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                BDBG_MSG(("BRAP_P_GetChannelPath: Internal capture path 1"));
                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            { 
                                ret =  BERR_TRACE(ret);
                                goto end;                                
                            }
                        }                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        
                        BDBG_MSG(("BRAP_P_UsgPath_eCapture uiPth=%d",uiPth));
                        
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                        
                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] =  hRapCh->pDstDetails[i];
                        
                    }
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == BRAP_INVALID_VALUE))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                break;                            
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;                
                    uiPth++;
                }
            }

        } /* if((true == hRapCh->sChAudProcessingStage[0][0].bCloneStage)*/

        /* Allocating the path for association network.
           ToDo: Algorithm */
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {        
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;

            uiAssocId = hRapCh->uiAssociationId[l];                

            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                BDBG_MSG(("Allocating the path for Association Network"));            
                
                bCompress = false;     
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));

                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL != hRapCh->pDstDetails[i])
                    {
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                        hRapCh->pDstDetails[i],
                                                        pPvtDstDetails,
                                                        &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                
                        }
                        if((m == uiAssocId) && (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                        {
                            break;
                        }
                    }            
                }
                if(i >= BRAP_P_MAX_DST_PER_RAPCH)
                {
                    BDBG_MSG(("No destination found in Association Network"));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;
                }

                m = BRAP_INVALID_VALUE;

            /* Check if the Path outputs the compress data  */
            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
            {
                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                    break;

                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)                        
                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                {
                    bCompress = true;
                    break;
                }
            }
            /* Last valid stage of association network */
            if(m>0)
            {
                uiLastStage = m -1;
            }
            else
            {
                uiLastStage = BRAP_INVALID_VALUE;
                BDBG_ERR(("Network must have one valid stage"));
                ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                goto end;
            }
                
            if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst)
            {
                if(NULL == hStartedAssoCh[uiAssocId])
                {
                    BRAP_AssociatedChannelHandle hAssociation;
                    hAssociation = &(hRapCh->hRap->sAssociatedCh[uiAssocId]);
           
                    /* Capture path not required for Decode channel, for MS10/11 */
                    if(!(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh)))
                    {
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)
                        {
                            if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                            {
                                break;
                            }
                            for(m=0; m<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++m)
                            {
                                if(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,m))
                                {
                                    continue;
                                }
                                else
                                    break;
                            }
                            /*Valid stage is before this value of m so subtract 1*/
                            m--;
                            
                            /*Get the path index*/
                            if(hRapCh->sChAudProcessingStage[k][m].hValidDestHandle == pPvtDstDetails)
                            {
                                ret = BRAP_P_GetInputPathIndexForAssociation(hRapCh,uiAssocId,&j);
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                            
                                }
                                break;
                            }
                        } /*for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)*/
                        
                        if(k >= BRAP_P_MAX_DST_PER_RAPCH)
                        {
                            ret = BERR_NOT_SUPPORTED;
                            BDBG_ERR(("Valid Destination not found in Channel Processing stage"));
                            goto end;                            
                        }
                
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }                        
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eCapture,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        BDBG_MSG(("BRAP_P_UsgPath_eCapture uiPth=%d",uiPth));
                        
                        /* Link current and previous path */
                        if((j < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (hRapCh->pPath[j] != NULL))
                        {
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                            hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                        (*uiNumCapPath)++;                
                        uiPth++;
                    }

                    if(true == bCompress)
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BDBG_MSG(("BRAP_P_UsgPath_eDecodeCompressPostMixing uiPth=%d",uiPth));                            
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);

                        /* Instantiate the DSP Channel corresponding to the DSP context resource 
                        manager has allocated */
                        ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                    &hAssociation,
                                                    false,
                                                    pDspChSettings);
                        if(BERR_SUCCESS != ret)
                        {
                            ret = BERR_TRACE(ret);
                            BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                            goto end;
                        }
                        hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                        
                        hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                        hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] = hRapCh->pDstDetails[0];
                        uiPth++;                    
                    }
                    else
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            { 
                                ret = BERR_TRACE(ret);
                                goto end;                                       
                            }
                        }
                        BDBG_MSG(("BRAP_P_UsgPath_eDecodePcmPostMixing uiPth=%d",uiPth));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eDecodePcmPostMixing,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
                        
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] = hRapCh->pDstDetails[0];
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount-1]->uDstDetails.sOpDetails.eOutput[0],uiPth));                         
                            uiPth++;
                        }              
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                (NULL == hRapCh->pPath[uiPth])&&
                                (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                (BRAP_P_UsgPath_eDecodePcmPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                
                                uiPth++;
                                break;                            
                            }
                        }
                    }
                } /* if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst) */

                if(BRAP_P_MAX_PATHS_IN_A_CHAN <= uiPth)
                {
                    ret = BERR_TRACE(BERR_NOT_SUPPORTED);                
                    BDBG_ERR(("No Free slot available to form Post Mixing Paths"));
                    goto end;
                }
                
                /* Check for more destinations connected to Association Network */
                ret = BRAP_P_FormPostMixingPathsForSubsequentDestinations(i, uiPth, uiAssocId, pAudioParams,hRapCh);
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    BDBG_ERR(("FormPostMixingPathsForSubsequentDestinations failed with err = %d", ret));
                    goto end;
                }
            } /* if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage)) */
        } /* for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l) */
    } /* if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) */
    
    else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
    {
#if 0    
        bSpdifMaiPresent = false;
        uiSpdifMaiPathindex =BRAP_INVALID_VALUE;
#endif        
        uiPth = 0;
        m=0;
        bAssociationNWDstnFound=false;
        BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
        if(hRapCh->pDstDetails[0] == NULL)
        {
            BDBG_ERR(("There should atleast one valid destination."));
            ret = BERR_TRACE(BERR_INVALID_PARAMETER);
            goto end;
        }
        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                        hRapCh->pDstDetails[0],
                                        pPvtDstDetails,
                                        &uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto end;
        }
        if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
        {
            bAssociationNWDstnFound = true;
        }        

        if(NULL == hRapCh->pPath[uiPth])
        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                            ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                            ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif              
            if(BERR_SUCCESS != ret)
            {
                ret =  BERR_TRACE(ret);
                goto end;                
            }
        }
        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                            BRAP_P_UsgPath_eDecodePcm,
                            BRAP_INVALID_VALUE,
                            uiPth,
                            BRAP_INVALID_VALUE,0);
        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

          /* Populate only if there is no Association network, since eDecodePCMPostMixing path feeds directly to Destination */
        if(bAssociationNWDstnFound == false)
        {
            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[0];
#if 0            
            if(( hRapCh->pDstDetails[0]->eAudioDst == BRAP_AudioDst_eOutputPort)
                &&((hRapCh->pDstDetails[0]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif)
                      ||(hRapCh->pDstDetails[0]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)))
            {
                bSpdifMaiPresent =true;
                uiSpdifMaiPathindex=uiPth;
            }
#endif            
                BDBG_MSG(("Adding Output port %d to  Path type = %d", 
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));
        }
        
        uiPth++;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                         
        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
        if(hRapCh->bIndepDelayEnabled == true)
        {
            for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
            {
            if( hRapCh->pDstDetails[m] != NULL)
            {
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[m],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If DecodePCM/PPBranch path corresponding to Post-Mixing path 
                           is already formed then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue; 
                    }
                    
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                           
                        if(BERR_SUCCESS != ret)
                        {
                            ret =  BERR_TRACE(ret);
                            goto end;                
                        }
                    }
                    
/*Disabling This Code because when HDMI and SPDIF is taking data from same SRC, IT is causing audio loss due to MIXER Rate Err*/                    
#if 0                    
                    if(( hRapCh->pDstDetails[m]->eAudioDst == BRAP_AudioDst_eOutputPort)
                        &&((hRapCh->pDstDetails[m]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eSpdif)
                              ||(hRapCh->pDstDetails[m]->uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)))
                    {
                        if(true == bSpdifMaiPresent)
                        {
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eSharedPP,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            k=uiSpdifMaiPathindex;
                            hRapCh->pPath[k]->bMixPath = true;
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = k;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));
                        }
                        else
                        {
                            bSpdifMaiPresent = true;
                            uiSpdifMaiPathindex = uiPth;
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_ePPBranch,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            
                            k=0;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                
                        }
                    }
                    else
#endif                        
                    {
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_ePPBranch,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            hRapCh->pPath[uiPth]->uiMasterpathId = 0;
                            
                            k=0;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh;                     
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                
                    }    
                    uiPth++;                
            }
        }
        }
         else
#endif            
        {
            for(m = 1; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
            {
                if( hRapCh->pDstDetails[m] != NULL)
                {        
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                    hRapCh->pDstDetails[m],
                                                    pPvtDstDetails,
                                                    &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                    {
                        /* If Destination details corresponding to Post-Mixing path are already 
                           populated in DecodePCM/PPBranch path then go to next destination */
                        if(bAssociationNWDstnFound == true)
                            continue;
                        else
                            bAssociationNWDstnFound = true;
                    }
                    
                    uiDestCount = hRapCh->pPath[uiPth -1]->uiDestcount++;
                    hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth -1]->eUsgPath));                                                  
                }
            }
        }



        /* See if any added destination needs Internal Capture Path */
        for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
        {
            if(NULL == hRapCh->pDstDetails[i])
                continue;
            /* Find the association ID for the destination */
            BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));           
            
            ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                hRapCh->pDstDetails[i],
                                                                pPvtDstDetails,
                                                                &uiAssocId);
            if(BERR_SUCCESS!=ret)
            {
                ret = BERR_TRACE(ret);
                goto end;                
            }

            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
            {
                if(NULL == hStartedAssoCh[uiAssocId])
                {
                    if(NULL == hRapCh->pPath[uiPth])
                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
										ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
										ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                        if(BERR_SUCCESS != ret)
                        { 
                            ret = BERR_TRACE(ret);
                            goto end;                            
                        }
                    }                        
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                            BRAP_P_UsgPath_eCapture,
                                                            BRAP_INVALID_VALUE,
                                                            uiPth,
                                                            BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                         /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;                         
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];
                }
                else
                {
                    flag = false;
                    /* Copy the relevant path from the started channel */
                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                    {
                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                        {
                            for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                            {
                                if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                            hRapCh->pDstDetails[i])
                                { 
                                    hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                    BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                    uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                                    uiPth++;                                    
                                    flag = true;
                                    break;
                                }
                            }
                            if (flag == true)
                            break;                            
                        }
                    }
                }
                (*uiNumCapPath)++;                
                uiPth++;   
            }
        }
            
        /******* Association Network *******/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];

            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {   
                BDBG_MSG(("Allocating the path for Association Network"));            
                i=0;
                bCompress = false;
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    

                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {
                    if(NULL != hRapCh->pDstDetails[i])
                    {
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                        hRapCh->pDstDetails[i],
                                                        pPvtDstDetails,
                                                        &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;                
                        }
                        if((m == uiAssocId) && (BRAP_P_IsAssociationNWValid(pPvtDstDetails)))
                        {
                            break;
                        }
                    }            
                }
                if(i >= BRAP_P_MAX_DST_PER_RAPCH)
                {
                    BDBG_MSG(("No destination found in Association Network"));
                    ret = BERR_NOT_SUPPORTED;
                    goto end;
                }

                m = BRAP_INVALID_VALUE;

                /* Check if the Path outputs the compress data  */
                for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                {
                    if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                        break;

                    eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                    BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                    if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                        ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                        ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                        ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                        ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                    {
                        bCompress = true;
                    }
                }
                if(m>0)
                {
                    uiLastStage = m -1;
                }
                else
                {
                    uiLastStage = BRAP_INVALID_VALUE;
                    BDBG_ERR(("Network must have one valid stage"));
                    ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                    goto end;                    
                }
                
                if(BRAP_AudioDst_eMax != hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        BRAP_AssociatedChannelHandle hAssociation;
                        hAssociation = &(hRapCh->hRap->sAssociatedCh[uiAssocId]);
 
                        for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)
                            { 
                            if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,k)))
                            {
                                break;
                            }
                            for(m=0; m<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++m)
                            {
                                if(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,m))
                                {
                                    continue;
                                }
                                else
                                    break;
                            }
                            /*Valid stage is before this value of m so subtract 1*/
                            m--;
                            
                            /*Get the path index*/
                            if(hRapCh->sChAudProcessingStage[k][m].hValidDestHandle == pPvtDstDetails)
                            {
                                ret = BRAP_P_GetInputPathIndexForAssociation(hRapCh,uiAssocId,&j);
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                            
                                }
                                break;
                            }
                        } /*for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; ++k)*/
                        if(k >= BRAP_P_MAX_DST_PER_RAPCH)
                        {
                            ret = BERR_NOT_SUPPORTED;
                            BDBG_ERR(("Valid Destination not found in Channel Processing stage"));
                            goto end;                            
                        }
                        
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                            if(BERR_SUCCESS != ret)
                            { 
                                ret =  BERR_TRACE(ret);
                                goto end;                                    
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                            BRAP_P_UsgPath_eCapture,
                                            BRAP_INVALID_VALUE,
                                            uiPth,
                                            BRAP_INVALID_VALUE,0);
                        flag = false;
                        /* Link current and previous path */
                        if((j < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                           (hRapCh->pPath[j] != NULL))
                        {
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        (*uiNumCapPath)++;                
                        uiPth++;
                        
                        if(true == bCompress)
                        {
                            /*Now allocate BRAP_P_UsgPath_eDecodeCompressPostMixing because 
                            first row of association network is available*/
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                    
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                            hRapCh->pPath[uiPth-1]->uiAssocId = uiAssocId;                        
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] =
                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[0]->sExtDstDetails);                                                                        
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount -1]->uDstDetails.sOpDetails.eOutput[0],uiPth));
                            
                            uiPth++;
                        }
                        else
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret = BERR_TRACE(ret);
                                    goto end;                                
                                }
                            }                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                BRAP_P_UsgPath_eDecodePcmPostMixing,
                                                BRAP_INVALID_VALUE,
                                                uiPth,
                                                BRAP_INVALID_VALUE,0);

                            /* Instantiate the DSP Channel corresponding to the DSP context resource 
                            manager has allocated */
                            
                            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                                        &hAssociation,
                                                        false,
                                                        pDspChSettings);
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                                goto end;
                            }
                            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;

                            /* Update Inlink and Outlink */
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                            {
                                if(hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                {
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[uiPth-1]->sOutPathProp[n].uiPathIdx = uiPth;
                                    flag = true;
                                    break;                            
                                }
                            }
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount++] =
                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[0]->sExtDstDetails);                                                                        
                            BDBG_MSG(("Adding OutputPort %d to Path = %d",
                                hRapCh->pPath[uiPth]->pDstDetails[hRapCh->pPath[uiPth]->uiDestcount -1]->uDstDetails.sOpDetails.eOutput[0],uiPth)); 
                            
                            uiPth++;   
                        }                      
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {                    
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT
/* Currently MS11 usage mode at max has 2 decode and 1 PB channels, 
   and no resources are shared among them as decode channels output to DRAM and PB to RBUF.
   ToDo: If multiple PB channels per Assoc need to be supported */
                        if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                                            
                                if(BERR_SUCCESS != ret)
                                { 
                                    ret =  BERR_TRACE(ret);
                                    goto end;                                    
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                BRAP_P_UsgPath_eCapture,
                                                BRAP_INVALID_VALUE,
                                                uiPth,
                                                BRAP_INVALID_VALUE,0);
                            flag = false;
                            for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                            {
                                if(NULL == hRapCh->pPath[j])
                                {
                                    continue;
                                }
                                if(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                                {
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                                    {
                                        if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                        {
                                            /* Set the out path index of previous path */
                                            hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                            flag = true;
                                            break;                            
                                        }
                                    }
                                }
                                if(flag == true)
                                {
                                    break;
                                }
                            }
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            (*uiNumCapPath)++;                
                            uiPth++;
                        }
#endif                    
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                               (NULL == hRapCh->pPath[uiPth])&&
                               (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                               (hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[0] == hRapCh->pDstDetails[i]))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                
                                uiPth++;
                                break;                            
                            }
                        }
                    }
                } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/

                /* Check for more destinations connected to Association Network */
                ret = BRAP_P_FormPostMixingPathsForSubsequentDestinations(i, uiPth, uiAssocId, pAudioParams,hRapCh);
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    BDBG_ERR(("FormPostMixingPathsForSubsequentDestinations failed with err = %d", ret));
                    goto end;
                }           
            } /* if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage)) */
        } /* for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l) */
    } /* else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType) */

    else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
    {
        if(BRAP_CaptureMode_eCaptureOnly == pAudioParams->eCapMode)
        {
            uiPth = 0;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eCapture,
                                                    BRAP_INVALID_VALUE,
                                                    uiPth,
                                                    BRAP_INVALID_VALUE,0);
            uiPth++;

           
           /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &uiAssocId);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }

                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                        
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }
                        
                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];

                    }
                    else
                    {
                        flag = false;
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                            {
                                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                    hRapCh->pDstDetails[i])
                                    {
                                        hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;                
                    uiPth++;
                }
            }
        }
        else if(BRAP_CaptureMode_eFullDuplex == pAudioParams->eCapMode)
        {
            if(BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage))
            {
                for(j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                {
                    if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,0,j)))
                        break;
                }
                j--;        
                ret = BRAP_P_GetAssocId(hRapCh,
                                        &(hRapCh->sChAudProcessingStage[0][j].hValidDestHandle->sExtDstDetails),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }

            }
            else if ( hRapCh->pDstDetails[0] != NULL)
            {
                ret = BRAP_P_GetAssocId(hRapCh,
                                        (hRapCh->pDstDetails[0]),
                                        &uiAssocId );    
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;
                }
            }
            else
            {
                BDBG_ERR(("No destination added to Capture Ch"));
                BDBG_ASSERT(0);
            }
            
            uiPth = 0;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eCapture,
                                                    BRAP_INVALID_VALUE,
                                                    uiPth,
                                                    (uiPth+1),0);
            hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
            
            /* Instantiate the DSP Channel corresponding to the DSP context resource 
            manager has allocated */
            ret = BRAP_DSPCHN_P_Open(   &(hRapCh->pPath[uiPth]->hDspCh),
                                        &hRapCh,
                                        true,
                                        pDspChSettings);
            if(BERR_SUCCESS != ret)
            {
                ret = BERR_TRACE(ret);
                BDBG_ERR(("DSPCHN_P_Opened failed with err = %d", ret));
                goto end;
            }
            hRapCh->pPath[uiPth]->hDspCh->sDspAudioParams.sExtAudioParams = pAudioParams->sDspChParams;
            
            uiPth++;
            if(NULL == hRapCh->pPath[uiPth])
            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                
                if(BERR_SUCCESS != ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                    
                }
            }
            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                    BRAP_P_UsgPath_eDecodePcm,
                                                    (uiPth -1),
                                                    uiPth,
                                                    BRAP_INVALID_VALUE,0);

            /* Before we update the resource grant, let us take out the DSP resources & put it in here */
            /* DSP was allocated in path 0, but now moved to path 1 */ 
            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
            
            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;            

#if ((BRAP_3548_FAMILY == 1) || (BRAP_7405_FAMILY == 1))
            if((BRAP_P_NETWORK_VALID(hRapCh->sChAudProcessingStage)))
            {
                /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[0][0].hValidDestHandle->sExtDstDetails);
                BDBG_MSG(("Adding Output port %d to Decode PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount]->uDstDetails.sOpDetails.eOutput[0]));  
                uiPth++;

                /* Start Multi Branch code */
                for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {   
                    if(!(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))                
                    {
                        break;
                    }
        #if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                 
                    bIndepPathRequire = false;      
        #endif
                    bDownmixPathRequire = false;                
                    bBranchCloned = flag = bMixPathRequire = false;
                    uiClonedBranch = BRAP_INVALID_VALUE;                            
                    for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                    {
                        uiCloneBranchId[k] = BRAP_INVALID_VALUE;
                    }
                    for (j = 0; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
                    {
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,i,j)))  
                            break;
                    }
                    if((true == hRapCh->sChAudProcessingStage[i][j-1].bCloneStage)) 
                    {
                            flag = true;
                    }

                    /* Last valid stage id */
                        uiLastStage  = j -1;   

                    ret = BRAP_P_GetAssocId(hRapCh,
                                &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                &uiAssocId );    
                    if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    
                    if(flag == false)
                    {
                        bBranchCloned = false;
                    }
                    else
                    {
                        ui32MasterBranchId = k= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterBranchId;
                        ui32MasterStageId = l= hRapCh->sChAudProcessingStage[i][uiLastStage].ui32MasterStageId;
                        m=0;
                        /* Check if the current branch is the clone of master branch of last stage of the current branch */
                        if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))           
                        {
                            bBranchCloned = true;
                            uiCloneBranchId[m]=k;
                            m++;
                            k++;
                        }
                        /* Now check if the branches between Master branch and current branch is similar to current  branch.
                        This is done by checking if the last stage is cloned, and its Master stage/branch id 
                        is same as that of last stage id of current branch. Just to make clear, here 
                        Current Branch/Stage Id is : i/uiLastStage
                        Master Branch/Stage Id is : ui32MasterBranchId/ui32MasterStageId
                        And we looping on K, which is between ui32MasterBranchId and i*/                                    
                        for(; k<i; ++k)
                        {
                            if(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1)))
                        {   
                                if((true == hRapCh->sChAudProcessingStage[k][l].bCloneStage)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterBranchId == ui32MasterBranchId)
                                    &&(hRapCh->sChAudProcessingStage[k][l].ui32MasterStageId == ui32MasterStageId)
                                    &&(!(BRAP_P_STAGE_VALID(hRapCh->sChAudProcessingStage,k,l+1))))
                            {
                                bBranchCloned = true;
                                uiCloneBranchId[m]=k;
                                m++;
                            } 
                        }
                        }
                        /* Now if there  are branches which are cloned to current then, Are they in same
                        association? If no then Create a Mix Path corresponding to them , If not created 
                        already.*/
                        if(bBranchCloned == true)
                        {
                            if(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            {                    
                            for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                            {
                                if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                    break;
                                
                                k = uiCloneBranchId[m];
                                /* For cloned branch */
                                    
                                    if((hRapCh->eChannelOutputMode ==BRAP_OutputMode_e2_0)
                                        ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                        hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                    {
                                        bDownmixPathRequire = false;
                                        uiClonedBranch = k;
                                        break;
                                    }
                                    else if (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0)
                                    {
                                        bDownmixPathRequire = true;
                                    }
                                }
                            }
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                                  
                            if((false == bDownmixPathRequire))
                            {                        
                            /*If its Mai and Muxselector is not Mai, then dont create path for it */
                                if( (!((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                                       &&(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == BRAP_OutputPort_eMai)
                                       &&(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings.eMaiMuxSelector != BRAP_OutputPort_eMai)))
                                    ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer) )
                                {
                                       for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                        {
                                            if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                                break;
                                            
                                            k = uiCloneBranchId[m];
                                            /* For cloned branch */
                                            /*If the Destination has Indepdelay Enabled then create similar path to its cloned.*/
                                            if((hRapCh->bIndepDelayEnabled == true)
                                                &&((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                                   ||(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)
                                                   ||(hRapCh->eChannelOutputMode ==BRAP_OutputMode_e2_0)
                                                   ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == 
                                                      hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort))
                                              )
                                                {
                                                    bIndepPathRequire = true;
                                                    uiClonedBranch = k;                                                                                
                                                    break;
                                                }
                                                else
                                                {
                                                    bIndepPathRequire = false;
                                                    uiClonedBranch = k;                                            
                                                }
                                        }                        
                                    }                        
                                }
#endif                        
                            
                            if((false == bIndepPathRequire)
                                &&(false == bDownmixPathRequire))
                            {
                                for(m=0; (m<BRAP_P_MAX_DST_PER_RAPCH)   ; ++m)
                                {
                                    if(uiCloneBranchId[m] == BRAP_INVALID_VALUE)
                                        break;
                                    
                                    k = uiCloneBranchId[m];
                                    /* For cloned branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                    &(hRapCh->sChAudProcessingStage[k][l].hValidDestHandle->sExtDstDetails),
                                                                                    pPvtDstDetails,
                                                                                    &uiCloneAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    /* For this branch */
                                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                                        &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails),
                                                                                        pPvtDstDetails,
                                                                                        &uiAssocId);
                                    if(BERR_SUCCESS!=ret)
                                    {
                                        ret = BERR_TRACE(ret);
                                        goto end;                
                                    }
                                    if(uiAssocId == uiCloneAssocId)
                                    {
                                        bMixPathRequire = false;
                                        uiClonedBranch = k;                                
                                        break;
                                    }
                                    else
                                    {
                                        bMixPathRequire = true;
                                    }
                                }
                            }                            
                        } /*if(bBranchCloned == true)*/
                    } /*if(j == BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED)*/
                    BDBG_MSG(("bBranchCloned=%d uiAssocId=%d uiCloneAssocId=%d",
                    bBranchCloned,uiAssocId,uiCloneAssocId));
                    if(((false == bBranchCloned)&&(BRAP_P_BRANCH_VALID(hRapCh->sChAudProcessingStage,i)))
                        ||((true == bBranchCloned) && (true == bDownmixPathRequire)))
                    {

                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }
                        if((((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                             &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true))
                            ||(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer))
                           && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))    /* Capture to rbuf is required in stereo mode as of now */
                        {
                        
    /*                        if(uiLastStage == 0)*/
                            {
                                BDBG_MSG(("BRAP_P_UsgPath_eDownmixedPath"));                                        
                                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                        BRAP_P_UsgPath_eDownmixedPath,
                                                                        BRAP_INVALID_VALUE, 
                                                                        uiPth,
                                                                        BRAP_INVALID_VALUE,0);
                            }
                        }
                        else
                    {
                        BDBG_MSG(("BRAP_P_UsgPath_ePPBranch"));
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_ePPBranch,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        }
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));  
                        uiPth++;
                    } /*if((false == bBranchCloned)&&*/
                    else if ((true == bBranchCloned) && (true == bMixPathRequire))
                    {   
                        /*Find the Path which is having cloned port */
                        ret = BRAP_P_GetPathIndex(hRapCh,pAudioParams,k,uiCloneOp,&m);
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }   
                        if((hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                            &&(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.bDownmixedOpPort == true)
                            && (hRapCh->eChannelOutputMode > BRAP_OutputMode_e2_0))
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eDownmixedMixPath uiPth=%d",uiPth));                        
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDownmixedMixPath,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        }
                        else
                        {
                            BDBG_MSG(("BRAP_P_UsgPath_eMixPath uiPth=%d",uiPth));                       
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eMixPath,
                                                                BRAP_INVALID_VALUE, 
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        /*Mark the path which is cloned for this stage as mix*/
                        BDBG_MSG(("Input to mix path uiPth=%d",m));
                        hRapCh->pPath[m]->bMixPath = true;
                        hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = m;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[m]->sRsrcGrnt.uiDspId;
                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[m]->sRsrcGrnt.uiDspContextId;
                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[m]->hDsp; 
                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[m]->hDspCh; 

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                        BDBG_MSG(("Adding Output port %d to Mix PCM Path", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0]));  

                        ++uiPth;
                    } /*else if ((true == bBranchCloned) &&(uiAssocId != uiCloneAssocId))*/
                    else
                    {
                        /* If Independent delay is on, then a corresponding path is created for the destination. Otherwise
                        no path is created for this destination. So add this destination to the path it belong.*/
                        uiCloneOp++;
                        flag = false;
                        for(m =0 ; m < uiPth ; m++)
                        {
                            uiDestCount = hRapCh->pPath[m]->uiDestcount;
                            
                            for(n =0 ; n < uiDestCount ; n++)
                            {
                                
                                if(hRapCh->pPath[m]->pDstDetails[n] == 
                                    &(hRapCh->sChAudProcessingStage[uiClonedBranch][0].hValidDestHandle->sExtDstDetails))
                                {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)          
                                    if(bIndepPathRequire == true)
                                    {/* Create a Path */

                                        switch(hRapCh->pPath[m]->eUsgPath)
                                        {
                                            case BRAP_P_UsgPath_eDecodePcm:
                                            case BRAP_P_UsgPath_eDecodeCompress:                                            
                                            case BRAP_P_UsgPath_ePPBranch:                                            
                                            case BRAP_P_UsgPath_eMixPath:                                            
                                            case BRAP_P_UsgPath_eSharedPP:                                                                          
                                                ePathType = BRAP_P_UsgPath_ePPBranch;
                                                break;
                                            case BRAP_P_UsgPath_eDownmixedPath:
                                            case BRAP_P_UsgPath_eDownmixedMixPath:                                            
                                                ePathType = BRAP_P_UsgPath_eDownmixedPath;
                                                break;
                                            default:
                                                ePathType = BRAP_P_UsgPath_ePPBranch;
                                                break;
                                        }
                                        
                                        if(NULL == hRapCh->pPath[uiPth])
                                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                            if(BERR_SUCCESS != ret)
                                            {
                                                ret = BERR_TRACE(ret);
                                                goto end;                            
                                            }
                                        }
                                        BDBG_MSG(("BRAP_P_UsgPath = %d",ePathType));
                                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                                ePathType,
                                                                                BRAP_INVALID_VALUE, 
                                                                                uiPth,
                                                                                BRAP_INVALID_VALUE,0);

                                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                        hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                        hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp; 
                                        hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh; 
                                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                        hRapCh->pPath[uiPth]->uiMasterpathId = m;

                                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][0].hValidDestHandle->sExtDstDetails);
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));  
                                        uiPth++;                                    
                                        
                                    }
                                    else
#endif                                    
                                    {                                        
                                    hRapCh->pPath[m]->pDstDetails[uiDestCount] = &(hRapCh->sChAudProcessingStage[i][uiLastStage].hValidDestHandle->sExtDstDetails);                                
                                        BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[m]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[m]->eUsgPath));                                      
                                    hRapCh->pPath[m]->uiDestcount++;
                                    }
                                    flag =true;
                                    break;
                                }
                            }
                            if(true == flag)
                                break;
                        }
                    }
                }    
            }
            else
            /* End Multi Branch code */ 
#endif
            {
                if( hRapCh->pDstDetails[0] != NULL)
                {
                    uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                    hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[0];
                    BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                                  
                }
                
                uiPth++;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)                         
        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                if(hRapCh->bIndepDelayEnabled == true)
                {
                    for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
                    {
                        if( hRapCh->pDstDetails[m] != NULL)
                        {
                                ret = BRAP_P_GetAssocId(hRapCh,
                                                        (hRapCh->pDstDetails[m]),
                                                        &uiAssocId );    
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;
                                }

                        
                                if(NULL == hRapCh->pPath[uiPth])
                                {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                    if(BERR_SUCCESS != ret)
                                    {
                                        ret =  BERR_TRACE(ret);
                                        goto end;                
                                    }
                                }
                                BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                        BRAP_P_UsgPath_eSharedPP,
                                                                        BRAP_INVALID_VALUE,
                                                                        uiPth,
                                                                        BRAP_INVALID_VALUE,0);
                                hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                            
                            uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;
                            hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
/*                            hRapCh->pPath[uiPth]->uiMasterpathId = 1;*/

                            k=uiPth-1;
                            hRapCh->pPath[k]->bMixPath = true;
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = k;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = hRapCh->pPath[k]->sRsrcGrnt.uiDspId;
                            hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = hRapCh->pPath[k]->sRsrcGrnt.uiDspContextId;
                            hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[k]->hDsp; 
                            hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[k]->hDspCh; 
                            
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth]->eUsgPath));                                                                  
                            uiPth++;                
                        }
                    }
                }
                else
#endif            
                {
                    for(m = 1 ; m < BRAP_P_MAX_DST_PER_RAPCH ; m++)
                    {
                        if( hRapCh->pDstDetails[m] != NULL)
                        {        
                            uiDestCount = hRapCh->pPath[uiPth -1]->uiDestcount++;
                            hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[m];
                            BDBG_MSG(("Adding Output port %d to  Path type = %d", hRapCh->pPath[uiPth -1]->pDstDetails[uiDestCount] ->uDstDetails.sOpDetails.eOutput[0],hRapCh->pPath[uiPth -1]->eUsgPath));                                                  
                        }
                    }
                }
            }

            /* See if any added destination needs Internal Capture Path */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(NULL == hRapCh->pDstDetails[i])
                    continue;
                if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
                {
                    BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                    ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                        hRapCh->pDstDetails[i],
                                                                        pPvtDstDetails,
                                                                        &uiAssocId);
                    if(BERR_SUCCESS!=ret)
                    {
                        ret = BERR_TRACE(ret);
                        goto end;
                    }
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                                
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        hRapCh->pPath[uiPth]->uiAssocId = BRAP_INVALID_VALUE;
                        flag =false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            for(k =0 ; k < hRapCh->pPath[j]->uiDestcount ; k++)
                            {                                
                                if(hRapCh->pPath[j]->pDstDetails[k] ==NULL)
                                    break;
                                else if(hRapCh->pPath[j]->pDstDetails[k]  == hRapCh->pDstDetails[i])
                                {                                    
                                    hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                    /* Set the out path index of previous path */
                                    hRapCh->pPath[j]->sOutPathProp[0].uiPathIdx = uiPth;
                                    flag =true;
                                    break;
                                }
                            }
                            if(flag == true)
                                break;                       
                        }

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                        uiDestCount = hRapCh->pPath[uiPth]->uiDestcount++;                        
                        hRapCh->pPath[uiPth]->pDstDetails[uiDestCount] = hRapCh->pDstDetails[i];
                        
                    }
                    else
                    {
                        flag = false;
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eCapture == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                            {
                                for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
                                {
                                    if(hStartedAssoCh[uiAssocId]->pPath[j]->pDstDetails[k] == 
                                    hRapCh->pDstDetails[i])
                                    {
                                        hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                        uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                    }
                    (*uiNumCapPath)++;
                    uiPth++;
                }
            } /*for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)*/
        }
        (*uiNumCapPath)++;
        
        /*Check for association network*/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];
            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                i=0;
                bCompress = false;
                if(NULL != hRapCh->pDstDetails[i])
                {
                BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));
                /*Find the audio procsssing for the destination of the row on association network*/
                ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                    hRapCh->pDstDetails[i],
                                                                    pPvtDstDetails,
                                                                    &m);
                if(BERR_SUCCESS!=ret)
                {
                    ret = BERR_TRACE(ret);
                    goto end;                
                }
                if(m != uiAssocId)
                {
                    continue;
                }
                /* Check if the Path outputs the compress data  */
                if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                {
                    for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                    {
                        if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                            break;
                        eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                        BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                        if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                        ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                        ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                        ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)
                        ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                        ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                        {
                            bCompress = true;
                        }
                    }
                }
                }

                if(m>0)
                {
                    uiLastStage = m -1;
                }
                else
                {
                    uiLastStage = BRAP_INVALID_VALUE;
                    BDBG_ERR(("Network must have one valid stage"));
                    ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                    goto end;                    
                }
                
                if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)) ||
                (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst))
                {
                    if(NULL == hStartedAssoCh[uiAssocId])
                    {
                        if(NULL == hRapCh->pPath[uiPth])
                        {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                            
                            if(BERR_SUCCESS != ret)
                            {
                                ret = BERR_TRACE(ret);
                                goto end;                            
                            }
                        }
                        BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                BRAP_P_UsgPath_eCapture,
                                                                BRAP_INVALID_VALUE,
                                                                uiPth,
                                                                BRAP_INVALID_VALUE,0);
                        flag = false;
                        for (j =0;j< BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            if(hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
                            {
                                hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx= j;
                                for(n=0; n<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; ++n)
                                {
                                    if(hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx == BRAP_INVALID_VALUE)
                                    {
                                        /* Set the out path index of previous path */
                                        hRapCh->pPath[j]->sOutPathProp[n].uiPathIdx = uiPth;
                                        flag = true;
                                        break;
                                    }
                                }
                            }
                        }
                        hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                        (*uiNumCapPath)++;
                        uiPth++;
                        if(true == bCompress)
                        {
                            /*Now allocate BRAP_P_UsgPath_eDecodeCompressPostMixing because 
                            first row of association network is available*/
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                                
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodeCompressPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth-1]->uiAssocId = uiAssocId;

                        /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                            if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                            {
                                for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                {
                                    hRapCh->pPath[uiPth]->pDstDetails[m] =
                                        &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                }                        
                            }  
                            
                            uiPth++;
                        }
                        else
                        {
                            if(NULL == hRapCh->pPath[uiPth])
                            {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                
                                if(BERR_SUCCESS != ret)
                                {
                                    ret = BERR_TRACE(ret);
                                    goto end;                                       
                                }
                            }
                            BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                    BRAP_P_UsgPath_eDecodePcmPostMixing,
                                                                    BRAP_INVALID_VALUE,
                                                                    uiPth,
                                                                    BRAP_INVALID_VALUE,0);
                            hRapCh->pPath[uiPth]->sInPathProp[0].uiPathIdx = uiPth-1;
                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;
                            hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;

                            /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                            if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                            {
                                for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                {
                                    hRapCh->pPath[uiPth]->pDstDetails[m] =
                                        &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                }                        
                            }  

                            uiPth++;   
                        }                       
                    } /*if(NULL == hStartedAssoCh[uiAssocId])*/
                    else
                    {
                        /* Copy the relevant path from the started channel */
                        for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                        {
                            if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                            (NULL == hRapCh->pPath[uiPth])&&
                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                            (BRAP_P_UsgPath_eDecodePcmPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                            (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                            {
                                hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                {
                                    if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                        break;
                                }
                                hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                
                                BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                uiPth, hRapCh->pPath[uiPth]->eUsgPath));
                                uiPth++;
                                break;
                            }
                        }
                    }
                } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/
                break;
            } /*if((true == hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage[0][0].bCloneStage)||*/
        } /* for(l=0; (l<BRAP_MAX_ASSOCIATED_GROUPS) && (hRapCh->uiAssociationId[l] != BRAP_INVALID_VALUE); ++l)*/
        for(l=0; l<BRAP_MAX_ASSOCIATED_GROUPS; ++l)
        {
            if(hRapCh->uiAssociationId[l] == BRAP_INVALID_VALUE)
                continue;
            
            uiAssocId = hRapCh->uiAssociationId[l];
            /*Check for association network*/
            if(BRAP_P_NETWORK_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage))
            {
                /*Check for other network node on association and if any other branch
                exist than create BRAP_P_UsgPath_ePPBranchPostMixing path for them*/
                for(i=1; i<BRAP_P_MAX_DST_PER_RAPCH; ++i)
                {
                    if((BRAP_P_BRANCH_VALID(hRapCh->hRap->sAssociatedCh[uiAssocId].sAudProcessingStage, i))&&
                        (NULL != hRapCh->pDstDetails[i]))
                    {
                        /*Find the audio procsssing for the destination of the row on 
                        association network*/
                        bCompress = false;              
                        BKNI_Memset((void *)pPvtDstDetails,0, sizeof( BRAP_P_DstDetails ));                    
                        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                                                                            hRapCh->pDstDetails[i],
                                                                            pPvtDstDetails,
                                                                            &m);
                        if(BERR_SUCCESS!=ret)
                        {
                            ret = BERR_TRACE(ret);
                            goto end;
                        }
                        if(m != uiAssocId)
                            continue;
                        /* Check if the Path outputs the compress data  */
                        if(BRAP_P_IsAssociationNWValid(pPvtDstDetails))
                        {
                            for(m =0; m < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; m++)
                            {
                                if(NULL == pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m])
                                    break; 

                                eAudioProcessing = pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[m]->sProcessingStageSettings.eAudioProcessing;

                                BDBG_MSG(("pPvtDstDetails->eAudProcessing[j] = %d",eAudioProcessing));

                                if((BRAP_ProcessingType_eConvertDdpToAc3  == eAudioProcessing)
                                    ||(BRAP_ProcessingType_eWmaProPassThru == eAudioProcessing)                              
                                    ||(BRAP_ProcessingType_eEncodeDts== eAudioProcessing)
                                    ||(BRAP_ProcessingType_eEncodeAc3==eAudioProcessing)
                                    ||(BRAP_ProcessingType_eGenericPassthru==eAudioProcessing)                                    
                                    ||(BRAP_ProcessingType_eEncodeMp3==eAudioProcessing)
                                    ||(BRAP_ProcessingType_ePassthru==eAudioProcessing))
                                {
                                    bCompress = true;
                                }
                            }
                        }
                        if(m>0)
                        {
                            uiLastStage = m -1;
                        }
                        else
                        {
                            uiLastStage = BRAP_INVALID_VALUE;
                            BDBG_ERR(("Network must have one valid stage"));
                            ret = BERR_TRACE(BERR_INVALID_PARAMETER);
                            goto end;                    
                        }
                        if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)) ||
                            (BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst))
                        {
                            if(true == bCompress)
                            {
                                if(NULL == hStartedAssoCh[uiAssocId])
                                {
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif                                        
                                        if(BERR_SUCCESS != ret)
                                        {
                                            ret = BERR_TRACE(ret);
                                            goto end;                                        
                                        }
                                    }
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth],
                                                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                                                            BRAP_INVALID_VALUE,
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    for(m = (uiPth-1); m > 0 ; m--)
                                    {
                                        /* Currently assumed all PCM carrying ports will be connected to same stage 
                                           ToDo: To make this generic like PPBranch path */
                                        if((hRapCh->pPath[m]!=NULL) &&
                                           (hRapCh->pPath[m]->eUsgPath == BRAP_P_UsgPath_eDecodeCompressPostMixing))
                                        {
                                            hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                            break;
                                        }
                                    }

                                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                                    if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                                    {
                                        for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                        {
                                            hRapCh->pPath[uiPth]->pDstDetails[m] =
                                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                        }                        
                                    }                                     
                                    
                                    uiPth++;
                                } /*if(NULL == hStartedAssoCh)*/
                                else
                                {
                                    /* Copy the relevant path from the started channel 
                                    We will search the first BRAP_P_UsgPath_ePPBranchPostMixing 
                                    and once we find it. We will keep on searching the other 
                                    BRAP_P_UsgPath_ePPBranchPostMixing and copy them.*/
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                            (hRapCh->pPath[uiPth] == NULL)&&
                                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                            (BRAP_P_UsgPath_eDecodeCompressPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)&&
                                            (hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                                        {
                                            /*Find one path and copy it in hRapCh */
                                            hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                            uiPth++;                    
                                            break;
                                        }
                                    }
                                } /*else if(NULL == hStartedAssoCh)*/
                            } 
                            else
                            {
                                if(NULL == hStartedAssoCh[uiAssocId])
                                {
                                    if(NULL == hRapCh->pPath[uiPth])
                                    {
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
                                        ret = BRAP_P_MallocPath(hRapCh,uiPth,&(hRapCh->pPath[uiPth]));
#else
                                        ret = BRAP_P_MallocPath(&(hRapCh->pPath[uiPth]));
#endif
                                        if(BERR_SUCCESS != ret)
                                        { 
                                            ret = BERR_TRACE(ret);
                                            goto end;                                        
                                        }
                                    }
                                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], 
                                                                            BRAP_P_UsgPath_ePPBranchPostMixing,
                                                                            BRAP_INVALID_VALUE,
                                                                            uiPth,
                                                                            BRAP_INVALID_VALUE,0);
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspId;
                                    hRapCh->pPath[uiPth]->sRsrcGrnt.uiDspContextId = 
                                    hRapCh->pPath[uiPth-1]->sRsrcGrnt.uiDspContextId;
                                    hRapCh->pPath[uiPth]->hDsp = hRapCh->pPath[uiPth-1]->hDsp;
                                    hRapCh->pPath[uiPth]->hDspCh = hRapCh->pPath[uiPth-1]->hDspCh;
                                    hRapCh->pPath[uiPth]->uiAssocId = uiAssocId;
                                    for(m = (uiPth-1); m > 0 ; m--)
                                    {
                                        /* Currently assumed all PCM carrying ports will be connected to same stage 
                                           ToDo: To make this generic like PPBranch path */
                                        if((hRapCh->pPath[m]!=NULL) &&
                                           (hRapCh->pPath[m]->eUsgPath == BRAP_P_UsgPath_eDecodePcmPostMixing))
                                        {
                                            hRapCh->pPath[uiPth]->uiMasterpathId = m;
                                            break;
                                        }
                                    }
                                    
                                    /*Populating Destination to Path. This was earlier done in DistributeDest() func */
                                    if(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage] != NULL)
                                    {
                                        for(m = 0 ; m < BRAP_P_MAX_DEST_PER_PROCESSING_STAGE ; m++)
                                        {
                                            hRapCh->pPath[uiPth]->pDstDetails[m] =
                                                &(pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->sExternalSettings.hAudProcessing[uiLastStage]->hDestHandle[m]->sExtDstDetails);
                                        }                        
                                    }                            
                                    
                                    uiPth++;
                                } /*if(NULL == hStartedAssoCh)*/
                                else
                                {
                                    /* Copy the relevant path from the started channel 
                                    We will search the first BRAP_P_UsgPath_ePPBranchPostMixing 
                                    and once we find it. We will keep on searching the other 
                                    BRAP_P_UsgPath_ePPBranchPostMixing and copy them.*/
                                    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
                                    {
                                        if((uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN)&&
                                            (NULL == hRapCh->pPath[uiPth])&& 
                                            (NULL != hStartedAssoCh[uiAssocId]->pPath[j])&& 
                                            ((BRAP_P_UsgPath_ePPBranchPostMixing == hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath)
                                            ||(BRAP_P_UsgPath_eDecodePcmPostMixing== hStartedAssoCh[uiAssocId]->pPath[j]->eUsgPath))
                                            &&(hStartedAssoCh[uiAssocId]->pPath[j]->uiAssocId == uiAssocId))
                                        {
                                            /*Find one path and copy it in hRapCh */
                                            hRapCh->pPath[uiPth] = hStartedAssoCh[uiAssocId]->pPath[j];
                                            for(k=0; k<BRAP_P_MAX_IN_PARALLEL_FMM_PATH; k++)
                                            {
                                                if(BRAP_INVALID_VALUE == hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx)
                                                    break;
                                            }
                                            hRapCh->pPath[uiPth]->sInPathProp[k].uiPathIdx = uiPth-1;
                                            hRapCh->pPath[uiPth-1]->sOutPathProp[0].uiPathIdx = uiPth;                                            
                                            BDBG_MSG(("hRapCh->pPath[uiPth =%d]->eUsgPath =%d",
                                            uiPth, hRapCh->pPath[uiPth]->eUsgPath));                                            
                                            uiPth++;                    
                                            break;                            
                                        }
                                    }
                                } /*else if(NULL == hStartedAssoCh)*/
                            }
                        } /*if(((BRAP_AudioDst_eOutputPort == hRapCh->pDstDetails[i]->eAudioDst)&&*/
                    } /*if((true == hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId]*/
                } /* for(i=1; i<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; ++i)*/
            } /* if((true==hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId].sAudProcessingStage[0][0].bCloneStage)*/
        } /*for(l=0; (l<BRAP_MAX_ASSOCIATED_GROUPS) && (hRapCh->uiAssociationId[l] != BRAP_INVALID_VALUE); ++l)*/      
    } /*else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) */
    hRapCh->uiNumCapPath = *uiNumCapPath;
    BDBG_MSG(("*uiNumCapPath > %d", *uiNumCapPath));

    BDBG_MSG(("===================================================="));    
    BDBG_MSG(("Channel Paths formed: "));
    for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
    {
        if(hRapCh->pPath[j] != NULL)
        {
            BDBG_MSG(("hRapCh->pPath[%d]->eUsgPath = %d",j,hRapCh->pPath[j]->eUsgPath));        
            for(k=0; k<BRAP_P_MAX_DST_PER_RAPCH; k++)
            {
                if(hRapCh->pPath[j]->pDstDetails[k]!=NULL)
                {
                    if(hRapCh->pPath[j]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eOutputPort)
                    {
                        BDBG_MSG(("Path = %d, Op = %d", 
                        j, hRapCh->pPath[j]->pDstDetails[k]->uDstDetails.sOpDetails.eOutput[0]));
                    }
                    else if(hRapCh->pPath[j]->pDstDetails[k]->eAudioDst == BRAP_AudioDst_eRingBuffer)
                    {
                        BDBG_MSG(("Path = %d, Capture Port = %d",
                            j,hRapCh->pPath[j]->pDstDetails[k]->uDstDetails.sRBufDetails.eCapPort[0]));
                    }
                    else 
                        BDBG_MSG(("Invalid Destination"));
                }
            }
        }
        else
            break;
    }
    BDBG_MSG(("Number of Paths: %d", j));
    BDBG_MSG(("===================================================="));    
    
end:    
    if(pDspChSettings)
        BKNI_Free(pDspChSettings);

    
    BDBG_LEAVE(BRAP_P_GetChannelPaths);
    return ret;
}

BERR_Code 
BRAP_P_UngetChannelPaths(
	BRAP_ChannelHandle 			hRapCh		    /* [in] RAP Channel handle */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    unsigned int uiPth = 0;
    unsigned int path =0 ;
    unsigned int i=0;
    
    BDBG_ENTER(BRAP_P_UngetChannelPaths);

    if((NULL != hRapCh->pPath[0])
        &&(NULL != hRapCh->pPath[0]->hDspCh))
    {
        /* First Make NULL all the hDspCh Handle stored in the Path which is same as hRapCh->pPath[0]->hDspCh */
        for(uiPth=1; uiPth<BRAP_P_MAX_PATHS_IN_A_CHAN; uiPth++)
        {
            if(NULL == hRapCh->pPath[uiPth])
            {
                continue;
            }
            if(hRapCh->pPath[0]->hDspCh == hRapCh->pPath[uiPth]->hDspCh)
            {
                hRapCh->pPath[uiPth]->hDspCh = NULL;
            }
        }
        /* Now close DSPCHN for Path 0 */        
        BRAP_DSPCHN_P_Close(hRapCh->pPath[0]->hDspCh);
        hRapCh->pPath[0]->hDspCh =NULL;
    }

    for(uiPth=0; uiPth<BRAP_P_MAX_PATHS_IN_A_CHAN; uiPth++)
    {
        if(NULL == hRapCh->pPath[uiPth])
        {
            continue;
        }
        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType
#if((BRAP_7405_FAMILY == 1))
			||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType)
			||(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
#endif
			) &&
           (0 == uiPth) && 
           ((BRAP_P_UsgPath_eDecodePcm == hRapCh->pPath[uiPth]->eUsgPath)||
#if((BRAP_7405_FAMILY == 1))
           (BRAP_P_UsgPath_eCapture== hRapCh->pPath[uiPth]->eUsgPath)||
#endif			
            (BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath)))
        {
            /* Initialize sMixingLevels and pDstDetails with Invalid values */

            for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
            {
                hRapCh->pPath[uiPth]->sMixingLevels[i] = sMixingLevelPropInvalid;
            }
            for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                hRapCh->pPath[uiPth]->pDstDetails[i] = NULL;
            }
            hRapCh->pPath[uiPth]->uiDestcount = 0;            
#if (BRAP_7405_FAMILY == 1)            		
            if(((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
                    continue;
#endif             
        }

        /* Close the PostMixing(loopback) path's hDspCh 
           'uiPth' is eDecodePcmPostMixing/eDecodeCompressPostMixing */   
        if((0 == hRapCh->pPath[uiPth]->uiPthOpenCnt) &&
           (NULL != hRapCh->pPath[uiPth]->hDspCh))
        {     
            /* Make hDspCh=NULL for all the subsequent paths of 'uiPth' 
               which have 'hDspCh' copied from 'uiPth' */
            for(i=uiPth+1; i<BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
            {
                if(NULL == hRapCh->pPath[i])
                {
                    continue;
                }
                if(hRapCh->pPath[uiPth]->hDspCh == hRapCh->pPath[i]->hDspCh)
                {
                    hRapCh->pPath[i]->hDspCh = NULL;
                }
            }
            /* Now close DSPCHN for Path uiPth */          
            BRAP_DSPCHN_P_Close(hRapCh->pPath[uiPth]->hDspCh);
            hRapCh->pPath[uiPth]->hDspCh =NULL;            
        }
        
        if(hRapCh->pPath[uiPth]->uiPthOpenCnt == 0)
        {
            BDBG_MSG(("Freeing path hRapCh->pPath[uiPth=%d]->uiPthOpenCnt = %d",
                uiPth, hRapCh->pPath[uiPth]->uiPthOpenCnt));
            
            if((BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)&&
            (BRAP_P_UsgPath_eDecodeCompress == hRapCh->pPath[uiPth]->eUsgPath))
            {
                BDBG_MSG(("Not freeing DecComp path for PCM PB \n"));
                /* Do not free compressed path in PCM PB channel */
            }
            else
            {
                /* Reset path */
                for (path =0 ; path < BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; path++)
                {
                    BRAP_P_SET_USG_PATH(hRapCh->pPath[uiPth], BRAP_P_UsgPath_eMax,
                    BRAP_INVALID_VALUE, BRAP_INVALID_VALUE, BRAP_INVALID_VALUE,path);
                }
                /* Free path memory */
                BRAP_P_FreePath(&(hRapCh->pPath[uiPth]));   
            }
        }
        hRapCh->pPath[uiPth] = NULL;
    }

    BDBG_LEAVE(BRAP_P_UngetChannelPaths);
    return ret;
}


/***************************************************************************
Summary:
    Private function that initializes SrcChHandleInfo with invalid values.  
**************************************************************************/
void 
BRAP_P_InitSrcChHandleInfo(
    BRAP_P_SrcChHandleInfo  *pSrcChInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pSrcChInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE; 
    sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcChInfo */
    pSrcChInfo->bValid = false;         
    pSrcChInfo->sSrcChInLink = sLinkInfo;
    pSrcChInfo->sSrcChSelfLink = sLinkInfo;
    pSrcChInfo->hSrcCh = NULL;
    pSrcChInfo->sSrcChOutLink = sLinkInfo;

    return;
}

/***************************************************************************
Summary:
    Private function that initializes DstChHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitDstChHandleInfo(
    BRAP_P_DstChHandleInfo  *pDstChInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pDstChInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sDstChInfo */
    pDstChInfo->bValid = false;         
    pDstChInfo->sDstChInLink = sLinkInfo;
    pDstChInfo->sDstChSelfLink= sLinkInfo;
    pDstChInfo->hDstCh = NULL;
    pDstChInfo->sDstChOutLink= sLinkInfo;

    return;
}

/***************************************************************************
Summary:
    Private function that initializes SrcHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitSrcHandleInfo(
    BRAP_P_SrcHandleInfo  *pSrcInfo,
    unsigned int          uiSrcCscdIndex
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pSrcInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcInfo */
    pSrcInfo->bValid = false;
    pSrcInfo->sSrcInLink  = sLinkInfo;
    pSrcInfo->sSrcSelfLink = sLinkInfo;
    pSrcInfo->hSrc[uiSrcCscdIndex] = NULL; 

    for(i = 0; i < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        pSrcInfo->sSrcOutLink[i] = sLinkInfo;
    }

    return;
}

/***************************************************************************
Summary:
    Private function that initializes SrcEqHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitSrcEqHandleInfo(
    BRAP_P_SrcEqHandleInfo  *pSrcEqInfo,
    unsigned int          uiSrcCscdIndex
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pSrcEqInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;

    /* sSrcInfo */
    pSrcEqInfo->bValid = false;
    pSrcEqInfo->sSrcEqInLink  = sLinkInfo;
    pSrcEqInfo->sSrcEqSelfLink = sLinkInfo;
    pSrcEqInfo->hSrcEq[uiSrcCscdIndex] = NULL; 

    for(i = 0; i < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        pSrcEqInfo->sSrcEqOutLink[i] = sLinkInfo;
    }

    return;
}

/***************************************************************************
Summary:
    Private function that initializes MixerHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitMixerHandleInfo(
    BRAP_P_MixerHandleInfo  *pMixerInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
    int i = 0;

    BDBG_ASSERT(pMixerInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sMixerInfo */
    pMixerInfo->bValid = false; 
    for(i = 0; i < BRAP_RM_P_MAX_MIXER_INPUTS; i++)
    {
        pMixerInfo->sMixerInLink[i] = sLinkInfo;
    }
    pMixerInfo->sMixerSelfLink = sLinkInfo;
    pMixerInfo->hMixer = NULL;
    for(i = 0; i < BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
    {
        pMixerInfo->sMixerOutLink[i] = sLinkInfo;
    }
    
    return;
}


/***************************************************************************
Summary:
    Private function that initializes OutputHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitOpHandleInfo(
    BRAP_P_OpHandleInfo  *pOpInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;
 
    BDBG_ASSERT(pOpInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;	

    /* sOpInfo */
    pOpInfo->bValid = false;
    pOpInfo->sOpInLink = sLinkInfo; 
    pOpInfo->sOpSelfLink = sLinkInfo;
    pOpInfo->hSpdifFm = NULL;
    pOpInfo->hOp = NULL;
    pOpInfo->hMaiOp = NULL;
    

    return;
}
  
/***************************************************************************
Summary:
    Private function that initializes CapPortHandleInfo with invalid values.  
**************************************************************************/
static void  
BRAP_P_InitCapPortHandleInfo(
    BRAP_P_CapPortHandleInfo  *pCapPortInfo
    )
{
    BRAP_P_LinkInfo         sLinkInfo;

    BDBG_ASSERT(pCapPortInfo);
    
    /* sLinkInfo */
    sLinkInfo.eRsrcType = BRAP_P_Rsrc_eMax;
    sLinkInfo.uiLevel = BRAP_INVALID_VALUE;
    sLinkInfo.eChnPair = BRAP_OutputChannelPair_eMax;
    sLinkInfo.uiPrlPth = BRAP_INVALID_VALUE;   
	sLinkInfo.uiMixerOutput = BRAP_INVALID_VALUE;		

    /* sCapInfo */
    pCapPortInfo->bValid = false;
    pCapPortInfo->sCapPortInLink = sLinkInfo;
    pCapPortInfo->sCapPortSelfLink = sLinkInfo;
    pCapPortInfo->hCapPort = NULL;
    pCapPortInfo->sCapPortoutLink = sLinkInfo;
    
    return;
}
 
/***************************************************************************
Summary:
    Private function that initializes Raptor channel handle with invalid 
    values.  
**************************************************************************/
BERR_Code 
BRAP_P_InitRapChannelHandle(
    BRAP_ChannelHandle  hRapCh,  /* [in] Rap channel handle to be inited to 
                                   invalid values */
BRAP_Handle 			    hRap		    /* [in] The Raptor Audio handle*/
                                   
    )
{
    int i = 0, j = 0, k = 0, l = 0;
    BRAP_P_SrcChHandleInfo  sSrcChInfo;
    BRAP_P_DstChHandleInfo  sDstChInfo;
	BRAP_P_SrcHandleInfo    sSrcInfo;
    BRAP_P_MixerHandleInfo  sMixerInfo;
    BRAP_P_SrcEqHandleInfo  sSrcEqInfo;
    BRAP_P_OpHandleInfo     sOpInfo;
    BRAP_P_CapPortHandleInfo sCapInfo;
    BRAP_P_AppIntCbInfo     sAppCbInfo;
    BRAP_RM_P_ResrcGrant    *psRsrcGrnt;
    BRAP_P_ChannelAudioProcessingStage sTempStage;
    BERR_Code ret = BERR_SUCCESS;
	
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)	
    BRAP_P_RBufMem          sRbufMem;
#endif

    BDBG_ENTER(BRAP_P_InitRapChannelHandle);

	psRsrcGrnt = hRap->sOpenTimeMallocs.psResrcGrant;
	if( NULL==psRsrcGrnt )
	{
		return BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
	}
        BKNI_Memset(psRsrcGrnt, 0, sizeof(BRAP_RM_P_ResrcGrant));             
    /* RM Grant */
    BRAP_RM_P_InitResourceGrant(psRsrcGrnt,true);
    
    /* sSrcChInfo */
    BRAP_P_InitSrcChHandleInfo(&sSrcChInfo);    

    /* sDstChInfo */
    BRAP_P_InitDstChHandleInfo(&sDstChInfo);    

    /* sSrcInfo */
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcHandleInfo(&sSrcInfo, i);    
    }

    /* sMixerInfo */
    BRAP_P_InitMixerHandleInfo(&sMixerInfo);

    /* sSrcEqInfo */
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcEqHandleInfo(&sSrcEqInfo, i);    
    }

    /* sOpInfo */
    BRAP_P_InitOpHandleInfo(&sOpInfo);
    
    /* sCapInfo */
    BRAP_P_InitCapPortHandleInfo(&sCapInfo);

    /* sAppCbInfo */
    sAppCbInfo.iParm2 = BRAP_INVALID_VALUE;
    sAppCbInfo.pParm1 = NULL;
    sAppCbInfo.pfAppCb = NULL;

    /* Channel handle */    
    hRapCh->hChip = NULL;
    hRapCh->hRegister = NULL;
    hRapCh->hHeap = NULL;
    hRapCh->hInt = NULL; 
    hRapCh->hRap = NULL;		
    hRapCh->uiXptChannelNo = BRAP_INVALID_VALUE;
    hRapCh->eChannelType = BRAP_ChannelType_eMax;
    hRapCh->uiChannelNo = BRAP_INVALID_VALUE; 
    hRapCh->eChannelSubType = BRAP_ChannelSubType_eMax;
    hRapCh->eAudioSource = BRAP_AudioSource_eMax;
    hRapCh->eSamplingRate = BAVC_AudioSamplingRate_eUnknown;    
    hRapCh->bGateOpened= false;
    hRapCh->uiModeValue = BRAP_INVALID_VALUE;
    
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        hRapCh->pPath[i] = NULL;
    }

#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
    	/* Allocate an Path handle memory during open time */
    	hRapCh->pMemPath[i] = (BRAP_P_ObjectHandles *)BKNI_Malloc(sizeof(BRAP_P_ObjectHandles));
    	if(NULL == hRapCh->pMemPath[i])
    	{
    		BDBG_ERR(("pPath open channel Memory allocation failed"));
    		ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
    	}
        BKNI_Memset(hRapCh->pMemPath[i],0,sizeof(BRAP_P_ObjectHandles));    
    }   
#endif	

    hRapCh->bSimulModeConfig = false; 
    hRapCh->hDSPCallback = NULL;
    hRapCh->hFMMCallback = NULL;
    for(i = 0; i < BRAP_Interrupt_eMaxInterrupts; i++)
    {
        hRapCh->sAppIntCbInfo[i] = sAppCbInfo; 
    }
    hRapCh->ui32FmmIntMask = 0;
    hRapCh->ui32FmmBFIntMask = 0;
    hRapCh->ui32DspIntMask = 0; 
    hRapCh->ui32AsynIntMask = 0;
    hRapCh->sTrickModeState.uiFrameAdvResidualTime = 0;	
    hRapCh->sTrickModeState.bAudioPaused = false;
    
    hRapCh->eState = BRAP_P_State_eInvalid;
    hRapCh->bStopinvoked = false;
    

    for(i = 0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
    {
        hRapCh->uiAssociationId[i] = BRAP_INVALID_VALUE;
    }

    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        hRapCh->pDstDetails[i] = NULL;
    }
    
    hRapCh->uiInputSamplingRate = BRAP_INVALID_VALUE; 
    hRapCh->eInputAudMode = BRAP_OutputMode_eLast;
    hRapCh->bInputLfeOn = false;

    for(i=0;i<BRAP_OutputChannelPair_eMax;i++)
    {
        hRapCh->sGainInfo.ui32LeftGain[i] = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
        hRapCh->sGainInfo.ui32RightGain[i]= BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
    }

    for(i=0;i<BRAP_RM_P_MAX_INTERNAL_DST;i++)
    {
        hRapCh->sIntDst[i] = sInternalDst;
    }


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
    /* sChanRBufPool */
    sRbufMem.bUsed = false;
    sRbufMem.pRBufPtr = NULL;
    sRbufMem.uiSize = 0;

    for(i = 0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRbufMem;
        }/* for j */
    }/* for i */

    for(i = 0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRbufMem;
        }/* for j */
    }/* for i */

    for(i = 0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRbufMem;
    }/* for i */

#endif
    sTempStage.bCloneStage = false;
    sTempStage.bDecoderStage = false;
    sTempStage.bInternalProcessingStage = false;    
    sTempStage.hAudioProcessing = NULL;
    sTempStage.hValidDestHandle = NULL;
    for(i=0;i<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;i++)    
    {
        sTempStage.hDestHandle[i] = NULL;
    }
    sTempStage.ui32MasterBranchId = BRAP_INVALID_VALUE;
    sTempStage.ui32MasterStageId = BRAP_INVALID_VALUE;
    sTempStage.ui32CitBranchId = BRAP_INVALID_VALUE;
    sTempStage.ui32CitStageId = BRAP_INVALID_VALUE;

    for (i=0;i<BRAP_P_MAX_DST_PER_RAPCH;i++)
    {
        for(j=0;j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED;j++)
        {
            hRapCh->sChAudProcessingStage[i][j] = sTempStage;
        }
    }
    for(l=0;l<BRAP_RM_P_MAX_MIXER_PER_DP_BLCK * BRAP_RM_P_MAX_DP_BLCK;l++)
    {
        for(k=0;k<BRAP_P_MAX_DST_PER_RAPCH;k++)
        {
            hRapCh->sScalingInfo.eOp[l][k] = BRAP_OutputPort_eMax;
            for(i=0;i<BRAP_OutputChannelPair_eMax;i++)
            {
                hRapCh->sScalingInfo.sScalingInfo[l][k].ui32LeftGain[i] = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                hRapCh->sScalingInfo.sScalingInfo[l][k].ui32RightGain[i]= BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
            }
        }
    }

    hRapCh->uiPBRate = BRAP_DSPCHN_PLAYBACKRATE_NORMAL;
    hRapCh->eChannelOutputMode = BRAP_OutputMode_e2_0;
	
    hRapCh->hMultiStreamDecoder = NULL;
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
    hRapCh->uiFWMixerIpIndex = BRAP_INVALID_VALUE;
#endif

    BDBG_LEAVE(BRAP_P_InitRapChannelHandle);
    return ret;
}

/*****************************************************************************
Summary:
    Private function that initializes Destination Details with invalid values.  
******************************************************************************/
void 
BRAP_P_InitDestination(
    BRAP_P_DstDetails  *psDstDetails  /* [in] Raptor Destination to be inited to 
                                        invalid values */
    )
{
    unsigned int j=0, k=0;
    BRAP_P_AppIntCbInfo     sAppCbInfo;    

    BDBG_ENTER(BRAP_P_InitDestination);
    BDBG_ASSERT(psDstDetails);

    /* sAppCbInfo */
    sAppCbInfo.iParm2 = BRAP_INVALID_VALUE;
    sAppCbInfo.pParm1 = NULL;
    sAppCbInfo.pfAppCb = NULL;

    psDstDetails->sExtDstDetails.eAudioDst = BRAP_AudioDst_eMax;
    psDstDetails->hAssociation = NULL;
    psDstDetails->ui32FmmIntMask = 0;
    psDstDetails->hFmmBf1Callback = NULL;
    psDstDetails->hFmmBf2Callback = NULL;        
    psDstDetails->hParentDestHandle = NULL;
    psDstDetails->uiForkingStage = BRAP_INVALID_VALUE;
    psDstDetails->eAudioProcessing = BRAP_ProcessingType_eMax;
    for(j=0; j<BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
    {
        psDstDetails->eAudProcessing[j] = BRAP_ProcessingType_eMax;
    }
    for(j=0; j<(BRAP_P_MAX_RAPCH_PER_DST+ 1); j++)
    {
        psDstDetails->psProcessingSettings[j] = NULL;
    }        
    for(j=0; j < BRAP_DestinationInterrupt_eMax; j++)
    {
        psDstDetails->sAppIntCbInfo[j] = sAppCbInfo; 
    }        
    for(j=0; j<BRAP_OutputChannelPair_eMax; j++)
    {
        for(k=0; k<BRAP_P_MAX_MIXERS_CONTROLS_IN_DATA_PATH; k++)
        {
            psDstDetails->uiLtVolume[j][k] = 0x800000; 
            psDstDetails->uiRtVolume[j][k] = 0x800000;
            psDstDetails->uiLtBalance[j][k] = 0x800000; 
            psDstDetails->uiRtBalance[j][k] = 0x800000;
            psDstDetails->bMute[j] = false;
        }
    }
    psDstDetails->hEqualizer = NULL; 
    BDBG_LEAVE(BRAP_P_InitDestination);        
}

BERR_Code BRAP_P_GetAudOpModeProp(
    BRAP_OutputMode     eOpMode,        /* [in] Output mode */
    bool                bLfeOn,         /* [in] if LFE is on/off */
    BRAP_P_OpAudModProp *pOpModeProp    /* [out] OpMode property structure
                                           passed by reference */    
    )
{
    BERR_Code ret = BERR_SUCCESS;
    
    BDBG_ENTER(BRAP_P_GetAudOpModeProp);
    BDBG_ASSERT(pOpModeProp);

    BDBG_MSG(("BRAP_P_GetAudOpModeProp: eOpMode = %d, bLfeOn = %d",
        eOpMode, bLfeOn));

    if(eOpMode > BRAP_OutputMode_e3_4)    
    {
        BDBG_ERR(("BRAP_P_GetAudOpModeProp: eOpMode %d not supported", eOpMode));
        /* Check if this eOpMode is valid. If valid, check if 
           sOutputAudModeProp[] has supported details and re-adjust the if
           condition above */
        return BERR_TRACE(BERR_NOT_SUPPORTED);           
    }
    
    *pOpModeProp = sOutputAudModeProp[eOpMode];
    if(true == bLfeOn)
    {
        pOpModeProp->bChnExists[BRAP_P_LFE_CHAN_INDEX] = true;
        pOpModeProp->ui8ChanBits |= 0x1 << 2; /* 2 = 8 - lfe(5) - 1 */
        pOpModeProp->uiNoChannels++;
    }    

    BDBG_LEAVE(BRAP_P_GetAudOpModeProp);
    return ret;
}

/***************************************************************************
Summary: 
    This function gives the absolute value corresponding to the enum 
    BAVC_AudioSamplingRate 
**************************************************************************/ 
BERR_Code BRAP_P_ConvertSR (
    BAVC_AudioSamplingRate   eSR,   /* [in] samping rate enum */
    unsigned int            *uiSR   /* [out] sampling rate unsigned value */
)
{
    BERR_Code err = BERR_SUCCESS;
    BDBG_ASSERT(uiSR);

    switch(eSR)
    {
    	case BAVC_AudioSamplingRate_e32k:   *uiSR = 32000; break;
        case BAVC_AudioSamplingRate_e44_1k: *uiSR = 44100; break;
        case BAVC_AudioSamplingRate_e48k:   *uiSR = 48000; break;
        case BAVC_AudioSamplingRate_e96k:   *uiSR = 96000; break;
        case BAVC_AudioSamplingRate_e16k:   *uiSR = 16000; break;
        case BAVC_AudioSamplingRate_e22_05k:*uiSR = 22050; break;
        case BAVC_AudioSamplingRate_e24k:   *uiSR = 24000; break;
        case BAVC_AudioSamplingRate_e64k:   *uiSR = 64000; break;
        case BAVC_AudioSamplingRate_e88_2k: *uiSR = 88200; break;
        case BAVC_AudioSamplingRate_e128k:  *uiSR = 128000; break;
        case BAVC_AudioSamplingRate_e176_4k:*uiSR = 176400; break;
        case BAVC_AudioSamplingRate_e192k:  *uiSR = 192000; break;
        case BAVC_AudioSamplingRate_e8k:    *uiSR = 8000; break;
        case BAVC_AudioSamplingRate_e12k:   *uiSR = 12000; break;
        case BAVC_AudioSamplingRate_e11_025k:  *uiSR = 11025; break;
        case BAVC_AudioSamplingRate_eUnknown: 
        default:
            BDBG_MSG(("BRAP_P_ConvertSR: Not supported eSR = %d, Forcing it to 48000", eSR));
            *uiSR = 48000;break;
    }
    return err;        
}

/***************************************************************************
Summary: 
    This function gives the enum corresponding to the absolute value of 
    BAVC_AudioSamplingRate 
**************************************************************************/    
BERR_Code BRAP_P_ConvertSrToEnum (
    unsigned int            uiSR,   /* [in] sampling rate unsigned value */
    BAVC_AudioSamplingRate  *eSR    /* [out] samping rate enum */
)
{
    BERR_Code err = BERR_SUCCESS;
    BDBG_ASSERT(eSR);

    switch(uiSR)
    {
    	case 32000:     *eSR = BAVC_AudioSamplingRate_e32k;     break;
        case 44100:     *eSR = BAVC_AudioSamplingRate_e44_1k;   break;
        case 48000:     *eSR = BAVC_AudioSamplingRate_e48k;     break;
        case 96000:     *eSR = BAVC_AudioSamplingRate_e96k;     break;
        case 16000:     *eSR = BAVC_AudioSamplingRate_e16k;     break;
        case 22050:     *eSR = BAVC_AudioSamplingRate_e22_05k;  break;
        case 24000:     *eSR = BAVC_AudioSamplingRate_e24k;     break;
        case 64000:     *eSR = BAVC_AudioSamplingRate_e64k;     break;
        case 88200:     *eSR = BAVC_AudioSamplingRate_e88_2k;   break;
        case 128000:    *eSR = BAVC_AudioSamplingRate_e128k;    break;
        case 176400:    *eSR = BAVC_AudioSamplingRate_e176_4k;  break;
        case 192000:    *eSR = BAVC_AudioSamplingRate_e192k;    break;
        case 8000:      *eSR = BAVC_AudioSamplingRate_e8k;      break;
        case 12000:     *eSR = BAVC_AudioSamplingRate_e12k;     break;
        case 11025:     *eSR = BAVC_AudioSamplingRate_e11_025k; break;
        default:
            BDBG_ERR(("BRAP_P_ConvertSrToEnum: Not supported uiSR = %d, Forcing it to BAVC_AudioSamplingRate_e48k", uiSR));
               *eSR = BAVC_AudioSamplingRate_e48k; break;
    }
    return err;        
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_GetMixerForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    BRAP_MIXER_P_Handle *phMixer,   /*[out] Mixer Handle */
    unsigned int        *puiMixerOp
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;

    BDBG_ENTER(BRAP_P_GetMixerForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);
    BDBG_ASSERT(puiMixerOp);


    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
	    *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;

	    *puiMixerOp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

	}
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
	    *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;

	    *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

	}
#endif    
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
    
	
    BDBG_LEAVE(BRAP_P_GetMixerForOpPort);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to an output port and which mixer of the 
    cascaded mixers is defined by the mixer level, an input parameter.
    
**************************************************************************/
BERR_Code
BRAP_P_GetCustomMixerForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    const unsigned int  uiMixerLevel,    
    BRAP_MIXER_P_Handle *phMixer,   /*[out] Mixer Handle */
    unsigned int        *puiMixerOp
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;

    BDBG_ENTER(BRAP_P_GetCustomMixerForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);
    BDBG_ASSERT(puiMixerOp);


    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
        if (NULL != hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer)
            *phMixer = hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer;    

	    *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
	}
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
#else
    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

	    /* Get the Handle for the Mixer feeding to the Output port */
        if (NULL != hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer)
            *phMixer = hRapCh->pPath[j]->sMixer[lvl-uiMixerLevel][eChPair][pp].hMixer;    

	    *puiMixerOp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

	}
	else if(BRAP_P_Rsrc_eSrcCh == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
		*phMixer = NULL;
		ret = BERR_SUCCESS;
	}
	else
		ret=BERR_INVALID_PARAMETER;
#endif    
	
    BDBG_LEAVE(BRAP_P_GetCustomMixerForOpPort);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a ring buffer
    
**************************************************************************/
#if ((BRAP_3548_FAMILY == 1) || (BRAP_7405_FAMILY == 1))
BERR_Code BRAP_P_GetMixerForRBuf(
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    unsigned int     	uiRBufId,   /*[in] Ring Buffer Id */
    BRAP_MIXER_P_Handle *phMixer,    /*[out] Mixer Handle */
    unsigned int        *puiMixerOp    
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            lvl =0, pp = 0;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
#endif
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;	

    BDBG_ENTER(BRAP_P_GetMixerForRBuf);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phMixer);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if((hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm) ||
               (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_ePPBranch))
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}
    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        *puiMixerOp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: Mixer Handle = %d", *phMixer));
	}
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        
        *puiMixerOp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            *phMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
		BDBG_MSG(("BRAP_P_GetMixerForRBuf: Mixer Handle = %d", *phMixer));
	}
#endif
	else
		ret=BERR_INVALID_PARAMETER;


    BDBG_LEAVE(BRAP_P_GetMixerForRBuf);
    return ret;
}

#endif

BERR_Code BRAP_P_MixingAssociation( 
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    unsigned int uiAssocId,
    bool            *bMixing     /*TRUE = If mixing is happening in Association */)
{
    BERR_Code   ret =BERR_SUCCESS;
    unsigned int    uiNoRapChannel = 0;
    unsigned int i;
    BDBG_ENTER(BRAP_P_MixingAssociation);
    BDBG_ASSERT(hRapCh);
    for(i=0 ; i < BRAP_MAX_PRI_DEC_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPriDecCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_SEC_DEC_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hSecDecCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_PB_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hPBCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }

    for(i=0 ; i < BRAP_MAX_CAP_CHAN_IN_ASSOCIATED_GRP ; i++)
    {
        if(hRapCh->hRap->sAssociatedCh[uiAssocId].hCapCh[i] != NULL)
        {
            uiNoRapChannel++;
        }
    }
    if(uiNoRapChannel > 1)
    {
        *bMixing = true;
    }
    else
    {
        *bMixing = false;
    }
    BDBG_LEAVE(BRAP_P_MixingAssociation);
    return ret;
}

/***************************************************************************
Summary:
    Private function that programs the scaling and panning coefficients for 
    a mixer    
**************************************************************************/
BERR_Code BRAP_P_ProgramCoefficients(
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    const BRAP_MixingCoef	    *pMixingCoeff   /* [in] Mixing Coeff passed 
	                                               during channel start time */
)
{
    BERR_Code                       ret=BERR_SUCCESS;
    int                             chPair = 0,path=0, i=0,j=0,k=0,l =0;
    unsigned int                    uiLvl = 0, uiPp = 0;
    unsigned int                    uiLvl1 = 0, uiPp1 = 0;
    BRAP_OutputChannelPair          eChP = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair          eChP1 = BRAP_OutputChannelPair_eMax;
    BRAP_P_MixerCoefficientsInfo    sMixingInfo;
    bool                            bProgrammingDone = false, bMixingInHW = true;
    BRAP_RM_P_MixerGrant            sTempMixerGrnt;
    BRAP_RM_P_ResrcGrant            *psTempGrant;
    unsigned int                    m=0 , n=0;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    BRAP_GainControl    sGain;    
     bool bCompress  = false;
    BDBG_ENTER(BRAP_P_ProgramCoefficients);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pMixingCoeff);

    /*Algo:
        1. Prepare the gain coefficents for all the channl pairs.
        2. for(chPair=0; all the channel pairs)
        {
            Trace the mixer for applying these coefficents
            if (hRapCh->pPath[0].sSrcCh[chPair]!=Invalid)
           
                go to the next level. Access the Resource connected to the 
                SrcCh's outlink info and find if mixer is connected.
                keep repeating untill get the first mixer.
                Note: One SRC can feed to multiple mixer inputs. For all calculate 
                      the new coeff and apply accordingly.

            for(spth = 0 to end)
                get the first mixers for each channel pairs
            
                Prepare -
                struct[per chp]
                {
                    hMixer[each SRC can feed to 4 mixers]
                    coeff0
                    coeff1
                }

                Pass this to MIXER API.
        }
    */

#ifdef RAP_MULTISTREAM_DECODER_SUPPORT  
    if(BRAP_P_IsFwMixingPostLoopbackEnabled(hRapCh))
    {
        bMixingInHW = false;
    }
#endif
    if(bMixingInHW == true)
    {
    	psTempGrant = hRapCh->hRap->sOpenTimeMallocs.psResrcGrant;
    	if( NULL==psTempGrant )
    	{
    		ret = BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
                    goto error;        
    	}
            BKNI_Memset(psTempGrant, 0, sizeof(BRAP_RM_P_ResrcGrant));             	
        /* TODO: For compressed channel, return error */
        
        for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
        {
            sMixingInfo.hMixer[i] = NULL;
            for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
            {
                sMixingInfo.uiMixerIp[i][j] = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff0[i][j].ui32Left  = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff0[i][j].ui32Right = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff1[i][j].ui32Left  = BRAP_INVALID_VALUE;
                sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_INVALID_VALUE;
            }
        }
        
        /* Trace all the paths to find first mixer where these coefficents can be 
           applied */
        for (path=0;path<BRAP_P_MAX_PATHS_IN_A_CHAN;path++)
        {
            if((NULL == hRapCh->pPath[path]))/* || (BRAP_P_UsgPath_eDecodePcm != hRapCh->pPath[path]->eUsgPath))*/
            {
                continue;
            }
            if(hRapCh->pPath[path]->uiAssocId == BRAP_INVALID_VALUE)
            {
                continue;
            }
            bCompress  = false;        
            BRAP_P_IsPathOutputCompress(hRapCh,path,&bCompress);
            for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
            {
                /* Reset the sMixingInfo */
                for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                {
                    sMixingInfo.hMixer[i] = NULL;
                    for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
                    {
                        sMixingInfo.uiMixerIp[i][j] = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff0[i][j].ui32Left  = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff0[i][j].ui32Right = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff1[i][j].ui32Left  = BRAP_INVALID_VALUE;
                        sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_INVALID_VALUE;
                    }
                }
                
                /* If channel pair present */
                if (true == hRapCh->pPath[path]->sSrcCh[chPair].bValid)
                {
                    BDBG_MSG(("BRAP_P_ProgramCoefficients: Path_id = %d",path));
                    /* Go to the SRC next to the srcch */
                    uiLvl =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiLevel;
                    uiPp =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiPrlPth;
                    eChP =hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eChnPair;


                    BDBG_MSG(("BRAP_P_ProgramCoefficients: Src Lvl = %d"
                              "Prll_Path = %d, Chan_Pair = %d ",
                              uiLvl,uiPp,eChP));
                    
                    /* for every Mixer connected to a SRC in Parallel */
                    for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                    {
#if (BRAP_7550_FAMILY != 1)
                        BDBG_MSG(("sSrcOutLink[%d].eRsrcType =%d",i,hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].sSrcOutLink[i].eRsrcType));
                        /* If valid resource and its a mixer */
                        if(BRAP_P_Rsrc_eMixer == 
                            hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                          sSrcOutLink[i].eRsrcType)
                        {
                            /* Get the level, pp and channel pair for the mixer */
                            uiLvl1 = 
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].uiLevel;
                            uiPp1 = 
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].uiPrlPth;
                            eChP1 =
                                hRapCh->pPath[path]->sSrc[uiLvl][eChP][uiPp].
                                                            sSrcOutLink[i].eChnPair;
#else                        
                        BDBG_MSG(("sSrcChOutLink.eRsrcType =%d",hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eRsrcType));
                        /* If valid resource and its a mixer */
                        if(BRAP_P_Rsrc_eMixer == 
                            hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eRsrcType)
                        {
                            /* Get the level, pp and channel pair for the mixer */
                            uiLvl1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiLevel;
                            uiPp1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.uiPrlPth;
                            eChP1 = hRapCh->pPath[path]->sSrcCh[chPair].sSrcChOutLink.eChnPair;
#endif                           
                            BDBG_MSG(("BRAP_P_ProgramCoefficients: Mixer Lvl = %d"
                                      "Prll_Path = %d, Chan_Pair = %d ",
                                      uiLvl1,uiPp1,eChP1));
                            
                            /* Store the handle */
                            sMixingInfo.hMixer[i] = 
                            hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].hMixer;                           

                            /* Find the Mixer Input for this channel pair */
                            *psTempGrant = hRapCh->pPath[path]->sRsrcGrnt;

                            sTempMixerGrnt = 
                                psTempGrant->sSrcMixerGrnt[uiLvl1].sMixerGrant
                                                                     [eChP1][uiPp1];

                            sMixingInfo.uiMixerIp[i][chPair] = 
                                              sTempMixerGrnt.uiMixerInputId[chPair];
                            switch(eChP1)
                            {
                                case BRAP_OutputChannelPair_eLR:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=0; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=0; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=0; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=0; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eLRSurround:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=2; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=2; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=2; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=2; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eCentreLF:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=4; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=4; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=4; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=4; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eLRRear:
                                    switch(chPair)
                                    {
                                        case BRAP_OutputChannelPair_eLR:
                                            m=6; n=0;
                                            break;
                                        case BRAP_OutputChannelPair_eLRSurround:
                                            m=6; n=2;
                                            break;
                                        case BRAP_OutputChannelPair_eCentreLF:
                                            m=6; n=4;
                                            break;
                                        case BRAP_OutputChannelPair_eLRRear:
                                            m=6; n=6;
                                            break;
                                        case BRAP_OutputChannelPair_eMax:
                                        default:
                                            BDBG_ASSERT(0);
                                    }
                                    break;
                                case BRAP_OutputChannelPair_eMax:
                                default:
                                    BDBG_ASSERT(0);
                            }
                            sMixingInfo.sCoeff0[i][chPair].ui32Left  = pMixingCoeff->ui32Coef[m][n];
                            sMixingInfo.sCoeff0[i][chPair].ui32Right = pMixingCoeff->ui32Coef[m][(n+1)];
                            sMixingInfo.sCoeff1[i][chPair].ui32Left  = pMixingCoeff->ui32Coef[(m+1)][n];
                            sMixingInfo.sCoeff1[i][chPair].ui32Right = pMixingCoeff->ui32Coef[(m+1)][(n+1)];

                            BDBG_MSG(("InputChp=%d, OutputChp=%d, m=%d,n=%d",chPair,eChP1,m,n));
                            BDBG_MSG(("LeftCoeff0=0x%x, RightCoeff0=0x%x, LeftCoeff1=0x%x,RightCoeff1=0x%x",
                                      pMixingCoeff->ui32Coef[m][n],pMixingCoeff->ui32Coef[m][n+1],
                                      pMixingCoeff->ui32Coef[m+1][n],pMixingCoeff->ui32Coef[m+1][n+1]));
                            
                    
                            hMixer = sMixingInfo.hMixer[i];
                            if(hMixer != NULL)
                            {
                                if((false == hMixer->bCompress))
                                {
                                    for(l =0 ; l < BRAP_RM_P_MAX_MIXER_OUTPUTS; l++)
                                    {
                                        if(hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].eRsrcType == BRAP_P_Rsrc_eOpPort)
                                        {
                                            uiLvl = hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].uiLevel;
                                            eChP= hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].eChnPair;
                                            uiPp = hRapCh->pPath[path]->sMixer[uiLvl1][eChP1][uiPp1].sMixerOutLink[l].uiPrlPth;                

                                            if(hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.eRsrcType == BRAP_P_Rsrc_eMixer)
                                            {
                                                if((hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.uiLevel== uiLvl1)
                                                &&(hRapCh->pPath[path]->sOp[eChP][uiPp].sOpInLink.eChnPair == eChP1))
                                                {
                                                    BDBG_MSG(("Setting scaling coeffiecients for O/P %d",hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort));

                                                    /* Find free location to keep coeff */
                                                    for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                                                    {
                                                        if((hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j]== BRAP_OutputPort_eMax)||
                                                        (hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j]== hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort))
                                                            break;
                                                    }
                                                    if(BRAP_P_MAX_DST_PER_RAPCH == j)
                                                    {
                                                        BDBG_ERR(("No space to keep Gain coeff!!"));
                                                            ret =  BERR_INVALID_PARAMETER;
                                                            goto error;
                                                    }

                                                    for(k =0 ; k< BRAP_OutputChannelPair_eMax;k++)
                                                    {
                                                        sGain.ui32LeftGain[k] = sMixingInfo.sCoeff0[i][k].ui32Left;
                                                        sGain.ui32RightGain[k] = sMixingInfo.sCoeff1[i][k].ui32Right;                                    
                                                    }                                
                                                    hRapCh->sScalingInfo.sScalingInfo[hMixer->uiDpIndex*hMixer->uiMixerIndex][j] = sGain;
                                                    hRapCh->sScalingInfo.eOp[hMixer->uiDpIndex*hMixer->uiMixerIndex][j] = hRapCh->pPath[path]->sOp[eChP][uiPp].hOp->eOutputPort;                                

                                                }
                                            }
                                        }   
                                    }
                                }
                            }                     
#if (BRAP_7550_FAMILY != 1)                        
                        }
#else
                        }
#endif
                    }
                    if(bCompress == true)
                    {
                        for(i=0;i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC;i++)
                        {
                            for (j=0;j<BRAP_OutputChannelPair_eMax;j++)
                            {
                                if((sMixingInfo.sCoeff0[i][j].ui32Left != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff0[i][j].ui32Left = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                                }
                                if((sMixingInfo.sCoeff0[i][j].ui32Right != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff0[i][j].ui32Right = 0;
                                }                        
                                if((sMixingInfo.sCoeff1[i][j].ui32Left != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff1[i][j].ui32Left = 0;
                                }                        
                                if((sMixingInfo.sCoeff1[i][j].ui32Right != BRAP_INVALID_VALUE))
                                {
                                    sMixingInfo.sCoeff1[i][j].ui32Right = BRAP_MIXER_P_DEFAULT_SCALING_COEFF;
                                }                            
                            }
                        }
                    }
                }            


                /* Call the Mixer API to program the coeffients for this 
                   channel pair */
                ret = BRAP_MIXER_P_ProgramPingPongCoeff(&sMixingInfo,
                                                        &bProgrammingDone);
                if(BERR_SUCCESS != ret)
                {
                    BDBG_ERR(("BRAP_P_ProgramCoefficients: Returned Error"));
                    ret = BERR_TRACE(ret);
            	goto error;
                }
            }
        }/* for eChPair */
    }
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT      
    else /* Configure FW Mixer PP */
    {
        if(!(BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap)))
        {
                if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder))
            &&(hRapCh->eState == BRAP_P_State_eStarted))
            {
                for(j =0 ; j < BRAP_MAX_PP_SUPPORTED; j++)
                {                
                    if(hRapCh->hRap->hAudioProcessingStageHandle[j]->sProcessingStageSettings.eAudioProcessing == BRAP_ProcessingType_eFwMixer)
                    {     
                        BRAP_ProcessingStageSettings * psProcessingStageSettings =NULL;                    
                        psProcessingStageSettings=(BRAP_ProcessingStageSettings *)BKNI_Malloc(sizeof(BRAP_ProcessingStageSettings));
                        if( NULL==psProcessingStageSettings)
                        {
                            ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
                            goto error;        
                        }                     
                            ret =BRAP_GetCurrentProcessingStageSettings(hRapCh->hRap->hAudioProcessingStageHandle[j],psProcessingStageSettings );
                        if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_ProgramCoefficients: BRAP_GetDefaultProcessingStageSettings() returned err(%d)",ret));	
                            goto error;
                        }                     
                        ret =BRAP_SetProcessingStageSettings(hRapCh->hRap->hAudioProcessingStageHandle[j],psProcessingStageSettings);                    
                        if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_ProgramCoefficients: BRAP_SetProcessingStageSettings() returned err(%d)",ret));	
                            goto error;
                        } 
                        BKNI_Free( psProcessingStageSettings );                               
                        break;
                    }
                }
            }
        }
    }
#endif    
    
error:	
    BDBG_LEAVE(BRAP_P_ProgramCoefficients);
    return ret;
}

#if (BRAP_DYNAMIC_PORT_SWITCHING == 1)
/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndDisableMixerOutputForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0, lvlCscd = 0, ppCscd = 0;
    BRAP_MIXER_P_Handle     hMixer;
    BRAP_MIXER_P_Handle     hMixerCscd;    
    unsigned int            uiMixerOutput=0, ui32RegVal=0;

    BDBG_ENTER(BRAP_P_FindAndDisableMixerOutputForOpPort);

    BDBG_ASSERT(hRap);

    *pbParentMixerRuns = false;

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec and Cap channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d is not Active",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    BDBG_ERR(("Cascade Mixer running"));
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);

        /* Stop the Output Ports */
        switch(eOpType)
        {
            case BRAP_OutputPort_eDac1:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;

            case BRAP_OutputPort_eI2s4:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;                                    

            case BRAP_OutputPort_eSpdif:
                ret = BRAP_OP_P_Stop( hOp );

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_OP_P_Stop: returned error for DAC1 port"));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }
                break;

            default:
                BDBG_ERR(("Mixer cannot be disabled for Output Port %d", eOpType));
                break;
        }    
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndDisableMixerOutputForOpPort);
    return ret;
}


/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndDisableMixerOutputForRbuf (
    BRAP_Handle         hRap,              /*[in] Rap Handle */
    unsigned int     	uiRBufId,          /*[in] Ring Buffer Id */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;    
    unsigned int            lvl =0, pp = 0, lvlCscd = 0, ppCscd = 0;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
#endif
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;
    BRAP_MIXER_P_Handle     hMixer;
    BRAP_MIXER_P_Handle     hMixerCscd;    
    unsigned int            uiMixerOutput=0, ui32RegVal=0;
    
    BDBG_ENTER(BRAP_P_FindAndDisableMixerOutputForRbuf);

    BDBG_ASSERT(hRap);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}

    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                BDBG_ERR(("In while"));
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    BDBG_ERR(("Cascade Mixer running"));
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}    
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndDisableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);

        /* Stop the Capture Port*/
        ret = BRAP_CAPPORT_P_Stop(hCapPort);    

        if(ret != BERR_SUCCESS)
        {
            BDBG_ERR(("BRAP_CAPPORT_P_Stop: returned error for Capture port %d", hCapPort->eCapPort));
            ret = BERR_TRACE(ret);        
            goto exit;        
        }   
    }
    
exit:        
    BDBG_LEAVE(BRAP_P_FindAndDisableMixerOutputForRbuf);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndEnableMixerOutputForOpPort (
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    int                     i=0,j=0,k=0,l=0;
    bool                    bFound = false;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair  eChSrcEq = BRAP_OutputChannelPair_eMax;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;
#endif
    unsigned int            lvl =0, pp = 0;
    BRAP_MIXER_P_Handle     hMixer;
#if 0
    unsigned int            lvlCscd = 0, ppCscd = 0
    BRAP_MIXER_P_Handle     hMixerCscd;
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;
#endif
    unsigned int            uiMixerOutput=0, ui32RegVal=0;

    BDBG_ENTER(BRAP_P_FindAndEnableMixerOutputForOpPort);

    BDBG_ASSERT(hRap);

    *pbParentMixerRuns = false;

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
            {
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                    {
                        if(NULL == hRapCh->pPath[j])
                        {
                            continue;
                        }
                        
                        hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                        if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }

    if (false == bFound)
    {

        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }   
        }
    
    }

    /* If not found in Dec and Cap channel, check for PB channels */
    if(false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_PATHS_IN_A_CHAN;j++)
                {
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                        {
                            if(NULL == hRapCh->pPath[j])
                            {
                                continue;
                            }
                            hOp = hRapCh->pPath[j]->sOp[k][l].hOp ;
                            if((hOp != NULL)&&(hOp->eOutputPort == eOpType))
                            {
                                bFound = true;
                                break;
                            }
                        }
                        if(true==bFound)
                        {
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if((false == bFound) || (NULL == hRapCh->pPath[j]))
    {
        BDBG_MSG(("BRAP_SetOutputVolume: The Output Port %d entry is not present",eOpType));
        /*
            This was earlier as BERR_TRACE(BERR_INVALID_PARAMETER);
            But on customer request this has been changed to only return without the trace
            The Trace was throwing an error message on the console.
        */
        return BERR_INVALID_PARAMETER;
    }

    /* If found, find the Mixer for the given Output Port */
	if(BRAP_P_Rsrc_eMixer==hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

 
	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eOpPort)
        {
            switch(eOpType)
            {
                case BRAP_OutputPort_eDac1:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sDac));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;

                case BRAP_OutputPort_eI2s4:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sI2s));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;                                    

                case BRAP_OutputPort_eSpdif:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sSpdif));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break; 

                default:
                    BDBG_ERR(("Mixer cannot be enabled for Output Port %d", eOpType));
                    break;                    
            }         
        }
        else
        {
            BDBG_ERR(("Op InLink and Mixer Outlink dont match"));
    		ret=BERR_NOT_SUPPORTED;
            goto exit;                              
        }
#if 0        
        else if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eMixer)
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                BDBG_ERR(("In while"));
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                uiMixerOutput = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiMixerOutput;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;                

        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
                    if(true != hMixerCscd->sParams.bOutputEnable0)
                    {
                        BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
                		ret=BERR_NOT_SUPPORTED;
                        goto exit;                  
                    }
                }
                else if(uiMixerOutput == 1)
                {
                    if(true != hMixerCscd->sParams.bOutputEnable1)
                    {
                        BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
                		ret=BERR_NOT_SUPPORTED;
                        goto exit;                  
                    }            
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
#if BRAP_P_EQUALIZER        
        else if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eSrcEq)
        {
        }
#endif 
#endif
    }
#if BRAP_P_EQUALIZER
    /* If found, find the Mixer for the given Output Port */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sOp[k][l].sOpInLink.eRsrcType)
	{
        /* For Equalizer case it is like MIXER->SRC->OP*/	    
	    eChSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sOp[k][l].sOpInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));
 
	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eOpPort)
        {
            switch(eOpType)
            {
                case BRAP_OutputPort_eDac1:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sDac));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;

                case BRAP_OutputPort_eI2s4:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sI2s));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break;                                    

                case BRAP_OutputPort_eSpdif:
                    ret = BRAP_OP_P_Start(hOp, &(hOp->uOpParams.sSpdif));

                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_OP_P_Start: returned error for DAC1 port"));
                        ret = BERR_TRACE(ret);        
                        goto exit;        
                    }
                    break; 

                default:
                    BDBG_ERR(("Mixer cannot be enabled for Output Port %d", eOpType));
                    break;                      
            }         
        }
        else
        {
            BDBG_ERR(("Op InLink and Mixer Outlink dont match"));
    		ret=BERR_NOT_SUPPORTED;
            goto exit;                              
        }
	}
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);
    
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndEnableMixerOutputForOpPort);
    return ret;
}


/***************************************************************************
Summary:
    Private function that gets the mixer associated to a output port
    
**************************************************************************/
BERR_Code
BRAP_P_FindAndEnableMixerOutputForRbuf (
    BRAP_Handle         hRap,              /*[in] Rap Handle */
    unsigned int     	uiRBufId,          /*[in] Ring Buffer Id */
    bool                *pbParentMixerRuns /*[out]*/
)
{
    BERR_Code               ret=BERR_SUCCESS;

    BRAP_ChannelHandle      hRapCh= NULL;
    BRAP_RBUF_P_Handle	    hRBuf;
	BRAP_CAPPORT_P_Handle   hCapPort=NULL;  /* Capture Port handle */
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            lvl =0, pp = 0;    
    int                     i=0,j=0,k=0,l=0;	
    bool                    bCapPort_found = false, bMixer_found = false;
    BRAP_MIXER_P_Handle     hMixer;
#if 0
    unsigned int            lvlCscd = 0, ppCscd = 0;
    BRAP_MIXER_P_Handle     hMixerCscd;
    unsigned int            lvlSrcEq = 0, ppSrcEq = 0;    
    BRAP_OutputChannelPair  eChPairCscd = BRAP_OutputChannelPair_eMax;    
#if BRAP_P_EQUALIZER
    BRAP_OutputChannelPair   eChSrcEq = BRAP_OutputChannelPair_eMax;
#endif    
#endif
    unsigned int            uiMixerOutput=0, ui32RegVal=0;
    
    BDBG_ENTER(BRAP_P_FindAndEnableMixerOutputForRbuf);

    BDBG_ASSERT(hRap);

    /* Find the channel which feeds to this ringbuffer */
	for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
	{
		hRapCh = hRap->hRapDecCh[i];
		if ( hRapCh != NULL )
		{
			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
			{
				if(NULL == hRapCh->pPath[j])
				{
					continue;
				}
				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
				{
					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
					{
						hRBuf = hRapCh->pPath[j]->hRBuf[k];
						if( hRBuf != NULL )
						{
							if ( hRBuf->uiIndex == uiRBufId )
							{
								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
								{
									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
									if (hCapPort != NULL)
									{
										bCapPort_found = true;						
										break;
									}
								}
								if (true == bCapPort_found)
								{
									break;						
								}								
							}
						}
					}
				}
				if (true == bCapPort_found)
				{
					break;
				}
		    }
			if( true==bCapPort_found )
			{
				break;
			}
		}	
	}

    /* If not found the required capture port in decode channel, look in capture channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapCapCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
						break;
					}
				}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Not found the required capture port in capture channel also, look in playback channel */
    if( false == bCapPort_found )
    {
    	for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
    	{
    		hRapCh = hRap->hRapPbCh[i];
    		if ( hRapCh != NULL )
    		{
    			for(j=(BRAP_P_MAX_PATHS_IN_A_CHAN - 1);j>=0;j--)
    			{
    				if(NULL == hRapCh->pPath[j])
    				{
    					continue;
    				}
    				if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eCapture)
    				{
    					for(k=0;k<BRAP_RM_P_MAX_OP_CHANNELS;k++)
    					{
    						hRBuf = hRapCh->pPath[j]->hRBuf[k];
    						if( hRBuf != NULL )
    						{
    							if ( hRBuf->uiIndex == uiRBufId )
    							{
    								for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
    								{
    									hCapPort = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort;
    									if (hCapPort != NULL)
    									{
    										bCapPort_found = true;						
    										break;
    									}
    								}
    								if (true == bCapPort_found)
    								{
    									break;						
    								}								
    							}
    						}
    					}
    				}
    				if (true == bCapPort_found)
    				{
    					break;
    				}
    			}
    			if( true==bCapPort_found )
    			{
    				break;
    			}
    		}	
    	}    
    }

    /* Capture port is found, now find the corresponding mixer */
	if (true == bCapPort_found)
	{
		for(j=0; j<BRAP_P_MAX_PATHS_IN_A_CHAN; j++)
		{
			if(NULL == hRapCh->pPath[j])
			{
				continue;
			}
			if (hRapCh->pPath[j]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)
			{
				for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
				{
					if(hCapPort == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][l].hCapPort)
					{
						bMixer_found = true;
						break;
					}
				}
				if (true == bMixer_found)
    			{
    				break;
    			}
    		}	
    	}    
    }
    
    
	/* If mixer or Capture Port for this Ring Buffer Id is not found in any of the active channels,
	    return Error */
	if((false == bCapPort_found) || (false == bMixer_found) || (NULL == hRapCh->pPath[j]))
	{
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: The Ring Buffer Id %d is not Active",uiRBufId));
		return BERR_INVALID_PARAMETER;
	}

    /* Find the Mixer for the Capture Port that feeds the given Rbuf */
	if(BRAP_P_Rsrc_eMixer == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChPair = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvl = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    pp = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;
        uiMixerOutput = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiMixerOutput;

        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

	    /* Get the Handle for the Mixer feeding to the Output port */
        if(uiMixerOutput == 0)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }
        }
        else if(uiMixerOutput == 1)
        {
            if(true == hMixer->sParams.bOutputEnable1)
            {
                *pbParentMixerRuns = true;            
            }
            else
            {
                BDBG_ERR(("Cannot link the Destination to an Inactive Mixer"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                  
            }            
        }
        else
        {
            BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }

        if(*pbParentMixerRuns == true)
        {
            if(hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerOutLink[!(uiMixerOutput)].eRsrcType == BRAP_P_Rsrc_eCapPort)
            {
                *pbParentMixerRuns = true;
                ret = BRAP_CAPPORT_P_Start(hCapPort, &hCapPort->sParams);    

                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_CAPPORT_P_Stop: returned error for Capture port %d", hCapPort->eCapPort));
                    ret = BERR_TRACE(ret);        
                    goto exit;        
                }         
            }
            else
            {
                BDBG_ERR(("Capture Port InLink and Mixer Outlink dont match"));
        		ret=BERR_NOT_SUPPORTED;
                goto exit;                              
            }
        }
    }
#if 0    
#if BRAP_P_EQUALIZER
    /* Find the SRC for the Capture Port that feeds the given Rbuf, then the corresponding Mixer */
	else if(BRAP_P_Rsrc_eSrcEq == hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eRsrcType)
	{
	    eChSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.eChnPair;
	    lvlSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiLevel;
	    ppSrcEq = hRapCh->pPath[j]->sCapPort[BRAP_OutputChannelPair_eLR][0].sCapPortInLink.uiPrlPth;

        eChPair = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.eChnPair;
        lvl = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiLevel;
        pp = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiPrlPth;

        uiMixerOutput = hRapCh->pPath[j]->sSrcEq[eChSrcEq][ppSrcEq].sSrcEqInLink.uiMixerOutput;
        if (NULL != hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer)
    	{
            hMixer = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer;
    	}
        else
        {
            BDBG_ERR(("Invalid Mixer Handle=0x%x", hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].hMixer));
    		ret=BERR_INVALID_PARAMETER;
            goto exit;            
        }        
		BDBG_MSG(("BRAP_P_FindAndEnableMixerOutputForRbuf: hMixer=0x%x, uiMixerIndex=%d", hMixer, hMixer->uiMixerIndex));

        if((true == hMixer->sParams.bOutputEnable0) &&
           (true == hMixer->sParams.bOutputEnable1))
        {
    	    /* Get the Handle for the Mixer feeding to the Output port */
            if(uiMixerOutput == 0)
            {
    	        hMixer->sParams.bOutputEnable0 = false;
                *pbParentMixerRuns = true;
            }
            else if(uiMixerOutput == 1)
            {
    	        hMixer->sParams.bOutputEnable1 = false;
                *pbParentMixerRuns = true;                
            }
            else
            {
                BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
        		ret=BERR_INVALID_PARAMETER;
                goto exit;            
            }        
        }
        else
        {

            hMixerCscd = hMixer;
            while((*pbParentMixerRuns == false) && 
                  (hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eRsrcType == BRAP_P_Rsrc_eMixer))
            {
                eChPairCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].eChnPair;
                lvlCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiLevel;
                ppCscd = hRapCh->pPath[j]->sMixer[lvl][eChPair][pp].sMixerInLink[hMixerCscd->sSettings.uiMixerInput[0]].uiPrlPth;
                hMixerCscd = hRapCh->pPath[j]->sMixer[lvlCscd][eChPairCscd][ppCscd].hMixer;

                if((true == hMixerCscd->sParams.bOutputEnable0) &&
                   (true == hMixerCscd->sParams.bOutputEnable1))
                {
                    *pbParentMixerRuns = true;  
                    break;
                }

                eChPair = eChPairCscd;
                lvl = lvlCscd;
                pp = ppCscd;
            }

            if(*pbParentMixerRuns == true)
            {
        	    /* Get the Handle for the Mixer feeding to the Output port */
                if(uiMixerOutput == 0)
                {
        	        hMixer->sParams.bOutputEnable0 = false;
                    *pbParentMixerRuns = true;
                }
                else if(uiMixerOutput == 1)
                {
        	        hMixer->sParams.bOutputEnable1 = false;
                    *pbParentMixerRuns = true;                
                }
                else
                {
                    BDBG_ERR(("Invalid uiMixerOutput=%d", uiMixerOutput));
            		ret=BERR_INVALID_PARAMETER;
                    goto exit;            
                }            
            }
        }
	}
#endif
#endif
	else
    {
		BDBG_ERR(("No mixer connected to this destination"));
		ret=BERR_INVALID_PARAMETER;        
        goto exit;
    }

    if(*pbParentMixerRuns == true)
    {
        /* Read the Output Enable Register */
        ui32RegVal = BRAP_Read32 (hMixer->hRegister,
                                   (hMixer->ui32DpOffset 
                                    + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA));

        /* Disable Mixer output */
        switch (hMixer->uiMixerIndex)
        {
            case 0:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER0_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER0_OUTPUT1_ENA, Disable);
                }
                break;
            case 1:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER1_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER1_OUTPUT1_ENA, Disable);
                }
                break;
            case 2:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER2_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER2_OUTPUT1_ENA, Disable);
                }
                break;
            case 3:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER3_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER3_OUTPUT1_ENA, Disable);
                }
                break;
            case 4:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER4_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER4_OUTPUT1_ENA, Disable);
                }
                break;
            case 5:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER5_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER5_OUTPUT1_ENA, Disable);
                }
                break;
            case 6:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER6_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER6_OUTPUT1_ENA, Disable);
                }
                break;
            case 7:
                if(false == hMixer->sParams.bOutputEnable0)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT0_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT0_ENA, Disable);
                }
                if(false == hMixer->sParams.bOutputEnable1)
                {
                    ui32RegVal &= ~(BCHP_MASK(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA,MIXER7_OUTPUT1_ENA));
                    ui32RegVal |= BCHP_FIELD_ENUM(AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA, MIXER7_OUTPUT1_ENA, Disable);
                }
                break;
            default:
                BDBG_ERR(("BRAP_MIXER_P_Start: Invalid Mixer Index %d",hMixer->uiMixerIndex));
                return BERR_TRACE (BERR_INVALID_PARAMETER);
        }

        BRAP_Write32 ( hMixer->hRegister,
                               (hMixer->ui32DpOffset 
                                + BCHP_AUD_FMM_DP_CTRL0_MIXER_OUTPUT_ENA), ui32RegVal);
    }

exit:        
    BDBG_LEAVE(BRAP_P_FindAndEnableMixerOutputForRbuf);
    return ret;
}

#endif


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)

void   BRAP_P_SearchAndFreeRbuf(
    BRAP_ChannelHandle hRapCh,
	unsigned int 				uiFwProcBranchId,/* [in] FW Processing Branch Id */
    unsigned int 				uiCapPortSrcId,	 /* [in] Capture Port Source Id */    
    void *pBufferPtr    
    )
{
    unsigned int    i = 0;

		        /* Returning Device Rbuf to Pool */
    /* sInRBuf */
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i].bUsed=false;
            goto end;
        }
    } 
    /* sOutRBuf */        
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i].bUsed=false;
            goto end;
        }
    }
    /* sDestRBuf */    
    for(i = 0; i< BRAP_OutputChannelPair_eMax*2; i++)
    {
        if(hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i].bUsed=false;
            goto end;
        }
    }
			        /* sHbrRBuf */
    for(i = 0; i< BRAP_NUM_HBR_BUFFERS;i++)
			        {
        if(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr == pBufferPtr)
        {
            hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i].bUsed=false;
            goto end;
        }
    }

				/* Returning Channel Rbuf to Pool */
    /* sDecOutRBuf */    
    for(i = 0; i< BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; i++)
    {
        if(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i].pRBufPtr == pBufferPtr)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i].bUsed=false;
            goto end;
        }
    }
    /* sDecInRBuf */    
    for(i = 0; i < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; i++)
    {
        if(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i].pRBufPtr == pBufferPtr)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i].bUsed=false;
            goto end;            
        }
    }
    /* sPbRBuf */    
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        if(hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr == pBufferPtr)
        {
	        hRapCh->sChanRBufPool.sPbRBuf[i].bUsed=false;
            goto end;
        }
    } 

    BDBG_WRN(("The Ring Buffer %#x can't be returned to the buffer pool",pBufferPtr));
end:
    return;
}


/***************************************************************************
Summary:
    Private function that returns the RBuf from Ring Buffer Pool.
***************************************************************************/
void
BRAP_P_ReturnRBufToPool(
    BRAP_ChannelHandle hRapCh,
    BRAP_P_ObjectHandles 		*pPath,			/* [in] Path id */
	bool						bIsDestRbuf,	/* [in] 1= Destination RBuf Type
												   0 =  Other RBuf Type */
	unsigned int 				uiFwProcBranchId,/* [in] FW Processing Branch Id */
	unsigned int 				uiCapPortSrcId	 /* [in] Capture Port Source Id */
    )
{
	unsigned int    i = 0;
    void *pTemp =NULL;
    BDBG_ENTER(BRAP_P_ReturnRBufToPool);
    BDBG_ASSERT(hRapCh);

    if(bIsDestRbuf == true) /*Destination Rbuf */
    {
        for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
        {
            if(NULL == hRapCh->pDstDetails[i]) 
            {
				continue;
            }
            if(BRAP_AudioDst_eRingBuffer == hRapCh->pDstDetails[i]->eAudioDst)
            {
                hRapCh->hRap->sDeviceRBufPool.sDestRBuf[0].bUsed=false;
                hRapCh->hRap->sDeviceRBufPool.sDestRBuf[1].bUsed=false;
                break;
            }
        }
    }
    else
    {
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        {
            if(pPath->hRBuf[i] == NULL)
            continue;
            pTemp =pPath->hRBuf[i]->sSettings.sExtSettings.pBufferStart;
            if(pTemp != NULL)
            {
                BRAP_P_SearchAndFreeRbuf(hRapCh,uiFwProcBranchId,uiCapPortSrcId,pTemp);
            }            
        }/* for i */	
#ifdef RAP_MULTISTREAM_DECODER_SUPPORT    
        if((hRapCh->hMultiStreamDecoder != NULL)
            &&(hRapCh->uiFWMixerIpIndex != BRAP_INVALID_VALUE)
            &&(hRapCh->uiFWMixerIpIndex < BRAP_P_MAX_FW_STG_INPUTS)
            &&(hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex] < BRAP_AF_P_MAX_CHANNELS))
        {
            for(i = 0; i < hRapCh->hMultiStreamDecoder->uiNumValidIOBuffer[hRapCh->uiFWMixerIpIndex]; i++)
            {
                pTemp = (void *)hRapCh->hMultiStreamDecoder->ui32InterTaskIoBufferAddress[hRapCh->uiFWMixerIpIndex][i];
                if(pTemp != NULL)
                {
                    BRAP_P_SearchAndFreeRbuf(hRapCh,uiFwProcBranchId,uiCapPortSrcId,pTemp);
    			}
    	    } /* for i */
        }
#endif        
	}
    
    BDBG_LEAVE(BRAP_P_ReturnRBufToPool);    
    return;
}

/***************************************************************************
Summary:
    Private function that gets the RBuf from Ring Buffer Pool.
***************************************************************************/
BERR_Code BRAP_P_GetRbufFromPool(
	BRAP_ChannelHandle 			hRapCh,			/* [in] Channel Handle */
	const BRAP_ChannelParams 	*pAudioParams, 	/* [in] Audio params passed 
	                                               during channel start time */
	BRAP_P_ObjectHandles 		*pPath,			/* [in] Path id */
	bool						bIsDestRbuf,	/* [in] 1= Destination RBuf Type
												   0 =  Other RBuf Type */
	unsigned int 				uiFwProcBranchId,   /* [in] FW Processing Branch Id */
	unsigned int 				uiCapPortSrcId,	 /* [in] Capture Port Source Id */
	BRAP_RBUF_P_Settings 		*pRBufSettings,     /* [out] Ring Buffer Settings */
	unsigned int                uiChannelNo         /* [in] Input Channel from 
	                                                   the channel pair */
	)
{
	int i = 0;
	BRAP_P_RBufMem *pRbufMem = NULL;
 
    BSTD_UNUSED(uiChannelNo);

	BDBG_ENTER(BRAP_P_GetRbufFromPool);
	
	BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(pRBufSettings);
  
	if(bIsDestRbuf == true) /*Destination Rbuf */
	{
		for(i = 0;i<BRAP_OutputChannelPair_eMax*2;i++)
		{
			pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sDestRBuf[i]);
			if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr != NULL))
			{
				pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
				pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FULL_BYTE_MARK;
				pRbufMem->bUsed = true;
				goto exit;
			}
		}
		BDBG_ERR(("Not enough RBuf available for Destination RBuf"));
		return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
	}
	else
	{
		BDBG_ASSERT(pPath);
		switch(hRapCh->eChannelType)
		{
			case BRAP_ChannelType_eDecode:
				switch(pPath->eUsgPath)
				{
                    case BRAP_P_UsgPath_eDecodePcmPostMixing:
                    case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                            if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                            {
                                pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                pRbufMem->bUsed = true;
                                pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                goto exit;
                            }
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
                        return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                        break;                        
                    case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_eDecodeCompress:
                    case BRAP_P_UsgPath_ePPBranch:
                    case BRAP_P_UsgPath_eDownmixedPath:
                        if((BRAP_P_UsgPath_eDecodeCompress==pPath->eUsgPath)
                            &&(true==hRapCh->hRap->sDeviceRBufPool.pExtRBufPoolSettings->bHbrMode)
                            && ( (hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].bHbrEnable == true)
                            ||(hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bHbrEnable == true))
                            &&(true==BRAP_P_IsMaiFedByPath(pPath)))
                        {
    						for(i = 0;i<BRAP_NUM_HBR_BUFFERS;i++)
    						{
    							pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i]);
    							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
    							{
    								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
    								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
    								pRbufMem->bUsed = true;
    								pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
    								goto exit;
    							}
					        }
                        }
#ifdef RAP_BTSC_SUPPORT
                        else if((true==BRAP_P_IsDacFedByPath(pPath))&&((BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac0))
                                ||(BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac1))
                                ||(BRAP_P_IsPPPresentOnOutput(hRapCh,BRAP_ProcessingType_eBtsc,BRAP_OutputPort_eDac2))))
                        {
                            for(i = 0;i<BRAP_NUM_HBR_BUFFERS;i++)
                            {
                                pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sHbrRBuf[i]);
                                if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                {
                                    pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                    pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                    pRbufMem->bUsed = true;
                                    pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;                                                    
                                    goto exit;
                                }
                            }                                        
                        }

#endif                                    
                        else
                        {
                            for(i = 0;i<BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH;i++)
                            {
                                pRbufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i]);
                                if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                {
                                	pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                	pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                	pRbufMem->bUsed = true;
                                	pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                	goto exit;
                                }
                            }
                        }
						BDBG_ERR(("Not enough RBuf available for DEC channel decode path output buffer"));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
						break;
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
								case BRAP_P_UsgPath_eDecodeCompress:
								case BRAP_P_UsgPath_eDecodePcm:
									for(i = 0;i<BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH;i++)
									{
										pRbufMem  =  &(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i]);
										if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
										{
											pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
											pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                                                            pRbufMem->bUsed = true;
											pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
											goto exit;
										}
									}
									BDBG_ERR(("Not enough RBuf available for DEC channel cap path buffer"));
									return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
									break;
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;
								default:										
									BDBG_ERR(("Unsupported out path %d for a cappath",hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath));
									return BERR_TRACE(BERR_NOT_SUPPORTED);
									break;
							}/* switch out eUsgPath */
						}/* if */
						break;
                    case BRAP_P_UsgPath_eMixPath:
                    case BRAP_P_UsgPath_eSharedPP:                        
                    case BRAP_P_UsgPath_eDownmixedMixPath:                                                                
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);					
				} /* switch DEC ch eUsgPath */
				break;
		    case BRAP_ChannelType_ePcmPlayback:
				switch(pPath->eUsgPath)
				{
					case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_ePPBranch:
                		BDBG_ASSERT(pAudioParams);                        
						for(i = 0;i<BRAP_P_MAX_RBUF_PER_PBCH;i++)
						{
							pRbufMem = &(hRapCh->sChanRBufPool.sPbRBuf[i]);
							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
							{
								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
								pRbufMem->bUsed = true;
								pRBufSettings->sExtSettings.uiWaterMark = pAudioParams->sBufParams.uiWaterMark;
								goto exit;
							}
						}
						BDBG_ERR(("Not enough RBuf available for PB buffer for decode path"));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
						break;
					case BRAP_P_UsgPath_eDecodePcmPostMixing:
					case BRAP_P_UsgPath_eDecodeCompressPostMixing:                        
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                        	if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                        	{
                        		pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                        		pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                        		pRbufMem->bUsed = true;
                        		pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                        		goto exit;
                        	}
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
						return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);                        
                     break;
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;					
				
								default:										
									BDBG_ERR(("Invalid Usage Path"));
									return BERR_TRACE(BERR_INVALID_PARAMETER);
							}
						}
						break;
                    case BRAP_P_UsgPath_eMixPath:
                    case BRAP_P_UsgPath_eSharedPP:                        
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);						
				}
				break;
			case BRAP_ChannelType_ePcmCapture:
				switch(pPath->eUsgPath)
				{
					case BRAP_P_UsgPath_eDecodePcm:
                    case BRAP_P_UsgPath_ePPBranch:                     
						for(i = 0;i<BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH;i++)
						{
							pRbufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[uiFwProcBranchId][i]);
							if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
							{
								pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
								pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
								pRbufMem->bUsed = true;
								pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
								goto exit;
							}
						}
                        break;
                    case BRAP_P_UsgPath_eDecodePcmPostMixing:
                    case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                    case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                        for(i = 0;i<BRAP_MAX_DEVICE_OUTPUT_BUFFER;i++)
                        {
                            pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sOutputBuffer[i]);
                            if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                            {
                                pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                pRbufMem->bUsed = true;
                                pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                goto exit;
                            }
                        }
                        BDBG_ERR(("Not enough RBuf available for output of Post mixing Task "));
                        return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                        break;                          
					case BRAP_P_UsgPath_eCapture:
						if((pPath->sOutPathProp[0].uiPathIdx != BRAP_INVALID_VALUE) && 
						   (pPath->sOutPathProp[0].uiPathIdx < BRAP_P_MAX_PATHS_IN_A_CHAN))
						{
						    BDBG_ASSERT(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]);
							switch(hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath)
							{
								case BRAP_P_UsgPath_eDecodeCompress:
								case BRAP_P_UsgPath_eDecodePcm:
									for(i = 0;i<BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH;i++)
									{
										pRbufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[uiCapPortSrcId][i]);
										if(pRbufMem->bUsed == false && pRbufMem->pRBufPtr!=NULL)
										{
											pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
											pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
											pRbufMem->bUsed = true;
											pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
											goto exit;
										}
									}
									BDBG_ERR(("Not enough RBuf available for CAP ch decode in path"));
									return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
									break;
                                case BRAP_P_UsgPath_eDecodePcmPostMixing:
            					case BRAP_P_UsgPath_eDecodeCompressPostMixing:
                                case BRAP_P_UsgPath_ePPBranchPostMixing:                        
                                    for(i = 0;i<BRAP_MAX_DEVICE_INPUT_BUFFER;i++)
                                    {
                                        pRbufMem = &(hRapCh->hRap->sDeviceRBufPool.sInputBuffer[i]);
                                        if((pRbufMem->bUsed == false) && (pRbufMem->pRBufPtr!=NULL))
                                        {
                                            pRBufSettings->sExtSettings.pBufferStart = pRbufMem->pRBufPtr;
                                            pRBufSettings->sExtSettings.uiSize = pRbufMem->uiSize;
                                            pRbufMem->bUsed = true;
                                            pRBufSettings->sExtSettings.uiWaterMark = BRAP_RBUF_P_DEFAULT_FREE_BYTE_MARK;
                                            goto exit;
                                        }
                                    }
                                    BDBG_ERR(("Not enough RBuf available for Input of Post mixing Task "));
                                    return BERR_TRACE(BRAP_ERR_RESOURCE_EXHAUSTED);
                                    break;                                    
								default:										
									BDBG_ERR(("Invalid Out Usage Path %d OutPathArrIdx = %d",
										 hRapCh->pPath[pPath->sOutPathProp[0].uiPathIdx]->eUsgPath, pPath->sOutPathProp[0].uiPathIdx));
									return BERR_TRACE(BERR_NOT_SUPPORTED);
							}
						}
                        break;
					default:
						BDBG_ERR(("Invalid Usage Path = %d",pPath->eUsgPath));
						return BERR_TRACE(BERR_NOT_SUPPORTED);					
					}
				break;
			default:
				BDBG_ERR(("Invalid Channel Type = %d",hRapCh->eChannelType));
				return BERR_TRACE(BERR_NOT_SUPPORTED);
		}/* switch chtype */
	}/* if bIsDestRbuf */

exit:	
	BDBG_LEAVE(BRAP_P_GetRbufFromPool);
	return BERR_SUCCESS;
}

#endif

/**************************************************************************
Summary:
    Private function that opens FMM module handles for a particular path.
    Note: Output and SpdifFm module handles are not opened here.
**************************************************************************/
BERR_Code BRAP_P_OpenFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
    const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                uiPth,          /* [in] Path id */
    BRAP_RM_P_ResrcGrant        *pRsrcGrnt      /* [in] Resources to be opened */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BERR_Code               ret1 = BERR_SUCCESS;
    BRAP_RBUF_P_Settings    sRBufSettings;
    BRAP_MIXER_P_Settings   sMixerSettings;
    BRAP_P_ObjectHandles    *pPath = NULL;
    unsigned int            i = 0,j=0,k=0,l=0;
#if (BRAP_7550_FAMILY != 1)    
    BRAP_RM_P_SrcGrant      sTempSrcGrant;
    BRAP_SRC_P_Settings     sSrcSettings;
    BRAP_DSTCH_P_Settings   sDstChSettings; 
    BRAP_CAPPORT_P_Settings sCapPortSettings;    
#endif
    #if BRAP_P_EQUALIZER
    BRAP_RM_P_SrcEqGrant    sTempSrcEqGrant;
    #endif
    BRAP_RM_P_MixerGrant    sTempMixerGrant;
    BRAP_SRCCH_P_Settings   sSrcChSettings;
    bool                    bWdgRecovery = false;
    unsigned int            uiMixInId = 0;
    bool bCompress =false;
#if ((BRAP_3548_FAMILY == 1) )
    bool                    bLinked = false;
    unsigned int            uiLinkId = 0;
    unsigned int            uiMasterPathId = BRAP_RM_P_INVALID_INDEX;
    BRAP_P_ObjectHandles    *pMasterPath = NULL;
#endif
    
    BDBG_ENTER(BRAP_P_OpenFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pRsrcGrnt);
    BDBG_ASSERT(uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

   /* Check if this is a watchdog recovery. */
	bWdgRecovery = BRAP_P_GetWatchdogRecoveryFlag(hRapCh->hRap);

    pPath = hRapCh->pPath[uiPth];

#if ((BRAP_3548_FAMILY == 1) )
	if(( BRAP_ChannelType_eDecode==hRapCh->eChannelType )
		&&( BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode )
		&&(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth]->eUsgPath)
		&&(0 == uiPth))
	{
        for(i=0;i<BRAP_RM_P_MAX_LINKAGE_SUPPORTED;i++)
        {
            if((true == hRapCh->hRap->sChLinkInfo[i].bUsedLinkage)&&
                (hRapCh == hRapCh->hRap->sChLinkInfo[i].hRapSlaveCh))
            {
                bLinked = true;
                uiLinkId = i;
                break;
            }
        }
        if((i!=BRAP_RM_P_MAX_LINKAGE_SUPPORTED)&&(true == bLinked))
        {
            for(i=0;i<BRAP_P_MAX_PATHS_IN_A_CHAN;i++)
            {
                if((BRAP_P_UsgPath_eCapture == 
                    hRapCh->hRap->sChLinkInfo[uiLinkId].hRapMasterCh->pPath[i]->eUsgPath) &&(0 == uiPth))
                {
                    uiMasterPathId = i;
                    pMasterPath = hRapCh->hRap->sChLinkInfo[uiLinkId].hRapMasterCh->pPath[i];
                    break;
                }
            }
        }
    }
#endif

     
    /* 1. Prepare settings and open Rbuf */
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        if(pRsrcGrnt->uiRbufId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            bCompress =false;
            BRAP_P_IsPathOutputCompress( hRapCh,uiPth,&bCompress);            
            if((bCompress == true) &&(i>=BRAP_NUM_BUFFER_FOR_COMPRESSED))
            {
                break;
            }        
            
            if(false == bWdgRecovery)
            {
                /* Get default settings */
                ret = BRAP_RBUF_P_GetDefaultSettings(&sRBufSettings);
                if(BERR_SUCCESS != ret)
                {ret = BERR_TRACE(ret);goto close_rbuf;}
#if (BRAP_7405_FAMILY == 1)            		
            if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
            {                
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
        		if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) 
                {
                    sRBufSettings.bProgRdWrRBufAddr = false;
                    sRBufSettings.bRbufOfClonedPort = false;
                    /* Default values for sRBufSettings.sExtSettings:
                        pBufferStart, uiSize and uiWaterMark */
                }
                else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
                {
                    /* TODO: Enable this code as and when more channel types are 
                       supported */
                    sRBufSettings.bProgRdWrRBufAddr = true;
                    sRBufSettings.bRbufOfClonedPort = false;
                }	
        		
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
            if(hRapCh->bIndepDelayEnabled == true)
            {
                BDBG_MSG(("pPath->uiMasterpathId =%d , hRapCh->pPath[pPath->uiMasterpathId] = %#x"
                    ,pPath->uiMasterpathId,hRapCh->pPath[pPath->uiMasterpathId] ));
                if((pPath->uiMasterpathId != BRAP_INVALID_VALUE)
                    &&(hRapCh->pPath[pPath->uiMasterpathId] != NULL)
                    &&(hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i] !=NULL))
                {
                    sRBufSettings.sExtSettings = hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i]->sSettings.sExtSettings;
                    sRBufSettings.bProgRdWrRBufAddr = hRapCh->pPath[pPath->uiMasterpathId]->hRBuf[i]->sSettings.bProgRdWrRBufAddr;
                    sRBufSettings.bRbufOfClonedPort = true;
                }
                else
                {
                    ret = BRAP_P_GetRbufFromPool(hRapCh,pAudioParams,pPath,false,0,0,&sRBufSettings, i);                
                }         
            }
            else
#endif
            {
#if ((BRAP_3548_FAMILY == 1) )
                if((true == bLinked)&&(BRAP_RM_P_INVALID_INDEX != uiMasterPathId)
                    &&(BRAP_P_UsgPath_eCapture == hRapCh->pPath[uiPth]->eUsgPath)&&(0 == uiPth))
                {
                    sRBufSettings.sExtSettings = pMasterPath->hRBuf[i]->sSettings.sExtSettings;
                    sRBufSettings.bProgRdWrRBufAddr = pMasterPath->hRBuf[i]->sSettings.bProgRdWrRBufAddr;
                    sRBufSettings.bRbufOfClonedPort = true;
                }
                else
#endif
                {
                    ret = BRAP_P_GetRbufFromPool(hRapCh,pAudioParams,pPath,false,0,0,&sRBufSettings, i);
                    }                    
            }
        		if(BERR_SUCCESS != ret)
                {
                	ret = BERR_TRACE(ret);
        			goto close_rbuf;
        		}
#else
                /* Modify settings (if any) */
                if(BRAP_ChannelType_eDecode == hRapCh->eChannelType) 
                {
                    sRBufSettings.bProgRdWrRBufAddr = false;
                    sRBufSettings.bRbufOfClonedPort = false;

                    /* Default values for sRBufSettings.sExtSettings:
                        pBufferStart, uiSize and uiWaterMark */
                }
                else if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
                {
                    /* TODO: Enable this code as and when more channel types are 
                       supported */
                    sRBufSettings.bProgRdWrRBufAddr = true;
                    sRBufSettings.bRbufOfClonedPort = false;
                    if (0 == i%BRAP_RM_P_MAX_RBUFS_PER_SRCCH)
                    {
                        sRBufSettings.sExtSettings.pBufferStart = 
                                        pAudioParams->sBufParams.pLeftBufferStart;
                    }
                    else
                    {
                        sRBufSettings.sExtSettings.pBufferStart = 
                                        pAudioParams->sBufParams.pRightBufferStart;
                    }
                    sRBufSettings.sExtSettings.uiSize = 
                                                   pAudioParams->sBufParams.uiSize;
                    sRBufSettings.sExtSettings.uiWaterMark = 
                                              pAudioParams->sBufParams.uiWaterMark;
                }
#endif            
            }
    
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif                 
                {
                /* Open Rbuf handle */
                ret = BRAP_RBUF_P_Open( pPath->hFmm,
                                        &(pPath->hRBuf[i]),
                                        pRsrcGrnt->uiRbufId[i],
                                        &sRBufSettings);
                if(BERR_SUCCESS != ret)
                    {
                        ret = BERR_TRACE(ret);goto close_rbuf;
                    }
                }

                }/* bWdgRecovery == false */
            else
            {
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif             
            {
                /* Open Rbuf handle */
                ret = BRAP_RBUF_P_Open( pPath->hFmm,
                                        &(pPath->hRBuf[i]),
                                        pRsrcGrnt->uiRbufId[i],
                                        NULL);
                if(BERR_SUCCESS != ret)
                {ret = BERR_TRACE(ret);goto close_rbuf;}                
            }
            }
            
            BDBG_MSG(("Ring buffer %d opened",pRsrcGrnt->uiRbufId[i]));
        }
    }/* for i */
    /* Ring buffer open done */

    /* 2. Prepare settings and open SrcCh */
#if (BRAP_7405_FAMILY == 1)            		
                if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                    &&(hRapCh->bOpenTimeWrToRbuf == true)
                    &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif   
{
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(pRsrcGrnt->uiSrcChId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            /* Open SrcCh handle */
            ret = BRAP_SRCCH_P_Open( pPath->hFmm,
                                    &(pPath->sSrcCh[i].hSrcCh),
                                    pRsrcGrnt->uiSrcChId[i],
                                    &sSrcChSettings);
            if(BERR_SUCCESS != ret)
            { ret =  BERR_TRACE(ret);goto close_srcch;}
            
            BDBG_MSG(("Source Channel %d opened",pRsrcGrnt->uiSrcChId[i]));
        }
    }/* for i */
    /* SrcCh Open Done */
}

#if (BRAP_7550_FAMILY !=1)
    /* 3. Prepare settings and open SRC */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    sTempSrcGrant = 
                                pRsrcGrnt->sSrcMixerGrnt[i].sSrcGrant[j][k][l];
                    if((sTempSrcGrant.uiSrcBlkId != BRAP_RM_P_INVALID_INDEX)&&
                       (sTempSrcGrant.uiSrcId != BRAP_RM_P_INVALID_INDEX))
                    {
                        /* Open SRC handle */
                        ret = BRAP_SRC_P_Open(pPath->hFmm,
                                              &(pPath->sSrc[i][k][l].hSrc[j]),
                                              sTempSrcGrant.uiSrcId,
                                              sTempSrcGrant.uiSrcBlkId,
                                              &sSrcSettings);
                        if(BERR_SUCCESS != ret)
                        {  ret = BERR_TRACE(ret);goto close_src;}
                        
                        BDBG_MSG(("SRC %d of SRC Block %d opened",
                               sTempSrcGrant.uiSrcId,sTempSrcGrant.uiSrcBlkId));                                              
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
    /* SRC open done */
#endif

    /* 4. Prepare settings and open Mixer */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                sTempMixerGrant = pRsrcGrnt->sSrcMixerGrnt[i].sMixerGrant[j][k];
                if ((sTempMixerGrant.uiDpId != BRAP_RM_P_INVALID_INDEX)&&
                    (sTempMixerGrant.uiMixerId != BRAP_RM_P_INVALID_INDEX))
                {
                    /* Get default setting */
                    ret = BRAP_MIXER_P_GetDefaultSettings(&sMixerSettings);
                    if(BERR_SUCCESS != ret)
                    {   
                        BDBG_ERR(("Mixer GetDefaultSettings error = %d", ret));
                        ret = BERR_TRACE(ret); 
                        goto close_mixer;
                    }

                    /* Modify the settings */
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        sMixerSettings.uiMixerInput[l] = 
                            sTempMixerGrant.uiMixerInputId[l];
                        BDBG_MSG ((" sTempMixerGrant.uiMixerInputId[%d]=%d",
                                       l,sTempMixerGrant.uiMixerInputId[l]));
                    }
                    
                    /* Open mixer handle */
                    ret = BRAP_MIXER_P_Open(pPath->hFmm,
                                            &(pPath->sMixer[i][j][k].hMixer),
                                            sTempMixerGrant.uiMixerId,
                                            sTempMixerGrant.uiDpId,
                                            &sMixerSettings);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("Mixer Open returned error = %d", ret));
                        ret = BERR_TRACE(ret);
                        goto close_mixer;
                    }
                    BDBG_MSG(("Mixer %d of DP Block %d opened",
                             sTempMixerGrant.uiMixerId,sTempMixerGrant.uiDpId));
                }/* if */
            }/* for k */
        }/* for j */
    }/* for i */
    /* Mixer open done */

#if (BRAP_7550_FAMILY !=1)
    /* 5. Prepare settings and open DstCh */
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(pRsrcGrnt->uiDstChId[i] != BRAP_RM_P_INVALID_INDEX)
        {
            /* Open DstCh handle */
            ret = BRAP_DSTCH_P_Open( pPath->hFmm,
                                    &(pPath->sDstCh[i].hDstCh),
                                    pRsrcGrnt->uiDstChId[i],
                                    &sDstChSettings);
            if(BERR_SUCCESS != ret)
            { ret = BERR_TRACE(ret);goto close_dstch;}
            BDBG_MSG(("Destination Channel %d opened",pRsrcGrnt->uiDstChId[i]));
        }
    }/* for i */
    /* DstCh Open Done */

    /* 6. Open Capport */
    for(i=0;i<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(pRsrcGrnt->sCapPortGrnt[i][j].eCapPort != BRAP_CapInputPort_eMax)
            {
                /* Open Capture Port */
                ret = BRAP_CAPPORT_P_Open(pPath->hFmm, 
                                          &(pPath->sCapPort[i][j].hCapPort),
                                          pRsrcGrnt->sCapPortGrnt[i][j].eCapPort,
                                          &sCapPortSettings);
                if(BERR_SUCCESS != ret)
                { ret = BERR_TRACE(ret);goto close_capport;}
                BDBG_MSG(("Capture Port %d opened",pRsrcGrnt->sCapPortGrnt[i][j].eCapPort));
            }
        }
    }
#endif    
#if BRAP_P_EQUALIZER    
    /* 7. Open SRC Equalizers */
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                sTempSrcEqGrant = pRsrcGrnt->sSrcEqGrant[j][k][l];
                if((sTempSrcEqGrant.uiSrcBlkId != BRAP_RM_P_INVALID_INDEX)&&
                   (sTempSrcEqGrant.uiSrcId != BRAP_RM_P_INVALID_INDEX))
                {
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0;
                    
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end_fmm_open;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                       
                    /* Open SRC handle */
                    ret = BRAP_SRC_P_Open(pPath->hFmm,
                                          &(pPath->sSrcEq[k][l].hSrcEq[j]),
                                          sTempSrcEqGrant.uiSrcId,
                                          sTempSrcEqGrant.uiSrcBlkId,
                                          &sSrcSettings);
                    if(BERR_SUCCESS != ret)
                    {  ret = BERR_TRACE(ret);goto close_srceq;}
                    
                    BDBG_MSG(("SRC %d of SRC Block %d opened for Equalizer",
                           sTempSrcEqGrant.uiSrcId,sTempSrcEqGrant.uiSrcBlkId));                                              

                    /* Find the destination on this path having Equalizer and 
                       update the allocated SRC handle in that Equalizer handle
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        /* Currently Equalizer is supported for output ports only */
                        if((NULL == pPath->pDstDetails[i]) ||
                           (BRAP_AudioDst_eOutputPort != pPath->pDstDetails[i]->eAudioDst))
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,pPath->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if (pPvtDstDetails->hEqualizer != NULL)
                        {
                            pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth] = pPath->sSrcEq[k][l].hSrcEq[j];
                            
                            BDBG_MSG(("SRCEQ_Open: Populating hSrcEq[%d][%d][%d][%d]=0x%x"
                                " for hEqualizer=0x%x on output port %d", 
                                j,k,l,uiPth, pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth], 
                                pPvtDstDetails->hEqualizer, pPvtDstDetails->sExtDstDetails.uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]));
                            break;
                        }
                    } /* for i */  
                    if(i == BRAP_P_MAX_DST_PER_RAPCH)
                    {
                        BDBG_ERR(("None of the Destinations on this path have Equalizer,"
                            "but Equalizer allocation has been requested"));
                         ret = BERR_NOT_SUPPORTED;
                         goto close_srceq;
                    }
                }
            }/* for l */
        }/* for k */
    }/* for j */
    /* SRC-EQ open done */
#endif    

    /* If success, exit from this function */
    if(BERR_SUCCESS == ret)
    {
        goto end_fmm_open;
    }    
    
#if BRAP_P_EQUALIZER
close_srceq:    
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_srceq"));        
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                if(NULL != pPath->sSrcEq[k][l].hSrcEq[j])
                {
                    ret1 = BRAP_SRC_P_Close(pPath->sSrcEq[k][l].hSrcEq[j]);
                    if (ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR (("BRAP_P_OpenFmmModuleHandles: call to"
                          " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                        ret1 = BERR_TRACE (ret1);
                    }
		            BRAP_P_InitSrcEqHandleInfo(&(pPath->sSrcEq[k][l]), j);
                    BDBG_MSG(("SRC closed"));
                }
            }/* for l */
        }/* for k */
    }/* for j */
#endif
#if (BRAP_7550_FAMILY !=1)   
close_capport:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_capport"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(NULL != pPath->sCapPort[i][j].hCapPort)
            {
                ret1 = BRAP_CAPPORT_P_Close(pPath->sCapPort[i][j].hCapPort);
                if (ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_CAPPORT_P_Close() failed. Ignoring error!!!!!"));
                    ret1 = BERR_TRACE (ret1);
                }
    	     BRAP_P_InitCapPortHandleInfo(&(pPath->sCapPort[i][j]));
                BDBG_MSG(("CapPort closed"));
            }
        }
    }/* for i */
    
close_dstch:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_dstch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sDstCh[i].hDstCh)
        {
            ret1 = BRAP_DSTCH_P_Close(pPath->sDstCh[i].hDstCh);
            if (ret1 != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                  " BRAP_DSTCH_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE (ret1);
            }
	     BRAP_P_InitDstChHandleInfo(&(pPath->sDstCh[i]));
            BDBG_MSG(("DstCh closed"));
        }
    }/* for i */
#endif                
    
close_mixer:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_mixer"));        
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                if(NULL != pPath->sMixer[i][j][k].hMixer)
                {
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        if(pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].
                                    uiMixerInputId[l] != BRAP_RM_P_INVALID_INDEX)
                        {
                            uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].uiMixerInputId[l];

                            ret = BRAP_MIXER_P_Close(pPath->sMixer[i][j][k].hMixer, uiMixInId);
                            if (ret != BERR_SUCCESS)
                            {
                                BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                                  " BRAP_MIXER_P_Close() failed. Ignoring error!!!!!"));
                                ret = BERR_TRACE (ret);
                            }
                            BDBG_MSG(("Mixer input %d closed", uiMixInId));
                        }
                    }/* for l */
                    BRAP_P_InitMixerHandleInfo(&(pPath->sMixer[i][j][k]));   
		        }
            }/* for k */
        }/* for j */
    }/* for i */

#if (BRAP_7550_FAMILY !=1)
close_src:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_src"));        
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    if(NULL != pPath->sSrc[i][k][l].hSrc[j])
                    {
                        ret1 = BRAP_SRC_P_Close(pPath->sSrc[i][k][l].hSrc[j]);
                        if (ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                              " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                            ret1 = BERR_TRACE (ret1);
                        }
			   BRAP_P_InitSrcHandleInfo(&(pPath->sSrc[i][k][l]), j);
                        BDBG_MSG(("SRC closed"));
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
#endif

close_srcch:
    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_srcch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sSrcCh[i].hSrcCh)
        {
            ret1 = BRAP_SRCCH_P_Close(pPath->sSrcCh[i].hSrcCh);
            if (ret1 != BERR_SUCCESS)
            {
                BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                  " BRAP_SRCCH_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE (ret1);
            }
	     BRAP_P_InitSrcChHandleInfo(&(pPath->sSrcCh[i]));
            BDBG_MSG(("SrcCh closed"));
        }
    }/* for i */

close_rbuf:
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
			/* Returning the Rbuf to global pool */
			BRAP_P_ReturnRBufToPool(hRapCh,pPath,0,0,0);
#endif

    BDBG_ERR(("BRAP_P_OpenFmmModuleHandles: Came in close_rbuf"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        if((pRsrcGrnt->uiRbufId[i] != BRAP_RM_P_INVALID_INDEX) &&
           (pPath->hRBuf[i] != NULL))
        {
            ret1 = BRAP_RBUF_P_Close(pPath->hRBuf[i]);
            if(BERR_SUCCESS != ret1)
            {
                BDBG_ERR (("BRAP_RBUF_P_Close() failed. Ignoring error!!!!!"));
                ret1 = BERR_TRACE(ret1);
            }
            pPath->hRBuf[i] = NULL;
            BDBG_MSG(("Ring buffer %d closed",pRsrcGrnt->uiRbufId[i]));
        }
    }/* for i */

end_fmm_open:
    BDBG_LEAVE(BRAP_P_OpenFmmModuleHandles);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that closes FMM module handles for a particular path.
    Note: Output and SpdifFm module handles are not closed here.
**************************************************************************/
BERR_Code BRAP_P_CloseFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    unsigned int            i = 0,j=0,k=0,l=0;
    unsigned int            uiMixInId = 0;
    bool                    bRbufAllocated = false;
    
    BDBG_ENTER(BRAP_P_CloseFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    
    pPath = hRapCh->pPath[uiPth];

#if BRAP_P_EQUALIZER
    /* close_srceq */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_srceq"));        
    for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
    {
        for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
        {
            for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
            {
                if(NULL != pPath->sSrcEq[k][l].hSrcEq[j])
                {
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0;
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                     
                    
                    /* Find if any destination on this path is having Equalizer and 
                       invalidate the SRC handle stored in that Equalizer handle
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if((NULL == pPath->pDstDetails[i]) ||
                           (BRAP_AudioDst_eOutputPort != pPath->pDstDetails[i]->eAudioDst))
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,pPath->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if (pPvtDstDetails->hEqualizer != NULL)
                        {
                            BDBG_MSG(("SRCEQ_Close: Invalidating hSrcEq[%d][%d][%d][%d]=0x%x "
                                "of hEqualizer=0x%x on output port %d", 
                                j,k,l,uiPth, pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth], 
                                pPvtDstDetails->hEqualizer, pPvtDstDetails->sExtDstDetails.uDstDetails.
                                sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]));

                            pPvtDstDetails->hEqualizer->hSrcEq[j][k][l][uiPth] = NULL;
                            break;
                        }
                    }
                    
                    ret = BRAP_SRC_P_Close(pPath->sSrcEq[k][l].hSrcEq[j]);
                    if (ret != BERR_SUCCESS)
                    {
                        BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                          " BRAP_SRC_P_Close() for Equalizer failed. Ignoring error!!!!!"));
                        ret = BERR_TRACE (ret);
                    }
			        BRAP_P_InitSrcEqHandleInfo(&(pPath->sSrcEq[k][l]), j);
                    BDBG_MSG(("SRC for Equalizer closed"));
                }
            }/* for l */
        }/* for k */
    }/* for j */
#endif

    /* close_mixer: */
    for (i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_PARALLEL_PATHS;k++)
            {
                if(NULL != pPath->sMixer[i][j][k].hMixer)
                {
                    for(l=0;l<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;l++)
                    {
                        if(pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].
                                    uiMixerInputId[l] != BRAP_RM_P_INVALID_INDEX)
                        {
                            uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[i].sMixerGrant[j][k].uiMixerInputId[l];

                            ret = BRAP_MIXER_P_Close(pPath->sMixer[i][j][k].hMixer, uiMixInId);
                            if (ret != BERR_SUCCESS)
                            {
                                BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                                  " BRAP_MIXER_P_Close() failed. Ignoring error!!!!!"));
                                ret = BERR_TRACE (ret);
                            }
                            BDBG_MSG(("Mixer input %d closed", uiMixInId));
                        }
                    }/* for l */
                    BRAP_P_InitMixerHandleInfo(&(pPath->sMixer[i][j][k]));    
		        }/* if hMixer */
            }/* for k */
        }/* for j */
    }/* for i */

#if (BRAP_7550_FAMILY != 1)
    /* close_src: */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_src"));        
    for(i=0;i<BRAP_RM_P_MAX_MIXING_LEVELS;i++)
    {
        for(j=0;j<BRAP_RM_P_MAX_SRC_IN_CASCADE;j++)
        {
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                for(l=0;l<BRAP_RM_P_MAX_PARALLEL_PATHS;l++)
                {
                    if(NULL != pPath->sSrc[i][k][l].hSrc[j])
                    {
                        ret = BRAP_SRC_P_Close(pPath->sSrc[i][k][l].hSrc[j]);
                        if (ret != BERR_SUCCESS)
                        {
                            BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                              " BRAP_SRC_P_Close() failed. Ignoring error!!!!!"));
                            ret = BERR_TRACE (ret);
                        }
   			   BRAP_P_InitSrcHandleInfo(&(pPath->sSrc[i][k][l]), j);
                        BDBG_MSG(("SRC closed"));
                    }
                }/* for l */
            }/* for k */
        }/* for j */
    }/* for i */
#endif

#if (BRAP_7405_FAMILY == 1)            		
            if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                &&(hRapCh->bOpenTimeWrToRbuf == true)
                &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
{
    /* close_srcch: */
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_srcch"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if(NULL != pPath->sSrcCh[i].hSrcCh)
        {
            if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
                &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
            {
                ret = BRAP_SRCCH_P_Close(pPath->sSrcCh[i].hSrcCh);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to"
                      " BRAP_SRCCH_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
            }
            BRAP_P_InitSrcChHandleInfo(&(pPath->sSrcCh[i]));
            BDBG_MSG(("SrcCh closed"));
        }
    }/* for i */
}
	for(j=0; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
	{
        if(NULL == pPath->pDstDetails[j])
        {
            continue;
        }
		if(BRAP_AudioDst_eRingBuffer == pPath->pDstDetails[j]->eAudioDst)
		{
		    bRbufAllocated = true;
            break;
		}
	}

    /* If RBUF & DSTCH are allocated during AddDestination, don't close them here. */
    if(!((true == bRbufAllocated)&&(pPath->eUsgPath == BRAP_P_UsgPath_eCapture)&&(pPath->uiSelfPathArrIdx !=0)))
    {
#if (BRAP_7405_FAMILY == 1)            		
        if(!((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
            &&(hRapCh->bOpenTimeWrToRbuf == true)
            &&(hRapCh->pPath[uiPth]->eUsgPath == BRAP_P_UsgPath_eDecodePcm)))
#endif  
        {    
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)
        if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
            &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
        {
        	BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in to return Rbuf to Pool"
             "eUsgPath = %d", pPath->eUsgPath));   
    	    BRAP_P_ReturnRBufToPool(hRapCh,pPath,0,0,0);
        }
#endif

        /* close_rbuf: */
        BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_rbuf"));        
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
        {
            if(pPath->hRBuf[i] != NULL)
            {
                if((pPath->eUsgPath != BRAP_P_UsgPath_eMixPath)
                    &&(pPath->eUsgPath != BRAP_P_UsgPath_eSharedPP))
                {                
                    ret = BRAP_RBUF_P_Close(pPath->hRBuf[i]);
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR (("BRAP_P_CloseFmmModuleHandles: call to "
                            "BRAP_RBUF_P_Close() failed. Ignoring error!!!!!"));
                        ret = BERR_TRACE(ret);
                    }
                }
                pPath->hRBuf[i] = NULL;
            }
        }/* for i */
        }
#if (BRAP_7550_FAMILY !=1)   
        BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_dstch"));        
        for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
        {
            if(NULL != pPath->sDstCh[i].hDstCh)
            {
                ret = BRAP_DSTCH_P_Close(pPath->sDstCh[i].hDstCh);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_DSTCH_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
                BRAP_P_InitDstChHandleInfo(&(pPath->sDstCh[i]));
                BDBG_MSG(("DstCh closed"));
            }
        }/* for i */
#endif
    }

 #if (BRAP_7550_FAMILY !=1)   
    BDBG_MSG(("BRAP_P_CloseFmmModuleHandles: Came in close_capport"));        
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        for(j=0;j<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;j++)
        {
            if(NULL != pPath->sCapPort[i][j].hCapPort)
            {
                ret = BRAP_CAPPORT_P_Close(pPath->sCapPort[i][j].hCapPort);
                if (ret != BERR_SUCCESS)
                {
                    BDBG_ERR (("BRAP_P_OpenOpPathFmmModules: call to"
                      " BRAP_CAPPORT_P_Close() failed. Ignoring error!!!!!"));
                    ret = BERR_TRACE (ret);
                }
                BRAP_P_InitCapPortHandleInfo(&(pPath->sCapPort[i][j]));
                BDBG_MSG(("CapPort closed"));
            }
        }
    }/* for i */
#endif
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_CloseFmmModuleHandles);    
    return ret;
}

/**************************************************************************
Summary:
    Private function that starts FMM module handles for a particular path.
    All the params required to start a resource is also prepared here.
**************************************************************************/
BERR_Code BRAP_P_StartFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
  	const BRAP_ChannelParams	*pAudioParams,  /* [in] Audio params passed 
	                                               during channel start time */
    unsigned int                uiPth,          /* [in] Path id */
    bool                        bCompress       /* [in] TRUE: if these resources
                                                   carry compressed data
                                                   FALSE : if PCM data */
    )
{
    BERR_Code               ret = BERR_SUCCESS, ret1 = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  eChP = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE,uiPrp = BRAP_INVALID_VALUE;
    unsigned int            uiCsc = BRAP_INVALID_VALUE; 
    unsigned int            uiOutputBitsPerSample = 0;
    void                    *pOpParams = NULL;
    BRAP_Handle             hRap = NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    BRAP_SPDIFFM_P_Handle   hSpdifFm = NULL;
    BRAP_SPDIFFM_P_Params   sSpdifFmParams;
    
#if (BRAP_7550_FAMILY !=1)
    unsigned int            uiOutputSampleRate=0;
    BRAP_SRC_P_Handle       hSrc = NULL;
    BRAP_SRC_P_Params       sSrcParams;
    BRAP_SRC_P_SrcInfo      sSrcInfo; 
	BRAP_DSTCH_P_Handle     hDstCh = NULL;
    BRAP_DSTCH_P_Params     sDstChParams;
    BRAP_CAPPORT_P_Handle   hCapPort = NULL;
    BRAP_CAPPORT_P_Params   sCapPortParams;    
#endif

    BRAP_OutputPortConfig   *pOpConfig = NULL;
    BRAP_RBUF_P_Handle      hRBuf = NULL;
    BRAP_RBUF_P_Params		sRBufParams;
    unsigned int            uiCh = BRAP_INVALID_VALUE;
    BRAP_SRCCH_P_Handle     hSrcCh = NULL;
    BRAP_SRCCH_P_Params     sSrcChParams;
    unsigned int            uiSR = 0;
    unsigned int            uiGrpId = BRAP_INVALID_VALUE;
    unsigned int            uiSRCGrpId[BRAP_RM_P_MAX_SRC_IN_CASCADE] = 
                                    {BRAP_INVALID_VALUE, BRAP_INVALID_VALUE};
    bool                    bFirst = true;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    BRAP_MIXER_P_Params     sMixerParams;
    BRAP_P_MixingLevelProp  *pMixingLevel = NULL;
    unsigned int            i = 0;
    BRAP_RM_P_MixerGrant    *pMixerGrant = NULL;
    unsigned int            uiMixInId = 0;
    BRAP_OP_P_SpdifParams	sSpdifParams;
    BRAP_OP_P_I2sParams		sI2sParams;
    BRAP_OP_P_DacParams	    sDacParams;
    BRAP_OP_P_MaiParams     sMaiParams;
    uint32_t                ui32FciId = 0;
    unsigned int            uiI2sInGrp = 0;
    bool                    bLoopBack=false;
	uint32_t				ui32RegMask = 0;
	uint32_t				ui32RegVal = 0;    
	uint32_t                uiTimeOutCtr=0;
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    bool                    bMulPPEnabled = false;
#endif
    BRAP_P_DstDetails       *pPvtDstDetails =NULL;

#if (BRAP_7405_FAMILY ==1) && (BRAP_7550_FAMILY !=1)
    unsigned int            uiBlkId =0, uiBlkOffset =0; 
#endif
#if ((BRAP_3548_FAMILY ==1) || (BRAP_7405_FAMILY ==1))
    bool                    bPrimary[BRAP_MAX_ASSOCIATED_GROUPS] = {false,false,false,false};
    BRAP_ChannelHandle      hStartedChannel[BRAP_MAX_ASSOCIATED_GROUPS] = {NULL,NULL,NULL,NULL};
    unsigned int            uiAssocId =0,j=0;    
    bool                    bBreakLoop =false;
#endif
    bool                    bProgramOutputClock = false;
    BRAP_OP_P_Handle hMaiOp=NULL;
    bool    bAdaptiveRateEnable=false;



    BDBG_ENTER(BRAP_P_StartFmmModuleHandles);
     /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pAudioParams);
    BDBG_ASSERT(uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    
    hRap = hRapCh->hRap;
    pPath = hRapCh->pPath[uiPth];

    BDBG_MSG(("Entering BRAP_P_StartFmmModuleHandles"));
    
#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    /* Find if MulPP is added */
    bMulPPEnabled = false;
#endif
    BDBG_MSG(("pPath = %d",pPath->eUsgPath));

    /* Start all outputs along with corresponding spdifFm */
    BDBG_MSG(("Starting Outputs"));
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            BDBG_MSG(("uiPp = %d, eChPair = %d", uiPp, eChPair));
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            bProgramOutputClock = false;
            if(hOp != NULL)
            {
                if(true == hRap->bOpSettingsValid[hOp->eOutputPort])
                {
                    pOpConfig = &(hRap->sOutputSettings[hOp->eOutputPort]);
                    uiOutputBitsPerSample = pOpConfig->uiOutputBitsPerSample;
                }
                else
                {
                    BDBG_ASSERT(0);
                }

                /* Form the Output Params */
                if ( (BRAP_P_Rsrc_eMixer == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType) ||
					 (BRAP_P_Rsrc_eSrcCh == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType) ||
					 (BRAP_P_Rsrc_eSrcEq == pPath->sOp[eChPair][uiPp].sOpInLink.eRsrcType)
				   )
                {
                    ret = BRAP_P_PrepareFciId(hRapCh->pPath[uiPth],
                                              &(pPath->sOp[eChPair][uiPp].sOpInLink),
                                              &ui32FciId,BRAP_INVALID_VALUE,false);
                    if(ret != BERR_SUCCESS){return BERR_TRACE(ret);}
                }
                else if((BRAP_OutputPort_eI2s5 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s6 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s7 == hOp->eOutputPort)||
                        (BRAP_OutputPort_eI2s8 == hOp->eOutputPort))
                {
                    /* Do Nothing */
                }
                else
                {
                    /* BDBG_ASSERT(0); */
                }
                
            	/* Output block params */
            	switch(hOp->eOutputPort)
            	{
            		case BRAP_OutputPort_eSpdif:
              		case BRAP_OutputPort_eSpdif1:
                        BRAP_OP_P_GetDefaultParams(hOp->eOutputPort, 
                            (void *)&sSpdifParams);
#if(BRAP_7405_FAMILY == 1)
            			sSpdifParams.eTimebase = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sSpdifParams.eTimebase = pAudioParams->eTimebase;
#endif
                        sSpdifParams.ui32InputFciId = ui32FciId;
                        sSpdifParams.bHbrEnable = pOpConfig->bHbrEnable;
            			pOpParams = &sSpdifParams;
            			break;
            		case BRAP_OutputPort_eI2s0:
            		case BRAP_OutputPort_eI2s1:
            		case BRAP_OutputPort_eI2s2:
            		case BRAP_OutputPort_eI2s3:
            		case BRAP_OutputPort_eI2s4:      
            		case BRAP_OutputPort_eI2s5:
            		case BRAP_OutputPort_eI2s6:
            		case BRAP_OutputPort_eI2s7:
            		case BRAP_OutputPort_eI2s8:      
                        BRAP_OP_P_GetDefaultParams(hOp->eOutputPort, (void *)&sI2sParams);               
#if(BRAP_7405_FAMILY == 1)
            			sI2sParams.eTimebase = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sI2sParams.eTimebase = pAudioParams->eTimebase;
#endif
            			sI2sParams.uiBitsPerSample = uiOutputBitsPerSample;
                        sI2sParams.ui32InputFciId = ui32FciId;

                        /* For a particular parallel path, check all the channel pairs to 
                           find number of I2s in group */
                        uiPrp = pPath->sOp[eChPair][uiPp].sOpSelfLink.uiPrlPth;
                        for(eChP = 0, uiI2sInGrp=0; eChP < BRAP_OutputChannelPair_eMax; eChP++)
                        {
                            if((hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp != NULL) &&
                               ((hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s0) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s1) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s2) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s3) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s5) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s6) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s7) ||
                               (hRapCh->pPath[uiPth]->sOp[eChP][uiPrp].hOp->eOutputPort ==
                                    BRAP_OutputPort_eI2s8))                        
                               )
                            {
                                uiI2sInGrp++;
                            }
                        }/* for eChP */
    
                        /* If uiI2sInGrp is more than 1, bMulti should be set to true */
                        sI2sParams.bIsMulti = (uiI2sInGrp > 1) ? true : false;

                        /* bHbrEnable */
                        sI2sParams.bHbrEnable = pOpConfig->bHbrEnable;
                        
                        /* I2sParams prepared */
            			pOpParams = &sI2sParams;
            			break;
            		case BRAP_OutputPort_eDac0:
                    case BRAP_OutputPort_eDac1:
                    case BRAP_OutputPort_eDac2:                      
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sDacParams); 
#if(BRAP_7405_FAMILY == 1)
            			sDacParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
            			sDacParams.eTimebase = pAudioParams->eTimebase;
#endif
                        /*check if BTSC PP added on DAC0 */
                        for(i=0;i<BRAP_MAX_PP_SUPPORTED;i++)
                        {
                            if((hRap->hAudioProcessingStageHandle[i]!=NULL)&&
                                (hRap->hAudioProcessingStageHandle[i]->sProcessingStageSettings.eAudioProcessing == BRAP_ProcessingType_eBtsc))
                            {
                                for(j=0;j<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;j++)
                                {                
                                    if((hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]!=NULL)&&
                                       (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails.\
                                        eAudioDst == BRAP_AudioDst_eOutputPort)&&
                                       (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails. \
                                        uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == BRAP_OutputPort_eDac0))
                                    {
                                        sDacParams.bBtscOnDAC = true;
                                    }
                                }
                            }
                        }
                        sDacParams.ui32InputFciId = ui32FciId;
            			pOpParams = &sDacParams;		
            			break;
                    case BRAP_OutputPort_eMai:
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sMaiParams); 
                        sMaiParams.uiSampleWidth = uiOutputBitsPerSample;
#if(BRAP_7405_FAMILY == 1)
                        sMaiParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
                        sMaiParams.eTimebase = pAudioParams->eTimebase;
#endif
                        sMaiParams.ui32InputFciId = ui32FciId;
                        sMaiParams.bHbrEnable = pOpConfig->bHbrEnable;
                        pOpParams = &sMaiParams;
                        break;
                    case BRAP_OutputPort_eMaiMulti0:                        
                    case BRAP_OutputPort_eMaiMulti1:                        
                    case BRAP_OutputPort_eMaiMulti2:                        
                    case BRAP_OutputPort_eMaiMulti3:
                        BRAP_OP_P_GetDefaultParams (hOp->eOutputPort, (void *)&sMaiParams); 
                        sMaiParams.ui32InputFciId = ui32FciId;                        
                        pOpParams = &sMaiParams;                            

                        break;
            		default:
            			BDBG_ERR(("BRAP_P_FormOpParams: Output port type %d not supported", 
            					  hOp->eOutputPort));
            			ret = BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);
            	}
                if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}


                /* Start corresponding spdifFm (if any) */
                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    /* Form spdifFm params */
               		ret = BRAP_SPDIFFM_P_GetDefaultParams (&sSpdifFmParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}

                    /* Note: Unlike 7400, etc. in 7440 we always set 
                       bSpdifFormat to true. If required, this can be exposed
                       to the user */
    		        sSpdifFmParams.sExtParams.bSpdifFormat = true; 
            		sSpdifFmParams.bCompressed = pOpConfig->bCompressed;

                    

                    sSpdifFmParams.uiCpToggleRate = pOpConfig->uiCpToggleRate;

    	        	sSpdifFmParams.bSeparateLRChanNum = pOpConfig->sSpdifChanStatusParams.bSeparateLRChanNum;
                    sSpdifFmParams.bUseSpdifPackedChanStatusBits = pOpConfig->bUseSpdifPackedChanStatusBits;
                    sSpdifFmParams.sSpdifPackedChanStatusBits = pOpConfig->sSpdifPackedChanStatusBits;
                    sSpdifFmParams.sChanStatusParams = pOpConfig->sSpdifChanStatusParams;

#if (BRAP_3548_FAMILY != 1) /* DDP Passthru on 3548 does not go through Mai */                    
                    if ((BRAP_P_UsgPath_eDecodeCompress== pPath->eUsgPath)
                        &&(BRAP_DSPCHN_AudioType_eAc3Plus==pAudioParams->sDspChParams.eType)
                        &&(BRAP_DSPCHN_DecodeMode_ePassThru==pAudioParams->sDspChParams.eDecodeMode))
                    {
                        sSpdifFmParams.bUseHwCBit = true;
                    }
                    else
#endif /* 3548_family != 1 */                        
                    {
                        sSpdifFmParams.bUseHwCBit = false;
                    }
                    BDBG_MSG(("Stream > %d, bUseHwCBit > %d", hSpdifFm->uiStreamIndex, sSpdifFmParams.bUseHwCBit));

                    /* TODO: - Should do this after SPDIF connect */
                    if ((BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource)  &&
                        ((BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort) ||
                         (BRAP_CapInputPort_eHdmi  == pAudioParams->eCapInputPort)))
                    {
            	    	ret = BRAP_P_GetBurstRepetitionPeriodForAlgo(
            	                        BAVC_StreamType_ePes,
            	                        BRAP_DSPCHN_AudioType_ePcm,
            	                        &sSpdifFmParams.eBurstRepPeriod);
                    }
                    else 
                    {
                        /* TODO: - Should do this after SPDIF connect */
                        
            	    	ret = BRAP_P_GetBurstRepetitionPeriodForAlgo(
            	                        pAudioParams->sDspChParams.eStreamType,
            	                        pAudioParams->sDspChParams.eType,
            	                        &sSpdifFmParams.eBurstRepPeriod);
                    }
        	    	if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                      sSpdifFmParams.eSamplingRate = pOpConfig->eOutputSR;
                    /* Start SpdifFm handle */
               		ret = BRAP_SPDIFFM_P_Start(hRapCh, hSpdifFm, &sSpdifFmParams);
        	        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}

        	        BDBG_MSG(("Spdiffm %d - stream %d started", 
        			            hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex));
#if(BRAP_7405_FAMILY == 1)
                    if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                    {
                        BRAP_OP_P_Handle hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;                
                        uint32_t ui32RegValue=0;
                        if((hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eI2s0)
                        ||(hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0)
                        ||(sSpdifFmParams.bUseHwCBit ==true))
                            
                        {
                            ui32RegValue = BRAP_Read32 (hSpdifFm->hRegister, 
                                    BCHP_AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0 + hSpdifFm->ui32Offset);
                            ui32RegValue &= ~( BCHP_MASK (AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0, STREAM_ENA) );    
                            ui32RegValue |= (BCHP_FIELD_ENUM (AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0, 
                                                              STREAM_ENA, Disable));
                            BRAP_Write32 (hSpdifFm->hRegister, 
                                          hSpdifFm->ui32Offset + BCHP_AUD_FMM_MS_CTRL_FW_STREAM_CTRL_0,
                                          ui32RegValue);                         
                        }
                    }
#endif                       
                }/* hSpdifFm */


                /* Start Output handle */
           		ret = BRAP_OP_P_Start(hOp, pOpParams);
                if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                BDBG_MSG(("Output port type %d started", hOp->eOutputPort));
                /* Special handling for hMaiOp tapping data from another Op */
                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;
                    BRAP_OP_P_GetDefaultParams (hMaiOp->eOutputPort, (void *)&sMaiParams); 
                    sMaiParams.uiSampleWidth = uiOutputBitsPerSample;
#if(BRAP_7405_FAMILY == 1)
                    sMaiParams.eTimebase =hRapCh->hRap->sOutputSettings[hOp->eOutputPort].eOutputTimebase;
#else
                    sMaiParams.eTimebase = pAudioParams->eTimebase;
#endif
#if(BRAP_7405_FAMILY == 1)
                    if((hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eI2s0)
                        ||(hMaiOp->uOpSettings.sMai.sExtSettings.eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0))
                    {
                        sMaiParams.ui32InputFciId = 0x3FF;
                    }
                    else
#endif                        
                    {
                    sMaiParams.ui32InputFciId = ui32FciId;
                    }
                    sMaiParams.bHbrEnable = pOpConfig->bHbrEnable;
                    pOpParams = &sMaiParams;
               		ret = BRAP_OP_P_Start(hMaiOp, pOpParams);
                    if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_op;}
                    BDBG_MSG(("Output port type %d started", hMaiOp->eOutputPort));
                }

                /* Program the Output PLL for PCM Play Back Channel */


                /* 
                    Identify when output clock should be programmed by PI 
                    In other cases it is the Firmware that programs this
                */
                ret = BRAP_P_GetStartedChannel(hRapCh,bPrimary,hStartedChannel);

                if(BERR_SUCCESS != ret)
                {
                    return BERR_TRACE(ret);
                }        
                bBreakLoop =false;
                for(i=0; i < BRAP_MAX_ASSOCIATED_GROUPS; i++)
                {
                    for(j=0; j < BRAP_MAX_ASSOCIATED_GROUPS; j++)
                    {
                        if(hRap->sAssociatedCh[i].sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[0] == hOp->eOutputPort)
                        {
                            uiAssocId = i;
                            bBreakLoop =true; 
                            break;
                        }
                    }
                    if(bBreakLoop)
                        break;
                }

                if ( (NULL == hStartedChannel[uiAssocId]) ||
                     ((BRAP_ChannelType_eDecode == hStartedChannel[uiAssocId]->eChannelType)
                         &&(hStartedChannel[uiAssocId]->bGateOpened == false))
                    ||((BRAP_ChannelType_eDecode != hStartedChannel[uiAssocId]->eChannelType)
                        &&(BRAP_ChannelType_eDecode != hRapCh->eChannelType))
                   )
                {
                    bProgramOutputClock = true;
                }
#if (BRAP_3548_FAMILY ==1)
                if ( (hStartedChannel[uiAssocId]) &&
                     (BRAP_ChannelType_ePcmCapture == hStartedChannel[uiAssocId]->eChannelType)
                   )
                {
                    bProgramOutputClock = false;
                }

                else if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                          (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                          (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                          ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                            (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                          )
                        )
                {
                    bProgramOutputClock = true;
                }

#endif
                BDBG_MSG (("The bProgramOutputClock = %d",bProgramOutputClock));                    
                if (true == bProgramOutputClock)
                {
                    /* If there are no other started channel in the Association 
                      or if the started channel is not a decode or capture
                      then we need to program the output ourselves */

	                ret = BRAP_OP_P_ProgramOutputClock(
                            hRapCh,
                            hOp->eOutputPort,
                            pOpConfig->eOutputSR
                           );
                    
	                if(BERR_SUCCESS != ret)
	                {
	                    BDBG_ERR(("BRAP_P_StartFmmModuleHandles:BRAP_OP_P_ProgramOutputClock"
	                               "returned error"));
	                    return BERR_TRACE(ret);
	                }

#if (BRAP_7550_FAMILY != 1)                    
                        if((NULL != hStartedChannel[uiAssocId])
                            &&(bFirst == true))
                        {
                            BRAP_P_ConvertSR(pOpConfig->eOutputSR,&uiOutputSampleRate);
                            BKNI_EnterCriticalSection();
                            BRAP_P_ConfigureAssociatedChannelsSrc_isr(hRapCh,uiOutputSampleRate);
                            BKNI_LeaveCriticalSection();                            
                            bFirst = false;
                        }                   
#endif                        
                } /*NULL == hStartedChannel */
            }/* hOp */
        }/* for eChPair */
    }/* for uiPp */

    bFirst = true;
#if BRAP_P_EQUALIZER
    /* Starting SRC - Equalizers */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        /* uiSRCGrpId[] is used to hold the group id of the SRCs for 
           a particular level and parallel path. Note: Different SRCs
           in same level, same parallel path but different channel pairs
           (0-3) form a group of SRCs */
        for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
        {
            uiSRCGrpId[uiCsc] = BRAP_INVALID_VALUE;
        }

        /* uiGrpId is used here for holding group id for mixers. Same logic
           as above for SRCs */ 
        uiGrpId = BRAP_INVALID_VALUE;            
        
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            /* Form SRC param and start SRC */
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];

                if(hSrc != NULL)
                {
                    BRAP_OutputChannelPair  eOpChPair = BRAP_OutputChannelPair_eMax;
                    unsigned int            uiOpPp = BRAP_INVALID_VALUE;
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0, j=0,k=0,l=0;
                    bool                    bSrcCoeffAssigned = false;
                    
                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end_fmm_start;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                      
                    
                    /* Initialize the SRC-EQ to bypass. This will be changed if
                        the output port requests an equalizer */
                    sSrcInfo.uiNumSrc = 1;
                    sSrcInfo.eSrcType[uiCsc] = BRAP_SRC_P_Type_eBypass;

                    /* Get the output port information from Out Link of SRC-EQ */
                    eOpChPair = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].eChnPair;
                    uiOpPp = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].uiPrlPth;

                    /* Find if any destination on this channel is having Equalizer 
                       and update SRC coefficient address if already allocated.
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if(NULL == hRapCh->pDstDetails[i])
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                            (pPath->sOp[eOpChPair][uiOpPp].hOp != NULL) &&                             
                            (pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]
                                == pPath->sOp[eOpChPair][uiOpPp].hOp->eOutputPort)
                          )
                        {
                            if(NULL != pPvtDstDetails->hEqualizer)
                            {
                                sSrcInfo.eSrcType[uiCsc] = BRAP_SRC_P_Type_eIIR;

                                for(j=0; j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
                                {
                                    for(k=0; k<BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
                                    {
                                        for(l=0; l<BRAP_P_MAX_PATHS_IN_A_CHAN; l++)
                                        {                          
                                            if((NULL != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l]) &&
                                               (BRAP_INVALID_VALUE != pPvtDstDetails->hEqualizer->
                                                        hSrcEq[uiCsc][j][k][l]->uiCoeffAddr))
                                            {
                                                hSrc->uiCoeffAddr = pPvtDstDetails->hEqualizer->
                                                    hSrcEq[uiCsc][j][k][l]->uiCoeffAddr;  
                                                bSrcCoeffAssigned = true;
                                                
                                                BDBG_MSG(("SRCEQ_Start: Populating the already allocated "
                                                    "Coefficient Address. uiCoeffAddr = %d, Index = %d, Block = %d",
                                        hSrc->uiCoeffAddr, hSrc->uiIndex, hSrc->uiBlkId));
                                                break;
                                            }
                                        }
                                        if(true == bSrcCoeffAssigned)
                                            break;
                                    }
                                    if(true == bSrcCoeffAssigned)
                                        break;                            
                                }
                                break;
                            }
                        }
                    } /* for i */

                    if(uiCsc > sSrcInfo.uiNumSrc)
                    {
                        ret = BERR_TRACE(BERR_NOT_SUPPORTED); 
                        goto stop_src_mixer;
                    }

                    if(BRAP_INVALID_VALUE == uiSRCGrpId[uiCsc])
                        uiSRCGrpId[uiCsc] = hSrc->uiIndex;

                    /* Form SRC params */
               		ret = BRAP_SRC_P_GetDefaultParams (&sSrcParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srceq;}

                    sSrcParams.eSrcType = sSrcInfo.eSrcType[uiCsc];
                    sSrcParams.eInputSR = sSrcInfo.eInSR[uiCsc];
                    sSrcParams.eOutputSR = sSrcInfo.eOutSR[uiCsc];
                    sSrcParams.bRampEnable = false;
                    sSrcParams.bPriorityHigh = false;
                    sSrcParams.uiGroupId = uiSRCGrpId[uiCsc];

                    ret = BRAP_P_PrepareFciId(pPath,
                            &(pPath->sSrcEq[eChPair][uiPp].sSrcEqInLink),
                            &(sSrcParams.ui32FciId), uiCsc,false);
                    if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_srceq;}

                    ret = BRAP_SRC_P_Start(hSrc, &sSrcParams);
                    if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srceq;}

    	            BDBG_MSG(("Eq SRC %d in SRC Blk %d started for Equalizer", 
        			            hSrc->uiIndex, hSrc->uiBlkId)); 
                } /* hSrc != NULL */
            }/* for uiCsc */
        }/* for eChPair */
    }/* for uiPp */
#endif

    /* Start Mixers-SRCs in each level */
    BDBG_MSG(("Starting Mixer-SRCs"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            /* uiSRCGrpId[] is used to hold the group id of the SRCs for 
               a particular level and parallel path. Note: Different SRCs
               in same level, same parallel path but different channel pairs
               (0-3) form a group of SRCs */
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                uiSRCGrpId[uiCsc] = BRAP_INVALID_VALUE;
            }

            /* uiGrpId is used here for holding group id for mixers. Same logic
               as above for SRCs */ 
            uiGrpId = BRAP_INVALID_VALUE;            
            
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixingLevel = &(pPath->sMixingLevels[uiLvl]);

#if (BRAP_7550_FAMILY != 1)
                /* Form SRC param and start SRC */
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
        				    /* Init to invalid values */
        				    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
        				    {
        				        sSrcInfo.eSrcType[i] = BRAP_SRC_P_Type_eUnknown;
        				        sSrcInfo.eInSR[i] = BAVC_AudioSamplingRate_eUnknown;
        				        sSrcInfo.eOutSR[i] = BAVC_AudioSamplingRate_eUnknown;
        				    }
                        
    			        if((BRAP_ChannelType_eDecode == hRapCh->eChannelType)&&
                           (BRAP_ChannelSubType_eNone == hRapCh->eChannelSubType))
    			    	{
        				    /* For Settop kind of app */
        				    sSrcInfo.uiNumSrc = 1;
        				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;
    			    	}
                        else if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                            (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort))  
                        {
                            if ( (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) && (0 == uiPth) )
                            {
                                /* ADC IN requires a Down 4 */
                                BDBG_MSG (("SRC needs to be in Down4 for ADC in Capture Path"));
            				    sSrcInfo.uiNumSrc = 1;
            				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eDown4;
                            }
                            else
                            {
                                BDBG_MSG (("SRC needs to be in normal mode for ADC in Decode PCM Path"));                            
            				    sSrcInfo.uiNumSrc = 1;
            				    sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;
                            }
                        }
                        else if ((BRAP_ChannelType_ePcmPlayback== hRapCh->eChannelType)
                                   ||(BRAP_ChannelType_ePcmCapture== hRapCh->eChannelType))
                        {
                            /* Assuming that for PCM playback/Capture we will do only Lint Mode SRC */
                            sSrcInfo.uiNumSrc = 1;
                            if(pMixingLevel->eInputSR != pMixingLevel->eOutputSR)
                                sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eLinInt;
                            else
                                sSrcInfo.eSrcType[0] = BRAP_SRC_P_Type_eBypass;

                            sSrcInfo.eInSR[0] = pMixingLevel->eInputSR;
                            sSrcInfo.eOutSR[0] = pMixingLevel->eOutputSR;                            
                        }
        			    else
    			    	{
                            ret = BRAP_SRC_P_GetRequiredSrc(
                                            &sSrcInfo,
                                            pMixingLevel->eInputSR, 
                                            pMixingLevel->eOutputSR,
                                            bCompress
                                            );                        
                            if(ret!=BERR_SUCCESS)
                            {
                                ret = BERR_TRACE(ret); 
                                goto stop_src_mixer;
                            }

    			    	}

                        if(uiCsc > sSrcInfo.uiNumSrc)
                        {
                            ret = BERR_TRACE(BERR_NOT_SUPPORTED); 
                            goto stop_src_mixer;
                        }

                        if(BRAP_INVALID_VALUE == uiSRCGrpId[uiCsc])
                            uiSRCGrpId[uiCsc] = hSrc->uiIndex;

                        /* Form SRC params */
                   		ret = BRAP_SRC_P_GetDefaultParams (&sSrcParams);
        		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

                        sSrcParams.eSrcType = sSrcInfo.eSrcType[uiCsc];
                        sSrcParams.eInputSR = sSrcInfo.eInSR[uiCsc];
                        sSrcParams.eOutputSR = sSrcInfo.eOutSR[uiCsc];

                        /* Scale ramp enable: If TRUE then scaling is applied to
                           a playback channel during start up. FALSE: other wise.
                           For Compressed data it should be false.*/
                        if ((true == bCompress)||  
                            ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                              (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                              (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                              (0 == uiPth)
                             )||
                            ((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType)))
                        {
	                            sSrcParams.bRampEnable = false;
	                            sSrcParams.bPriorityHigh = false;
                    	}
 	                    else
                    	{
                            sSrcParams.bRampEnable = true;
                            /* Input sampling rate in a level will decide the high
                               or low priority for both the SRCs in cascade */
                            ret = BRAP_P_ConvertSR(pMixingLevel->eOutputSR, &uiSR);
                            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;} 

                            sSrcParams.bPriorityHigh = (uiSR >= 96000) ? true:false;
                    	}

                        sSrcParams.uiGroupId = uiSRCGrpId[uiCsc];
                        ret = BRAP_P_PrepareFciId(pPath,
                                &(pPath->sSrc[uiLvl][eChPair][uiPp].sSrcInLink),
                                &(sSrcParams.ui32FciId), uiCsc,false);
                        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;}

#if (BRAP_7405_FAMILY ==1)
                    if(!((hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                        &&(pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eDecode)))
                    {
                        for(uiBlkId = 0; uiBlkId < BRAP_RM_P_MAX_SRC_BLCK; uiBlkId++)
                        {
#if ( BRAP_RM_P_MAX_SRC_BLCK > 1 )    
                            uiBlkOffset = (BCHP_AUD_FMM_SRC_CTRL1_STRM_ENA - BCHP_AUD_FMM_SRC_CTRL0_STRM_ENA) * uiBlkId;
#endif                    
                            BRAP_Write32(hRapCh->hRegister, (BCHP_AUD_FMM_SRC_CTRL0_RAMP_STEP + uiBlkOffset), hRap->uiSrcRampStepSize);   
                        }
                    }
#endif                    
                        ret = BRAP_SRC_P_Start(hSrc, &sSrcParams);
                        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

        	            BDBG_MSG(("SRC %d in SRC Blk %d started", 
        			            hSrc->uiIndex, hSrc->uiBlkId));                        
                    }
                }/* for uiCsc */
#endif

                /* Form MIXER params and start mixer */
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    if(BRAP_INVALID_VALUE == uiGrpId)
                        uiGrpId = hMixer->uiMixerIndex;

                    /* Form Mixer params */
               		ret = BRAP_MIXER_P_GetDefaultParams(&sMixerParams);
    		        if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}

                    if ((true == bCompress)|| 
                        ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                          (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                          (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                          (0 == uiPth)
                        )||                        
                        ((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
                         ( BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType )))
                    {
                        sMixerParams.bPriorityHigh = false;
                    }
                    else
                    {
                        /* Input sampling rate in a level will decide the high
                           or low priority for both the SRCs in cascade */
                        ret = BRAP_P_ConvertSR(pMixingLevel->eOutputSR, &uiSR);
                        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;} 
                        sMixerParams.bPriorityHigh = (uiSR >= 96000) ? true : false;
                    }
                    
                    
           			sMixerParams.bCompress = bCompress;
                    sMixerParams.uiGroupId = uiGrpId;

                    pMixerGrant = &(pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                        sMixerGrant[eChPair][uiPp]);
                    if(pMixerGrant->uiMixerOutputId[0]!=BRAP_RM_P_INVALID_INDEX)
                    {
                        if(pMixerGrant->uiMixerOutputId[0] == 0)
                        {
                            sMixerParams.bOutputEnable0 = true;
                        }
                        else if (pMixerGrant->uiMixerOutputId[0] == 1)
                        {
                            sMixerParams.bOutputEnable1 = true;
                        }
                    }
                    if(pMixerGrant->uiMixerOutputId[1]!=BRAP_RM_P_INVALID_INDEX)
                    {
                        if(pMixerGrant->uiMixerOutputId[1] == 0)
                        {
                            sMixerParams.bOutputEnable0 = true;
                        }
                        else if (pMixerGrant->uiMixerOutputId[1] == 1)
                        {
                            sMixerParams.bOutputEnable1 = true;
                        }
                    }

                 
                    /* Soft-Limiting should be enabled only if data is uncompressed */
                    sMixerParams.bEnableSoftLimit = (bCompress == false)? 
                                            hRap->sSettings.bEnableSoftLimit : false;


                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixInId = pMixerGrant->uiMixerInputId[i];
                        if(uiMixInId != BRAP_RM_P_INVALID_INDEX)
                        {
                            if(BRAP_P_Rsrc_eMixer ==
                                pPath->sMixer[uiLvl][eChPair][uiPp].
                                sMixerInLink[uiMixInId].eRsrcType)
                            {
                                bLoopBack=true;
                            }
                            BDBG_MSG(("Calling PrepareFciId for Mixer "));
                            ret = BRAP_P_PrepareFciId(pPath,
                                &(pPath->sMixer[uiLvl][eChPair][uiPp].sMixerInLink[uiMixInId]),
                                &(sMixerParams.ui32InputFciId[uiMixInId]), 
                                BRAP_INVALID_VALUE,bLoopBack);
                            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_src_mixer;}
#if (BRAP_7405_FAMILY ==1)
                            if(!((hRapCh->eChannelType == BRAP_ChannelType_eDecode)
                                &&(pAudioParams->sDspChParams.eDecodeMode == BRAP_DSPCHN_DecodeMode_eDecode)))
                            {
                                BRAP_Write32 (hRapCh->hRegister, BCHP_AUD_FMM_DP_CTRL0_VOLUME_RAMP_STEP, hRap->uiMixerRampStepSize);
                            }
#endif                    
                            ret = BRAP_MIXER_P_Start(hMixer, 
                                                    uiMixInId, &sMixerParams);
                            if(ret!=BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_src_mixer;}
            	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d started", 
            			            hMixer->uiMixerIndex, uiMixInId,
            			            hMixer->uiDpIndex));                        
                        }
                    }/* for i */
                }
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
    

/*Restoring Mute status of O/P at Mixer level*/
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                BKNI_EnterCriticalSection();                
                BRAP_OP_P_MuteMixerOfOutput_isr(hRap,hOp->eOutputPort,hOp->hFmm->hRap->bOutputMute[hOp->eOutputPort]);
                BKNI_LeaveCriticalSection();
                

                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    hMaiOp = pPath->sOp[eChPair][uiPp].hMaiOp;
                    BKNI_EnterCriticalSection();                    
                    BRAP_OP_P_MuteMixerOfOutput_isr(hRap,hMaiOp->eOutputPort,hMaiOp->hFmm->hRap->bOutputMute[hMaiOp->eOutputPort]);
                    BKNI_LeaveCriticalSection();                    
                }
            }
        }
    }

    
    /* Start Ring buffers */
    BDBG_MSG(("Starting RBufs"));
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret = BRAP_RBUF_P_GetDefaultParams(&sRBufParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_rbuf;}

            sRBufParams.uiStartWRPoint = hRBuf->sSettings.sExtSettings.uiSize-1;
            sRBufParams.uiStartSize = hRBuf->sSettings.sExtSettings.uiSize;                     

            if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {

                if((pAudioParams->uiStartWRPtrLocation == BRAP_INVALID_VALUE)
                || (pAudioParams->uiStartWRPtrLocation > sRBufParams.uiStartSize -1))
                {
                    sRBufParams.uiStartWRPoint = sRBufParams.uiStartSize - 0x101; 
                }
                else
                {
                    sRBufParams.uiStartWRPoint = pAudioParams->uiStartWRPtrLocation; 
                }
    	    }

            /* TODO: For a CAP channel default sRBufParams will change */
            /* Start the ring buffer */
            ret = BRAP_RBUF_P_Start(hRBuf, &sRBufParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_rbuf;}
            
            BDBG_MSG(("Ring buffer %d started", hRBuf->uiIndex));
        }
    }/* for uiCh */

    /* Programming the application provided volume levels for destination at start time */

                    
    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
    if ( NULL==pPvtDstDetails )
    {
        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        goto stop_rbuf;                
    }
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));  
    
    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        unsigned int            uiAssocId,uiMixerlevel=0;
        if(NULL == hRapCh->pDstDetails[i])
            continue;
        if(hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer)
        {
        BDBG_MSG(("hRapCh->pDstDetails[i]=%x",hRapCh->pDstDetails[i]));
        
        /*Find the audio procsssing for the destination of the row on association network*/
        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            BKNI_Free(pPvtDstDetails);
            goto stop_rbuf;
        }

        /* call BRAP_SetDestinationVolume() only if it is a ringbuffer destination or an output port carrying pcm data */
        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eRingBuffer)||
            ((pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
            (hRap->sOutputSettings[pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]].bCompressed == false)) )
        {
            ret = BRAP_SetDestinationVolume(pPvtDstDetails,pPvtDstDetails->uiLtVolume[BRAP_OutputChannelPair_eLR][uiMixerlevel],
                                                        pPvtDstDetails->uiRtVolume[BRAP_OutputChannelPair_eLR][uiMixerlevel]);
        }
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto stop_rbuf;
        }

        ret = BRAP_SetDestinationMute(pPvtDstDetails,pPvtDstDetails->bMute[BRAP_OutputChannelPair_eLR]);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            goto stop_rbuf;
        }        
    }
    }

    
    /* Start Source Channels */
    BDBG_MSG(("Starting SrcCh"));
    for(eChPair = 0, bFirst = true, uiGrpId = BRAP_INVALID_VALUE; 
        eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
        eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            if(true == bFirst)
            {
                uiGrpId = hSrcCh->uiIndex;
                bFirst = false;
            }
                
            /* Get the default parameters first */
            ret = BRAP_SRCCH_P_GetDefaultParams(&sSrcChParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;} 

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType))
            {
                sSrcChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                
           		if(true == bCompress)
        	    {
        			sSrcChParams.bCompress = true;
        			/* Set bits per sample = 16, as DSP generates 16 bits per sample for compressed data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
        	    }
        		else
                {
        			sSrcChParams.bCompress = false;
        			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                }
                 
            }
            else if (BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                if((BRAP_P_UsgPath_eDecodePcmPostMixing == pPath->eUsgPath) ||
                   (BRAP_P_UsgPath_ePPBranchPostMixing == pPath->eUsgPath))
                {
                    sSrcChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;                
               		if(true == bCompress)
            	    {
            			sSrcChParams.bCompress = true;
            			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
            	    }
            		else
                    {
            			sSrcChParams.bCompress = false;
            			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
            			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
        		    }
                }
                else
                {
                    /* 
                        For PCM Playback channel and non loopback path
                        the parameters from applicatoin are to be used.
                    */
                    sSrcChParams.eBufDataMode = pAudioParams->eBufDataMode;
                    if(pAudioParams->eBufDataMode == BRAP_BufDataMode_eMono)
                    {
                        /* If Mono route to it both Lout and Rout */
                            sSrcChParams.eLRDataCntl = BRAP_SRCCH_P_LRDataControl_L_2_LR;
                    }
        			sSrcChParams.eInputBitsPerSample = pAudioParams->eInputBitsPerSample;
                    
               		if(true == bCompress)
            	    {
            			sSrcChParams.bCompress = true;
            	    }
            		else
                    {
            			sSrcChParams.bCompress = false;
#if (BRAP_UNSIGNED_PCM_SUPPORTED == 1)                    
                        sSrcChParams.bIsSigned = pAudioParams->bIsPcmSigned;
#endif
                    }

                    sSrcChParams.bNotPauseWhenEmpty = pAudioParams->bLoopAroundEn;
                }
            }
            else if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
            {
                sSrcChParams.eBufDataMode = pAudioParams->eBufDataMode;
                if(pAudioParams->eBufDataMode == BRAP_BufDataMode_eMono)
                {
                    /* If Mono route to it both Lout and Rout */
                        sSrcChParams.eLRDataCntl = BRAP_SRCCH_P_LRDataControl_L_2_LR;
                }                
              
#if (BRAP_3548_FAMILY ==1)

           		if(true == bCompress)
        	    {
        			sSrcChParams.bCompress = true;
        			/* Set bits per sample = 16, as DSP generates 16 bits per sample for compressed data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e16;
        	    }
        		else
                {
        			sSrcChParams.bCompress = false;
        			/* Set bits per sample = 32, as DSP generates 32 bits per sample for PCM data */
        			sSrcChParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                }
#else                
                if(true == bCompress)
                {
                    sSrcChParams.bCompress = true;
                }
                else
                {
                    sSrcChParams.bCompress = false;
                }
                sSrcChParams.eInputBitsPerSample = pAudioParams->eInputBitsPerSample;
                sSrcChParams.bNotPauseWhenEmpty = pAudioParams->bLoopAroundEn;           
#if (BRAP_UNSIGNED_PCM_SUPPORTED == 1)                    
                sSrcChParams.bIsSigned = pAudioParams->bIsPcmSigned;
#endif                  
#endif                
            }
            else
                BDBG_ASSERT(0); /* TODO: support for other channel types */



#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
            if(hRapCh->bIndepDelayEnabled == true)
            {
                BDBG_MSG(("pPath->uiMasterpathId =%d , hRapCh->pPath[pPath->uiMasterpathId] = %#x "
                    ,pPath->uiMasterpathId,hRapCh->pPath[pPath->uiMasterpathId]));
                if((pPath->uiMasterpathId != BRAP_INVALID_VALUE)
                    &&(hRapCh->pPath[pPath->uiMasterpathId] != NULL)
                    &&(hRapCh->pPath[pPath->uiMasterpathId]->sSrcCh[eChPair].hSrcCh != NULL))
                {

                
                    if (    (hRapCh->eChannelType == BRAP_ChannelType_eDecode)
#if (BRAP_3548_FAMILY ==1)
                        || (hRapCh->eChannelType == BRAP_ChannelType_ePcmCapture)
#endif
                        )
                    {
                        sSrcChParams.bSharedRbuf = false;
                    }
                    else
                    {                     
                    sSrcChParams.bSharedRbuf = true;
                    sSrcChParams.uiMasterSrcCh = hRapCh->pPath[pPath->uiMasterpathId]->sSrcCh[eChPair].hSrcCh->uiIndex;                    
                    }
                }
            }
            else
#endif 
            {
                sSrcChParams.bSharedRbuf = false;
                sSrcChParams.uiMasterSrcCh = BRAP_RM_P_INVALID_INDEX;
            }

            if((BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)&&
                (BRAP_DataEndian_eSwap == pAudioParams->eDataSwap))
            {
                /* swap system data endianness */
                sSrcChParams.eDataSwap = BRAP_DataEndian_eSwap;
            }
            else
            {
                /* don't swap system data endianness */
                sSrcChParams.eDataSwap = BRAP_DataEndian_eSame;
            }

#if (BRAP_7405_FAMILY == 1) || (BRAP_3548_FAMILY == 1)
            if ( (hRapCh->eChannelType == BRAP_ChannelType_ePcmCapture) ||
                 ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                   (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                   (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                   ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                     (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                   )
                 )
               )
            {
                sSrcChParams.bStartSelection = false;            
            }
            else
            {
                sSrcChParams.bStartSelection = true;
            }
#else
            sSrcChParams.bStartSelection = true;
#endif
            sSrcChParams.bCapDirect2SrcFIFO = false;

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
            {
                sSrcChParams.bProcessIdHigh = false;
                /* Check for bProcessIdHigh once sample rate change interrupt comes in */
        	}
            else
            {
            ret = BRAP_P_ConvertSR(pAudioParams->eInputSR, &uiSR);

            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;}

   			sSrcChParams.bProcessIdHigh = (uiSR >= 96000) ? true : false;
            }
            sSrcChParams.uiGroupId = uiGrpId;

            /* Start the SrcCh */
       		ret = BRAP_SRCCH_P_Start(hSrcCh, &sSrcChParams);
	        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_srcch;}
	        BDBG_MSG(("Source channel %d started", hSrcCh->uiIndex));
        }
    }/* for eChPair */

    /* Program Adaptive Rate ctrl  for the Path, If the its DecodeMode.*/
        BRAP_P_EnableAdaptiveRate(hRapCh,&bAdaptiveRateEnable,pAudioParams->sDspChParams.bPPMCorrection);        
        BDBG_MSG(("pAudioParams->sDspChParams.bPPMCorrection = %d, bAdaptiveRateEnable =%d ",pAudioParams->sDspChParams.bPPMCorrection,bAdaptiveRateEnable));
        
        if(bAdaptiveRateEnable == true)
        {
        ret = BRAP_P_ProgramAdaptRateCtrl (hRapCh,uiPth);
        if(BERR_SUCCESS != ret)
        {
            BDBG_ERR(("BRAP_P_StartDecPath: BRAP_P_ProgramAdaptRateCtrl failed %d", ret));
            return BERR_TRACE(ret);              
        }            
    }
    
#if (BRAP_7550_FAMILY !=1)
    /* Start DstCh here */
    BDBG_MSG(("Starting DstCh"));
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            /* Get the default parameters first */
            ret = BRAP_DSTCH_P_GetDefaultParams(&sDstChParams);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;} 

            if(BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType)
            {
                if (0 == uiPth)
                    sDstChParams.eCapMode = pAudioParams->eCapMode;
                else
                    sDstChParams.eCapMode = BRAP_CaptureMode_eCaptureOnly;
            }
            else if ( (BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
                      (BRAP_DSPCHN_DecodeMode_ePassThru == pAudioParams->sDspChParams.eDecodeMode) &&
                      (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) &&
                      ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                        (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                      ) &&
                      (0 == uiPth)
                     )
            {
                /* Put DSTCH in passthru mode only when SPDIF RX is in passthru */
                sDstChParams.eCapMode = BRAP_CaptureMode_eByPass;
            }
                      
            else
            {
                /* TODO: to check if it is correct */
                sDstChParams.eCapMode = BRAP_CaptureMode_eCaptureOnly; /* TODO: XCD Check */
                
            }

            if ((BRAP_ChannelType_ePcmCapture == hRapCh->eChannelType) && (0 == uiPth))
            {
                sDstChParams.eBufDataMode = 
                 hRap->sInputSettings[pAudioParams->eCapInputPort].eBufDataMode;
            }
            else
            {
            
                bBreakLoop =false;
                for(i=0; i<BRAP_P_MAX_DST_PER_RAPCH; i++)
                {

                    for(j =0 ; j < BRAP_P_MAX_DST_PER_RAPCH; j++)
                    {
                        if( hRapCh->pDstDetails[i]!= NULL && 
                            hRapCh->pDstDetails[i]->eAudioDst == BRAP_AudioDst_eRingBuffer &&
                            hRapCh->pPath[uiPth]->pDstDetails[j] == hRapCh->pDstDetails[i])
                        {
                            sDstChParams.eBufDataMode = 
                             hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.eBufDataMode[BRAP_OutputChannelPair_eCaptureLR];
                            
                            /* Note: If bNotPauseWhenFull is true, BF interrupts(e.g. full/free 
                               watermark) don't come. So, set it to false. */
                            sDstChParams.bNotPauseWhenFull = 
                            hRapCh->pDstDetails[i]->uDstDetails.sRBufDetails.bDontPauseWhenFull;                        
                            bBreakLoop =true;
                            break;
                        }
                        else
                        {
                            sDstChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                        }                    
                    }                
                    if(bBreakLoop == true)
                        break;

                }
            }

            if(  sDstChParams.eCapMode != BRAP_CaptureMode_eCaptureOnly )
            {
                sDstChParams.uiSrcChId = 
                            hRapCh->pPath[uiPth+1]->sRsrcGrnt.uiSrcChId[eChPair];

            }

            if((BRAP_ChannelType_eDecode == hRapCh->eChannelType )&&
            (BRAP_ChannelSubType_eNone ==hRapCh->eChannelSubType))
            {
                sDstChParams.bProcessIdHigh = false;
                /* Check for bProcessIdHigh once sample rate change interrupt comes in */
        	}
            else
            {
            ret = BRAP_P_ConvertSR(pAudioParams->eInputSR, &uiSR);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;} 

            sDstChParams.bProcessIdHigh = (uiSR >= 96000) ? true : false;
            }

           
            ret = BRAP_P_PrepareFciId(pPath, 
                                &(pPath->sDstCh[eChPair].sDstChInLink), 
                                (uint32_t *)&(sDstChParams.uiInputFciId),
                                BRAP_INVALID_VALUE,false);
            if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret);goto stop_dstch;}


#if (BRAP_3548_FAMILY ==1)
            if ( (BRAP_AudioSource_eExtCapPort == pAudioParams->eAudioSource) &&
                 (0 == uiPth) &&
                 ( (BRAP_CapInputPort_eHdmi == pAudioParams->eCapInputPort)||
                   (BRAP_CapInputPort_eSpdif == pAudioParams->eCapInputPort)
                 )
               )
            {
                if (BRAP_DSPCHN_AudioType_ePcm == pAudioParams->sDspChParams.eType)
                {
                    sDstChParams.eBufDataMode = BRAP_BufDataMode_eStereoNoninterleaved;
                }
                else
                {
                    sDstChParams.eBufDataMode = BRAP_BufDataMode_eMono;
                }
            }
#endif
           /* Start the DstCh */
       		ret = BRAP_DSTCH_P_Start(hDstCh, &sDstChParams);
	        if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_dstch;}
	        BDBG_MSG(("Destination channel %d started", hDstCh->uiIndex));
        }
    }/* for eChPair */
   
    /* Start Cap port here */
    BDBG_MSG(("Starting CapPort"));    
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {

        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if((hCapPort != NULL) && 
               (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
               (true == BRAP_P_IsInternalCapPort(hCapPort->eCapPort)) &&
               ( (BRAP_CapInputPort_eAdc != hRapCh->eCapInputPort) || (uiPth!=0)))
            {
                continue;                
            }
                
            if(hCapPort != NULL)
            {
                    /* Get the default parameters first */
                    ret = BRAP_CAPPORT_P_GetDefaultParams(&sCapPortParams);
                    if(ret != BERR_SUCCESS){ret = BERR_TRACE(ret); goto stop_capport;} 
#if (BRAP_7405_FAMILY == 1)
                uiGrpId = BRAP_INVALID_VALUE;

                    switch(hCapPort->eCapPort)
                    {
                    case BRAP_CapInputPort_eExtI2s0:
                        uiGrpId = 4;
                        break;
                        case BRAP_CapInputPort_eIntCapPort0:
                            uiGrpId = 0;
                            break;
                        case BRAP_CapInputPort_eIntCapPort1:
                            uiGrpId = 1;
                            break;
                        case BRAP_CapInputPort_eIntCapPort2:
                            uiGrpId = 2;
                            break;
                        case BRAP_CapInputPort_eIntCapPort3:
                            uiGrpId = 3;
                            break;
                        case BRAP_CapInputPort_eIntCapPort4:
                            uiGrpId = 4;
                            break;
                        case BRAP_CapInputPort_eIntCapPort5:
                            uiGrpId = 5;
                            break;
                        case BRAP_CapInputPort_eIntCapPort6:
                            uiGrpId = 6;
                            break;
                        case BRAP_CapInputPort_eIntCapPort7:
                            uiGrpId = 7;
                            break;
                        default:
                            BDBG_ASSERT(0);
                    }
                
                sCapPortParams.uiGrpId = uiGrpId;
#endif


                switch(hCapPort->eCapPort)
                {
                    case BRAP_CapInputPort_eIntCapPort0:
                    case BRAP_CapInputPort_eIntCapPort1:
                    case BRAP_CapInputPort_eIntCapPort2:
                    case BRAP_CapInputPort_eIntCapPort3:
                    case BRAP_CapInputPort_eIntCapPort4:
                    case BRAP_CapInputPort_eIntCapPort5:
                    case BRAP_CapInputPort_eIntCapPort6:
                    case BRAP_CapInputPort_eIntCapPort7:                    
                        sCapPortParams.eInputBitsPerSample = BRAP_InputBitsPerSample_e32;
                        sCapPortParams.eSamplingRate = BAVC_AudioSamplingRate_e48k;
                    
                        ret = BRAP_P_PrepareFciId(
                                pPath, 
                                &(pPath->sCapPort[eChPair][uiPp].sCapPortInLink), 
                                (uint32_t *)&(sCapPortParams.uiInputFciId),
                                BRAP_INVALID_VALUE,
                                false);

                        if(ret != BERR_SUCCESS)
                        {
                            ret = BERR_TRACE(ret);
                            goto stop_capport;
                        }         
                        break;

                    default:
                        sCapPortParams.eInputBitsPerSample = hRap->sInputSettings[hCapPort->eCapPort].eInputBitsPerSample;                        
                        sCapPortParams.eSamplingRate = hRap->sInputSettings[hCapPort->eCapPort].eSampleRate;                        
                        /* Other capture ports need not be considered here*/
                        break;
                }
                
                /* The below values might have to be derived instead of hardcoding 
                later using the Fs Timing, SRC and PLL logic */
                sCapPortParams.ePll = BRAP_OP_Pll_ePll0;
                sCapPortParams.uiFsTmgSrc = 0;
                /* Start the Capture port */
                ret = BRAP_CAPPORT_P_Start(hCapPort, &sCapPortParams);
                if (ret != BERR_SUCCESS)
                {
                    ret = BERR_TRACE(ret);
                    goto stop_capport;
                }
                BDBG_MSG(("Capture port %d Started",hCapPort->eCapPort));

                
            }
        }/* for eChPair */
    }/* for uiPp */
#endif

    if(BERR_SUCCESS == ret)
        goto end_fmm_start;
#if (BRAP_7550_FAMILY !=1)            
stop_capport:
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if(hCapPort != NULL)
            {
                ret1 = BRAP_CAPPORT_P_Stop(hCapPort);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_CAPPORT_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
			    BDBG_MSG(("Capture Port %d stopped", hCapPort->eCapPort));
            }
        }
    }

stop_dstch:
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            ret1 = BRAP_DSTCH_P_Stop(hDstCh);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_DSTCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Destination Channel %d stopped", hDstCh->uiIndex));        
        }
    }
#endif
stop_srcch:
	ui32RegMask=0x0;
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            ret1 = BRAP_SRCCH_P_Stop(hSrcCh);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartOpPathFmmModules: BRAP_SRCCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Source Channel %d stopped", hSrcCh->uiIndex));        

			/*[Gautam] TODO: Mask should be formed for this stop sequence only 
			when its start count has reached to zero */
			
			ui32RegMask |= (1 << hSrcCh->uiIndex);
        }
    }

	/*
	BF Limitation in the FMM Arch:
	When the channel group is disabled with both runs and enables are set to 0, it 
	is required either to read the grouped enable status and wait till the status 
	for all the grouped enables are zero before the SRC can be disabled or the
	channel group is disabled
	*/
	uiTimeOutCtr = BRAP_P_STOP_TIMEOUT_COUNTER;
	do
	{
		if(BRAP_P_STOP_TIMEOUT_COUNTER != uiTimeOutCtr)
		{
			BKNI_Sleep(1);
		}	
		ui32RegVal = BRAP_Read32(hRapCh->hRegister,BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE);		
		ui32RegVal = BCHP_GET_FIELD_DATA(ui32RegVal, AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE, STATUS);		
		ui32RegVal &= ui32RegMask;
		uiTimeOutCtr--;	
	}while((0!=ui32RegVal) && (0!=uiTimeOutCtr));

	if(0!=ui32RegVal)
	{
		BDBG_WRN(("AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE_STATUS=%#x is not disabled. [Time out]",ui32RegVal));
	}

stop_rbuf:
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret1 = BRAP_RBUF_P_Stop(hRBuf);
		    if(ret1 != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_RBUF_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret1 = BERR_TRACE(ret1);
            }
			BDBG_MSG(("Ring buffer %d stopped", hRBuf->uiIndex));
		}
    }    
    
stop_src_mixer:
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {

#if (BRAP_7550_FAMILY != 1)
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
                        ret1 = BRAP_SRC_P_Stop(hSrc);
            		    if(ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SRC_P_Stop()"
                                " failed!!! Ignoring error!!! "));
                            ret1 = BERR_TRACE(ret1);
                        }
            			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                            hSrc->uiIndex, hSrc->uiBlkId));
                    }
                }
#endif
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixInId = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];

                        if(hMixer->eInputState[uiMixInId] != BRAP_P_State_eStarted)
                            continue;
                                            
                        ret1 = BRAP_MIXER_P_Stop(hMixer, uiMixInId);
            		    if(ret1 != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                " failed for input %d!!! Ignoring error!!! ",uiMixInId));
                            ret1 = BERR_TRACE(ret);
                        }
        	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
        			            hMixer->uiMixerIndex, hMixer->uiDpIndex));                        
                    }
                }
            
            }
        }
    }
#if BRAP_P_EQUALIZER
stop_srceq:    
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];
                if(hSrc != NULL)
                {
                    ret1 = BRAP_SRC_P_Stop(hSrc);
        		    if(ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SRC_P_Stop() for EQ"
                            " failed!!! Ignoring error!!! "));
                        ret1 = BERR_TRACE(ret1);
                    }
        			BDBG_MSG(("SRC %d in SRC Block %d stopped for Equalizer", 
                        hSrc->uiIndex, hSrc->uiBlkId));
                }
            }    
        }
    }
#endif
    
stop_op:
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
                         eChPair++, hOp = NULL, pOpParams = NULL)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                ret1 = BRAP_OP_P_Stop(hOp);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
		        BDBG_MSG(("Output port type %d stopped", hOp->eOutputPort));

                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    ret1 = BRAP_SPDIFFM_P_Stop(hSpdifFm);
                    if(ret1 != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_SPDIFFM_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret1 = BERR_TRACE(ret1);
                    }
            		BDBG_MSG(("Spdiffm %d - stream %d stopped", 
				        hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex)); 
                }
            }
            /* Special handling for Mai tapping data from another Output Port */
            if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
            {
                ret1 = BRAP_OP_P_Stop(pPath->sOp[eChPair][uiPp].hMaiOp);
                if(ret1 != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StartFmmModules: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret1 = BERR_TRACE(ret1);
                }
		        BDBG_MSG(("Output port type %d stopped", pPath->sOp[eChPair][uiPp].hMaiOp->eOutputPort));
            }/* hMaiOp */
        }/* for eChPair */
    }/* for uiPp */
    
end_fmm_start:    
    BDBG_MSG(("Leaving BRAP_P_StartFmmModuleHandles"));
    BDBG_LEAVE(BRAP_P_StartFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that stops FMM module handles for a particular path.
**************************************************************************/
BERR_Code BRAP_P_StopFmmModuleHandles(
    BRAP_ChannelHandle          hRapCh,         /* [in] Channel Handle */
    unsigned int                uiPth           /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
#if (BRAP_7550_FAMILY != 1)
    unsigned int            uiCsc = BRAP_INVALID_VALUE; 
    BRAP_SRC_P_Handle       hSrc = NULL;
    BRAP_CAPPORT_P_Handle hCapPort = NULL;
    BRAP_DSTCH_P_Handle	hDstCh = NULL;    
#endif
    void                    *pOpParams = NULL;
    BRAP_Handle             hRap = NULL;
    BRAP_OP_P_Handle        hOp = NULL;
    BRAP_SPDIFFM_P_Handle   hSpdifFm = NULL;
    BRAP_RBUF_P_Handle      hRBuf = NULL;
    unsigned int            uiCh = BRAP_INVALID_VALUE;
    BRAP_SRCCH_P_Handle     hSrcCh = NULL;
    BRAP_MIXER_P_Handle     hMixer = NULL;
    unsigned int            i = 0;
    unsigned int            uiMixIp=0;
	uint32_t				ui32RegVal = 0;
	uint32_t				uiTimeOutCtr=0;
	uint32_t				ui32RegMask = 0;
#if (BRAP_3548_FAMILY != 1)    
   unsigned int uiNumSrcInGrp=0;
#endif
    BDBG_ENTER(BRAP_P_StopFmmModuleHandles);

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }

    BDBG_ASSERT(hRapCh->pPath[uiPth]);

    hRap = hRapCh->hRap;
    pPath = hRapCh->pPath[uiPth];

    /* stop_srcch: */
	ui32RegMask=0x0;

    ret = BRAP_P_ResetAdaptRateCtrl(hRapCh,uiPth);
    if(ret != BERR_SUCCESS)
    {
        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_P_ResetAdaptRateCtrl()"
            " failed!!! Ignoring error!!! "));
        ret = BERR_TRACE(ret);
    }
    
#if (BRAP_3548_FAMILY != 1)
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {	
		ui32RegMask |= (1 << hSrcCh->uiIndex);
               uiNumSrcInGrp++;
        }
    }
    BDBG_MSG(("ui32RegMask = %d , uiNumSrcInGrp =%d",ui32RegMask,uiNumSrcInGrp));
    if(uiNumSrcInGrp == 1)
    {
        /*Stop Src_Mixer*/
        for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)    
        {
            for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
            {
                for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
                {
#if (BRAP_7550_FAMILY != 1)
                    for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                    {
                        hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                        if(hSrc != NULL)
                        {
                            ret = BRAP_SRC_P_Stop(hSrc);
                		    if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop()"
                                    " failed!!! Ignoring error!!! "));
                                ret = BERR_TRACE(ret);
                            }
                			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                                hSrc->uiIndex, hSrc->uiBlkId));
                        }
                    }/* for uiCsc */
#endif     
                    hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                    if(hMixer != NULL)
                    {
                        for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                        {
                            uiMixIp = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];
                            if (BRAP_RM_P_INVALID_INDEX != uiMixIp)
                            {
                                ret = BRAP_MIXER_P_Stop(hMixer, uiMixIp);
                    		    if(ret != BERR_SUCCESS)
                                {
                                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                        " failed for input %d!!! Ignoring error!!! ",uiMixIp));
                                    ret = BERR_TRACE(ret);
                                }
                	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
                			            hMixer->uiMixerIndex, uiMixIp,hMixer->uiDpIndex));
                            }
                        }
                    }
                }/* for eChPair */
            }/* for uiPp */
        }

/*Set GROUP_SYNC_DIS=1 for the channel(s) being shutdown*/
       BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS, ui32RegMask);        

    }
#endif
    
    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hSrcCh = pPath->sSrcCh[eChPair].hSrcCh;
        if(hSrcCh != NULL)
        {
            ret = BRAP_SRCCH_P_Stop(hSrcCh);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRCCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }
			BDBG_MSG(("Source Channel %d stopped", hSrcCh->uiIndex));        
#if (BRAP_3548_FAMILY == 1)            
			ui32RegMask |= (1 << hSrcCh->uiIndex);
#endif            
        }
    }



	/*
	BF Limitation in the FMM Arch:
	When the channel group is disabled with both runs and enables are set to 0, it 
	is required either to read the grouped enable status and wait till the status 
	for all the grouped enables are zero before the SRC can be disabled or the
	channel group is disabled
	*/
	uiTimeOutCtr = BRAP_P_STOP_TIMEOUT_COUNTER;
	do
	{
		if(BRAP_P_STOP_TIMEOUT_COUNTER != uiTimeOutCtr)
		{
			BKNI_Sleep(1);
		}
		ui32RegVal = BRAP_Read32(hRapCh->hRegister,BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE);
		ui32RegVal = BCHP_GET_FIELD_DATA(ui32RegVal, AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE, STATUS);
		ui32RegVal &= ui32RegMask;
		uiTimeOutCtr--;		
	}while((0!=ui32RegVal) && (0!=uiTimeOutCtr));

	if(0!=ui32RegVal)
	{
		BDBG_ERR(("AUD_FMM_BF_CTRL_SOURCECH_GROUP_ENABLE_STATUS=%#x is not disabled. [Time out]",ui32RegVal));
	}
#if (BRAP_3548_FAMILY != 1)
    if(uiNumSrcInGrp == 1)
    {
/*Set GROUP_SYNC_DIS=0 for the channel(s) being shutdown*/
        ui32RegVal = BRAP_Read32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS );
        ui32RegVal ^= ui32RegMask;
        
        BRAP_Write32(hRapCh->hRegister, BCHP_AUD_FMM_BF_CTRL_SOURCECH_GROUP_SYNC_DIS, ui32RegMask);        
	}
#endif
    /* stop_rbuf: */
    for(uiCh = 0; uiCh < BRAP_RM_P_MAX_OP_CHANNELS; uiCh++)
    {
        hRBuf = pPath->hRBuf[uiCh];
        if(hRBuf != NULL)
        {
            ret = BRAP_RBUF_P_Stop(hRBuf);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_RBUF_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }
			BDBG_MSG(("Ring buffer %d stopped", hRBuf->uiIndex));
		}
    }/* for uiCh */    
#if (BRAP_3548_FAMILY != 1)
    if(uiNumSrcInGrp > 1)
#endif        
    {
    /* stop_src_mixer: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
#if (BRAP_7550_FAMILY != 1)
                for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
                {
                    hSrc = pPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc];
                    if(hSrc != NULL)
                    {
                        ret = BRAP_SRC_P_Stop(hSrc);
            		    if(ret != BERR_SUCCESS)
                        {
                            BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop()"
                                " failed!!! Ignoring error!!! "));
                            ret = BERR_TRACE(ret);
                        }
            			BDBG_MSG(("SRC %d in SRC Block %d stopped", 
                            hSrc->uiIndex, hSrc->uiBlkId));
                    }
                }/* for uiCsc */
 #endif
                hMixer = pPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(hMixer != NULL)
                {
                    for(i = 0; i <BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
                    {
                        uiMixIp = pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sMixerGrant[eChPair][uiPp].uiMixerInputId[i];
                        if (BRAP_RM_P_INVALID_INDEX != uiMixIp)
                        {
                            ret = BRAP_MIXER_P_Stop(hMixer, uiMixIp);
                		    if(ret != BERR_SUCCESS)
                            {
                                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_MIXER_P_Stop()"
                                    " failed for input %d!!! Ignoring error!!! ",uiMixIp));
                                ret = BERR_TRACE(ret);
                            }
            	            BDBG_MSG(("Mixer %d MixerIn %d in DP Blk %d stopped", 
            			            hMixer->uiMixerIndex, uiMixIp,hMixer->uiDpIndex));
                        }
                    }
                }
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
    }
#if BRAP_P_EQUALIZER
    /* stop_src_eq: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                hSrc = pPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc];
                if(hSrc != NULL)
                {
                    BRAP_OutputChannelPair  eOpChPair = BRAP_OutputChannelPair_eMax;
                    unsigned int            uiOpPp = BRAP_INVALID_VALUE;
                    BRAP_P_DstDetails       *pPvtDstDetails;
                    unsigned int            uiAssocId = 0, j=0, k=0, l=0;
                    bool                    bSrcCoeffWasCopied = false;

                    pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
                    if ( NULL==pPvtDstDetails )
                    {
                        ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
                        goto end;                
                    }
                    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));                      

                    /* Get the output port information from Out Link of SRC-EQ */
                    eOpChPair = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].eChnPair;
                    uiOpPp = pPath->sSrcEq[eChPair][uiPp].sSrcEqOutLink[0].uiPrlPth;

                    /* Find if coefficient address was not allocated for this SRC 
                       but was copied as it was already allocated and had to be shared.
                    */
                    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
                    {
                        if(NULL == hRapCh->pDstDetails[i])
                            continue;
                        
                        /* hEqualizer is present in Private structure. Get it */
                        ret = BRAP_P_GetPvtDstDetails(hRapCh,hRapCh->pDstDetails[i],pPvtDstDetails,&uiAssocId);
                        if(BERR_SUCCESS!=ret)
                        {
                            continue;
                        }

                        if( (pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort) &&
                            (pPath->sOp[eOpChPair][uiOpPp].hOp != NULL) &&                             
                            (pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR]
                                == pPath->sOp[eOpChPair][uiOpPp].hOp->eOutputPort)
                          )
                        {
                            if (pPvtDstDetails->hEqualizer != NULL)
                            {
                                /* Coeff address allocation was done only for the first
                                   SrcEq that was started, for rest all it was copied.
                                   Deallocation need to happen only for that SrcEq, 
                                   which gets stopped at the last */

                                for(j=0; j<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
                                {
                                    for(k=0; k<BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
                                    {
                                        for(l=0; l<BRAP_P_MAX_PATHS_IN_A_CHAN; l++)
                                        {             
                                            if((NULL != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l]) &&
                                               (BRAP_P_State_eStarted == pPvtDstDetails->hEqualizer->
                                                   hSrcEq[uiCsc][j][k][l]->eState))
                                            {
                                                if(hSrc != pPvtDstDetails->hEqualizer->hSrcEq[uiCsc][j][k][l])
                                {
                                    hSrc->uiCoeffAddr = BRAP_INVALID_VALUE;  
                                                    bSrcCoeffWasCopied = true;
                                    BDBG_MSG(("SRCEQ_Stop: Invalidating the copied Coefficient Address."
                                        "Index = %d, Block =%d", hSrc->uiIndex, hSrc->uiBlkId));
                                                    break;                                                    
                                                }
                                            }
                                        }
                                        if(true == bSrcCoeffWasCopied)
                                            break;
                                    }
                                    if(true == bSrcCoeffWasCopied)
                                        break;                            
                                }
                            }
                            break;
                        }
                    }
                    
                    ret = BRAP_SRC_P_Stop(hSrc);
        		    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SRC_P_Stop() for Equalizer"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
        			BDBG_MSG(("SRC %d in SRC Block %d stopped for Equalizer", 
                        hSrc->uiIndex, hSrc->uiBlkId));
                }
            }/* for uiCsc */
        }
    }
#endif    

#if (BRAP_7550_FAMILY != 1)
    /* stop_cap_port: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            hCapPort = pPath->sCapPort[eChPair][uiPp].hCapPort;
            if(hCapPort != NULL)
            {
                ret = BRAP_CAPPORT_P_Stop(hCapPort);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_CAPPORT_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret = BERR_TRACE(ret);
                }
			    BDBG_MSG(("Capture Port %d stopped", hCapPort->eCapPort));
            }
        }
    }

    for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        hDstCh = pPath->sDstCh[eChPair].hDstCh;
        if(hDstCh != NULL)
        {
            ret = BRAP_DSTCH_P_Stop(hDstCh);
		    if(ret != BERR_SUCCESS)
            {
                BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_DSTCH_P_Stop()"
                    " failed!!! Ignoring error!!! "));
                ret = BERR_TRACE(ret);
            }         
			BDBG_MSG(("Destination Channel %d stopped", hDstCh->uiIndex));        
        }
    }
#endif

    /* stop_op: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; 
                         eChPair++, hOp = NULL, pOpParams = NULL)
        {
            hOp = pPath->sOp[eChPair][uiPp].hOp;
            if(hOp != NULL)
            {
                ret = BRAP_OP_P_Stop(hOp);
                if(ret != BERR_SUCCESS)
                {
                    BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_OP_P_Stop()"
                        " failed!!! Ignoring error!!! "));
                    ret = BERR_TRACE(ret);
                }
		        BDBG_MSG(("Output port type %d stopped", hOp->eOutputPort));


                /* Special handling for hMaiOp tapping data from another Op */
                if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
                {
                    ret = BRAP_OP_P_Stop(pPath->sOp[eChPair][uiPp].hMaiOp);
                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_OP_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
    		        BDBG_MSG(("Output port type %d stopped", 
                        pPath->sOp[eChPair][uiPp].hMaiOp->eOutputPort));
                }

                hSpdifFm = pPath->sOp[eChPair][uiPp].hSpdifFm;
                if(hSpdifFm != NULL)
                {
                    BRAP_SPDIFFM_P_Stop(hSpdifFm);
                    if(ret != BERR_SUCCESS)
                    {
                        BDBG_ERR(("BRAP_P_StopFmmModuleHandles: BRAP_SPDIFFM_P_Stop()"
                            " failed!!! Ignoring error!!! "));
                        ret = BERR_TRACE(ret);
                    }
            		BDBG_MSG(("Spdiffm %d - stream %d stopped", 
				        hSpdifFm->uiIndex, hSpdifFm->uiStreamIndex)); 
                }
            }
        }
    }
#if BRAP_P_EQUALIZER
end:
#endif
    BDBG_LEAVE(BRAP_P_StopFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that links various FMM module handles as required for  
    a particular path.
**************************************************************************/    
BERR_Code BRAP_P_LinkFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputChannelPair  ePrivChP = BRAP_OutputChannelPair_eMax;    
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
    unsigned int            uiPrivPp = BRAP_INVALID_VALUE;
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_P_SrcChHandleInfo  *pSrcCh = NULL;
#if (BRAP_7550_FAMILY != 1)
    BRAP_P_DstChHandleInfo  *pDstCh = NULL;
    BRAP_P_SrcHandleInfo    *pSrc = NULL, *pPrivSrc=NULL;
    bool    bFound =false;
    BRAP_P_CapPortHandleInfo *pCap = NULL; 
    unsigned int            i = 0;    
#endif
    BRAP_P_MixerHandleInfo  *pMixer = NULL, *pPrivMixer = NULL;
    BRAP_RM_P_MixerGrant    *pMixerGrant = NULL;
    unsigned int            j=0, n = 0;
#if BRAP_P_EQUALIZER
    BRAP_P_SrcEqHandleInfo  *pSrcEq = NULL;
#endif
    BRAP_OutputPortDetails  *pOpDetails = NULL;
    BRAP_P_OpHandleInfo     *pOp = NULL;
    unsigned int uiPPStart = 0;

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    bool bMulPPEnabled = false;
#endif
        
    /* Check params */
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(hRapCh->pPath[uiPth]);

#if (BRAP_INDEP_OP_DELAY_SUPPORTED ==1)
    /* Find if MulPP is added */
    bMulPPEnabled = false;
/*    for(i=0;i<BRAP_P_MAX_PATHS_IN_A_CHAN;i++)
    {
        if(NULL == hRapCh->pPath[i])
            break;
        if(hRapCh->pPath[i]->uiPPBranchId > 0)
        {
            bMulPPEnabled = true;
            break;
        }
    }*/
#endif

    pPath = hRapCh->pPath[uiPth];

    BDBG_ENTER(BRAP_P_LinkFmmModuleHandles);

    /* Link info for the source channels:
        ------------------------------------------------------------------------
        sSrcCh[ch] 		Resource    Level     ChPair    ParallelPath
        ----------      --------    -----     ------    ------------
        sSrcChInLink	Rbuf	    NA	        0-3	        NA
        sSrcChSelfLink	SrcCh	    NA	        0-3	        NA
        sSrcChOutLink	Src	        0           0-3	        NA 
        				Mixer		0			0-3			NA
        				Output		NA			0-3			NA
        ------------------------------------------------------------------------
    */
    BDBG_MSG(("Linking SrcCh"));
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        if(pPath->sSrcCh[eChPair].hSrcCh != NULL)
        {
            BDBG_MSG(("pPath->sSrcCh[%d].hSrcCh",eChPair));
            pSrcCh = &(pPath->sSrcCh[eChPair]);

            /* Set bValid */
            pSrcCh->bValid = true;
            
            /* Set self link */
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChSelfLink, BRAP_P_Rsrc_eSrcCh,
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Set in link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChInLink, BRAP_P_Rsrc_eRBuf, 
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Outlink will be programmed in the level0 SRC */
        }
    }/* for eChPair */

#if (BRAP_7550_FAMILY != 1)
    /* Link info for the SRCs:
        ------------------------------------------------------------------------
        sSrc[lvl][chp][pp] 		        Resource    Level   ChPair  ParallelPath
        ------------------              --------    -----   ------  ------------
        sSrcInLink	                    SrcCh	    NA	    0-3	    NA
    	                                Mixer 	    Lvl-1	0-3	    Incoming Pp (= mixer output id)
        sSrcSelfLink	                Src	        Lvl	    0-3	    self Pp
        sSrcOutLink[MAX_TO_SAME_SRC]	Mixer	    Lvl	    0-3	    Outgoing Pp
                                                                    to Mixer
                                        CapPort		NA		0-3		Outgoing Pp to CapPort		
        ------------------------------------------------------------------------                                                                    
    */
    BDBG_MSG(("Linking SRCs"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pSrc = &(pPath->sSrc[uiLvl][eChPair][uiPp]);
                if(pSrc->hSrc[0] != NULL)
                {
                    BDBG_MSG(("pPath->sSrc[lvl=%d][chp=%d][pp=%d]",uiLvl,eChPair,uiPp));
                    /* Set bValid */
                    pSrc->bValid = true;
                    
                    /* Set self link */
                    BRAP_P_SET_LINK_INFO(pSrc->sSrcSelfLink,BRAP_P_Rsrc_eSrc,
                        uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
#if (BRAP_3548_FAMILY == 1)
                    if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                         (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                         (0 == uiPth)
                       )

                    {
                        /* This is the case of ADC */
                        
                        /* Set inlink */
                        BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eCapPort,
                            BRAP_INVALID_VALUE, eChPair+i, 0,BRAP_INVALID_VALUE);
                        
                    }
                    else
#endif
                    {
                        /* Decide the inlink details */
                        if(0 == uiLvl)
                        {
                            /* Level-0, inlink resource is SrcCh */
                            /* Set inlink */
                            BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eSrcCh,
                                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                            /* Set outlink of SrcCh */
                            pSrcCh = &(pPath->sSrcCh[eChPair]);
                            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eSrc,
                                uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
                        }
                        else
                        {
                            /* Other than Level-0, inlink resource is Mixer */
                            for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                    sMixerGrant[eChPair][uiPrivPp].uiMixerId != 
                                    BRAP_RM_P_INVALID_INDEX) &&
                                   (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                    sMixerGrant[eChPair][uiPrivPp].uiDpId != 
                                    BRAP_RM_P_INVALID_INDEX))
                                {
                                    /* Got the previous mixer's self location */
                                    break;
                                }
                            }
                            if(uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {
                                /* Set outlink of privious level Mixer */
                                pMixer = &(pPath->sMixer[uiLvl-1][eChPair][uiPp]);
                                /* Only output 2 of previous mixer can feed to next level SRC
                                   check if previous mixer's 2nd output is free */
                                if(BRAP_P_Rsrc_eMax != pMixer->sMixerOutLink[1].eRsrcType)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " free previous mixer outlink"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }
                                BRAP_P_SET_LINK_INFO(pMixer->sMixerOutLink[1], BRAP_P_Rsrc_eSrc,
                                    uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set inlink */
                                BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eMixer,
                                    uiLvl-1, eChPair, uiPrivPp,1);


                            }
                        }
                    }

                    /* Outlink will be programmed in the next level mixer */
                    
                }/* if hSrc != NULL */                    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */
#endif

    /* Link info for the Mixers:
        ------------------------------------------------------------------------
        sMixer[lvl][chp][pp]            Resource    Level   ChPair  ParallelPath
        --------------------            --------    -----   ------  ------------
        sMixerInLink[MAX_MIXER_INPUTS]	Src	        Lvl	    0-3	    Incoming Pp
	                                    Mixer	    Lvl-1	0-3	    Incoming Pp
	                                    SrcCh		NA		0-3		NA
        sMixerSelfLink	                Mixer	    Lvl	    0-3	    Incoming Pp
        sMixerOutLink[MAX_MIXER_OUTPUTS]Src	        Lvl+1	0-3	    Outgoing Pp
                                                                    to SRC
	                                    Mixer	    Lvl+1	0-3	    Outgoing Pp
	                                                                to Mixer
	                                    Op/Cap      NA      0-3     Outgoing Pp
                                                	                to Op/Cap
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking Mixers"));
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixer = &(pPath->sMixer[uiLvl][eChPair][uiPp]);
                if(pMixer->hMixer != NULL)
                {
                    BDBG_MSG(("pPath->sMixer[lvl=%d][chp=%d][pp=%d]",uiLvl,eChPair,uiPp));
                    BDBG_MSG(("Aud Mode In(%d, %d) Out(%d, %d)",
                        pPath->sMixingLevels[uiLvl].eInputAudMode,
                        pPath->sMixingLevels[uiLvl].bInputLfeOn,
                        pPath->sMixingLevels[uiLvl].eOutputAudMode,
                        pPath->sMixingLevels[uiLvl].bOutputLfeOn));

                    /* Set bValid */
                    pMixer->bValid = true;
                    
                    /* Set self link */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerSelfLink, 
                        BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);

                    /* For each mixer input set the in link */
                    pMixerGrant = &(pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                sMixerGrant[eChPair][uiPp]);
                    for(ePrivChP=0; ePrivChP < BRAP_OutputChannelPair_eMax; ePrivChP++)
                    {
                        if(pMixerGrant->uiMixerInputId[ePrivChP] != 
                                BRAP_RM_P_INVALID_INDEX)
                        {
                            BDBG_MSG(("Valid MixInput %d at ePrivChP = %d", 
                                pMixerGrant->uiMixerInputId[ePrivChP], 
                                ePrivChP));
                            
                            /* Check if SRC in the same level is an input to 
                               this mixer */

                            for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                    sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcId != 
                                        BRAP_RM_P_INVALID_INDEX) &&
                                   (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                                    sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcBlkId != 
                                        BRAP_RM_P_INVALID_INDEX))
                                {
                                    BDBG_MSG(("Valid SRC Id=%d Blk=%d at ePrivChP=%d ePrivPp = %d", 
                                        pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcId, 
                                        pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].sSrcGrant[0][ePrivChP][uiPrivPp].uiSrcBlkId, 
                                        ePrivChP,uiPrivPp));

#if (BRAP_7550_FAMILY != 1)
                                    /* Got the previous SRC's self location */
                                    /* Set Inlink of the Mixer */
                                    BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrc, uiLvl, 
                                        ePrivChP, uiPrivPp,BRAP_INVALID_VALUE);

                                    /* Get input SRC */
                                    pSrc = &(pPath->sSrc[uiLvl][ePrivChP][uiPrivPp]);
                                    for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                    {         
                                        if(BRAP_P_Rsrc_eMax == pSrc->sSrcOutLink[i].eRsrcType)
                                        {
                                            break;
                                        }
                                    }
                                    if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                    {
                                        BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                            " previous SRC"));
                                        return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                    }
                                    
                                    /* Set outlink of input SRC */                                    
                                    BRAP_P_SET_LINK_INFO(pSrc->sSrcOutLink[i], 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair,uiPp,BRAP_INVALID_VALUE);

                                    /* Inlink to mixer and outlink of SRC set */                                    
#else /* For 7550 family only */
                                    /* Got the previous SRCCH's self location */
                                    /* Set Inlink of the Mixer */
                                    BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrcCh, uiLvl, 
                                        ePrivChP, uiPrivPp,BRAP_INVALID_VALUE);

                                    /* Set outlink of SrcCh */
                                    pSrcCh = &(pPath->sSrcCh[eChPair]);
                                    BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair,uiPp,BRAP_INVALID_VALUE);
                                    
                                    /* Inlink to mixer and outlink of SRCCH set */
#endif                                    
                                    break;
                                }
                            }/* for uiPrivPp */
                            
                            if(uiPrivPp >= BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {
							/* If  Level=0 and since no Src of same lvl is 
							feeding this mixer then, SrcCh must be feeding
							this mixer input */

							if(0 == uiLvl && (pPath->sMixingLevels[uiLvl].eInputSR == pPath->sMixingLevels[uiLvl].eOutputSR))
		                    {
		                        /* Level-0, inlink resource is SrcCh */
		                        /* Set inlink */
								BRAP_P_SET_LINK_INFO(
                                        pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                        BRAP_P_Rsrc_eSrcCh,BRAP_INVALID_VALUE, 
                                        ePrivChP, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE); /*Check the Last parameter*/

		                        /* Set outlink of SrcCh */
		                        pSrcCh = &(pPath->sSrcCh[eChPair]);
								if(pSrcCh->bValid==true)
								{
		                        	BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eMixer,
		                            	uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
								}
								else
								{
									BDBG_ERR(("Valid SrcCh not available to link with Mixer"));
									return BERR_TRACE(BERR_INVALID_PARAMETER);
								}
								BDBG_MSG(("Linking Mixer to SrcCh"));
		                    }
							else
							{
                                /* If no SRC is an input to this mixer, then 
                                   previous level mixer must be an input to this
                                   mixer */
                                   
                                /* Find previous level mixer feeding to this level 
                                   mixer directly */
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT
                                for(uiPrivPp=uiPp; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
#else
                                for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
#endif
                                {
                                    if((pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                        sMixerGrant[ePrivChP][uiPrivPp].uiMixerId != 
                                            BRAP_RM_P_INVALID_INDEX) &&
                                       (pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].
                                        sMixerGrant[ePrivChP][uiPrivPp].uiDpId != 
                                            BRAP_RM_P_INVALID_INDEX))
                                    {
                                        BDBG_MSG(("Valid Mixer Id=%d Blk=%d at ePrivPp = %d, ePrivChP=%d", 
                                                    pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].sMixerGrant[ePrivChP][uiPrivPp].uiMixerId,
                                                    pPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl-1].sMixerGrant[ePrivChP][uiPrivPp].uiDpId,
                                                    uiPrivPp,ePrivChP));
                                        /* Got the previous Mixer's self location */

                                        /* Set outlink of previous level Mixer */ 
                                        pPrivMixer = &(pPath->sMixer[uiLvl-1][ePrivChP][uiPrivPp]);

                                       /* Set Inlink of this level Mixer */
                                        BRAP_P_SET_LINK_INFO(
                                            pMixer->sMixerInLink[pMixerGrant->uiMixerInputId[ePrivChP]],
                                            BRAP_P_Rsrc_eMixer, uiLvl-1, 
                                            ePrivChP, uiPrivPp,1);
                                        
                                        BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[1], 
                                            BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPp,BRAP_INVALID_VALUE);
                                        /* Inlink to mixer and outlink of SRC set */
                                        break;
                                    }
                                }/* for uiPrivPp */
							}                            
                            }                        
                        }
                    }/* for ePrivChP */
                }                    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */



    

    /* Link info for the Outputs:
        ------------------------------------------------------------------------
        sOp[chp][pp]                    Resource    Level   ChPair  ParallelPath
        ------------                    --------    -----   ------  ------------
        sOpInLink	                    Mixer	    Lvl	    0-3	    Incoming Pp
        								SrcCh		NA		0-3		NA		
        sOpSelfLink	                    Op			NA      0-3     self Pp
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking OutputPorts"));
    /* Also Linking SRC - Equalizers */ 
    
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        pOpDetails = NULL;
        for(j=0; j < BRAP_RM_P_MAX_PARALLEL_PATHS; j++)          
        {
            if((NULL == pPath->sMixingLevels[uiLvl].pDstDetails[j]) ||
               (pPath->sMixingLevels[uiLvl].pDstDetails[j]->eAudioDst != 
               BRAP_AudioDst_eOutputPort))
            {
                /* There is no OpPort as destination in this level. Goto next */
                continue;        
            }
            else
            {
                BDBG_MSG(("Found DST at pPath->sMixingLevels[uiLvl=%d].pDstDetails[j=%d]",
                    uiLvl,j));
                pOpDetails = 
                &(pPath->sMixingLevels[uiLvl].pDstDetails[j]->uDstDetails.sOpDetails);
            }

            for(eChPair= 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
            {
                if(pOpDetails->eOutput[eChPair] != BRAP_OutputPort_eMax)
                {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT                
                    for(uiPp = j; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
#else 
                    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
#endif
                    {                    
                        pOp = &(pPath->sOp[eChPair][uiPp]);
                        
                        
                        if((false == pOp->bValid) && (pOp->hOp != NULL) &&
                           (pOp->hOp->eOutputPort == pOpDetails->eOutput[eChPair]))
                        {
                            BDBG_MSG(("uiPp = %d, eChPair = %d", uiPp, eChPair));
#if BRAP_P_EQUALIZER
                            pSrcEq = &(pPath->sSrcEq[eChPair][uiPp]);

                            if (pSrcEq->hSrcEq[0] != NULL)
                            {
                                BDBG_MSG(("OpPort<->SrcEQ: pPath->sSrcEq[chp=%d][pp=%d]",eChPair,uiPp));
                                pSrcEq->bValid = true;

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, 
                                    BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                {         
                                    if(BRAP_P_Rsrc_eMax == pSrcEq->sSrcEqOutLink[i].eRsrcType)
                                    {
                                        break;
                                    }
                                }
                                if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " previous SRC-EQ"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }                                

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], 
                                    BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set In Link of OP pointing to this Equalizer */
	                            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
	                                eChPair, uiPp, BRAP_INVALID_VALUE);                                
                            }
#endif
                            /* Set bValid */
                            pOp->bValid = true;
                            
                            /* Set self link */
                            BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, 
                                BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                                eChPair, uiPp,BRAP_INVALID_VALUE);

                            if(true == hRapCh->hRap->sSettings.bIndOpVolCtrl)
                            {
                                uiPPStart = uiPp;
                            }
                            else
                            {
                                uiPPStart = 0;
                            }
                            for(uiPrivPp=uiPPStart; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                            {
                                pPrivMixer = &(pPath->sMixer[uiLvl][eChPair][uiPrivPp]);
                                for(n=0; n < BRAP_RM_P_MAX_MIXER_OUTPUTS; n++)
                                {
                                    BDBG_MSG(("n = %d SelfLinkRsrc = %d OutLinkRsrc = %d",
                                        n, pPrivMixer->sMixerSelfLink.eRsrcType,
                                        pPrivMixer->sMixerOutLink[n].eRsrcType));
                                    if((BRAP_P_Rsrc_eMax == 
                                        pPrivMixer->sMixerOutLink[n].eRsrcType) &&
                                       (BRAP_P_Rsrc_eMixer == 
                                        pPrivMixer->sMixerSelfLink.eRsrcType) )
                                    {
                                        /* Got n */
                                        BDBG_MSG(("Got n = %d",n));
                                        break;                            
                                    }
                                }
                                if(n < BRAP_RM_P_MAX_MIXER_OUTPUTS)
                                {
                                    /* Got uiPrivPp */
                                    BDBG_MSG(("Got uiPrivPp = %d",uiPrivPp));
                                    break;
                                }
                            }/* for uiPrivPp */

							if((uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS) && (n < BRAP_RM_P_MAX_MIXER_OUTPUTS))
							{
#if BRAP_P_EQUALIZER
                                if (pSrcEq->hSrcEq[0] != NULL)
                                {
    	                            /* Set In Link of Equalizer pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer to Equalizer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, uiPp,BRAP_INVALID_VALUE);
                                
                                }
                                else
#endif                                    
                                {
    	                            /* Set In Link of OP pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, uiPp,BRAP_INVALID_VALUE);
                                }

							}
							else
								pOp->bValid = false;
                        }
                    }/* for uiPp */
                } 
            }/* for chpair */
        }/* for j */
    }/* uiLvl */

	/* No Mixer is the Inlink of Output Port */
		pOpDetails = NULL;
        for(j=0; j <BRAP_P_MAX_DST_PER_RAPCH ; j++)
        {
            if((NULL == pPath->pDstDetails[j]) ||
               (pPath->pDstDetails[j]->eAudioDst != BRAP_AudioDst_eOutputPort))
            {
                /* There is no OpPort as destination in this level. Goto next */
                continue;        
            }
            else
            {
                BDBG_MSG(("Found DST at pPath->pDstDetails[j=%d]",j));
                pOpDetails = &(pPath->pDstDetails[j]->uDstDetails.sOpDetails);
            }
			for(eChPair= 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
            {
                if(pOpDetails->eOutput[eChPair] != BRAP_OutputPort_eMax)
                {
					uiPp=0;
                    pOp = &(pPath->sOp[eChPair][uiPp]);
                      
                   					
                    if((false == pOp->bValid) && (pOp->hOp != NULL) &&
                       (pOp->hOp->eOutputPort == pOpDetails->eOutput[eChPair]))
                    {

                        /* Set bValid */
                        pOp->bValid = true;
                        
                        /* Set self link */
                        BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, 
                            BRAP_P_Rsrc_eOpPort, BRAP_RM_P_INVALID_INDEX,
                            eChPair, uiPp,BRAP_INVALID_VALUE);

                                           
                        /* Set In Link of OP pointing to some SrcCh */
                        BRAP_P_SET_LINK_INFO(pOp->sOpInLink, 
                            BRAP_P_Rsrc_eSrcCh,BRAP_INVALID_VALUE, eChPair,BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                        pSrcCh = &(pPath->sSrcCh[eChPair]);
						if(pSrcCh->bValid==true)
						{
				            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eOpPort,
					            BRAP_INVALID_VALUE, eChPair, uiPp,BRAP_INVALID_VALUE);
						}
						else
						{
							BDBG_ERR(("Valid SrcCh not available to link with Output"));
							return BERR_TRACE(BERR_INVALID_PARAMETER);
						}
                    }

                    if((pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s5)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s6)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s7)||
                       (pOpDetails->eOutput[eChPair] == BRAP_OutputPort_eI2s8))
                       break;
                }
			}
        }

#if (BRAP_7550_FAMILY != 1)
    /* Link info for the CapPort:
        ------------------------------------------------------------------------
        sCapPort[chp][pp]               Resource    Level   ChPair  ParallelPath
        ------------                    --------    -----   ------  ------------
        sCapInLink	                    Mixer	    Lvl	    0-3	    Incoming Pp
        								Src			Lvl		0-3		Incoming Pp
        sCapSelfLink                    Cap			NA      0-3     self Pp
        sCapoutLink                     DstCh		NA      0-3     NA
        ------------------------------------------------------------------------                                                	                
    */
    BDBG_MSG(("Linking CapPorts"));
    /* Go to last mixing level and find out the properties */
    /* TODO : The capture can be from any mixing level. Enable that
       support later */

    if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
         (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
         (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
         (0 == uiPth)         
       )
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {                
            for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
            { 
                pCap = &(pPath->sCapPort[eChPair][uiPp]);
                /* We are interested in the internal capture only*/
                if (NULL != pCap->hCapPort)
                {
                    /* The actual ADC capture has to be treated as usual*/
                    if (BRAP_CapInputPort_eAdc == pCap->hCapPort->eCapPort)
                    {
                        continue;
                    }
                
                    pCap->bValid = true;

                    /* Set self link */
	                    BRAP_P_SET_LINK_INFO(pCap->sCapPortSelfLink, 
	                        BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
	                        eChPair, 0,BRAP_INVALID_VALUE);
#if (BRAP_7550_FAMILY != 1)
                    /* Set In Link */
                    BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                        BRAP_P_Rsrc_eSrc, 0, eChPair, 0,0);   
#endif
                }
            }
        }
    }

    
    for(uiLvl =  0;uiLvl <  BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(i =0;i<BRAP_RM_P_MAX_MIXER_OUTPUTS;i++)
        {
            if(NULL != pPath->sMixingLevels[uiLvl].pIntDstDetails[i])
            {
                /* Got the Capture port Level */
                for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
                {
                    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
                    { 
#if BRAP_P_EQUALIZER                    
                        int uiSrcEqPP = 0;
                        bool bSrcEqFound = false;
#endif                        
                        
    	                pCap = &(pPath->sCapPort[eChPair][uiPp]);

    	                if((false == pCap->bValid) && (NULL != pCap->hCapPort) && 
    	                   (pCap->hCapPort->eCapPort == 
    	                     pPath->sMixingLevels[uiLvl].pIntDstDetails[i]->eCapPort[eChPair]))
    	                {
    	                    BDBG_MSG(("pPath->sCapPort[eChPair=%d][uiPp=%d]",eChPair,uiPp));
    	                    /* Set bValid */
    	                    pCap->bValid = true;

#if BRAP_P_EQUALIZER
                            for(uiSrcEqPP = 0; uiSrcEqPP < BRAP_RM_P_MAX_PARALLEL_PATHS; uiSrcEqPP++)
                            { 
                                pSrcEq = &(pPath->sSrcEq[eChPair][uiSrcEqPP]);

                                if (pSrcEq->hSrcEq[0] != NULL)
                                {
                                    if (pSrcEq->sSrcEqInLink.eRsrcType != BRAP_P_Rsrc_eMixer)
                                    {
                                        bSrcEqFound = true;
                                        break;
                                    }
                                }

                            }
                           
                            if (true == bSrcEqFound)
                            {
                                /* If the equalizer SRC is not tied to an Output Port it is available 
                                   for this internal capport */
                                BDBG_MSG(("Capport<->SrcEQ: pPath->sSrcEq[chp=%d][pp=%d]",eChPair,uiSrcEqPP));
                                pSrcEq->bValid = true;

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, 
                                    BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiSrcEqPP,BRAP_INVALID_VALUE);

                                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                                {         
                                    if(BRAP_P_Rsrc_eMax == pSrcEq->sSrcEqOutLink[i].eRsrcType)
                                    {
                                        break;
                                    }
                                }
                                if(i >= BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC)
                                {
                                    BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " previous SRC-EQ"));
                                    return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                }                                

                                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], 
                                    BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
                                    eChPair, uiPp,BRAP_INVALID_VALUE);

                                /* Set In Link of CAP pointing to this Equalizer */
	                            BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
	                                eChPair, uiSrcEqPP, BRAP_INVALID_VALUE);                                
                            }
#endif                            
    	                    
    	                    /* Set self link */
    	                    BRAP_P_SET_LINK_INFO(pCap->sCapPortSelfLink, 
    	                        BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX,
    	                        eChPair, 0,BRAP_INVALID_VALUE);

    	                    bFound = false;
    	                    for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
    	                    {
    	                        pPrivMixer = &(pPath->sMixer[uiLvl][eChPair][uiPrivPp]);
    	                        for(n=0; n < BRAP_RM_P_MAX_MIXER_OUTPUTS; n++)
    	                        {
    	                            if((BRAP_P_Rsrc_eMax == 
    	                                pPrivMixer->sMixerOutLink[n].eRsrcType) &&
    	                               (BRAP_P_Rsrc_eMixer == 
    	                                pPrivMixer->sMixerSelfLink.eRsrcType) )
    	                            {
    	                                /* Got n */
                                        bFound =true;                                        
    	                                break;                            
    	                            }
    	                        }
                                 if(bFound == true)                                        
    	                        {
                                    /* Got uiPrivPp */
                                    break;
                                }
                            }/* for uiPrivPp */
                                
                            if(bFound == false)
                            {
                                BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                    " free previous mixer outlink"));
                                return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                            }
                            bFound = false;
                            if(uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS)
                            {

#if BRAP_P_EQUALIZER
                                if (true == bSrcEqFound)
                                {
    	                            /* Set In Link of Equalizer pointing to some mixer */
    	                            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, 
    	                                BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp, n);

    	                            /* Set outlink of previous Mixer to Equalizer */
    	                            BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
    	                                BRAP_P_Rsrc_eSrcEq, BRAP_RM_P_INVALID_INDEX, 
    	                                eChPair, bSrcEqFound,BRAP_INVALID_VALUE);
                                
                                }
                                else
#endif
                                {
                                    /* Set In Link of OP pointing to some mixer */
                                    BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                                    BRAP_P_Rsrc_eMixer, uiLvl, eChPair, uiPrivPp,n);

                                    /* Set outlink of previous Mixer */
                                    BRAP_P_SET_LINK_INFO(pPrivMixer->sMixerOutLink[n], 
                                    BRAP_P_Rsrc_eCapPort, BRAP_RM_P_INVALID_INDEX, 
                                    eChPair, uiPp,BRAP_INVALID_VALUE);
                                }
                            }
#if (BRAP_7550_FAMILY != 1)
                            else /*SRC is the inlink of the CapPort */
                            {
                                for(uiPrivPp=0; uiPrivPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPrivPp++)
                                {
                                    pPrivSrc = &(pPath->sSrc[uiLvl][eChPair][uiPrivPp]);
                                    for(n=0; n < BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; n++)
                                    {
                                        if((BRAP_P_Rsrc_eMax == pPrivSrc->sSrcOutLink[n].eRsrcType) &&
                                        (BRAP_P_Rsrc_eSrc == pPrivSrc->sSrcSelfLink.eRsrcType) )
                                        {
                                            /* Got n */
                                            bFound =true;
                                            break;                            
                                        }
                                    }
                                     if(bFound == true)                                        
                                    {
                                        /* Got uiPrivPp */
                                        break;
                                    }
                                }/* for uiPrivPp */
                                if(bFound == false)
                                    {
                                        BDBG_ERR(("BRAP_P_LinkFmmModuleHandles: Can't find"
                                        " free previous src outlink"));
                                        return BERR_TRACE(BRAP_ERR_DEVICE_UNINTIALIZED);
                                    }
                                /* Set In Link of OP pointing to some mixer */
                                BRAP_P_SET_LINK_INFO(pCap->sCapPortInLink, 
                                BRAP_P_Rsrc_eSrc, uiLvl, eChPair, uiPrivPp,BRAP_INVALID_VALUE);

                                /* Set outlink of previous Src */
                                BRAP_P_SET_LINK_INFO(pPrivSrc->sSrcOutLink[n], 
                                BRAP_P_Rsrc_eCapPort, BRAP_INVALID_VALUE, 
                                eChPair, uiPp,BRAP_INVALID_VALUE);
                            }
#endif                            
    	                }/* if */
    	             }
                }/* for eChPair */
            }/* if */
        }
    }/* for uiLvl */

    /* Link info for the Destination channels:
        ------------------------------------------------------------------------
        sDstCh[ch] 		Resource    Level     ChPair    ParallelPath
        ----------      --------    -----     ------    ------------
        sDstChInLink	CapPort	    NA	        0-3	        0
        sDstChSelfLink	DstCh	    NA	        0-3	        NA
        sDstChOutLink	Rbuf        NA          0-3	        NA 
        ------------------------------------------------------------------------
    */
    BDBG_MSG(("Linking DstCh"));
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        pDstCh = &(pPath->sDstCh[eChPair]);
        if((pPath->sDstCh[eChPair].hDstCh != NULL) && (false == pDstCh->bValid))
        {
            BDBG_MSG(("pPath->sDstCh[eChPair=%d]",eChPair));    
            /* Set bValid */
            pDstCh->bValid = true;
            
            /* Set self link */
            BRAP_P_SET_LINK_INFO(pDstCh->sDstChSelfLink, BRAP_P_Rsrc_eDstCh,
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            
            if ( (BRAP_AudioSource_eExtCapPort == hRapCh->eAudioSource) && 
                 (BRAP_CapInputPort_eAdc == hRapCh->eCapInputPort) &&
                 (BRAP_P_UsgPath_eCapture == pPath->eUsgPath) &&
                 (0 == uiPth)
               )
            {
                /* Set in link */            
                BRAP_P_SET_LINK_INFO(pDstCh->sDstChInLink, BRAP_P_Rsrc_eCapPort, 
                    BRAP_INVALID_VALUE, eChPair, 1,BRAP_INVALID_VALUE);

                /* Set Outlink of Capport */
                BRAP_P_SET_LINK_INFO( pPath->sCapPort[eChPair][1].sCapPortoutLink,
                BRAP_P_Rsrc_eDstCh,BRAP_INVALID_VALUE , eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            
            }
            else
            {

                /* Set in link */            
                BRAP_P_SET_LINK_INFO(pDstCh->sDstChInLink, BRAP_P_Rsrc_eCapPort, 
                    BRAP_INVALID_VALUE, eChPair, 0,BRAP_INVALID_VALUE);

                /* Set Outlink of Capport */
                BRAP_P_SET_LINK_INFO( pPath->sCapPort[eChPair][0].sCapPortoutLink,
                BRAP_P_Rsrc_eDstCh,BRAP_INVALID_VALUE , eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            }

            /* Set outlink of DstCh */
            BRAP_P_SET_LINK_INFO(pDstCh->sDstChOutLink, BRAP_P_Rsrc_eRBuf, 
                BRAP_INVALID_VALUE, eChPair, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
        }
    }/* for eChPair */
#endif
    
    BDBG_MSG(("All Linking done!!"));

#if BRAP_P_DBG_LINK_INFO
    /* Debug print all the linkage info */
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        /* TODO */
        BDBG_MSG(("sSrcCh[%d]:\tbValid = %d \thSrcCh = %p\n"
                  "          :\teRsrcType \teLvl \teChp \tePp\n"
                  "In[%d]=%x%x%x Self[%d]=%x%x%x Out[%d]=%x%x%x\n",
                  eChPair, pPath->sSrcCh[eChPair].bValid, 
                  pPath->sSrcCh[eChPair].hSrcCh,
                  pPath->sSrcCh[eChPair].sSrcChInLink.eRsrcType,
                  pPath->sSrcCh[eChPair].sSrcChInLink.uiLevel,
                  pPath->sSrcCh[eChPair].sSrcChInLink.eChnPair,
                  pPath->sSrcCh[eChPair].sSrcChInLink.uiPrlPth));
    }
#endif
    
    BDBG_LEAVE(BRAP_P_LinkFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that unlinks various FMM module handles for a particular
    path.
**************************************************************************/    
BERR_Code BRAP_P_UnlinkFmmModuleHandles(
    BRAP_ChannelHandle      hRapCh,     /* [in] Channel Handle */
    unsigned int            uiPth       /* [in] Path id */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int            uiLvl = BRAP_INVALID_VALUE;
    unsigned int            uiPp = BRAP_INVALID_VALUE;
    unsigned int            i = 0;    
    BRAP_P_ObjectHandles    *pPath = NULL;
    BRAP_P_SrcChHandleInfo  *pSrcCh = NULL;
    BRAP_P_SrcHandleInfo    *pSrc = NULL;
#if BRAP_P_EQUALIZER
    BRAP_P_SrcEqHandleInfo  *pSrcEq = NULL;    
#endif
    BRAP_P_MixerHandleInfo  *pMixer = NULL;
    BRAP_P_OpHandleInfo     *pOp = NULL;

    BDBG_ENTER(BRAP_P_UnlinkFmmModuleHandles);        

    /* Check params */
    BDBG_ASSERT(hRapCh);

    if(uiPth >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("uiPth = %d  can't be greater  or equal to than BRAP_P_MAX_PATHS_IN_A_CHAN = %d",uiPth,BRAP_P_MAX_PATHS_IN_A_CHAN));
        BDBG_ASSERT(0);
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
        
    pPath = hRapCh->pPath[uiPth];

    /* Unlink info for the source channels: */
    for(eChPair=0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
    {
        if(pPath->sSrcCh[eChPair].hSrcCh != NULL)
        {
            pSrcCh = &(pPath->sSrcCh[eChPair]);

            /* Reset bValid */
            pSrcCh->bValid = false;
            
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChSelfLink, BRAP_P_Rsrc_eMax,
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset in link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset out link */            
            BRAP_P_SET_LINK_INFO(pSrcCh->sSrcChOutLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
        }
    }/* for eChPair */

    /* Unlink info for the SRCs: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pSrc = &(pPath->sSrc[uiLvl][eChPair][uiPp]);
                /* Reset bValid */
                pSrc->bValid = false;
                    
                /* Reset self link */
                BRAP_P_SET_LINK_INFO(pSrc->sSrcSelfLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                    
                /* Reset in link */
                BRAP_P_SET_LINK_INFO(pSrc->sSrcInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                /* Reset out link */
                for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
                {
                    BRAP_P_SET_LINK_INFO(pSrc->sSrcOutLink[i], BRAP_P_Rsrc_eMax, 
                    BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */                   
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */

    /* Unlink info for the Mixers: */
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {
            for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
            {
                pMixer = &(pPath->sMixer[uiLvl][eChPair][uiPp]);

                /* Reset bValid */
                pMixer->bValid = false;
                    
                /* Reset self link */
                BRAP_P_SET_LINK_INFO(pMixer->sMixerSelfLink, BRAP_P_Rsrc_eMax, 
                    BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

                /* For each mixer input, reset the in link */
                for(i=0; i<BRAP_RM_P_MAX_MIXER_INPUTS; i++)
                {
                    /* Set Inlink of the Mixer */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerInLink[i], BRAP_P_Rsrc_eMax, 
                        BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */

                /* for each mixer output, reset the out link */
                for(i=0; i<BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    /* Set Inlink of the Mixer */
                    BRAP_P_SET_LINK_INFO(pMixer->sMixerOutLink[i], BRAP_P_Rsrc_eMax, 
                        BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                }/* for i */
    
            }/* for eChPair */
        }/* for uiPp */
    }/* for uiLvl */

#if BRAP_P_EQUALIZER
    /* Unlink info for the SRC-EQs: */
    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; eChPair++)
        {
            pSrcEq = &(pPath->sSrcEq[eChPair][uiPp]);
            /* Reset bValid */
            pSrcEq->bValid = false;
                
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqSelfLink, BRAP_P_Rsrc_eMax, 
            BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
                
            /* Reset in link */
            BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqInLink, BRAP_P_Rsrc_eMax, 
            BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset out link */
            for(i=0; i< BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
            {
                BRAP_P_SET_LINK_INFO(pSrcEq->sSrcEqOutLink[i], BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);
            }/* for i */                   
        }/* for eChPair */
    }/* for uiPp */
#endif

    /* Unlink info for the Outputs: */
    for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
    {
        for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
        {                    
            pOp = &(pPath->sOp[eChPair][uiPp]);

            /* Reset bValid */
            pOp->bValid = false;
                    
            /* Reset self link */
            BRAP_P_SET_LINK_INFO(pOp->sOpSelfLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

            /* Reset in link */
            BRAP_P_SET_LINK_INFO(pOp->sOpInLink, BRAP_P_Rsrc_eMax, 
                BRAP_INVALID_VALUE, BRAP_OutputChannelPair_eMax, BRAP_INVALID_VALUE,BRAP_INVALID_VALUE);

        }/* for uiPp */
    }/* eChPair */

    BDBG_LEAVE(BRAP_P_UnlinkFmmModuleHandles);
    return ret;
}

/**************************************************************************
Summary:
    Private function that returns the FCI Id.
**************************************************************************/ 
BERR_Code 
BRAP_P_PrepareFciId(
    BRAP_P_ObjectHandles    *psPath,        /* [in] Pointer to usage path */
    BRAP_P_LinkInfo         *psInLink,      /* [in] Pointer to the inlink */     
    uint32_t                *pui32FciId,    /* [out] FCI id to be returned */
    unsigned int            uiSrcCascade,   /* [in] Cascade index. Valid only 
                                               for SRC */
    bool                    bLoopBack
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    uint32_t        ui32FciId = 0;
    uint32_t        ui32BlkId = 0 , ui32RsrcId = 0;
    BRAP_OutputChannelPair eChPair = BRAP_OutputChannelPair_eMax;
    unsigned int    uiLvl = 0;
    unsigned int    uiPp = 0;
    unsigned int    uiMixOutput = 0;
#if (BRAP_7550_FAMILY != 1)
    unsigned int    uiCsc = 0;
    BRAP_SRC_P_Handle hSrc = NULL;
    BRAP_CAPPORT_P_Handle hCap = NULL;    
#endif
    BRAP_MIXER_P_Handle hMixer = NULL;
    unsigned int    i = 0, uiMixOp = BRAP_INVALID_VALUE;
    
    BDBG_ENTER(BRAP_P_PrepareFciId);
#if (BRAP_7550_FAMILY == 1)
    BSTD_UNUSED(uiSrcCascade);
#endif
    BSTD_UNUSED(bLoopBack);
            
    eChPair = psInLink->eChnPair;
    uiLvl = psInLink->uiLevel;
    uiPp = psInLink->uiPrlPth;
    uiMixOutput = psInLink->uiMixerOutput;

    BDBG_MSG(("BRAP_P_PrepareFciId: psInLink->eRsrcType = %d", psInLink->eRsrcType));
    BDBG_MSG(("eChPair = %d, uiLvl = %d, uiPp = %d", eChPair, uiLvl, uiPp));
    switch(psInLink->eRsrcType)
    {        
        case BRAP_P_Rsrc_eRBuf:
            return BERR_TRACE(BERR_INVALID_PARAMETER);
            break;
#if (BRAP_7550_FAMILY != 1)
        case BRAP_P_Rsrc_eSrcCh:
            
            if(0 == uiSrcCascade)
            {
                ui32BlkId = BRAP_P_FCI_BLK_ID_BF_PLAYBACK;
                ui32RsrcId = psPath->sSrcCh[eChPair].hSrcCh->uiIndex;
            }
            else
            {
                hSrc = psPath->sSrc[0][eChPair][0].hSrc[uiSrcCascade-1];
                if(hSrc == NULL)
                {
                    BDBG_ASSERT(0);
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                if(0 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
                else if(1 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                ui32RsrcId = hSrc->uiIndex;
            }
            break;
        case BRAP_P_Rsrc_eSrc: 
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                if(psPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc] != NULL)
                   hSrc = psPath->sSrc[uiLvl][eChPair][uiPp].hSrc[uiCsc]; 
            }
            if(hSrc == NULL)
            {
                BDBG_ASSERT(0);
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            if(0 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
            else if(1 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
            else
                return BERR_TRACE(BERR_INVALID_PARAMETER);

            ui32RsrcId = hSrc->uiIndex;
            break;
        case BRAP_P_Rsrc_eSrcEq: 
            for(uiCsc = 0; uiCsc < BRAP_RM_P_MAX_SRC_IN_CASCADE; uiCsc++)
            {
                if(psPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc] != NULL)
                   hSrc = psPath->sSrcEq[eChPair][uiPp].hSrcEq[uiCsc]; 
            }
            if(hSrc == NULL)
            {
                BDBG_ASSERT(0);
                return BERR_TRACE(BERR_INVALID_PARAMETER);
            }
            if(0 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
            else if(1 == hSrc->uiBlkId)
                ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
            else
                return BERR_TRACE(BERR_INVALID_PARAMETER);

            ui32RsrcId = hSrc->uiIndex;
            break; 
#else /* For 7550 family only*/
        case BRAP_P_Rsrc_eSrcCh:
            ui32BlkId = BRAP_P_FCI_BLK_ID_BF_PLAYBACK;
            ui32RsrcId = psPath->sSrcCh[eChPair].hSrcCh->uiIndex;
            break;
#endif
            
        case BRAP_P_Rsrc_eMixer:
            if ((BRAP_INVALID_VALUE == uiSrcCascade) || (0 == uiSrcCascade))
            {
                hMixer = psPath->sMixer[uiLvl][eChPair][uiPp].hMixer;
                if(0 == hMixer->uiDpIndex)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_DP0;
                else if(1 == hMixer->uiDpIndex)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_DP1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                /* Prepare the LSB */
                for(i=0; i < BRAP_RM_P_MAX_MIXER_OUTPUTS; i++)
                {
                    uiMixOp = psPath->sRsrcGrnt.sSrcMixerGrnt[uiLvl].
                        sMixerGrant[eChPair][uiPp].uiMixerOutputId[i];
                    if(uiMixOutput == uiMixOp)
                    {
                        break;
                    }
                }

                if(BRAP_INVALID_VALUE == uiMixOp)
                {
                    BDBG_ERR(("BRAP_P_PrepareFciId: Could not find uiMixOp"));    
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                else
                {
                    BDBG_MSG(("BRAP_P_PrepareFciId: uiMixOp = %d ", uiMixOp));
                }

                ui32RsrcId = (hMixer->uiMixerIndex * BRAP_RM_P_MAX_MIXER_OUTPUTS) +
                                uiMixOp;
            }
#if BRAP_P_EQUALIZER
            else
            {
                unsigned int uiPpSrcEqCsc = 0;

                /* The two SRCs for Eq are treated as one block and so both have inlink as Mixer.
                   To find out parent SRC connected in cascade to this SRC we need the corresponding 
                   parallel path of the SrcEq which is stored in sMixerOutLink */                
                uiPpSrcEqCsc = psPath->sMixer[uiLvl][eChPair][uiPp].sMixerOutLink[uiMixOutput].uiPrlPth;
                hSrc = psPath->sSrcEq[eChPair][uiPpSrcEqCsc].hSrcEq[uiSrcCascade-1];
                if(hSrc == NULL)
                {
                    BDBG_ASSERT(0);
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                }
                if(0 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC0;
                else if(1 == hSrc->uiBlkId)
                    ui32BlkId = BRAP_P_FCI_BLK_ID_SRC1;
                else
                    return BERR_TRACE(BERR_INVALID_PARAMETER);

                ui32RsrcId = hSrc->uiIndex;                        
            }
#endif      
            break;
#if (BRAP_7550_FAMILY != 1)            
        case BRAP_P_Rsrc_eCapPort:
            ui32BlkId = BRAP_P_FCI_BLK_ID_IOP_CAPTURE;
            hCap = psPath->sCapPort[eChPair][uiPp].hCapPort;
		    BDBG_MSG(("hCap > %x", hCap));
            BDBG_ASSERT(hCap != NULL);

            switch(hCap->eCapPort)
            {
                case BRAP_CapInputPort_eIntCapPort0:
                    ui32RsrcId = 0;
                    break;
                case BRAP_CapInputPort_eIntCapPort1:
                    ui32RsrcId = 1;
                    break;
                case BRAP_CapInputPort_eIntCapPort2:
                    ui32RsrcId = 2;
                    break;
                case BRAP_CapInputPort_eIntCapPort3:
                    ui32RsrcId = 3;
                    break;
                case BRAP_CapInputPort_eIntCapPort4:
                    ui32RsrcId = 4;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort5:
                    ui32RsrcId = 5;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort6:
                    ui32RsrcId = 6;
                    break;                      
                case BRAP_CapInputPort_eIntCapPort7:
                    ui32RsrcId = 7;
                    break;  
                /* External Capture Port Resource IDs based on the chip */    
#if  (BRAP_3548_FAMILY == 1) 
                case BRAP_CapInputPort_eExtI2s0:    
                    ui32RsrcId = 4;
                    break;
                case BRAP_CapInputPort_eRfAudio:    
                    ui32RsrcId = 5;
                    break;
                case BRAP_CapInputPort_eAdc:
#if (BCHP_VER==BCHP_VER_A0)
                    ui32RsrcId = 7;
#else
                    ui32RsrcId = 10;
#endif
                    break;
                case BRAP_CapInputPort_eSpdif:    
                case BRAP_CapInputPort_eHdmi:                        
                    ui32RsrcId = 6;
                    break;
#elif (BRAP_7405_FAMILY == 1)                    
                case BRAP_CapInputPort_eExtI2s0:    
                    ui32RsrcId = 4;
                    break;
#endif                    
                default:
                    BDBG_ERR(("BRAP_P_PrepareFciId: Unsupported CapPort"));
                    return BERR_TRACE(BERR_INVALID_PARAMETER);
                    break;
            }
            break;            
        case BRAP_P_Rsrc_eDstCh:
            /* TODO */
#endif            
        default:
            BDBG_ERR(("BRAP_P_PrepareFciId: Unsupported Rsrc type = %d",
                 psInLink->eRsrcType));
            return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    
    BRAP_P_PREPARE_FCI_ID(ui32FciId, ui32BlkId, ui32RsrcId);
    *pui32FciId = ui32FciId;

    BDBG_MSG(("ui32FciId = 0x%x, ui32BlkId = 0x%x, ui32RsrcId = 0x%x", 
        ui32FciId, ui32BlkId, ui32RsrcId));
    
    BDBG_LEAVE(BRAP_P_PrepareFciId);
    return ret;
}

/***************************************************************************
Summary:
    Private function that updates the already allocated output and spdiffm 
    ids in the resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_UpdateOpResrcGrant(
    BRAP_ChannelHandle      hRapCh,         /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputPortDetails  *pOpDetails = NULL;
    BRAP_DstDetails         *pDstDetails = NULL;
    unsigned int            uiLvl = 0,uiPp=0, i = 0,j=0;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    BRAP_OutputPort         eMaiMuxOp = BRAP_OutputPort_eMax;

    BDBG_ASSERT(pPath);
    BDBG_ASSERT(pRsrcGrnt);

    BDBG_ENTER(BRAP_P_UpdateOpResrcGrant);

    /* Check if Mai has been added as a destination with a valid Mux-Selector */
    for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        pDstDetails = hRapCh->pDstDetails[i];
        if((NULL == pDstDetails) || 
           (BRAP_AudioDst_eOutputPort != pDstDetails->eAudioDst))
        {
            continue;
        }
#if 0
        if(BRAP_OutputPort_eMai == pDstDetails->uDstDetails.sOpDetails.
            eOutput[BRAP_OutputChannelPair_eLR])
#endif            
        {
            eMaiMuxOp = hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].
                uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
        }
    }/* for i */
    uiPp = 0;
    for(uiLvl = 0; uiLvl < BRAP_RM_P_MAX_MIXING_LEVELS; uiLvl++)
    {
        for(j=0; j < BRAP_RM_P_MAX_PARALLEL_PATHS; j++)          
        {
#if BRAP_P_CUSTOM_MIXER_REQUIREMENT        
            uiPp = j;
#endif            
            if((NULL == pPath->sMixingLevels[uiLvl].pDstDetails[j]) ||
               (pPath->sMixingLevels[uiLvl].pDstDetails[j]->eAudioDst != 
                    BRAP_AudioDst_eOutputPort))
            {
                /* This mixing level is not feeding to any output port directly */
                continue;
            }

            pOpDetails = 
                &(pPath->sMixingLevels[uiLvl].pDstDetails[j]->uDstDetails.sOpDetails);
            
            for(i = 0; i < BRAP_OutputChannelPair_eMax; i++)
            {
                eOp = pOpDetails->eOutput[i];
                
                if(eOp != BRAP_OutputPort_eMax)
                {
                    /* Note: uiPp can not be more than it's max. If required for 
                       a chip, the max should be increased. */
                    if(uiPp >= BRAP_RM_P_MAX_PARALLEL_PATHS)
                    {
                        BDBG_ERR(("uiPp = %d  can't be greater  or equal to than BRAP_RM_P_MAX_PARALLEL_PATHS = %d",uiPp,BRAP_RM_P_MAX_PARALLEL_PATHS));
                        BDBG_ASSERT(0);
                        return BERR_TRACE(BRAP_ERR_BAD_DEVICE_STATE);
                    }
                
                    eChPair = i;
                    pRsrcGrnt->sOpPortGrnt[eChPair].eOutputPort = eOp;
                    pPath->sOp[eChPair][uiPp].hOp = hRapCh->hRap->hFmm[0]->hOp[eOp];

     
                    if(BRAP_OutputPort_eMai == eOp)
                        ret = BRAP_RM_P_GetSpdifFmForOpPort(
                                hRapCh->hRap->hRm,
                                eOp,
                                eMaiMuxOp,
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                    else
                    ret = BRAP_RM_P_GetSpdifFmForOpPort(
                            hRapCh->hRap->hRm,
                            eOp,
                            BRAP_OutputPort_eMax,
                            &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                            &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                    
                    if(BERR_SUCCESS != ret)
                    {
                        BDBG_ERR(("BRAP_P_UpdateOpResrcGrant: "
                            "BRAP_RM_P_GetSpdifFmForOpPort failed %d", ret));
                    }
                    /* TODO: Is hardcoding the PP to 0 okay?? */
                    pPath->sOp[eChPair][uiPp].hSpdifFm = 
                        hRapCh->hRap->hFmm[0]->hSpdifFm[pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId];

                    /* If this output port is the mux-selector for MAI, special 
                       handling for Mai tapping data from this output port */                   
#if (BRAP_7405_FAMILY == 1) /* Need this only for I2S Mux */
                    if((eOp == eMaiMuxOp)&&(eOp != BRAP_OutputPort_eMai))
                    {
                        hRapCh->hRap->hFmm[0]->hOp[BRAP_OutputPort_eMai]->uOpSettings.sMai.sExtSettings
                            = hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eMai].uOutputPortSettings.sMaiSettings;
                        pPath->sOp[eChPair][uiPp].hMaiOp = 
                            hRapCh->hRap->hFmm[0]->hOp[BRAP_OutputPort_eMai];
                                
                        /* TODO: Do we need to have a separate SPDIFFM?? */
#if 1 /*(BRAP_7405_FAMILY != 1) */
                        ret = BRAP_RM_P_GetSpdifFmForOpPort(
                                hRapCh->hRap->hRm,
                                BRAP_OutputPort_eMai,
                                eOp,
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId),
                                &(pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId));
                        if(BERR_SUCCESS != ret)
                        {
                            BDBG_ERR(("BRAP_P_UpdateOpResrcGrant: "
                                "BRAP_RM_P_GetSpdifFmForOpPort failed %d", ret));
                    }
                        /* TODO: Is hardcoding the PP to 0 okay?? */
                        pPath->sOp[eChPair][uiPp].hSpdifFm = 
                            hRapCh->hRap->hFmm[0]->hSpdifFm[pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId];
#endif                        
                    }
#endif                    
                    /* TODO: Commneting here and moving outside for loop. Verify if it breaks any feature
					uiPp++;
					*/
                }
            }/* for i */
#if (!BRAP_P_CUSTOM_MIXER_REQUIREMENT)
            uiPp++;
#endif
        }/* for  */
    }/* for uiLvl */

    BDBG_LEAVE(BRAP_P_UpdateOpResrcGrant);   
    return ret;
}

/***************************************************************************
Summary:
    Private function that resets/removes output port and spdiffm ids from the
    resource grant structure.
****************************************************************************/
static BERR_Code
BRAP_P_ResetOpResrcGrant(
    BRAP_Handle             hRap,           /* [in] Raptor device handle */
    BRAP_P_ObjectHandles    *pPath,         /* [in] Path which carries output 
                                               details */
    BRAP_RM_P_ResrcGrant    *pRsrcGrnt      /* [out] Resource grant to update */
    )
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            uiPp = 0;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;

    BDBG_ENTER(BRAP_P_ResetOpResrcGrant);

    BDBG_ASSERT(pPath);
    BDBG_ASSERT(pRsrcGrnt);
    BSTD_UNUSED(hRap);

    for(uiPp = 0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
        for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
        {
            if(pPath->sOp[eChPair][uiPp].hOp != NULL)
            {
                /* Note: The actual freeing of handles will happen in 
                   RemoveDestination() */
                pPath->sOp[eChPair][uiPp].hOp = NULL;
                pPath->sOp[eChPair][uiPp].hSpdifFm = NULL;
                pRsrcGrnt->sOpPortGrnt[eChPair].eOutputPort = 
                                                        BRAP_OutputPort_eMax;
                pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmId = 
                                                        BRAP_INVALID_VALUE;
                pRsrcGrnt->sOpPortGrnt[eChPair].uiSpdiffmStreamId = 
                                                        BRAP_INVALID_VALUE;
            }

            /* Similarly for hMaiOp */                   
            if(pPath->sOp[eChPair][uiPp].hMaiOp != NULL)
            {
                pPath->sOp[eChPair][uiPp].hMaiOp = NULL;
                /* TODO: Handle dedicated spdifFm (if any later) */
            }
        }/* eChPair */
    }/* uiPp */

    BDBG_LEAVE(BRAP_P_ResetOpResrcGrant);
    return ret;
}

/***************************************************************************
Summary:
    Private function gets the burst repetition period for an algo type.

    Recommended Burst Repetition Periods for various algo types are as follows:
    AC3 and DTS = PER_3
    MPEG-2 Layers 1, 2, and 3 < 32kHz = PER_64
    MPEG-1, MPEG-2/AAC, and any other MPEG-2 formats = PER_32
****************************************************************************/
BERR_Code BRAP_P_GetBurstRepetitionPeriodForAlgo(
    BAVC_StreamType                 eStreamType,
                                        /* [in] audio stream type*/
    BRAP_DSPCHN_AudioType           eAudioType, 
                                        /* [in] audio type for which 
                                           burst repetition period is 
                                           sought */
    BRAP_SPDIFFM_P_BurstRepPeriod   *pBurstRepPeriod
                                        /* [out] corresponding burst 
                                           repetition period for the 
                                           algo type passed */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BDBG_ENTER(BRAP_P_GetBurstRepetitionPeriodForAlgo);

    /* validate input */
    BDBG_ASSERT(pBurstRepPeriod);

    switch(eAudioType)
    {
        /* Here we return PER_32 for both MPEG-1 and MPEG-2. For
           MPEG-2 < 32KHz, PER_64 is set from SamplingRateChange_isr */
        case BRAP_DSPCHN_AudioType_eMpeg:
		case BRAP_DSPCHN_AudioType_eMpegMc:			
            if((eStreamType == BAVC_StreamType_ePS) ||
               (eStreamType == BAVC_StreamType_eMpeg1System) ||
               (eStreamType == BAVC_StreamType_eTsMpeg)) 
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer32;
            else
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_eNone;
            break;

        /*Note: AC3+ simul mode uses SPDIFFM */
        case BRAP_DSPCHN_AudioType_eAc3:
        case BRAP_DSPCHN_AudioType_eAc3Lossless:
       	case BRAP_DSPCHN_AudioType_eDts:
        case BRAP_DSPCHN_AudioType_eDtsBroadcast:            
       	case BRAP_DSPCHN_AudioType_eDtshd:
        case BRAP_DSPCHN_AudioType_eDtshdSub:
       	case BRAP_DSPCHN_AudioType_eDdp7_1:			
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer3;
            break;
            
            case BRAP_DSPCHN_AudioType_eAc3Plus:
                *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer4;
            break;
            
            case BRAP_DSPCHN_AudioType_eAac:
            case BRAP_DSPCHN_AudioType_eAacLoas:                        
            case BRAP_DSPCHN_AudioType_eAacSbr:
            case BRAP_DSPCHN_AudioType_eAacSbrAdts:
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer32;
            break;

        /* Not supported / un-compressed algo types */
       	case BRAP_DSPCHN_AudioType_eLpcmBd:
       	case BRAP_DSPCHN_AudioType_eLpcmHdDvd:            
       	case BRAP_DSPCHN_AudioType_eLpcmDvd:  
        case BRAP_DSPCHN_AudioType_eLpcmDvdA:
        case BRAP_DSPCHN_AudioType_ePcm:
		case BRAP_DSPCHN_AudioType_eWmaStd:
		case BRAP_DSPCHN_AudioType_eWmaPro:
		case BRAP_DSPCHN_AudioType_eMlp:
		case BRAP_DSPCHN_AudioType_eDtsLbr:            
        case BRAP_DSPCHN_AudioType_ePcmWav:
        case BRAP_DSPCHN_AudioType_eAmr:            
            case BRAP_DSPCHN_AudioType_eRealAudioLbr:                        
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_eNone;
            break;
            
        case BRAP_DSPCHN_AudioType_eDra:            
            *pBurstRepPeriod = BRAP_SPDIFFM_P_BurstRepPeriod_ePer1024;
            break;
            
        case BRAP_DSPCHN_AudioType_eInvalid:
        default: 
            return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
    BDBG_LEAVE(BRAP_P_GetBurstRepetitionPeriodForAlgo);
    return ret;
}

/***************************************************************************
Summary:
    Private function that gets the PLL for the output port.
****************************************************************************/
#if (BRAP_7550_FAMILY != 1)
BERR_Code
BRAP_P_GetPllForOp(
	const BRAP_Handle 	    hRap,           /* [in] The RAP handle */
	const BRAP_OutputPort	eOutputPort,    /* [in] Output port */
    BRAP_OP_Pll             *pPll           /* [out] The Pll associated with 
                                               this output port */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_OutputPort eMaiMuxSelect = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_GetPllForOp);
    BDBG_ASSERT(hRap);
    BDBG_ASSERT(pPll);
    
    /* Make sure  port is configured */
    if(hRap->bOpSettingsValid[eOutputPort] == false)    
    {
        BDBG_ERR(("BRAP_P_GetPllForOp: Output port %d is not configured. Please"
            " configure before calling this PI.", eOutputPort));
        return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
    }       

    switch(eOutputPort)
    {
        case BRAP_OutputPort_eSpdif:
        case BRAP_OutputPort_eSpdif1:
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sSpdifSettings.ePll;                            
            break;
        case BRAP_OutputPort_eI2s0:
        case BRAP_OutputPort_eI2s1:
        case BRAP_OutputPort_eI2s2:              
        case BRAP_OutputPort_eI2s3:
        case BRAP_OutputPort_eI2s4:
        case BRAP_OutputPort_eI2s5:
        case BRAP_OutputPort_eI2s6:
        case BRAP_OutputPort_eI2s7:              
        case BRAP_OutputPort_eI2s8:
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sI2sSettings.ePll;                             
            break;
        case BRAP_OutputPort_eDac0:
        case BRAP_OutputPort_eDac1:
        case BRAP_OutputPort_eDac2:                      
            *pPll = BRAP_RM_P_INVALID_INDEX;
            break;
        case BRAP_OutputPort_eMai:
            eMaiMuxSelect = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
            if(BRAP_OutputPort_eMax != eMaiMuxSelect)
            {
#if (BRAP_7405_FAMILY == 1)
                *pPll =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sMaiSettings.ePll; 
#else
                *pPll =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sSpdifSettings.ePll; 
#endif
            }
            break;
        case BRAP_OutputPort_eMaiMulti0:
        case BRAP_OutputPort_eMaiMulti1:
        case BRAP_OutputPort_eMaiMulti2:
        case BRAP_OutputPort_eMaiMulti3:   
            *pPll = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiMultiSettings.ePll;                  
            break;
        case BRAP_OutputPort_eFlex:
            break;
        default:
            BDBG_ERR(("BRAP_P_GetPllForOp:  Output port type %d not supported",
                    eOutputPort ));
            return BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);   
    }

    BDBG_MSG(("BRAP_P_GetPllForOp: Pll %d is associated with ouput port %d", *pPll, eOutputPort));

    BDBG_LEAVE (BRAP_P_GetPllForOp);        
    return ret;
}
#else /* For 7550 family only */
BERR_Code
BRAP_P_GetPllForOp(
	const BRAP_Handle 	    hRap,           /* [in] The RAP handle */
	const BRAP_OutputPort	eOutputPort,    /* [in] Output port */
    BRAP_OP_MClkRate        *eMClkRate      /* [out] The MCLK associated with 
                                               this output port */
    )
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_OutputPort eMaiMuxSelect = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_GetPllForOp);
    BDBG_ASSERT(hRap);
    BDBG_ASSERT(eMClkRate);
    
    /* Make sure  port is configured */
    if(hRap->bOpSettingsValid[eOutputPort] == false)    
    {
        BDBG_ERR(("BRAP_P_GetPllForOp: Output port %d is not configured. Please"
            " configure before calling this PI.", eOutputPort));
        return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
    }       

    switch(eOutputPort)
    {
        case BRAP_OutputPort_eSpdif:
        case BRAP_OutputPort_eSpdif1:
            *eMClkRate = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sSpdifSettings.eMClkRate;                            
            break;
        case BRAP_OutputPort_eDac0:
        case BRAP_OutputPort_eDac1:
        case BRAP_OutputPort_eDac2:                      
            *eMClkRate = BRAP_RM_P_INVALID_INDEX;
            break;
        case BRAP_OutputPort_eMai:
            eMaiMuxSelect = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiSettings.eMaiMuxSelector;
            if(BRAP_OutputPort_eMax != eMaiMuxSelect)
            {
#if (BRAP_7405_FAMILY == 1)
                *eMClkRate =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sMaiSettings.eMClkRate; 
#else
                *eMClkRate =  hRap->sOutputSettings[eMaiMuxSelect].
                                uOutputPortSettings.sSpdifSettings.eMClkRate; 
#endif
            }
            break;
        case BRAP_OutputPort_eMaiMulti0:
        case BRAP_OutputPort_eMaiMulti1:
        case BRAP_OutputPort_eMaiMulti2:
        case BRAP_OutputPort_eMaiMulti3:   
            *eMClkRate = hRap->sOutputSettings[eOutputPort].uOutputPortSettings.sMaiMultiSettings.eMClkRate;                  
            break;            
        case BRAP_OutputPort_eFlex:
            break;
        default:
            BDBG_ERR(("BRAP_P_GetPllForOp:  Output port type %d not supported",
                    eOutputPort ));
            return BERR_TRACE(BRAP_ERR_OUPUT_PORT_NOT_SUPPORTED);   
    }

    BDBG_MSG(("BRAP_P_GetPllForOp: eMClkRate %d is associated with ouput port %d", *eMClkRate, eOutputPort));

    BDBG_LEAVE (BRAP_P_GetPllForOp);        
    return ret;
}
#endif
/**************************************************************************
Summary:
    Private function that checks the compatibility between the HDMI and 
    its mux selector.
**************************************************************************/
BERR_Code BRAP_P_IsMaiAndMuxSelectorCompatible(
    BRAP_Handle                     hRap,
    BRAP_AssociatedChannelHandle    hAssociatedCh,     
    BRAP_DstDetails                 *pDstDetails    
    )
{
    BERR_Code                   ret = BERR_SUCCESS;
    BRAP_OutputPortDetails      *pMuxOpDetails = NULL;
    BRAP_OP_MaiSettings         *pMaiSettings = NULL;
    BRAP_DstDetails             *pTmpDstDetails = NULL;
    int i = 0;
    int j = 0;
    BRAP_ProcessingType        eAudioProcessing = BRAP_ProcessingType_eNone;
    
    BDBG_ENTER(BRAP_P_IsMaiAndMuxSelectorCompatible);

    if((BRAP_AudioDst_eOutputPort == pDstDetails->eAudioDst) && 
       (BRAP_OutputPort_eMai == pDstDetails->uDstDetails.sOpDetails.
                            eOutput[BRAP_OutputChannelPair_eLR]))
    {
        pMaiSettings = &(hRap->sOutputSettings[BRAP_OutputPort_eMai].
                                uOutputPortSettings.sMaiSettings);
        if(BRAP_OutputPort_eMai == pMaiSettings->eMaiMuxSelector)
        {
            /* HDMI taking data straight from mixer */
            BDBG_LEAVE(BRAP_P_IsMaiAndMuxSelectorCompatible);
            return BERR_SUCCESS;
        }

        /* Check if the mux selector output port is already added as destination 
           or not */
#if BRAP_P_MAI_NEEDS_MUX_SELECTOR
        if(BRAP_OutputPort_eMax == pMaiSettings->eMaiMuxSelector)
        {
            BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: eMaiMuxSelector not set"));
            return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);            
        }
#endif        
        if(BRAP_OutputPort_eMax != pMaiSettings->eMaiMuxSelector)
        {

            /* If MAI Mux Select is I2S_Multi0 or I2S_Multi1,then MAI and SPDIF1
               can not coexist in the system. Check and return error if so. */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[i].sExtDstDetails.eAudioDst) 
                {
                    for(j=0; j < BRAP_OutputChannelPair_eMax; j++)
                    {
                        if(((pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s0)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s1)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s2)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s3)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s5)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s6)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s7)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eI2s8)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti0)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti1)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti2)||
                            (pMaiSettings->eMaiMuxSelector == BRAP_OutputPort_eMaiMulti3)                           
                            )&&
                           (BRAP_OutputPort_eSpdif1 == 
                            hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails.eOutput[j]))
                        {
                            BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: SPDIF1 cannot co-exist"
                                      "with HDMI with Mux Select I2s_Multi0 or I2S_Multi1"));
                            return BERR_TRACE(BERR_NOT_SUPPORTED);
                        }
                        
                    }/* for j */
                }
            }/* for i */

        
            /* Check if the mux selector has already been added, else return */
            for(i=0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[i].sExtDstDetails.eAudioDst) 
                {
                    for(j=0; j < BRAP_OutputChannelPair_eMax; j++)
                    {
                        if(pMaiSettings->eMaiMuxSelector ==
                            hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails.eOutput[j])
                        {
                            /* matched, break from the j for loop */
                            pMuxOpDetails = &(hAssociatedCh->sDstDetails[i].sExtDstDetails.uDstDetails.sOpDetails);
                            pTmpDstDetails = &(hAssociatedCh->sDstDetails[i].sExtDstDetails);
                            break;
                        }
                    }/* for j */

                    if(j < BRAP_OutputChannelPair_eMax)
                    {
                        /* matched, break from the i for loop */
                        break;
                    }
                }
            }/* for i */

            if(i >= BRAP_P_MAX_DST_PER_RAPCH)
            {
                /* Mux selector has not been added, return with error */
                BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Add eMaiMuxSelector"
                    " before adding the HDMI output port"));
                return BERR_TRACE(BRAP_ERR_OUTPUT_NOT_CONFIGURED);
            }
            else
            {
                if((BRAP_OutputPort_eSpdif == pMaiSettings->eMaiMuxSelector)||
                   (BRAP_OutputPort_eSpdif1 == pMaiSettings->eMaiMuxSelector)) 
                {
                    /* Verify if Mai and mux-selector's settings are identical */
                    if((hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].bCompressed != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].bCompressed) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bProfessionalMode !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bProfessionalMode) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSwCopyRight !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSwCopyRight) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16CategoryCode !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16CategoryCode) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16ClockAccuracy != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16ClockAccuracy) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSeparateLRChanNum !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSeparateLRChanNum) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.uiCGMS_A!=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.uiCGMS_A) ||                        
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.bEnableDither != 
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.bEnableDither) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.eBurstType !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.eBurstType) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample))
                    {
                        BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match "
                            "in eMuxSelector(%d)and HDMI Settings: "
                            "\n\t bCompressed (%d, %d)"
                            "\n\t eOutputSR (%d, %d)"
                            "\n\t ChanStatusParams ((%d %d %d %d %d), (%d %d %d %d %d)"
                            "\n\t SpdifFmSettings ((%d %d), (%d, %d))"
                            "\n\t uiOpBitsPerSample (%d, %d)",
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].bCompressed,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].bCompressed, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bProfessionalMode, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSwCopyRight, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16CategoryCode, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.ui16ClockAccuracy, 
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bProfessionalMode,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSwCopyRight,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16CategoryCode,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.ui16ClockAccuracy,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdifChanStatusParams.bSeparateLRChanNum, 
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.bEnableDither,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].sSpdiffmSettings.eBurstType,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdifChanStatusParams.bSeparateLRChanNum,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.bEnableDither,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].sSpdiffmSettings.eBurstType,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample));
                        return BERR_TRACE(BERR_NOT_SUPPORTED);
                    }/* if sOutputSettings */                   
                }
                else if (BRAP_OutputPort_eMax != pMaiSettings->eMaiMuxSelector)
                {
                    /* Verify if Mai and mux-selector's settings are identical */
                    if((hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR) ||
                       (hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample !=
                        hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample))
                    {
                        BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match "
                            "in eMuxSelector(%d)and HDMI Settings: "
                            "\n\t eOutputSR (%d, %d)"
                            "\n\t uiOpBitsPerSample (%d, %d)",pMaiSettings->eMaiMuxSelector,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].eOutputSR,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].eOutputSR,
                            hRap->sOutputSettings[pMaiSettings->eMaiMuxSelector].uiOutputBitsPerSample,
                            hRap->sOutputSettings[BRAP_OutputPort_eMai].uiOutputBitsPerSample));
                        return BERR_TRACE(BERR_NOT_SUPPORTED);
                    }/* if sOutputSettings */                   
                }
                else
                {
                    /* Do nothing for now */
                }

                eAudioProcessing = hAssociatedCh->sDstDetails[i].eAudioProcessing;
                
                /* Verify if Mai and mux-selector's DstDetails are identical */
                if((pMuxOpDetails->bLfeOn != 
                        pDstDetails->uDstDetails.sOpDetails.bLfeOn) ||
                   (pMuxOpDetails->eAudioMode != 
                        pDstDetails->uDstDetails.sOpDetails.eAudioMode) ||
                   (hAssociatedCh->sDstDetails[i].eAudioProcessing != eAudioProcessing))
                {
                    BDBG_ERR(("BRAP_P_IsMaiAndMuxSelectorCompatible: Mis-match"\
                        " in sOpDetails between the eMuxSelector(%d) and HDMI:"
                        "\n\t bLfeOn (%d, %d)"
                        "\n\t eAudioMode (%d, %d)"
                        "\n\t eAudioProcessing (%d, %d)",
                        pMuxOpDetails->bLfeOn,
                        pDstDetails->uDstDetails.sOpDetails.bLfeOn,
                        pMuxOpDetails->eAudioMode,
                        pDstDetails->uDstDetails.sOpDetails.eAudioMode,
                        hAssociatedCh->sDstDetails[i].eAudioProcessing,
                        eAudioProcessing));
                    return BERR_TRACE(BERR_NOT_SUPPORTED);                
                }/* if DstDetails */
            }/* if i */
        }/* if eMaiMuxSelector */
    }/* if eAudioDst */
        
    BDBG_LEAVE(BRAP_P_IsMaiAndMuxSelectorCompatible);
    return ret;
}

bool BRAP_P_IsMaiFedByPath(BRAP_P_ObjectHandles *pPath)
{
    unsigned int i, j;
    bool bMaiFed = false;

    for (i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if ((pPath->pDstDetails[i]!=NULL)
            && (BRAP_AudioDst_eOutputPort==pPath->pDstDetails[i]->eAudioDst))
        {
            for (j = 0; j < BRAP_OutputChannelPair_eMax; j++)
            {
                if ( (BRAP_OutputPort_eMai==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
#if (BRAP_3548_FAMILY == 1)                    
                    ||(BRAP_OutputPort_eSpdif==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
#endif                    
                    )
                {
                    bMaiFed = true;
                    break;
                }
            }
        }
        if (true==bMaiFed)
            break;
    }
    return bMaiFed;
}

bool BRAP_P_IsDacFedByPath(BRAP_P_ObjectHandles *pPath)
{
    unsigned int i, j;
    bool bDacFed = false;

    for (i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        if ((pPath->pDstDetails[i]!=NULL)
            && (BRAP_AudioDst_eOutputPort==pPath->pDstDetails[i]->eAudioDst))
        {
            for (j = 0; j < BRAP_OutputChannelPair_eMax; j++)
            {
                if ( (BRAP_OutputPort_eDac0==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])  
                    ||(BRAP_OutputPort_eDac1==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
                    ||(BRAP_OutputPort_eDac2==pPath->pDstDetails[i]->uDstDetails.sOpDetails.eOutput[j])
                    )
                {
                    bDacFed = true;
                    break;
                }
            }
        }
        if (true==bDacFed)
            break;
    }
    return bDacFed;
}



BERR_Code BRAP_P_IsVolumeControlSupported(BRAP_Handle     hRap,
                BRAP_OutputPort eOpType,
                BRAP_ProcessingType eProcessingType
                )
{
    BERR_Code   ret = BERR_SUCCESS;
    uint32_t i=0,j=0;
	BDBG_ASSERT(hRap);
     
    for(i=0;i<BRAP_MAX_PP_SUPPORTED;i++)
    {
        if((hRap->hAudioProcessingStageHandle[i]!=NULL)&&
            (hRap->hAudioProcessingStageHandle[i]->sProcessingStageSettings.eAudioProcessing == eProcessingType))
        {
            for(j=0;j<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;j++)
            {                
                if((hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]!=NULL)&&
                (hRap->hAudioProcessingStageHandle[i]->hDestHandle[j]->sExtDstDetails. \
                uDstDetails.sOpDetails.eOutput[BRAP_OutputChannelPair_eLR] == eOpType))
                {
                    BDBG_ERR(("BTSC Encode post processing is added on DAC0. So Volume control cannot be done on DAC"));
            	    return BERR_TRACE (BERR_NOT_SUPPORTED);    
                }
            }
        }
    }
    return ret;
}

/**************************************************************************
Summary:
    Private function that checks if a destination or its sub-part is already
    present in the channel. Valid only for an output port destination.
**************************************************************************/
bool BRAP_P_IsDstAlreadyPresent(
    BRAP_Handle                     hRap,
    BRAP_AssociatedChannelHandle    hAssociatedCh,     
    BRAP_DstDetails                 *pDstDetails    
    )
{
    int             i = 0, j =0, k = 0;
    BRAP_OutputPort eOp = BRAP_OutputPort_eMax;
    
    BDBG_ENTER(BRAP_P_IsDstAlreadyPresent);
    
    if(BRAP_AudioDst_eOutputPort == pDstDetails->eAudioDst)
    {
        for(i=0; i<BRAP_OutputChannelPair_eMax; i++)
        {
            eOp = pDstDetails->uDstDetails.sOpDetails.eOutput[i];
            if(BRAP_OutputPort_eMax == eOp)
            {
                continue;
            }
            
            for(j=0; j<BRAP_P_MAX_DST_PER_RAPCH; j++)
            {
                if(BRAP_AudioDst_eOutputPort == hAssociatedCh->sDstDetails[j].sExtDstDetails.eAudioDst)
                {
                    for(k=0; k < BRAP_OutputChannelPair_eMax; k++)
                    {
                        if(eOp == hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.
                            sOpDetails.eOutput[k])
                        {                                   
                            BDBG_ERR (("BRAP_P_IsDstAlreadyPresent: Requested"
                                " output port %d is already used by this"
                                " association", eOp));
                            return true;                                    
                        }/* if eOp */

                        if((true == hRap->sOutputSettings[eOp].bHbrEnable)&&
                           (true == hRap->sOutputSettings[eOp].bCompressed)&&
                           (true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bCompressed))
                        {
                            BDBG_ERR(("No other compressed DST can be added in the system"
                                      "eOp=%d already present in compressed mode",
                                      hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]));
                            return true;
                        }

                        if((true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bHbrEnable)&&
                           (true == hRap->sOutputSettings[hAssociatedCh->sDstDetails[j].
                           sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]].bCompressed)&&
                           (true == hRap->sOutputSettings[eOp].bCompressed))
                        {
                            BDBG_ERR(("No other compressed DST can be added in the system"
                                      "eOp=%d already present in compressed mode",
                                      hAssociatedCh->sDstDetails[j].sExtDstDetails.uDstDetails.sOpDetails.eOutput[k]));
                            return true;
                        }
                           
                    }/* for k */
                }/* if eAudioDst */
            }/* for j */
        }/* for i */
    }
    else if(BRAP_AudioDst_eRingBuffer == pDstDetails->eAudioDst)
    {
        /* TODO */
        
    }
    else
    {
        /* TODO : Assert since the control should not come here */
        
    }/* if eAudioDst */
    
    BDBG_LEAVE(BRAP_P_IsDstAlreadyPresent);
    return false;
}

/***************************************************************************
Summary:
    Private function that programs the downmixing coefficients for a mixer    
**************************************************************************/
BERR_Code BRAP_P_ProgramDownMixCoefficients(
    BRAP_ChannelHandle          hRapCh,         /* [in] Rap channel Handle */
    unsigned int                uiPath
)
{
    BERR_Code                       ret=BERR_SUCCESS;
    unsigned int                    chPair = 0, i=0,pp=0;
    unsigned int                    lvl=0,inChp =0;
    BRAP_P_MixingLevelProp          *pMixingLvl = NULL;
    bool                            bDwmixEn = false;
    BRAP_MIXER_P_Handle             hMixer = NULL;
    BRAP_P_MixerCoefficientsInfo    sMixingInfo;
    BRAP_Handle                     hRap = hRapCh->hRap;
    BRAP_DownMixingCoef             sDnMixCoef;
    unsigned int                    m =0, n=0;
    bool                            bProgrammingDone = false;
    
    BDBG_ENTER(BRAP_P_ProgramDownMixCoefficients);
    BDBG_ASSERT(hRapCh);

    sDnMixCoef.eInputMode = BRAP_OutputMode_eLast;
    sDnMixCoef.eOutputMode = BRAP_OutputMode_eLast;
    sDnMixCoef.bInputLfePresent = false;
    sDnMixCoef.bOutputLfePresent = false;

    /* Invalid Init sMixingInfo structure */
    BKNI_Memset(&sMixingInfo, 0, sizeof(BRAP_P_MixerCoefficientsInfo));
    for(i=0; i<BRAP_RM_P_MAX_RSRCS_CONNECTED_TO_SAME_SRC; i++)
    {
        for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
        {
            sMixingInfo.uiMixerIp[i][chPair] = BRAP_INVALID_VALUE;
        }
    }
    if(uiPath >= BRAP_P_MAX_PATHS_IN_A_CHAN)
    {
        BDBG_ERR(("BRAP_P_ProgramDownMixCoefficients: Could not find DecPCM path"));
        return BERR_TRACE(BERR_NOT_SUPPORTED);
    }    

    for(lvl=0;lvl< BRAP_RM_P_MAX_MIXING_LEVELS; lvl++)
    {
        pMixingLvl = &(hRapCh->pPath[uiPath]->sMixingLevels[lvl]);
        
        if((0 != lvl)&&
           (BRAP_OutputMode_eLast != pMixingLvl->eInputAudMode)&&
           (BRAP_OutputMode_eLast != pMixingLvl->eOutputAudMode))
        {
            ret = BRAP_P_DecideDwnMixing(pMixingLvl->eInputAudMode,
                                             pMixingLvl->bInputLfeOn,
                                             pMixingLvl->eOutputAudMode,
                                             pMixingLvl->bOutputLfeOn,
                                             &bDwmixEn);
            BDBG_MSG(("BRAP_P_DecideDwnMixing: inMode %d outMode %d bDwnMixEn %d ",
                pMixingLvl->eInputAudMode,pMixingLvl->eOutputAudMode,bDwmixEn));
            if(BERR_SUCCESS != ret)
            {
                BDBG_ERR(("BRAP_P_DecideDwnMixing returned %d", ret));
                return BERR_TRACE(ret);
            }
            if(true == bDwmixEn)
            {
                for(i =0 ; i<BRAP_P_MAX_DOWN_MIX_COEFF; i++)
                {
                    BDBG_MSG(("hRap->sDnMixCoeff[i=%d].eInputMode=%d"
                              "hRap->sDnMixCoeff[i].eOutputMode=%d"
                              "pMixingLvl->eInputAudMode=%d"
                              "pMixingLvl->eOutputAudMode=%d"
                              "hRap->sDnMixCoeff[i].bInputLfePresent=%d"
                              "hRap->sDnMixCoeff[i].bOutputLfePresent=%d"
                              "pMixingLvl->bInputLfeOn=%d"
                              "pMixingLvl->bOutputLfeOn=%d",
                              i,hRap->sDnMixCoeff[i].eInputMode,
                              hRap->sDnMixCoeff[i].eOutputMode,
                              pMixingLvl->eInputAudMode,
                              pMixingLvl->eOutputAudMode,
                              hRap->sDnMixCoeff[i].bInputLfePresent,
                              hRap->sDnMixCoeff[i].bOutputLfePresent,
                              pMixingLvl->bInputLfeOn,
                              pMixingLvl->bOutputLfeOn));

                    if((hRap->sDnMixCoeff[i].eInputMode == pMixingLvl->eInputAudMode)&&
                       (hRap->sDnMixCoeff[i].eOutputMode == pMixingLvl->eOutputAudMode)&&
                       (hRap->sDnMixCoeff[i].bInputLfePresent == pMixingLvl->bInputLfeOn)&&
                       (hRap->sDnMixCoeff[i].bOutputLfePresent== pMixingLvl->bOutputLfeOn))
                    {
                        sDnMixCoef = hRap->sDnMixCoeff[i];
                        break;
                    }
                }

                if(BRAP_OutputMode_eLast == sDnMixCoef.eInputMode)
                {
                    BDBG_ERR(("Coefficients not available for requested downmix"));
                    BDBG_ASSERT(0);
                }
                
                for(chPair =0 ; chPair < BRAP_OutputChannelPair_eMax; chPair++)
                {
                    for(pp=0;pp<BRAP_RM_P_MAX_PARALLEL_PATHS;pp++)
                    {
                        if (true == hRapCh->pPath[uiPath]->sMixer[lvl][chPair][pp].bValid)
                        {
                            hMixer = hRapCh->pPath[uiPath]->sMixer[lvl][chPair][pp].hMixer;
                            sMixingInfo.hMixer[0] = hMixer;

                            for(inChp =0;inChp<BRAP_OutputChannelPair_eMax;inChp++)
                            {
                                sMixingInfo.uiMixerIp[0][inChp] = 
                                hRapCh->pPath[uiPath]->sRsrcGrnt.sSrcMixerGrnt[lvl].
                                    sMixerGrant[chPair][pp].uiMixerInputId[inChp];

                                switch(chPair)
                                {
                                    case BRAP_OutputChannelPair_eLR:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=0; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=0; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=0; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=0; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;

                                     case BRAP_OutputChannelPair_eLRSurround:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=2; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=2; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=2; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=2; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;

                                     case BRAP_OutputChannelPair_eCentreLF:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=4; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=4; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=4; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=4; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;
                                        
                                     case BRAP_OutputChannelPair_eLRRear:
                                        switch(inChp)
                                        {
                                            case BRAP_OutputChannelPair_eLR:
                                                m=6; n=0;
                                                break;
                                            case BRAP_OutputChannelPair_eLRSurround:
                                                m=6; n=2;
                                                break;
                                            case BRAP_OutputChannelPair_eCentreLF:
                                                m=6; n=4;
                                                break;
                                            case BRAP_OutputChannelPair_eLRRear:
                                                m=6; n=6;
                                                break;
                                            case BRAP_OutputChannelPair_eMax:
                                            default:
                                                BDBG_ASSERT(0);
                                        }
                                        break;
                                     default:
                                        BDBG_ASSERT(0);
                                }
                                if((BRAP_OutputMode_e3_2 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e2_0 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef5_1To2_0[(m+1)][(n+1)];
                                }
                                else if((BRAP_OutputMode_e3_4 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e2_0 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To2_0[(m+1)][(n+1)];
                                }
                                else if((BRAP_OutputMode_e3_4 == sDnMixCoef.eInputMode)&&
                                   (BRAP_OutputMode_e3_2 == sDnMixCoef.eOutputMode))
                                {
                                    sMixingInfo.sCoeff0[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[m][n];
                                    sMixingInfo.sCoeff0[0][inChp].ui32Right =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[m][(n+1)];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Left  =
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[(m+1)][n];
                                    sMixingInfo.sCoeff1[0][inChp].ui32Right = 
                                        sDnMixCoef.uDnCoeff.ui32DnCoef7_1To5_1[(m+1)][(n+1)];
                                }
                                BDBG_MSG(("InputChp=%d, OutputChp=%d, m=%d,n=%d",chPair,inChp,m,n));
                                BDBG_MSG(("LeftCoeff0=0x%x, RightCoeff0=0x%x, LeftCoeff1=0x%x,RightCoeff1=0x%x",
                                  sMixingInfo.sCoeff0[0][inChp].ui32Left,sMixingInfo.sCoeff0[0][inChp].ui32Right,
                                  sMixingInfo.sCoeff1[0][inChp].ui32Left,sMixingInfo.sCoeff1[0][inChp].ui32Right));
                            }/* For inChp */

                            /* Call the Mixer API to program the coeffients for this 
                               channel pair */
                            ret = BRAP_MIXER_P_ProgramPingPongCoeff(&sMixingInfo,
                                                                    &bProgrammingDone);
                            if(BERR_SUCCESS != ret)
                            {
                                BDBG_ERR(("BRAP_P_ProgramCoefficients: Returned Error"));
                                return BERR_TRACE(ret);
                            }
                        }/* if bValid */
                    }/* for pp */
                }/* for chPair */
            }/* if bDwmixEn */
        }/* if eInputAudMode */
    }/* for lvl */
    BDBG_LEAVE(BRAP_P_ProgramDownMixCoefficients);
    return ret;
}

/**************************************************************************
Summary:
    Private function that returns the output sampling rate for the output 
    port(s) carried in pOpDetails.
**************************************************************************/
BAVC_AudioSamplingRate 
BRAP_P_GetSRFromOpDetails(
    BRAP_ChannelHandle      hRapCh,
    BRAP_OutputPortDetails  *pOpDetails
    )
{
    BAVC_AudioSamplingRate eSR = BAVC_AudioSamplingRate_eUnknown;
    BRAP_OutputPort eOp = BRAP_OutputPort_eMax;
    BRAP_OutputChannelPair eChP = BRAP_OutputChannelPair_eMax;
    
    BDBG_ENTER(BRAP_P_GetSRFromOpDetails);
    BDBG_ASSERT(pOpDetails);
    BDBG_ASSERT(hRapCh);
    
    for(eChP = 0; eChP < BRAP_OutputChannelPair_eMax; eChP++)
    {
        eOp = pOpDetails->eOutput[eChP];
        if(BRAP_OutputPort_eMax != eOp)
        {
            /* Got the output port */
            break;
        }
    }

    /* Get the corresponding sampling rate */
    if(eOp != BRAP_OutputPort_eMax)
    {
       eSR = hRapCh->hRap->sOutputSettings[eOp].eOutputSR;
    }

    BDBG_LEAVE(BRAP_P_GetSRFromOpDetails);
    return eSR;

}


#if (BRAP_OPEN_TIME_RBUF_ALLOCATION==1)

/***************************************************************************
Summary:
   This Funtion allocates device specific Rbuf Memory as per the settings
   provided in the device handle. 
***************************************************************************/
BERR_Code
BRAP_P_AllocateDeviceRBufPool(
    BRAP_Handle hRap
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    i = 0, j = 0,k=0;
    BRAP_P_RBufMem  *pRBufMem = NULL;
    BRAP_P_RBufMem  sRBufMem;
    size_t          uiSize = 0;
    void *cacheAddr=NULL;    
    unsigned int uiNumHbrBuf=0;
        
    BDBG_ENTER(BRAP_P_AllocateDeviceRBufPool);

    /* pExtRBufPoolSettings */
    hRap->sDeviceRBufPool.pExtRBufPoolSettings = &(hRap->sSettings.sDeviceRBufPool);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    for(i=0; i < BRAP_ProcessingType_eMax; i++)
    {
        for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
        {
            hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        hRap->sDeviceRBufPool.sInputBuffer[i]= sRBufMem;
    }
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {    
        hRap->sDeviceRBufPool.sOutputBuffer[i] = sRBufMem;
    }


    for (i = 0; i < BRAP_NUM_HBR_BUFFERS; i++)
    {
        hRap->sDeviceRBufPool.sHbrRBuf[i] = sRBufMem;
    }

        /* Validate */
    if(hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers > BRAP_MAX_DEVICE_INPUT_BUFFER)
    {
        BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumInputBuffer=%d "
                    "exceeds max permissible %d",
        hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers,
        BRAP_MAX_DEVICE_INPUT_BUFFER));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto free;
    }

    if(hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers > BRAP_MAX_DEVICE_OUTPUT_BUFFER)
    {
        BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumOutputBuffer=%d "
                    "exceeds max permissible %d",
        hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers,
        BRAP_MAX_DEVICE_OUTPUT_BUFFER));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto free;
    }

    /* Note: Every audio processing can have different rbuf size requirements */
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
    uiSize = BRAP_RBUF_P_DEFAULT_DELAY_RBUF_SIZE;
#else
    uiSize = BRAP_RBUF_P_DEFAULT_SIZE; 
#endif

    for(j = 0; j < hRap->sSettings.sDeviceRBufPool.uiNumPostMixingInputBuffers; j++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sInputBuffer[j]);

        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }

        /* Update size */
        pRBufMem->uiSize = uiSize;

        /* Mark as free */
        pRBufMem->bUsed = false;
    } /* for j */

    for(j = 0; j < hRap->sSettings.sDeviceRBufPool.uiNumPostMixingOutputBuffers; j++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sOutputBuffer[j]);

        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        /* Update size */
        pRBufMem->uiSize = uiSize;

        /* Mark as free */
        pRBufMem->bUsed = false;
    } /* for j */            


    /* sDestRBuf */
    for(i = 0,k=0; i < BRAP_OutputChannelPair_eMax; i++)
    {
        if(0 == hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i])
        {
            continue;
        }
            
        /* Validate */
        if(hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i] > 
            BRAP_RM_P_MAX_RBUFS_PER_DSTCH)
        {
            BDBG_ERR(("BRAP_P_AllocateDeviceRBufPool: uiMaxNumOutChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i],
                BRAP_RM_P_MAX_RBUFS_PER_DSTCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }
		pRBufMem = &(hRap->sDeviceRBufPool.sDestRBuf[k++]);
        uiSize = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].uiSize; 
	    uiSize = (uiSize == 0) ? BRAP_RBUF_P_DEFAULT_SIZE : uiSize;
        if(hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pLeftBufferStart != NULL)
        {
            pRBufMem->pRBufPtr = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pLeftBufferStart;
        }
        else
        {
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
        }
        pRBufMem->uiSize = uiSize;
        pRBufMem->bUsed = false;
        BMEM_Heap_ConvertAddressToCached(hRap->hHeap, pRBufMem->pRBufPtr,(void **)&cacheAddr);
        BMEM_Heap_FlushCache(hRap->hHeap,cacheAddr, uiSize);
        if(hRap->sSettings.sDeviceRBufPool.uiMaxNumRBuf[i] == BRAP_RM_P_MAX_RBUFS_PER_DSTCH)
        {
   			pRBufMem = &(hRap->sDeviceRBufPool.sDestRBuf[k++]);
            if(hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pRightBufferStart != NULL)
            {
                pRBufMem->pRBufPtr = hRap->sSettings.sDeviceRBufPool.sDstBufSettings[i].pRightBufferStart;
            }
            else
            {
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
            }
			pRBufMem->uiSize = uiSize;
	        pRBufMem->bUsed = false;
            BMEM_Heap_ConvertAddressToCached(hRap->hHeap, pRBufMem->pRBufPtr,(void **)&cacheAddr);
            BMEM_Heap_FlushCache(hRap->hHeap,cacheAddr, uiSize);            
        }
    }

    if(true==hRap->sSettings.sDeviceRBufPool.bHbrMode)
    {
        uiNumHbrBuf += BRAP_NUM_BUFFER_FOR_DDP_PASSTHRU;
    }
#ifdef RAP_BTSC_SUPPORT
    uiNumHbrBuf += BRAP_NUM_BUFFER_FOR_BTSC;
#endif
    for (i = 0; i < uiNumHbrBuf; i++)
    {
        pRBufMem = &(hRap->sDeviceRBufPool.sHbrRBuf[i]);
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
        pRBufMem->pRBufPtr = (void *) BRAP_P_AllocAligned(hRap, BRAP_P_HBR_DELAY_RBUF_SIZE, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        pRBufMem->uiSize = BRAP_P_HBR_DELAY_RBUF_SIZE;
        pRBufMem->bUsed = false;
#else
        pRBufMem->pRBufPtr = (void *) BRAP_P_AllocAligned(hRap, BRAP_P_HBR_RBUF_SIZE, 8, 0);
        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
        {
            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
            goto free;
        }
        pRBufMem->uiSize = BRAP_P_HBR_RBUF_SIZE;
        pRBufMem->bUsed = false;
#endif            
    }
    
    if(BERR_SUCCESS == ret)
        goto exit;
    
free:
    BRAP_P_FreeDeviceRBufPool(hRap);
    
exit:

    /* Debugging messages */
    BDBG_MSG(("\n\n Device Memory Allocation Details ::"));
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        BDBG_MSG(("\n sInputBuffer[%d]:",i));
        if(hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr)
        {
            BDBG_MSG(("\n\t\t sInRBuf[%d].pLeftRBufPtr = %p"
                "\n\t\t sInRBuf[].bUsed = %d"
                "\n\t\t sInRBuf[].uiSize = %d",i,
            hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr,
            hRap->sDeviceRBufPool.sInputBuffer[i].bUsed,
            hRap->sDeviceRBufPool.sInputBuffer[i].uiSize));
        }
    }
    
    for(i=0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {        
        if(hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr)
        {
            BDBG_MSG(("\n\t\t sOutRBuf[%d].pLeftRBufPtr = %p"
                "\n\t\t sOutRBuf[].bUsed = %d"
                "\n\t\t sOutRBuf[].uiSize = %d",i,
            hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr,
            hRap->sDeviceRBufPool.sOutputBuffer[i].bUsed,
            hRap->sDeviceRBufPool.sOutputBuffer[i].uiSize));
        }
    }/* for i */
    
    for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
    {
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr)
        {
            BDBG_MSG(("\tsDestRBuf[%d]:"
                "\n\t\t sDestRBuf[].pLeftRBufPtr = %p"
                "\n\t\t sDestRBuf[].bUsed = %d"
                "\n\t\t sDestRBuf[].uiSize = %d", j,
            hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr,
            hRap->sDeviceRBufPool.sDestRBuf[j].bUsed,
            hRap->sDeviceRBufPool.sDestRBuf[j].uiSize));       
        }
    }/* for j */
    
    for (j = 0; j < uiNumHbrBuf; j++)
    {
        if(hRap->sDeviceRBufPool.sHbrRBuf[j].pRBufPtr)
        {
            BDBG_MSG(("\tsDestRBuf[%d]:"
                "\n\t\t sHbrRBuf[].pLeftRBufPtr = %p"
                "\n\t\t sHbrRBuf[].bUsed = %d"
                "\n\t\t sHbrRBuf[].uiSize = %d", j,
            hRap->sDeviceRBufPool.sHbrRBuf[j].pRBufPtr,
            hRap->sDeviceRBufPool.sHbrRBuf[j].bUsed,
            hRap->sDeviceRBufPool.sHbrRBuf[j].uiSize));       
        }
    }/* for j */        

    
    BDBG_LEAVE(BRAP_P_AllocateDeviceRBufPool);
    return ret;
}

/***************************************************************************
Summary:
   This Funtion frees device specific Rbuf Memory.
***************************************************************************/
void
BRAP_P_FreeDeviceRBufPool(
    BRAP_Handle hRap
    )
{
    unsigned int    i = 0, j = 0;
    BRAP_P_RBufMem  sRBufMem;
        
    BDBG_ENTER(BRAP_P_FreeDeviceRBufPool);
    BDBG_ASSERT(hRap);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    
    /* sInRBuf */    
    for(i=0; i < BRAP_MAX_DEVICE_INPUT_BUFFER; i++)
    {
        if(hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr != NULL)
        {
            BRAP_P_Free(hRap,
            hRap->sDeviceRBufPool.sInputBuffer[i].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sInputBuffer[i] = sRBufMem;          
    }
    /* sOutRBuf */
    for(i = 0; i < BRAP_MAX_DEVICE_OUTPUT_BUFFER; i++)
    {  
        if(hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr != NULL)
        {
            BRAP_P_Free(hRap,
            hRap->sDeviceRBufPool.sOutputBuffer[i].pRBufPtr);                
        }
        hRap->sDeviceRBufPool.sOutputBuffer[i] = sRBufMem;            

    }/* for i */
            
	for(j = 0; j < BRAP_OutputChannelPair_eMax*2; j++)
    {
            /* sDestRBuf */
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr != NULL
			&& hRap->sSettings.sDeviceRBufPool.sDstBufSettings[j/2].pLeftBufferStart == NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;

        j++;
        if(j >= BRAP_OutputChannelPair_eMax*2)
        {
            BDBG_ERR(("j should be less than %d",BRAP_OutputChannelPair_eMax*2));        
            return;
        }
        if(hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr != NULL
			&& hRap->sSettings.sDeviceRBufPool.sDstBufSettings[j/2].pRightBufferStart == NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sDestRBuf[j].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sDestRBuf[j] = sRBufMem;
	}

    for (i=0; i < BRAP_NUM_HBR_BUFFERS; i++)
    {
        if (hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr!=NULL)
        {
            BRAP_P_Free(hRap,hRap->sDeviceRBufPool.sHbrRBuf[i].pRBufPtr);
        }
        hRap->sDeviceRBufPool.sHbrRBuf[i] = sRBufMem;
    }
	
    /* pExtRBufPoolSettings */
    hRap->sDeviceRBufPool.pExtRBufPoolSettings = NULL; /*will doing like this free the memory??? */

    BDBG_LEAVE(BRAP_P_FreeDeviceRBufPool);
    return;
}

/***************************************************************************
Summary:
   This Funtion allocates channel specific Rbuf Memory as per the settings 
   provided in the channel handle.   
***************************************************************************/
BERR_Code
BRAP_P_AllocateChannelRBufPool(
    BRAP_ChannelHandle hRapCh
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    i = 0, j = 0,k=0;
    BRAP_P_RBufMem  *pRBufMem = NULL;
    BRAP_P_RBufMem  sRBufMem;
    bool            bAllocateBothLR = false;
    size_t          uiSize = 0;
        
    BDBG_ENTER(BRAP_P_AllocateChannelRBufPool);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRBufMem;
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRBufMem;
        }/* for j */
    }/* for i */
	
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
    	hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;
    }/* for i */

  	/* sDecOutRBuf */
    for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        /* Validate */
        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i] > 
            BRAP_MAX_OUT_CHPAIRS_PER_FW_PROC_BRANCH)
        {
            BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumOutChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i],
                BRAP_MAX_OUT_CHPAIRS_PER_FW_PROC_BRANCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }

         /* Incoming channel pairs for an audio processing type */
        bAllocateBothLR = true;

        /* Note: Every audio processing can have different rbuf size requirements */
        if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
        {
            uiSize = BRAP_PB_P_RBUF_DEFAULT_SIZE;
        }
        else
        {
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1)
            if(true == hRapCh->bIndepDelayEnabled)
            {
        	    uiSize = BRAP_RBUF_P_DEFAULT_DELAY_RBUF_SIZE;
            }
            else
            {
    	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
        }
#else
       	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
#endif
        }
         

        for(j = 0,k=0; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumOutChPairs[i]; j++)
        {
            pRBufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[i][k++]);

            /* Allocate Left */
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
            /* Update size */
            pRBufMem->uiSize = uiSize;

            /* Mark as free */
            pRBufMem->bUsed = false;
			
            if(true == bAllocateBothLR)
            {
            	pRBufMem = &(hRapCh->sChanRBufPool.sDecOutRBuf[i][k++]);
                /* Allocate Right */
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
			    /* Update size */
	            pRBufMem->uiSize = uiSize;

	            /* Mark as free */
	            pRBufMem->bUsed = false;
            }/* if bAllocateBothLR */
        }/* for j */
    }/* for i */

    /* sDecInRBuf */
    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        /* Validate */
        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i] > 
            BRAP_MAX_IN_CHPAIRS_PER_FW_PROC_BRANCH)
        {
            BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumInChPairs[%d]=%d "
                "exceeds max permissible %d",i,
                hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i],
                BRAP_MAX_IN_CHPAIRS_PER_FW_PROC_BRANCH));
            ret = BERR_TRACE(BERR_NOT_SUPPORTED);
            goto free;
        }

         /* Incoming channel pairs for an audio processing type */
        bAllocateBothLR = true;

        /* Note: Every audio processing can have different rbuf size requirements */
        if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
        {
            uiSize = BRAP_PB_P_RBUF_DEFAULT_SIZE;
        }
        else
        {
    	    uiSize = BRAP_RBUF_P_DEFAULT_SIZE;
        } 

        for(j = 0,k=0; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumInChPairs[i]; j++)
        {
            pRBufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[i][k++]);

            /* Allocate Left */
            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
            {
                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                goto free;
            }
            /* Update size */
            pRBufMem->uiSize = uiSize;

            /* Mark as free */
            pRBufMem->bUsed = false;
			
            if(true == bAllocateBothLR)
            {
   	            pRBufMem = &(hRapCh->sChanRBufPool.sDecInRBuf[i][k++]);
                /* Allocate Right */
                pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
                if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
                {
                    ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
                    goto free;
                }
	            /* Update size */
	            pRBufMem->uiSize = uiSize;

	            /* Mark as free */
	            pRBufMem->bUsed = false;
				
            }/* if bAllocateBothLR */
        }/* for j */
    }/* for i */

    /* sPbRBuf */	
    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf != 0)
    {
	    /* Validate */
	    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf > 
	        BRAP_P_MAX_RBUF_PER_PBCH)
	    {
	        BDBG_ERR(("BRAP_P_AllocateChannelRBufPool: uiMaxNumOutChPairs[%d]=%d "
	            "exceeds max permissible %d",i,
	            hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf,
	            BRAP_P_MAX_RBUF_PER_PBCH));
	        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
	        goto free;
	    }

		for(j = 0 ; j < hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf; j++)
	    {
		    pRBufMem = &(hRapCh->sChanRBufPool.sPbRBuf[j]);
		    uiSize = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.uiSize; 
            if(BRAP_ChannelType_ePcmPlayback == hRapCh->eChannelType)
            {
                uiSize = (uiSize == 0) ? BRAP_PB_P_RBUF_DEFAULT_SIZE : uiSize;
            }
            else
            {
        	    uiSize = (uiSize == 0) ? BRAP_RBUF_P_DEFAULT_SIZE : uiSize;
            }
		    
		    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart != NULL)
		    {
		        pRBufMem->pRBufPtr = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart;
		    }
		    else
		    {
		        pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
		        if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
		        {
		            ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
		            goto free;
		        }
		    }

   		    pRBufMem->uiSize = uiSize;
		    pRBufMem->bUsed = false;

/* What is the purpose of this code? Is it required?
   Todo: Remove after found unharmful. */            
#if 0
			/*j++;*/
		    if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.uiMaxNumRBuf == BRAP_P_MAX_RBUF_PER_PBCH)
		    {
 		    	pRBufMem = &(hRapCh->sChanRBufPool.sPbRBuf[j]);
		        if(hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart != NULL)
		        {
		            pRBufMem->pRBufPtr = hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart;
		        }
		        else
		        {
		            pRBufMem->pRBufPtr = (void *)BRAP_P_AllocAligned(hRapCh->hRap, uiSize, 8, 0);
		            if(pRBufMem->pRBufPtr == (void *) BRAP_P_INVALID_DRAM_ADDRESS)
		            {
		                ret = BERR_TRACE (BERR_OUT_OF_DEVICE_MEMORY);
		                goto free;
		            }
		        }
			    pRBufMem->uiSize = uiSize;
			    pRBufMem->bUsed = false;
		    }
#endif
		}
    }
    if(BERR_SUCCESS == ret)
        goto exit;
    
free:
    BRAP_P_FreeChannelRBufPool(hRapCh);
    
exit:

    /* Debugging messages */
	BDBG_MSG(("\n\n Channel Memory Allocation Details ::"));
	for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        BDBG_MSG(("\tsDecOutRBuf[%d]:",i));
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            if(hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr)
            {
    			BDBG_MSG(("\n\t\t sDecOutRBuf[%d][%d].pRBufPtr = %p"
    			"\n\t\t sDecOutRBuf[][].bUsed = %d"
    			"\n\t\t sDecOutRBuf[][].uiSize = %d",i,j,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].bUsed,
    			hRapCh->sChanRBufPool.sDecOutRBuf[i][j].uiSize));
            }
        }/* for j */
    }/* for i */

    for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
            BDBG_MSG(("\tsDecInRBuf[%d]:",i));
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            if(hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr)
            {
			BDBG_MSG(("\n\t\t sDecInRBuf[%d][%d].pRBufPtr = %p"
			"\n\t\t sDecInRBuf[][].bUsed = %d"
			"\n\t\t sDecInRBuf[][].uiSize = %d",i,j,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].bUsed,
			hRapCh->sChanRBufPool.sDecInRBuf[i][j].uiSize));
            }
        }/* for j */
    }/* for i */
	
    for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
        if(hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr)
        {
		BDBG_MSG(("\n\t\t sPbRBuf[%d].pLeftRBufPtr = %p"
		"\n\t\t sPbRBuf[].bUsed = %d"
		"\n\t\t sPbRBuf[].uiSize = %d",i,
		hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr,
		hRapCh->sChanRBufPool.sPbRBuf[i].bUsed,
		hRapCh->sChanRBufPool.sPbRBuf[i].uiSize));
        }
    }/* for i */

    BDBG_LEAVE(BRAP_P_AllocateChannelRBufPool);
    return ret;
}

/***************************************************************************
Summary:
   This Funtion frees channel specific Rbuf Memory.
***************************************************************************/
void
BRAP_P_FreeChannelRBufPool(
    BRAP_ChannelHandle hRapCh
    )
{
	unsigned int    i = 0, j = 0;
    BRAP_P_RBufMem  sRBufMem;
        
    BDBG_ENTER(BRAP_P_FreeChannelRBufPool);
    BDBG_ASSERT(hRapCh);

    /* Invalid init */
    sRBufMem.bUsed = false;
    sRBufMem.pRBufPtr = NULL;
    sRBufMem.uiSize = 0;
    
   for(i=0; i < BRAP_MAX_FW_PROC_BRANCHES; i++)
    {
        for(j = 0; j < BRAP_MAX_OUT_CH_PER_FW_PROC_BRANCH; j++)
        {
            /* sDecOutRBuf */
            if(hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr != NULL)
            {
                BRAP_P_Free(hRapCh->hRap,
                    hRapCh->sChanRBufPool.sDecOutRBuf[i][j].pRBufPtr);
            }
            hRapCh->sChanRBufPool.sDecOutRBuf[i][j] = sRBufMem;            
        
        }/* for j */
    }/* for i */

	for(i=0; i < BRAP_MAX_DEC_CHAN_WITH_CAPPORT_SOURCE; i++)
    {
        for(j = 0; j < BRAP_MAX_IN_CH_PER_FW_PROC_BRANCH; j++)
        {
            /* sDecInRBuf */
            if(hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr != NULL)
            {
                BRAP_P_Free(hRapCh->hRap,
                    hRapCh->sChanRBufPool.sDecInRBuf[i][j].pRBufPtr);
            }
            hRapCh->sChanRBufPool.sDecInRBuf[i][j] = sRBufMem;            
        
        }/* for j */
    }/* for i */
	
	for(i=0; i < BRAP_P_MAX_RBUF_PER_PBCH; i++)
    {
	 /* sDecInRBuf */
        if((hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr != NULL )
			&& (hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pLeftBufferStart == NULL))
        {
            BRAP_P_Free(hRapCh->hRap,
                hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr);
        }
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;

		i++;
		if((hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr != NULL )
			&& (hRapCh->sChanRBufPool.sExtRBufPoolSettings.sBufSettings.pRightBufferStart == NULL))
        {
            BRAP_P_Free(hRapCh->hRap,
                hRapCh->sChanRBufPool.sPbRBuf[i].pRBufPtr);
        }
        hRapCh->sChanRBufPool.sPbRBuf[i] = sRBufMem;
		
    }/* for i */
	
    /* pExtRBufPoolSettings */

    BDBG_LEAVE(BRAP_P_FreeChannelRBufPool);
    return;
}

#endif /* OPEN_TIME_RBUF_ALLOCATION */


/**************************************************************************
Summary:
    Private function that mallocs and invalid inits the pPath data structure.
**************************************************************************/
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION
BERR_Code
BRAP_P_MallocPath(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    uint32_t uiPth,     /* [in] */
    BRAP_P_ObjectHandles **pPath /* [out] */    
    )
#else
BERR_Code
BRAP_P_MallocPath(
    BRAP_P_ObjectHandles **pPath /* [out] */
    )
#endif    
{
    BERR_Code               ret = BERR_SUCCESS;
    BRAP_P_ObjectHandles    *pTempPath = NULL; 
    BRAP_P_SrcHandleInfo    sSrcInfo;
    BRAP_P_SrcEqHandleInfo  sSrcEqInfo;
    int i=0, j=0, k=0;
    
    BDBG_ENTER(BRAP_P_MallocPath);
    BDBG_ASSERT(pPath);

    *pPath = NULL;
#ifdef BRAP_OPEN_TIME_PATH_ALLOCATION        
    pTempPath = hRapCh->pMemPath[uiPth];
#else    
    /* Malloc path handle */
    pTempPath = (BRAP_P_ObjectHandles *)BKNI_Malloc(sizeof(BRAP_P_ObjectHandles));
    if(NULL == pTempPath)
    {
        BDBG_ERR(("pPath malloc failed"));
		return BERR_TRACE( BERR_OUT_OF_SYSTEM_MEMORY );
    }
    BKNI_Memset(pTempPath , 0, sizeof(BRAP_P_ObjectHandles));  
#endif
    /* RM Grant */
    BRAP_RM_P_InitResourceGrant(&(pTempPath->sRsrcGrnt),true);
    for(i = 0; i < BRAP_RM_P_MAX_SRC_IN_CASCADE; i++)
    {
        BRAP_P_InitSrcHandleInfo(&sSrcInfo, i);    
        BRAP_P_InitSrcEqHandleInfo (&sSrcEqInfo, i);
    }
    /* Invalid Init */
    pTempPath->eUsgPath = BRAP_P_UsgPath_eMax;
    pTempPath->uiDestcount = 0;
    
    for (i=0;i<BRAP_P_MAX_IN_PARALLEL_FMM_PATH;i++)
    {
        pTempPath->sInPathProp[i].uiPathIdx = BRAP_INVALID_VALUE;
    }

    pTempPath->uiSelfPathArrIdx = BRAP_INVALID_VALUE;

    for (i=0;i<BRAP_P_MAX_OUT_PARALLEL_FMM_PATH;i++)
    {
        pTempPath->sOutPathProp[i].uiPathIdx = BRAP_INVALID_VALUE;
    }

    pTempPath->uiPthOpenCnt = 0;
    pTempPath->uiPthStartCnt = 0;
    
	pTempPath->hFmm = NULL;
    pTempPath->hDsp = NULL;
    pTempPath->hDspCh = NULL;
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNELS; i++)
    {
        pTempPath->hRBuf[i] = NULL;	
    }
    for(i = 0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        BRAP_P_InitSrcChHandleInfo(&(pTempPath->sSrcCh[i]));
        BRAP_P_InitDstChHandleInfo(&(pTempPath->sDstCh[i]));
    }
    for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
    {
        for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
        {
            for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
            {
                pTempPath->sSrc[i][j][k] = sSrcInfo;
                BRAP_P_InitMixerHandleInfo(&(pTempPath->sMixer[i][j][k]));
            }
        }
    }
    for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
    {
        for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
        {
            pTempPath->sSrcEq[j][k] = sSrcEqInfo;
        }
    }
    for(j = 0; j < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; j++)
    {
        for(k = 0; k < BRAP_RM_P_MAX_PARALLEL_PATHS; k++)
        {
            BRAP_P_InitOpHandleInfo(&(pTempPath->sOp[j][k]));
            BRAP_P_InitCapPortHandleInfo(&(pTempPath->sCapPort[j][k]));
        }
    }
    for(i = 0; i < BRAP_RM_P_MAX_MIXING_LEVELS; i++)
    {
        pTempPath->sMixingLevels[i] = sMixingLevelPropInvalid;
    }
    for(i = 0; i < BRAP_P_MAX_DST_PER_RAPCH; i++)
    {
        pTempPath->pDstDetails[i] = NULL;
    }
    pTempPath->uiAssocId = BRAP_INVALID_VALUE;
#if (BRAP_INDEP_OP_DELAY_SUPPORTED == 1) 
    pTempPath->uiMasterpathId = BRAP_INVALID_VALUE;
#endif
    /* Populate return handle */
    *pPath = pTempPath;    

    BDBG_LEAVE(BRAP_P_MallocPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that frees the pPath data structure. It returns the NULL
    pPath.
**************************************************************************/
void
BRAP_P_FreePath(
    BRAP_P_ObjectHandles **pPath /* [in] */
    )
{
    BDBG_ENTER(BRAP_P_FreePath);
    BDBG_ASSERT(pPath);
#ifndef BRAP_OPEN_TIME_PATH_ALLOCATION        
    BKNI_Free(*pPath);
#endif
    *pPath = NULL;

    BDBG_LEAVE(BRAP_P_FreePath);
    return;
}


/**************************************************************************
Summary:
    Private function that gets the current channel settings.
**************************************************************************/
BERR_Code
BRAP_P_GetCurrentChannelSettings (
	BRAP_ChannelHandle	    hRapCh,         /* [in] Decode channel handle */
	BRAP_ChannelSettings    *pChanSettings  /* [out] Current channel settings */
	)
{
    BERR_Code ret = BERR_SUCCESS;
    BDBG_ENTER(BRAP_P_GetCurrentChannelSettings);
    BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(pChanSettings);

    pChanSettings->eChType = hRapCh->eChannelType;
    pChanSettings->eChSubType = hRapCh->eChannelSubType;
#if (BRAP_OPEN_TIME_RBUF_ALLOCATION == 1)
    pChanSettings->sChnRBufPool = hRapCh->sChanRBufPool.sExtRBufPoolSettings;
#endif

    BDBG_LEAVE(BRAP_P_GetCurrentChannelSettings);
    return ret;
}


/**************************************************************************
Summary:
    Private function that finds the matching reference path in a channel 
    handle and returns the started corresponding path index.
    If the path is not found, uiStartedPathId BRAP_INVALID_VALUE is returned.
**************************************************************************/
BERR_Code
BRAP_P_GetCorrespondingStartedPath(
    BRAP_ChannelHandle      hRefRapCh,
    unsigned int            uiRefPth,
    unsigned int            uiRefPathOutIdx,
    BRAP_ChannelHandle      hStartedRapCh,
    unsigned int            *uiStartedPathId )
{
    BERR_Code               ret = BERR_SUCCESS;
    unsigned int            uiPth = 0;
    BRAP_P_ObjectHandles    *pRefPath = NULL;
        
    BDBG_ENTER(BRAP_P_GetCorrespondingStartedPath);
    BDBG_MSG(("uiRefPth = %d uiRefPathOutIdx = %d", uiRefPth, uiRefPathOutIdx));

    BDBG_ASSERT(hStartedRapCh);
    BDBG_ASSERT(hRefRapCh);
    BDBG_ASSERT(uiStartedPathId);
    BSTD_UNUSED(uiRefPathOutIdx);
    
    pRefPath = hRefRapCh->pPath[uiRefPth];
    BDBG_ASSERT(pRefPath);

    *uiStartedPathId = BRAP_INVALID_VALUE;

    for(uiPth = 0; 
        (uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN) && (*uiStartedPathId == BRAP_INVALID_VALUE);
        uiPth++)
    {        
        if(NULL == hStartedRapCh->pPath[uiPth])
        {
            continue;
        }

        BDBG_MSG(("hStartedRapCh->pPath[uiPth=%d]->eUsgPath = %d pRefPath->eUsgPath = %d",
            uiPth, hStartedRapCh->pPath[uiPth]->eUsgPath, pRefPath->eUsgPath));        
        /* For the same self path */
        if(hStartedRapCh->pPath[uiPth]->eUsgPath == pRefPath->eUsgPath)
        {
#if 1
            /* Got the matching uiPth path */
            *uiStartedPathId = uiPth;
            break;
#else
            /* Is this extra logic required?? later?? */
            /* Verify if the out path in target path is same as the out path in 
               the reference path */
            for(uiOutPth=0; uiOutPth <BRAP_P_MAX_OUT_PARALLEL_FMM_PATH; uiOutPth++)
            {
                uiTgtOutPthIdx = hStartedRapCh->pPath[uiPth]->sOutPathProp[uiOutPth].uiPathIdx;
                uiRfrOutPthIdx = pRefPath->sOutPathProp[uiRefPathOutIdx].uiPathIdx;
                
                BDBG_ERR(("uiTgtOutPthIdx = %d, uiRfrOutPthIdx = %d", 
                    uiTgtOutPthIdx,uiRfrOutPthIdx ));
                if((BRAP_INVALID_VALUE == uiTgtOutPthIdx) || 
                   (BRAP_INVALID_VALUE == uiRfrOutPthIdx))
                {
                    continue;
                }

                BDBG_ASSERT(hStartedRapCh->pPath[uiTgtOutPthIdx]);
                BDBG_ASSERT(hRefRapCh->pPath[uiTgtOutPthIdx]);

                BDBG_MSG((" hStartedRapCh->pPath[uiTgtOutPthIdx =%d]->eUsgPath = %d"
                   "hRefRapCh->pPath[uiTgtOutPthIdx =%d]->eUsgPath = %d",
                   uiTgtOutPthIdx, hStartedRapCh->pPath[uiTgtOutPthIdx]->eUsgPath,
                   uiTgtOutPthIdx, hRefRapCh->pPath[uiTgtOutPthIdx]->eUsgPath));
                   
                if(hStartedRapCh->pPath[uiTgtOutPthIdx]->eUsgPath == 
                   hRefRapCh->pPath[uiTgtOutPthIdx]->eUsgPath)
                {
                    /* Got the matching uiPth path */
                    *uiStartedPathId = uiPth;
                    break;
                }
            }/* for uiOutPth */        
#endif    
        }/* if eUsgPath */
    }/* for uiPth */

    BDBG_MSG(("GetCorrespondingStrtPath: *uiStartedPathId = %d",
        *uiStartedPathId));

    BDBG_LEAVE(BRAP_P_GetCorrespondingStartedPath);
    return ret;
}

/**************************************************************************
Summary:
    Private function that finds the PLL that can support a particular 
    sampling rate.
**************************************************************************/
BERR_Code
BRAP_P_GetPLLForSR(
    BRAP_ChannelHandle      hRapCh, /* [in] */
    BAVC_AudioSamplingRate  eSR,    /* [in] */
    BRAP_OP_Pll             *ePll   /* [out] */
    )
{
    BERR_Code           ret = BERR_SUCCESS;
    unsigned int        i = 0;
    BRAP_OP_P_Handle    hOp = NULL;
    BRAP_OP_Pll         eOpPll = BRAP_OP_Pll_eMax;
    BAVC_AudioSamplingRate  eOpBaseSR = BAVC_AudioSamplingRate_eUnknown;
    BAVC_AudioSamplingRate  eBaseSR = BAVC_AudioSamplingRate_eUnknown;
    
    BDBG_ENTER(BRAP_P_GetPLLForSR);
    *ePll = BRAP_OP_Pll_eMax;

    eBaseSR = BRAP_P_GetBaseSR(eSR);
    if(BAVC_AudioSamplingRate_eUnknown == eBaseSR)
    {
        return BERR_TRACE(BERR_NOT_SUPPORTED);
    }

    for(i=0; i < BRAP_RM_P_MAX_OUTPUTS; i++)
    {
        hOp = hRapCh->hRap->hFmm[0]->hOp[i];
        if(NULL == hOp)
        {
            continue;
        }

        if(hOp->uiStartCnt > 0)
        {
            switch(hOp->eOutputPort)
            {
                case BRAP_OutputPort_eI2s0:
                case BRAP_OutputPort_eI2s1:
                case BRAP_OutputPort_eI2s2:
                case BRAP_OutputPort_eI2s3:
                case BRAP_OutputPort_eI2s4:                    
                case BRAP_OutputPort_eI2s5:
                case BRAP_OutputPort_eI2s6:
                case BRAP_OutputPort_eI2s7:
                case BRAP_OutputPort_eI2s8:
                    eOpBaseSR = BRAP_P_GetBaseSR(hOp->eSamplingRate);                    
                    eOpPll = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].
                        uOutputPortSettings.sI2sSettings.ePll;
                    break;
                case BRAP_OutputPort_eSpdif:
                case BRAP_OutputPort_eSpdif1:    
                    eOpBaseSR = BRAP_P_GetBaseSR(hOp->eSamplingRate);                    
                    eOpPll = hRapCh->hRap->sOutputSettings[hOp->eOutputPort].
                        uOutputPortSettings.sSpdifSettings.ePll;
                    break;
                default:
                    continue;
            }/* switch */
        }/* uiStartCnt */

        if(eOpBaseSR == eBaseSR)
        {
            *ePll = eOpPll;
            break;
        }
    }

    BDBG_LEAVE(BRAP_P_GetPLLForSR);
    return ret;    
}

/**************************************************************************
Summary:
    Private function that returns the base sampling rate for a given sampling 
    rate.
    
    Following are the base sampling rates:
        - 32 for (32, 64, 128) 
        - 48 for (48, 96, 192)
        - 44.1 for (44.1, 88.2, 176.4)    
**************************************************************************/
BAVC_AudioSamplingRate 
BRAP_P_GetBaseSR(
    BAVC_AudioSamplingRate eSR /* [in] */
    )
{
    BAVC_AudioSamplingRate eBaseSR = BAVC_AudioSamplingRate_eUnknown;
    BDBG_ENTER(BRAP_P_GetBaseSR);
    
	switch(eSR)
    {   
        case BAVC_AudioSamplingRate_e32k:
        case BAVC_AudioSamplingRate_e64k:
        case BAVC_AudioSamplingRate_e128k:
            eBaseSR = BAVC_AudioSamplingRate_e32k; 
            break;
        case BAVC_AudioSamplingRate_e44_1k:
        case BAVC_AudioSamplingRate_e88_2k:
        case BAVC_AudioSamplingRate_e176_4k:
            eBaseSR = BAVC_AudioSamplingRate_e44_1k;
            break;            
        case BAVC_AudioSamplingRate_e48k:
        case BAVC_AudioSamplingRate_e96k:
        case BAVC_AudioSamplingRate_e192k:
            eBaseSR = BAVC_AudioSamplingRate_e48k;
            break;            
        default:
            eBaseSR = BAVC_AudioSamplingRate_eUnknown;
            break;
    }
    
    BDBG_LEAVE(BRAP_P_GetBaseSR);
    return eBaseSR;
}

/**************************************************************************
Summary:
    Private function that returns true if eCapPort is an internal capPort.
**************************************************************************/
bool
BRAP_P_IsInternalCapPort(
    BRAP_CapInputPort       eCapPort
    )
{
    switch(eCapPort)
    {
    case BRAP_CapInputPort_eIntCapPort0:
    case BRAP_CapInputPort_eIntCapPort1:
    case BRAP_CapInputPort_eIntCapPort2:
    case BRAP_CapInputPort_eIntCapPort3:
    case BRAP_CapInputPort_eIntCapPort4:
    case BRAP_CapInputPort_eIntCapPort5:
    case BRAP_CapInputPort_eIntCapPort6:
    case BRAP_CapInputPort_eIntCapPort7:
        return true;
    default:
        return false;
    }
}


BERR_Code
BRAP_P_GetAssocId(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    BRAP_DstDetails     *pDstDetails,   /* [in] */
    unsigned int            *ui32AssocId
    )    
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_P_DstDetails   *pTmpDst = NULL;
    unsigned int uiDstId = 0,j=0;
    bool    flag=false;
    BDBG_ENTER(BRAP_P_GetAssocId);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pDstDetails);

    BDBG_MSG(("pDstDetails = 0x%x",pDstDetails));
    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        BDBG_MSG(("j=%d hRapCh->uiAssociationId[j]=%d",j,hRapCh->uiAssociationId[j]));
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
            continue;
        
        for(uiDstId=0; uiDstId<BRAP_P_MAX_DST_PER_RAPCH; uiDstId++)
        {

            pTmpDst = &(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].sDstDetails[uiDstId]);
            BDBG_MSG(("uiDstId = %d pTmpDst=0x%x",uiDstId,&(pTmpDst->sExtDstDetails)));
            if(&(pTmpDst->sExtDstDetails) == pDstDetails)
            {
                *ui32AssocId = hRapCh->uiAssociationId[j];
                flag = true;
                break;
            }
        }
        if(flag == true)
        {
            break;
        }
    }
    
    BDBG_MSG(("BRAP_P_GetAssocId uiDstId=%d",uiDstId));
    if(uiDstId >= BRAP_P_MAX_DST_PER_RAPCH)
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
    }
    
    BDBG_LEAVE(BRAP_P_GetAssocId);
    return ret;
}
BERR_Code
BRAP_P_GetPvtDstDetails(
    BRAP_ChannelHandle  hRapCh,         /* [in] */
    BRAP_DstDetails     *pDstDetails,   /* [in] */
    BRAP_P_DstDetails   *pPvtDstDetails, /* [out] */
    unsigned int            *ui32AssocId
    )    
{
    BERR_Code ret = BERR_SUCCESS;
    BRAP_P_DstDetails   *pTmpDst = NULL;
    unsigned int uiDstId = 0,j=0;
    bool    flag=false;
    BDBG_ENTER(BRAP_P_GetPvtDstDetails);
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(pDstDetails);
    BDBG_ASSERT(pPvtDstDetails);

    for(j=0; j<BRAP_MAX_ASSOCIATED_GROUPS; j++)
    {
        BDBG_MSG(("j=%d hRapCh->uiAssociationId[j]=%d",j,hRapCh->uiAssociationId[j]));
        if(hRapCh->uiAssociationId[j] == BRAP_INVALID_VALUE)
            continue;
        
    for(uiDstId=0; uiDstId<BRAP_P_MAX_DST_PER_RAPCH; uiDstId++)
    {

            pTmpDst = &(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[j]].sDstDetails[uiDstId]);
            BDBG_MSG(("j = %d pTmpDst=%x",j,&(pTmpDst->sExtDstDetails)));
        if(&(pTmpDst->sExtDstDetails) == pDstDetails)
        {
            *pPvtDstDetails = *pTmpDst;
                *ui32AssocId = hRapCh->uiAssociationId[j];
                flag = true;
                break;
            }
        }
        if(flag == true)
        {
            break;
        }
    }
    /* Taking the mute value from hRap since if app uses BRAP_SetOutputMute() call instead of BRAP_SetDestinationMute() the mute status 
                    will not be updated in destiantion details */
    if(pPvtDstDetails->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
    {
        for(j=0; j<BRAP_OutputChannelPair_eMax; j++) 
        {            
            if(pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[j] != BRAP_OutputPort_eMax)
            {    
                pPvtDstDetails->bMute[j] = pPvtDstDetails->hAssociation->hRap->bOutputMute[pPvtDstDetails->sExtDstDetails.uDstDetails.sOpDetails.eOutput[j]];
            }
        }
    }

    BDBG_MSG(("BRAP_P_GetPvtDstDetails uiDstId=%d",uiDstId));
    if(uiDstId >= BRAP_P_MAX_DST_PER_RAPCH)
    {
        ret = BERR_TRACE(BERR_NOT_INITIALIZED);
    }
    
    BDBG_LEAVE(BRAP_P_GetPvtDstDetails);
    return ret;
}


/**************************************************************************
Summary:
    Private function that returns Spdif channel parametrs.
	If in the Path
		- Only SPDIF0 exist : return channel params of SPDIF0
		- Only SPDIF1 exist : return channel params of SPDIF1		
		- If both SPDIF0 and SPDIF1 exist : both should have same c-bit config 
			params. And any one of them is returned.
**************************************************************************/
BERR_Code BRAP_P_GetSpdifChanStatusParams(
	BRAP_ChannelHandle 				hRapCh,
	const unsigned int 				uiPth,
	BRAP_OP_SpdifChanStatusParams	*psSpdifChStatusParams,
	bool							*pbUpdateChStatusParams
)
{
  	BERR_Code               ret = BERR_SUCCESS;
    BRAP_OutputChannelPair  eChPair = BRAP_OutputChannelPair_eMax;
    BRAP_OutputPort         eOp = BRAP_OutputPort_eMax;
    unsigned int            uiPp = 0;
	bool bSpdifEnable=false,bSpdif1Enable=false;
	BRAP_OP_SpdifChanStatusParams sSpdifParams,sSpdif1Params;
    
    BDBG_ENTER(BRAP_P_GetSpdifChanStatusParams);
	BDBG_ASSERT(hRapCh);
	BDBG_ASSERT(psSpdifChStatusParams);
	BDBG_ASSERT(pbUpdateChStatusParams);	
    BDBG_ASSERT(NULL != hRapCh->pPath[uiPth]);
    
    for(uiPp=0; uiPp < BRAP_RM_P_MAX_PARALLEL_PATHS; uiPp++)
    {
	    for(eChPair = 0; eChPair < BRAP_OutputChannelPair_eMax; eChPair++)
	    {
	        BDBG_MSG(("BRAP_P_GetSpdifChanStatusParams: eChPair = %d", eChPair));
	        if((true == hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].bValid) &&
	          (NULL != hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].hOp))
	        {
	            eOp = hRapCh->pPath[uiPth]->sOp[eChPair][uiPp].hOp->eOutputPort;
	            BDBG_MSG(("BRAP_P_GetSpdifChanStatusParams: eOp = %d", eOp));        

	            if(true == hRapCh->hRap->bOpSettingsValid[eOp])
	            {
	               if(BRAP_OutputPort_eSpdif == eOp)
				   		bSpdifEnable = true;
				   else if(BRAP_OutputPort_eSpdif1 == eOp)
				   		bSpdif1Enable = true;
	            }
	            else
	            {
	                BDBG_ERR(("BRAP_P_GetSpdifChanStatusParams: OpPort %d not configured",
	                    eOp));
	                return BERR_TRACE(ret);
	            }        
	        }
	    }
    }/* for */

	if((true == bSpdifEnable) && (true == bSpdif1Enable))
	{
		sSpdifParams =  hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		sSpdif1Params =  hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].sSpdifChanStatusParams;		

		if((sSpdifParams.bProfessionalMode != sSpdif1Params.bProfessionalMode) ||
		   (sSpdifParams.bSeparateLRChanNum != sSpdif1Params.bSeparateLRChanNum)||
		   (sSpdifParams.bSwCopyRight != sSpdif1Params.bSwCopyRight) ||
		   (sSpdifParams.ui16CategoryCode != sSpdif1Params.ui16CategoryCode) ||
		   (sSpdifParams.ui16ClockAccuracy != sSpdif1Params.ui16ClockAccuracy)||
		   (sSpdifParams.uiCGMS_A != sSpdif1Params.uiCGMS_A) )
		{
			BDBG_ERR(("BRAP_P_GetSpdifChanStatusParams:Spdif channel status params"
				" for output port SPDIF0 and SPDIF1 should be same if they carry same decoded data"));

			BDBG_ERR(("sSpdifParams.bProfessionalMode =%d , sSpdif1Params.bProfessionalMode =%d"
					  "sSpdifParams.bSeparateLRChanNum =%d , sSpdif1Params.bSeparateLRChanNum =%d"
					  "sSpdifParams.bSwCopyRight =%d , sSpdif1Params.bSwCopyRight =%d"
					  "sSpdifParams.ui16CategoryCode =%d , sSpdif1Params.ui16CategoryCode =%d"
					  "sSpdifParams.ui16ClockAccuracy =%d , sSpdif1Params.ui16ClockAccuracy =%d",
					  sSpdifParams.bProfessionalMode,sSpdif1Params.bProfessionalMode,
					  sSpdifParams.bSeparateLRChanNum,sSpdif1Params.bSeparateLRChanNum,
					  sSpdifParams.bSwCopyRight,sSpdif1Params.bSwCopyRight,
					  sSpdifParams.ui16CategoryCode,sSpdif1Params.ui16CategoryCode,
					  sSpdifParams.ui16ClockAccuracy,sSpdif1Params.ui16ClockAccuracy,
					  sSpdifParams.uiCGMS_A,sSpdif1Params.uiCGMS_A));

			return BERR_TRACE(BERR_NOT_SUPPORTED);
		}
		
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
			
	}
	else if((false == bSpdif1Enable) && (true == bSpdifEnable))
	{
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif].bUseSpdifPackedChanStatusBits );
	}
	else if((false == bSpdifEnable) && (true == bSpdif1Enable))
	{
		*psSpdifChStatusParams = 
                hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].sSpdifChanStatusParams;
		*pbUpdateChStatusParams =
			!( hRapCh->hRap->sOutputSettings[BRAP_OutputPort_eSpdif1].bUseSpdifPackedChanStatusBits );
	}
	
    BDBG_LEAVE(BRAP_P_GetSpdifChanStatusParams);
    return ret;

}

BERR_Code BRAP_P_GetChannelForOpPort(
    const BRAP_Handle       hRap, 	        /* [in] The RAP Device handle */
    const BRAP_OutputPort   eOpType,        /* [in] Output port */    
    BRAP_ChannelHandle      *phChannel,     /* [out] Channel handle */
    BRAP_DSPCHN_Handle      *phDspCh        /* [out] DSP Channel handle */
    )
{
    BERR_Code               ret=BERR_SUCCESS;
    BRAP_ChannelHandle      hRapCh= NULL;
    int                     i=0,j=0,k=0;
    bool                    bFound = false;

    BDBG_ENTER(BRAP_P_GetChannelForOpPort);

    BDBG_ASSERT(hRap);
    BDBG_ASSERT(phChannel);

    /* Find the channel which is outputing to this port */
    for (i=0;i<BRAP_RM_P_MAX_DEC_CHANNELS;i++)
    {
        hRapCh = hRap->hRapDecCh[i];
        if ( hRapCh != NULL )
        {
            for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
            {
                if(NULL == hRapCh->pDstDetails[j])
                {
                    continue;
                }
                if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                {
                    continue;
                }
                for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                {
                    if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                    {
                        continue;
                    }
                    if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                    {
                        bFound = true;
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
    }
    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_CAP_CHANNELS;i++)
        {
            hRapCh = hRap->hRapCapCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                {
                    if(NULL == hRapCh->pDstDetails[j])
                    {
                        continue;
                    }
                    if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                    {
                        continue;
                    }
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                        {
                            continue;
                        }
                        if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }
    if (false == bFound)
    {
        for (i=0;i<BRAP_RM_P_MAX_PCM_CHANNELS;i++)
        {
            hRapCh = hRap->hRapPbCh[i];
            if ( hRapCh != NULL )
            {
                for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
                {
                    if(NULL == hRapCh->pDstDetails[j])
                    {
                        continue;
                    }
                    if(BRAP_AudioDst_eOutputPort != hRapCh->pDstDetails[j]->eAudioDst)
                    {
                        continue;
                    }
                    for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
                    {
                        if(BRAP_OutputPort_eMax == hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                        {
                            continue;
                        }
                        if(hRapCh->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                        {
                            bFound = true;
                            break;
                        }
                    }
                    if(true==bFound)
                    {
                        break;
                    }
                }
                if(true==bFound)
                {
                    break;
                }
            }
        }
    }

    /* If this output port is not found in any of the active channels, return
       Error */
    if(false == bFound)
    {
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: The Output Port %d is not Active",eOpType));
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }

    /* Rap Channel found, find DSP Channel handle */
    bFound = false;
    for(i = 0; i < BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
    {
        if(NULL == hRapCh->pPath[i])
            continue;
        for(j=0;j<BRAP_P_MAX_DST_PER_RAPCH;j++)
        {
            if(NULL == hRapCh->pPath[i]->pDstDetails[j])
            {
                continue;
            }
            if(BRAP_AudioDst_eOutputPort != hRapCh->pPath[i]->pDstDetails[j]->eAudioDst)
            {
                continue;
            }
            for(k=0;k<BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;k++)
            {
                if(BRAP_OutputPort_eMax == hRapCh->pPath[i]->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k])
                {
                    continue;
                }
                if(hRapCh->pPath[i]->pDstDetails[j]->uDstDetails.sOpDetails.eOutput[k] == eOpType)
                {
                    *phDspCh = hRapCh->pPath[i]->hDspCh;
                    bFound = true;
                    break;
                }
            }
            if(true==bFound)
            {
                break;
            }
        }
        if(true==bFound)
        {
            break;
        }
    }
    
    if(false == bFound)
    {
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: DSPCH not found!"));
        BDBG_MSG(("BRAP_P_GetChannelForOpPort: PI should program the CBITs"));
    }

    *phChannel = hRapCh;
    BDBG_LEAVE(BRAP_P_GetChannelForOpPort);
    return ret;
}
/**************************************************************************
Summary:
    Private function that Resets the CHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK
    bit for the SrcCh which is unmasked to recieve the interrupt.
    Resetting this bit is a part of hardware workaround. For resetting the 
    bit, First set it to 0, then set the bit to 1 again
**************************************************************************/

void BRAP_P_ReArmFreeMarkInterrupt (
	BRAP_ChannelHandle	hRapch
	)
{
	BDBG_ENTER(BRAP_P_ReArmFreeMarkInterrupt);
	BDBG_ASSERT(hRapch);

    BKNI_EnterCriticalSection();
    BRAP_P_ReArmFreeMarkInterrupt_isr(hRapch);
    BKNI_LeaveCriticalSection();

    BDBG_LEAVE(BRAP_P_ReArmFreeMarkInterrupt);
    return;
}

/**************************************************************************
Summary:
	Isr version of BRAP_P_ReArmFreeMarkInterrupt.
**************************************************************************/


void BRAP_P_ReArmFreeMarkInterrupt_isr(
	BRAP_ChannelHandle	hRapch
	)
{
	uint32_t 	ui32RegVal =0x0,ui32ReArmBitFreeMark=0x0,ui32ReArmBitFullMark=0x0;
	int i=0,uiPth=0;
	
	BDBG_ENTER(BRAP_P_ReArmFreeMarkInterrupt_isr);
	BDBG_ASSERT(hRapch);
	
	if(BRAP_ChannelType_ePcmPlayback == hRapch->eChannelType)
	{
		for(i=0 ; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS ; i++)
		{
			if(hRapch->pPath[BRAP_P_UsgPath_eDecodePcm]->sRsrcGrnt.uiSrcChId[i] != (unsigned int) BRAP_RM_P_INVALID_INDEX)
			{
				ui32ReArmBitFreeMark |= (1 << hRapch->pPath[BRAP_P_UsgPath_eDecodePcm]->sRsrcGrnt.uiSrcChId[i]);
			}
		}
	}
		
	for(uiPth=0 ; uiPth < BRAP_P_MAX_PATHS_IN_A_CHAN ; uiPth++)
	{

        if(NULL == hRapch->pPath[uiPth])
        {
            continue;
        }
		
        /* The first capture path is omitted as that case is for SPDIF HDMI In */
		if ( (uiPth !=0) && (BRAP_P_UsgPath_eCapture == hRapch->pPath[uiPth]->eUsgPath))
		{
			for(i=0 ; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS ; i++)
			{
				if(hRapch->pPath[uiPth]->sRsrcGrnt.uiDstChId[i] != (unsigned int) BRAP_RM_P_INVALID_INDEX)
				{
					ui32ReArmBitFullMark |= (1 << hRapch->pPath[uiPth]->sRsrcGrnt.uiDstChId[i]);
				}
			}
			break;
		}
	}
		
	/* First set 0 to Re-Arm bits of source channel and destination channels, then set them to 1 */
	ui32RegVal = BRAP_Read32_isr(hRapch->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal = (~ui32ReArmBitFreeMark) & ui32RegVal;
	ui32RegVal = (~(ui32ReArmBitFullMark<<8)) & ui32RegVal;
	BRAP_Write32_isr (hRapch->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);


	ui32RegVal = BRAP_Read32_isr(hRapch->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, 
                    	REARM_FREEMARK, ui32ReArmBitFreeMark);
#if (BRAP_7550_FAMILY != 1)
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, 
                    	REARM_FULLMARK, ui32ReArmBitFullMark);	
#endif
	BRAP_Write32_isr (hRapch->hRegister,  
              			BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);
	
	BDBG_LEAVE(BRAP_P_ReArmFreeMarkInterrupt_isr);
	return;
	

}

/**************************************************************************
Summary:
    Private function that Resets the CHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK
    bit for the Destination which is unmasked to recieve the interrupt.
    Resetting this bit is a part of hardware workaround. For resetting the 
    bit, First set it to 0, then set the bit to 1 again
**************************************************************************/

void BRAP_P_ReArmFullMarkInterrupt(
	BRAP_DestinationHandle        hDstHandle
	)
{
	BDBG_ENTER(BRAP_P_ReArmFullMarkInterrupt);
	BDBG_ASSERT(hDstHandle);

    BKNI_EnterCriticalSection();
    BRAP_P_ReArmFullMarkInterrupt_isr(hDstHandle);
    BKNI_LeaveCriticalSection();

    BDBG_LEAVE(BRAP_P_ReArmFullMarkInterrupt);
    return;
}

/**************************************************************************
Summary:
	Isr version of BRAP_P_ReArmFullMarkInterrupt.
**************************************************************************/
void BRAP_P_ReArmFullMarkInterrupt_isr(
	BRAP_DestinationHandle        hDstHandle
	)
{
	uint32_t 	        ui32RegVal =0x0,ui32ReArmBitFullMark=0x0;
	unsigned int        uichannelpair = 0;    
	
	BDBG_ENTER(BRAP_P_ReArmFullMarkInterrupt_isr);
	BDBG_ASSERT(hDstHandle);

    for (uichannelpair = 0; uichannelpair < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; uichannelpair++)
	{
		if (hDstHandle->sExtDstDetails.uDstDetails.sRBufDetails.uiDstChId[uichannelpair] != (unsigned int)BRAP_RM_P_INVALID_INDEX)
		{
		    ui32ReArmBitFullMark |= (1 << hDstHandle->sExtDstDetails.uDstDetails.sRBufDetails.uiDstChId[uichannelpair]);    		
	    }
    }
	/* First set 0 to Re-Arm bits corresponding to destination channel id, then set them to 1 */
	ui32RegVal = BRAP_Read32_isr(hDstHandle->hAssociation->hRap->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
	ui32RegVal = (~(ui32ReArmBitFullMark<<8)) & ui32RegVal;
	BRAP_Write32_isr (hDstHandle->hAssociation->hRap->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK,ui32RegVal);


	ui32RegVal = BRAP_Read32_isr(hDstHandle->hAssociation->hRap->hRegister,BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK );
#if (BRAP_7550_FAMILY != 1)
	ui32RegVal |= BCHP_FIELD_DATA(AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, REARM_FULLMARK, ui32ReArmBitFullMark);	
#endif
	BRAP_Write32_isr (hDstHandle->hAssociation->hRap->hRegister, BCHP_AUD_FMM_BF_CTRL_REARM_FREEFULL_MARK, ui32RegVal);
	
	BDBG_LEAVE(BRAP_P_ReArmFullMarkInterrupt_isr);
	return;
}

BERR_Code BRAP_P_ProgramAdaptRateCtrl (
                BRAP_ChannelHandle		hRapCh,
                const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                                       to pPath[] array element */	
		)
{

    BERR_Code ret = BERR_SUCCESS;
    unsigned int  ui32RegVal = 0, ui32Offset=0;   
    unsigned int  i=0, uiAdaptRateCtrlId=0;

    BDBG_ENTER (BRAP_P_ProgramAdaptRateCtrl);
    BDBG_ASSERT (hRapCh);           
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    /* If this channel has a SrcCh which carries PCM data, program the 
    AUD_FMM_BF_CTRL_ADAPTRATE_X accordingly */
    ui32Offset = (BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_1_CFG -  BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG);
        
    for(i=0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh == NULL) 
        {
            continue;
        }
        else
        {
            /* Make sure the SrcCh is carrying PCM data.
            Note: whether the srcch is carrying PCM or Comp is determined only 
            at start time. So make sure the Srcch has been started.*/
            if ((hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->eState == BRAP_SRCCH_P_State_eRunning) 
                && (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->sParams.bCompress == false))
            {
                uiAdaptRateCtrlId = hRapCh->pPath[uiPth]->sRsrcGrnt.uiAdaptRateCtrlId[i];   

                if(BRAP_RM_P_INVALID_INDEX == uiAdaptRateCtrlId)
                {
                    continue;
                }
                
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset));

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_SFIFO_SEL));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_SFIFO_SEL, hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));            

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                    TRIWINDOW_WIDTH_SEL));

                /* TODO: hardcoding window width field to 8 ie actual window 
                width of 256. This has to be changed later to be taken from 
                application */
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                TRIWINDOW_WIDTH_SEL, TRIWINDOW_WIDTH_SEL_VALUE));
                
                /* Earlier, for a decode channel FW was setting the enable flag. 
                Now we're doing AdaptRate control for PCM channels also. So let the 
                PI set this flag always */                
#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_ENABLE, 0));  
#else
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_ENABLE, 1));  
#endif                


#if ((BRAP_7420_FAMILY != 1)|| ((BCHP_CHIP==7420)&&((BCHP_VER == A0)||(BCHP_VER == BCHP_VER_A1))))&&(BRAP_7550_FAMILY != 1)
                /* Program ADAPTIVE_RATE_THRESHOLD required */
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_THRESHOLD));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_THRESHOLD, ADAPTIVE_RATE_THRESHOLD_VALUE));
#endif

#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)
            /* Program ADAPTIVE_RATE_MASTER_ENABLE  */
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_MASTER_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_MASTER_ENABLE, 1));

#endif

                BDBG_MSG(("For AdaptRateControl: channel pair %d, SrcFifo %d"
                    ", AdaptRateThreshold=5 and WindowWidth = 256 ", i, 
                    hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset), 
                            ui32RegVal);
#if ((BRAP_7420_FAMILY == 1)&&((BCHP_CHIP==7420)&&(BCHP_VER != A0)&&(BCHP_VER != BCHP_VER_A1)))||(BRAP_7550_FAMILY == 1)
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                    BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0 + (uiAdaptRateCtrlId*ui32Offset));

                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0, ADAPTIVE_RATE_THRESHOLD));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0, 
                                ADAPTIVE_RATE_THRESHOLD, ADAPTIVE_RATE_THRESHOLD_VALUE));

                BRAP_Write32(hRapCh->hRegister, 
                    BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_THRESHOLD_0 + (uiAdaptRateCtrlId*ui32Offset),
                    ui32RegVal);

#endif
            }
    	}
    }  

    BDBG_LEAVE (BRAP_P_ProgramAdaptRateCtrl);
    return ret;    
}



BERR_Code BRAP_P_ResetAdaptRateCtrl (
                BRAP_ChannelHandle		hRapCh,
                const unsigned int          uiPth       	/* [in] Path idx corresponding 
                                                                       to pPath[] array element */	
		)
{

    BERR_Code ret = BERR_SUCCESS;
    unsigned int  ui32RegVal = 0, ui32Offset=0;   
    unsigned int  i=0, uiAdaptRateCtrlId=0;

    BDBG_ENTER (BRAP_P_ResetAdaptRateCtrl);
    BDBG_ASSERT (hRapCh);           
    BDBG_ASSERT(hRapCh->pPath[uiPth]);
    /* If this channel has a SrcCh which carries PCM data, program the 
    AUD_FMM_BF_CTRL_ADAPTRATE_X accordingly */
    ui32Offset = (BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_1_CFG -  BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG);
        
    for(i=0; i < BRAP_RM_P_MAX_OP_CHANNEL_PAIRS; i++)
    {
        if (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh == NULL) 
        {
            continue;
        }
        else
        {
            /* Make sure the SrcCh is carrying PCM data.
            Note: whether the srcch is carrying PCM or Comp is determined only 
            at start time. So make sure the Srcch has been started.*/
            if ((hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->eState == BRAP_SRCCH_P_State_eRunning) 
                && (hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->sParams.bCompress == false))
            {
                uiAdaptRateCtrlId = hRapCh->pPath[uiPth]->sRsrcGrnt.uiAdaptRateCtrlId[i];   

                if(BRAP_RM_P_INVALID_INDEX == uiAdaptRateCtrlId)
                {
                    continue;
                }
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_REPEATDROP_WRCNT_0 + (uiAdaptRateCtrlId*ui32Offset), 
                            0x0);   
                
                ui32RegVal = BRAP_Read32(hRapCh->hRegister, 
                BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset));
                
                /* Earlier, for a decode channel FW was setting the enable flag. 
                Now we're doing AdaptRate control for PCM channels also. So let the 
                PI set this flag always */                
                ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_ENABLE));                
                ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                                ADAPTIVE_RATE_ENABLE, 0));  

#if (BRAP_7420_FAMILY == 1)||(BRAP_7550_FAMILY == 1)                
            /* Reset ADAPTIVE_RATE_MASTER_ENABLE  */
            ui32RegVal &= ~(BCHP_MASK (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, ADAPTIVE_RATE_MASTER_ENABLE));                
            ui32RegVal |= (BCHP_FIELD_DATA (AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG, 
                            ADAPTIVE_RATE_MASTER_ENABLE, 0));

#endif


                BDBG_MSG(("Disabling AdaptRateControl: channel pair %d, SrcFifo %d"
                    " ", i, 
                    hRapCh->pPath[uiPth]->sSrcCh[i].hSrcCh->uiIndex));
                
                BRAP_Write32(hRapCh->hRegister, 
                            BCHP_AUD_FMM_BF_CTRL_ADAPTRATE_0_CFG + (uiAdaptRateCtrlId*ui32Offset), 
                            ui32RegVal);    
            }
    	}
    }  

    BDBG_LEAVE (BRAP_P_ResetAdaptRateCtrl);
    return ret;    
}


/**************************************************************************************
SUMMARY:
function to show the current settings of all the post processing stages 
***************************************************************************************/


void BRAP_P_ShowHandleStage( BRAP_ChannelHandle hRapCh)
{
	/*
    int i=0, loop=0;
    int destdevice=0;
    int stgsdevice=0;	
    */
    uint32_t i=0,loop=0,destdevice=0,stgsdevice=0;

    BDBG_MSG(("\n SETTINGS FOR THE STAGES"));
    BDBG_MSG(("\n*****************************"));


    for(i=0;i<BRAP_MAX_ASSOCIATED_GROUPS;i++)
    {  
        if (i >= 2)
        {
            break;
        }
        if(hRapCh->uiAssociationId[i] == BRAP_INVALID_VALUE)
            continue;
        BDBG_MSG(("\n GROUP ASSOCIATION NUMBER: %d",i));
        BDBG_MSG(("\n $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"));

        for(destdevice=0;destdevice<BRAP_P_MAX_DST_PER_RAPCH;destdevice++)
        { 
            if(hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hAssociation == NULL)
            { 
                BDBG_MSG(("\n This Destination:%d is Not Valid ",destdevice));
                continue;
            }

            BDBG_MSG(("\n\n SETTINGS FOR THE DESTINATION: %d",destdevice));
            BDBG_MSG(("\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"));
            BDBG_MSG(("\n Destination of the audio data from the Raptor Channel :%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].sExtDstDetails.eAudioDst));
            BDBG_MSG(("\n Destination Detaols:%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].sExtDstDetails.uDstDetails));
            BDBG_MSG(("\n Associated Channel Handle to which the destination belongs :%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hAssociation));
            BDBG_MSG(("\n Parent Destination Handle :%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].hParentDestHandle));
            BDBG_MSG(("\n Forking Stage :%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].uiForkingStage));
            BDBG_MSG(("\n The main audio processing for this destination %d\n",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].eAudioProcessing));

            /* hDestHandle is same as &(hRap->sAssociatedCh[i].sDstDetails[destdevice]) */
            for (loop=0;loop<BRAP_P_MAX_RAPCH_PER_DST+1;loop++)
            {

                if(NULL == hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop])
                {
                    /*BDBG_MSG (("The PP Settings Array for index = %d is NULL", loop));*/
                    continue;
                }

                BDBG_MSG(("\n PP Settings are present in Index : %d",loop));
                BDBG_MSG(("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"));

                for(stgsdevice=0;stgsdevice<BRAP_MAX_PP_PER_BRANCH_SUPPORTED;stgsdevice++)
                {  
                    if(hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]==NULL)
                    {
                        BDBG_MSG(("\n hAudProcessing for stage %d is NULL",stgsdevice));
                        continue;
                    } 

                    BDBG_MSG(("\n Processing Stage=%d",stgsdevice));
                    BDBG_MSG(("\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"));


                    BDBG_MSG( ("\n TESTING OUR PP ALGO:: %d", hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->sProcessingStageSettings.eAudioProcessing));
                    /*BDBG_MSG(("\n TESTING OUR PP ALGO uconfig:: %d", hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->sProcessingStageSettings.uConfigParams));*/
                    BDBG_MSG(("\n TESTING OUR PP ALGO uistage position ::%d",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->uiStagePosition));
                    BDBG_MSG(("\n TESTING OUR PP ALGO hRap::%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->hRap));
                    BDBG_MSG(("\n TESTING OUR PP ALGO hRapCh::%x",hRapCh->hRap->sAssociatedCh[i].sDstDetails[destdevice].psProcessingSettings[loop]->sExternalSettings.hAudProcessing[stgsdevice]->uHandle.hRapCh));
                }
            }
        }
    } 
}


/**************************************************************************************
SUMMARY:
function to show the current settings of all the CIT structure 

***************************************************************************************/


void BRAP_P_ShowCitSettings(BRAP_P_AudioProcNetwork *psAudProcNetwork, BRAP_CIT_P_InputInfo    *pCitInputStruct)
{  
    uint32_t  i=0,j=0,k=0,l=0,m=0, n = 0;

    BDBG_MSG( ("\n Showing the CIT input Structure settings"));
    BDBG_MSG(("\n **********************************************************"));

    BDBG_MSG(("\n The number of outputs :%d ",pCitInputStruct->ui32NumOutputs));
    BDBG_MSG(("\n ---------------------------------------------------------------"));

    for(j=0; j< pCitInputStruct->ui32NumOutputs; j++)
    {
        BDBG_MSG(("\n OutPut num : %d",j));
        BDBG_MSG(("\n ------------------------------"));
        BDBG_MSG(("\n\npCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType > %d", pCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType));
        BDBG_MSG(("\npsCitInputStruct->sPortCfg[j].ui32PllIndex > %d", pCitInputStruct->sPortCfg[j].ui32PllIndex));
        if(BRAP_OutputPort_eSpdif == pCitInputStruct->sPortCfg[j].sFmmDstDetails.uFmmDstPortType.eOpType)
            BDBG_MSG(("psCitInputStruct->sPortCfg[j].uOpCfg.sSpdifCfg.bPcmOnSpdif > %d", pCitInputStruct->sPortCfg[j].uOpCfg.sSpdifCfg.bPcmOnSpdif));
    }  

    BDBG_MSG(("\n The number of branches :%d",pCitInputStruct->ui32NumBranches));
    BDBG_MSG(("\n-------------------------------------------------------------------"));

    for(j=0; j< pCitInputStruct->ui32NumBranches; j++)
    {
        BDBG_MSG(("\n Branch number:%d ",j));
        BDBG_MSG(("\n---------------------------"));
        BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].ui32NumStages = %d",j,pCitInputStruct->pBranchInfo[j]->ui32NumStages));
        for(k =0; k < pCitInputStruct->pBranchInfo[j]->ui32NumStages; k++)
        { 
            BDBG_MSG(("\n Stage number :%d",k));
            BDBG_MSG(("\n----------------------------"));
            BDBG_MSG(("\n Branch info:"));
            BDBG_MSG(("\n======================"));
            BDBG_MSG(("\nsFwStgInfo[%d].ui32BranchId = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].ui32BranchId));
            BDBG_MSG(("sFwStgInfo[%d].ui32StageId = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].ui32StageId));
            BDBG_MSG(("sFwStgInfo[%d].eAudioAlgoType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].eAudioAlgoType));
            BDBG_MSG(("sFwStgInfo[%d].uAlgorithm.eAudioType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].uAlgorithm.eDecAudioAlgo));
            BDBG_MSG(("sFwStgInfo[%d].uAudioMode.eDecAudioMode = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].uAudioMode.eDecAudioMode));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.ui32NumSrc = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumSrc));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.sSrcDetails[0].eType = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].eType));
            BDBG_MSG(("sFwStgInfo[%d].sStgConnectivity.sSrcDetails[0].uDetails = %d",k,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails));

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType));				

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers));				

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0] = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0]));				
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1] = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1]));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr));								


            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32BaseAddr));				
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32EndAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32ReadAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32WriteAddr));								
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[1].ui32WrapAddr));

            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32BranchId = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32BranchId));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32DistinctOpNum = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32DistinctOpNum));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32OpNum = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32OpNum));
            BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32StageId = %d",
            pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sSrcDetails[0].uDetails.sFwStage.ui32StageId));					







            BDBG_MSG(("\n pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp:%d ",pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp));
            BDBG_MSG(("\n-----------------------------------------------------------------------------------------------"));
            for( m=0;m<pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDistinctOp;m++)
            { 
                BDBG_MSG(("\n m=%d",m));
                BDBG_MSG(("sFwStgInfo[k].sStgConnectivity.ui32NumDst[%d] =%d",m,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDst[m]));                
                BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].sFwStgInfo[%d].sStgConnectivity.eDistinctOpType[%d] = %d",j,k,m,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.eDistinctOpType[m]));				                

                for(i = 0; i< pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.ui32NumDst[m]; i++)
                {	
                    BDBG_MSG(("\n i=%d",i));		
                    BDBG_MSG(("\npsCitInputStruct->sBranchInfo[%d].sFwStgInfo[%d].sStgConnectivity.sDstDetails[%d][%d].eType = %d",j,k,m,i,pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].eType));				

                    BDBG_MSG(("psCitInputStruct->sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.uiBufferId[0] = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[0]));		
                    BDBG_MSG(("psCitInputStruct->sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.uiBufferId[1] = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32BufferId[1]));						
                    BDBG_MSG(("psCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.eBufferType));		
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32NumBuffers));

                    for(n = 0; n <  BRAP_RM_P_MAX_OP_CHANNEL_PAIRS;n++)
                    {
                        BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32AdaptRateCtrlIds[%d] = %d",m,i,n,
                        pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffId.ui32AdaptRateCtrlIds[n]));
                    }

                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.ui32NumBuffers));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32BaseAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32EndAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32ReadAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WrapAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoBuffer.sIoBuffer.sCircBuffer[0].ui32WriteAddr));

                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.ui32NumBuffers = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.ui32NumBuffers));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32BaseAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32BaseAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32EndAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32EndAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32ReadAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32ReadAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WrapAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WrapAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WriteAddr = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffer.sCircBuffer.ui32WriteAddr));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.eBufferType = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.eBufferType));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32BufferId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32BufferId));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32NumBuffer = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sIoBuf.uIoGenericBuffer.sIoGenericBuffId.ui32NumBuffers));


                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32BranchId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32BranchId));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32DistinctOpNum = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32DistinctOpNum));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32OpNum = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32OpNum));
                    BDBG_MSG(("sCitInputStruct.sBranchInfo[j].sFwStgInfo[k].sStgConnectivity.sDstDetails[%d][%d].uDetails.sFwStage.ui32StageId = %d",m,i,
                    pCitInputStruct->pBranchInfo[j]->sFwStgInfo[k].sStgConnectivity.sDstDetails[m][i].uDetails.sFwStage.ui32StageId));
                }				
            }
        }
    }

    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32SharedMemPhysAdr = %d",pCitInputStruct->sMemInfo.ui32SharedMemPhysAdr));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32SharedMemSize = %d",pCitInputStruct->sMemInfo.ui32SharedMemSize));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32TaskMemPhysAdr = %d",pCitInputStruct->sMemInfo.ui32TaskMemPhysAdr));
    BDBG_MSG(("psCitInputStruct->sMemInfo.ui32TaskMemSize = %d",pCitInputStruct->sMemInfo.ui32TaskMemSize));

    BDBG_MSG(("\n Details of the master Index Table "));
    BDBG_MSG(("\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"));
    for(l=0;l<BRAP_AF_P_AlgoId_eMax;l++)
    {
        if(pCitInputStruct->psMit==NULL)
        {
            continue;
        }
        if(pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodePtr != 0xffffffff)
        {
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoCodePtr :%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodePtr));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoCodeSize :%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoCodeSize));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoDataPtr:%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoDataPtr));
        BDBG_MSG(("psCitInputStruct->psMit->sAlgoDwnldDetail[%d].ui32AlgoDataSize:%d",l,pCitInputStruct->psMit->sAlgoDwnldDetail[l].ui32AlgoDataSize));
        }
    }

    BDBG_MSG(("\n RdbCfg Details"));
    BDBG_MSG(("\n #####################"));
    BDBG_MSG(("\npsCitInputStruct->sRdbCfg.ui32RDBBaseOffset: %d",pCitInputStruct->sRdbCfg.ui32RdbBaseOffset));
    BDBG_MSG(("psCitInputStruct->sRdbCfg.ui32RDBChipOffset: %d",pCitInputStruct->sRdbCfg.ui32RdbDspOffset));

    BDBG_MSG(("\n Network Details "));
    BDBG_MSG(("\n==========================================\n"));

    for(i=0;i<BRAP_P_MAX_DST_PER_RAPCH;i++)
    { 
            for (j=0; j<BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED;j++)
            { 
                if(psAudProcNetwork!=NULL)
                {
                    if(BRAP_P_STAGE_VALID(psAudProcNetwork->sAudProcessingStage,i,j))                        
                    {
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].bDecoderStage: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].bDecoderStage));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].bCloneStage: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].bCloneStage));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].ui32MasterBranchId: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].ui32MasterBranchId));
                        BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].ui32MasterStageId: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].ui32MasterStageId));

                        if(NULL != psAudProcNetwork->sAudProcessingStage[i][j].hAudioProcessing)
                            BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hAudioProcessing.sProcessingStageSettings.eAudioProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing));
                        for(l=0;l<BRAP_P_MAX_DEST_PER_PROCESSING_STAGE;l++)
                        {   
                            if (psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]!=NULL)
                            {
                                BDBG_MSG(("\n l=%d",l));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->eAudioProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->eAudioProcessing));
                                BDBG_MSG(("\n this was AudioProcessing,now we get AudProcessing\n"));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->eAudProcessing: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->eAudProcessing));
                                BDBG_MSG(("psAudProcNetwork->sAudProcessingStage[%d][%d].hDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[: %d",i,j,psAudProcNetwork->sAudProcessingStage[i][j].hDestHandle[l]->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]));
                            }
                        }	 
                    }						 
                    else
                    {
                        break;
                    }
                }
        }
    }
}

BERR_Code BRAP_P_SetOutputVolumeGain( 
    BRAP_Handle         hRap,       /*[in] Rap Handle */
    BRAP_OutputPort     eOpType,    /*[in] Output Port */
    unsigned int            uiLVolume,      /* [in] Left channel volume in 0.23 format */
    unsigned int            uiRVolume       /* [in] Right channel volume in in 0.23 format*/
)    
{
    BRAP_MIXER_P_Handle     hMixer = NULL;
    unsigned int            uiMixerOutput=0;    
    BERR_Code               ret = BERR_SUCCESS;
    

	/* Get the Mixer handle for mixer linked to this output port */
	ret = BRAP_P_GetMixerForOpPort(hRap,eOpType,&hMixer,&uiMixerOutput);
    
	if(BERR_INVALID_PARAMETER == ret)
	{
		/* Channel not started yet */
		ret = BERR_SUCCESS;
	}
	else if(BERR_SUCCESS == ret)
	{
		/* Call the Mixer volume control API */
		ret = BRAP_MIXER_P_SetOutputVolumeGain(hMixer,uiMixerOutput,uiLVolume,uiRVolume);
		if(BERR_SUCCESS != ret)
		{
			BDBG_ERR(("BRAP_P_SetOutputVolumeGain:BRAP_MIXER_P_SetOutputVolumeGain returned"
				"Error"));
		}
	}
	else
	{
		BDBG_ERR(("BRAP_P_SetOutputVolumeGain:BRAP_P_GetMixerForOpPort returned"
			"Error"));
		ret = BERR_TRACE(ret);
	}

    return ret;

}
bool   BRAP_P_IsPassthruSupportedWithoutLicense(BRAP_DSPCHN_AudioType  eType)
{

    if(
#ifdef  RAP_AC3_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eAc3)||
#endif        
#ifdef  RAP_DTSBROADCAST_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eDtsBroadcast)||
#endif        
#ifdef  RAP_DTSHD_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eDtshd)||
#endif
#ifdef  RAP_DDP_PASSTHRU_SUPPORT                       
        (eType == BRAP_DSPCHN_AudioType_eAc3Plus)||
#endif
#ifdef  RAP_MPEG_PASSTHRU_SUPPORT                               
        (eType == BRAP_DSPCHN_AudioType_eMpeg)||
#endif
#ifdef  RAP_AACSBR_PASSTHRU_SUPPORT                               
        (eType == BRAP_DSPCHN_AudioType_eAacAdts)||                                     
        (eType == BRAP_DSPCHN_AudioType_eAacLoas)||        
        (eType == BRAP_DSPCHN_AudioType_eAacSbrAdts)||        
        (eType == BRAP_DSPCHN_AudioType_eAacSbrLoas)||
#endif        
#ifdef  RAP_DRA_PASSTHRU_SUPPORT               
        (eType == BRAP_DSPCHN_AudioType_eDra)||       
#endif        
#ifdef  RAP_REALAUDIOLBR_PASSTHRU_SUPPORT               
                (eType == BRAP_DSPCHN_AudioType_eRealAudioLbr)||       
#endif     

        (false)
        )
    {
        return  true;
    }
    else
    {
        return  false;
    }
}

BERR_Code BRAP_P_GetAlgorithmProfileId(
    uint8_t     *pui8AlgoProfileId
    )
{
    BERR_Code       ret = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_GetAlgorithmProfileId);
    
#if defined(RAP_DTSENC_SUPPORT)

#if defined(RAP_DTSBROADCAST_SUPPORT) && defined(RAP_DTSHD_SUPPORT)
    *pui8AlgoProfileId = 4;
#elif defined(RAP_DTSBROADCAST_SUPPORT)
    *pui8AlgoProfileId = 3;
#else
    *pui8AlgoProfileId = 2;
#endif

#else

#if defined(RAP_DTSHD_SUPPORT)
    *pui8AlgoProfileId = 1;
#else
    *pui8AlgoProfileId = 0; /* Invalid Profile */
#endif

#endif

    BDBG_LEAVE(BRAP_P_GetAlgorithmProfileId);
return ret;
}


/***************************************************************************
Summary:
    Creates Multi Stream Decoder object.
Description:
    This function creates Multi Stream Decoder object. F
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_GetMultiStreamDecoderObject    
    BRAP_P_DestroyMultiStreamDecoderObject

**************************************************************************/
BERR_Code BRAP_P_CreateMultiStreamDecoderObject(
    BRAP_Handle hRap, 
    BRAP_MultiStreamDecoderHandle *phMultiStreamDecoder
    )
{
    BERR_Code ret  = BERR_SUCCESS;
    unsigned int uiMsObjIndex = 0,uiStgIp=0;

    BDBG_ENTER(BRAP_P_CreateMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hRap);
    BDBG_ASSERT (phMultiStreamDecoder);    

    *phMultiStreamDecoder = NULL;
    for (uiMsObjIndex=0; uiMsObjIndex<BRAP_P_MAX_MULTI_STREAM_DECODER_OBJECTS; uiMsObjIndex++)
    {
        if (true == hRap->sMultiStreamDecoderObjs[uiMsObjIndex].bAvailable)
        {
            break;
        }
    }
    if (BRAP_P_MAX_MULTI_STREAM_DECODER_OBJECTS == uiMsObjIndex)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Max Multi Stream Decoder object reached"));
        ret = BERR_TRACE(BERR_NOT_SUPPORTED);
        goto exit;      
    }

    /* ui32InterTaskIoBufferAddress is allocated(in BRAP_P_OpenDecPath()) from RBUF pool */
    
    for (uiStgIp=0; uiStgIp<BRAP_P_MAX_FW_STG_INPUTS; uiStgIp++)
    {    
        hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp] = (uint32_t)BRAP_P_AllocAligned(hRap, BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE,2, 0);    /* 32 bit aligned*/    
        if((void *) BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp])
        {
            BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for IO Gen Buffer!"));
            ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
            goto exit;
        }
        BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32InterTaskIoGenericBufferAddress[uiStgIp]), 0, BRAP_AF_P_INTERTASK_IOGENBUFFER_SIZE );    
    }

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress = (uint32_t)BRAP_P_AllocAligned(hRap, (BRAP_AF_P_INTERTASK_FEEDBACK_BUFFER_SIZE + 4) ,2, 0);    /* 32 bit aligned*/
    if((void *) BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for Feedback  Buffer !"));
        ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
        goto exit;
    }
    BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32FeedbackBufferAddress), 0, (BRAP_AF_P_INTERTASK_FEEDBACK_BUFFER_SIZE + 4));

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress = (uint32_t)BRAP_P_AllocAligned(hRap, sizeof(BRAP_AF_P_sTASK_CONFIG) ,2, 0);    /* 32 bit aligned*/
    if( (void *)BRAP_P_INVALID_DRAM_ADDRESS == (void *)hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress)
    {
        BDBG_ERR(("BRAP_P_CreateMultiStreamDecoderObject: Unable to Allocate memory for Reconfigured CIT output !"));
        ret = BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
        goto exit;
    }
    BKNI_Memset((void *)(hRap->sMultiStreamDecoderObjs[uiMsObjIndex].ui32ReconfiguredCITAddress), 0, sizeof(BRAP_AF_P_sTASK_CONFIG));

    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].hRap = hRap;
    hRap->sMultiStreamDecoderObjs[uiMsObjIndex].bAvailable = false;
    
    *phMultiStreamDecoder = &(hRap->sMultiStreamDecoderObjs[uiMsObjIndex]);

exit:
    BDBG_LEAVE(BRAP_P_CreateMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Destroys Multi Stream Decoder object.
Description:
    This function destroys Multi Stream Decoder object. 
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_GetMultiStreamDecoderObject    
**************************************************************************/
BERR_Code BRAP_P_DestroyMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder
    )
{
    BERR_Code ret  = BERR_SUCCESS;
    unsigned int uiStgIp=0, k=0;

    BDBG_ENTER(BRAP_P_DestroyMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);

    hMultiStreamDecoder->sExtMultiStreamDecoderDetails.uiNumSecondaryChannel = 0;
    hMultiStreamDecoder->sExtMultiStreamDecoderDetails.hPrimaryChannel = NULL;

    for (k=0; k<BRAP_MAX_SEC_CHANNEL_FOR_MS_DECODER; k++)
    {     
        hMultiStreamDecoder->sExtMultiStreamDecoderDetails.hSecondaryChannel[k] = NULL;
    }
    
    if((uint32_t)NULL != hMultiStreamDecoder->ui32ReconfiguredCITAddress)
    {
        BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32ReconfiguredCITAddress);    
    }
    hMultiStreamDecoder->ui32ReconfiguredCITAddress = (uint32_t)NULL;
    
    if((uint32_t)NULL != hMultiStreamDecoder->ui32FeedbackBufferAddress)
    {
        BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32FeedbackBufferAddress);
    }
    hMultiStreamDecoder->ui32FeedbackBufferAddress = (uint32_t)NULL;
    
    for (uiStgIp=0; uiStgIp<BRAP_P_MAX_FW_STG_INPUTS; uiStgIp++)
    {
        if((uint32_t)NULL != hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp])
        {
            BRAP_P_Free (hMultiStreamDecoder->hRap, (void*)hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp]);
        }
        hMultiStreamDecoder->ui32InterTaskIoGenericBufferAddress[uiStgIp] = (uint32_t)NULL;
    }

    hMultiStreamDecoder->hRap = NULL;
    hMultiStreamDecoder->bAvailable = true;
   
    BDBG_LEAVE(BRAP_P_DestroyMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Sets the Multi Stream Decoder Object
Description:
    This function sets the Multi Stream Decoder Object. 
    
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_GetMultiStreamDecoderObject
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_DestroyMultiStreamDecoderObject
**************************************************************************/
BERR_Code BRAP_P_SetMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder,     /* [in] Audio Desc handle */ 
    BRAP_P_MultiStreamDecoderparams *psParams /* [in] Audio Desc Params */
    )
{
    BERR_Code ret  = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_SetMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);
    BDBG_ASSERT (psParams);

    hMultiStreamDecoder->sExtMultiStreamDecoderDetails= (*psParams);
  
    BDBG_LEAVE(BRAP_P_SetMultiStreamDecoderObject);
    return ret;
}


/***************************************************************************
Summary:
    Gets the Multi Stream Decoder Object
Description:
    This function gets the Multi Stream Decoder Object. 
    
Returns:
    BERR_SUCCESS on success
    Error code on failure
See Also:
    BRAP_P_SetMultiStreamDecoderObject
    BRAP_P_CreateMultiStreamDecoderObject
    BRAP_P_DestroyMultiStreamDecoderObject

**************************************************************************/
BERR_Code BRAP_P_GetMultiStreamDecoderObject(
    BRAP_MultiStreamDecoderHandle hMultiStreamDecoder,     /* [in] Audio Desc handle */ 
    BRAP_P_MultiStreamDecoderparams *psParams  /* [out] Audio Desc Params */
    )
{
    BERR_Code ret  = BERR_SUCCESS;

    BDBG_ENTER(BRAP_P_GetMultiStreamDecoderObject);

    /* Validate input params */
    BDBG_ASSERT (hMultiStreamDecoder);
    BDBG_ASSERT (psParams);

    if (false == hMultiStreamDecoder->bAvailable)
    {
        /* This hMultiStreamDecoder has been allocated and in use */
        (*psParams) = hMultiStreamDecoder->sExtMultiStreamDecoderDetails;
    }
    else
    {
        /* This hMultiStreamDecoder has been already destroyed */
        return BERR_TRACE(BERR_INVALID_PARAMETER);
    }
  
    BDBG_LEAVE(BRAP_P_GetMultiStreamDecoderObject);
    return ret;
}

bool    BRAP_P_IsPPPresent(
    BRAP_ChannelHandle  hRapCh,
    bool                bAssociationNw,	    
    BRAP_ProcessingType ePPType)
{
    unsigned int i =0 , j= 0;
    BDBG_ASSERT(hRapCh);

    if(bAssociationNw ==  false)
    {
        for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
        {
            for(j =0 ; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
            {        
                if(BRAP_P_IsPointerValid((void *)hRapCh->sChAudProcessingStage[i][j].hAudioProcessing))
                {
                    if(hRapCh->sChAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                    {
                        return true;
                    }
                }
            }
        }
    }
    else
    {
        unsigned int    uiAssocId=0;    
        for(uiAssocId = 0 ; uiAssocId < BRAP_MAX_ASSOCIATED_GROUPS ; uiAssocId++)
        {
            if((hRapCh->uiAssociationId[uiAssocId] == BRAP_INVALID_VALUE) ||
               (!(BRAP_P_IsPointerValid((void *)hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].hMultiStreamDecoder))))
                continue;
            for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
            {        
                for(j =0 ; j < BRAP_MAX_PP_PER_BRANCH_SUPPORTED; j++)
                {        
                    if(BRAP_P_IsPointerValid((void *)hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].
                        sAudProcessingStage[i][j].hAudioProcessing))
                    {
                        if(hRapCh->hRap->sAssociatedCh[hRapCh->uiAssociationId[uiAssocId]].sAudProcessingStage[i][j].
                            hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                        {
                            return true;
                        }
                    }
                }
            }
        }    
    }
    return false;
}

bool    BRAP_P_IsPPPresentOnOutput(
    BRAP_ChannelHandle  hRapCh,
    BRAP_ProcessingType ePPType,
    BRAP_OutputPort    eOpType)
{
    unsigned int i =0 , j= 0;
    BDBG_ASSERT(hRapCh);

    for(i = 0 ; i < BRAP_P_MAX_DST_PER_RAPCH ; i++)
    {
        for(j =0 ; j < BRAP_MAX_STAGE_PER_BRANCH_SUPPORTED; j++)
        {        
            if(hRapCh->sChAudProcessingStage[i][j].hAudioProcessing != NULL)
            {
                if((hRapCh->sChAudProcessingStage[i][j].hAudioProcessing->sProcessingStageSettings.eAudioProcessing == ePPType)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle != NULL)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle->sExtDstDetails.eAudioDst == BRAP_AudioDst_eOutputPort)
                    &&(hRapCh->sChAudProcessingStage[i][j].hValidDestHandle->sExtDstDetails.uDstDetails.sOpDetails.eOutput[0]== eOpType))
                {
                    return true;
                }
            }
        }
    }
    return false;
}


bool BRAP_P_IsMs11UsageMode(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);

    if(      
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eDDRE) == true)
       ||(BRAP_P_IsPPPresent(hRapCh,false,BRAP_ProcessingType_eDDRE) == true))
        return true;
    else
    return false;
}


bool BRAP_P_IsMs10UsageMode(
    BRAP_ChannelHandle  hRapCh)
{

    BDBG_ASSERT(hRapCh);
    
    if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder)) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eFwMixer) == true) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eDDRE) == false))
        return true;
    else
        return false;
}

bool BRAP_P_IsMultiStreamDecodeUsageMode(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);
    
    return ( BRAP_P_IsMs10UsageMode(hRapCh) || BRAP_P_IsMs11UsageMode(hRapCh) );
}

bool BRAP_P_IsFwMixingPostLoopbackEnabled(
    BRAP_ChannelHandle  hRapCh)
{
    BDBG_ASSERT(hRapCh);
    
    if((BRAP_P_IsPointerValid((void *)hRapCh->hMultiStreamDecoder)) &&
       (BRAP_P_IsPPPresent(hRapCh,true,BRAP_ProcessingType_eFwMixer) == true))
        return true;
    else
        return false;
}


BERR_Code BRAP_P_EnableAdaptiveRate(
	BRAP_ChannelHandle 			hRapCh,		    /* [in] RAP Channel handle */
	bool                *bAdaptiveRateEnable,
	bool                bPPMCorrection
    )
{
    unsigned int i=0;
    bool bCompress = false;

    BDBG_ENTER(BRAP_P_EnableAdaptiveRate);
    
    if(hRapCh->eChannelType == BRAP_ChannelType_eDecode)
    {
        *bAdaptiveRateEnable =bPPMCorrection;    
        for(i =0 ; i< BRAP_P_MAX_PATHS_IN_A_CHAN; i++)
        {
            if(hRapCh->pPath[i] != NULL)
            {
                bCompress =false;
                BRAP_P_IsPathOutputCompress(hRapCh,i,&bCompress);
                if(bCompress == true)
                {
                    break;
                }
            }
        } 

        if((bCompress == true) ||
           (BRAP_P_IsMs10UsageMode(hRapCh)))
        {
            *bAdaptiveRateEnable = false;
        }
    }
    else
    {
        *bAdaptiveRateEnable = false;
    }

    BDBG_LEAVE(BRAP_P_EnableAdaptiveRate);
    return BERR_SUCCESS;
}

/* Return whether Association Network(PP) is valid */
bool BRAP_P_IsAssociationNWValid(
    BRAP_P_DstDetails   *pPvtDstDetails)
{
    BDBG_ASSERT(pPvtDstDetails);

    /* BRAP_P_MAX_RAPCH_PER_DST + 1 th entry of psProcessingSettings has 
       the Association Network details of the destination */
    if((BRAP_P_IsPointerValid((void *) pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST])) &&
       (BRAP_P_IsPointerValid((void *) pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->
                                sExternalSettings.hAudProcessing[0])))
        return true;
    else
        return false;
}

BERR_Code BRAP_P_IsFMMPathAllocated(
	BRAP_ChannelHandle      hRapCh,             /* [in] RAP Channel handle */
	unsigned int            uiPth,
	bool                    *bFMMPathAllocated  /* [Out] FMM Path not required/allocated */
    )
{
    BERR_Code       ret = BERR_SUCCESS;
    unsigned int    uiAssocId=0;
    BRAP_P_DstDetails   *pPvtDstDetails = NULL;
    
    BDBG_ASSERT(hRapCh);

	pPvtDstDetails = hRapCh->hRap->sOpenTimeMallocs.pPvtDstDetails;
	if ( NULL==pPvtDstDetails )
	{
	    ret = BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        return ret;                                
	}
    BKNI_Memset(pPvtDstDetails, 0, sizeof(BRAP_P_DstDetails));
    
    if((BRAP_ChannelType_eDecode == hRapCh->eChannelType) &&
       (BRAP_INVALID_VALUE != hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx) &&
       (BRAP_P_IsPointerValid((void *)hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx])) &&
       ((BRAP_P_UsgPath_eDecodePcmPostMixing == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath)||
        (BRAP_P_UsgPath_eDecodeCompressPostMixing == hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->eUsgPath)) &&
       (BRAP_P_IsPointerValid((void *)hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->pDstDetails[0])))
    {
        ret = BRAP_P_GetPvtDstDetails(hRapCh, 
                    hRapCh->pPath[hRapCh->pPath[uiPth]->sOutPathProp[0].uiPathIdx]->pDstDetails[0],
                    pPvtDstDetails,
                    &uiAssocId);
        if(BERR_SUCCESS!=ret)
        {
            ret = BERR_TRACE(ret);
            return ret;
        }
        if(BRAP_ProcessingType_eFwMixer == 
            pPvtDstDetails->psProcessingSettings[BRAP_P_MAX_RAPCH_PER_DST]->
            sExternalSettings.hAudProcessing[0]->sProcessingStageSettings.eAudioProcessing)
        {
            *bFMMPathAllocated = false;
        }
    }
    else
        *bFMMPathAllocated = true;

    return ret;
}

/***************************************************************************
Description: Refer to Prototype
****************************************************************************/
bool BRAP_P_DspToConfigureOutputClock(
    BRAP_ChannelHandle  hRapCh,         /* [in] RAP Channel handle */
    BRAP_DstDetails     *pDstDetails    /* [in] Pointer to Destination details */
    )
{
    unsigned int uiAssocId=0, uiDstIndex=0;
    BDBG_ASSERT(hRapCh);
    BDBG_ASSERT(hRapCh->hRap);

    for(uiAssocId=0; uiAssocId<BRAP_MAX_ASSOCIATED_GROUPS; uiAssocId++)
    {
        for(uiDstIndex=0; uiDstIndex<BRAP_P_MAX_DST_PER_RAPCH; uiDstIndex++)
        {
            /* Compare if structure values are same */
            if( !(BKNI_Memcmp(pDstDetails, &(hRapCh->hRap->sAssociatedCh[uiAssocId].sDstDetails[uiDstIndex].sExtDstDetails), sizeof(pDstDetails))))                
            {
                return (BRAP_P_SECONDARY_CHANNEL_SRC(hRapCh,uiAssocId) ? false:true);
            }
        }
    }
    BDBG_WRN(("Did not find specified Destination details in any of the Associations"));
    return true;
}

