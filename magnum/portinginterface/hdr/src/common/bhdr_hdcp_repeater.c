/***************************************************************************
 *     Copyright (c) 2003-2013, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: $
 * $brcm_Revision: $
 * $brcm_Date: $
 *
 * $brcm_Log: $
 *
 ***************************************************************************/

#if BDBG_DEBUG_BUILD
#if defined LINUX && !defined __KERNEL__
#include "ctype.h"
#endif
#endif

#include "bchp_dvp_hr.h"

#include "bhdr.h"
#include "bhdr_priv.h"



BDBG_MODULE(BHDR_HDCP_REPEATER) ;

/******************************************************************************
Summary:
I2C Rx HDCP Registers
*******************************************************************************/

/* Rx Bksv value (Read Only) */
#define BHDR_HDCP_RX_BKSV0			0x00
#define BHDR_HDCP_RX_BKSV1			0x01
#define BHDR_HDCP_RX_BKSV2			0x02
#define BHDR_HDCP_RX_BKSV3			0x03
#define BHDR_HDCP_RX_BKSV4			0x04


/* Rx Link verification values (Read Only) */
#define BHDR_HDCP_RX_RI0		 0x08
#define BHDR_HDCP_RX_RI1		 0x09
#define BHDR_HDCP_RX_PJ             0x0A


/* Tx Aksv value (Write Only) */
#define BHDR_HDCP_RX_AKSV0			0x10
#define BHDR_HDCP_RX_AKSV1			0x11
#define BHDR_HDCP_RX_AKSV2			0x12
#define BHDR_HDCP_RX_AKSV3			0x13
#define BHDR_HDCP_RX_AKSV4			0x14


/*  Rx HDCP Enable HDCP 1.1 features (Write Only) */
#define BHDR_HDCP_RX_AINFO             0x15
#define BHDR_HDCP_RX_ENABLE_1_1_FEATURES 0x02


/* Session Random Number (An) value generated by the Tx (Write Only) */
#define BHDR_HDCP_RX_AN0			0x18
#define BHDR_HDCP_RX_AN1			0x19
#define BHDR_HDCP_RX_AN2			0x1a
#define BHDR_HDCP_RX_AN3			0x1b
#define BHDR_HDCP_RX_AN4			0x1c
#define BHDR_HDCP_RX_AN5			0x1d
#define BHDR_HDCP_RX_AN6			0x1e
#define BHDR_HDCP_RX_AN7			0x1f


/* HDCP Repeater Registers */

/* HDCP Repeater SHA-1 Hash value V' */
#define BHDR_HDCP_REPEATER_SHA1_V_H0 0x20
#define BHDR_HDCP_REPEATER_SHA1_V_H1 0x24
#define BHDR_HDCP_REPEATER_SHA1_V_H2 0x28
#define BHDR_HDCP_REPEATER_SHA1_V_H3 0x2c
#define BHDR_HDCP_REPEATER_SHA1_V_H4 0x30
#define BHDR_HDCP_REPEATER_KSV_FIFO 0x43 /* 2 Bytes */

#define BHDR_HDCP_REPEATER_MAX_DEVICE_COUNT 127
#define BHDR_HDCP_REPEATER_MAX_DEPTH 7


/* Rx Capabilities and Status Registers (Read Only) */
#define BHDR_HDCP_RX_BCAPS          0x40

#define BHDR_HDCP_RX_BSTATUS        0x41 /* 2 Bytes */
#define BDHM_HDCP_RX_BSTATUS_DEPTH        0x0700
#define BHDR_HDCP_RX_BSTATUS_DEVICE_COUNT 0x007F



/******************************************************************************
BERR_Code BHDR_HDCP_P_EnableRepeater
Summary: Enable the HDMI Rx Core as a Repeater
*******************************************************************************/
BERR_Code  BHDR_HDCP_P_EnableRepeater(BHDR_Handle hHDR)
{
   	BREG_Handle hRegister  ;
	uint32_t Register ;
	uint32_t ulOffset  ;
	uint16_t BStatus =0 ;

	BDBG_OBJECT_ASSERT(hHDR, BHDR_P_Handle) ;
	hRegister = hHDR->hRegister ;
	ulOffset = hHDR->ulOffset ;

	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_CONFIG + ulOffset) ;
	Register |= BCHP_MASK(HDMI_RX_0_HDCP_CONFIG, RDB_REPEATER) ;
	Register |= BCHP_MASK(HDMI_RX_0_HDCP_CONFIG, DISABLE_OTP_REPEATER) ;
	BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_CONFIG + ulOffset, Register) ;

	/* clear HDCP BStatus */
	BHDR_WriteRxI2cRegisterSpace(hHDR,  BAVC_HDMI_HDCP_RX_BSTATUS, (uint8_t *) &BStatus, 2) ;


	return BERR_SUCCESS ;
}



/******************************************************************************
Summary: Install Downstream Info
*******************************************************************************/
void BHDR_HDCP_LoadRepeaterKsvFifo(
	BHDR_Handle hHDR,
	BHDR_HDCP_RepeaterDownStreamInfo *pDownstreamInfo,
	uint8_t *pKsvs)
{
	BERR_Code rc ;
	BREG_Handle hRegister ;
	uint32_t Register ;
	uint32_t ulOffset ;
	uint32_t   BksvRegisterValue ;

	uint8_t i, j ;
	uint8_t
		Ksv[BAVC_HDMI_HDCP_KSV_LENGTH] ;
	uint16_t BStatus ;
#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	uint8_t BCaps ;
#endif
	uint8_t downstreamDevices, downstreamDepth;
	uint8_t *pUpdatedKsvs;

	BDBG_ENTER(BHDR_HDCP_LoadRepeaterKsvFifo) ;
	BDBG_OBJECT_ASSERT(hHDR, BHDR_P_Handle) ;

	BDBG_ASSERT(pDownstreamInfo) ;

	hRegister = hHDR->hRegister ;
	ulOffset = hHDR->ulOffset ;

	/* Update HDCP Rx BStatus */
	rc = BHDR_ReadRxI2cRegisterSpace(hHDR, BAVC_HDMI_HDCP_RX_BSTATUS,
		(uint8_t *) &BStatus, 2) ;
	if (rc) {BERR_TRACE(rc) ;}
#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BDBG_WRN(("Current BStatus: %x", BStatus)) ;
#endif

	/* add 1 to device count and depth if attached device is a repeater */
	downstreamDevices = pDownstreamInfo->devices + (uint8_t) pDownstreamInfo->isRepeater;
	downstreamDepth = pDownstreamInfo->depth + (uint8_t) pDownstreamInfo->isRepeater;

	BStatus &= ~ BAVC_HDMI_HDCP_RX_BSTATUS_DEPTH ;
	BStatus &= ~ BAVC_HDMI_HDCP_RX_BSTATUS_DEVICE_COUNT ;

	BStatus |= downstreamDepth << 8 ;
	BStatus |= downstreamDevices;

	if ((downstreamDevices > hHDR->stHdcpSettings.uiMaxDevices)
		|| pDownstreamInfo->maxDevicesExceeded)
	{
		BDBG_ERR(("Downstream Devices of %d exceeds max of %d",
			downstreamDevices, hHDR->stHdcpSettings.uiMaxDevices)) ;
		BStatus |= BAVC_HDMI_HDCP_RxStatus_eMaxDevicesExceeded;
	}

	if ((downstreamDepth > hHDR->stHdcpSettings.uiMaxLevels)
		|| pDownstreamInfo->maxDepthExceeded)
	{
		BDBG_ERR(("Downstream Depth Level of %d exceeds %d",
			downstreamDepth, hHDR->stHdcpSettings.uiMaxLevels)) ;
		BStatus |= BAVC_HDMI_HDCP_RxStatus_eMaxRepeatersExceeded ;
	}

#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BDBG_WRN(("Depth: %d Device Count: %d; Updated BStatus: %x",
		downstreamDepth, downstreamDevices, BStatus)) ;
#endif

	rc = BHDR_WriteRxI2cRegisterSpace(hHDR,  BAVC_HDMI_HDCP_RX_BSTATUS,
		(uint8_t *) &BStatus, 2) ;

	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_MON_RX_BSTATUS__BCAPS + ulOffset) ;
	BStatus = Register & 0x0000FFFF ;

#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	BCaps = (Register & 0x00FF0000) >> 16 ;
	BDBG_LOG(("HDCP_MON_RX_BSTATUS__BCAPS %#X", Register)) ;
	BDBG_LOG(("BCaps__BStatus Monitor BCaps: %#02X BStatus: %#04x",
		BCaps, BStatus)) ;
#endif

	/* copy KSV list */
	pUpdatedKsvs = (uint8_t *)
		BKNI_Malloc((pDownstreamInfo->devices + (uint8_t) pDownstreamInfo->isRepeater)
						* BAVC_HDMI_HDCP_KSV_LENGTH);
	BKNI_Memcpy(pUpdatedKsvs, pKsvs, (pDownstreamInfo->devices * BAVC_HDMI_HDCP_KSV_LENGTH));


	/* append repeater ksv to ksv list */
	if (pDownstreamInfo->isRepeater)
	{
		BKNI_Memcpy(pUpdatedKsvs + pDownstreamInfo->devices * BAVC_HDMI_HDCP_KSV_LENGTH,
			pDownstreamInfo->repeaterKsv, BAVC_HDMI_HDCP_KSV_LENGTH);
	}

	/* now load the downstream KSVs */
	for (i = 0 ; i < downstreamDevices; i++)
	{
		/* copy the next Ksv */
		for (j = 0 ; j < BAVC_HDMI_HDCP_KSV_LENGTH ; j++)
			Ksv[j] = *(pUpdatedKsvs+BAVC_HDMI_HDCP_KSV_LENGTH * i  + j)  ;


		/* write the 4 LSBs RxBksv to the transmitter... */
		BksvRegisterValue =
			  Ksv[0] | Ksv[1] <<  8 | Ksv[2] << 16 | Ksv[3] << 24 ;

#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
		BDBG_WRN(("Load KSV FIFO Device # %02d KSV: %02X %02X %02X %02X %02X",
			i+1, Ksv[4], Ksv[3], Ksv[2], 	Ksv[1], Ksv[0])) ;
#endif

		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_0 + ulOffset, BksvRegisterValue) ;


		/* write the 1 MSB RxBksv to the transmitter; also write KSV address ... */
		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register &= ~ (
				  BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV)
				| BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_ADDRESS)) ;

			Register |= (
				  BCHP_FIELD_DATA(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV, Ksv[4])
				| BCHP_FIELD_DATA(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_ADDRESS, i)) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;

		/* pulse to load the current downstream KSV  */
		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register |= BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_FIFO_LOAD) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;

		Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset) ;
			Register &= ~ BCHP_MASK(HDMI_RX_0_HDCP_KSV_FIFO_1, KSV_FIFO_LOAD) ;
		BREG_Write32(hRegister, BCHP_HDMI_RX_0_HDCP_KSV_FIFO_1 + ulOffset, Register) ;

		BKNI_Delay(1000);
	}


#if BHDR_CONFIG_DEBUG_HDCP_KEY_LOADING
	Register = BREG_Read32(hRegister, BCHP_HDMI_RX_0_HDCP_MON_RX_BSTATUS__BCAPS + ulOffset) ;
	BCaps = (Register & 0x00FF0000) >> 16 ;
	BStatus = Register & 0x0000FFFF ;


	BDBG_WRN(("HDCP_MON_RX_BSTATUS__BCAPS (Reg= %#08x): BCaps: %#02x BStatus: %#04x",
		Register, 	BCaps, BStatus)) ;
	BDBG_WRN(("")) ;
	BDBG_WRN(("")) ;
#endif

	hHDR->stHdcpStatus.eAuthState = BHDR_HDCP_AuthState_eKsvFifoReady ;


	BKNI_Free(pUpdatedKsvs);
	BDBG_LEAVE(BHDR_HDCP_LoadRepeaterKsvFifo) ;
}



