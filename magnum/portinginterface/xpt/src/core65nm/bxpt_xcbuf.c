/******************************************************************************
 * (c) 2003-2015 Broadcom Corporation
 *
 * This program is the proprietary software of Broadcom Corporation and/or its
 * licensors, and may only be used, duplicated, modified or distributed pursuant
 * to the terms and conditions of a separate, written license agreement executed
 * between you and Broadcom (an "Authorized License").  Except as set forth in
 * an Authorized License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and Broadcom
 * expressly reserves all rights in and to the Software and all intellectual
 * property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 *    constitutes the valuable trade secrets of Broadcom, and you shall use all
 *    reasonable efforts to protect the confidentiality thereof, and to use
 *    this information only in connection with your use of Broadcom integrated
 *    circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 *    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
 *    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
 *    TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
 *    WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
 *    PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
 *    ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME
 *    THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
 *    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
 *    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
 *    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
 *    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
 *    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER
 *    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
 *    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 *****************************************************************************/


#include "bstd.h"
#include "bxpt_priv.h"
#include "bxpt.h"
#include "bkni.h"
#include "bxpt_xcbuf.h"

#include "bchp_xpt_xcbuff.h"

BDBG_MODULE( xpt_xcbuf );

#ifdef SW7342_241_WORKAROUND
    #define INITIAL_BITRATE (30000000 * 2)
#else
    #define INITIAL_BITRATE 25000000
#endif

/* give PB XC enough BW and limit the BW through Plaback engine BO_COUNT mechanism */
#define BXPT_MAX_PLAYBACK_RATE  ( 108000000 )

static struct
{
    BXPT_XcBuf_Id Id;
    uint32_t BoRegAddr;
    uint32_t BufPtrRegAddr;
    unsigned long InitRate;
    unsigned long InitSize;     /* ToDo: Remove, since it's no longer used. */
    uint32_t EnableRegAddr;
    uint32_t EnableBitShift;
    uint32_t PauseBitShift;
}
const XcBuf[] =
{
#if ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7630 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 },

        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 },

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0},
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1},
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2},
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3},
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4},
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5},

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },

#elif ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RMX0_IBP6,  BCHP_XPT_XCBUFF_BO_RMX0_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 },
#if ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX0_PBP4,  BCHP_XPT_XCBUFF_BO_RMX0_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RMX0_PBP5,  BCHP_XPT_XCBUFF_BO_RMX0_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX0_PBP6,  BCHP_XPT_XCBUFF_BO_RMX0_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX0_PBP7,  BCHP_XPT_XCBUFF_BO_RMX0_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 31, 15 },
#endif
        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RMX1_IBP6,  BCHP_XPT_XCBUFF_BO_RMX1_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 },
#if ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX1_PBP4,  BCHP_XPT_XCBUFF_BO_RMX1_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RMX1_PBP5,  BCHP_XPT_XCBUFF_BO_RMX1_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX1_PBP6,  BCHP_XPT_XCBUFF_BO_RMX1_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX1_PBP7,  BCHP_XPT_XCBUFF_BO_RMX1_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 31, 15 },
#endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 },
#if ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_RAVE_PBP5,  BCHP_XPT_XCBUFF_BO_RAVE_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RAVE_PBP6,  BCHP_XPT_XCBUFF_BO_RAVE_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RAVE_PBP7,  BCHP_XPT_XCBUFF_BO_RAVE_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 31, 15 },
#endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
#if ( BCHP_CHIP == 7420 )
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
        { BXPT_XcBuf_Id_MSG_PBP5,   BCHP_XPT_XCBUFF_BO_MSG_PBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP5,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_MSG_PBP6,   BCHP_XPT_XCBUFF_BO_MSG_PBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP6,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_MSG_PBP7,   BCHP_XPT_XCBUFF_BO_MSG_PBP7,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP7,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 31, 15 },
#endif

#elif ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RMX0_IBP6,  BCHP_XPT_XCBUFF_BO_RMX0_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RMX0_PBP2,  BCHP_XPT_XCBUFF_BO_RMX0_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX0_PBP3,  BCHP_XPT_XCBUFF_BO_RMX0_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX0_PBP4,  BCHP_XPT_XCBUFF_BO_RMX0_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 28, 12 },
    #if ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_RMX0_PBP5,  BCHP_XPT_XCBUFF_BO_RMX0_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX0_PBP6,  BCHP_XPT_XCBUFF_BO_RMX0_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX0_PBP7,  BCHP_XPT_XCBUFF_BO_RMX0_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 31, 15 },
    #endif

        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RMX1_IBP6,  BCHP_XPT_XCBUFF_BO_RMX1_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RMX1_PBP2,  BCHP_XPT_XCBUFF_BO_RMX1_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RMX1_PBP3,  BCHP_XPT_XCBUFF_BO_RMX1_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RMX1_PBP4,  BCHP_XPT_XCBUFF_BO_RMX1_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 28, 12 },
    #if ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_RMX1_PBP5,  BCHP_XPT_XCBUFF_BO_RMX1_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RMX1_PBP6,  BCHP_XPT_XCBUFF_BO_RMX1_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RMX1_PBP7,  BCHP_XPT_XCBUFF_BO_RMX1_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 31, 15 },
    #endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 },
    #if ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_RAVE_PBP5,  BCHP_XPT_XCBUFF_BO_RAVE_PBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP5,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_RAVE_PBP6,  BCHP_XPT_XCBUFF_BO_RAVE_PBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP6,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_RAVE_PBP7,  BCHP_XPT_XCBUFF_BO_RAVE_PBP7,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP7,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 31, 15 },
    #endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 },

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
    #if ( BCHP_CHIP == 7342 )
        { BXPT_XcBuf_Id_MSG_PBP5,   BCHP_XPT_XCBUFF_BO_MSG_PBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP5,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 29, 13 },
        { BXPT_XcBuf_Id_MSG_PBP6,   BCHP_XPT_XCBUFF_BO_MSG_PBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP6,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 30, 14 },
        { BXPT_XcBuf_Id_MSG_PBP7,   BCHP_XPT_XCBUFF_BO_MSG_PBP7,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP7,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 31, 15 },
    #endif
#elif ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 )
        { BXPT_XcBuf_Id_RMX0_IBP0,  BCHP_XPT_XCBUFF_BO_RMX0_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX0_IBP1,  BCHP_XPT_XCBUFF_BO_RMX0_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX0_IBP2,  BCHP_XPT_XCBUFF_BO_RMX0_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX0_IBP3,  BCHP_XPT_XCBUFF_BO_RMX0_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX0_IBP4,  BCHP_XPT_XCBUFF_BO_RMX0_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX0_IBP5,  BCHP_XPT_XCBUFF_BO_RMX0_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_RMX0_PBP0,  BCHP_XPT_XCBUFF_BO_RMX0_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX0_PBP1,  BCHP_XPT_XCBUFF_BO_RMX0_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX0_CTRL, 25, 9 },

        { BXPT_XcBuf_Id_RMX1_IBP0,  BCHP_XPT_XCBUFF_BO_RMX1_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RMX1_IBP1,  BCHP_XPT_XCBUFF_BO_RMX1_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RMX1_IBP2,  BCHP_XPT_XCBUFF_BO_RMX1_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RMX1_IBP3,  BCHP_XPT_XCBUFF_BO_RMX1_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RMX1_IBP4,  BCHP_XPT_XCBUFF_BO_RMX1_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RMX1_IBP5,  BCHP_XPT_XCBUFF_BO_RMX1_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_RMX1_PBP0,  BCHP_XPT_XCBUFF_BO_RMX1_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RMX1_PBP1,  BCHP_XPT_XCBUFF_BO_RMX1_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RMX1_CTRL, 25, 9 },

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 },

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 },
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 },

        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
#else
    #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_RMX0_A,     BCHP_XPT_XCBUFF_BO_RMX0_A,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_A,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 1, 0 },
        { BXPT_XcBuf_Id_RMX0_B,     BCHP_XPT_XCBUFF_BO_RMX0_B,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX0_B,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX0_CTRL, 2, 0 },
    #endif

    #if ( BCHP_CHIP == 3563 )|| ( BCHP_CHIP == 7440 )
        /* These chips have only 1 remux. */
    #else
        /* Everybody else has 2 */
        { BXPT_XcBuf_Id_RMX1_A,     BCHP_XPT_XCBUFF_BO_RMX1_A,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_A,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 1, 0 },
        { BXPT_XcBuf_Id_RMX1_B,     BCHP_XPT_XCBUFF_BO_RMX1_B,     BCHP_XPT_XCBUFF_BASE_POINTER_RMX1_B,     INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RMX1_CTRL, 2, 0 },
    #endif

        { BXPT_XcBuf_Id_RAVE_IBP0,  BCHP_XPT_XCBUFF_BO_RAVE_IBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP0,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_RAVE_IBP1,  BCHP_XPT_XCBUFF_BO_RAVE_IBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP1,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_RAVE_IBP2,  BCHP_XPT_XCBUFF_BO_RAVE_IBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP2,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_RAVE_IBP3,  BCHP_XPT_XCBUFF_BO_RAVE_IBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP3,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_RAVE_IBP4,  BCHP_XPT_XCBUFF_BO_RAVE_IBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP4,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 20, 4 },

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* 7118 does not have IB5 or 6 */
    #else
        { BXPT_XcBuf_Id_RAVE_IBP5,  BCHP_XPT_XCBUFF_BO_RAVE_IBP5,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP5,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_RAVE_IBP6,  BCHP_XPT_XCBUFF_BO_RAVE_IBP6,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_IBP6,  INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_RAVE_CTRL, 22, 6 },
    #endif

    #if ( BCHP_CHIP == 3563 )
        /* 3563 has only PB0 */
        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
    #else
        { BXPT_XcBuf_Id_RAVE_PBP0,  BCHP_XPT_XCBUFF_BO_RAVE_PBP0,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP0,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_RAVE_PBP1,  BCHP_XPT_XCBUFF_BO_RAVE_PBP1,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP1,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 25, 9 },
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
        { BXPT_XcBuf_Id_RAVE_PBP2,  BCHP_XPT_XCBUFF_BO_RAVE_PBP2,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP2,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 26, 10 },
        #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_RAVE_PBP3,  BCHP_XPT_XCBUFF_BO_RAVE_PBP3,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP3,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 27, 11 },
        #endif
    #endif

    #if ( BCHP_CHIP == 7400 && BCHP_VER >= BCHP_VER_B0 ) || ( BCHP_CHIP == 7405 )
        { BXPT_XcBuf_Id_RAVE_PBP4,  BCHP_XPT_XCBUFF_BO_RAVE_PBP4,  BCHP_XPT_XCBUFF_BASE_POINTER_RAVE_PBP4,  INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_RAVE_CTRL, 28, 12 },
    #endif

        { BXPT_XcBuf_Id_MSG_IBP0,   BCHP_XPT_XCBUFF_BO_MSG_IBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP0,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 16, 0 },
        { BXPT_XcBuf_Id_MSG_IBP1,   BCHP_XPT_XCBUFF_BO_MSG_IBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP1,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 17, 1 },
        { BXPT_XcBuf_Id_MSG_IBP2,   BCHP_XPT_XCBUFF_BO_MSG_IBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP2,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 18, 2 },
        { BXPT_XcBuf_Id_MSG_IBP3,   BCHP_XPT_XCBUFF_BO_MSG_IBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP3,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 19, 3 },
        { BXPT_XcBuf_Id_MSG_IBP4,   BCHP_XPT_XCBUFF_BO_MSG_IBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP4,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 20, 4 },

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* 7118 doesn't have either IB5 or 6 */
    #else
        { BXPT_XcBuf_Id_MSG_IBP5,   BCHP_XPT_XCBUFF_BO_MSG_IBP5,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP5,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 21, 5 },
        { BXPT_XcBuf_Id_MSG_IBP6,   BCHP_XPT_XCBUFF_BO_MSG_IBP6,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_IBP6,   INITIAL_BITRATE, 200 * 1024, BCHP_XPT_XCBUFF_MSG_CTRL, 22, 6 },
    #endif

    #if ( BCHP_CHIP == 3563 )
        /* 3563 has only PB0 */
        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
    #else
        { BXPT_XcBuf_Id_MSG_PBP0,   BCHP_XPT_XCBUFF_BO_MSG_PBP0,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP0,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 24, 8 },
        { BXPT_XcBuf_Id_MSG_PBP1,   BCHP_XPT_XCBUFF_BO_MSG_PBP1,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP1,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 25, 9 },
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
        { BXPT_XcBuf_Id_MSG_PBP2,   BCHP_XPT_XCBUFF_BO_MSG_PBP2,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP2,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 26, 10 },
        #if ( BCHP_CHIP != 7440 )
        { BXPT_XcBuf_Id_MSG_PBP3,   BCHP_XPT_XCBUFF_BO_MSG_PBP3,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP3,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 27, 11 },
        #endif
    #endif

    #if ( BCHP_CHIP == 7400 && BCHP_VER >= BCHP_VER_B0 ) || ( BCHP_CHIP == 7405 )
        { BXPT_XcBuf_Id_MSG_PBP4,   BCHP_XPT_XCBUFF_BO_MSG_PBP4,   BCHP_XPT_XCBUFF_BASE_POINTER_MSG_PBP4,   INITIAL_BITRATE, 10 * 256, BCHP_XPT_XCBUFF_MSG_CTRL, 28, 12 },
    #endif
#endif
    { 0, 0, 0, 0, 0, 0, 0, 0 }      /* Last entry is a NULL. */
};

/* Number of buffers, which does NOT include the NULL entry at the end of the list */
#define NUM_BUFFERS (( sizeof( XcBuf ) / sizeof( XcBuf[ 0 ] )) - 1 )

#define MAX_BITRATE                 ( 108000000 )
#define BLOCKOUT_REG_STEPSIZE       4
#define BUFFER_PTR_REG_STEPSIZE     24

/* Threshold for pause generation when XC Buffer for a corresponding band is almost full */
#define DEFAULT_PACKET_PAUSE_LEVEL  ( 6 )

static BERR_Code AllocateBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    );

static BERR_Code DeleteBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    );

static BERR_Code EnableBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    );

static BERR_Code DisableBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    );

static BXPT_XcBuf_Id GetBufferId(
    BXPT_XcBuf_Id BaseId,
    unsigned WhichOne
    );

static BERR_Code SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    );

static BERR_Code SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO
    );

static int GetBufferIndex(
    BXPT_XcBuf_Id Id
    )
{
    if (Id >= BXPT_XcBuf_Id_END) {
        BDBG_ERR(( "Bad XcBuf ID" ));
        return -1;
    }

    return (int) Id;
}

BERR_Code BXPT_XcBuf_SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    )
{
#ifdef SW7342_241_WORKAROUND
    BSTD_UNUSED( hXpt );
    BSTD_UNUSED( Id );
    BSTD_UNUSED( Rate );
    BSTD_UNUSED( PacketLen );
    return BERR_SUCCESS;
#else
    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);
    hXpt->XcBufBO[ Id ] = BXPT_P_XcBuf_ComputeBlockOut( Rate, PacketLen );
    return SetBandDataRate( hXpt, Id, Rate, PacketLen );
#endif
}

static BERR_Code SetBandDataRate(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Rate,         /* [in] Max rate in bps */
    unsigned PacketLen          /* [in] size of mpeg packet */
    )
{
    uint32_t NewB0;

    BERR_Code ExitCode = BERR_SUCCESS;

    NewB0 = BXPT_P_XcBuf_ComputeBlockOut( Rate, PacketLen );             /* default set for mpeg */
    ExitCode = SetBlockout( hXpt, Id, NewB0 );

    return( ExitCode );
}


uint32_t BXPT_P_XcBuf_ComputeBlockOut(
    unsigned long PeakRate,         /* [in] Max data rate (in bps) the band will handle. */
    unsigned PacketLen             /* [in] Packet size ,130 for dss and 188 for mpeg */
    )
{
    uint32_t NewBO;

    NewBO = MAX_BITRATE / 1000000;
    PeakRate = PeakRate / 1000000;
    NewBO = (NewBO *PacketLen* 8) / PeakRate;
    return NewBO;
}

BERR_Code BXPT_XcBuf_SetBufferSize(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    )
{
    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    DisableBuffer( hXpt, Id );
    DeleteBuffer( hXpt, Id );
    AllocateBuffer( hXpt, Id, Size );
    EnableBuffer( hXpt, Id );

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Init(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    const BXPT_DramBufferCfg *Cfg
    )
{
    BXPT_XcBuf_Id Id;
    uint32_t Reg;
    unsigned ii;
    unsigned BufferSize;
    uint32_t InitialBlockOut;

    BERR_Code ExitCode = BERR_SUCCESS;
    unsigned long TotalXcMemory = 0;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

#if BDBG_DEBUG_BUILD
    /*
    ** We have to statically define BXPT_P_MAX_XC_BUFFERS in bxpt_priv.h since
    ** that file is included before the XcBuf struct is declared.
    */
    if( BXPT_P_MAX_XC_BUFFERS < NUM_BUFFERS )
    {
        BDBG_ERR(( "Number of XC Buffers used exceeds the max supported!!" ));
    }
#endif

    /* Default all buffers to disabled. */
    for( Id = 0; Id < NUM_BUFFERS; Id++ )
    {
        DisableBuffer( hXpt, Id );
    }

    InitialBlockOut = BXPT_P_XcBuf_ComputeBlockOut( BXPT_P_DEFAULT_PEAK_RATE, 188 );
    for( ii = 0; ii < BXPT_P_MAX_XC_BUFFERS; ii++ )
        hXpt->XcBufBO[ ii ] = InitialBlockOut;

    /* Set Pause to 6 packets */
    Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_PAUSE_THRESHOLD );
    Reg &= ~( BCHP_MASK( XPT_XCBUFF_PAUSE_THRESHOLD, PACKETS ) );
    Reg |= ( BCHP_FIELD_DATA( XPT_XCBUFF_PAUSE_THRESHOLD, PACKETS, DEFAULT_PACKET_PAUSE_LEVEL ) );
    BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_PAUSE_THRESHOLD, Reg );

#if ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7630 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP3; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP3; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }

#elif ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        #if ( BCHP_CHIP == 7420 )
        for( Id = BXPT_XcBuf_Id_RMX0_PBP2; Id <= BXPT_XcBuf_Id_RMX0_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
        #endif

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        #if ( BCHP_CHIP == 7420 )
        for( Id = BXPT_XcBuf_Id_RMX1_PBP2; Id <= BXPT_XcBuf_Id_RMX1_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
        #endif
    }

#elif ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP4; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP4; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }

#elif ( BCHP_CHIP == 7342 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP6; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP7; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }
#elif ( BCHP_CHIP == 7125 ) || ( BCHP_CHIP == 7340 )
    /* Remux architecture changed quite a bit on the these parts */
    {
        for( Id = BXPT_XcBuf_Id_RMX0_IBP0; Id <= BXPT_XcBuf_Id_RMX0_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );

#ifdef SW7342_241_WORKAROUND
            BXPT_P_XcBuf_Pause( hXpt, Id, false );
#endif

            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX0_PBP0; Id <= BXPT_XcBuf_Id_RMX0_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );

#ifdef SW7342_241_WORKAROUND
            BXPT_P_XcBuf_Pause( hXpt, Id, false );
#endif

            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_IBP0; Id <= BXPT_XcBuf_Id_RMX1_IBP5; Id++ )
        {
            /* PR 25771: Need a buffer of at least 256 bytes. */
            if( Cfg->RemuxXcCfg[ 0 ].BandAXcSize )
                BufferSize = Cfg->RemuxXcCfg[ 0 ].BandAXcSize * 1024;
            else
                BufferSize = 256;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }

        for( Id = BXPT_XcBuf_Id_RMX1_PBP0; Id <= BXPT_XcBuf_Id_RMX1_PBP1; Id++ )
        {
            /* Use 8k for remux data from playback. */
            BufferSize = 8 * 1024;

            SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
            AllocateBuffer( hXpt, Id, BufferSize );
            EnableBuffer( hXpt, Id );

            TotalXcMemory += BufferSize;
            BDBG_MSG(( "Enabling XC buffer for Remux ID %u", (unsigned) Id ));
        }
    }
#elif ( BCHP_CHIP == 7440 )
    /* On the 7440, we don't want the Message block to apply
       back-pressure to playback (ie, don't want graphics or
       advanced file data to throttle audio-video). */
    Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_MSG_CTRL );
    Reg &= ~( BCHP_MASK( XPT_XCBUFF_MSG_CTRL, PAUSE_EN_PBP ) );
    BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_MSG_CTRL, Reg );
#else
    for( ii = 0; ii < BXPT_P_MAX_REMULTIPLEXORS; ii++ )
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RemuxXcCfg[ ii ].BandAXcSize )
            BufferSize = Cfg->RemuxXcCfg[ ii ].BandAXcSize * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RMX0_A, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Remux %lu, Band A", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RemuxXcCfg[ ii ].BandBXcSize )
            BufferSize = Cfg->RemuxXcCfg[ ii ].BandBXcSize * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RMX0_B, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate,188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Remux %lu, Band B", ii ));
    }
#endif

    for( ii = 0; ii < BXPT_P_MAX_PID_PARSERS; ii++ )
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RaveXcCfg.IbParserXcSize[ ii ] )
            BufferSize = Cfg->RaveXcCfg.IbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RAVE_IBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate,188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Rave IB %lu", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->MesgBufXcCfg.IbParserXcSize[ ii ] )
            BufferSize = Cfg->MesgBufXcCfg.IbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_MSG_IBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Mesg filter IB %lu", ii ));
    }

#if ( BCHP_CHIP == 7342 )
    for( ii = 0; ii <= (BXPT_XcBuf_Id_RAVE_PBP7 - BXPT_XcBuf_Id_RAVE_PBP0); ii++ )
#else
    for( ii = 0; ii < BXPT_P_MAX_PLAYBACKS; ii++ )
#endif
    {
        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->RaveXcCfg.PbParserXcSize[ ii ] )
            BufferSize = Cfg->RaveXcCfg.PbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_RAVE_PBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Rave PB %lu", ii ));

        /* PR 25771: Need a buffer of at least 256 bytes. */
        if( Cfg->MesgBufXcCfg.PbParserXcSize[ ii ] )
            BufferSize = Cfg->MesgBufXcCfg.PbParserXcSize[ ii ] * 1024;
        else
            BufferSize = 256;

        Id = GetBufferId( BXPT_XcBuf_Id_MSG_PBP0, ii );
        SetBandDataRate( hXpt, Id, XcBuf[ Id ].InitRate, 188 );
        AllocateBuffer( hXpt, Id, BufferSize );
        EnableBuffer( hXpt, Id );

        TotalXcMemory += BufferSize;
        BDBG_MSG(( "Enabling XC buffer for Mesg filter PB %lu", ii ));
    }

    /* WORKAROUND. PR 22836: If PB0 support is enabled, PB1 support must be also. */
    /* NOTE: PR 22836 is covered by the workaround for PR 25771. */

    BDBG_MSG(( "Total XC memory usage is %lu bytes", TotalXcMemory ));

    /* Store the initial BlockOut values we've set above */
    for( ii = 0; ii < BXPT_P_MAX_PID_PARSERS; ii++ )
        hXpt->XcBufBO[ BXPT_XcBuf_Id_RAVE_IBP0 + ii ] = BXPT_P_XcBuf_GetBlockout( hXpt, BXPT_XcBuf_Id_RAVE_IBP0 + ii );

#ifdef SW7342_241_WORKAROUND
    #if (BCHP_CHIP == 7340) || (BCHP_CHIP == 7342)
    /* This bifield isn't supported on all devices. */
        Reg = BREG_Read32( hXpt->hRegister, BCHP_XPT_XCBUFF_NO_RD_HANG_CTRL );
        Reg |= (
        BCHP_FIELD_DATA( XPT_XCBUFF_NO_RD_HANG_CTRL, MSG_NO_RD_HANG_ON_WRONG_PKT_LEN, 1 ) |
        BCHP_FIELD_DATA( XPT_XCBUFF_NO_RD_HANG_CTRL, RAVE_NO_RD_HANG_ON_WRONG_PKT_LEN, 1 )
        );
        BREG_Write32( hXpt->hRegister, BCHP_XPT_XCBUFF_NO_RD_HANG_CTRL, Reg );
    #endif
#endif

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Shutdown(
    BXPT_Handle hXpt            /* [in] Handle for this transport */
    )
{
    BXPT_XcBuf_Id Id;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    for( Id = 0; Id < NUM_BUFFERS; Id++ )
        if( BXPT_P_XcBuf_IsBufferEnabled( hXpt, Id ) )
        {
            DisableBuffer( hXpt, Id );
            DeleteBuffer( hXpt, Id );
        }

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_Pause(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    bool Enable
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    if( Enable == true )
        EnReg |= ( 1ul << XcBuf[ Id ].PauseBitShift );
    else
        EnReg &= ~( 1ul << XcBuf[ Id ].PauseBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );

    return( ExitCode );
}

BERR_Code BXPT_P_XcBuf_RemuxPause(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    unsigned RemuxNum,          /* [in] Which client buffer we are dealing with */
    bool Enable
    )
{
    uint32_t EnReg, EnRegAddr;

    BERR_Code ExitCode = BERR_SUCCESS;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

#if ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 ) \
    || ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7342 )  || ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 ) || ( BCHP_CHIP == 7630 )
    switch( RemuxNum )
    {
        case 0:
        EnRegAddr = BCHP_XPT_XCBUFF_RMX0_CTRL;
        break;

        case 1:
        EnRegAddr = BCHP_XPT_XCBUFF_RMX1_CTRL;
        break;

        default:
        BDBG_ERR(( "Unsupported remux instance: %u", RemuxNum ));
        ExitCode = BERR_NOT_SUPPORTED;
        goto Done;
    }

    EnReg = BREG_Read32( hXpt->hRegister, EnRegAddr );
    if( Enable == true )
        EnReg |= 0x1F7F;
    else
        EnReg &= 0xFFFF0000;
    BREG_Write32( hXpt->hRegister, EnRegAddr, EnReg );
#else
    switch( RemuxNum )
    {
        case 0:
        EnRegAddr = BCHP_XPT_XCBUFF_RMX0_CTRL;
        break;

    #if ( BCHP_CHIP == 3563 )|| ( BCHP_CHIP == 7440 )
        /* These chips have only 1 remux. */
    #else
        case 1:
        EnRegAddr = BCHP_XPT_XCBUFF_RMX1_CTRL;
        break;
    #endif

        default:
        BDBG_ERR(( "Unsupported remux instance: %u", RemuxNum ));
        ExitCode = BERR_NOT_SUPPORTED;
        goto Done;
    }

    EnReg = BREG_Read32( hXpt->hRegister, EnRegAddr );
    if( Enable == true )
        EnReg |= 0x01;
    else
        EnReg &= 0xFFFFFFFE;
    BREG_Write32( hXpt->hRegister, EnRegAddr, EnReg );
#endif

    Done:
    return( ExitCode );
}

static BERR_Code DisableBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    EnReg &= ~( 1ul << XcBuf[ Id ].EnableBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );

    return( ExitCode );
}

static BERR_Code EnableBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    )
{
    uint32_t EnReg;

    BERR_Code ExitCode = BERR_SUCCESS;

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    EnReg |= ( 1ul << XcBuf[ Id ].EnableBitShift );
    BREG_Write32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr, EnReg );

    return( ExitCode );
}

static BERR_Code DeleteBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    )
{
    int index;

    index = GetBufferIndex( Id );
    BDBG_ASSERT(index >= 0);

    BMMA_UnlockOffset(hXpt->xcbuff[index].block, hXpt->xcbuff[index].offset);
    BMMA_Free(hXpt->xcbuff[index].block);

    return BERR_SUCCESS;
}

static BERR_Code AllocateBuffer(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long Size          /* [in] Size in bytes. Must be a multiple of 256. */
    )
{
    BMMA_Block_Handle block;
    uint32_t Offset, RegAddr;
    int index;

    /* If there is a secure heap defined, use it. */
    BMMA_Heap_Handle mmaHeap = hXpt->mmaRHeap ? hXpt->mmaRHeap : hXpt->mmaHeap;

    /* Size must be a multiple of 256. */
    Size = Size - ( Size % 256 );

    index = GetBufferIndex( Id );
    BDBG_ASSERT(index >= 0); /* this is internal, so do a hard assert */

    block = BMMA_Alloc(mmaHeap, Size, 256, 0);
    if (!block) {
        BDBG_ERR(("XC buffer alloc failed!"));
        return BERR_TRACE(BERR_OUT_OF_DEVICE_MEMORY);
    }
    Offset = BMMA_LockOffset(block);
    hXpt->xcbuff[index].block = block;
    hXpt->xcbuff[index].offset = Offset;

    RegAddr = XcBuf[ Id ].BufPtrRegAddr;
    BREG_Write32( hXpt->hRegister, RegAddr, Offset );                   /* Set BASE */
    BREG_Write32( hXpt->hRegister, RegAddr + 4, Offset + Size - 1 );    /* Set END */
    BREG_Write32( hXpt->hRegister, RegAddr + 8, Offset - 1 );           /* Set WRITE */
    BREG_Write32( hXpt->hRegister, RegAddr + 12, Offset - 1 );          /* Set VALID */
    BREG_Write32( hXpt->hRegister, RegAddr + 16, Offset - 1 );          /* Set READ */
    BREG_Write32( hXpt->hRegister, RegAddr + 20, 0 );                   /* Set WATERMARK */

    BDBG_MSG(( "Allocating for xc buf ID %u, base reg 0x%lX, DRAM addr 0x%lX", (unsigned) Id, (unsigned long) RegAddr, (unsigned long) Offset ));

    return BERR_SUCCESS;
}

static BXPT_XcBuf_Id GetBufferId(
    BXPT_XcBuf_Id BaseId,
    unsigned WhichOne
    )
{
    BXPT_XcBuf_Id BufferId = BaseId + WhichOne;

#if ( BCHP_CHIP == 7325 ) || ( BCHP_CHIP == 7335 ) || ( BCHP_CHIP == 7336  ) || ( BCHP_CHIP == 3548 ) || ( BCHP_CHIP == 3556 ) || ( BCHP_CHIP == 7420 ) \
    || ( BCHP_CHIP == 7635 ) || ( BCHP_CHIP == 7342 )  || ( BCHP_CHIP == 7125) || ( BCHP_CHIP == 7340 ) || ( BCHP_CHIP == 7630 )
    /* These chips follow the above rule. */
#else
        /* There are some exceptions to the above rule. */
        switch( BaseId )
        {
    #if ( BCHP_CHIP == 3563 ) || ( BCHP_CHIP == 7440 )
            /* 3563 has only 1 remux. */
    #else
            case BXPT_XcBuf_Id_RMX0_A:
            if( WhichOne )
                BufferId = BXPT_XcBuf_Id_RMX1_A;
            break;

            case BXPT_XcBuf_Id_RMX0_B:
            if( WhichOne )
                BufferId = BXPT_XcBuf_Id_RMX1_B;
            break;
    #endif

    #if ( BCHP_CHIP == 7118 ) || ( BCHP_CHIP == 3563 )
        /* Not in either of these chips */
    #else
            case BXPT_XcBuf_Id_RAVE_PBP0:
            if( WhichOne >= 2 )
                BufferId = BXPT_XcBuf_Id_RAVE_PBP2 + ( WhichOne - 2 );
            break;

            case BXPT_XcBuf_Id_MSG_PBP0:
            if( WhichOne >= 2 )
                BufferId = BXPT_XcBuf_Id_MSG_PBP2 + ( WhichOne - 2 );
            break;
    #endif

            default:
            break;
        }
#endif

    return BufferId;
}

bool BXPT_P_XcBuf_IsBufferEnabled(
    BXPT_Handle hXpt,
    BXPT_XcBuf_Id Id
    )
{
    uint32_t EnReg;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    EnReg = BREG_Read32( hXpt->hRegister, XcBuf[ Id ].EnableRegAddr );
    return EnReg & ( 1ul << XcBuf[ Id ].EnableBitShift ) ? true : false;
}

unsigned long BXPT_P_XcBuf_GetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id           /* [in] size of mpeg packet */
    )
{
    uint32_t Reg, RegAddr;

    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);

    RegAddr = XcBuf[ Id ].BoRegAddr;
    Reg = BREG_Read32( hXpt->hRegister, RegAddr );
    return( BCHP_GET_FIELD_DATA( Reg, XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT ) );
}

BERR_Code BXPT_P_XcBuf_SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO
    )
{
#ifdef SW7342_241_WORKAROUND
    BSTD_UNUSED( hXpt );
    BSTD_UNUSED( Id );
    BSTD_UNUSED( NewBO );
    return( BERR_SUCCESS );
#else
    BDBG_OBJECT_ASSERT(hXpt, bxpt_t);
    return SetBlockout( hXpt, Id, NewBO);
#endif
}

static BERR_Code SetBlockout(
    BXPT_Handle hXpt,           /* [in] Handle for this transport */
    BXPT_XcBuf_Id Id,           /* [in] Which client buffer we are dealing with */
    unsigned long NewBO
    )
{
    uint32_t Reg, RegAddr;

    BERR_Code ExitCode = BERR_SUCCESS;

    RegAddr = XcBuf[ Id ].BoRegAddr;
    Reg = BREG_Read32( hXpt->hRegister, RegAddr );
    Reg &= ~BCHP_MASK( XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT );
    Reg |= BCHP_FIELD_DATA( XPT_XCBUFF_BO_RAVE_IBP0, BO_COUNT, NewBO );
    BREG_Write32( hXpt->hRegister, RegAddr, Reg );

    return( ExitCode );
}
